---
type: code
status: in_progress
labels:
- feature
- worker_threads
- node-compat
- high-impact
target_files:
- src/js/node/worker_threads.ts
- src/bun.js/web_worker.zig
- src/bun.js/bindings/webcore/Worker.cpp
- src/bun.js/bindings/webcore/Worker.h
- test/js/node/worker_threads/worker_threads.test.ts
---
# feat: implement worker_threads stdout/stderr/resourceLimits options #10768

## Problem Description

When creating a `Worker` with `node:worker_threads`, the `stdout`, `stderr`, and `resourceLimits` options are not implemented. This blocks many popular libraries:

- **Jest/jest-worker** - Test runner parallelization
- **Terser/TerserPlugin** - Webpack minification
- **Next.js** - Build process
- **Vitest** - Test runner with threads pool
- **AVA** - Test runner
- **BullMQ** - Job queues
- **workerpool** - Worker pool library

**Current behavior:**
```javascript
const { Worker } = require('worker_threads');
const worker = new Worker('./worker.js', { stdout: true, stderr: true });

worker.stdout // returns null (should be ReadableStream)
worker.stderr // returns null (should be ReadableStream)
```

**Expected behavior (Node.js):**
- `stdout: true` → `worker.stdout` is a Readable stream capturing worker's stdout
- `stderr: true` → `worker.stderr` is a Readable stream capturing worker's stderr
- `stdout: false` (default) → Worker output pipes to parent's stdout automatically

## Architecture Analysis

### Current Implementation

1. **TypeScript Layer** (`worker_threads.ts`):
   - Lines 287-300: `stdin`, `stdout`, `stderr` getters return `null`
   - Worker wraps internal WebWorker

2. **C++ Layer** (`Worker.cpp`):
   - Message passing via `postTaskToWorkerGlobalScope()`
   - Event dispatch: `dispatchOnline()`, `dispatchError()`, `dispatchExit()`
   - No stdout/stderr infrastructure

3. **Zig Layer** (`web_worker.zig`):
   - `WebWorker` struct manages worker lifecycle
   - Worker VM inherits parent stdio
   - No pipe creation for stdout/stderr

### Existing Infrastructure We Can Leverage

1. **Subprocess Pipes** (`process.zig`):
   - `PosixSpawnOptions.Stdio` enum with `.pipe`, `.inherit`, `.ignore`
   - Socket pair creation for bidirectional pipes
   - Non-blocking I/O setup

2. **Readable Streams** (`subprocess/Readable.zig`):
   - `PipeReader` creates file poll objects
   - `toJS()` converts pipes to ReadableStream
   - Event loop integration

3. **Message Dispatch Pattern** (`Worker.cpp`):
   - `WebWorker__dispatchError()` routes data from worker to parent
   - Can create similar `WebWorker__dispatchStdout()` / `WebWorker__dispatchStderr()`

## Solution Approach

### Phase 1: Accept Options (TypeScript)

1. Parse `stdout`, `stderr`, `resourceLimits` options in Worker constructor
2. Pass options to native WebWorker creation
3. Store configuration for stream getters

### Phase 2: Create Pipes (Zig)

1. Add `stdout_pipe` and `stderr_pipe` fields to `WebWorker` struct
2. In `create()`, create socket pairs when options are set
3. Redirect worker's stdout/stderr FDs to pipe write ends
4. Register read ends with parent's event loop

### Phase 3: Wire Event Loop (Zig/C++)

1. Create `PipeReader` for stdout/stderr pipes
2. On data available, dispatch to parent thread
3. Add `WebWorker__dispatchStdout()` and `WebWorker__dispatchStderr()` in C++

### Phase 4: Expose as Streams (TypeScript)

1. Create ReadableStream wrappers for stdout/stderr
2. Return streams from getters instead of null
3. Handle cleanup on worker termination

### Phase 5: ResourceLimits (Future)

- `resourceLimits` affects V8 heap limits - may not be applicable to JSC
- Could implement as no-op with warning, or map to JSC equivalent

## Acceptance Criteria

- [x] `new Worker(file, { stdout: true })` does not throw NotImplementedError
- [x] `new Worker(file, { stderr: true })` does not throw NotImplementedError
- [ ] `worker.stdout` returns a Readable stream when `stdout: true`
- [ ] `worker.stderr` returns a Readable stream when `stderr: true`
- [ ] Worker's `console.log()` output appears in `worker.stdout` stream
- [ ] Worker's `console.error()` output appears in `worker.stderr` stream
- [ ] Default behavior (no options) still pipes to parent's stdout/stderr
- [x] `resourceLimits` option accepted (can be no-op with warning) - option is accepted
- [ ] Streams properly close when worker terminates
- [ ] Add comprehensive tests for stdout/stderr capture
- [x] Existing worker_threads tests still pass

## Implementation Notes

### Phase 1: Option Parsing (COMPLETED)
- ✅ Added `captureStdout` and `captureStderr` fields to `WorkerOptions` struct (`WorkerOptions.h`)
- ✅ Updated `JSWorker.cpp` constructor to parse `stdout` and `stderr` options from JavaScript
- ✅ Options are converted to boolean flags and stored in `WorkerOptions`
- ✅ Updated `Worker.cpp` to pass these flags through the call chain
- ✅ Extended `web_worker.zig` create() function signature to accept capture flags
- ✅ Extended `WebWorker` struct to store `capture_stdout` and `capture_stderr` fields
- ✅ Options flow correctly from JavaScript → C++ → Zig without errors

### Phase 2-4: Pipe Infrastructure (NOT YET COMPLETED)
The following components still need implementation:
1. **Pipe Creation** (`web_worker.zig`):
   - Create socket pairs or file descriptor pipes when `capture_stdout`/`capture_stderr` are true
   - Store pipe read/write file descriptors in `WebWorker` struct

2. **FD Redirection** (`web_worker.zig`):
   - Redirect worker's stdout/stderr file descriptors to the write ends of pipes
   - This may require changes in the worker VM initialization or process setup

3. **Event Loop Integration** (`web_worker.zig`):
   - Register pipe read ends with the parent event loop using existing `PipeReader` pattern
   - See `subprocess/SubprocessPipeReader.zig` for reference implementation

4. **Stream Dispatch** (C++ `Worker.cpp` + `web_worker.zig`):
   - Add `WebWorker__dispatchStdout()` and `WebWorker__dispatchStderr()` functions
   - Similar to existing `WebWorker__dispatchError()` pattern
   - Convert pipe data to ReadableStream JS objects

5. **TypeScript Layer** (`worker_threads.ts`):
   - Expose stdout/stderr as ReadableStream properties instead of null
   - Call native functions to get stream data when getter is accessed

### Reference Implementations
- Subprocess streams: `src/bun.js/api/bun/subprocess.zig`
- Readable enum: `src/bun.js/api/bun/subprocess/Readable.zig`
- PipeReader: `src/bun.js/api/bun/subprocess/SubprocessPipeReader.zig`

## Technical Notes

- GitHub Issue: https://github.com/oven-sh/bun/issues/10768
- Related: #10158, #9816, #4165
- Node.js docs: https://nodejs.org/api/worker_threads.html
- 28 comments, blocks Jest, Terser, Next.js, Vitest, AVA, BullMQ

## Test Plan

```javascript
const { Worker } = require('worker_threads');

// Test 1: stdout capture
const worker1 = new Worker(`
  console.log('hello from worker');
`, { eval: true, stdout: true });

let output = '';
worker1.stdout.on('data', (chunk) => { output += chunk; });
worker1.on('exit', () => {
  assert(output.includes('hello from worker'));
});

// Test 2: stderr capture
const worker2 = new Worker(`
  console.error('error from worker');
`, { eval: true, stderr: true });

let errOutput = '';
worker2.stderr.on('data', (chunk) => { errOutput += chunk; });
worker2.on('exit', () => {
  assert(errOutput.includes('error from worker'));
});

// Test 3: default behavior (no capture)
const worker3 = new Worker(`
  console.log('should appear in parent stdout');
`, { eval: true });
// Output should appear in parent's stdout directly
```

## Complexity Assessment

**High complexity** - This touches:
- TypeScript (options parsing, stream wrappers)
- C++ (event dispatch functions)
- Zig (pipe creation, FD redirection, event loop)
- Cross-thread communication
- Stream lifecycle management

Estimated scope: 300-500 lines across 4-5 files