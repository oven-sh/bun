---
type: task
status: completed
commits:
- c054dadda9
completed_at: 2026-01-30T13:27:06Z
---
# Research: mock.module fails to mock process.getBuiltinModule - GitHub #26591

## Problem

When using `mock.module()` to mock a Node.js built-in module like `node:os`, the mock works correctly for:
- `import { homedir } from "node:os"`
- `const { homedir } = await import("node:os")`

But fails for:
- `const { homedir } = globalThis.process.getBuiltinModule("node:os")`

The third approach returns the real module instead of the mocked one.

## Solution Approach

1. Find where `getBuiltinModule` is implemented (BunProcess.cpp calls `resolveAndFetchBuiltinModule`)
2. Find where `mock.module` intercepts module loading
3. Determine how to make `getBuiltinModule` also check for mocked modules
4. The fix likely involves checking `getMockedModule` before returning from `resolveAndFetchBuiltinModule`

## Acceptance Criteria

- [x] Understand how `resolveAndFetchBuiltinModule` works
- [x] Understand how `mock.module` stores and retrieves mocked modules
- [x] Identify the exact code path that needs modification
- [x] Document the proposed fix approach

## Detailed Research Findings

### 1. How `resolveAndFetchBuiltinModule` Works

**Location:** `src/bun.js/bindings/ModuleLoader.cpp:573-618`

The function is called from `BunProcess.cpp` when `process.getBuiltinModule(moduleName)` is invoked:

```cpp
JSValue resolveAndFetchBuiltinModule(
    Zig::GlobalObject* globalObject,
    BunString* specifier)
{
    void* bunVM = globalObject->bunVM();
    auto& vm = JSC::getVM(globalObject);
    auto scope = DECLARE_THROW_SCOPE(vm);
    ErrorableResolvedSource res;
    res.success = false;
    memset(&res.result, 0, sizeof res.result);
    if (Bun__resolveAndFetchBuiltinModule(bunVM, specifier, &res)) {
        // Returns the built-in module directly based on tag
        // Cases: BunObject, NodeModule, NodeProcess, ESM, InternalModuleRegistry
    }
    return {};
}
```

**Key point:** This function bypasses the mock system entirely. It directly resolves to built-in module objects without checking if they're mocked.

### 2. How `mock.module()` Stores and Retrieves Mocked Modules

**Storage Structure:**
- Located in: `src/bun.js/bindings/BunPlugin.h:18`
- Type: `VirtualModuleMap` = `WTF::UncheckedKeyHashMap<String, JSC::Strong<JSC::JSObject>>`
- Field: `BunPlugin::OnLoad::virtualModules` (a pointer to the map)

**Storage Function:**
- `BunPlugin::OnLoad::addModuleMock()` adds mocks to the map
- Called from `JSMock__jsModuleMock()` in `BunPlugin.cpp:498-701`

**Retrieval Function:**
- `Bun::runVirtualModule()` (declared in `BunPlugin.h:107`, defined in `BunPlugin.cpp:888-944`)
- Takes: `globalObject`, `specifier` (BunString*), and `wasModuleMock` (bool ref)
- Returns: JSValue if mock found, or fallback if not

**Signature:**
```cpp
JSC::JSValue runVirtualModule(Zig::GlobalObject*, BunString* specifier, bool& wasModuleMock);
```

### 3. Exact Code Path That Needs Modification

**Current flow for `process.getBuiltinModule("node:os")`:**
1. JavaScript: `process.getBuiltinModule("node:os")`
2. C++: `BunProcess.cpp:3891` → `Process_functionLoadBuiltinModule()`
3. C++: Calls `Bun::resolveAndFetchBuiltinModule(zigGlobalObject, &idStr)`
4. C++: `ModuleLoader.cpp:573` → Returns built-in module directly (SKIPS MOCK CHECK)
5. Result: Real `node:os` module is returned instead of mocked one

**Where normal imports check for mocks:**
- `ModuleLoader.cpp:670` and other locations
- They call `Bun::runVirtualModule(globalObject, &specifier, wasModuleMock)` BEFORE returning the real module
- This is done inside a condition: `if (isBunTest)` (line 669)

### 4. Proposed Fix Approach

**Option 1: Add mock check in `resolveAndFetchBuiltinModule`**
- Before returning any built-in module, check if it's been mocked
- Add call to `Bun::runVirtualModule()` at the beginning of `resolveAndFetchBuiltinModule()`
- If a mock is found, return it; otherwise continue with normal resolution
- File: `src/bun.js/bindings/ModuleLoader.cpp:573-618`

**Implementation outline:**
```cpp
JSValue resolveAndFetchBuiltinModule(
    Zig::GlobalObject* globalObject,
    BunString* specifier)
{
    // NEW: Check for mocked module first
    bool wasModuleMock = false;
    JSC::JSValue virtualModuleResult = Bun::runVirtualModule(globalObject, specifier, wasModuleMock);
    if (virtualModuleResult) {
        // Mock found, return it
        return virtualModuleResult;
    }

    // EXISTING: Normal built-in module resolution
    void* bunVM = globalObject->bunVM();
    // ... rest of function
}
```

**Why this works:**
- `runVirtualModule()` checks the `BunPlugin::OnLoad::virtualModules` map
- If the specifier is found in the mock map, it executes the callback and returns the mocked module
- If not found, it returns empty/falsy, and we continue to normal resolution
- This maintains backward compatibility while enabling mock support

**Context where mocking is enabled:**
- The mock system stores mocks in `globalObject->onLoadPlugins.virtualModules`
- Currently, mocks are checked during normal `require()` and `import()` calls (in test mode)
- Built-in modules loaded via `process.getBuiltinModule()` bypass this entirely

### Summary

The issue is that `process.getBuiltinModule()` directly calls `resolveAndFetchBuiltinModule()` which doesn't check the mock system. The fix is to add a single `runVirtualModule()` check at the beginning of `resolveAndFetchBuiltinModule()` before proceeding with normal built-in module resolution. This follows the same pattern used in other module resolution paths.

## Agent Output

2026-01-30T13:27:08Z

```
I'll start by examining the spec file and understanding the research requirements.
Now let me create a todo list to track this research task:
Let me search for where `getBuiltinModule` is implemented:
Let me search more broadly in C++ and Zig files:
Good! Now let me look at the BunProcess.cpp file:
Perfect! I found the function. Let me look for the `resolveAndFetchBuiltinModule` function definition:
Let me fix the find command:
Let me use the correct grep syntax:
Great! Let me read the ModuleLoader.h header file to understand the function signature:
Now let me look at the implementation in ModuleLoader.cpp:
Good! Now let me search for where `mock.module` is implemented. Let me search for "mock" in the codebase:
Let me search more broadly for "mock":
Let me use the Explore agent to search for mock module implementation more efficiently:
Excellent! Now I have a good understanding of the mock system. Let me update my todo and search for where built-in modules specifically get resolved, to understand why `getBuiltinModule` doesn't check the mock system:
Now let me look more closely at the `resolveAndFetchBuiltinModule` function to see the full implementation:
Good! Now let me look at where the mock checking should happen. Let me examine how regular imports check for mocks:
Perfect! Let me look at one of these usages to see the pattern:
Excellent! Now let me look at `runVirtualModule` to understand its signature and where it's declared:
Perfect! Now I have a clear understanding. Let me update my todo and document my findings:
Now let me update the spec file with my findings:
Now let me update the spec with detailed findings and check off the acceptance criteria:
Perfect! Now let me update my final todo and commit the research:
Now let me commit this research work:
Perfect! Let me verify the git status is clean:
Excellent! I've completed the research spec. Let me provide a summary of what I found:

## Research Complete ✓

I've thoroughly researched the issue where `mock.module()` fails to mock `process.getBuiltinModule()` in Bun. Here are the key findings:

### Problem Confirmed
- `mock.module()` successfully mocks modules loaded via `import` and `import()` 
- But it fails when modules are loaded via `process.getBuiltinModule()`
- The issue is that `getBuiltinModule` bypasses the mock system entirely

### Root Cause Identified
The call chain is:
1. `process.getBuiltinModule("node:os")` → `BunProcess.cpp:3891`
2. → `Bun::resolveAndFetchBuiltinModule()` → `ModuleLoader.cpp:573`
3. → Returns the real built-in module WITHOUT checking mocks

### Mock System Architecture
- Mocks are stored in a hash map: `BunPlugin::OnLoad::virtualModules`
- Type: `WTF::UncheckedKeyHashMap<String, JSC::Strong<JSC::JSObject>>`
- Retrieved via: `Bun::runVirtualModule(globalObject, specifier, wasModuleMock)`
- This function is already called in other module resolution paths but NOT in `resolveAndFetchBuiltinModule()`

### Proposed Solution
Add a mock check at the beginning of `resolveAndFetchBuiltinModule()` in `src/bun.js/bindings/ModuleLoader.cpp:573`:

```cpp
JSValue resolveAndFetchBuiltinModule(
    Zig::GlobalObject* globalObject,
    BunString* specifier)
{
    // NEW: Check for mocked module first
    bool wasModuleMock = false;
    JSC::JSValue virtualModuleResult = Bun::runVirtualModule(globalObject, specifier, wasModuleMock);
    if (virtualModuleResult) {
        return virtualModuleResult;
    }

    // EXISTING: Continue with normal built-in module resolution...
}
```

All acceptance criteria have been met and documented in the spec file at `.chant/specs/2026-01-30-001-vpz.md`. The research has been committed with the commit message properly referencing the spec ID.```
