---
type: task
status: in_progress
---
# Research: mock.module fails to mock process.getBuiltinModule - GitHub #26591

## Problem

When using `mock.module()` to mock a Node.js built-in module like `node:os`, the mock works correctly for:
- `import { homedir } from "node:os"`
- `const { homedir } = await import("node:os")`

But fails for:
- `const { homedir } = globalThis.process.getBuiltinModule("node:os")`

The third approach returns the real module instead of the mocked one.

## Solution Approach

1. Find where `getBuiltinModule` is implemented (BunProcess.cpp calls `resolveAndFetchBuiltinModule`)
2. Find where `mock.module` intercepts module loading
3. Determine how to make `getBuiltinModule` also check for mocked modules
4. The fix likely involves checking `getMockedModule` before returning from `resolveAndFetchBuiltinModule`

## Acceptance Criteria

- [x] Understand how `resolveAndFetchBuiltinModule` works
- [x] Understand how `mock.module` stores and retrieves mocked modules
- [x] Identify the exact code path that needs modification
- [x] Document the proposed fix approach

## Detailed Research Findings

### 1. How `resolveAndFetchBuiltinModule` Works

**Location:** `src/bun.js/bindings/ModuleLoader.cpp:573-618`

The function is called from `BunProcess.cpp` when `process.getBuiltinModule(moduleName)` is invoked:

```cpp
JSValue resolveAndFetchBuiltinModule(
    Zig::GlobalObject* globalObject,
    BunString* specifier)
{
    void* bunVM = globalObject->bunVM();
    auto& vm = JSC::getVM(globalObject);
    auto scope = DECLARE_THROW_SCOPE(vm);
    ErrorableResolvedSource res;
    res.success = false;
    memset(&res.result, 0, sizeof res.result);
    if (Bun__resolveAndFetchBuiltinModule(bunVM, specifier, &res)) {
        // Returns the built-in module directly based on tag
        // Cases: BunObject, NodeModule, NodeProcess, ESM, InternalModuleRegistry
    }
    return {};
}
```

**Key point:** This function bypasses the mock system entirely. It directly resolves to built-in module objects without checking if they're mocked.

### 2. How `mock.module()` Stores and Retrieves Mocked Modules

**Storage Structure:**
- Located in: `src/bun.js/bindings/BunPlugin.h:18`
- Type: `VirtualModuleMap` = `WTF::UncheckedKeyHashMap<String, JSC::Strong<JSC::JSObject>>`
- Field: `BunPlugin::OnLoad::virtualModules` (a pointer to the map)

**Storage Function:**
- `BunPlugin::OnLoad::addModuleMock()` adds mocks to the map
- Called from `JSMock__jsModuleMock()` in `BunPlugin.cpp:498-701`

**Retrieval Function:**
- `Bun::runVirtualModule()` (declared in `BunPlugin.h:107`, defined in `BunPlugin.cpp:888-944`)
- Takes: `globalObject`, `specifier` (BunString*), and `wasModuleMock` (bool ref)
- Returns: JSValue if mock found, or fallback if not

**Signature:**
```cpp
JSC::JSValue runVirtualModule(Zig::GlobalObject*, BunString* specifier, bool& wasModuleMock);
```

### 3. Exact Code Path That Needs Modification

**Current flow for `process.getBuiltinModule("node:os")`:**
1. JavaScript: `process.getBuiltinModule("node:os")`
2. C++: `BunProcess.cpp:3891` → `Process_functionLoadBuiltinModule()`
3. C++: Calls `Bun::resolveAndFetchBuiltinModule(zigGlobalObject, &idStr)`
4. C++: `ModuleLoader.cpp:573` → Returns built-in module directly (SKIPS MOCK CHECK)
5. Result: Real `node:os` module is returned instead of mocked one

**Where normal imports check for mocks:**
- `ModuleLoader.cpp:670` and other locations
- They call `Bun::runVirtualModule(globalObject, &specifier, wasModuleMock)` BEFORE returning the real module
- This is done inside a condition: `if (isBunTest)` (line 669)

### 4. Proposed Fix Approach

**Option 1: Add mock check in `resolveAndFetchBuiltinModule`**
- Before returning any built-in module, check if it's been mocked
- Add call to `Bun::runVirtualModule()` at the beginning of `resolveAndFetchBuiltinModule()`
- If a mock is found, return it; otherwise continue with normal resolution
- File: `src/bun.js/bindings/ModuleLoader.cpp:573-618`

**Implementation outline:**
```cpp
JSValue resolveAndFetchBuiltinModule(
    Zig::GlobalObject* globalObject,
    BunString* specifier)
{
    // NEW: Check for mocked module first
    bool wasModuleMock = false;
    JSC::JSValue virtualModuleResult = Bun::runVirtualModule(globalObject, specifier, wasModuleMock);
    if (virtualModuleResult) {
        // Mock found, return it
        return virtualModuleResult;
    }

    // EXISTING: Normal built-in module resolution
    void* bunVM = globalObject->bunVM();
    // ... rest of function
}
```

**Why this works:**
- `runVirtualModule()` checks the `BunPlugin::OnLoad::virtualModules` map
- If the specifier is found in the mock map, it executes the callback and returns the mocked module
- If not found, it returns empty/falsy, and we continue to normal resolution
- This maintains backward compatibility while enabling mock support

**Context where mocking is enabled:**
- The mock system stores mocks in `globalObject->onLoadPlugins.virtualModules`
- Currently, mocks are checked during normal `require()` and `import()` calls (in test mode)
- Built-in modules loaded via `process.getBuiltinModule()` bypass this entirely

### Summary

The issue is that `process.getBuiltinModule()` directly calls `resolveAndFetchBuiltinModule()` which doesn't check the mock system. The fix is to add a single `runVirtualModule()` check at the beginning of `resolveAndFetchBuiltinModule()` before proceeding with normal built-in module resolution. This follows the same pattern used in other module resolution paths.