# Yarn v2+ (Berry) Lockfile Format - Comprehensive Research

**Date**: October 2025  
**Purpose**: Research and planning for implementing Yarn Berry (v2+) lockfile migration to bun.lock

---

## Executive Summary

Yarn v2+ (Berry) uses a **completely different lockfile format** from v1. It's a breaking change requiring a separate implementation. Key differences:

1. **Valid YAML** (not YAML-like like v1)
2. **Protocol prefixes on ALL dependencies** (`npm:`, `workspace:`, `patch:`, etc.)
3. **Different integrity format** (`checksum: 10c0/hash` vs `integrity: sha512-hash`)
4. **Virtual packages** for peer dependency resolution
5. **First-class patch support** via `patch:` protocol
6. **Explicit `__metadata` section** for lockfile versioning

**Bottom line**: Cannot reuse v1 parser. Must implement from scratch using YAML library.

---

## 1. Format Overview

### 1.1 Version Detection

**Yarn v1:**

```
# yarn lockfile v1
# THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
```

**Yarn v2+ (Berry):**

```yaml
__metadata:
  version: 8
  cacheKey: 10c0
```

**Detection logic:**

```zig
if (strings.hasPrefixComptime(data, "# yarn lockfile v1")) {
    // v1 migration
} else if (strings.contains(data, "__metadata:")) {
    // v2+ Berry migration
} else {
    return error.YarnLockfileVersionUnknown;
}
```

### 1.2 File Format Comparison

| Feature          | Yarn v1                                            | Yarn Berry (v2+)                    |
| ---------------- | -------------------------------------------------- | ----------------------------------- |
| Format           | YAML-like (custom)                                 | Valid YAML                          |
| Parser           | Custom indentation-based                           | `bun.interchange.yaml.YAML`         |
| Protocols        | Implicit (only for special cases)                  | Explicit (always prefixed)          |
| Entry key        | `"pkg@^1.0.0, pkg@~1.0.0":`                        | `"pkg@npm:^1.0.0, pkg@npm:~1.0.0":` |
| Integrity        | `integrity: sha512-...`                            | `checksum: 10c0/...`                |
| Workspace marker | `version: 0.0.0-use.local` or `resolved: file:...` | `resolution: "pkg@workspace:."`     |
| Metadata         | None                                               | `__metadata:` section               |

---

## 2. Entry Structure

### 2.1 Basic Entry Format

```yaml
"package-name@protocol:range, package-name@protocol:range2":
  version: resolved-version
  resolution: "package-name@protocol:exact-reference"
  dependencies:
    dep1: "protocol:range"
    dep2: "protocol:range"
  peerDependencies:
    peer1: "*"
  dependenciesMeta:
    optional-dep:
      optional: true
  checksum: 10c0/sha512-base64...
  languageName: node
  linkType: hard
  bin:
    command: ./bin/cli.js
```

### 2.2 Field Descriptions

#### Required Fields

- **Key** (entry name): `"pkg@protocol:range, ..."` - Can be multi-spec
- **`version`**: Resolved exact version (e.g., `4.17.21`)
- **`resolution`**: Full package locator with protocol (e.g., `"lodash@npm:4.17.21"`)
- **`linkType`**: `hard` (real package) or `soft` (symlink/workspace)
- **`languageName`**: Usually `node` or `unknown`

#### Optional Fields

- **`dependencies`**: Object with dependency ranges (with protocols!)
- **`peerDependencies`**: Peer dependency ranges
- **`peerDependenciesMeta`**: Metadata about peer deps (optional, etc.)
- **`dependenciesMeta`**: Metadata about deps (optional, unplugged, etc.)
- **`checksum`**: Integrity hash in format `{cacheKey}/{base64-sha512}`
- **`bin`**: Binary commands (string or object)
- **`os`**: OS restrictions
- **`cpu`**: CPU/arch restrictions

---

## 3. Protocols Deep Dive

### 3.1 `npm:` - NPM Registry Packages

**Most common protocol.** All standard npm packages use this.

**Example:**

```yaml
"lodash@npm:^4.17.21":
  version: 4.17.21
  resolution: "lodash@npm:4.17.21"
  checksum: 10c0/eb835a2a4d5a152b4...
  languageName: node
  linkType: hard
```

**Migration to bun.lock:**

- Resolution: `npm` type with version `4.17.21`
- URL: Empty string (default registry)
- Integrity: Convert `checksum` to `sha512-...` format

### 3.2 `workspace:` - Workspace Packages

**Critical for monorepos.** References local packages.

**Examples:**

```yaml
# Root workspace
"my-app@workspace:.":
  version: 0.0.0-use.local
  resolution: "my-app@workspace:."
  dependencies:
    my-lib: "workspace:^"
  languageName: unknown
  linkType: soft

# Non-root workspace
"my-lib@workspace:packages/lib":
  version: 1.0.0
  resolution: "my-lib@workspace:packages/lib"
  dependencies:
    lodash: "npm:^4.17.21"
  languageName: unknown
  linkType: soft
```

**Special workspace ranges:**

- `workspace:*` - Any version
- `workspace:^` - Compatible version (published as real semver)
- `workspace:~` - Compatible version
- `workspace:.` - Root workspace (special case)
- `workspace:packages/name` - Relative path to workspace

**Migration to bun.lock:**

- Resolution: `workspace` type with path
- Key: Just package name (no namespace needed for workspaces)
- Dependencies: Resolve using workspace versions map

### 3.3 `patch:` - Patched Packages

**VERY IMPORTANT!** Berry's killer feature. Common in real-world usage.

**Example:**

```yaml
"left-pad@patch:left-pad@npm%3A1.3.0#~/.yarn/patches/left-pad-npm-1.3.0-abc123.patch::locator=my-app%40workspace%3A.":
  version: 1.3.0
  resolution: "left-pad@patch:left-pad@npm%3A1.3.0#~/.yarn/patches/left-pad-npm-1.3.0-abc123.patch::locator=my-app%40workspace%3A."
  dependencies:
    # patched dependencies (may differ from original!)
  checksum: 10c0/different-hash...
  languageName: node
  linkType: hard
```

**Format breakdown:**

```
patch:
  left-pad@npm%3A1.3.0          # Base package (URL-encoded)
  #~/.yarn/patches/...patch     # Patch file path
  ::locator=my-app%40workspace%3A.  # Parent requesting patch
```

**URL Encoding:**

- `@` → `%40`
- `:` → `%3A`
- `/` → `%2F`
- etc.

**Patch file location:**

- `.yarn/patches/` directory
- Standard unified diff format

**Migration strategy:**

1. **Option A - Full support:**
   - Read patch files from `.yarn/patches/`
   - Store in Bun's patch system
   - Create patched package entry
2. **Option B - Skip patches initially:**
   - Treat as base package (without patch)
   - Warn user that patches were not migrated
   - User can re-apply patches using Bun's patch system

**Recommended:** Option B for initial implementation, Option A for full support.

### 3.4 `portal:` - Portal Dependencies

**Like `link:` but with full dependency resolution.**

**Example:**

```yaml
"my-local-pkg@portal:../my-local-pkg":
  version: 0.0.0-use.local
  resolution: "my-local-pkg@portal:../my-local-pkg"
  dependencies:
    lodash: "npm:^4.17.21"
  languageName: unknown
  linkType: soft
```

**Key difference from `link:`:**

- `portal:` packages can have dependencies that are resolved
- `link:` packages are just symlinks, no dep resolution

**Migration to bun.lock:**

- Could map to `folder` resolution in Bun
- OR warn and skip (less common protocol)

### 3.5 `link:` - Symlinked Dependencies

**Direct symlinks without dependency resolution.**

**Example:**

```yaml
"my-linked@link:../my-linked":
  version: 0.0.0-use.local
  resolution: "my-linked@link:../my-linked"
  languageName: node
  linkType: soft
```

**Migration to bun.lock:**

- Map to `link` resolution type with path
- Note: Bun's link protocol has same semantics

### 3.6 `file:` - Local File Dependencies

**Tarballs or local directories.**

**Example:**

```yaml
"my-file-dep@file:../vendor/my-file-dep.tgz":
  version: 1.0.0
  resolution: "my-file-dep@file:../vendor/my-file-dep.tgz"
  checksum: 10c0/...
  languageName: node
  linkType: hard
```

**Migration to bun.lock:**

- If `.tgz` or `.tar.gz`: `local_tarball` resolution
- Otherwise: `folder` resolution

### 3.7 `git:` / `github:` / `gitlab:` - Git Dependencies

**Git-based dependencies.**

**Git protocol:**

```yaml
"my-git-dep@git://github.com/user/repo.git#commit-hash":
  version: 0.0.0-use.local
  resolution: "my-git-dep@git://github.com/user/repo.git#commit:commit-hash"
  checksum: 10c0/...
  languageName: node
  linkType: hard
```

**GitHub shorthand:**

```yaml
"my-pkg@github:user/repo#semver:^1.0.0":
  version: 1.2.3
  resolution: "my-pkg@github:user/repo#commit:abc123"
  checksum: 10c0/...
  languageName: node
  linkType: hard
```

**Resolution format:**

- `#commit:hash` - Specific commit
- `#semver:^1.0.0` - Semver tag (before resolution)
- After resolution, always `#commit:hash`

**Migration to bun.lock:**

- `git:` protocol: Map to `git` resolution
- `github:` shorthand: Map to `github` resolution
- Extract commit hash from resolution field

### 3.8 `exec:` - Executable Protocol

**Runs command to generate package. Rare.**

**Example:**

```yaml
"my-generated@exec:./scripts/generate-pkg.js":
  version: 0.0.0-use.local
  resolution: "my-generated@exec:./scripts/generate-pkg.js"
  languageName: node
  linkType: soft
```

**Migration strategy:**

- Skip with warning (very rare, Bun doesn't support)

### 3.9 `http:` / `https:` - Remote Tarballs

**Direct URL to tarball.**

**Example:**

```yaml
"remote-pkg@https://example.com/packages/pkg-1.0.0.tgz":
  version: 1.0.0
  resolution: "remote-pkg@https://example.com/packages/pkg-1.0.0.tgz"
  checksum: 10c0/...
  languageName: node
  linkType: hard
```

**Migration to bun.lock:**

- Map to `remote_tarball` resolution with URL

---

## 4. Virtual Packages

**Critical concept in Berry!** Used for peer dependency resolution.

### 4.1 What Are Virtual Packages?

When a package has peer dependencies, it may be instantiated multiple times with different peer dependency sets. Berry creates "virtual" package entries for each unique peer dep set.

### 4.2 Example

**Base package (with peer deps):**

```yaml
"@babel/plugin-transform-runtime@npm:^7.24.0":
  version: 7.24.0
  resolution: "@babel/plugin-transform-runtime@npm:7.24.0"
  peerDependencies:
    "@babel/core": "^7.0.0"
  checksum: 10c0/...
  languageName: node
  linkType: hard
```

**Virtual package (specific peer dep set):**

```yaml
"@babel/plugin-transform-runtime@virtual:abc123#npm:7.24.0":
  version: 7.24.0
  resolution: "@babel/plugin-transform-runtime@npm:7.24.0"
  dependencies:
    "@babel/core": "npm:7.24.0" # Resolved peer dep!
    # ... other resolved deps/peers
  peerDependencies:
    "@babel/core": "^7.0.0"
  peerDependenciesMeta:
    "@babel/core":
      optional: false
  checksum: 10c0/...
  languageName: node
  linkType: hard
```

### 4.3 Virtual Package Key Format

```
package-name@virtual:{hash}#protocol:version
```

- `{hash}`: Unique identifier for peer dep set (e.g., `abc123`)
- `#protocol:version`: Base protocol and version

### 4.4 Migration Strategy

**Complexity:** HIGH. Virtual packages are a Berry-specific optimization.

**Options:**

1. **Full virtual package support (complex):**
   - Parse virtual package entries
   - Create multiple package instances in bun.lock
   - Use namespaced keys to differentiate

2. **Flatten to base package (simpler):**
   - Use only the base package (non-virtual)
   - Let Bun's peer dep resolution handle it
   - May lose some precision but usually works

3. **Best approach:**
   - Detect virtual packages by `@virtual:` in key
   - For now, skip virtual entries and use base packages
   - Document that Berry's virtual package optimization is lost

**Recommended:** Option 3 for initial implementation. Virtual packages are an optimization, not a requirement.

---

## 5. Multi-Spec Entries

**Same as v1!** Multiple version ranges can resolve to same package.

**Example:**

```yaml
"react@npm:^18.0.0, react@npm:^18.2.0, react@npm:^18.3.0":
  version: 18.3.1
  resolution: "react@npm:18.3.1"
  dependencies:
    loose-envify: "npm:^1.1.0"
  checksum: 10c0/...
  languageName: node
  linkType: hard
```

**Parsing:**

1. Split entry key by `, ` (comma-space)
2. Each spec format: `"package@protocol:range"`
3. All specs map to same resolution

**Migration:**
Same as v1 - create one package, map all specs to it.

---

## 6. Metadata Section

### 6.1 `__metadata` Structure

```yaml
__metadata:
  version: 8 # Lockfile version
  cacheKey: 10c0 # Cache key for checksum format
```

**Current version:** 8 (as of 2025)

**Supported versions:** 6, 7, 8 (modern Berry)

**Older versions:** 5 and below might have different formats

### 6.2 Version History

- **v5**: Early Berry format
- **v6**: Introduced virtual packages
- **v7**: Checksums standardized
- **v8**: Current stable format

**Recommendation:** Only support v6+ initially, return error for older versions.

---

## 7. Dependency Fields

### 7.1 Regular Dependencies

**Always have protocol prefix!**

```yaml
dependencies:
  lodash: "npm:^4.17.21"
  my-workspace: "workspace:^"
  my-patch: "patch:pkg@npm%3A1.0.0#..."
```

### 7.2 Peer Dependencies

```yaml
peerDependencies:
  react: "npm:^18.0.0"
  "@babel/core": "*"
```

### 7.3 Dependencies Meta

```yaml
dependenciesMeta:
  optional-dep:
    optional: true
  fsevents:
    optional: true
  native-dep:
    unplugged: true
```

**Fields:**

- `optional`: Dependency is optional
- `unplugged`: Must be unplugged (extracted, not in zip)
- `built`: Has build step

---

## 8. Checksum Format

### 8.1 Berry Format

```yaml
checksum: 10c0/eb835a2a4d5a152b4...
```

**Format:** `{cacheKey}/{base64-sha512}`

- `cacheKey`: Matches `__metadata.cacheKey`
- Hash: Base64-encoded SHA-512

### 8.2 Conversion to Bun Format

**Bun uses:** `sha512-base64hash`

**Conversion:**

```zig
// Berry: "10c0/eb835a2a4d5a152b4..."
// Bun:   "sha512-eb835a2a4d5a152b4..."

const checksum_str = "10c0/eb835a2a4d5a152b4...";
const slash_idx = strings.indexOfChar(checksum_str, '/');
const hash = checksum_str[slash_idx + 1..];
const bun_integrity = try std.fmt.allocPrint(allocator, "sha512-{s}", .{hash});
```

---

## 9. Workspace Handling

### 9.1 Root Workspace

```yaml
"my-app@workspace:.":
  version: 0.0.0-use.local
  resolution: "my-app@workspace:."
  dependencies:
    react: "npm:^18.0.0"
    my-lib: "workspace:^"
  languageName: unknown
  linkType: soft
```

**Key points:**

- Always `workspace:.` for root
- `version: 0.0.0-use.local` is common
- `linkType: soft` always

### 9.2 Non-Root Workspaces

```yaml
"my-lib@workspace:packages/lib":
  version: 1.0.0
  resolution: "my-lib@workspace:packages/lib"
  dependencies:
    lodash: "npm:^4.17.21"
  languageName: unknown
  linkType: soft
```

**Key points:**

- Resolution includes relative path from root
- Actual version from workspace's package.json
- Can have regular dependencies

### 9.3 Workspace References

In dependencies:

```yaml
dependencies:
  my-lib: "workspace:^" # Published as ^1.0.0
  my-lib2: "workspace:~" # Published as ~1.0.0
  my-lib3: "workspace:*" # Published as *
```

**Protocol replacement:**
When published, `workspace:` is replaced with actual semver:

- `workspace:^` → `^1.0.0`
- `workspace:~` → `~1.0.0`
- `workspace:*` → `*`

---

## 10. Resolutions/Overrides

Berry supports selective dependency resolution via package.json `resolutions` field.

### 10.1 Package.json Configuration

```json
{
  "resolutions": {
    "package-name": "1.2.3",
    "**/nested-dep": "2.0.0",
    "package-a/**/deep-dep": "3.0.0"
  }
}
```

### 10.2 Effect on Lockfile

```yaml
"overridden-pkg@npm:^1.0.0":
  version: 2.0.0 # Override applied!
  resolution: "overridden-pkg@npm:2.0.0"
  checksum: 10c0/...
  languageName: node
  linkType: hard
```

### 10.3 Migration

Read `resolutions` from package.json and apply during migration.

---

## 11. Real-World Example

```yaml
__metadata:
  version: 8
  cacheKey: 10c0

"my-monorepo@workspace:.":
  version: 0.0.0-use.local
  resolution: "my-monorepo@workspace:."
  dependencies:
    react: "npm:^18.0.0"
    my-lib: "workspace:^"
  languageName: unknown
  linkType: soft

"my-lib@workspace:packages/lib":
  version: 1.0.0
  resolution: "my-lib@workspace:packages/lib"
  dependencies:
    lodash: "npm:^4.17.21"
  languageName: unknown
  linkType: soft

"lodash@npm:^4.17.21":
  version: 4.17.21
  resolution: "lodash@npm:4.17.21"
  checksum: 10c0/eb835a2a4d5a152b4...
  languageName: node
  linkType: hard

"react@npm:^18.0.0, react@npm:^18.2.0":
  version: 18.3.1
  resolution: "react@npm:18.3.1"
  dependencies:
    loose-envify: "npm:^1.1.0"
  checksum: 10c0/d52f3f0eb38cbae32a...
  languageName: node
  linkType: hard

"loose-envify@npm:^1.1.0":
  version: 1.4.0
  resolution: "loose-envify@npm:1.4.0"
  dependencies:
    js-tokens: "npm:^3.0.0 || ^4.0.0"
  bin:
    loose-envify: cli.js
  checksum: 10c0/6517e24e0cad87ec9...
  languageName: node
  linkType: hard

"js-tokens@npm:^3.0.0 || ^4.0.0":
  version: 4.0.0
  resolution: "js-tokens@npm:4.0.0"
  checksum: 10c0/...
  languageName: node
  linkType: hard
```

---

## 12. Migration Architecture

### 12.1 High-Level Phases

```zig
pub fn migrateYarnBerryLockfile(
    lockfile: *Lockfile,
    manager: *PackageManager,
    allocator: std.mem.Allocator,
    log: *logger.Log,
    data: []const u8,
    dir: bun.FD,
) MigrateYarnBerryError!LoadResult {
    // Phase 1: Parse YAML
    // Phase 2: Extract metadata & validate version
    // Phase 3: Build workspace map
    // Phase 4: Create packages (root + workspaces)
    // Phase 5: Create regular packages
    // Phase 6: Resolve dependencies
    // Phase 7: Finalize (fetch metadata, sort, validate)
}
```

### 12.2 Phase 1: Parse YAML

Use Bun's YAML parser:

```zig
const yaml_source = &logger.Source.initPathString("yarn.lock", data);
const yaml = bun.interchange.yaml.YAML.parse(allocator, yaml_source, log) catch {
    return error.YarnBerryParseError;
};
defer yaml.deinit();

const root = yaml.root;
if (root.data != .e_object) {
    return error.InvalidYarnBerryLockfile;
}
```

### 12.3 Phase 2: Extract Metadata

```zig
const metadata = root.data.e_object.get("__metadata") orelse {
    return error.MissingMetadata;
};

const version_expr = metadata.data.e_object.get("version") orelse {
    return error.MissingVersion;
};

const lockfile_version: u32 = switch (version_expr.data) {
    .e_number => @intFromFloat(version_expr.data.e_number.value),
    .e_string => std.fmt.parseInt(u32, version_expr.data.e_string.slice(allocator), 10) catch {
        return error.InvalidVersion;
    },
    else => return error.InvalidVersion,
};

if (lockfile_version < 6) {
    try log.addErrorFmt(null, logger.Loc.Empty, allocator,
        "Yarn Berry lockfile version {d} is too old. Please upgrade to v6+.",
        .{lockfile_version});
    return error.YarnBerryVersionTooOld;
}

const cache_key = if (metadata.data.e_object.get("cacheKey")) |ck|
    ck.asString(allocator)
else
    "10c0";
```

### 12.4 Phase 3: Build Workspace Map

Similar to v1, but using Berry's resolution format:

```zig
var workspace_map: bun.StringHashMap(WorkspaceInfo) = .init(allocator);

for (root.data.e_object.properties.slice()) |prop| {
    const key_str = prop.key.?.asString(allocator) orelse continue;

    // Skip __metadata
    if (strings.eqlComptime(key_str, "__metadata")) continue;

    const entry = prop.value.?.data.e_object;
    const resolution = entry.get("resolution").?.asString(allocator) orelse continue;

    // Check if workspace
    if (strings.hasPrefix(resolution, "\"") and strings.hasSuffix(resolution, "\"")) {
        const unquoted = resolution[1..resolution.len-1];

        // Parse: "pkg-name@workspace:path"
        const at_idx = strings.lastIndexOfChar(unquoted, '@');
        if (at_idx == null) continue;

        const pkg_name = unquoted[0..at_idx.?];
        const protocol_part = unquoted[at_idx.? + 1..];

        if (strings.hasPrefix(protocol_part, "workspace:")) {
            const ws_path = protocol_part["workspace:".len..];
            const version = entry.get("version").?.asString(allocator) orelse "0.0.0";

            try workspace_map.put(pkg_name, .{
                .path = ws_path,
                .version = version,
            });
        }
    }
}
```

### 12.5 Phase 4: Create Packages

**For each entry:**

```zig
for (root.data.e_object.properties.slice()) |prop| {
    const entry_key = prop.key.?.asString(allocator) orelse continue;
    if (strings.eqlComptime(entry_key, "__metadata")) continue;

    const entry_obj = prop.value.?.data.e_object;

    // Parse multi-spec key
    const specs = try parseMultiSpecKey(entry_key, allocator);
    defer specs.deinit();

    // Get resolution
    const resolution_str = entry_obj.get("resolution").?.asString(allocator) orelse {
        return error.MissingResolution;
    };

    // Unquote: "pkg@npm:1.0.0" -> pkg@npm:1.0.0
    const resolution = if (strings.hasPrefix(resolution_str, "\""))
        resolution_str[1..resolution_str.len-1]
    else
        resolution_str;

    // Parse resolution to determine type
    const res = try parseResolution(resolution, allocator, string_buf);

    // Skip virtual packages for now
    if (strings.contains(resolution, "@virtual:")) {
        continue;
    }

    // Skip workspace packages (handled separately)
    if (strings.hasPrefix(resolution, "workspace:") or
        strings.contains(resolution, "@workspace:")) {
        continue;
    }

    // Create package
    var pkg: Lockfile.Package = .{
        .name = ...,
        .resolution = res,
        .meta = .{
            .integrity = try parseChecksum(entry_obj, cache_key, allocator, string_buf),
        },
    };

    // Parse dependencies
    const deps_off, const deps_len = try parseDependencies(
        entry_obj, allocator, lockfile, string_buf, workspace_map
    );
    pkg.dependencies = .{ .off = deps_off, .len = deps_len };

    // Parse bin
    pkg.bin = try parseBin(entry_obj, string_buf);

    // Add package
    const pkg_id = try lockfile.appendPackageDedupe(&pkg, string_buf.bytes.items);

    // Map all specs to this package
    for (specs.items) |spec| {
        try pkg_map.put(spec, pkg_id);
    }
}
```

### 12.6 Protocol Parsing

```zig
fn parseResolution(
    resolution: []const u8,
    allocator: Allocator,
    string_buf: *StringBuf,
) !Resolution {
    // Format: "package-name@protocol:reference"

    const at_idx = strings.lastIndexOfChar(resolution, '@');
    if (at_idx == null) return error.InvalidResolution;

    const pkg_name = resolution[0..at_idx.?];
    const protocol_part = resolution[at_idx.? + 1..];

    // Check for protocol prefix
    if (strings.hasPrefix(protocol_part, "npm:")) {
        const version = protocol_part["npm:".len..];
        return .init(.{ .npm = .{
            .version = try Semver.parse(version, string_buf, allocator),
            .url = String.empty,
        }});
    } else if (strings.hasPrefix(protocol_part, "workspace:")) {
        const path = protocol_part["workspace:".len..];
        return .init(.{ .workspace = try string_buf.append(path) });
    } else if (strings.hasPrefix(protocol_part, "patch:")) {
        // For now, extract base package and skip patch
        // TODO: Full patch support
        // Example: "patch:pkg@npm%3A1.0.0#.yarn/patches/...::locator=..."

        // Extract base descriptor after "patch:"
        const patch_content = protocol_part["patch:".len..];
        const hash_idx = strings.indexOfChar(patch_content, '#');
        if (hash_idx == null) return error.InvalidPatchProtocol;

        const base_descriptor = patch_content[0..hash_idx.?];

        // URL decode and recursively parse
        const decoded = try urlDecode(base_descriptor, allocator);
        defer allocator.free(decoded);

        return parseResolution(decoded, allocator, string_buf);
    } else if (strings.hasPrefix(protocol_part, "link:")) {
        const path = protocol_part["link:".len..];
        return .init(.{ .folder = try string_buf.append(path) });
    } else if (strings.hasPrefix(protocol_part, "portal:")) {
        const path = protocol_part["portal:".len..];
        return .init(.{ .folder = try string_buf.append(path) });
    } else if (strings.hasPrefix(protocol_part, "file:")) {
        const path = protocol_part["file:".len..];
        if (strings.hasSuffix(path, ".tgz") or strings.hasSuffix(path, ".tar.gz")) {
            return .init(.{ .local_tarball = try string_buf.append(path) });
        } else {
            return .init(.{ .folder = try string_buf.append(path) });
        }
    } else if (strings.hasPrefix(protocol_part, "git://") or
               strings.hasPrefix(protocol_part, "git+https://") or
               strings.hasPrefix(protocol_part, "git+ssh://")) {
        // Git protocol
        const commit_idx = strings.lastIndexOf(protocol_part, "#commit:");
        if (commit_idx) |idx| {
            const repo = protocol_part[0..idx];
            const commit = protocol_part[idx + "#commit:".len..];
            return .init(.{ .git = .{
                .repo = try string_buf.append(repo),
                .committish = try string_buf.append(commit),
            }});
        }
        return .init(.{ .git = .{
            .repo = try string_buf.append(protocol_part),
            .committish = String.empty,
        }});
    } else if (strings.hasPrefix(protocol_part, "github:")) {
        // GitHub shorthand: "github:user/repo#commit:hash"
        const content = protocol_part["github:".len..];
        const commit_idx = strings.indexOfChar(content, '#');

        if (commit_idx) |idx| {
            const repo = content[0..idx];
            const commit_part = content[idx + 1..];

            if (strings.hasPrefix(commit_part, "commit:")) {
                const commit = commit_part["commit:".len..];
                return .init(.{ .github = .{
                    .owner = try extractGitHubOwner(repo, string_buf),
                    .repo = try extractGitHubRepo(repo, string_buf),
                    .committish = try string_buf.append(commit),
                }});
            }
        }

        return .init(.{ .github = .{
            .owner = try extractGitHubOwner(content, string_buf),
            .repo = try extractGitHubRepo(content, string_buf),
            .committish = String.empty,
        }});
    } else if (strings.hasPrefix(protocol_part, "https://") or
               strings.hasPrefix(protocol_part, "http://")) {
        // Remote tarball
        return .init(.{ .remote_tarball = try string_buf.append(protocol_part) });
    }

    // Unknown protocol or no protocol - shouldn't happen in Berry
    return error.UnknownProtocol;
}
```

### 12.7 Dependency Parsing

```zig
fn parseDependencies(
    entry_obj: JSAst.Expr.Object,
    allocator: Allocator,
    lockfile: *Lockfile,
    string_buf: *StringBuf,
    workspace_map: bun.StringHashMap(WorkspaceInfo),
) !struct { u32, u32 } {
    const deps_off: u32 = @intCast(lockfile.buffers.dependencies.items.len);

    const deps_obj = entry_obj.get("dependencies");
    const peer_deps_obj = entry_obj.get("peerDependencies");
    const optional_deps_obj = entry_obj.get("dependenciesMeta");

    var dep_count: u32 = 0;

    // Parse regular dependencies
    if (deps_obj) |deps| {
        if (deps.data == .e_object) {
            for (deps.data.e_object.properties.slice()) |dep_prop| {
                const dep_name = dep_prop.key.?.asString(allocator) orelse continue;
                const dep_range_raw = dep_prop.value.?.asString(allocator) orelse continue;

                // Unquote: "npm:^1.0.0" -> npm:^1.0.0
                const dep_range = if (strings.hasPrefix(dep_range_raw, "\""))
                    dep_range_raw[1..dep_range_raw.len-1]
                else
                    dep_range_raw;

                // Remove protocol prefix for version
                // "npm:^1.0.0" -> "^1.0.0"
                const colon_idx = strings.indexOfChar(dep_range, ':');
                const version_part = if (colon_idx) |idx|
                    dep_range[idx + 1..]
                else
                    dep_range;

                const dep = Dependency{
                    .name = try string_buf.appendWithHash(dep_name),
                    .version = try Dependency.Version.parse(
                        version_part,
                        string_buf,
                        allocator,
                        log,
                    ),
                };

                try lockfile.buffers.dependencies.append(allocator, dep);
                dep_count += 1;
            }
        }
    }

    // TODO: Parse peer dependencies (store separately)
    // TODO: Parse dependenciesMeta for optional flags

    return .{ deps_off, dep_count };
}
```

### 12.8 Checksum Parsing

```zig
fn parseChecksum(
    entry_obj: JSAst.Expr.Object,
    cache_key: []const u8,
    allocator: Allocator,
    string_buf: *StringBuf,
) !Integrity {
    const checksum_expr = entry_obj.get("checksum") orelse {
        return Integrity{};
    };

    const checksum_str = checksum_expr.asString(allocator) orelse {
        return Integrity{};
    };

    // Unquote if needed
    const checksum = if (strings.hasPrefix(checksum_str, "\""))
        checksum_str[1..checksum_str.len-1]
    else
        checksum_str;

    // Format: "10c0/base64hash"
    const slash_idx = strings.indexOfChar(checksum, '/');
    if (slash_idx == null) return Integrity{};

    const hash = checksum[slash_idx.? + 1..];

    // Convert to Bun format: "sha512-base64hash"
    const bun_integrity = try std.fmt.allocPrint(allocator, "sha512-{s}", .{hash});
    defer allocator.free(bun_integrity);

    return Integrity.parse(bun_integrity, string_buf) catch Integrity{};
}
```

---

## 13. Comparison with v1 Implementation

### 13.1 Similarities (Can Reuse)

1. **Workspace discovery logic** (glob matching, package.json reading)
2. **Package creation architecture** (root → workspaces → packages)
3. **Dependency resolution pattern** (3-phase: root → workspaces → packages)
4. **bun.lock generation** (same target format)
5. **String buffer management**
6. **Metadata fetching** (os/cpu from npm)

### 13.2 Differences (Cannot Reuse)

1. **Parser**: YAML vs custom indentation-based
2. **Protocol handling**: ALL deps have protocols vs only special cases
3. **Entry format**: Different structure, fields, names
4. **Integrity format**: `checksum:` vs `integrity:`
5. **Virtual packages**: New concept, no equivalent in v1
6. **Patch protocol**: New feature
7. **Workspace detection**: Different markers

### 13.3 Code Reuse Strategy

```zig
// src/install/yarn_berry.zig - New file!
const YarnV1 = @import("./yarn.zig");

// Can reuse:
const parseWorkspacesFromPackageJson = YarnV1.parseWorkspacesFromPackageJson;
const parsePackageJsonDependencies = YarnV1.parsePackageJsonDependencies;
const parseBinFromPackageJson = YarnV1.parseBinFromPackageJson;

// Cannot reuse (implement new):
fn parseYarnBerryLockfile(...) !YarnBerryEntryList { ... }
fn parseProtocol(...) !Resolution { ... }
fn parseChecksum(...) !Integrity { ... }
```

---

## 14. Test Plan

### 14.1 Basic Tests (Must Have)

1. **Simple npm dependencies**

   ```yaml
   "lodash@npm:^4.17.21":
     version: 4.17.21
     resolution: "lodash@npm:4.17.21"
     checksum: 10c0/...
   ```

   - Verify package created
   - Verify integrity converted correctly

2. **Workspace dependencies**

   ```yaml
   "my-app@workspace:.":
     version: 1.0.0
     resolution: "my-app@workspace:."
     dependencies:
       my-lib: "workspace:^"
   ```

   - Verify workspace packages created
   - Verify workspace deps resolve correctly

3. **Multi-spec consolidation**

   ```yaml
   "react@npm:^18.0.0, react@npm:^18.2.0":
     version: 18.3.1
   ```

   - Verify single package created
   - Verify both specs resolve to same package

4. **Scoped packages**
   ```yaml
   "@babel/core@npm:^7.0.0":
     version: 7.24.0
   ```

   - Verify scoped packages work

### 14.2 Protocol Tests (Should Have)

5. **Patch protocol (skip initially)**

   ```yaml
   "pkg@patch:pkg@npm%3A1.0.0#...":
   ```

   - Warn user patches not migrated
   - Use base package

6. **Portal protocol**

   ```yaml
   "pkg@portal:../pkg":
   ```

   - Map to folder resolution

7. **Link protocol**

   ```yaml
   "pkg@link:../pkg":
   ```

   - Map to link resolution

8. **Git dependencies**

   ```yaml
   "pkg@git://github.com/user/repo#commit:abc":
   ```

   - Map to git resolution

9. **GitHub shorthand**

   ```yaml
   "pkg@github:user/repo#commit:abc":
   ```

   - Map to github resolution

10. **File dependencies**
    ```yaml
    "pkg@file:../vendor/pkg.tgz":
    ```

    - Map to local_tarball or folder

### 14.3 Complex Tests (Nice to Have)

11. **Complex monorepo**
    - Multiple workspaces
    - Inter-workspace dependencies
    - External dependencies

12. **Peer dependencies**
    - Packages with peers
    - Virtual packages (skip for now)

13. **Resolutions/overrides**
    - Read from package.json
    - Apply during migration

14. **Optional dependencies**
    - dependenciesMeta with optional: true
    - Verify marked as optional in bun.lock

15. **Bin scripts**
    - Single bin string
    - Multiple bin object
    - Verify copied to bun.lock

### 14.4 Edge Cases

16. **URL encoding in patches**
    - `@` → `%40`, `:` → `%3A`
    - Decode correctly

17. **Very long package names**
    - Don't corrupt

18. **Mixed protocols**
    - Same package with different protocols
    - Should be different packages

19. **Missing fields**
    - No checksum
    - No dependencies
    - No bin
    - Should not crash

20. **Invalid lockfile version**
    - Version < 6
    - Return error with helpful message

### 14.5 Test File Structure

```
test/cli/install/migration/
  yarn-berry/
    basic/
      package.json
      yarn.lock
    workspaces/
      package.json
      yarn.lock
      packages/
        lib/package.json
    patches/
      package.json
      yarn.lock
      .yarn/patches/...
    protocols/
      package.json
      yarn.lock
```

---

## 15. Implementation Phases

### Phase 1: Minimal Viable Product (MVP)

**Goal:** Migrate basic Berry lockfiles with npm packages

**Scope:**

- ✅ YAML parsing
- ✅ `npm:` protocol support
- ✅ `workspace:` protocol support
- ✅ Multi-spec consolidation
- ✅ Checksum conversion
- ✅ Basic dependency resolution
- ❌ No patches
- ❌ No virtual packages
- ❌ No exotic protocols

**Test coverage:** Tests 1-4, 16-20

**Estimated effort:** 3-5 days

### Phase 2: Common Protocols

**Goal:** Support most common real-world cases

**Scope:**

- ✅ `link:` protocol
- ✅ `portal:` protocol
- ✅ `file:` protocol
- ✅ `git:` / `github:` protocols
- ✅ `https:` protocol (remote tarballs)
- ❌ Still no patches
- ❌ Still no virtual packages

**Test coverage:** Tests 5-10

**Estimated effort:** 2-3 days

### Phase 3: Advanced Features

**Goal:** Full compatibility

**Scope:**

- ✅ `patch:` protocol (read patches, store in Bun format)
- ✅ Virtual packages (flatten or full support)
- ✅ Resolutions/overrides
- ✅ Peer dependency metadata
- ✅ Optional dependency flags

**Test coverage:** Tests 11-15

**Estimated effort:** 4-6 days

### Phase 4: Polish & Edge Cases

**Goal:** Production ready

**Scope:**

- ✅ Error messages
- ✅ Edge case handling
- ✅ Performance optimization
- ✅ Documentation
- ✅ Integration tests with real projects

**Test coverage:** All tests

**Estimated effort:** 2-3 days

**Total estimated effort:** 11-17 days

---

## 16. Key Decisions & Recommendations

### 16.1 Virtual Packages

**Decision:** Skip virtual packages in MVP, flatten to base packages

**Rationale:**

- Virtual packages are Berry-specific optimization
- Bun's peer dep resolution is different
- Flattening to base packages usually works
- Can add full support later if needed

**Implementation:**

```zig
// Skip virtual package entries
if (strings.contains(entry_key, "@virtual:")) {
    continue;
}
```

### 16.2 Patch Protocol

**Decision:** Warn and use base package in MVP, full support in Phase 3

**Rationale:**

- Patches are important but complex
- Need to read `.yarn/patches/` directory
- Need URL decoding
- Better to warn than fail

**MVP implementation:**

```zig
if (strings.hasPrefix(protocol_part, "patch:")) {
    try log.addWarning(null, logger.Loc.Empty,
        "Patch protocol detected but not fully supported yet. " ++
        "Using base package without patch. " ++
        "You may need to re-apply patches manually.");

    // Extract base package
    const patch_content = protocol_part["patch:".len..];
    const hash_idx = strings.indexOfChar(patch_content, '#');
    const base_descriptor = patch_content[0..hash_idx.?];
    const decoded = try urlDecode(base_descriptor, allocator);
    defer allocator.free(decoded);
    return parseResolution(decoded, allocator, string_buf);
}
```

### 16.3 Lockfile Version Support

**Decision:** Support v6, v7, v8 only

**Rationale:**

- v5 and below have different formats
- v6+ is stable and widely used
- Easier to maintain

**Implementation:**

```zig
if (lockfile_version < 6) {
    try log.addErrorFmt(null, logger.Loc.Empty, allocator,
        "Yarn Berry lockfile version {d} is too old. " ++
        "Please upgrade to Yarn v2.0+ and regenerate lockfile.",
        .{lockfile_version});
    return error.YarnBerryVersionTooOld;
}
```

### 16.4 Error Handling

**Decision:** Fail fast with helpful errors

**Rationale:**

- Berry lockfiles are complex
- Better to fail with clear error than produce broken bun.lock
- Users can fix issues and retry

**Error messages:**

- "Yarn Berry lockfile version X is too old"
- "Invalid protocol: X in package Y"
- "Missing required field 'resolution' in entry X"
- "Patch protocol not fully supported yet"
- "Virtual packages are not supported yet"

---

## 17. Future Enhancements

### 17.1 Full Patch Support

**Goal:** Migrate `.yarn/patches/` to Bun's patch system

**Requirements:**

- Read patch files from `.yarn/patches/`
- Parse patch descriptors with URL encoding
- Store patches in Bun format
- Apply patches during migration

### 17.2 Full Virtual Package Support

**Goal:** Support Berry's virtual package optimization

**Requirements:**

- Parse virtual package hashes
- Create multiple package instances
- Use namespaced keys in bun.lock
- Preserve peer dep sets

### 17.3 Plug'n'Play (PnP) Support

**Goal:** Migrate from PnP mode to node_modules mode

**Challenges:**

- PnP has no node_modules
- Need to read `.pnp.cjs` file
- Extract package locations
- Reconstruct dependency tree

**Recommendation:** Out of scope initially. Very complex.

---

## 18. Related Resources

### Official Yarn Berry Docs

- https://yarnpkg.com/
- https://yarnpkg.com/advanced/lexicon
- https://github.com/yarnpkg/berry

### Lockfile Spec

- No official spec document
- Best reference: Yarn Berry source code
- https://github.com/yarnpkg/berry/tree/master/packages/yarnpkg-lockfile

### Protocol Docs

- npm: Standard npm registry
- workspace: Monorepo support
- patch: https://yarnpkg.com/cli/patch
- portal: Similar to link with deps
- exec: https://yarnpkg.com/features/protocols

### Existing Implementations

- Yarn Berry itself (TypeScript)
- Some partial parsers in various tools
- None in Zig (we're first!)

---

## 19. Success Metrics

### Migration Quality

- ✅ All packages from yarn.lock present in bun.lock
- ✅ All dependencies resolved correctly
- ✅ Workspace structure preserved
- ✅ Integrity hashes preserved
- ✅ Bin scripts preserved

### Test Coverage

- ✅ 20+ test cases covering all protocols
- ✅ Real-world project tests (Babel, Jest, etc.)
- ✅ Edge case coverage

### Performance

- ✅ Migration completes in <5s for typical projects
- ✅ Memory usage reasonable (<500MB for large monorepos)

### User Experience

- ✅ Clear error messages
- ✅ Helpful warnings for unsupported features
- ✅ Progress indication for large lockfiles
- ✅ Documentation for manual fixes needed

---

## 20. Conclusion

Yarn Berry (v2+) lockfile format is a **complete redesign** from v1. Key takeaways:

1. **Cannot reuse v1 parser** - Must use YAML library
2. **Protocol handling is critical** - Every dep has explicit protocol
3. **Start simple** - MVP with `npm:` and `workspace:` protocols
4. **Iterate** - Add protocols progressively
5. **Virtual packages can wait** - Flatten to base packages initially
6. **Patches are important** - Warn initially, full support later
7. **Test extensively** - Many edge cases to handle

**Recommended approach:**

1. Implement Phase 1 (MVP) first
2. Test with real projects
3. Gather feedback
4. Implement Phase 2 (common protocols)
5. Iterate based on user needs

**Estimated total effort:** 11-17 days for full implementation

**Priority:** Medium-High. Berry is increasingly popular in enterprise projects and modern monorepos.

---

## Appendix A: Sample Migration Test

### Input: yarn.lock (Berry)

```yaml
__metadata:
  version: 8
  cacheKey: 10c0

"my-app@workspace:.":
  version: 1.0.0
  resolution: "my-app@workspace:."
  dependencies:
    lodash: "npm:^4.17.21"
  languageName: unknown
  linkType: soft

"lodash@npm:^4.17.21":
  version: 4.17.21
  resolution: "lodash@npm:4.17.21"
  checksum: 10c0/eb835a2a4d5a152b4abc123def456...
  languageName: node
  linkType: hard
```

### Expected Output: bun.lock

```jsonc
{
  "lockfileVersion": 0,
  "workspaces": {
    "": {
      "dependencies": {
        "lodash": "^4.17.21",
      },
    },
  },
  "packages": {
    "lodash": [
      "lodash@4.17.21",
      "",
      {},
      "sha512-eb835a2a4d5a152b4abc123def456...",
    ],
  },
}
```

---

**End of Research Document**
