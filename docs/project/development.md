Configuring a development environment for Bun can take 10-30 minutes depending on your internet connection and computer speed. You will need ~10GB of free disk space for the repository and build artifacts.

## Install LLVM

Bun requires LLVM 15 and Clang 15 (`clang` is part of LLVM). This version requirement is to match WebKit (precompiled), as mismatching versions will cause memory allocation failures at runtime. In most cases, you can install LLVM through your system package manager:

{% codetabs %}

```bash#macOS (Homebrew)
$ brew install llvm@15
```

```bash#Ubuntu/Debian
# On Ubuntu 22.04 and newer, LLVM 15 is available in the default repositories
$ sudo apt install llvm-15 lld-15
# On older versions, 
$ wget https://apt.llvm.org/llvm.sh -O - | sudo bash -s -- 15 all
```

```bash#Arch
$ sudo pacman -S llvm
```

{% /codetabs %}

If none of the above solutions apply, you will have to install it [manually](https://github.com/llvm/llvm-project/releases/tag/llvmorg-15.0.7).

Make sure LLVM 15 is in your path:

```
$ which clang-15
```

If not, run this to manually link it:

{% codetabs %}

```bash#macOS (Homebrew)
# use fish_add_path if you're using fish
$ export PATH="$PATH:$(brew --prefix llvm@15)/bin"
$ export LDFLAGS="$LDFLAGS -L$(brew --prefix llvm@15)/lib"
$ export CPPFLAGS="$CPPFLAGS -I$(brew --prefix llvm@15)/include"
```

{% /codetabs %}

## Install Dependencies

Using your system's package manager, install the rest of Bun's dependencies:

{% codetabs %}

```bash#macOS (Homebrew)
$ brew install automake cmake coreutils esbuild gnu-sed go libiconv libtool ninja pkg-config rust
```

```bash#Ubuntu/Debian
$ sudo apt install cargo cmake esbuild git golang libtool ninja-build pkg-config rustc
```

```bash#Arch
$ pacman -S base-devel ccache clang cmake esbuild git go libiconv libtool lld make ninja pkg-config python rust sed unzip
```

{% /codetabs %}

In addition to this, you will need either `bun` or `npm` installed to install the package.json dependencies.

## Install Zig

Zig can installed either with our npm package [`@oven/zig`](https://www.npmjs.com/package/@oven/zig), or using [zigup](https://github.com/marler8997/zigup).

```
$ bun install -g @oven/zig
$ zigup master
```

## Building

After cloning the repository, prepare bun to be built:

```bash
$ make setup
```

Then to build Bun:

```bash
$ make dev
```

The binary will be located at `packages/debug-bun-{platform}-{arch}/bun/bun-debug`. It is recommended to add this to your `$PATH`.

If you're building on a macOS device, you'll need to have a valid Developer Certificate, or else the code signing step will fail. To check if you have one, open the `Keychain Access` app, go to the `login` profile and search for `Apple Development`. You should have at least one certificate with a name like `Apple Development: user@example.com (WDYABC123)`. If you don't have one, follow [this guide](https://ioscodesigning.com/generating-code-signing-files/#generate-a-code-signing-certificate-using-xcode) to get one. You can still work with the generated binary locally at `packages/debug-bun-*/bun-debug` even if the code signing fails.

To verify the build worked, lets print the version number on the development build of Bun.

```bash
$ packages/debug-bun-*/bun-debug --version
bun 0.x.y__dev
```

## JavaScript builtins

When you change anything in `src/bun.js/builtins/js/*`, run this:

```bash
$ make clean-bindings generate-builtins && make bindings -j$(nproc)
```

That inlines the JavaScript code into C++ headers using the same builtins generator script that Safari uses.


## Code generation scripts

Bun leverages a lot of code generation scripts.

The [./src/bun.js/bindings/headers.h](https://github.com/oven-sh/bun/blob/main/src/bun.js/bindings/headers.h) file has bindings to & from Zig <> C++ code. This file is generated by running the following:

```bash
$ make headers
```

This ensures that the types for Zig and the types for C++ match up correctly, by using comptime reflection over functions exported/imported.

TypeScript files that end with `*.classes.ts` are another code generation script. They generate C++ boilerplate for classes implemented in Zig. The generated code lives in:

- [src/bun.js/bindings/ZigGeneratedClasses.cpp](https://github.com/oven-sh/bun/tree/main/src/bun.js/bindings/ZigGeneratedClasses.cpp)
- [src/bun.js/bindings/ZigGeneratedClasses.h](https://github.com/oven-sh/bun/tree/main/src/bun.js/bindings/ZigGeneratedClasses.h)
- [src/bun.js/bindings/generated_classes.zig](https://github.com/oven-sh/bun/tree/main/src/bun.js/bindings/generated_classes.zig)
  To generate the code, run:

```bash
$ make codegen
```

Lastly, we also have a [code generation script](src/bun.js/scripts/generate-jssink.js) for our native stream implementations.
To run that, run:

```bash
$ make generate-sink
```

You probably won't need to run that one much.

## Modifying ESM core modules

Certain modules like `node:fs`, `node:path`, `node:stream`, and `bun:sqlite` are implemented in JavaScript. These live in `src/bun.js/*.exports.js` files.

While Bun is in beta, you can modify them at runtime in release builds via the environment variable `BUN_OVERRIDE_MODULE_PATH`. When set, Bun will look in the override directory for `<name>.exports.js` before checking the files from `src/bun.js` (which are now baked in to the binary). This lets you test changes to the ESM modules without needing to re-compile Bun.

## Troubleshooting

If you see an error when compiling `libarchive`, run this:

```bash
$ brew install pkg-config
```

If you see an error about missing files on `zig build obj`, make sure you built the headers.

```bash
$ make headers
```
