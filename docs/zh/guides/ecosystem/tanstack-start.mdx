---
title: åœ¨ Bun ä¸­ä½¿ç”¨ TanStack Start
sidebarTitle: TanStack Start ä¸ Bun
mode: center
---

[TanStack Start](https://tanstack.com/start/latest) æ˜¯ä¸€ä¸ªç”± TanStack Router é©±åŠ¨çš„å…¨æ ˆæ¡†æ¶ã€‚å®ƒæ”¯æŒå…¨æ–‡æ¡£ SSRã€æµå¼ä¼ è¾“ã€æœåŠ¡å™¨å‡½æ•°ã€æ‰“åŒ…ç­‰åŠŸèƒ½ï¼Œç”± TanStack Router å’Œ [Vite](https://vite.dev/) é©±åŠ¨ã€‚

---

<Steps>
  <Step title="åˆ›å»ºä¸€ä¸ªæ–°çš„ TanStack Start åº”ç”¨">
    ä½¿ç”¨äº¤äº’å¼ CLI åˆ›å»ºä¸€ä¸ªæ–°çš„ TanStack Start åº”ç”¨ã€‚

    ```sh terminal icon="terminal"
    bun create @tanstack/start@latest my-tanstack-app
    ```

  </Step>
  <Step title="å¯åŠ¨å¼€å‘æœåŠ¡å™¨">
    æ›´æ”¹åˆ°é¡¹ç›®ç›®å½•å¹¶ä½¿ç”¨ Bun è¿è¡Œå¼€å‘æœåŠ¡å™¨ã€‚

    ```sh terminal icon="terminal"
    cd my-tanstack-app
    bun --bun run dev
    ```

    è¿™å°†ä½¿ç”¨ Bun å¯åŠ¨ Vite å¼€å‘æœåŠ¡å™¨ã€‚

  </Step>
  <Step title="æ›´æ–° package.json ä¸­çš„è„šæœ¬">
   é€šè¿‡åœ¨ Vite CLI å‘½ä»¤å‰ç¼€åŠ ä¸Š `bun --bun` æ¥ä¿®æ”¹ `package.json` ä¸­çš„è„šæœ¬å­—æ®µã€‚è¿™ç¡®ä¿äº† Bun ä¸ºå¸¸è§ä»»åŠ¡å¦‚ `dev`ã€`build` å’Œ `preview` æ‰§è¡Œ Vite CLIã€‚

    ```json package.json icon="file-json"
    {
      "scripts": {
        "dev": "bun --bun vite dev", // [!code ++]
        "build": "bun --bun vite build", // [!code ++]
        "serve": "bun --bun vite preview" // [!code ++]
      }
    }
    ```

  </Step>
</Steps>

---

## æ‰˜ç®¡

è¦æ‰˜ç®¡æ‚¨çš„ TanStack Start åº”ç”¨ï¼Œæ‚¨å¯ä»¥ä½¿ç”¨ [Nitro](https://nitro.build/) æˆ–è‡ªå®šä¹‰ Bun æœåŠ¡å™¨è¿›è¡Œç”Ÿäº§éƒ¨ç½²ã€‚

<Tabs>
  <Tab title="Nitro">
    <Steps>
      <Step title="å‘é¡¹ç›®æ·»åŠ  Nitro">
        å‘æ‚¨çš„é¡¹ç›®æ·»åŠ  [Nitro](https://nitro.build/)ã€‚è¿™ä¸ªå·¥å…·å…è®¸æ‚¨å°† TanStack Start åº”ç”¨éƒ¨ç½²åˆ°ä¸åŒçš„å¹³å°ã€‚

        ```sh terminal icon="terminal"
        bun add nitro
        ```

      </Step>
      <Step title={<span>æ›´æ–°æ‚¨çš„ <code>vite.config.ts</code> æ–‡ä»¶</span>}>
        æ›´æ–°æ‚¨çš„ [vite.config.ts] æ–‡ä»¶ä»¥åŒ…å« Bun çš„ TanStack Start æ‰€éœ€çš„å¿…è¦æ’ä»¶ã€‚

        ```ts vite.config.ts icon="/icons/typescript.svg"
        // å…¶ä»–å¯¼å…¥...
        import { nitro } from "nitro/vite"; // [!code ++]

        const config = defineConfig({
          plugins: [
            tanstackStart(),
            nitro({ preset: "bun" }), // [!code ++]
            // å…¶ä»–æ’ä»¶...
          ],
        });

        export default config;
        ```

        <Note>
          `bun` é¢„è®¾æ˜¯å¯é€‰çš„ï¼Œä½†å®ƒé…ç½®äº†ä¸“é—¨é’ˆå¯¹ Bun è¿è¡Œæ—¶çš„æ„å»ºè¾“å‡ºã€‚
        </Note>

      </Step>
      <Step title="æ›´æ–°å¯åŠ¨å‘½ä»¤">
        ç¡®ä¿ `build` å’Œ `start` è„šæœ¬å­˜åœ¨äºæ‚¨çš„ [package.json] æ–‡ä»¶ä¸­ï¼š

        ```json package.json icon="file-json"
          {
            "scripts": {
              "build": "bun --bun vite build", // [!code ++]
              // å½“æ‚¨è¿è¡Œ `bun run build` æ—¶ï¼ŒNitro ä¼šåˆ›å»º .output æ–‡ä»¶ã€‚
              // éƒ¨ç½²åˆ° Vercel æ—¶ä¸éœ€è¦ã€‚
              "start": "bun run .output/server/index.mjs" // [!code ++]
            }
          }
        ```

        <Note>
          <Note>
          åœ¨éƒ¨ç½²åˆ° Vercel æ—¶ï¼Œæ‚¨**ä¸éœ€è¦**è‡ªå®šä¹‰ `start` è„šæœ¬ã€‚
        </Note>

      </Step>
      <Step title="éƒ¨ç½²æ‚¨çš„åº”ç”¨">
        æŸ¥çœ‹æˆ‘ä»¬çš„æŒ‡å—ä¹‹ä¸€ï¼Œå°†æ‚¨çš„åº”ç”¨éƒ¨ç½²åˆ°æ‰˜ç®¡æä¾›å•†ã€‚

        <Note>
          éƒ¨ç½²åˆ° Vercel æ—¶ï¼Œæ‚¨å¯ä»¥åœ¨ `vercel.json` æ–‡ä»¶ä¸­æ·»åŠ  `"bunVersion": "1.x"`ï¼Œæˆ–å°†å…¶æ·»åŠ åˆ° [vite.config.ts] æ–‡ä»¶ä¸­çš„ `nitro` é…ç½®ä¸­ï¼š

          <Warning>
            éƒ¨ç½²åˆ° Vercel æ—¶ä¸è¦ä½¿ç”¨ `bun` Nitro é¢„è®¾ã€‚
          </Warning>

          ```ts vite.config.ts icon="/icons/typescript.svg"
          export default defineConfig({
            plugins: [
              tanstackStart(),
              nitro({
                preset: "bun", // [!code --]
                vercel: { // [!code ++]
                  functions: { // [!code ++]
                    runtime: "bun1.x", // [!code ++]
                  }, // [!code ++]
              }, // [!code ++]
              }),
            ],
          });
          ```
        </Note>
      </Step>
    </Steps>

  </Tab>
  <Tab title="è‡ªå®šä¹‰æœåŠ¡å™¨">
    <Note>
      æ­¤è‡ªå®šä¹‰æœåŠ¡å™¨å®ç°åŸºäº [TanStack çš„ Bun æ¨¡æ¿](https://github.com/TanStack/router/blob/main/examples/react/start-bun/server.ts)ã€‚å®ƒæä¾›äº†å¯¹é™æ€èµ„äº§æœåŠ¡çš„ç»†ç²’åº¦æ§åˆ¶ï¼ŒåŒ…æ‹¬å¯é…ç½®çš„å†…å­˜ç®¡ç†ï¼Œè¯¥ç®¡ç†å°†å°æ–‡ä»¶é¢„åŠ è½½åˆ°å†…å­˜ä¸­ä»¥å¿«é€Ÿæä¾›æœåŠ¡ï¼Œè€ŒæŒ‰éœ€æä¾›è¾ƒå¤§çš„æ–‡ä»¶ã€‚å½“æ‚¨éœ€è¦åœ¨ç”Ÿäº§éƒ¨ç½²ä¸­ç²¾ç¡®æ§åˆ¶èµ„æºä½¿ç”¨å’Œèµ„äº§åŠ è½½è¡Œä¸ºæ—¶ï¼Œè¿™ç§æ–¹æ³•éå¸¸æœ‰ç”¨ã€‚
    </Note>

    <Steps>
      <Step title="åˆ›å»ºç”Ÿäº§æœåŠ¡å™¨">
        åœ¨æ‚¨çš„é¡¹ç›®æ ¹ç›®å½•åˆ›å»ºä¸€ä¸ª [server.ts] æ–‡ä»¶ï¼Œå…¶ä¸­åŒ…å«ä»¥ä¸‹è‡ªå®šä¹‰æœåŠ¡å™¨å®ç°ï¼š

        ```ts server.ts icon="/icons/typescript.svg" expandable
        /**
        * ç”¨äº Bun çš„ TanStack Start ç”Ÿäº§æœåŠ¡å™¨
        *
        * ä¸€ä¸ªé«˜æ€§èƒ½çš„ TanStack Start åº”ç”¨ç¨‹åºç”Ÿäº§æœåŠ¡å™¨ï¼Œ
        * å®ç°äº†æ™ºèƒ½é™æ€èµ„äº§åŠ è½½å’Œå¯é…ç½®çš„å†…å­˜ç®¡ç†ã€‚
        *
        * åŠŸèƒ½:
        * - æ··åˆåŠ è½½ç­–ç•¥ï¼ˆé¢„åŠ è½½å°æ–‡ä»¶ï¼ŒæŒ‰éœ€æä¾›å¤§æ–‡ä»¶ï¼‰
        * - å¯é…ç½®çš„æ–‡ä»¶è¿‡æ»¤ï¼ŒåŒ…æ‹¬åŒ…å«/æ’é™¤æ¨¡å¼
        * - å†…å­˜é«˜æ•ˆçš„å“åº”ç”Ÿæˆ
        * - é€‚åˆç”Ÿäº§çš„ç¼“å­˜å¤´
        *
        * ç¯å¢ƒå˜é‡:
        *
        * PORT (number)
        *   - æœåŠ¡å™¨ç«¯å£å·
        *   - é»˜è®¤å€¼: 3000
        *
        * ASSET_PRELOAD_MAX_SIZE (number)
        *   - é¢„åŠ è½½åˆ°å†…å­˜çš„æœ€å¤§æ–‡ä»¶å¤§å°ï¼ˆä»¥å­—èŠ‚ä¸ºå•ä½ï¼‰
        *   - å¤§äºæ­¤å¤§å°çš„æ–‡ä»¶å°†ä»ç£ç›˜æŒ‰éœ€æä¾›
        *   - é»˜è®¤å€¼: 5242880 (5MB)
        *   - ç¤ºä¾‹: ASSET_PRELOAD_MAX_SIZE=5242880 (5MB)
        *
        * ASSET_PRELOAD_INCLUDE_PATTERNS (string)
        *   - ä»¥é€—å·åˆ†éš”çš„ glob æ¨¡å¼åˆ—è¡¨ï¼Œç”¨äºè¦åŒ…å«çš„æ–‡ä»¶
        *   - å¦‚æœæŒ‡å®šï¼Œåˆ™åªæœ‰åŒ¹é…çš„æ–‡ä»¶æ‰æœ‰èµ„æ ¼é¢„åŠ è½½
        *   - æ¨¡å¼ä»…åŒ¹é…æ–‡ä»¶åï¼Œè€Œéå®Œæ•´è·¯å¾„
        *   - ç¤ºä¾‹: ASSET_PRELOAD_INCLUDE_PATTERNS="*.js,*.css,*.woff2"
        *
        * ASSET_PRELOAD_EXCLUDE_PATTERNS (string)
        *   - ä»¥é€—å·åˆ†éš”çš„ glob æ¨¡å¼åˆ—è¡¨ï¼Œç”¨äºè¦æ’é™¤çš„æ–‡ä»¶
        *   - åœ¨åŒ…å«æ¨¡å¼ä¹‹ååº”ç”¨
        *   - æ¨¡å¼ä»…åŒ¹é…æ–‡ä»¶åï¼Œè€Œéå®Œæ•´è·¯å¾„
        *   - ç¤ºä¾‹: ASSET_PRELOAD_EXCLUDE_PATTERNS="*.map,*.txt"
        *
        * ASSET_PRELOAD_VERBOSE_LOGGING (boolean)
        *   - å¯ç”¨å·²åŠ è½½å’Œå·²è·³è¿‡æ–‡ä»¶çš„è¯¦ç»†æ—¥å¿—è®°å½•
        *   - é»˜è®¤å€¼: false
        *   - è®¾ç½®ä¸º "true" ä»¥å¯ç”¨è¯¦ç»†è¾“å‡º
        *
        * ASSET_PRELOAD_ENABLE_ETAG (boolean)
        *   - ä¸ºé¢„åŠ è½½çš„èµ„äº§å¯ç”¨ ETag ç”Ÿæˆ
        *   - é»˜è®¤å€¼: true
        *   - è®¾ç½®ä¸º "false" ä»¥ç¦ç”¨ ETag æ”¯æŒ
        *
        * ASSET_PRELOAD_ENABLE_GZIP (boolean)
        *   - ä¸ºç¬¦åˆæ¡ä»¶çš„èµ„äº§å¯ç”¨ Gzip å‹ç¼©
        *   - é»˜è®¤å€¼: true
        *   - è®¾ç½®ä¸º "false" ä»¥ç¦ç”¨ Gzip å‹ç¼©
        *
        * ASSET_PRELOAD_GZIP_MIN_SIZE (number)
        *   - Gzip å‹ç¼©æ‰€éœ€çš„æœ€å°æ–‡ä»¶å¤§å°ï¼ˆä»¥å­—èŠ‚ä¸ºå•ä½ï¼‰
        *   - å°äºæ­¤å¤§å°çš„æ–‡ä»¶ä¸ä¼šè¢«å‹ç¼©
        *   - é»˜è®¤å€¼: 1024 (1KB)
        *
        * ASSET_PRELOAD_GZIP_MIME_TYPES (string)
        *   - æœ‰èµ„æ ¼è¿›è¡Œ Gzip å‹ç¼©çš„ MIME ç±»å‹åˆ—è¡¨ï¼Œä»¥é€—å·åˆ†éš”
        *   - æ”¯æŒå¯¹ä»¥ "/" ç»“å°¾çš„ç±»å‹è¿›è¡Œéƒ¨åˆ†åŒ¹é…
        *   - é»˜è®¤å€¼: text/,application/javascript,application/json,application/xml,image/svg+xml
        *
        * ç”¨æ³•:
        *   bun run server.ts
        */

        import path from 'node:path'

        // é…ç½®
        const SERVER_PORT = Number(process.env.PORT ?? 3000)
        const CLIENT_DIRECTORY = './dist/client'
        const SERVER_ENTRY_POINT = './dist/server/server.js'

        // ä¸“ä¸šè¾“å‡ºçš„æ—¥å¿—å·¥å…·
        const log = {
          info: (message: string) => {
            console.log(`[INFO] ${message}`)
          },
          success: (message: string) => {
            console.log(`[SUCCESS] ${message}`)
          },
          warning: (message: string) => {
            console.log(`[WARNING] ${message}`)
          },
          error: (message: string) => {
            console.log(`[ERROR] ${message}`)
          },
          header: (message: string) => {
            console.log(`\n${message}\n`)
          },
        }

        // ä»ç¯å¢ƒå˜é‡é¢„åŠ è½½é…ç½®
        const MAX_PRELOAD_BYTES = Number(
          process.env.ASSET_PRELOAD_MAX_SIZE ?? 5 * 1024 * 1024, // 5MB é»˜è®¤å€¼
        )

        // è§£æä»¥é€—å·åˆ†éš”çš„åŒ…å«æ¨¡å¼ï¼ˆæ— é»˜è®¤å€¼ï¼‰
        const INCLUDE_PATTERNS = (process.env.ASSET_PRELOAD_INCLUDE_PATTERNS ?? '')
          .split(',')
          .map((s) => s.trim())
          .filter(Boolean)
          .map((pattern: string) => convertGlobToRegExp(pattern))

        // è§£æä»¥é€—å·åˆ†éš”çš„æ’é™¤æ¨¡å¼ï¼ˆæ— é»˜è®¤å€¼ï¼‰
        const EXCLUDE_PATTERNS = (process.env.ASSET_PRELOAD_EXCLUDE_PATTERNS ?? '')
          .split(',')
          .map((s) => s.trim())
          .filter(Boolean)
          .map((pattern: string) => convertGlobToRegExp(pattern))

        // è¯¦ç»†æ—¥å¿—è®°å½•æ ‡å¿—
        const VERBOSE = process.env.ASSET_PRELOAD_VERBOSE_LOGGING === 'true'

        // å¯é€‰çš„ ETag åŠŸèƒ½
        const ENABLE_ETAG = (process.env.ASSET_PRELOAD_ENABLE_ETAG ?? 'true') === 'true'

        // å¯é€‰çš„ Gzip åŠŸèƒ½
        const ENABLE_GZIP = (process.env.ASSET_PRELOAD_ENABLE_GZIP ?? 'true') === 'true'
        const GZIP_MIN_BYTES = Number(process.env.ASSET_PRELOAD_GZIP_MIN_SIZE ?? 1024) // 1KB
        const GZIP_TYPES = (
          process.env.ASSET_PRELOAD_GZIP_MIME_TYPES ??
          'text/,application/javascript,application/json,application/xml,image/svg+xml'
        )
          .split(',')
          .map((v) => v.trim())
          .filter(Boolean)

        /**
        * å°†ç®€å• glob æ¨¡å¼è½¬æ¢ä¸ºæ­£åˆ™è¡¨è¾¾å¼
        * æ”¯æŒ * é€šé…ç¬¦ä»¥åŒ¹é…ä»»æ„å­—ç¬¦
        */
        function convertGlobToRegExp(globPattern: string): RegExp {
          // è½¬ä¹‰é™¤ * ä»¥å¤–çš„æ­£åˆ™ç‰¹æ®Šå­—ç¬¦ï¼Œç„¶åå°† * æ›¿æ¢ä¸º .*
          const escapedPattern = globPattern
            .replace(/[-/\\^$+?.()|[\]{}]/g, '\\$&')
            .replace(/\*/g, '.*')
          return new RegExp(`^${escapedPattern}$`, 'i')
        }

        /**
        * ä¸ºç»™å®šçš„æ•°æ®ç¼“å†²åŒºè®¡ç®— ETag
        */
        function computeEtag(data: Uint8Array): string {
          const hash = Bun.hash(data)
          return `W/"${hash.toString(16)}-${data.byteLength.toString()}"`
        }

        /**
        * é¢„åŠ è½½é™æ€èµ„äº§çš„å…ƒæ•°æ®
        */
        interface AssetMetadata {
          route: string
          size: number
          type: string
        }

        /**
        * å†…å­˜ä¸­çš„èµ„äº§ï¼Œæ”¯æŒ ETag å’Œ Gzip
        */
        interface InMemoryAsset {
          raw: Uint8Array
          gz?: Uint8Array
          etag?: string
          type: string
          immutable: boolean
          size: number
        }

        /**
        * é™æ€èµ„äº§é¢„åŠ è½½è¿‡ç¨‹çš„ç»“æœ
        */
        interface PreloadResult {
          routes: Record<string, (req: Request) => Response | Promise<Response>>
          loaded: AssetMetadata[]
          skipped: AssetMetadata[]
        }

        /**
        * æ ¹æ®é…ç½®çš„æ¨¡å¼æ£€æŸ¥æ–‡ä»¶æ˜¯å¦æœ‰èµ„æ ¼é¢„åŠ è½½
        */
        function isFileEligibleForPreloading(relativePath: string): boolean {
          const fileName = relativePath.split(/[/\\]/).pop() ?? relativePath

          // å¦‚æœæŒ‡å®šäº†åŒ…å«æ¨¡å¼ï¼Œæ–‡ä»¶å¿…é¡»è‡³å°‘åŒ¹é…ä¸€ä¸ª
          if (INCLUDE_PATTERNS.length > 0) {
            if (!INCLUDE_PATTERNS.some((pattern) => pattern.test(fileName))) {
              return false
            }
          }

          // å¦‚æœæŒ‡å®šäº†æ’é™¤æ¨¡å¼ï¼Œæ–‡ä»¶ä¸å¾—åŒ¹é…ä»»ä½•æ¨¡å¼
          if (EXCLUDE_PATTERNS.some((pattern) => pattern.test(fileName))) {
            return false
          }

          return true
        }

        /**
        * æ£€æŸ¥ MIME ç±»å‹æ˜¯å¦å¯å‹ç¼©
        */
        function isMimeTypeCompressible(mimeType: string): boolean {
          return GZIP_TYPES.some((type) =>
            type.endsWith('/') ? mimeType.startsWith(type) : mimeType === type,
          )
        }

        /**
        * æ ¹æ®å¤§å°å’Œ MIME ç±»å‹æœ‰æ¡ä»¶åœ°å‹ç¼©æ•°æ®
        */
        function compressDataIfAppropriate(
          data: Uint8Array,
          mimeType: string,
        ): Uint8Array | undefined {
          if (!ENABLE_GZIP) return undefined
          if (data.byteLength < GZIP_MIN_BYTES) return undefined
          if (!isMimeTypeCompressible(mimeType)) return undefined
          try {
            return Bun.gzipSync(data.buffer as ArrayBuffer)
          } catch {
            return undefined
          }
        }

        /**
        * åˆ›å»ºå…·æœ‰ ETag å’Œ Gzip æ”¯æŒçš„å“åº”å¤„ç†ç¨‹åºå‡½æ•°
        */
        function createResponseHandler(
          asset: InMemoryAsset,
        ): (req: Request) => Response {
          return (req: Request) => {
            const headers: Record<string, string> = {
              'Content-Type': asset.type,
              'Cache-Control': asset.immutable
                ? 'public, max-age=31536000, immutable'
                : 'public, max-age=3600',
            }

            if (ENABLE_ETAG && asset.etag) {
              const ifNone = req.headers.get('if-none-match')
              if (ifNone && ifNone === asset.etag) {
                return new Response(null, {
                  status: 304,
                  headers: { ETag: asset.etag },
                })
              }
              headers.ETag = asset.etag
            }

            if (
              ENABLE_GZIP &&
              asset.gz &&
              req.headers.get('accept-encoding')?.includes('gzip')
            ) {
              headers['Content-Encoding'] = 'gzip'
              headers['Content-Length'] = String(asset.gz.byteLength)
              const gzCopy = new Uint8Array(asset.gz)
              return new Response(gzCopy, { status: 200, headers })
            }

            headers['Content-Length'] = String(asset.raw.byteLength)
            const rawCopy = new Uint8Array(asset.raw)
            return new Response(rawCopy, { status: 200, headers })
          }
        }

        /**
        * ä»åŒ…å«æ¨¡å¼åˆ›å»ºå¤åˆ glob æ¨¡å¼
        */
        function createCompositeGlobPattern(): Bun.Glob {
          const raw = (process.env.ASSET_PRELOAD_INCLUDE_PATTERNS ?? '')
            .split(',')
            .map((s) => s.trim())
            .filter(Boolean)
          if (raw.length === 0) return new Bun.Glob('**/*')
          if (raw.length === 1) return new Bun.Glob(raw[0])
          return new Bun.Glob(`{${raw.join(',')}}`)
        }

        /**
        * ä½¿ç”¨æ™ºèƒ½é¢„åŠ è½½ç­–ç•¥åˆå§‹åŒ–é™æ€è·¯ç”±
        * å°æ–‡ä»¶åŠ è½½åˆ°å†…å­˜ä¸­ï¼Œå¤§æ–‡ä»¶æŒ‰éœ€æä¾›
        */
        async function initializeStaticRoutes(
          clientDirectory: string,
        ): Promise<PreloadResult> {
          const routes: Record<string, (req: Request) => Response | Promise<Response>> =
            {}
          const loaded: AssetMetadata[] = []
          const skipped: AssetMetadata[] = []

          log.info(`ä» ${clientDirectory} åŠ è½½é™æ€èµ„äº§...`)
          if (VERBOSE) {
            console.log(
              `æœ€å¤§é¢„åŠ è½½å¤§å°: ${(MAX_PRELOAD_BYTES / 1024 / 1024).toFixed(2)} MB`,
            )
            if (INCLUDE_PATTERNS.length > 0) {
              console.log(
                `åŒ…å«æ¨¡å¼: ${process.env.ASSET_PRELOAD_INCLUDE_PATTERNS ?? ''}`,
              )
            }
            if (EXCLUDE_PATTERNS.length > 0) {
              console.log(
                `æ’é™¤æ¨¡å¼: ${process.env.ASSET_PRELOAD_EXCLUDE_PATTERNS ?? ''}`,
              )
            }
          }

          let totalPreloadedBytes = 0

          try {
            const glob = createCompositeGlobPattern()
            for await (const relativePath of glob.scan({ cwd: clientDirectory })) {
              const filepath = path.join(clientDirectory, relativePath)
              const route = `/${relativePath.split(path.sep).join(path.posix.sep)}`

              try {
                // è·å–æ–‡ä»¶å…ƒæ•°æ®
                const file = Bun.file(filepath)

                // å¦‚æœæ–‡ä»¶ä¸å­˜åœ¨æˆ–ä¸ºç©ºåˆ™è·³è¿‡
                if (!(await file.exists()) || file.size === 0) {
                  continue
                }

                const metadata: AssetMetadata = {
                  route,
                  size: file.size,
                  type: file.type || 'application/octet-stream',
                }

                // ç¡®å®šæ–‡ä»¶æ˜¯å¦åº”é¢„åŠ è½½
                const matchesPattern = isFileEligibleForPreloading(relativePath)
                const withinSizeLimit = file.size <= MAX_PRELOAD_BYTES

                if (matchesPattern && withinSizeLimit) {
                  // é¢„åŠ è½½å°æ–‡ä»¶åˆ°å†…å­˜ä¸­ï¼Œæ”¯æŒ ETag å’Œ Gzip
                  const bytes = new Uint8Array(await file.arrayBuffer())
                  const gz = compressDataIfAppropriate(bytes, metadata.type)
                  const etag = ENABLE_ETAG ? computeEtag(bytes) : undefined
                  const asset: InMemoryAsset = {
                    raw: bytes,
                    gz,
                    etag,
                    type: metadata.type,
                    immutable: true,
                    size: bytes.byteLength,
                  }
                  routes[route] = createResponseHandler(asset)

                  loaded.push({ ...metadata, size: bytes.byteLength })
                  totalPreloadedBytes += bytes.byteLength
                } else {
                  // æŒ‰éœ€æä¾›å¤§æ–‡ä»¶æˆ–è¿‡æ»¤çš„æ–‡ä»¶
                  routes[route] = () => {
                    const fileOnDemand = Bun.file(filepath)
                    return new Response(fileOnDemand, {
                      headers: {
                        'Content-Type': metadata.type,
                        'Cache-Control': 'public, max-age=3600',
                      },
                    })
                  }

                  skipped.push(metadata)
                }
              } catch (error: unknown) {
                if (error instanceof Error && error.name !== 'EISDIR') {
                  log.error(`åŠ è½½ ${filepath} å¤±è´¥: ${error.message}`)
                }
              }
            }

            // ä»…åœ¨å¯ç”¨è¯¦ç»†æ¨¡å¼æ—¶æ˜¾ç¤ºè¯¦ç»†æ–‡ä»¶æ¦‚è§ˆ
            if (VERBOSE && (loaded.length > 0 || skipped.length > 0)) {
              const allFiles = [...loaded, ...skipped].sort((a, b) =>
                a.route.localeCompare(b.route),
              )

              // è®¡ç®—æœ€å¤§è·¯å¾„é•¿åº¦ä»¥å¯¹é½
              const maxPathLength = Math.min(
                Math.max(...allFiles.map((f) => f.route.length)),
                60,
              )

              // ä½¿ç”¨ KB å’Œå®é™… gzip å¤§å°æ ¼å¼åŒ–æ–‡ä»¶å¤§å°
              const formatFileSize = (bytes: number, gzBytes?: number) => {
                const kb = bytes / 1024
                const sizeStr = kb < 100 ? kb.toFixed(2) : kb.toFixed(1)

                if (gzBytes !== undefined) {
                  const gzKb = gzBytes / 1024
                  const gzStr = gzKb < 100 ? gzKb.toFixed(2) : gzKb.toFixed(1)
                  return {
                    size: sizeStr,
                    gzip: gzStr,
                  }
                }

                // å¦‚æœæ²¡æœ‰å®é™… gzip æ•°æ®ï¼Œåˆ™ç²—ç•¥ä¼°ç®— gzipï¼ˆé€šå¸¸ 30-70% å‹ç¼©ç‡ï¼‰
                const gzipKb = kb * 0.35
                return {
                  size: sizeStr,
                  gzip: gzipKb < 100 ? gzipKb.toFixed(2) : gzipKb.toFixed(1),
                }
              }

              if (loaded.length > 0) {
                console.log('\nğŸ“ é¢„åŠ è½½åˆ°å†…å­˜:')
                console.log(
                  'è·¯å¾„                                            â”‚    å¤§å° â”‚ Gzip å¤§å°',
                )
                loaded
                  .sort((a, b) => a.route.localeCompare(b.route))
                  .forEach((file) => {
                    const { size, gzip } = formatFileSize(file.size)
                    const paddedPath = file.route.padEnd(maxPathLength)
                    const sizeStr = `${size.padStart(7)} kB`
                    const gzipStr = `${gzip.padStart(7)} kB`
                    console.log(`${paddedPath} â”‚ ${sizeStr} â”‚  ${gzipStr}`)
                  })
              }

              if (skipped.length > 0) {
                console.log('\nğŸ’¾ æŒ‰éœ€æä¾›:')
                console.log(
                  'è·¯å¾„                                            â”‚    å¤§å° â”‚ Gzip å¤§å°',
                )
                skipped
                  .sort((a, b) => a.route.localeCompare(b.route))
                  .forEach((file) => {
                    const { size, gzip } = formatFileSize(file.size)
                    const paddedPath = file.route.padEnd(maxPathLength)
                    const sizeStr = `${size.padStart(7)} kB`
                    const gzipStr = `${gzip.padStart(7)} kB`
                    console.log(`${paddedPath} â”‚ ${sizeStr} â”‚  ${gzipStr}`)
                  })
              }
            }

            // å¦‚æœå¯ç”¨äº†è¯¦ç»†ä¿¡æ¯ï¼Œåˆ™æ˜¾ç¤ºè¯¦ç»†ä¿¡æ¯
            if (VERBOSE) {
              if (loaded.length > 0 || skipped.length > 0) {
                const allFiles = [...loaded, ...skipped].sort((a, b) =>
                  a.route.localeCompare(b.route),
                )
                console.log('\nğŸ“Š è¯¦ç»†æ–‡ä»¶ä¿¡æ¯:')
                console.log(
                  'çŠ¶æ€         â”‚ è·¯å¾„                            â”‚ MIME ç±»å‹                    â”‚ åŸå› ',
                )
                allFiles.forEach((file) => {
                  const isPreloaded = loaded.includes(file)
                  const status = isPreloaded ? 'MEMORY' : 'ON-DEMAND'
                  const reason =
                    !isPreloaded && file.size > MAX_PRELOAD_BYTES
                      ? 'å¤ªå¤§'
                      : !isPreloaded
                        ? 'å·²è¿‡æ»¤'
                        : 'å·²é¢„åŠ è½½'
                  const route =
                    file.route.length > 30
                      ? file.route.substring(0, 27) + '...'
                      : file.route
                  console.log(
                    `${status.padEnd(12)} â”‚ ${route.padEnd(30)} â”‚ ${file.type.padEnd(28)} â”‚ ${reason.padEnd(10)}`,
                  )
                })
              } else {
                console.log('\nğŸ“Š æ²¡æœ‰æ‰¾åˆ°è¦æ˜¾ç¤ºçš„æ–‡ä»¶')
              }
            }

            // åœ¨æ–‡ä»¶åˆ—è¡¨åè®°å½•æ‘˜è¦
            console.log() // ç©ºè¡Œç”¨äºåˆ†éš”
            if (loaded.length > 0) {
              log.success(
                `é¢„åŠ è½½ ${String(loaded.length)} ä¸ªæ–‡ä»¶ (${(totalPreloadedBytes / 1024 / 1024).toFixed(2)} MB) åˆ°å†…å­˜`,
              )
            } else {
              log.info('æ²¡æœ‰æ–‡ä»¶é¢„åŠ è½½åˆ°å†…å­˜')
            }

            if (skipped.length > 0) {
              const tooLarge = skipped.filter((f) => f.size > MAX_PRELOAD_BYTES).length
              const filtered = skipped.length - tooLarge
              log.info(
                `${String(skipped.length)} ä¸ªæ–‡ä»¶å°†æŒ‰éœ€æä¾› (${String(tooLarge)} å¤ªå¤§, ${String(filtered)} å·²è¿‡æ»¤)`,
              )
            }
          } catch (error) {
            log.error(
              `ä» ${clientDirectory} åŠ è½½é™æ€æ–‡ä»¶å¤±è´¥: ${String(error)}`,
            )
          }

          return { routes, loaded, skipped }
        }

        /**
        * åˆå§‹åŒ–æœåŠ¡å™¨
        */
        async function initializeServer() {
          log.header('å¯åŠ¨ç”Ÿäº§æœåŠ¡å™¨')

          // åŠ è½½ TanStack Start æœåŠ¡å™¨å¤„ç†ç¨‹åº
          let handler: { fetch: (request: Request) => Response | Promise<Response> }
          try {
            const serverModule = (await import(SERVER_ENTRY_POINT)) as {
              default: { fetch: (request: Request) => Response | Promise<Response> }
            }
            handler = serverModule.default
            log.success('TanStack Start åº”ç”¨å¤„ç†ç¨‹åºå·²åˆå§‹åŒ–')
          } catch (error) {
            log.error(`åŠ è½½æœåŠ¡å™¨å¤„ç†ç¨‹åºå¤±è´¥: ${String(error)}`)
            process.exit(1)
          }

          // ä½¿ç”¨æ™ºèƒ½é¢„åŠ è½½æ„å»ºé™æ€è·¯ç”±
          const { routes } = await initializeStaticRoutes(CLIENT_DIRECTORY)

          // åˆ›å»º Bun æœåŠ¡å™¨
          const server = Bun.serve({
            port: SERVER_PORT,

            routes: {
              // æä¾›é™æ€èµ„äº§ï¼ˆé¢„åŠ è½½æˆ–æŒ‰éœ€ï¼‰
              ...routes,

              // ä½œä¸ºåå¤‡ï¼Œå°†æ‰€æœ‰å…¶ä»–è·¯ç”±è½¬å‘ç»™ TanStack Start å¤„ç†ç¨‹åº
              '/*': (req: Request) => {
                try {
                  return handler.fetch(req)
                } catch (error) {
                  log.error(`æœåŠ¡å™¨å¤„ç†ç¨‹åºé”™è¯¯: ${String(error)}`)
                  return new Response('å†…éƒ¨æœåŠ¡å™¨é”™è¯¯', { status: 500 })
                }
              },
            },

            // å…¨å±€é”™è¯¯å¤„ç†ç¨‹åº
            error(error) {
              log.error(
                `æœªæ•è·çš„æœåŠ¡å™¨é”™è¯¯: ${error instanceof Error ? error.message : String(error)}`,
              )
              return new Response('å†…éƒ¨æœåŠ¡å™¨é”™è¯¯', { status: 500 })
            },
          })

          log.success(`æœåŠ¡å™¨æ­£åœ¨ http://localhost:${String(server.port)} ä¸Šç›‘å¬`)
        }

        // åˆå§‹åŒ–æœåŠ¡å™¨
        initializeServer().catch((error: unknown) => {
          log.error(`å¯åŠ¨æœåŠ¡å™¨å¤±è´¥: ${String(error)}`)
          process.exit(1)
        })
        ```

      </Step>
      <Step title="æ›´æ–° package.json è„šæœ¬">
        æ·»åŠ ä¸€ä¸ª `start` è„šæœ¬æ¥è¿è¡Œè‡ªå®šä¹‰æœåŠ¡å™¨:

        ```json package.json icon="file-json"
        {
          "scripts": {
            "build": "bun --bun vite build",
            "start": "bun run server.ts" // [!code ++]
          }
        }
        ```

      </Step>
      <Step title="æ„å»ºå’Œè¿è¡Œ">
        æ„å»ºæ‚¨çš„åº”ç”¨å¹¶å¯åŠ¨æœåŠ¡å™¨:

        ```sh terminal icon="terminal"
        bun run build
        bun run start
        ```

        æœåŠ¡å™¨å°†é»˜è®¤åœ¨ç«¯å£ 3000 ä¸Šå¯åŠ¨ï¼ˆå¯é€šè¿‡ `PORT` ç¯å¢ƒå˜é‡é…ç½®ï¼‰ã€‚

      </Step>
    </Steps>

  </Tab>
</Tabs>

<Columns cols={3}>
  <Card title="Vercel" href="/guides/deployment/vercel" icon="/icons/ecosystem/vercel.svg">
    éƒ¨ç½²åˆ° Vercel
  </Card>
  <Card title="Render" href="/guides/deployment/render" icon="/icons/ecosystem/render.svg">
    éƒ¨ç½²åˆ° Render
  </Card>
  <Card title="Railway" href="/guides/deployment/railway" icon="/icons/ecosystem/railway.svg">
    éƒ¨ç½²åˆ° Railway
  </Card>
  <Card title="DigitalOcean" href="/guides/deployment/digital-ocean" icon="/icons/ecosystem/digitalocean.svg">
    éƒ¨ç½²åˆ° DigitalOcean
  </Card>
  <Card title="AWS Lambda" href="/guides/deployment/aws-lambda" icon="/icons/ecosystem/aws.svg">
    éƒ¨ç½²åˆ° AWS Lambda
  </Card>
  <Card title="Google Cloud Run" href="/guides/deployment/google-cloud-run" icon="/icons/ecosystem/gcp.svg">
    éƒ¨ç½²åˆ° Google Cloud Run
  </Card>
</Columns>

---

## æ¨¡æ¿

<Columns cols={2}>
  <Card
    title="ä½¿ç”¨ Tanstack + Bun çš„å¾…åŠåº”ç”¨"
    img="/images/templates/bun-tanstack-todo.png"
    href="https://github.com/bun-templates/bun-tanstack-todo"
    arrow="true"
    cta="è½¬åˆ°æ¨¡æ¿"
  >
    ä¸€ä¸ªä½¿ç”¨ Bunã€TanStack Start å’Œ PostgreSQL æ„å»ºçš„å¾…åŠåº”ç”¨ã€‚
  </Card>
  <Card
    title="Bun + TanStack Start åº”ç”¨"
    img="/images/templates/bun-tanstack-basic.png"
    href="https://github.com/bun-templates/bun-tanstack-basic"
    arrow="true"
    cta="è½¬åˆ°æ¨¡æ¿"
  >
    ä¸€ä¸ªä½¿ç”¨ Bun çš„ TanStack Start æ¨¡æ¿ï¼Œæ”¯æŒ SSR å’ŒåŸºäºæ–‡ä»¶çš„è·¯ç”±ã€‚
  </Card>
  <Card
    title="åŸºæœ¬ Bun + Tanstack å¯åŠ¨å™¨"
    img="/images/templates/bun-tanstack-start.png"
    href="https://github.com/bun-templates/bun-tanstack-start"
    arrow="true"
    cta="è½¬åˆ°æ¨¡æ¿"
  >
    ä½¿ç”¨ Bun è¿è¡Œæ—¶å’Œ Bun æ–‡ä»¶ API çš„åŸºæœ¬ TanStack å¯åŠ¨å™¨ã€‚
  </Card>
</Columns>

---

[â†’ æŸ¥çœ‹ TanStack Start çš„å®˜æ–¹æ–‡æ¡£](https://tanstack.com/start/latest/docs/framework/react/guide/hosting) äº†è§£æœ‰å…³æ‰˜ç®¡çš„æ›´å¤šä¿¡æ¯ã€‚
