---
title: 生成子进程并使用 IPC 进行通信
sidebarTitle: 生成子进程并使用 IPC 进行通信
mode: center
---

使用 [`Bun.spawn()`](/runtime/child-process) 来生成一个子进程。当生成第二个 `bun` 进程时，可以在两个进程之间打开一个直接的进程间通信（IPC）通道。

<Note>
  此 API 仅与其他 `bun` 进程兼容。使用 `process.execPath` 获取当前运行的
  `bun` 可执行文件的路径。
</Note>

```ts parent.ts icon="/icons/typescript.svg"
const child = Bun.spawn(["bun", "child.ts"], {
  ipc(message) {
    /**
     * 从子进程接收到的消息
     **/
  },
});
```

---

父进程可以使用返回的 `Subprocess` 实例上的 `.send()` 方法向子进程发送消息。发送子进程的引用也可在 `ipc` 处理程序的第二个参数中获得。

```ts parent.ts icon="/icons/typescript.svg"
const childProc = Bun.spawn(["bun", "child.ts"], {
  ipc(message, childProc) {
    /**
     * 从子进程接收到的消息
     **/
    childProc.send("Respond to child");
  },
});

childProc.send("I am your father"); // 父进程也可以向子进程发送消息
```

---

同时，子进程可以使用 `process.send()` 向其父进程发送消息，并使用 `process.on("message")` 接收消息。这与 Node.js 中的 `child_process.fork()` 使用的 API 相同。

```ts child.ts icon="/icons/typescript.svg"
process.send("Hello from child as string");
process.send({ message: "Hello from child as object" });

process.on("message", message => {
  // 从父进程打印消息
  console.log(message);
});
```

---

所有消息都使用 JSC `serialize` API 进行序列化，这允许使用与 `postMessage` 和 `structuredClone` 支持的相同[可传输类型](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Transferable_objects)，包括字符串、类型化数组、流和对象。

```ts child.ts icon="/icons/typescript.svg"
// 发送一个字符串
process.send("Hello from child as string");

// 发送一个对象
process.send({ message: "Hello from child as object" });
```

---

请参阅 [文档 > API > 子进程](/runtime/child-process) 以获取完整文档。
