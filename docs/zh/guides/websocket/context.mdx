---
title: 在 WebSocket 上设置每个套接字的上下文数据
sidebarTitle: 上下文数据
mode: center
---

在构建 WebSocket 服务器时，通常需要存储与每个连接客户端相关的一些标识信息或上下文。

使用 [Bun.serve()](/runtime/http/websockets#contextual-data)，当连接最初通过在 `server.upgrade()` 调用中传递 [data] 参数进行升级时，这个"上下文数据"会被设置。

```ts server.ts icon="/icons/typescript.svg"
Bun.serve({
  fetch(req, server) {
    const success = server.upgrade(req, {
      data: {
        socketId: Math.random(),
      },
    });
    if (success) return undefined;

    // 正常处理 HTTP 请求
    // ...
  },
  websocket: {
    // TypeScript: 像这样指定 ws.data 的类型
    data: {} as { socketId: number },

    // 定义 websocket 处理程序
    async message(ws, message) {
      // 上下文数据作为 WebSocket 实例上的 [data] 属性可用
      console.log(`Received ${message} from ${ws.data.socketId}}`);
    },
  },
});
```

---

通常需要从传入的请求中读取 cookies/headers 以识别连接的客户端。

```ts server.ts icon="/icons/typescript.svg"
type WebSocketData = {
  createdAt: number;
  token: string;
  userId: string;
};

Bun.serve({
  async fetch(req, server) {
    // 使用库来解析 cookies
    const cookies = parseCookies(req.headers.get("Cookie"));
    const token = cookies["X-Token"];
    const user = await getUserFromToken(token);

    const upgraded = server.upgrade(req, {
      data: {
        createdAt: Date.now(),
        token: cookies["X-Token"],
        userId: user.id,
      },
    });

    if (upgraded) return undefined;
  },
  websocket: {
    // TypeScript: 像这样指定 ws.data 的类型
    data: {} as WebSocketData,

    async message(ws, message) {
      // 将消息保存到数据库
      await saveMessageToDatabase({
        message: String(message),
        userId: ws.data.userId,
      });
    },
  },
});
```
