---
title: Bun 运行时
description: 使用 Bun 的快速运行时执行 JavaScript/TypeScript 文件、package.json 脚本和可执行包。
---

import Run from "/snippets/cli/run.mdx";

Bun 运行时设计为快速启动和快速运行。

在底层，Bun 使用 [JavaScriptCore 引擎](https://developer.apple.com/documentation/javascriptcore)，这是由苹果为 Safari 开发的。在大多数情况下，启动和运行性能比 Node.js 和基于 Chromium 的浏览器使用的 V8 引擎更快。其转译器和运行时使用 Zig 编写，这是一种现代、高性能的语言。在 Linux 上，这转化为比 Node.js [快 4 倍](https://twitter.com/jarredsumner/status/1499225725492076544) 的启动时间。

| 命令            | 时间     |
| --------------- | -------- |
| `bun hello.js`  | `5.2ms`  |
| `node hello.js` | `25.1ms` |

此基准测试基于在 Linux 上运行一个简单的 Hello World 脚本

## 运行一个文件

使用 `bun run` 来执行源文件。

```bash terminal icon="terminal"
bun run index.js
```

Bun 开箱即用地支持 TypeScript 和 JSX。每个文件在执行前都会由 Bun 的快速本地转译器即时转译。

```bash terminal icon="terminal"
bun run index.js
bun run index.jsx
bun run index.ts
bun run index.tsx
```

或者，您可以省略 `run` 关键字并使用"裸露"命令；它的行为完全相同。

```bash terminal icon="terminal"
bun index.tsx
bun index.js
```

### `--watch`

要在监视模式下运行文件，请使用 `--watch` 标志。

```bash terminal icon="terminal"
bun --watch run index.tsx
```

<Note>
使用 `bun run` 时，将 Bun 标志（如 `--watch`）放在 `bun` 之后。
```bash
bun --watch run dev # ✔️ 做这个
bun run dev --watch # ❌ 不要这样做
```

出现在命令末尾的标志将被忽略并传递给 `"dev"` 脚本本身。
</Note>

## 运行 `package.json` 脚本

<Note>
对比 `npm run <script>` 或 `yarn <script>`
</Note>

```sh
bun [bun flags] run <script> [script flags]
```

您的 `package.json` 可以定义许多命名的 `"scripts"`，它们对应于 shell 命令。

```json package.json icon="file-json"
{
  // ... 其他字段
  "scripts": {
    "clean": "rm -rf dist && echo 'Done.'",
    "dev": "bun server.ts"
  }
}
```

使用 `bun run <script>` 来执行这些脚本。

```bash terminal icon="terminal"
bun run clean
rm -rf dist && echo 'Done.'
```

```txt
Cleaning...
Done.
```

Bun 在子 shell 中执行脚本命令。在 Linux 和 macOS 上，它按顺序检查以下 shell，使用找到的第一个：`bash`、`sh`、`zsh`。在 Windows 上，它使用 [bun shell](/runtime/shell) 来支持 bash 类语法和许多常用命令。

<Note>⚡️ Linux 上 `npm run` 的启动时间约为 170ms；而 Bun 是 `6ms`。</Note>

脚本也可以使用较短的命令 `bun <script>` 运行，但是如果有同名的内置 bun 命令，内置命令优先。在这种情况下，使用更明确的 `bun run <script>` 命令来执行您的包脚本。

```bash terminal icon="terminal"
bun run dev
```

要查看可用脚本列表，请运行不带任何参数的 `bun run`。

```bash terminal icon="terminal"
bun run
```

```txt
quickstart scripts:

 bun run clean
   rm -rf dist && echo 'Done.'

 bun run dev
   bun server.ts

2 scripts
```

Bun 遵循生命周期钩子。例如，如果定义了 `preclean` 和 `postclean`，`bun run clean` 将执行它们。如果 `pre<script>` 失败，Bun 将不会执行脚本本身。

### `--bun`

`package.json` 脚本通常引用本地安装的 CLI，如 `vite` 或 `next`。这些 CLI 通常是用 [shebang](<https://en.wikipedia.org/wiki/Shebang_(Unix)>) 标记的 JavaScript 文件，以表明它们应该用 `node` 执行。

```js cli.js icon="/icons/javascript.svg"
#!/usr/bin/env node

// do stuff
```

默认情况下，Bun 遵循这个 shebang 并使用 `node` 执行脚本。但是，您可以使用 `--bun` 标志覆盖此行为。对于基于 Node.js 的 CLI，这将使用 Bun 而不是 Node.js 运行 CLI。

```bash terminal icon="terminal"
bun run --bun vite
```

### 过滤

在包含多个包的单一代码库中，您可以使用 `--filter` 参数在多个包中同时执行脚本。

使用 `bun run --filter <name_pattern> <script>` 在所有名称匹配 `<name_pattern>` 的包中执行 `<script>`。
例如，如果您有包含名为 `foo`、`bar` 和 `baz` 的包的子目录，运行

```bash terminal icon="terminal"
bun run --filter 'ba*' <script>
```

将在 `bar` 和 `baz` 中执行 `<script>`，但不在 `foo` 中执行。

在 [filter](/pm/filter#running-scripts-with-filter) 的文档页面中找到更多详细信息。

## `bun run -` 从标准输入管道传输代码

`bun run -` 让您可以从 stdin 读取 JavaScript、TypeScript、TSX 或 JSX 并执行它，而无需先写入临时文件。

```bash terminal icon="terminal"
echo "console.log('Hello')" | bun run -
```

```txt
Hello
```

您还可以使用 `bun run -` 将文件重定向到 Bun。例如，要将 `.js` 文件作为 `.ts` 文件运行：

```bash terminal icon="terminal"
echo "console.log!('This is TypeScript!' as any)" > secretly-typescript.js
bun run - < secretly-typescript.js
```

```txt
This is TypeScript!
```

为了方便，使用 `bun run -` 时，所有代码都被视为具有 JSX 支持的 TypeScript。

## `bun run --console-depth`

使用 `--console-depth` 标志控制控制台输出中对象检查的深度。

```bash terminal icon="terminal"
bun --console-depth 5 run index.tsx
```

这设置了在 `console.log()` 输出中显示嵌套对象的深度。默认深度为 `2`。较高的值显示更多嵌套属性，但对于复杂对象可能产生冗长的输出。

```ts console.ts icon="/icons/typescript.svg"
const nested = { a: { b: { c: { d: "deep" } } } };
console.log(nested);
// 使用 --console-depth 2（默认）：{ a: { b: [Object] } }
// 使用 --console-depth 4：{ a: { b: { c: { d: 'deep' } } } }
```

## `bun run --smol`

在内存受限的环境中，使用 `--smol` 标志以牺牲性能为代价减少内存使用。

```bash terminal icon="terminal"
bun --smol run index.tsx
```

这会导致垃圾收集器更频繁地运行，这可能会减慢执行速度。然而，在内存有限的环境中它可能是有用的。Bun 根据可用内存自动调整垃圾收集器的堆大小（考虑 cgroups 和其他内存限制），无论是否使用 `--smol` 标志，所以这主要用于希望让堆大小增长更缓慢的情况。

## 解析顺序

绝对路径和以 `./` 或 `.\` 开头的路径总是作为源文件执行。除非使用 `bun run`，运行具有允许扩展名的文件会优先于 package.json 脚本。

当有同名的 package.json 脚本和文件时，`bun run` 优先处理 package.json 脚本。完整的解析顺序是：

1. package.json 脚本，例如 `bun run build`
2. 源文件，例如 `bun run src/main.js`
3. 来自项目包的二进制文件，例如 `bun add eslint && bun run eslint`
4. （仅 `bun run`）系统命令，例如 `bun run ls`

---

<Run />
