{
  "version": 3,
  "sources": ["../src/codegen/bindgen-lib-internal.ts"],
  "sourcesContent": [
    "// While working on this file, it is important to have very rigorous errors\n// and checking on input data. The goal is to allow people not aware of\n// various footguns in JavaScript, C++, and the bindings generator to\n// always produce correct code, or bail with an error.\nimport { expect } from \"bun:test\";\nimport type { Type, t } from \"./bindgen-lib\";\nimport * as path from \"node:path\";\nimport assert from \"node:assert\";\n\nexport const src = path.join(import.meta.dirname, \"../\");\n\nexport type TypeKind = keyof typeof t;\n\nexport let allFunctions: Func[] = [];\nexport let files = new Map<string, File>();\n/** A reachable type is one that is required for code generation */\nexport let typeHashToReachableType = new Map<string, TypeImpl>();\nexport let typeHashToStruct = new Map<string, Struct>();\nexport let typeHashToNamespace = new Map<string, string>();\nexport let structHashToSelf = new Map<string, Struct>();\n\n/** String literal */\nexport const str = (v: any) => JSON.stringify(v);\n/** Capitalize */\nexport const cap = (s: string) => s[0].toUpperCase() + s.slice(1);\n/** Escape a Zig Identifier */\nexport const zid = (s: string) => (s.match(/^[a-zA-Z_][a-zA-Z0-9_]*$/) ? s : \"@\" + str(s));\n/** Snake Case */\nexport const snake = (s: string) =>\n  s[0].toLowerCase() +\n  s\n    .slice(1)\n    .replace(/([A-Z])/g, \"_$1\")\n    .toLowerCase();\n\n// Return symbol names of extern values (must be equivalent between C++ and Zig)\n\n/** The JS Host function, aka fn (*JSC.JSGlobalObject, *JSC.CallFrame) JSValue.MaybeException */\nexport const extJsFunction = (namespaceVar: string, fnLabel: string) =>\n  `bindgen_${cap(namespaceVar)}_js${cap(fnLabel)}`;\n/** Each variant gets a dispatcher function. */\nexport const extDispatchVariant = (namespaceVar: string, fnLabel: string, variantNumber: number) =>\n  `bindgen_${cap(namespaceVar)}_dispatch${cap(fnLabel)}${variantNumber}`;\n\ninterface TypeDataDefs {\n  /** The name */\n  ref: string;\n\n  sequence: {\n    element: TypeImpl;\n    repr: \"slice\";\n  };\n  record: {\n    value: TypeImpl;\n    repr: \"kv-slices\";\n  };\n  zigEnum: {\n    file: string;\n    impl: string;\n  };\n  stringEnum: string[];\n  oneOf: TypeImpl[];\n  dictionary: DictionaryField[];\n}\ntype TypeData<K extends TypeKind> = K extends keyof TypeDataDefs ? TypeDataDefs[K] : any;\n\ninterface Flags {\n  optional?: boolean;\n  required?: boolean;\n  nullable?: boolean;\n  default?: any;\n}\n\nexport interface DictionaryField {\n  key: string;\n  type: TypeImpl;\n}\n\n/**\n * Implementation of the Type interface.  All types are immutable and hashable.\n * Hashes de-duplicate structure and union definitions. Flags do not account for\n * the hash, so `oneOf(A, B)` and `oneOf(A, B).optional` will point to the same\n * generated struct type, the purpose of the flags are to inform receivers like\n * `t.dictionary` and `fn` to mark uses as optional or provide default values.\n */\nexport class TypeImpl<K extends TypeKind = TypeKind> implements Type<any, any> {\n  kind: K;\n  data: TypeData<K>;\n  flags: Flags;\n  /** Access via .name(). */\n  nameDeduplicated: string | null | undefined = undefined;\n  /** Access via .hash() */\n  #hash: string | undefined = undefined;\n  ownerFile: string;\n\n  constructor(kind: K, data: TypeData<K>, flags: Flags = {}) {\n    this.kind = kind;\n    this.data = data;\n    this.flags = flags;\n    this.ownerFile = path.basename(stackTraceFileName(snapshotCallerLocation()), \".bind.ts\");\n  }\n\n  isVirtualArgument() {\n    return this.kind === \"globalObject\" || this.kind === \"zigVirtualMachine\";\n  }\n\n  hash() {\n    if (this.#hash) {\n      return this.#hash;\n    }\n    let h = `${this.kind}:`;\n    switch (this.kind) {\n      case \"ref\":\n        throw new Error(\"TODO\");\n      case \"sequence\":\n        h += this.data.element.hash();\n        break;\n      case \"record\":\n        h += this.data.value.hash();\n        break;\n      case \"zigEnum\":\n        h += `${this.data.file}:${this.data.impl}`;\n        break;\n      case \"stringEnum\":\n        h += this.data.join(\",\");\n        break;\n      case \"oneOf\":\n        h += this.data.map(t => t.hash()).join(\",\");\n        break;\n      case \"dictionary\":\n        h += this.data.map(({ key, required, type }) => `${key}:${required}:${type.hash()}`).join(\",\");\n        break;\n    }\n    let hash = String(Bun.hash(h));\n    this.#hash = hash;\n    return hash;\n  }\n\n  lowersToStruct() {\n    switch (this.kind) {\n      case \"ref\":\n        throw new Error(\"TODO\");\n      case \"sequence\":\n      case \"record\":\n      case \"oneOf\":\n      case \"dictionary\":\n        return true;\n      default:\n        return false;\n    }\n  }\n\n  canDirectlyMapToCAbi(): CAbiType | null {\n    let kind = this.kind;\n    switch (kind) {\n      case \"ref\":\n        throw new Error(\"TODO\");\n      case \"any\":\n        return \"JSValue\";\n      case \"ByteString\":\n        return \"bun.String\";\n      case \"DOMString\":\n        return \"bun.String\";\n      case \"USVString\":\n        return \"bun.String\";\n      case \"boolean\":\n        return \"bool\";\n      case \"strictBoolean\":\n        return \"bool\";\n      case \"f64\":\n        return \"f64\";\n      case \"usize\":\n        return \"usize\";\n      case \"globalObject\":\n      case \"zigVirtualMachine\":\n        return \"*JSGlobalObject\";\n      case \"stringEnum\":\n        throw new Error(\"TODO\");\n      case \"zigEnum\":\n        throw new Error(\"TODO\");\n      case \"undefined\":\n        return \"u0\";\n      // classes\n      case \"AbortSignal\":\n      case \"Blob\":\n      case \"BufferSource\":\n      case \"FormData\":\n      case \"ReadableStream\":\n      case \"URLSearchParams\":\n        throw new Error(\"TODO\");\n      case \"oneOf\": // `union(enum)`\n      case \"UTF8String\": // []const u8\n      case \"record\": // undecided how to lower records\n      case \"sequence\": // []const T\n        return null;\n      case \"dictionary\": {\n        let existing = typeHashToStruct.get(this.hash());\n        if (existing) return existing;\n        existing = new Struct();\n        for (const { key, type } of this.data as DictionaryField[]) {\n          if (type.flags.optional && !(\"default\" in type.flags)) {\n            return null; // ?T\n          }\n          const repr = type.canDirectlyMapToCAbi();\n          if (!repr) return null;\n\n          existing.add(key, repr);\n        }\n        existing.reorderForSmallestSize();\n        if (!structHashToSelf.has(existing.hash())) {\n          structHashToSelf.set(existing.hash(), existing);\n        }\n        existing.assignName(this.name());\n        typeHashToStruct.set(this.hash(), existing);\n        return existing;\n      }\n      case \"sequence\": {\n        return null;\n      }\n      default: {\n        throw new Error(\"unexpected: \" + (kind satisfies never));\n      }\n    }\n  }\n\n  name() {\n    if (this.nameDeduplicated) {\n      return this.nameDeduplicated;\n    }\n    const hash = this.hash();\n    const existing = typeHashToReachableType.get(hash);\n    if (existing) return (this.nameDeduplicated = existing.nameDeduplicated ??= this.#generateName());\n    return (this.nameDeduplicated = `anon_${this.kind}_${hash}`);\n  }\n\n  cppName() {\n    const name = this.name();\n    const cAbiType = this.canDirectlyMapToCAbi();\n    if (cAbiType) {\n      return cAbiTypeName(cAbiType);\n    }\n    const namespace = typeHashToNamespace.get(this.hash());\n    return namespace ? `${namespace}${cap(name)}` : name;\n  }\n\n  #generateName() {\n    return `anon_${this.ownerFile}_${this.hash()}`;\n  }\n\n  /**\n   * Name assignment is done to give readable names.\n   * The first name to a unique hash wins.\n   */\n  assignName(name: string) {\n    if (this.nameDeduplicated) return;\n    const hash = this.hash();\n    const existing = typeHashToReachableType.get(hash);\n    if (existing) {\n      this.nameDeduplicated = existing.nameDeduplicated ??= name;\n      return;\n    }\n    this.nameDeduplicated = name;\n  }\n\n  markReachable() {\n    if (!this.lowersToStruct()) return;\n    const hash = this.hash();\n    const existing = typeHashToReachableType.get(hash);\n    this.nameDeduplicated ??= existing?.name() ?? `anon_${this.kind}_${hash}`;\n    if (!existing) typeHashToReachableType.set(hash, this);\n\n    switch (this.kind) {\n      case \"ref\":\n        throw new Error(\"TODO\");\n      case \"sequence\":\n        this.data.element.markReachable();\n        break;\n      case \"record\":\n        this.data.value.markReachable();\n        break;\n      case \"oneOf\":\n        for (const type of this.data as TypeImpl[]) {\n          type.markReachable();\n        }\n        break;\n      case \"dictionary\":\n        for (const { type } of this.data as DictionaryField[]) {\n          type.markReachable();\n        }\n        break;\n    }\n  }\n\n  // Interface definition API\n  get optional() {\n    if (this.flags.required) {\n      throw new Error(\"Cannot derive optional on a required type\");\n    }\n    if (this.flags.default) {\n      throw new Error(\"Cannot derive optional on a something with a default value (default implies optional)\");\n    }\n    return new TypeImpl(this.kind, this.data, {\n      ...this.flags,\n      optional: true,\n    });\n  }\n\n  get nullable() {\n    return new TypeImpl(this.kind, this.data, {\n      ...this.flags,\n      nullable: true,\n    });\n  }\n\n  get required() {\n    if (this.flags.required) {\n      throw new Error(\"This type already has required set\");\n    }\n    if (this.flags.required) {\n      throw new Error(\"Cannot derive required on an optional type\");\n    }\n    return new TypeImpl(this.kind, this.data, {\n      ...this.flags,\n      required: true,\n    });\n  }\n\n  assertDefaultIsValid(value: unknown) {\n    switch (this.kind) {\n      case \"DOMString\":\n      case \"ByteString\":\n      case \"USVString\":\n      case \"UTF8String\":\n        if (typeof value !== \"string\") {\n          throw new Error(`Expected string, got ${inspect(value)}`);\n        }\n        break;\n      case \"boolean\":\n        if (typeof value !== \"boolean\") {\n          throw new Error(`Expected boolean, got ${inspect(value)}`);\n        }\n        break;\n      case \"f64\":\n        if (typeof value !== \"number\") {\n          throw new Error(`Expected number, got ${inspect(value)}`);\n        }\n        break;\n      case \"usize\":\n        // case \"u8\":\n        // case \"u16\":\n        // case \"u32\":\n        // case \"u64\":\n        // case \"i8\":\n        // case \"i16\":\n        // case \"i32\":\n        // case \"i64\":\n        const range = cAbiNumberLimits(this.kind);\n        if (typeof value === \"number\") {\n          if (value % 1 !== 0) {\n            throw new Error(`Expected integer, got ${inspect(value)}`);\n          }\n          if (value >= Number.MAX_SAFE_INTEGER || value <= Number.MIN_SAFE_INTEGER) {\n            throw new Error(\n              `Specify default ${this.kind} outside of max safe integer range as a BigInt to avoid precision loss`,\n            );\n          }\n          if (value < Number(range[0]) || value > Number(range[1])) {\n            throw new Error(`Expected integer in range ${range}, got ${inspect(value)}`);\n          }\n        } else if (typeof value === \"bigint\") {\n          if (value < BigInt(range[0]) || value > BigInt(range[1])) {\n            throw new Error(`Expected integer in range ${range}, got ${inspect(value)}`);\n          }\n        } else {\n          throw new Error(`Expected integer, got ${inspect(value)}`);\n        }\n        break;\n      case \"dictionary\":\n        if (typeof value !== \"object\" || value === null) {\n          throw new Error(`Expected object, got ${inspect(value)}`);\n        }\n        for (const { key, type } of this.data as DictionaryField[]) {\n          if (key in value) {\n            type.assertDefaultIsValid(value[key]);\n          } else if (type.flags.required) {\n            throw new Error(`Missing key ${key} in dictionary`);\n          }\n        }\n        break;\n      default:\n        throw new Error(`TODO: set default value on type ${this.kind}`);\n    }\n  }\n\n  emitCppDefaultValue(w: CodeWriter) {\n    const value = this.flags.default;\n    switch (this.kind) {\n      case \"boolean\":\n        w.add(value ? \"true\" : \"false\");\n        break;\n      case \"f64\":\n        w.add(String(value));\n        break;\n      case \"usize\":\n        const str = String(value);\n        w.add(`${str}ULL`);\n        break;\n      default:\n        console.log({ this: this });\n        const struct = this.structType();\n        w.line(`${this.cppName()} {`);\n        break;\n    }\n  }\n\n  structType() {\n    const direct = this.canDirectlyMapToCAbi();\n    assert(typeof direct !== \"string\");\n    if (direct) return direct;\n    throw new Error(\"TODO: generate non-extern struct for representing this data type\");\n  }\n\n  default(def: any) {\n    if (\"default\" in this.flags) {\n      throw new Error(\"This type already has a default value\");\n    }\n    if (this.flags.required) {\n      throw new Error(\"Cannot derive default on a required type\");\n    }\n    this.assertDefaultIsValid(def);\n    return new TypeImpl(this.kind, this.data, {\n      ...this.flags,\n      default: def,\n    });\n  }\n\n  [Symbol.toStringTag] = \"Type\";\n  [Bun.inspect.custom](depth, options, inspect) {\n    return (\n      `${options.stylize(\"Type\", \"special\")} ${\n        this.nameDeduplicated ? options.stylize(JSON.stringify(this.nameDeduplicated), \"string\") + \" \" : \"\"\n      }${options.stylize(\n        `[${this.kind}${[\"required\", \"optional\", \"nullable\"]\n          .filter(k => this.flags[k])\n          .map(x => \", \" + x)\n          .join(\"\")}]`,\n        \"regexp\",\n      )}` +\n      (this.data\n        ? \" \" +\n          inspect(this.data, {\n            ...options,\n            depth: options.depth === null ? null : options.depth - 1,\n          }).replace(/\\n/g, \"\\n\")\n        : \"\")\n    );\n  }\n}\n\nfunction cAbiNumberLimits(type: CAbiType) {\n  switch (type) {\n    case \"f64\":\n      return [-Infinity, Infinity];\n    case \"u8\":\n      return [0, 255];\n    case \"u16\":\n      return [0, 65535];\n    case \"u32\":\n      return [0, 4294967295];\n    case \"u64\":\n      return [0, 18446744073709551615n];\n    case \"usize\":\n      return [0, 18446744073709551615n];\n    case \"i8\":\n      return [-128, 127];\n    case \"i16\":\n      return [-32768, 32767];\n    case \"i32\":\n      return [-2147483648, 2147483647];\n    case \"i64\":\n      return [-9223372036854775808n, 9223372036854775807n];\n    default:\n      throw new Error(`Unexpected type ${type}`);\n  }\n}\n\nfunction inspect(value: any) {\n  return Bun.inspect(value, { colors: Bun.enableANSIColors });\n}\n\nexport function oneOfImpl(types: TypeImpl[]): TypeImpl {\n  const out: TypeImpl[] = [];\n  for (const type of types) {\n    if (type.kind === \"oneOf\") {\n      out.push(...type.data);\n    } else {\n      if (type.flags.nullable) {\n        throw new Error(\"Union type cannot include nullable\");\n      }\n      if (type.flags.default) {\n        throw new Error(\n          \"Union type cannot include a default value. Instead, set a default value on the union type itself\",\n        );\n      }\n      if (type.isVirtualArgument()) {\n        throw new Error(`t.${type.kind} can only be used as a function argument type`);\n      }\n      out.push(type);\n    }\n  }\n  return new TypeImpl(\"oneOf\", out);\n}\n\nexport function dictionaryImpl(record: Record<string, TypeImpl>): TypeImpl {\n  const out: DictionaryField[] = [];\n  for (const key in record) {\n    const type = record[key];\n    if (type.isVirtualArgument()) {\n      throw new Error(`t.${type.kind} can only be used as a function argument type`);\n    }\n    out.push({\n      key,\n      type: type,\n    });\n  }\n  return new TypeImpl(\"dictionary\", out);\n}\n\nexport interface Func {\n  name: string;\n  snapshot: string;\n  zigFile: string;\n  variants: Variant[];\n}\n\nexport interface Variant {\n  impl: string;\n  args: Arg[];\n  ret: TypeImpl;\n  returnStrategy?: ReturnStrategy;\n  globalObjectArg?: number | \"hidden\";\n  minRequiredArgs: number;\n}\n\nexport interface Arg {\n  name: string;\n  type: TypeImpl;\n  loweringStrategy?: ArgStrategy;\n  zigMappedName?: string;\n}\n\n/**  */\nexport type ArgStrategy = { type: \"c-abi-pointer\"; abiType: CAbiType } | { type: \"c-abi-value\"; abiType: CAbiType };\n\n/**\n * In addition to moving a payload over, an additional bit of information\n * crosses the ABI boundary indicating if the function threw an exception.\n *\n * For simplicity, the possibility of any Zig binding returning an error/calling\n * `throw` is assumed and there isnt a way to disable the exception check.\n */\nexport type ReturnStrategy =\n  // JSValue is special cased because it encodes exception as 0x0\n  | { type: \"jsvalue\" }\n  // For primitives and simple structures where direct assignment into a\n  // pointer is possible. function returns a boolean indicating success/error.\n  | { type: \"basic-out-param\"; abiType: CAbiType };\n\nexport interface File {\n  functions: Func[];\n  typedefs: TypeDef[];\n}\n\nexport interface TypeDef {\n  name: string;\n  type: TypeImpl;\n}\n\nexport function registerFunction(opts: any) {\n  const snapshot = snapshotCallerLocation();\n  const filename = stackTraceFileName(snapshot);\n  expect(filename).toEndWith(\".bind.ts\");\n  const zigFile = path.relative(src, filename.replace(/\\.bind\\.ts$/, \".zig\"));\n  let file = files.get(zigFile);\n  if (!file) {\n    file = { functions: [], typedefs: [] };\n    files.set(zigFile, file);\n  }\n  const variants: Variant[] = [];\n  if (\"variants\" in opts) {\n    let i = 1;\n    for (const variant of opts.variants) {\n      const { minRequiredArgs } = validateVariant(variant);\n      variants.push({\n        ...variant,\n        impl: opts.name + i,\n        minRequiredArgs,\n      });\n      i++;\n    }\n  } else {\n    const { minRequiredArgs } = validateVariant(opts);\n    variants.push({\n      impl: opts.name,\n      args: Object.entries(opts.args).map(([name, type]) => ({ name, type })) as Arg[],\n      ret: opts.ret,\n      minRequiredArgs,\n    });\n  }\n\n  const func: Func = {\n    name: opts.name,\n    snapshot,\n    zigFile,\n    variants,\n  };\n  allFunctions.push(func);\n  file.functions.push(func);\n}\n\nfunction validateVariant(variant: any) {\n  let minRequiredArgs = 0;\n  let seenOptionalArgument = false;\n  let i = 0;\n  console.log(variant);\n\n  for (const [name, type] of Object.entries(variant.args) as [string, TypeImpl][]) {\n    if (!(type instanceof TypeImpl)) {\n      throw new Error(`Expected type for argument ${name}, got ${inspect(type)}`);\n    }\n    i += 1;\n    if (type.isVirtualArgument()) {\n      continue;\n    }\n    if (!type.flags.optional && !(\"default\" in type.flags)) {\n      if (seenOptionalArgument) {\n        throw new Error(`Required argument ${name} cannot follow an optional argument`);\n      }\n      minRequiredArgs++;\n    } else {\n      seenOptionalArgument = true;\n    }\n  }\n\n  return { minRequiredArgs };\n}\n\nfunction snapshotCallerLocation(): string {\n  const stack = new Error().stack!;\n  const lines = stack.split(\"\\n\");\n  let i = 1;\n  for (; i < lines.length; i++) {\n    if (!lines[i].includes(import.meta.dir)) {\n      return lines[i];\n    }\n  }\n  throw new Error(\"Couldn't find caller location in stack trace\");\n}\n\nfunction stackTraceFileName(line: string): string {\n  return / \\(((?:[A-Za-z]:)?.*?)[:)]/.exec(line)![1].replaceAll(\"\\\\\", \"/\");\n}\n\ntype CAbiType =\n  | \"*anyopaque\"\n  | \"*JSGlobalObject\"\n  | \"JSValue\"\n  | \"JSValue.MaybeException\"\n  | \"u0\"\n  | \"bun.String\"\n  | \"bool\"\n  | \"u8\"\n  | \"u16\"\n  | \"u32\"\n  | \"u64\"\n  | \"usize\"\n  | \"i8\"\n  | \"i16\"\n  | \"i32\"\n  | \"i64\"\n  | \"f64\"\n  | Struct;\n\nexport function cAbiTypeInfo(type: CAbiType): [size: number, align: number] {\n  if (typeof type !== \"string\") {\n    return type.abiInfo();\n  }\n  switch (type) {\n    case \"u0\":\n      return [0, 0]; // no-op\n    case \"bool\":\n    case \"u8\":\n    case \"i8\":\n      return [1, 1];\n    case \"u16\":\n    case \"i16\":\n      return [2, 2];\n    case \"u32\":\n    case \"i32\":\n      return [4, 4];\n    case \"usize\":\n    case \"u64\":\n    case \"i64\":\n    case \"f64\":\n      return [8, 8];\n    case \"*anyopaque\":\n    case \"*JSGlobalObject\":\n    case \"JSValue\":\n    case \"JSValue.MaybeException\":\n      return [8, 8]; // pointer size\n    case \"bun.String\":\n      return [24, 8];\n    default:\n      throw new Error(\"unexpected: \" + (type satisfies never));\n  }\n}\n\nexport function cAbiTypeName(type: CAbiType) {\n  if (typeof type !== \"string\") {\n    return type.name();\n  }\n  return (\n    {\n      \"*anyopaque\": \"void*\",\n      \"*JSGlobalObject\": \"JSC::JSGlobalObject*\",\n      \"JSValue\": \"JSValue\",\n      \"JSValue.MaybeException\": \"JSValue\",\n      \"bool\": \"bool\",\n      \"u8\": \"uint8_t\",\n      \"u16\": \"uint16_t\",\n      \"u32\": \"uint32_t\",\n      \"u64\": \"uint64_t\",\n      \"i8\": \"int8_t\",\n      \"i16\": \"int16_t\",\n      \"i32\": \"int32_t\",\n      \"i64\": \"int64_t\",\n      \"f64\": \"double\",\n      \"usize\": \"size_t\",\n      \"bun.String\": \"BunString\",\n      u0: \"void\",\n    } satisfies Record<Extract<CAbiType, string>, string>\n  )[type];\n}\n\nfunction alignForward(size: number, alignment: number) {\n  return (size + alignment - 1) & ~(alignment - 1);\n}\n\nclass Struct {\n  fields: StructField[] = [];\n  #hash?: string;\n  #name?: string;\n  namespace?: string;\n\n  abiInfo(): [size: number, align: number] {\n    let size = 0;\n    let align = 0;\n    for (const field of this.fields) {\n      size = alignForward(size, field.naturalAlignment);\n      size += field.size;\n      align = Math.max(align, field.naturalAlignment);\n    }\n    return [size, align];\n  }\n\n  reorderForSmallestSize() {\n    // for conistency sort by alignment, then size, then name\n    this.fields.sort((a, b) => {\n      if (a.naturalAlignment !== b.naturalAlignment) {\n        return a.naturalAlignment - b.naturalAlignment;\n      }\n      if (a.size !== b.size) {\n        return a.size - b.size;\n      }\n      return a.name.localeCompare(b.name);\n    });\n  }\n\n  hash() {\n    return (this.#hash ??= String(\n      Bun.hash(\n        this.fields\n          .map(f => {\n            if (f.type instanceof Struct) {\n              return f.name + `:` + f.type.hash();\n            }\n            return f.name + `:` + f.type;\n          })\n          .join(\",\"),\n      ),\n    ));\n  }\n\n  name() {\n    if (this.#name) return this.#name;\n    const hash = this.hash();\n    const existing = structHashToSelf.get(hash);\n    if (existing && existing !== this) return (this.#name = existing.name());\n    return (this.#name = `anon_extern_struct_${hash}`);\n  }\n\n  toString() {\n    return this.namespace ? `${this.namespace}.${this.name()}` : this.name();\n  }\n\n  assignName(name: string) {\n    if (this.#name) return;\n    const hash = this.hash();\n    const existing = structHashToSelf.get(hash);\n    if (existing && existing.#name) name = existing.#name;\n    this.#name = name;\n    if (existing) existing.#name = name;\n  }\n\n  add(name: string, cType: CAbiType) {\n    const [size, naturalAlignment] = cAbiTypeInfo(cType);\n    this.fields.push({ name, type: cType, size, naturalAlignment });\n  }\n\n  emitZig(zig: CodeWriter, semi: \"with-semi\" | \"no-semi\") {\n    zig.line(\"extern struct {\");\n    zig.indent();\n    for (const field of this.fields) {\n      zig.line(`${snake(field.name)}: ${field.type},`);\n    }\n    zig.dedent();\n    zig.line(\"}\" + (semi === \"with-semi\" ? \";\" : \"\"));\n  }\n\n  emitCpp(cpp: CodeWriter, structName: string) {\n    cpp.line(`struct ${structName} {`);\n    cpp.indent();\n    for (const field of this.fields) {\n      cpp.line(`${cAbiTypeName(field.type)} ${field.name};`);\n    }\n    cpp.dedent();\n    cpp.line(\"};\");\n  }\n}\n\nexport interface StructField {\n  /** camel case */\n  name: string;\n  type: CAbiType;\n  size: number;\n  naturalAlignment: number;\n}\n\nexport class CodeWriter {\n  level = 0;\n  buffer = \"\";\n\n  line(s?: string) {\n    this.add((s ?? \"\") + \"\\n\");\n  }\n\n  add(s: string) {\n    this.buffer += (this.buffer.endsWith(\"\\n\") ? \"    \".repeat(this.level) : \"\") + s;\n  }\n\n  indent() {\n    this.level += 1;\n  }\n\n  dedent() {\n    this.level -= 1;\n  }\n\n  trimLastNewline() {\n    this.buffer = this.buffer.trimEnd();\n  }\n}\n"
  ],
  "mappings": "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",
  "debugId": "66889C711D1FD57564756E2164756E21",
  "names": []
}