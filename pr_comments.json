[{"url":"https://api.github.com/repos/oven-sh/bun/pulls/comments/2280238448","pull_request_review_id":3125654553,"id":2280238448,"node_id":"PRRC_kwDOFVKCyc6H6a1w","diff_hunk":"@@ -72,6 +73,48 @@ JSC_DEFINE_HOST_FUNCTION(getExtraCACertificates, (JSC::JSGlobalObject * globalOb\n     RELEASE_AND_RETURN(scope, JSValue::encode(JSC::objectConstructorFreeze(globalObject, rootCertificates)));\n }\n \n+JSC_DEFINE_HOST_FUNCTION(getSystemCACertificates, (JSC::JSGlobalObject * globalObject, JSC::CallFrame* callFrame))\n+{\n+    auto scope = DECLARE_THROW_SCOPE(globalObject->vm());\n+    VM& vm = globalObject->vm();\n+\n+    STACK_OF(X509)* root_system_cert_instances = us_get_root_system_cert_instances();\n+\n+    auto size = sk_X509_num(root_system_cert_instances);\n+    if (size < 0) size = 0; // root_system_cert_instances is nullptr\n+\n+    auto rootCertificates = JSC::JSArray::create(vm, globalObject->arrayStructureForIndexingTypeDuringAllocation(JSC::ArrayWithContiguous), size);","path":"src/bun.js/bindings/NodeTLS.cpp","commit_id":"1e05f26c3ba1dc7d90fcd3c1fb90348db3734849","original_commit_id":"4fbd6d240d54ff25bdd5315152a15d1a308b889d","user":{"login":"Jarred-Sumner","id":709451,"node_id":"MDQ6VXNlcjcwOTQ1MQ==","avatar_url":"https://avatars.githubusercontent.com/u/709451?v=4","gravatar_id":"","url":"https://api.github.com/users/Jarred-Sumner","html_url":"https://github.com/Jarred-Sumner","followers_url":"https://api.github.com/users/Jarred-Sumner/followers","following_url":"https://api.github.com/users/Jarred-Sumner/following{/other_user}","gists_url":"https://api.github.com/users/Jarred-Sumner/gists{/gist_id}","starred_url":"https://api.github.com/users/Jarred-Sumner/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/Jarred-Sumner/subscriptions","organizations_url":"https://api.github.com/users/Jarred-Sumner/orgs","repos_url":"https://api.github.com/users/Jarred-Sumner/repos","events_url":"https://api.github.com/users/Jarred-Sumner/events{/privacy}","received_events_url":"https://api.github.com/users/Jarred-Sumner/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"This code should be rewritten to use a MarkedArgumentsBuffer, append to the marked arguments buffer, and then at the end use JSC::objectConstructorFreeze(JSC::constructArray on that marked arguments buffer","created_at":"2025-08-16T04:55:27Z","updated_at":"2025-08-16T04:55:28Z","html_url":"https://github.com/oven-sh/bun/pull/21898#discussion_r2280238448","pull_request_url":"https://api.github.com/repos/oven-sh/bun/pulls/21898","author_association":"MEMBER","_links":{"self":{"href":"https://api.github.com/repos/oven-sh/bun/pulls/comments/2280238448"},"html":{"href":"https://github.com/oven-sh/bun/pull/21898#discussion_r2280238448"},"pull_request":{"href":"https://api.github.com/repos/oven-sh/bun/pulls/21898"}},"reactions":{"url":"https://api.github.com/repos/oven-sh/bun/pulls/comments/2280238448/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":86,"side":"RIGHT","original_position":22,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/oven-sh/bun/pulls/comments/2280238592","pull_request_review_id":3125654689,"id":2280238592,"node_id":"PRRC_kwDOFVKCyc6H6a4A","diff_hunk":"@@ -0,0 +1,60 @@\n+#ifdef _WIN32\n+\n+#include <windows.h>\n+#include <wincrypt.h>\n+#include <vector>\n+#include <cstring>\n+\n+// Forward declaration to avoid including OpenSSL headers here\n+// This prevents conflicts with Windows macros like X509_NAME\n+\n+// Structure to hold raw certificate data\n+struct RawCertificate {\n+  std::vector<unsigned char> data;\n+};\n+\n+// Helper function to load raw certificates from a Windows certificate store\n+static void LoadRawCertsFromStore(std::vector<RawCertificate>& raw_certs, \n+                                  DWORD store_flags, \n+                                  const wchar_t* store_name) {\n+  HCERTSTORE cert_store = CertOpenStore(\n+    CERT_STORE_PROV_SYSTEM_W,\n+    0,\n+    0,\n+    store_flags | CERT_STORE_READONLY_FLAG,\n+    store_name\n+  );\n+  \n+  if (cert_store == NULL) {\n+    return;\n+  }\n+  \n+  PCCERT_CONTEXT cert_context = NULL;\n+  while ((cert_context = CertEnumCertificatesInStore(cert_store, cert_context)) != NULL) {\n+    RawCertificate raw_cert;\n+    raw_cert.data.assign(cert_context->pbCertEncoded, \n+                        cert_context->pbCertEncoded + cert_context->cbCertEncoded);\n+    raw_certs.push_back(std::move(raw_cert));\n+  }\n+  \n+  CertCloseStore(cert_store, 0);\n+}\n+\n+// Main function to load raw system certificates on Windows\n+// Returns certificates as raw DER data to avoid OpenSSL header conflicts\n+extern \"C\" void us_load_system_certificates_windows_raw(","path":"packages/bun-usockets/src/crypto/root_certs_windows.cpp","commit_id":"1e05f26c3ba1dc7d90fcd3c1fb90348db3734849","original_commit_id":"4fbd6d240d54ff25bdd5315152a15d1a308b889d","user":{"login":"Jarred-Sumner","id":709451,"node_id":"MDQ6VXNlcjcwOTQ1MQ==","avatar_url":"https://avatars.githubusercontent.com/u/709451?v=4","gravatar_id":"","url":"https://api.github.com/users/Jarred-Sumner","html_url":"https://github.com/Jarred-Sumner","followers_url":"https://api.github.com/users/Jarred-Sumner/followers","following_url":"https://api.github.com/users/Jarred-Sumner/following{/other_user}","gists_url":"https://api.github.com/users/Jarred-Sumner/gists{/gist_id}","starred_url":"https://api.github.com/users/Jarred-Sumner/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/Jarred-Sumner/subscriptions","organizations_url":"https://api.github.com/users/Jarred-Sumner/orgs","repos_url":"https://api.github.com/users/Jarred-Sumner/repos","events_url":"https://api.github.com/users/Jarred-Sumner/events{/privacy}","received_events_url":"https://api.github.com/users/Jarred-Sumner/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"why is this extern \"C\"? why not extern and then a reference to the vector?","created_at":"2025-08-16T04:56:13Z","updated_at":"2025-08-16T04:56:13Z","html_url":"https://github.com/oven-sh/bun/pull/21898#discussion_r2280238592","pull_request_url":"https://api.github.com/repos/oven-sh/bun/pulls/21898","author_association":"MEMBER","_links":{"self":{"href":"https://api.github.com/repos/oven-sh/bun/pulls/comments/2280238592"},"html":{"href":"https://github.com/oven-sh/bun/pull/21898#discussion_r2280238592"},"pull_request":{"href":"https://api.github.com/repos/oven-sh/bun/pulls/21898"}},"reactions":{"url":"https://api.github.com/repos/oven-sh/bun/pulls/comments/2280238592/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":45,"side":"RIGHT","original_position":45,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/oven-sh/bun/pulls/comments/2280239781","pull_request_review_id":3125655667,"id":2280239781,"node_id":"PRRC_kwDOFVKCyc6H6bKl","diff_hunk":"@@ -3743,6 +3743,14 @@ pub fn contains(item: anytype, list: *const std.ArrayListUnmanaged(@TypeOf(item)\n \n pub const safety = @import(\"./safety.zig\");\n \n+// Export function to check if --use-system-ca flag is set\n+pub fn getUseSystemCA(globalObject: *jsc.JSGlobalObject, callFrame: *jsc.CallFrame) error{ JSError, OutOfMemory }!jsc.JSValue {\n+    _ = globalObject;\n+    _ = callFrame;\n+    const use_system_ca = @extern(*bool, .{ .name = \"Bun__Node__UseSystemCA\" });","path":"src/bun.zig","commit_id":"1e05f26c3ba1dc7d90fcd3c1fb90348db3734849","original_commit_id":"4fbd6d240d54ff25bdd5315152a15d1a308b889d","user":{"login":"Jarred-Sumner","id":709451,"node_id":"MDQ6VXNlcjcwOTQ1MQ==","avatar_url":"https://avatars.githubusercontent.com/u/709451?v=4","gravatar_id":"","url":"https://api.github.com/users/Jarred-Sumner","html_url":"https://github.com/Jarred-Sumner","followers_url":"https://api.github.com/users/Jarred-Sumner/followers","following_url":"https://api.github.com/users/Jarred-Sumner/following{/other_user}","gists_url":"https://api.github.com/users/Jarred-Sumner/gists{/gist_id}","starred_url":"https://api.github.com/users/Jarred-Sumner/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/Jarred-Sumner/subscriptions","organizations_url":"https://api.github.com/users/Jarred-Sumner/orgs","repos_url":"https://api.github.com/users/Jarred-Sumner/repos","events_url":"https://api.github.com/users/Jarred-Sumner/events{/privacy}","received_events_url":"https://api.github.com/users/Jarred-Sumner/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"why are we using an extern here instead of reading it from the correct variable","created_at":"2025-08-16T04:57:53Z","updated_at":"2025-08-16T04:57:53Z","html_url":"https://github.com/oven-sh/bun/pull/21898#discussion_r2280239781","pull_request_url":"https://api.github.com/repos/oven-sh/bun/pulls/21898","author_association":"MEMBER","_links":{"self":{"href":"https://api.github.com/repos/oven-sh/bun/pulls/comments/2280239781"},"html":{"href":"https://github.com/oven-sh/bun/pull/21898#discussion_r2280239781"},"pull_request":{"href":"https://api.github.com/repos/oven-sh/bun/pulls/21898"}},"reactions":{"url":"https://api.github.com/repos/oven-sh/bun/pulls/comments/2280239781/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":3750,"side":"RIGHT","original_position":8,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/oven-sh/bun/pulls/comments/2311703951","pull_request_review_id":3170766628,"id":2311703951,"node_id":"PRRC_kwDOFVKCyc6Jyc2P","diff_hunk":"@@ -0,0 +1,423 @@\n+#ifdef __APPLE__\n+\n+#include <dlfcn.h>\n+#include <CoreFoundation/CoreFoundation.h>\n+#include <atomic>\n+#include <openssl/x509.h>\n+#include <openssl/x509_vfy.h>\n+#include <stdio.h>\n+\n+// Security framework types and constants - dynamically loaded\n+typedef struct OpaqueSecCertificateRef* SecCertificateRef;\n+typedef struct OpaqueSecTrustRef* SecTrustRef;\n+typedef struct OpaqueSecPolicyRef* SecPolicyRef;\n+typedef int32_t OSStatus;\n+typedef uint32_t SecTrustSettingsDomain;\n+\n+// Security framework constants\n+enum {\n+    errSecSuccess = 0,\n+    errSecItemNotFound = -25300,\n+};\n+\n+// Trust settings domains\n+enum {\n+    kSecTrustSettingsDomainUser = 0,\n+    kSecTrustSettingsDomainAdmin = 1,\n+    kSecTrustSettingsDomainSystem = 2,\n+};\n+\n+// Trust status enumeration\n+enum class TrustStatus {\n+    TRUSTED,\n+    DISTRUSTED,\n+    UNSPECIFIED\n+};\n+\n+// Dynamic Security framework loader\n+class SecurityFramework {\n+public:\n+    void* handle;\n+    void* cf_handle;\n+    \n+    // Core Foundation constants\n+    CFStringRef kSecClass;\n+    CFStringRef kSecClassCertificate;\n+    CFStringRef kSecMatchLimit;\n+    CFStringRef kSecMatchLimitAll;\n+    CFStringRef kSecReturnRef;\n+    CFBooleanRef kCFBooleanTrue;\n+    CFAllocatorRef kCFAllocatorDefault;\n+    CFArrayCallBacks* kCFTypeArrayCallBacks;\n+    CFDictionaryKeyCallBacks* kCFTypeDictionaryKeyCallBacks;\n+    CFDictionaryValueCallBacks* kCFTypeDictionaryValueCallBacks;\n+    \n+    // Core Foundation function pointers\n+    CFMutableArrayRef (*CFArrayCreateMutable)(CFAllocatorRef allocator, CFIndex capacity, const CFArrayCallBacks *callBacks);\n+    CFArrayRef (*CFArrayCreate)(CFAllocatorRef allocator, const void **values, CFIndex numValues, const CFArrayCallBacks *callBacks);\n+    void (*CFArraySetValueAtIndex)(CFMutableArrayRef theArray, CFIndex idx, const void *value);\n+    const void* (*CFArrayGetValueAtIndex)(CFArrayRef theArray, CFIndex idx);\n+    CFIndex (*CFArrayGetCount)(CFArrayRef theArray);\n+    void (*CFRelease)(CFTypeRef cf);\n+    CFDictionaryRef (*CFDictionaryCreate)(CFAllocatorRef allocator, const void **keys, const void **values, CFIndex numValues, const CFDictionaryKeyCallBacks *keyCallBacks, const CFDictionaryValueCallBacks *valueCallBacks);\n+    const UInt8* (*CFDataGetBytePtr)(CFDataRef theData);\n+    CFIndex (*CFDataGetLength)(CFDataRef theData);\n+    \n+    // Security framework function pointers\n+    OSStatus (*SecItemCopyMatching)(CFDictionaryRef query, CFTypeRef *result);\n+    CFDataRef (*SecCertificateCopyData)(SecCertificateRef certificate);\n+    OSStatus (*SecTrustCreateWithCertificates)(CFArrayRef certificates, CFArrayRef policies, SecTrustRef *trust);\n+    SecPolicyRef (*SecPolicyCreateSSL)(Boolean server, CFStringRef hostname);\n+    Boolean (*SecTrustEvaluateWithError)(SecTrustRef trust, CFErrorRef *error);\n+    OSStatus (*SecTrustSettingsCopyTrustSettings)(SecCertificateRef certRef, SecTrustSettingsDomain domain, CFArrayRef *trustSettings);\n+    \n+    SecurityFramework() : handle(nullptr), cf_handle(nullptr),\n+                         kSecClass(nullptr), kSecClassCertificate(nullptr),\n+                         kSecMatchLimit(nullptr), kSecMatchLimitAll(nullptr),\n+                         kSecReturnRef(nullptr), kCFBooleanTrue(nullptr),\n+                         kCFAllocatorDefault(nullptr), kCFTypeArrayCallBacks(nullptr),\n+                         kCFTypeDictionaryKeyCallBacks(nullptr), kCFTypeDictionaryValueCallBacks(nullptr),\n+                         CFArrayCreateMutable(nullptr), CFArrayCreate(nullptr),\n+                         CFArraySetValueAtIndex(nullptr), CFArrayGetValueAtIndex(nullptr),\n+                         CFArrayGetCount(nullptr), CFRelease(nullptr),\n+                         CFDictionaryCreate(nullptr), CFDataGetBytePtr(nullptr), CFDataGetLength(nullptr),\n+                         SecItemCopyMatching(nullptr), SecCertificateCopyData(nullptr),\n+                         SecTrustCreateWithCertificates(nullptr), SecPolicyCreateSSL(nullptr),\n+                         SecTrustEvaluateWithError(nullptr), SecTrustSettingsCopyTrustSettings(nullptr) {}\n+    \n+    ~SecurityFramework() {\n+        if (handle) {\n+            dlclose(handle);\n+        }\n+        if (cf_handle) {\n+            dlclose(cf_handle);\n+        }\n+    }\n+    \n+    bool load() {\n+        if (handle && cf_handle) return true; // Already loaded\n+        \n+        // Load CoreFoundation framework\n+        cf_handle = dlopen(\"/System/Library/Frameworks/CoreFoundation.framework/CoreFoundation\", RTLD_LAZY | RTLD_LOCAL);\n+        if (!cf_handle) {\n+            fprintf(stderr, \"Failed to load CoreFoundation framework: %s\\n\", dlerror());\n+            return false;\n+        }\n+        \n+        // Load Security framework\n+        handle = dlopen(\"/System/Library/Frameworks/Security.framework/Security\", RTLD_LAZY | RTLD_LOCAL);\n+        if (!handle) {\n+            fprintf(stderr, \"Failed to load Security framework: %s\\n\", dlerror());\n+            dlclose(cf_handle);\n+            cf_handle = nullptr;\n+            return false;\n+        }\n+        \n+        // Load constants and functions\n+        if (!load_constants()) {\n+            if (handle) {\n+                dlclose(handle);\n+                handle = nullptr;\n+            }\n+            if (cf_handle) {\n+                dlclose(cf_handle);\n+                cf_handle = nullptr;\n+            }\n+            return false;\n+        }\n+        \n+        if (!load_functions()) {\n+            if (handle) {\n+                dlclose(handle);\n+                handle = nullptr;\n+            }\n+            if (cf_handle) {\n+                dlclose(cf_handle);\n+                cf_handle = nullptr;\n+            }\n+            return false;\n+        }\n+        \n+        return true;\n+    }\n+\n+private:\n+    bool load_constants() {\n+        // Load Security framework constants\n+        void* ptr = dlsym(handle, \"kSecClass\");\n+        if (!ptr) { fprintf(stderr, \"DEBUG: kSecClass not found\\n\"); return false; }\n+        kSecClass = *(CFStringRef*)ptr;\n+        \n+        ptr = dlsym(handle, \"kSecClassCertificate\");\n+        if (!ptr) { fprintf(stderr, \"DEBUG: kSecClassCertificate not found\\n\"); return false; }\n+        kSecClassCertificate = *(CFStringRef*)ptr;\n+        \n+        ptr = dlsym(handle, \"kSecMatchLimit\");\n+        if (!ptr) { fprintf(stderr, \"DEBUG: kSecMatchLimit not found\\n\"); return false; }\n+        kSecMatchLimit = *(CFStringRef*)ptr;\n+        \n+        ptr = dlsym(handle, \"kSecMatchLimitAll\");\n+        if (!ptr) { fprintf(stderr, \"DEBUG: kSecMatchLimitAll not found\\n\"); return false; }\n+        kSecMatchLimitAll = *(CFStringRef*)ptr;\n+        \n+        ptr = dlsym(handle, \"kSecReturnRef\");\n+        if (!ptr) { fprintf(stderr, \"DEBUG: kSecReturnRef not found\\n\"); return false; }\n+        kSecReturnRef = *(CFStringRef*)ptr;\n+        \n+        // Load CoreFoundation constants\n+        ptr = dlsym(cf_handle, \"kCFBooleanTrue\");\n+        if (!ptr) { fprintf(stderr, \"DEBUG: kCFBooleanTrue not found\\n\"); return false; }\n+        kCFBooleanTrue = *(CFBooleanRef*)ptr;\n+        \n+        ptr = dlsym(cf_handle, \"kCFAllocatorDefault\");\n+        if (!ptr) { fprintf(stderr, \"DEBUG: kCFAllocatorDefault not found\\n\"); return false; }\n+        kCFAllocatorDefault = *(CFAllocatorRef*)ptr;\n+        \n+        ptr = dlsym(cf_handle, \"kCFTypeArrayCallBacks\");\n+        if (!ptr) { fprintf(stderr, \"DEBUG: kCFTypeArrayCallBacks not found\\n\"); return false; }\n+        kCFTypeArrayCallBacks = (CFArrayCallBacks*)ptr;\n+        \n+        ptr = dlsym(cf_handle, \"kCFTypeDictionaryKeyCallBacks\");\n+        if (!ptr) { fprintf(stderr, \"DEBUG: kCFTypeDictionaryKeyCallBacks not found\\n\"); return false; }\n+        kCFTypeDictionaryKeyCallBacks = (CFDictionaryKeyCallBacks*)ptr;\n+        \n+        ptr = dlsym(cf_handle, \"kCFTypeDictionaryValueCallBacks\");\n+        if (!ptr) { fprintf(stderr, \"DEBUG: kCFTypeDictionaryValueCallBacks not found\\n\"); return false; }\n+        kCFTypeDictionaryValueCallBacks = (CFDictionaryValueCallBacks*)ptr;\n+        \n+        return true;\n+    }\n+    \n+    bool load_functions() {\n+        // Load CoreFoundation functions\n+        CFArrayCreateMutable = (CFMutableArrayRef (*)(CFAllocatorRef, CFIndex, const CFArrayCallBacks*))dlsym(cf_handle, \"CFArrayCreateMutable\");\n+        CFArrayCreate = (CFArrayRef (*)(CFAllocatorRef, const void**, CFIndex, const CFArrayCallBacks*))dlsym(cf_handle, \"CFArrayCreate\");\n+        CFArraySetValueAtIndex = (void (*)(CFMutableArrayRef, CFIndex, const void*))dlsym(cf_handle, \"CFArraySetValueAtIndex\");\n+        CFArrayGetValueAtIndex = (const void* (*)(CFArrayRef, CFIndex))dlsym(cf_handle, \"CFArrayGetValueAtIndex\");\n+        CFArrayGetCount = (CFIndex (*)(CFArrayRef))dlsym(cf_handle, \"CFArrayGetCount\");\n+        CFRelease = (void (*)(CFTypeRef))dlsym(cf_handle, \"CFRelease\");\n+        CFDictionaryCreate = (CFDictionaryRef (*)(CFAllocatorRef, const void**, const void**, CFIndex, const CFDictionaryKeyCallBacks*, const CFDictionaryValueCallBacks*))dlsym(cf_handle, \"CFDictionaryCreate\");\n+        CFDataGetBytePtr = (const UInt8* (*)(CFDataRef))dlsym(cf_handle, \"CFDataGetBytePtr\");\n+        CFDataGetLength = (CFIndex (*)(CFDataRef))dlsym(cf_handle, \"CFDataGetLength\");\n+        \n+        // Load Security framework functions\n+        SecItemCopyMatching = (OSStatus (*)(CFDictionaryRef, CFTypeRef*))dlsym(handle, \"SecItemCopyMatching\");\n+        SecCertificateCopyData = (CFDataRef (*)(SecCertificateRef))dlsym(handle, \"SecCertificateCopyData\");\n+        SecTrustCreateWithCertificates = (OSStatus (*)(CFArrayRef, CFArrayRef, SecTrustRef*))dlsym(handle, \"SecTrustCreateWithCertificates\");\n+        SecPolicyCreateSSL = (SecPolicyRef (*)(Boolean, CFStringRef))dlsym(handle, \"SecPolicyCreateSSL\");\n+        SecTrustEvaluateWithError = (Boolean (*)(SecTrustRef, CFErrorRef*))dlsym(handle, \"SecTrustEvaluateWithError\");\n+        SecTrustSettingsCopyTrustSettings = (OSStatus (*)(SecCertificateRef, SecTrustSettingsDomain, CFArrayRef*))dlsym(handle, \"SecTrustSettingsCopyTrustSettings\");\n+        \n+        return CFArrayCreateMutable && CFArrayCreate && CFArraySetValueAtIndex &&\n+               CFArrayGetValueAtIndex && CFArrayGetCount && CFRelease &&\n+               CFDictionaryCreate && CFDataGetBytePtr && CFDataGetLength &&\n+               SecItemCopyMatching && SecCertificateCopyData &&\n+               SecTrustCreateWithCertificates && SecPolicyCreateSSL &&\n+               SecTrustEvaluateWithError && SecTrustSettingsCopyTrustSettings;\n+    }\n+};\n+\n+// Global instance for dynamic loading\n+static std::atomic<SecurityFramework*> g_security_framework{nullptr};\n+\n+static SecurityFramework* get_security_framework() {\n+    SecurityFramework* framework = g_security_framework.load();\n+    if (!framework) {\n+        SecurityFramework* new_framework = new SecurityFramework();\n+        if (new_framework->load()) {\n+            SecurityFramework* expected = nullptr;\n+            if (g_security_framework.compare_exchange_strong(expected, new_framework)) {\n+                framework = new_framework;\n+            } else {\n+                delete new_framework;\n+                framework = expected;\n+            }\n+        } else {\n+            delete new_framework;\n+            framework = nullptr;\n+        }\n+    }\n+    return framework;\n+}\n+\n+// Helper function to determine if a certificate is self-issued\n+static bool is_certificate_self_issued(X509* cert) {\n+    X509_NAME* subject = X509_get_subject_name(cert);\n+    X509_NAME* issuer = X509_get_issuer_name(cert);\n+    \n+    return subject && issuer && X509_NAME_cmp(subject, issuer) == 0;\n+}\n+\n+// Validate certificate trust using Security framework\n+static bool is_certificate_trust_valid(SecurityFramework* security, SecCertificateRef cert_ref) {\n+    CFMutableArrayRef subj_certs = security->CFArrayCreateMutable(nullptr, 1, security->kCFTypeArrayCallBacks);\n+    if (!subj_certs) return false;\n+    \n+    security->CFArraySetValueAtIndex(subj_certs, 0, cert_ref);\n+    \n+    SecPolicyRef policy = security->SecPolicyCreateSSL(false, nullptr);\n+    if (!policy) {","path":"packages/bun-usockets/src/crypto/root_certs_darwin.cpp","commit_id":"1e05f26c3ba1dc7d90fcd3c1fb90348db3734849","original_commit_id":"56f543fde29b3af1380c98e2950582b9d8b0ab1f","user":{"login":"coderabbitai[bot]","id":136622811,"node_id":"BOT_kgDOCCSy2w","avatar_url":"https://avatars.githubusercontent.com/in/347564?v=4","gravatar_id":"","url":"https://api.github.com/users/coderabbitai%5Bbot%5D","html_url":"https://github.com/apps/coderabbitai","followers_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/followers","following_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/following{/other_user}","gists_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/gists{/gist_id}","starred_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/subscriptions","organizations_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/orgs","repos_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/repos","events_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/events{/privacy}","received_events_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"_‚ö†Ô∏è Potential issue_\n\n**Wrong policy: pass server=true to SecPolicyCreateSSL.**\n\nUsing false evaluates client auth, not server auth. This can misclassify trust.\n\n\n\n```diff\n-    SecPolicyRef policy = security->SecPolicyCreateSSL(false, nullptr);\n+    SecPolicyRef policy = security->SecPolicyCreateSSL(true, nullptr);\n```\n\n<!-- suggestion_start -->\n\n<details>\n<summary>üìù Committable suggestion</summary>\n\n> ‚ÄºÔ∏è **IMPORTANT**\n> Carefully review the code before committing. Ensure that it accurately replaces the highlighted code, contains no missing lines, and has no issues with indentation. Thoroughly test & benchmark the code to ensure it meets the requirements.\n\n```suggestion\n    SecPolicyRef policy = security->SecPolicyCreateSSL(true, nullptr);\n    if (!policy) {\n        // handle error‚Ä¶\n```\n\n</details>\n\n<!-- suggestion_end -->\n\n<details>\n<summary>ü§ñ Prompt for AI Agents</summary>\n\n```\nIn packages/bun-usockets/src/crypto/root_certs_darwin.cpp around lines 258-259,\nthe call to SecPolicyCreateSSL uses false (client mode) but should use true for\nserver validation; change the SecPolicyCreateSSL call to pass server=true so the\npolicy evaluates server authentication rather than client auth, and ensure the\nnullptr peer name parameter remains appropriate.\n```\n\n</details>\n\n<!-- fingerprinting:phantom:medusa:chinchilla -->\n\n<!-- This is an auto-generated comment by CodeRabbit -->","created_at":"2025-08-30T00:45:03Z","updated_at":"2025-08-30T00:45:10Z","html_url":"https://github.com/oven-sh/bun/pull/21898#discussion_r2311703951","pull_request_url":"https://api.github.com/repos/oven-sh/bun/pulls/21898","author_association":"NONE","_links":{"self":{"href":"https://api.github.com/repos/oven-sh/bun/pulls/comments/2311703951"},"html":{"href":"https://github.com/oven-sh/bun/pull/21898#discussion_r2311703951"},"pull_request":{"href":"https://api.github.com/repos/oven-sh/bun/pulls/21898"}},"reactions":{"url":"https://api.github.com/repos/oven-sh/bun/pulls/comments/2311703951/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":258,"original_start_line":258,"start_side":"RIGHT","line":259,"original_line":259,"side":"RIGHT","original_position":259,"position":259,"subject_type":"line"},{"url":"https://api.github.com/repos/oven-sh/bun/pulls/comments/2311703954","pull_request_review_id":3170766628,"id":2311703954,"node_id":"PRRC_kwDOFVKCyc6Jyc2S","diff_hunk":"@@ -0,0 +1,423 @@\n+#ifdef __APPLE__\n+\n+#include <dlfcn.h>\n+#include <CoreFoundation/CoreFoundation.h>\n+#include <atomic>\n+#include <openssl/x509.h>\n+#include <openssl/x509_vfy.h>\n+#include <stdio.h>\n+\n+// Security framework types and constants - dynamically loaded\n+typedef struct OpaqueSecCertificateRef* SecCertificateRef;\n+typedef struct OpaqueSecTrustRef* SecTrustRef;\n+typedef struct OpaqueSecPolicyRef* SecPolicyRef;\n+typedef int32_t OSStatus;\n+typedef uint32_t SecTrustSettingsDomain;\n+\n+// Security framework constants\n+enum {\n+    errSecSuccess = 0,\n+    errSecItemNotFound = -25300,\n+};\n+\n+// Trust settings domains\n+enum {\n+    kSecTrustSettingsDomainUser = 0,\n+    kSecTrustSettingsDomainAdmin = 1,\n+    kSecTrustSettingsDomainSystem = 2,\n+};\n+\n+// Trust status enumeration\n+enum class TrustStatus {\n+    TRUSTED,\n+    DISTRUSTED,\n+    UNSPECIFIED\n+};\n+\n+// Dynamic Security framework loader\n+class SecurityFramework {\n+public:\n+    void* handle;\n+    void* cf_handle;\n+    \n+    // Core Foundation constants\n+    CFStringRef kSecClass;\n+    CFStringRef kSecClassCertificate;\n+    CFStringRef kSecMatchLimit;\n+    CFStringRef kSecMatchLimitAll;\n+    CFStringRef kSecReturnRef;\n+    CFBooleanRef kCFBooleanTrue;\n+    CFAllocatorRef kCFAllocatorDefault;\n+    CFArrayCallBacks* kCFTypeArrayCallBacks;\n+    CFDictionaryKeyCallBacks* kCFTypeDictionaryKeyCallBacks;\n+    CFDictionaryValueCallBacks* kCFTypeDictionaryValueCallBacks;\n+    \n+    // Core Foundation function pointers\n+    CFMutableArrayRef (*CFArrayCreateMutable)(CFAllocatorRef allocator, CFIndex capacity, const CFArrayCallBacks *callBacks);\n+    CFArrayRef (*CFArrayCreate)(CFAllocatorRef allocator, const void **values, CFIndex numValues, const CFArrayCallBacks *callBacks);\n+    void (*CFArraySetValueAtIndex)(CFMutableArrayRef theArray, CFIndex idx, const void *value);\n+    const void* (*CFArrayGetValueAtIndex)(CFArrayRef theArray, CFIndex idx);\n+    CFIndex (*CFArrayGetCount)(CFArrayRef theArray);\n+    void (*CFRelease)(CFTypeRef cf);\n+    CFDictionaryRef (*CFDictionaryCreate)(CFAllocatorRef allocator, const void **keys, const void **values, CFIndex numValues, const CFDictionaryKeyCallBacks *keyCallBacks, const CFDictionaryValueCallBacks *valueCallBacks);\n+    const UInt8* (*CFDataGetBytePtr)(CFDataRef theData);\n+    CFIndex (*CFDataGetLength)(CFDataRef theData);\n+    \n+    // Security framework function pointers\n+    OSStatus (*SecItemCopyMatching)(CFDictionaryRef query, CFTypeRef *result);\n+    CFDataRef (*SecCertificateCopyData)(SecCertificateRef certificate);\n+    OSStatus (*SecTrustCreateWithCertificates)(CFArrayRef certificates, CFArrayRef policies, SecTrustRef *trust);\n+    SecPolicyRef (*SecPolicyCreateSSL)(Boolean server, CFStringRef hostname);\n+    Boolean (*SecTrustEvaluateWithError)(SecTrustRef trust, CFErrorRef *error);\n+    OSStatus (*SecTrustSettingsCopyTrustSettings)(SecCertificateRef certRef, SecTrustSettingsDomain domain, CFArrayRef *trustSettings);\n+    \n+    SecurityFramework() : handle(nullptr), cf_handle(nullptr),\n+                         kSecClass(nullptr), kSecClassCertificate(nullptr),\n+                         kSecMatchLimit(nullptr), kSecMatchLimitAll(nullptr),\n+                         kSecReturnRef(nullptr), kCFBooleanTrue(nullptr),\n+                         kCFAllocatorDefault(nullptr), kCFTypeArrayCallBacks(nullptr),\n+                         kCFTypeDictionaryKeyCallBacks(nullptr), kCFTypeDictionaryValueCallBacks(nullptr),\n+                         CFArrayCreateMutable(nullptr), CFArrayCreate(nullptr),\n+                         CFArraySetValueAtIndex(nullptr), CFArrayGetValueAtIndex(nullptr),\n+                         CFArrayGetCount(nullptr), CFRelease(nullptr),\n+                         CFDictionaryCreate(nullptr), CFDataGetBytePtr(nullptr), CFDataGetLength(nullptr),\n+                         SecItemCopyMatching(nullptr), SecCertificateCopyData(nullptr),\n+                         SecTrustCreateWithCertificates(nullptr), SecPolicyCreateSSL(nullptr),\n+                         SecTrustEvaluateWithError(nullptr), SecTrustSettingsCopyTrustSettings(nullptr) {}\n+    \n+    ~SecurityFramework() {\n+        if (handle) {\n+            dlclose(handle);\n+        }\n+        if (cf_handle) {\n+            dlclose(cf_handle);\n+        }\n+    }\n+    \n+    bool load() {\n+        if (handle && cf_handle) return true; // Already loaded\n+        \n+        // Load CoreFoundation framework\n+        cf_handle = dlopen(\"/System/Library/Frameworks/CoreFoundation.framework/CoreFoundation\", RTLD_LAZY | RTLD_LOCAL);\n+        if (!cf_handle) {\n+            fprintf(stderr, \"Failed to load CoreFoundation framework: %s\\n\", dlerror());\n+            return false;\n+        }\n+        \n+        // Load Security framework\n+        handle = dlopen(\"/System/Library/Frameworks/Security.framework/Security\", RTLD_LAZY | RTLD_LOCAL);\n+        if (!handle) {\n+            fprintf(stderr, \"Failed to load Security framework: %s\\n\", dlerror());\n+            dlclose(cf_handle);\n+            cf_handle = nullptr;\n+            return false;\n+        }\n+        \n+        // Load constants and functions\n+        if (!load_constants()) {\n+            if (handle) {\n+                dlclose(handle);\n+                handle = nullptr;\n+            }\n+            if (cf_handle) {\n+                dlclose(cf_handle);\n+                cf_handle = nullptr;\n+            }\n+            return false;\n+        }\n+        \n+        if (!load_functions()) {\n+            if (handle) {\n+                dlclose(handle);\n+                handle = nullptr;\n+            }\n+            if (cf_handle) {\n+                dlclose(cf_handle);\n+                cf_handle = nullptr;\n+            }\n+            return false;\n+        }\n+        \n+        return true;\n+    }\n+\n+private:\n+    bool load_constants() {\n+        // Load Security framework constants\n+        void* ptr = dlsym(handle, \"kSecClass\");\n+        if (!ptr) { fprintf(stderr, \"DEBUG: kSecClass not found\\n\"); return false; }\n+        kSecClass = *(CFStringRef*)ptr;\n+        \n+        ptr = dlsym(handle, \"kSecClassCertificate\");\n+        if (!ptr) { fprintf(stderr, \"DEBUG: kSecClassCertificate not found\\n\"); return false; }\n+        kSecClassCertificate = *(CFStringRef*)ptr;\n+        \n+        ptr = dlsym(handle, \"kSecMatchLimit\");\n+        if (!ptr) { fprintf(stderr, \"DEBUG: kSecMatchLimit not found\\n\"); return false; }\n+        kSecMatchLimit = *(CFStringRef*)ptr;\n+        \n+        ptr = dlsym(handle, \"kSecMatchLimitAll\");\n+        if (!ptr) { fprintf(stderr, \"DEBUG: kSecMatchLimitAll not found\\n\"); return false; }\n+        kSecMatchLimitAll = *(CFStringRef*)ptr;\n+        \n+        ptr = dlsym(handle, \"kSecReturnRef\");\n+        if (!ptr) { fprintf(stderr, \"DEBUG: kSecReturnRef not found\\n\"); return false; }\n+        kSecReturnRef = *(CFStringRef*)ptr;\n+        \n+        // Load CoreFoundation constants\n+        ptr = dlsym(cf_handle, \"kCFBooleanTrue\");\n+        if (!ptr) { fprintf(stderr, \"DEBUG: kCFBooleanTrue not found\\n\"); return false; }\n+        kCFBooleanTrue = *(CFBooleanRef*)ptr;\n+        \n+        ptr = dlsym(cf_handle, \"kCFAllocatorDefault\");\n+        if (!ptr) { fprintf(stderr, \"DEBUG: kCFAllocatorDefault not found\\n\"); return false; }\n+        kCFAllocatorDefault = *(CFAllocatorRef*)ptr;\n+        \n+        ptr = dlsym(cf_handle, \"kCFTypeArrayCallBacks\");\n+        if (!ptr) { fprintf(stderr, \"DEBUG: kCFTypeArrayCallBacks not found\\n\"); return false; }\n+        kCFTypeArrayCallBacks = (CFArrayCallBacks*)ptr;\n+        \n+        ptr = dlsym(cf_handle, \"kCFTypeDictionaryKeyCallBacks\");\n+        if (!ptr) { fprintf(stderr, \"DEBUG: kCFTypeDictionaryKeyCallBacks not found\\n\"); return false; }\n+        kCFTypeDictionaryKeyCallBacks = (CFDictionaryKeyCallBacks*)ptr;\n+        \n+        ptr = dlsym(cf_handle, \"kCFTypeDictionaryValueCallBacks\");\n+        if (!ptr) { fprintf(stderr, \"DEBUG: kCFTypeDictionaryValueCallBacks not found\\n\"); return false; }\n+        kCFTypeDictionaryValueCallBacks = (CFDictionaryValueCallBacks*)ptr;\n+        \n+        return true;\n+    }\n+    \n+    bool load_functions() {\n+        // Load CoreFoundation functions\n+        CFArrayCreateMutable = (CFMutableArrayRef (*)(CFAllocatorRef, CFIndex, const CFArrayCallBacks*))dlsym(cf_handle, \"CFArrayCreateMutable\");\n+        CFArrayCreate = (CFArrayRef (*)(CFAllocatorRef, const void**, CFIndex, const CFArrayCallBacks*))dlsym(cf_handle, \"CFArrayCreate\");\n+        CFArraySetValueAtIndex = (void (*)(CFMutableArrayRef, CFIndex, const void*))dlsym(cf_handle, \"CFArraySetValueAtIndex\");\n+        CFArrayGetValueAtIndex = (const void* (*)(CFArrayRef, CFIndex))dlsym(cf_handle, \"CFArrayGetValueAtIndex\");\n+        CFArrayGetCount = (CFIndex (*)(CFArrayRef))dlsym(cf_handle, \"CFArrayGetCount\");\n+        CFRelease = (void (*)(CFTypeRef))dlsym(cf_handle, \"CFRelease\");\n+        CFDictionaryCreate = (CFDictionaryRef (*)(CFAllocatorRef, const void**, const void**, CFIndex, const CFDictionaryKeyCallBacks*, const CFDictionaryValueCallBacks*))dlsym(cf_handle, \"CFDictionaryCreate\");\n+        CFDataGetBytePtr = (const UInt8* (*)(CFDataRef))dlsym(cf_handle, \"CFDataGetBytePtr\");\n+        CFDataGetLength = (CFIndex (*)(CFDataRef))dlsym(cf_handle, \"CFDataGetLength\");\n+        \n+        // Load Security framework functions\n+        SecItemCopyMatching = (OSStatus (*)(CFDictionaryRef, CFTypeRef*))dlsym(handle, \"SecItemCopyMatching\");\n+        SecCertificateCopyData = (CFDataRef (*)(SecCertificateRef))dlsym(handle, \"SecCertificateCopyData\");\n+        SecTrustCreateWithCertificates = (OSStatus (*)(CFArrayRef, CFArrayRef, SecTrustRef*))dlsym(handle, \"SecTrustCreateWithCertificates\");\n+        SecPolicyCreateSSL = (SecPolicyRef (*)(Boolean, CFStringRef))dlsym(handle, \"SecPolicyCreateSSL\");\n+        SecTrustEvaluateWithError = (Boolean (*)(SecTrustRef, CFErrorRef*))dlsym(handle, \"SecTrustEvaluateWithError\");\n+        SecTrustSettingsCopyTrustSettings = (OSStatus (*)(SecCertificateRef, SecTrustSettingsDomain, CFArrayRef*))dlsym(handle, \"SecTrustSettingsCopyTrustSettings\");\n+        \n+        return CFArrayCreateMutable && CFArrayCreate && CFArraySetValueAtIndex &&\n+               CFArrayGetValueAtIndex && CFArrayGetCount && CFRelease &&\n+               CFDictionaryCreate && CFDataGetBytePtr && CFDataGetLength &&\n+               SecItemCopyMatching && SecCertificateCopyData &&\n+               SecTrustCreateWithCertificates && SecPolicyCreateSSL &&\n+               SecTrustEvaluateWithError && SecTrustSettingsCopyTrustSettings;\n+    }\n+};\n+\n+// Global instance for dynamic loading\n+static std::atomic<SecurityFramework*> g_security_framework{nullptr};\n+\n+static SecurityFramework* get_security_framework() {\n+    SecurityFramework* framework = g_security_framework.load();\n+    if (!framework) {\n+        SecurityFramework* new_framework = new SecurityFramework();\n+        if (new_framework->load()) {\n+            SecurityFramework* expected = nullptr;\n+            if (g_security_framework.compare_exchange_strong(expected, new_framework)) {\n+                framework = new_framework;\n+            } else {\n+                delete new_framework;\n+                framework = expected;\n+            }\n+        } else {\n+            delete new_framework;\n+            framework = nullptr;\n+        }\n+    }\n+    return framework;\n+}\n+\n+// Helper function to determine if a certificate is self-issued\n+static bool is_certificate_self_issued(X509* cert) {\n+    X509_NAME* subject = X509_get_subject_name(cert);\n+    X509_NAME* issuer = X509_get_issuer_name(cert);\n+    \n+    return subject && issuer && X509_NAME_cmp(subject, issuer) == 0;\n+}\n+\n+// Validate certificate trust using Security framework\n+static bool is_certificate_trust_valid(SecurityFramework* security, SecCertificateRef cert_ref) {\n+    CFMutableArrayRef subj_certs = security->CFArrayCreateMutable(nullptr, 1, security->kCFTypeArrayCallBacks);\n+    if (!subj_certs) return false;\n+    \n+    security->CFArraySetValueAtIndex(subj_certs, 0, cert_ref);\n+    \n+    SecPolicyRef policy = security->SecPolicyCreateSSL(false, nullptr);\n+    if (!policy) {\n+        security->CFRelease(subj_certs);\n+        return false;\n+    }\n+    \n+    CFArrayRef policies = security->CFArrayCreate(nullptr, (const void**)&policy, 1, security->kCFTypeArrayCallBacks);\n+    if (!policies) {\n+        security->CFRelease(policy);\n+        security->CFRelease(subj_certs);\n+        return false;\n+    }\n+    \n+    SecTrustRef sec_trust = nullptr;\n+    OSStatus ortn = security->SecTrustCreateWithCertificates(subj_certs, policies, &sec_trust);\n+    \n+    bool result = false;\n+    if (ortn == errSecSuccess && sec_trust) {\n+        result = security->SecTrustEvaluateWithError(sec_trust, nullptr);\n+    }\n+    \n+    // Cleanup\n+    if (sec_trust) security->CFRelease(sec_trust);\n+    security->CFRelease(policies);\n+    security->CFRelease(policy);\n+    security->CFRelease(subj_certs);\n+    \n+    return result;\n+}\n+\n+// Check trust settings for policy (simplified version)\n+static TrustStatus is_trust_settings_trusted_for_policy(SecurityFramework* security, CFArrayRef trust_settings, bool is_self_issued) {\n+    if (!trust_settings) {\n+        return TrustStatus::UNSPECIFIED;\n+    }\n+    \n+    // Empty trust settings array means \"always trust this certificate\"\n+    if (security->CFArrayGetCount(trust_settings) == 0) {\n+        return is_self_issued ? TrustStatus::TRUSTED : TrustStatus::UNSPECIFIED;\n+    }\n+    \n+    // For simplicity, we'll do basic checking here\n+    // A full implementation would parse the trust dictionary entries\n+    return TrustStatus::UNSPECIFIED;\n+}\n+\n+// Check if certificate is trusted for server auth policy\n+static bool is_certificate_trusted_for_policy(SecurityFramework* security, X509* cert, SecCertificateRef cert_ref) {\n+    bool is_self_issued = is_certificate_self_issued(cert);\n+    bool trust_evaluated = false;\n+    \n+    // Check user trust domain, then admin domain\n+    for (const auto& trust_domain : {kSecTrustSettingsDomainUser, kSecTrustSettingsDomainAdmin}) {\n+        CFArrayRef trust_settings = nullptr;\n+        OSStatus err = security->SecTrustSettingsCopyTrustSettings(cert_ref, trust_domain, &trust_settings);\n+        \n+        if (err != errSecSuccess && err != errSecItemNotFound) {\n+            continue;\n+        }\n+        \n+        if (err == errSecSuccess && trust_settings) {\n+            TrustStatus result = is_trust_settings_trusted_for_policy(security, trust_settings, is_self_issued);\n+            security->CFRelease(trust_settings);\n+            \n+            if (result == TrustStatus::TRUSTED) {\n+                return true;\n+            } else if (result == TrustStatus::DISTRUSTED) {\n+                return false;\n+            }\n+        }\n+        \n+        // If no trust settings and we haven't evaluated trust yet, check trust validity\n+        if (!trust_settings && !trust_evaluated) {\n+            if (is_certificate_trust_valid(security, cert_ref)) {\n+                return true;\n+            }\n+            trust_evaluated = true;\n+        }\n+    }","path":"packages/bun-usockets/src/crypto/root_certs_darwin.cpp","commit_id":"1e05f26c3ba1dc7d90fcd3c1fb90348db3734849","original_commit_id":"56f543fde29b3af1380c98e2950582b9d8b0ab1f","user":{"login":"coderabbitai[bot]","id":136622811,"node_id":"BOT_kgDOCCSy2w","avatar_url":"https://avatars.githubusercontent.com/in/347564?v=4","gravatar_id":"","url":"https://api.github.com/users/coderabbitai%5Bbot%5D","html_url":"https://github.com/apps/coderabbitai","followers_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/followers","following_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/following{/other_user}","gists_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/gists{/gist_id}","starred_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/subscriptions","organizations_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/orgs","repos_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/repos","events_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/events{/privacy}","received_events_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"_üõ†Ô∏è Refactor suggestion_\n\n**Include system trust settings domain in evaluation.**\n\nOnly checking User/Admin may miss System domain policies.\n\n\n\n```diff\n-    for (const auto& trust_domain : {kSecTrustSettingsDomainUser, kSecTrustSettingsDomainAdmin}) {\n+    for (const auto& trust_domain : {kSecTrustSettingsDomainUser, kSecTrustSettingsDomainAdmin, kSecTrustSettingsDomainSystem}) {\n```\n\n<!-- suggestion_start -->\n\n<details>\n<summary>üìù Committable suggestion</summary>\n\n> ‚ÄºÔ∏è **IMPORTANT**\n> Carefully review the code before committing. Ensure that it accurately replaces the highlighted code, contains no missing lines, and has no issues with indentation. Thoroughly test & benchmark the code to ensure it meets the requirements.\n\n```suggestion\n    for (const auto& trust_domain : {kSecTrustSettingsDomainUser, kSecTrustSettingsDomainAdmin, kSecTrustSettingsDomainSystem}) {\n        CFArrayRef trust_settings = nullptr;\n        OSStatus err = security->SecTrustSettingsCopyTrustSettings(cert_ref, trust_domain, &trust_settings);\n        \n        if (err != errSecSuccess && err != errSecItemNotFound) {\n            continue;\n        }\n        \n        if (err == errSecSuccess && trust_settings) {\n            TrustStatus result = is_trust_settings_trusted_for_policy(security, trust_settings, is_self_issued);\n            security->CFRelease(trust_settings);\n            \n            if (result == TrustStatus::TRUSTED) {\n                return true;\n            } else if (result == TrustStatus::DISTRUSTED) {\n                return false;\n            }\n        }\n        \n        // If no trust settings and we haven't evaluated trust yet, check trust validity\n        if (!trust_settings && !trust_evaluated) {\n            if (is_certificate_trust_valid(security, cert_ref)) {\n                return true;\n            }\n            trust_evaluated = true;\n        }\n    }\n```\n\n</details>\n\n<!-- suggestion_end -->\n\n<details>\n<summary>ü§ñ Prompt for AI Agents</summary>\n\n```\nIn packages/bun-usockets/src/crypto/root_certs_darwin.cpp around lines 310 to\n336, the loop only iterates User and Admin trust domains so it can miss\nSystem-level trust settings; include kSecTrustSettingsDomainSystem in the set of\ndomains iterated (e.g., iterate {kSecTrustSettingsDomainUser,\nkSecTrustSettingsDomainAdmin, kSecTrustSettingsDomainSystem}) so System policies\nare evaluated the same way as User/Admin, preserving existing logic for handling\nSecTrustSettingsCopyTrustSettings errors, checking trust_settings, calling\nis_trust_settings_trusted_for_policy, releasing the CFArray, and falling back to\nis_certificate_trust_valid when no settings exist and trust hasn't yet been\nevaluated.\n```\n\n</details>\n\n<!-- fingerprinting:phantom:medusa:chinchilla -->\n\n<!-- This is an auto-generated comment by CodeRabbit -->","created_at":"2025-08-30T00:45:03Z","updated_at":"2025-08-30T00:45:10Z","html_url":"https://github.com/oven-sh/bun/pull/21898#discussion_r2311703954","pull_request_url":"https://api.github.com/repos/oven-sh/bun/pulls/21898","author_association":"NONE","_links":{"self":{"href":"https://api.github.com/repos/oven-sh/bun/pulls/comments/2311703954"},"html":{"href":"https://github.com/oven-sh/bun/pull/21898#discussion_r2311703954"},"pull_request":{"href":"https://api.github.com/repos/oven-sh/bun/pulls/21898"}},"reactions":{"url":"https://api.github.com/repos/oven-sh/bun/pulls/comments/2311703954/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":310,"original_start_line":310,"start_side":"RIGHT","line":336,"original_line":336,"side":"RIGHT","original_position":336,"position":336,"subject_type":"line"},{"url":"https://api.github.com/repos/oven-sh/bun/pulls/comments/2311703955","pull_request_review_id":3170766628,"id":2311703955,"node_id":"PRRC_kwDOFVKCyc6Jyc2T","diff_hunk":"@@ -0,0 +1,423 @@\n+#ifdef __APPLE__\n+\n+#include <dlfcn.h>\n+#include <CoreFoundation/CoreFoundation.h>\n+#include <atomic>\n+#include <openssl/x509.h>\n+#include <openssl/x509_vfy.h>\n+#include <stdio.h>\n+\n+// Security framework types and constants - dynamically loaded\n+typedef struct OpaqueSecCertificateRef* SecCertificateRef;\n+typedef struct OpaqueSecTrustRef* SecTrustRef;\n+typedef struct OpaqueSecPolicyRef* SecPolicyRef;\n+typedef int32_t OSStatus;\n+typedef uint32_t SecTrustSettingsDomain;\n+\n+// Security framework constants\n+enum {\n+    errSecSuccess = 0,\n+    errSecItemNotFound = -25300,\n+};\n+\n+// Trust settings domains\n+enum {\n+    kSecTrustSettingsDomainUser = 0,\n+    kSecTrustSettingsDomainAdmin = 1,\n+    kSecTrustSettingsDomainSystem = 2,\n+};\n+\n+// Trust status enumeration\n+enum class TrustStatus {\n+    TRUSTED,\n+    DISTRUSTED,\n+    UNSPECIFIED\n+};\n+\n+// Dynamic Security framework loader\n+class SecurityFramework {\n+public:\n+    void* handle;\n+    void* cf_handle;\n+    \n+    // Core Foundation constants\n+    CFStringRef kSecClass;\n+    CFStringRef kSecClassCertificate;\n+    CFStringRef kSecMatchLimit;\n+    CFStringRef kSecMatchLimitAll;\n+    CFStringRef kSecReturnRef;\n+    CFBooleanRef kCFBooleanTrue;\n+    CFAllocatorRef kCFAllocatorDefault;\n+    CFArrayCallBacks* kCFTypeArrayCallBacks;\n+    CFDictionaryKeyCallBacks* kCFTypeDictionaryKeyCallBacks;\n+    CFDictionaryValueCallBacks* kCFTypeDictionaryValueCallBacks;\n+    \n+    // Core Foundation function pointers\n+    CFMutableArrayRef (*CFArrayCreateMutable)(CFAllocatorRef allocator, CFIndex capacity, const CFArrayCallBacks *callBacks);\n+    CFArrayRef (*CFArrayCreate)(CFAllocatorRef allocator, const void **values, CFIndex numValues, const CFArrayCallBacks *callBacks);\n+    void (*CFArraySetValueAtIndex)(CFMutableArrayRef theArray, CFIndex idx, const void *value);\n+    const void* (*CFArrayGetValueAtIndex)(CFArrayRef theArray, CFIndex idx);\n+    CFIndex (*CFArrayGetCount)(CFArrayRef theArray);\n+    void (*CFRelease)(CFTypeRef cf);\n+    CFDictionaryRef (*CFDictionaryCreate)(CFAllocatorRef allocator, const void **keys, const void **values, CFIndex numValues, const CFDictionaryKeyCallBacks *keyCallBacks, const CFDictionaryValueCallBacks *valueCallBacks);\n+    const UInt8* (*CFDataGetBytePtr)(CFDataRef theData);\n+    CFIndex (*CFDataGetLength)(CFDataRef theData);\n+    \n+    // Security framework function pointers\n+    OSStatus (*SecItemCopyMatching)(CFDictionaryRef query, CFTypeRef *result);\n+    CFDataRef (*SecCertificateCopyData)(SecCertificateRef certificate);\n+    OSStatus (*SecTrustCreateWithCertificates)(CFArrayRef certificates, CFArrayRef policies, SecTrustRef *trust);\n+    SecPolicyRef (*SecPolicyCreateSSL)(Boolean server, CFStringRef hostname);\n+    Boolean (*SecTrustEvaluateWithError)(SecTrustRef trust, CFErrorRef *error);\n+    OSStatus (*SecTrustSettingsCopyTrustSettings)(SecCertificateRef certRef, SecTrustSettingsDomain domain, CFArrayRef *trustSettings);\n+    \n+    SecurityFramework() : handle(nullptr), cf_handle(nullptr),\n+                         kSecClass(nullptr), kSecClassCertificate(nullptr),\n+                         kSecMatchLimit(nullptr), kSecMatchLimitAll(nullptr),\n+                         kSecReturnRef(nullptr), kCFBooleanTrue(nullptr),\n+                         kCFAllocatorDefault(nullptr), kCFTypeArrayCallBacks(nullptr),\n+                         kCFTypeDictionaryKeyCallBacks(nullptr), kCFTypeDictionaryValueCallBacks(nullptr),\n+                         CFArrayCreateMutable(nullptr), CFArrayCreate(nullptr),\n+                         CFArraySetValueAtIndex(nullptr), CFArrayGetValueAtIndex(nullptr),\n+                         CFArrayGetCount(nullptr), CFRelease(nullptr),\n+                         CFDictionaryCreate(nullptr), CFDataGetBytePtr(nullptr), CFDataGetLength(nullptr),\n+                         SecItemCopyMatching(nullptr), SecCertificateCopyData(nullptr),\n+                         SecTrustCreateWithCertificates(nullptr), SecPolicyCreateSSL(nullptr),\n+                         SecTrustEvaluateWithError(nullptr), SecTrustSettingsCopyTrustSettings(nullptr) {}\n+    \n+    ~SecurityFramework() {\n+        if (handle) {\n+            dlclose(handle);\n+        }\n+        if (cf_handle) {\n+            dlclose(cf_handle);\n+        }\n+    }\n+    \n+    bool load() {\n+        if (handle && cf_handle) return true; // Already loaded\n+        \n+        // Load CoreFoundation framework\n+        cf_handle = dlopen(\"/System/Library/Frameworks/CoreFoundation.framework/CoreFoundation\", RTLD_LAZY | RTLD_LOCAL);\n+        if (!cf_handle) {\n+            fprintf(stderr, \"Failed to load CoreFoundation framework: %s\\n\", dlerror());\n+            return false;\n+        }\n+        \n+        // Load Security framework\n+        handle = dlopen(\"/System/Library/Frameworks/Security.framework/Security\", RTLD_LAZY | RTLD_LOCAL);\n+        if (!handle) {\n+            fprintf(stderr, \"Failed to load Security framework: %s\\n\", dlerror());\n+            dlclose(cf_handle);\n+            cf_handle = nullptr;\n+            return false;\n+        }\n+        \n+        // Load constants and functions\n+        if (!load_constants()) {\n+            if (handle) {\n+                dlclose(handle);\n+                handle = nullptr;\n+            }\n+            if (cf_handle) {\n+                dlclose(cf_handle);\n+                cf_handle = nullptr;\n+            }\n+            return false;\n+        }\n+        \n+        if (!load_functions()) {\n+            if (handle) {\n+                dlclose(handle);\n+                handle = nullptr;\n+            }\n+            if (cf_handle) {\n+                dlclose(cf_handle);\n+                cf_handle = nullptr;\n+            }\n+            return false;\n+        }\n+        \n+        return true;\n+    }\n+\n+private:\n+    bool load_constants() {\n+        // Load Security framework constants\n+        void* ptr = dlsym(handle, \"kSecClass\");\n+        if (!ptr) { fprintf(stderr, \"DEBUG: kSecClass not found\\n\"); return false; }\n+        kSecClass = *(CFStringRef*)ptr;\n+        \n+        ptr = dlsym(handle, \"kSecClassCertificate\");\n+        if (!ptr) { fprintf(stderr, \"DEBUG: kSecClassCertificate not found\\n\"); return false; }\n+        kSecClassCertificate = *(CFStringRef*)ptr;\n+        \n+        ptr = dlsym(handle, \"kSecMatchLimit\");\n+        if (!ptr) { fprintf(stderr, \"DEBUG: kSecMatchLimit not found\\n\"); return false; }\n+        kSecMatchLimit = *(CFStringRef*)ptr;\n+        \n+        ptr = dlsym(handle, \"kSecMatchLimitAll\");\n+        if (!ptr) { fprintf(stderr, \"DEBUG: kSecMatchLimitAll not found\\n\"); return false; }\n+        kSecMatchLimitAll = *(CFStringRef*)ptr;\n+        \n+        ptr = dlsym(handle, \"kSecReturnRef\");\n+        if (!ptr) { fprintf(stderr, \"DEBUG: kSecReturnRef not found\\n\"); return false; }\n+        kSecReturnRef = *(CFStringRef*)ptr;\n+        \n+        // Load CoreFoundation constants\n+        ptr = dlsym(cf_handle, \"kCFBooleanTrue\");\n+        if (!ptr) { fprintf(stderr, \"DEBUG: kCFBooleanTrue not found\\n\"); return false; }\n+        kCFBooleanTrue = *(CFBooleanRef*)ptr;\n+        \n+        ptr = dlsym(cf_handle, \"kCFAllocatorDefault\");\n+        if (!ptr) { fprintf(stderr, \"DEBUG: kCFAllocatorDefault not found\\n\"); return false; }\n+        kCFAllocatorDefault = *(CFAllocatorRef*)ptr;\n+        \n+        ptr = dlsym(cf_handle, \"kCFTypeArrayCallBacks\");\n+        if (!ptr) { fprintf(stderr, \"DEBUG: kCFTypeArrayCallBacks not found\\n\"); return false; }\n+        kCFTypeArrayCallBacks = (CFArrayCallBacks*)ptr;\n+        \n+        ptr = dlsym(cf_handle, \"kCFTypeDictionaryKeyCallBacks\");\n+        if (!ptr) { fprintf(stderr, \"DEBUG: kCFTypeDictionaryKeyCallBacks not found\\n\"); return false; }\n+        kCFTypeDictionaryKeyCallBacks = (CFDictionaryKeyCallBacks*)ptr;\n+        \n+        ptr = dlsym(cf_handle, \"kCFTypeDictionaryValueCallBacks\");\n+        if (!ptr) { fprintf(stderr, \"DEBUG: kCFTypeDictionaryValueCallBacks not found\\n\"); return false; }\n+        kCFTypeDictionaryValueCallBacks = (CFDictionaryValueCallBacks*)ptr;\n+        \n+        return true;\n+    }\n+    \n+    bool load_functions() {\n+        // Load CoreFoundation functions\n+        CFArrayCreateMutable = (CFMutableArrayRef (*)(CFAllocatorRef, CFIndex, const CFArrayCallBacks*))dlsym(cf_handle, \"CFArrayCreateMutable\");\n+        CFArrayCreate = (CFArrayRef (*)(CFAllocatorRef, const void**, CFIndex, const CFArrayCallBacks*))dlsym(cf_handle, \"CFArrayCreate\");\n+        CFArraySetValueAtIndex = (void (*)(CFMutableArrayRef, CFIndex, const void*))dlsym(cf_handle, \"CFArraySetValueAtIndex\");\n+        CFArrayGetValueAtIndex = (const void* (*)(CFArrayRef, CFIndex))dlsym(cf_handle, \"CFArrayGetValueAtIndex\");\n+        CFArrayGetCount = (CFIndex (*)(CFArrayRef))dlsym(cf_handle, \"CFArrayGetCount\");\n+        CFRelease = (void (*)(CFTypeRef))dlsym(cf_handle, \"CFRelease\");\n+        CFDictionaryCreate = (CFDictionaryRef (*)(CFAllocatorRef, const void**, const void**, CFIndex, const CFDictionaryKeyCallBacks*, const CFDictionaryValueCallBacks*))dlsym(cf_handle, \"CFDictionaryCreate\");\n+        CFDataGetBytePtr = (const UInt8* (*)(CFDataRef))dlsym(cf_handle, \"CFDataGetBytePtr\");\n+        CFDataGetLength = (CFIndex (*)(CFDataRef))dlsym(cf_handle, \"CFDataGetLength\");\n+        \n+        // Load Security framework functions\n+        SecItemCopyMatching = (OSStatus (*)(CFDictionaryRef, CFTypeRef*))dlsym(handle, \"SecItemCopyMatching\");\n+        SecCertificateCopyData = (CFDataRef (*)(SecCertificateRef))dlsym(handle, \"SecCertificateCopyData\");\n+        SecTrustCreateWithCertificates = (OSStatus (*)(CFArrayRef, CFArrayRef, SecTrustRef*))dlsym(handle, \"SecTrustCreateWithCertificates\");\n+        SecPolicyCreateSSL = (SecPolicyRef (*)(Boolean, CFStringRef))dlsym(handle, \"SecPolicyCreateSSL\");\n+        SecTrustEvaluateWithError = (Boolean (*)(SecTrustRef, CFErrorRef*))dlsym(handle, \"SecTrustEvaluateWithError\");\n+        SecTrustSettingsCopyTrustSettings = (OSStatus (*)(SecCertificateRef, SecTrustSettingsDomain, CFArrayRef*))dlsym(handle, \"SecTrustSettingsCopyTrustSettings\");\n+        \n+        return CFArrayCreateMutable && CFArrayCreate && CFArraySetValueAtIndex &&\n+               CFArrayGetValueAtIndex && CFArrayGetCount && CFRelease &&\n+               CFDictionaryCreate && CFDataGetBytePtr && CFDataGetLength &&\n+               SecItemCopyMatching && SecCertificateCopyData &&\n+               SecTrustCreateWithCertificates && SecPolicyCreateSSL &&\n+               SecTrustEvaluateWithError && SecTrustSettingsCopyTrustSettings;\n+    }\n+};\n+\n+// Global instance for dynamic loading\n+static std::atomic<SecurityFramework*> g_security_framework{nullptr};\n+\n+static SecurityFramework* get_security_framework() {\n+    SecurityFramework* framework = g_security_framework.load();\n+    if (!framework) {\n+        SecurityFramework* new_framework = new SecurityFramework();\n+        if (new_framework->load()) {\n+            SecurityFramework* expected = nullptr;\n+            if (g_security_framework.compare_exchange_strong(expected, new_framework)) {\n+                framework = new_framework;\n+            } else {\n+                delete new_framework;\n+                framework = expected;\n+            }\n+        } else {\n+            delete new_framework;\n+            framework = nullptr;\n+        }\n+    }\n+    return framework;\n+}\n+\n+// Helper function to determine if a certificate is self-issued\n+static bool is_certificate_self_issued(X509* cert) {\n+    X509_NAME* subject = X509_get_subject_name(cert);\n+    X509_NAME* issuer = X509_get_issuer_name(cert);\n+    \n+    return subject && issuer && X509_NAME_cmp(subject, issuer) == 0;\n+}\n+\n+// Validate certificate trust using Security framework\n+static bool is_certificate_trust_valid(SecurityFramework* security, SecCertificateRef cert_ref) {\n+    CFMutableArrayRef subj_certs = security->CFArrayCreateMutable(nullptr, 1, security->kCFTypeArrayCallBacks);\n+    if (!subj_certs) return false;\n+    \n+    security->CFArraySetValueAtIndex(subj_certs, 0, cert_ref);\n+    \n+    SecPolicyRef policy = security->SecPolicyCreateSSL(false, nullptr);\n+    if (!policy) {\n+        security->CFRelease(subj_certs);\n+        return false;\n+    }\n+    \n+    CFArrayRef policies = security->CFArrayCreate(nullptr, (const void**)&policy, 1, security->kCFTypeArrayCallBacks);\n+    if (!policies) {\n+        security->CFRelease(policy);\n+        security->CFRelease(subj_certs);\n+        return false;\n+    }\n+    \n+    SecTrustRef sec_trust = nullptr;\n+    OSStatus ortn = security->SecTrustCreateWithCertificates(subj_certs, policies, &sec_trust);\n+    \n+    bool result = false;\n+    if (ortn == errSecSuccess && sec_trust) {\n+        result = security->SecTrustEvaluateWithError(sec_trust, nullptr);\n+    }\n+    \n+    // Cleanup\n+    if (sec_trust) security->CFRelease(sec_trust);\n+    security->CFRelease(policies);\n+    security->CFRelease(policy);\n+    security->CFRelease(subj_certs);\n+    \n+    return result;\n+}\n+\n+// Check trust settings for policy (simplified version)\n+static TrustStatus is_trust_settings_trusted_for_policy(SecurityFramework* security, CFArrayRef trust_settings, bool is_self_issued) {\n+    if (!trust_settings) {\n+        return TrustStatus::UNSPECIFIED;\n+    }\n+    \n+    // Empty trust settings array means \"always trust this certificate\"\n+    if (security->CFArrayGetCount(trust_settings) == 0) {\n+        return is_self_issued ? TrustStatus::TRUSTED : TrustStatus::UNSPECIFIED;\n+    }\n+    \n+    // For simplicity, we'll do basic checking here\n+    // A full implementation would parse the trust dictionary entries\n+    return TrustStatus::UNSPECIFIED;\n+}\n+\n+// Check if certificate is trusted for server auth policy\n+static bool is_certificate_trusted_for_policy(SecurityFramework* security, X509* cert, SecCertificateRef cert_ref) {\n+    bool is_self_issued = is_certificate_self_issued(cert);\n+    bool trust_evaluated = false;\n+    \n+    // Check user trust domain, then admin domain\n+    for (const auto& trust_domain : {kSecTrustSettingsDomainUser, kSecTrustSettingsDomainAdmin}) {\n+        CFArrayRef trust_settings = nullptr;\n+        OSStatus err = security->SecTrustSettingsCopyTrustSettings(cert_ref, trust_domain, &trust_settings);\n+        \n+        if (err != errSecSuccess && err != errSecItemNotFound) {\n+            continue;\n+        }\n+        \n+        if (err == errSecSuccess && trust_settings) {\n+            TrustStatus result = is_trust_settings_trusted_for_policy(security, trust_settings, is_self_issued);\n+            security->CFRelease(trust_settings);\n+            \n+            if (result == TrustStatus::TRUSTED) {\n+                return true;\n+            } else if (result == TrustStatus::DISTRUSTED) {\n+                return false;\n+            }\n+        }\n+        \n+        // If no trust settings and we haven't evaluated trust yet, check trust validity\n+        if (!trust_settings && !trust_evaluated) {\n+            if (is_certificate_trust_valid(security, cert_ref)) {\n+                return true;\n+            }\n+            trust_evaluated = true;\n+        }\n+    }\n+    \n+    return false;\n+}\n+\n+// Main function to load system certificates on macOS\n+extern \"C\" void us_load_system_certificates_macos(STACK_OF(X509) **system_certs) {\n+    *system_certs = sk_X509_new_null();\n+    if (!*system_certs) {\n+        return;\n+    }\n+\n+    SecurityFramework* security = get_security_framework();\n+    if (!security) {\n+        return; // Fail silently\n+    }\n+\n+    // Create search dictionary for certificates\n+    CFTypeRef search_keys[] = {\n+        security->kSecClass, \n+        security->kSecMatchLimit, \n+        security->kSecReturnRef\n+    };\n+    CFTypeRef search_values[] = {\n+        security->kSecClassCertificate, \n+        security->kSecMatchLimitAll, \n+        security->kCFBooleanTrue\n+    };\n+    \n+    CFDictionaryRef search = security->CFDictionaryCreate(\n+        security->kCFAllocatorDefault,\n+        search_keys,\n+        search_values,\n+        3,\n+        security->kCFTypeDictionaryKeyCallBacks,\n+        security->kCFTypeDictionaryValueCallBacks\n+    );\n+","path":"packages/bun-usockets/src/crypto/root_certs_darwin.cpp","commit_id":"1e05f26c3ba1dc7d90fcd3c1fb90348db3734849","original_commit_id":"56f543fde29b3af1380c98e2950582b9d8b0ab1f","user":{"login":"coderabbitai[bot]","id":136622811,"node_id":"BOT_kgDOCCSy2w","avatar_url":"https://avatars.githubusercontent.com/in/347564?v=4","gravatar_id":"","url":"https://api.github.com/users/coderabbitai%5Bbot%5D","html_url":"https://github.com/apps/coderabbitai","followers_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/followers","following_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/following{/other_user}","gists_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/gists{/gist_id}","starred_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/subscriptions","organizations_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/orgs","repos_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/repos","events_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/events{/privacy}","received_events_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"_üõ†Ô∏è Refactor suggestion_\n\n**Query only trusted certs to avoid O(n) evaluations over all items.**\n\nAdd kSecMatchTrustedOnly to the query; otherwise we iterate every certificate in keychains and call SecTrust for each, which is slow and error-prone.\n\n\n\n```diff\n-    CFTypeRef search_keys[] = {\n-        security->kSecClass, \n-        security->kSecMatchLimit, \n-        security->kSecReturnRef\n-    };\n-    CFTypeRef search_values[] = {\n-        security->kSecClassCertificate, \n-        security->kSecMatchLimitAll, \n-        security->kCFBooleanTrue\n-    };\n+    CFTypeRef search_keys[] = {\n+        security->kSecClass,\n+        security->kSecMatchLimit,\n+        security->kSecReturnRef,\n+        security->kSecMatchTrustedOnly,\n+    };\n+    CFTypeRef search_values[] = {\n+        security->kSecClassCertificate,\n+        security->kSecMatchLimitAll,\n+        security->kCFBooleanTrue,\n+        security->kCFBooleanTrue,\n+    };\n```\nFollow-up: ensure kSecMatchTrustedOnly is dlsym‚Äôed.\n\n```diff\n class SecurityFramework {\n public:\n   ...\n-  CFStringRef kSecReturnRef;\n+  CFStringRef kSecReturnRef;\n+  CFStringRef kSecMatchTrustedOnly;\n   ...\n private:\n   bool load_constants() {\n     ...\n-    ptr = dlsym(handle, \"kSecReturnRef\");\n+    ptr = dlsym(handle, \"kSecReturnRef\");\n     if (!ptr) { fprintf(stderr, \"DEBUG: kSecReturnRef not found\\n\"); return false; }\n     kSecReturnRef = *(CFStringRef*)ptr;\n+    ptr = dlsym(handle, \"kSecMatchTrustedOnly\");\n+    if (!ptr) { fprintf(stderr, \"DEBUG: kSecMatchTrustedOnly not found\\n\"); return false; }\n+    kSecMatchTrustedOnly = *(CFStringRef*)ptr;\n```\n\n\n> Committable suggestion skipped: line range outside the PR's diff.\n\n<details>\n<summary>ü§ñ Prompt for AI Agents</summary>\n\n```\nIn packages/bun-usockets/src/crypto/root_certs_darwin.cpp around lines 353 to\n373, the SecItem query builds a dictionary without kSecMatchTrustedOnly so it\nfetches all certificates and forces expensive SecTrust evaluations; update the\nsearch_keys and search_values to include security->kSecMatchTrustedOnly paired\nwith security->kCFBooleanTrue so only trusted certs are returned, and ensure the\nkSecMatchTrustedOnly symbol is resolved via dlsym like the other security\nsymbols before use.\n```\n\n</details>\n\n<!-- fingerprinting:phantom:medusa:chinchilla -->\n\n<!-- This is an auto-generated comment by CodeRabbit -->","created_at":"2025-08-30T00:45:03Z","updated_at":"2025-08-30T00:45:10Z","html_url":"https://github.com/oven-sh/bun/pull/21898#discussion_r2311703955","pull_request_url":"https://api.github.com/repos/oven-sh/bun/pulls/21898","author_association":"NONE","_links":{"self":{"href":"https://api.github.com/repos/oven-sh/bun/pulls/comments/2311703955"},"html":{"href":"https://github.com/oven-sh/bun/pull/21898#discussion_r2311703955"},"pull_request":{"href":"https://api.github.com/repos/oven-sh/bun/pulls/21898"}},"reactions":{"url":"https://api.github.com/repos/oven-sh/bun/pulls/comments/2311703955/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":353,"original_start_line":353,"start_side":"RIGHT","line":373,"original_line":373,"side":"RIGHT","original_position":373,"position":373,"subject_type":"line"},{"url":"https://api.github.com/repos/oven-sh/bun/pulls/comments/2311703957","pull_request_review_id":3170766628,"id":2311703957,"node_id":"PRRC_kwDOFVKCyc6Jyc2V","diff_hunk":"@@ -0,0 +1,423 @@\n+#ifdef __APPLE__\n+\n+#include <dlfcn.h>\n+#include <CoreFoundation/CoreFoundation.h>\n+#include <atomic>\n+#include <openssl/x509.h>\n+#include <openssl/x509_vfy.h>\n+#include <stdio.h>\n+\n+// Security framework types and constants - dynamically loaded\n+typedef struct OpaqueSecCertificateRef* SecCertificateRef;\n+typedef struct OpaqueSecTrustRef* SecTrustRef;\n+typedef struct OpaqueSecPolicyRef* SecPolicyRef;\n+typedef int32_t OSStatus;\n+typedef uint32_t SecTrustSettingsDomain;\n+\n+// Security framework constants\n+enum {\n+    errSecSuccess = 0,\n+    errSecItemNotFound = -25300,\n+};\n+\n+// Trust settings domains\n+enum {\n+    kSecTrustSettingsDomainUser = 0,\n+    kSecTrustSettingsDomainAdmin = 1,\n+    kSecTrustSettingsDomainSystem = 2,\n+};\n+\n+// Trust status enumeration\n+enum class TrustStatus {\n+    TRUSTED,\n+    DISTRUSTED,\n+    UNSPECIFIED\n+};\n+\n+// Dynamic Security framework loader\n+class SecurityFramework {\n+public:\n+    void* handle;\n+    void* cf_handle;\n+    \n+    // Core Foundation constants\n+    CFStringRef kSecClass;\n+    CFStringRef kSecClassCertificate;\n+    CFStringRef kSecMatchLimit;\n+    CFStringRef kSecMatchLimitAll;\n+    CFStringRef kSecReturnRef;\n+    CFBooleanRef kCFBooleanTrue;\n+    CFAllocatorRef kCFAllocatorDefault;\n+    CFArrayCallBacks* kCFTypeArrayCallBacks;\n+    CFDictionaryKeyCallBacks* kCFTypeDictionaryKeyCallBacks;\n+    CFDictionaryValueCallBacks* kCFTypeDictionaryValueCallBacks;\n+    \n+    // Core Foundation function pointers\n+    CFMutableArrayRef (*CFArrayCreateMutable)(CFAllocatorRef allocator, CFIndex capacity, const CFArrayCallBacks *callBacks);\n+    CFArrayRef (*CFArrayCreate)(CFAllocatorRef allocator, const void **values, CFIndex numValues, const CFArrayCallBacks *callBacks);\n+    void (*CFArraySetValueAtIndex)(CFMutableArrayRef theArray, CFIndex idx, const void *value);\n+    const void* (*CFArrayGetValueAtIndex)(CFArrayRef theArray, CFIndex idx);\n+    CFIndex (*CFArrayGetCount)(CFArrayRef theArray);\n+    void (*CFRelease)(CFTypeRef cf);\n+    CFDictionaryRef (*CFDictionaryCreate)(CFAllocatorRef allocator, const void **keys, const void **values, CFIndex numValues, const CFDictionaryKeyCallBacks *keyCallBacks, const CFDictionaryValueCallBacks *valueCallBacks);\n+    const UInt8* (*CFDataGetBytePtr)(CFDataRef theData);\n+    CFIndex (*CFDataGetLength)(CFDataRef theData);\n+    \n+    // Security framework function pointers\n+    OSStatus (*SecItemCopyMatching)(CFDictionaryRef query, CFTypeRef *result);\n+    CFDataRef (*SecCertificateCopyData)(SecCertificateRef certificate);\n+    OSStatus (*SecTrustCreateWithCertificates)(CFArrayRef certificates, CFArrayRef policies, SecTrustRef *trust);\n+    SecPolicyRef (*SecPolicyCreateSSL)(Boolean server, CFStringRef hostname);\n+    Boolean (*SecTrustEvaluateWithError)(SecTrustRef trust, CFErrorRef *error);\n+    OSStatus (*SecTrustSettingsCopyTrustSettings)(SecCertificateRef certRef, SecTrustSettingsDomain domain, CFArrayRef *trustSettings);\n+    \n+    SecurityFramework() : handle(nullptr), cf_handle(nullptr),\n+                         kSecClass(nullptr), kSecClassCertificate(nullptr),\n+                         kSecMatchLimit(nullptr), kSecMatchLimitAll(nullptr),\n+                         kSecReturnRef(nullptr), kCFBooleanTrue(nullptr),\n+                         kCFAllocatorDefault(nullptr), kCFTypeArrayCallBacks(nullptr),\n+                         kCFTypeDictionaryKeyCallBacks(nullptr), kCFTypeDictionaryValueCallBacks(nullptr),\n+                         CFArrayCreateMutable(nullptr), CFArrayCreate(nullptr),\n+                         CFArraySetValueAtIndex(nullptr), CFArrayGetValueAtIndex(nullptr),\n+                         CFArrayGetCount(nullptr), CFRelease(nullptr),\n+                         CFDictionaryCreate(nullptr), CFDataGetBytePtr(nullptr), CFDataGetLength(nullptr),\n+                         SecItemCopyMatching(nullptr), SecCertificateCopyData(nullptr),\n+                         SecTrustCreateWithCertificates(nullptr), SecPolicyCreateSSL(nullptr),\n+                         SecTrustEvaluateWithError(nullptr), SecTrustSettingsCopyTrustSettings(nullptr) {}\n+    \n+    ~SecurityFramework() {\n+        if (handle) {\n+            dlclose(handle);\n+        }\n+        if (cf_handle) {\n+            dlclose(cf_handle);\n+        }\n+    }\n+    \n+    bool load() {\n+        if (handle && cf_handle) return true; // Already loaded\n+        \n+        // Load CoreFoundation framework\n+        cf_handle = dlopen(\"/System/Library/Frameworks/CoreFoundation.framework/CoreFoundation\", RTLD_LAZY | RTLD_LOCAL);\n+        if (!cf_handle) {\n+            fprintf(stderr, \"Failed to load CoreFoundation framework: %s\\n\", dlerror());\n+            return false;\n+        }\n+        \n+        // Load Security framework\n+        handle = dlopen(\"/System/Library/Frameworks/Security.framework/Security\", RTLD_LAZY | RTLD_LOCAL);\n+        if (!handle) {\n+            fprintf(stderr, \"Failed to load Security framework: %s\\n\", dlerror());\n+            dlclose(cf_handle);\n+            cf_handle = nullptr;\n+            return false;\n+        }\n+        \n+        // Load constants and functions\n+        if (!load_constants()) {\n+            if (handle) {\n+                dlclose(handle);\n+                handle = nullptr;\n+            }\n+            if (cf_handle) {\n+                dlclose(cf_handle);\n+                cf_handle = nullptr;\n+            }\n+            return false;\n+        }\n+        \n+        if (!load_functions()) {\n+            if (handle) {\n+                dlclose(handle);\n+                handle = nullptr;\n+            }\n+            if (cf_handle) {\n+                dlclose(cf_handle);\n+                cf_handle = nullptr;\n+            }\n+            return false;\n+        }\n+        \n+        return true;\n+    }\n+\n+private:\n+    bool load_constants() {\n+        // Load Security framework constants\n+        void* ptr = dlsym(handle, \"kSecClass\");\n+        if (!ptr) { fprintf(stderr, \"DEBUG: kSecClass not found\\n\"); return false; }\n+        kSecClass = *(CFStringRef*)ptr;\n+        \n+        ptr = dlsym(handle, \"kSecClassCertificate\");\n+        if (!ptr) { fprintf(stderr, \"DEBUG: kSecClassCertificate not found\\n\"); return false; }\n+        kSecClassCertificate = *(CFStringRef*)ptr;\n+        \n+        ptr = dlsym(handle, \"kSecMatchLimit\");\n+        if (!ptr) { fprintf(stderr, \"DEBUG: kSecMatchLimit not found\\n\"); return false; }\n+        kSecMatchLimit = *(CFStringRef*)ptr;\n+        \n+        ptr = dlsym(handle, \"kSecMatchLimitAll\");\n+        if (!ptr) { fprintf(stderr, \"DEBUG: kSecMatchLimitAll not found\\n\"); return false; }\n+        kSecMatchLimitAll = *(CFStringRef*)ptr;\n+        \n+        ptr = dlsym(handle, \"kSecReturnRef\");\n+        if (!ptr) { fprintf(stderr, \"DEBUG: kSecReturnRef not found\\n\"); return false; }\n+        kSecReturnRef = *(CFStringRef*)ptr;\n+        \n+        // Load CoreFoundation constants\n+        ptr = dlsym(cf_handle, \"kCFBooleanTrue\");\n+        if (!ptr) { fprintf(stderr, \"DEBUG: kCFBooleanTrue not found\\n\"); return false; }\n+        kCFBooleanTrue = *(CFBooleanRef*)ptr;\n+        \n+        ptr = dlsym(cf_handle, \"kCFAllocatorDefault\");\n+        if (!ptr) { fprintf(stderr, \"DEBUG: kCFAllocatorDefault not found\\n\"); return false; }\n+        kCFAllocatorDefault = *(CFAllocatorRef*)ptr;\n+        \n+        ptr = dlsym(cf_handle, \"kCFTypeArrayCallBacks\");\n+        if (!ptr) { fprintf(stderr, \"DEBUG: kCFTypeArrayCallBacks not found\\n\"); return false; }\n+        kCFTypeArrayCallBacks = (CFArrayCallBacks*)ptr;\n+        \n+        ptr = dlsym(cf_handle, \"kCFTypeDictionaryKeyCallBacks\");\n+        if (!ptr) { fprintf(stderr, \"DEBUG: kCFTypeDictionaryKeyCallBacks not found\\n\"); return false; }\n+        kCFTypeDictionaryKeyCallBacks = (CFDictionaryKeyCallBacks*)ptr;\n+        \n+        ptr = dlsym(cf_handle, \"kCFTypeDictionaryValueCallBacks\");\n+        if (!ptr) { fprintf(stderr, \"DEBUG: kCFTypeDictionaryValueCallBacks not found\\n\"); return false; }\n+        kCFTypeDictionaryValueCallBacks = (CFDictionaryValueCallBacks*)ptr;\n+        \n+        return true;\n+    }\n+    \n+    bool load_functions() {\n+        // Load CoreFoundation functions\n+        CFArrayCreateMutable = (CFMutableArrayRef (*)(CFAllocatorRef, CFIndex, const CFArrayCallBacks*))dlsym(cf_handle, \"CFArrayCreateMutable\");\n+        CFArrayCreate = (CFArrayRef (*)(CFAllocatorRef, const void**, CFIndex, const CFArrayCallBacks*))dlsym(cf_handle, \"CFArrayCreate\");\n+        CFArraySetValueAtIndex = (void (*)(CFMutableArrayRef, CFIndex, const void*))dlsym(cf_handle, \"CFArraySetValueAtIndex\");\n+        CFArrayGetValueAtIndex = (const void* (*)(CFArrayRef, CFIndex))dlsym(cf_handle, \"CFArrayGetValueAtIndex\");\n+        CFArrayGetCount = (CFIndex (*)(CFArrayRef))dlsym(cf_handle, \"CFArrayGetCount\");\n+        CFRelease = (void (*)(CFTypeRef))dlsym(cf_handle, \"CFRelease\");\n+        CFDictionaryCreate = (CFDictionaryRef (*)(CFAllocatorRef, const void**, const void**, CFIndex, const CFDictionaryKeyCallBacks*, const CFDictionaryValueCallBacks*))dlsym(cf_handle, \"CFDictionaryCreate\");\n+        CFDataGetBytePtr = (const UInt8* (*)(CFDataRef))dlsym(cf_handle, \"CFDataGetBytePtr\");\n+        CFDataGetLength = (CFIndex (*)(CFDataRef))dlsym(cf_handle, \"CFDataGetLength\");\n+        \n+        // Load Security framework functions\n+        SecItemCopyMatching = (OSStatus (*)(CFDictionaryRef, CFTypeRef*))dlsym(handle, \"SecItemCopyMatching\");\n+        SecCertificateCopyData = (CFDataRef (*)(SecCertificateRef))dlsym(handle, \"SecCertificateCopyData\");\n+        SecTrustCreateWithCertificates = (OSStatus (*)(CFArrayRef, CFArrayRef, SecTrustRef*))dlsym(handle, \"SecTrustCreateWithCertificates\");\n+        SecPolicyCreateSSL = (SecPolicyRef (*)(Boolean, CFStringRef))dlsym(handle, \"SecPolicyCreateSSL\");\n+        SecTrustEvaluateWithError = (Boolean (*)(SecTrustRef, CFErrorRef*))dlsym(handle, \"SecTrustEvaluateWithError\");\n+        SecTrustSettingsCopyTrustSettings = (OSStatus (*)(SecCertificateRef, SecTrustSettingsDomain, CFArrayRef*))dlsym(handle, \"SecTrustSettingsCopyTrustSettings\");\n+        \n+        return CFArrayCreateMutable && CFArrayCreate && CFArraySetValueAtIndex &&\n+               CFArrayGetValueAtIndex && CFArrayGetCount && CFRelease &&\n+               CFDictionaryCreate && CFDataGetBytePtr && CFDataGetLength &&\n+               SecItemCopyMatching && SecCertificateCopyData &&\n+               SecTrustCreateWithCertificates && SecPolicyCreateSSL &&\n+               SecTrustEvaluateWithError && SecTrustSettingsCopyTrustSettings;\n+    }\n+};\n+\n+// Global instance for dynamic loading\n+static std::atomic<SecurityFramework*> g_security_framework{nullptr};\n+\n+static SecurityFramework* get_security_framework() {\n+    SecurityFramework* framework = g_security_framework.load();\n+    if (!framework) {\n+        SecurityFramework* new_framework = new SecurityFramework();\n+        if (new_framework->load()) {\n+            SecurityFramework* expected = nullptr;\n+            if (g_security_framework.compare_exchange_strong(expected, new_framework)) {\n+                framework = new_framework;\n+            } else {\n+                delete new_framework;\n+                framework = expected;\n+            }\n+        } else {\n+            delete new_framework;\n+            framework = nullptr;\n+        }\n+    }\n+    return framework;\n+}\n+\n+// Helper function to determine if a certificate is self-issued\n+static bool is_certificate_self_issued(X509* cert) {\n+    X509_NAME* subject = X509_get_subject_name(cert);\n+    X509_NAME* issuer = X509_get_issuer_name(cert);\n+    \n+    return subject && issuer && X509_NAME_cmp(subject, issuer) == 0;\n+}\n+\n+// Validate certificate trust using Security framework\n+static bool is_certificate_trust_valid(SecurityFramework* security, SecCertificateRef cert_ref) {\n+    CFMutableArrayRef subj_certs = security->CFArrayCreateMutable(nullptr, 1, security->kCFTypeArrayCallBacks);\n+    if (!subj_certs) return false;\n+    \n+    security->CFArraySetValueAtIndex(subj_certs, 0, cert_ref);\n+    \n+    SecPolicyRef policy = security->SecPolicyCreateSSL(false, nullptr);\n+    if (!policy) {\n+        security->CFRelease(subj_certs);\n+        return false;\n+    }\n+    \n+    CFArrayRef policies = security->CFArrayCreate(nullptr, (const void**)&policy, 1, security->kCFTypeArrayCallBacks);\n+    if (!policies) {\n+        security->CFRelease(policy);\n+        security->CFRelease(subj_certs);\n+        return false;\n+    }\n+    \n+    SecTrustRef sec_trust = nullptr;\n+    OSStatus ortn = security->SecTrustCreateWithCertificates(subj_certs, policies, &sec_trust);\n+    \n+    bool result = false;\n+    if (ortn == errSecSuccess && sec_trust) {\n+        result = security->SecTrustEvaluateWithError(sec_trust, nullptr);\n+    }\n+    \n+    // Cleanup\n+    if (sec_trust) security->CFRelease(sec_trust);\n+    security->CFRelease(policies);\n+    security->CFRelease(policy);\n+    security->CFRelease(subj_certs);\n+    \n+    return result;\n+}\n+\n+// Check trust settings for policy (simplified version)\n+static TrustStatus is_trust_settings_trusted_for_policy(SecurityFramework* security, CFArrayRef trust_settings, bool is_self_issued) {\n+    if (!trust_settings) {\n+        return TrustStatus::UNSPECIFIED;\n+    }\n+    \n+    // Empty trust settings array means \"always trust this certificate\"\n+    if (security->CFArrayGetCount(trust_settings) == 0) {\n+        return is_self_issued ? TrustStatus::TRUSTED : TrustStatus::UNSPECIFIED;\n+    }\n+    \n+    // For simplicity, we'll do basic checking here\n+    // A full implementation would parse the trust dictionary entries\n+    return TrustStatus::UNSPECIFIED;\n+}\n+\n+// Check if certificate is trusted for server auth policy\n+static bool is_certificate_trusted_for_policy(SecurityFramework* security, X509* cert, SecCertificateRef cert_ref) {\n+    bool is_self_issued = is_certificate_self_issued(cert);\n+    bool trust_evaluated = false;\n+    \n+    // Check user trust domain, then admin domain\n+    for (const auto& trust_domain : {kSecTrustSettingsDomainUser, kSecTrustSettingsDomainAdmin}) {\n+        CFArrayRef trust_settings = nullptr;\n+        OSStatus err = security->SecTrustSettingsCopyTrustSettings(cert_ref, trust_domain, &trust_settings);\n+        \n+        if (err != errSecSuccess && err != errSecItemNotFound) {\n+            continue;\n+        }\n+        \n+        if (err == errSecSuccess && trust_settings) {\n+            TrustStatus result = is_trust_settings_trusted_for_policy(security, trust_settings, is_self_issued);\n+            security->CFRelease(trust_settings);\n+            \n+            if (result == TrustStatus::TRUSTED) {\n+                return true;\n+            } else if (result == TrustStatus::DISTRUSTED) {\n+                return false;\n+            }\n+        }\n+        \n+        // If no trust settings and we haven't evaluated trust yet, check trust validity\n+        if (!trust_settings && !trust_evaluated) {\n+            if (is_certificate_trust_valid(security, cert_ref)) {\n+                return true;\n+            }\n+            trust_evaluated = true;\n+        }\n+    }\n+    \n+    return false;\n+}\n+\n+// Main function to load system certificates on macOS\n+extern \"C\" void us_load_system_certificates_macos(STACK_OF(X509) **system_certs) {\n+    *system_certs = sk_X509_new_null();\n+    if (!*system_certs) {\n+        return;\n+    }\n+\n+    SecurityFramework* security = get_security_framework();\n+    if (!security) {\n+        return; // Fail silently\n+    }\n+\n+    // Create search dictionary for certificates\n+    CFTypeRef search_keys[] = {\n+        security->kSecClass, \n+        security->kSecMatchLimit, \n+        security->kSecReturnRef\n+    };\n+    CFTypeRef search_values[] = {\n+        security->kSecClassCertificate, \n+        security->kSecMatchLimitAll, \n+        security->kCFBooleanTrue\n+    };\n+    \n+    CFDictionaryRef search = security->CFDictionaryCreate(\n+        security->kCFAllocatorDefault,\n+        search_keys,\n+        search_values,\n+        3,\n+        security->kCFTypeDictionaryKeyCallBacks,\n+        security->kCFTypeDictionaryValueCallBacks\n+    );\n+\n+    if (!search) {\n+        return;\n+    }\n+\n+    CFArrayRef certificates = nullptr;\n+    OSStatus status = security->SecItemCopyMatching(search, (CFTypeRef*)&certificates);\n+    security->CFRelease(search);\n+\n+    if (status != errSecSuccess || !certificates) {\n+        return;\n+    }\n+\n+    CFIndex count = security->CFArrayGetCount(certificates);\n+    \n+    for (CFIndex i = 0; i < count; ++i) {\n+        SecCertificateRef cert_ref = (SecCertificateRef)security->CFArrayGetValueAtIndex(certificates, i);\n+        if (!cert_ref) continue;\n+        \n+        // Get certificate data\n+        CFDataRef cert_data = security->SecCertificateCopyData(cert_ref);\n+        if (!cert_data) continue;\n+        \n+        // Convert to X509\n+        const unsigned char* data_ptr = security->CFDataGetBytePtr(cert_data);\n+        long data_len = security->CFDataGetLength(cert_data);\n+        X509* x509_cert = d2i_X509(nullptr, &data_ptr, data_len);\n+        security->CFRelease(cert_data);\n+        \n+        if (!x509_cert) continue;\n+        \n+        // Check if certificate is trusted for server authentication\n+        if (is_certificate_trusted_for_policy(security, x509_cert, cert_ref)) {\n+            sk_X509_push(*system_certs, x509_cert);\n+        } else {\n+            X509_free(x509_cert);\n+        }","path":"packages/bun-usockets/src/crypto/root_certs_darwin.cpp","commit_id":"1e05f26c3ba1dc7d90fcd3c1fb90348db3734849","original_commit_id":"56f543fde29b3af1380c98e2950582b9d8b0ab1f","user":{"login":"coderabbitai[bot]","id":136622811,"node_id":"BOT_kgDOCCSy2w","avatar_url":"https://avatars.githubusercontent.com/in/347564?v=4","gravatar_id":"","url":"https://api.github.com/users/coderabbitai%5Bbot%5D","html_url":"https://github.com/apps/coderabbitai","followers_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/followers","following_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/following{/other_user}","gists_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/gists{/gist_id}","starred_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/subscriptions","organizations_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/orgs","repos_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/repos","events_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/events{/privacy}","received_events_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"_‚ö†Ô∏è Potential issue_\n\n**Do not add end-entity certs to the trust store; restrict to CA certs.**\n\nPushing non-CA certs into the X509_STORE can anchor arbitrary end-entities, weakening security.\n\n\n\n```diff\n-        // Check if certificate is trusted for server authentication\n-        if (is_certificate_trusted_for_policy(security, x509_cert, cert_ref)) {\n+        // Only consider CA certificates\n+        if (X509_check_ca(x509_cert) == 1 &&\n+            is_certificate_trusted_for_policy(security, x509_cert, cert_ref)) {\n             sk_X509_push(*system_certs, x509_cert);\n         } else {\n             X509_free(x509_cert);\n         }\n```\n\n<!-- suggestion_start -->\n\n<details>\n<summary>üìù Committable suggestion</summary>\n\n> ‚ÄºÔ∏è **IMPORTANT**\n> Carefully review the code before committing. Ensure that it accurately replaces the highlighted code, contains no missing lines, and has no issues with indentation. Thoroughly test & benchmark the code to ensure it meets the requirements.\n\n```suggestion\n        // Only consider CA certificates\n        if (X509_check_ca(x509_cert) == 1 &&\n            is_certificate_trusted_for_policy(security, x509_cert, cert_ref)) {\n            sk_X509_push(*system_certs, x509_cert);\n        } else {\n            X509_free(x509_cert);\n        }\n```\n\n</details>\n\n<!-- suggestion_end -->\n\n<details>\n<summary>ü§ñ Prompt for AI Agents</summary>\n\n```\nIn packages/bun-usockets/src/crypto/root_certs_darwin.cpp around lines 404‚Äì409,\nthe code currently pushes any certificate that is \"trusted for server\nauthentication\" into the X509_STORE; instead, only CA certs should be added.\nChange the logic to detect whether x509_cert is a CA (e.g., use\nX509_check_ca(x509_cert) or inspect the basicConstraints CA:true extension and\nensure it is a CA certificate) and only call sk_X509_push(*system_certs,\nx509_cert) when that CA check passes; otherwise free the cert with\nX509_free(x509_cert). Keep reference handling correct (do not push non-CA certs)\nso end-entity certs are never anchored in the trust store.\n```\n\n</details>\n\n<!-- fingerprinting:phantom:medusa:chinchilla -->\n\n<!-- This is an auto-generated comment by CodeRabbit -->","created_at":"2025-08-30T00:45:03Z","updated_at":"2025-08-30T00:45:10Z","html_url":"https://github.com/oven-sh/bun/pull/21898#discussion_r2311703957","pull_request_url":"https://api.github.com/repos/oven-sh/bun/pulls/21898","author_association":"NONE","_links":{"self":{"href":"https://api.github.com/repos/oven-sh/bun/pulls/comments/2311703957"},"html":{"href":"https://github.com/oven-sh/bun/pull/21898#discussion_r2311703957"},"pull_request":{"href":"https://api.github.com/repos/oven-sh/bun/pulls/21898"}},"reactions":{"url":"https://api.github.com/repos/oven-sh/bun/pulls/comments/2311703957/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":404,"original_start_line":404,"start_side":"RIGHT","line":409,"original_line":409,"side":"RIGHT","original_position":409,"position":409,"subject_type":"line"},{"url":"https://api.github.com/repos/oven-sh/bun/pulls/comments/2311703959","pull_request_review_id":3170766628,"id":2311703959,"node_id":"PRRC_kwDOFVKCyc6Jyc2X","diff_hunk":"@@ -5,6 +5,7 @@\n #define CPPDECL extern \"C\"\n \n STACK_OF(X509) *us_get_root_extra_cert_instances();\n+STACK_OF(X509) *us_get_root_system_cert_instances();\n ","path":"packages/bun-usockets/src/crypto/root_certs_header.h","commit_id":"1e05f26c3ba1dc7d90fcd3c1fb90348db3734849","original_commit_id":"56f543fde29b3af1380c98e2950582b9d8b0ab1f","user":{"login":"coderabbitai[bot]","id":136622811,"node_id":"BOT_kgDOCCSy2w","avatar_url":"https://avatars.githubusercontent.com/in/347564?v=4","gravatar_id":"","url":"https://api.github.com/users/coderabbitai%5Bbot%5D","html_url":"https://github.com/apps/coderabbitai","followers_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/followers","following_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/following{/other_user}","gists_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/gists{/gist_id}","starred_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/subscriptions","organizations_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/orgs","repos_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/repos","events_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/events{/privacy}","received_events_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"_üí° Verification agent_\n\n<details>\n<summary>üß© Analysis chain</summary>\n\n**Fix symbol name mismatch with implementation (linker/runtime crash risk).**\n\nHeader declares `us_get_root_system_cert_instances()` but implementation (and call sites) refer to `us_get_root_system_certificates()`. Rename the header declaration to match the definition to avoid unresolved symbols and the failing system-CA tests.\n\n\nApply this diff:\n\n```diff\n-STACK_OF(X509) *us_get_root_extra_cert_instances();\n-STACK_OF(X509) *us_get_root_system_cert_instances();\n+STACK_OF(X509) *us_get_root_extra_cert_instances();\n+STACK_OF(X509) *us_get_root_system_certificates();\n```\n\n\nRun to confirm consistency across the tree:\n\n---\n\nüèÅ Script executed:\n\n```shell\n#!/bin/bash\nrg -nP --glob '!**/node_modules/**' '\\bus_get_root_system_cert(_instances|ificates)\\b' \\\n  packages/bun-usockets src | sed -E 's/:.*$//' | sort -u\n```\n\nLength of output: 277\n\n---\n\n\n\n</details>\n\n**Fix declaration to match definition**  \nIn packages/bun-usockets/src/crypto/root_certs_header.h (line 8), rename  \n```diff\n-STACK_OF(X509) *us_get_root_system_cert_instances();\n+STACK_OF(X509) *us_get_root_system_certificates();\n```  \nso it matches the implementation in root_certs.cpp and calls in NodeTLS.cpp.\n\n<!-- suggestion_start -->\n\n<details>\n<summary>üìù Committable suggestion</summary>\n\n> ‚ÄºÔ∏è **IMPORTANT**\n> Carefully review the code before committing. Ensure that it accurately replaces the highlighted code, contains no missing lines, and has no issues with indentation. Thoroughly test & benchmark the code to ensure it meets the requirements.\n\n```suggestion\nSTACK_OF(X509) *us_get_root_extra_cert_instances();\nSTACK_OF(X509) *us_get_root_system_certificates();\n```\n\n</details>\n\n<!-- suggestion_end -->\n\n<details>\n<summary>ü§ñ Prompt for AI Agents</summary>\n\n```\nIn packages/bun-usockets/src/crypto/root_certs_header.h around lines 7 to 9, the\ndeclared function names do not match their implementations and uses; rename the\ntwo declarations from us_get_root_extra_cert_instances() and\nus_get_root_system_cert_instances() to us_get_root_extra_certificates() and\nus_get_root_system_certificates() respectively so they match the definitions in\nroot_certs.cpp and the calls in NodeTLS.cpp; update the header declarations only\n(keep return type STACK_OF(X509) *) to the exact names used in the\nimplementation and rebuild to verify linkage.\n```\n\n</details>\n\n<!-- fingerprinting:phantom:medusa:chinchilla -->\n\n<!-- This is an auto-generated comment by CodeRabbit -->","created_at":"2025-08-30T00:45:04Z","updated_at":"2025-08-30T00:45:10Z","html_url":"https://github.com/oven-sh/bun/pull/21898#discussion_r2311703959","pull_request_url":"https://api.github.com/repos/oven-sh/bun/pulls/21898","author_association":"NONE","_links":{"self":{"href":"https://api.github.com/repos/oven-sh/bun/pulls/comments/2311703959"},"html":{"href":"https://github.com/oven-sh/bun/pull/21898#discussion_r2311703959"},"pull_request":{"href":"https://api.github.com/repos/oven-sh/bun/pulls/21898"}},"reactions":{"url":"https://api.github.com/repos/oven-sh/bun/pulls/comments/2311703959/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":7,"original_start_line":7,"start_side":"RIGHT","line":null,"original_line":9,"side":"RIGHT","original_position":5,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/oven-sh/bun/pulls/comments/2311703960","pull_request_review_id":3170766628,"id":2311703960,"node_id":"PRRC_kwDOFVKCyc6Jyc2Y","diff_hunk":"@@ -0,0 +1,153 @@\n+#ifndef _WIN32\n+#ifndef __APPLE__\n+\n+#include <dirent.h>\n+#include <stdio.h>\n+#include <string.h>\n+#include <limits.h>\n+#include <openssl/x509.h>\n+#include <openssl/x509_vfy.h>\n+#include <openssl/pem.h>\n+\n+extern \"C\" void BUN__warn__extra_ca_load_failed(const char* filename, const char* error_msg);\n+\n+// Helper function to load certificates from a directory\n+static void load_certs_from_directory(const char* dir_path, STACK_OF(X509)* cert_stack) {\n+  DIR* dir = opendir(dir_path);\n+  if (!dir) {\n+    return;\n+  }\n+  \n+  struct dirent* entry;\n+  while ((entry = readdir(dir)) != NULL) {\n+    // Skip . and ..\n+    if (strcmp(entry->d_name, \".\") == 0 || strcmp(entry->d_name, \"..\") == 0) {\n+      continue;\n+    }\n+    \n+    // Check if file has .crt, .pem, or .cer extension\n+    const char* ext = strrchr(entry->d_name, '.');\n+    if (!ext || (strcmp(ext, \".crt\") != 0 && strcmp(ext, \".pem\") != 0 && strcmp(ext, \".cer\") != 0)) {\n+      continue;\n+    }\n+    \n+    // Build full path\n+    char filepath[PATH_MAX];\n+    snprintf(filepath, sizeof(filepath), \"%s/%s\", dir_path, entry->d_name);\n+    \n+    // Try to load certificate\n+    FILE* file = fopen(filepath, \"r\");\n+    if (file) {\n+      X509* cert = PEM_read_X509(file, NULL, NULL, NULL);\n+      fclose(file);\n+      \n+      if (cert) {\n+        sk_X509_push(cert_stack, cert);\n+      }\n+    }\n+  }\n+  \n+  closedir(dir);\n+}","path":"packages/bun-usockets/src/crypto/root_certs_linux.cpp","commit_id":"1e05f26c3ba1dc7d90fcd3c1fb90348db3734849","original_commit_id":"56f543fde29b3af1380c98e2950582b9d8b0ab1f","user":{"login":"coderabbitai[bot]","id":136622811,"node_id":"BOT_kgDOCCSy2w","avatar_url":"https://avatars.githubusercontent.com/in/347564?v=4","gravatar_id":"","url":"https://api.github.com/users/coderabbitai%5Bbot%5D","html_url":"https://github.com/apps/coderabbitai","followers_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/followers","following_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/following{/other_user}","gists_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/gists{/gist_id}","starred_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/subscriptions","organizations_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/orgs","repos_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/repos","events_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/events{/privacy}","received_events_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"_‚ö†Ô∏è Potential issue_\n\n**Directory loader must check push errors; avoid leaking X509.**\n\n`sk_X509_push` can fail; free the cert on failure.\n\n```diff\n-      if (cert) {\n-        sk_X509_push(cert_stack, cert);\n-      }\n+      if (cert) {\n+        if (!sk_X509_push(cert_stack, cert)) {\n+          X509_free(cert);\n+        }\n+      }\n```\n\n<!-- suggestion_start -->\n\n<details>\n<summary>üìù Committable suggestion</summary>\n\n> ‚ÄºÔ∏è **IMPORTANT**\n> Carefully review the code before committing. Ensure that it accurately replaces the highlighted code, contains no missing lines, and has no issues with indentation. Thoroughly test & benchmark the code to ensure it meets the requirements.\n\n```suggestion\n// Helper function to load certificates from a directory\nstatic void load_certs_from_directory(const char* dir_path, STACK_OF(X509)* cert_stack) {\n  DIR* dir = opendir(dir_path);\n  if (!dir) {\n    return;\n  }\n\n  struct dirent* entry;\n  while ((entry = readdir(dir)) != NULL) {\n    // Skip . and ..\n    if (strcmp(entry->d_name, \".\") == 0 || strcmp(entry->d_name, \"..\") == 0) {\n      continue;\n    }\n\n    // Check if file has .crt, .pem, or .cer extension\n    const char* ext = strrchr(entry->d_name, '.');\n    if (!ext || (strcmp(ext, \".crt\") != 0 && strcmp(ext, \".pem\") != 0 && strcmp(ext, \".cer\") != 0)) {\n      continue;\n    }\n\n    // Build full path\n    char filepath[PATH_MAX];\n    snprintf(filepath, sizeof(filepath), \"%s/%s\", dir_path, entry->d_name);\n\n    // Try to load certificate\n    FILE* file = fopen(filepath, \"r\");\n    if (file) {\n      X509* cert = PEM_read_X509(file, NULL, NULL, NULL);\n      fclose(file);\n\n      if (cert) {\n        if (!sk_X509_push(cert_stack, cert)) {\n          X509_free(cert);\n        }\n      }\n    }\n  }\n\n  closedir(dir);\n}\n```\n\n</details>\n\n<!-- suggestion_end -->\n\n<details>\n<summary>ü§ñ Prompt for AI Agents</summary>\n\n```\nIn packages/bun-usockets/src/crypto/root_certs_linux.cpp around lines 14 to 51,\nthe directory loader calls sk_X509_push(cert_stack, cert) but doesn't check its\nreturn value, which can fail and leak the X509 object; after PEM_read_X509\nsucceeds, check the return of sk_X509_push and if it returns 0, call\nX509_free(cert) to avoid the leak (optionally log the failure), otherwise keep\nthe cert on the stack; ensure this cleanup path is applied wherever cert objects\nare created before being pushed.\n```\n\n</details>\n\n<!-- fingerprinting:phantom:medusa:chinchilla -->\n\n<!-- This is an auto-generated comment by CodeRabbit -->","created_at":"2025-08-30T00:45:04Z","updated_at":"2025-08-30T00:45:10Z","html_url":"https://github.com/oven-sh/bun/pull/21898#discussion_r2311703960","pull_request_url":"https://api.github.com/repos/oven-sh/bun/pulls/21898","author_association":"NONE","_links":{"self":{"href":"https://api.github.com/repos/oven-sh/bun/pulls/comments/2311703960"},"html":{"href":"https://github.com/oven-sh/bun/pull/21898#discussion_r2311703960"},"pull_request":{"href":"https://api.github.com/repos/oven-sh/bun/pulls/21898"}},"reactions":{"url":"https://api.github.com/repos/oven-sh/bun/pulls/comments/2311703960/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":14,"original_start_line":14,"start_side":"RIGHT","line":null,"original_line":51,"side":"RIGHT","original_position":51,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/oven-sh/bun/pulls/comments/2311703962","pull_request_review_id":3170766628,"id":2311703962,"node_id":"PRRC_kwDOFVKCyc6Jyc2a","diff_hunk":"@@ -0,0 +1,153 @@\n+#ifndef _WIN32\n+#ifndef __APPLE__\n+\n+#include <dirent.h>\n+#include <stdio.h>\n+#include <string.h>\n+#include <limits.h>\n+#include <openssl/x509.h>\n+#include <openssl/x509_vfy.h>\n+#include <openssl/pem.h>\n+\n+extern \"C\" void BUN__warn__extra_ca_load_failed(const char* filename, const char* error_msg);\n+\n+// Helper function to load certificates from a directory\n+static void load_certs_from_directory(const char* dir_path, STACK_OF(X509)* cert_stack) {\n+  DIR* dir = opendir(dir_path);\n+  if (!dir) {\n+    return;\n+  }\n+  \n+  struct dirent* entry;\n+  while ((entry = readdir(dir)) != NULL) {\n+    // Skip . and ..\n+    if (strcmp(entry->d_name, \".\") == 0 || strcmp(entry->d_name, \"..\") == 0) {\n+      continue;\n+    }\n+    \n+    // Check if file has .crt, .pem, or .cer extension\n+    const char* ext = strrchr(entry->d_name, '.');\n+    if (!ext || (strcmp(ext, \".crt\") != 0 && strcmp(ext, \".pem\") != 0 && strcmp(ext, \".cer\") != 0)) {\n+      continue;\n+    }\n+    \n+    // Build full path\n+    char filepath[PATH_MAX];\n+    snprintf(filepath, sizeof(filepath), \"%s/%s\", dir_path, entry->d_name);\n+    \n+    // Try to load certificate\n+    FILE* file = fopen(filepath, \"r\");\n+    if (file) {\n+      X509* cert = PEM_read_X509(file, NULL, NULL, NULL);\n+      fclose(file);\n+      \n+      if (cert) {\n+        sk_X509_push(cert_stack, cert);\n+      }\n+    }\n+  }\n+  \n+  closedir(dir);\n+}\n+\n+// Helper function to load certificates from a bundle file\n+static void load_certs_from_bundle(const char* bundle_path, STACK_OF(X509)* cert_stack) {\n+  FILE* file = fopen(bundle_path, \"r\");\n+  if (!file) {\n+    return;\n+  }\n+  \n+  X509* cert;\n+  while ((cert = PEM_read_X509(file, NULL, NULL, NULL)) != NULL) {\n+    sk_X509_push(cert_stack, cert);\n+  }\n+  \n+  fclose(file);\n+}","path":"packages/bun-usockets/src/crypto/root_certs_linux.cpp","commit_id":"1e05f26c3ba1dc7d90fcd3c1fb90348db3734849","original_commit_id":"56f543fde29b3af1380c98e2950582b9d8b0ab1f","user":{"login":"coderabbitai[bot]","id":136622811,"node_id":"BOT_kgDOCCSy2w","avatar_url":"https://avatars.githubusercontent.com/in/347564?v=4","gravatar_id":"","url":"https://api.github.com/users/coderabbitai%5Bbot%5D","html_url":"https://github.com/apps/coderabbitai","followers_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/followers","following_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/following{/other_user}","gists_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/gists{/gist_id}","starred_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/subscriptions","organizations_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/orgs","repos_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/repos","events_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/events{/privacy}","received_events_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"_üõ†Ô∏è Refactor suggestion_\n\n**Same leak risk in bundle loader loop.**\n\nFree the cert when push fails; also tolerate EOF by clearing errors after loop.\n\n```diff\n-  X509* cert;\n-  while ((cert = PEM_read_X509(file, NULL, NULL, NULL)) != NULL) {\n-    sk_X509_push(cert_stack, cert);\n-  }\n+  X509* cert;\n+  while ((cert = PEM_read_X509(file, NULL, NULL, NULL)) != NULL) {\n+    if (!sk_X509_push(cert_stack, cert)) {\n+      X509_free(cert);\n+      break;\n+    }\n+  }\n+  ERR_clear_error();\n```\n\n<!-- suggestion_start -->\n\n<details>\n<summary>üìù Committable suggestion</summary>\n\n> ‚ÄºÔ∏è **IMPORTANT**\n> Carefully review the code before committing. Ensure that it accurately replaces the highlighted code, contains no missing lines, and has no issues with indentation. Thoroughly test & benchmark the code to ensure it meets the requirements.\n\n```suggestion\n// Helper function to load certificates from a bundle file\nstatic void load_certs_from_bundle(const char* bundle_path, STACK_OF(X509)* cert_stack) {\n  FILE* file = fopen(bundle_path, \"r\");\n  if (!file) {\n    return;\n  }\n  \n  X509* cert;\n  while ((cert = PEM_read_X509(file, NULL, NULL, NULL)) != NULL) {\n    if (!sk_X509_push(cert_stack, cert)) {\n      X509_free(cert);\n      break;\n    }\n  }\n  ERR_clear_error();\n  \n  fclose(file);\n}\n```\n\n</details>\n\n<!-- suggestion_end -->\n\n<details>\n<summary>ü§ñ Prompt for AI Agents</summary>\n\n```\nIn packages/bun-usockets/src/crypto/root_certs_linux.cpp around lines 53 to 66,\nthe bundle loader loop can leak an X509 when sk_X509_push fails and may leave\nOpenSSL errors set on normal EOF; modify the loop so that if\nsk_X509_push(cert_stack, cert) returns failure you call X509_free(cert) before\nbreaking/returning, and after the PEM_read_X509 loop completes call\nERR_clear_error() to clear any EOF/PEM parse errors so they don't propagate;\nkeep the existing fclose(file).\n```\n\n</details>\n\n<!-- fingerprinting:phantom:medusa:chinchilla -->\n\n<!-- This is an auto-generated comment by CodeRabbit -->","created_at":"2025-08-30T00:45:04Z","updated_at":"2025-08-30T00:45:10Z","html_url":"https://github.com/oven-sh/bun/pull/21898#discussion_r2311703962","pull_request_url":"https://api.github.com/repos/oven-sh/bun/pulls/21898","author_association":"NONE","_links":{"self":{"href":"https://api.github.com/repos/oven-sh/bun/pulls/comments/2311703962"},"html":{"href":"https://github.com/oven-sh/bun/pull/21898#discussion_r2311703962"},"pull_request":{"href":"https://api.github.com/repos/oven-sh/bun/pulls/21898"}},"reactions":{"url":"https://api.github.com/repos/oven-sh/bun/pulls/comments/2311703962/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":53,"original_start_line":53,"start_side":"RIGHT","line":null,"original_line":66,"side":"RIGHT","original_position":66,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/oven-sh/bun/pulls/comments/2311703963","pull_request_review_id":3170766628,"id":2311703963,"node_id":"PRRC_kwDOFVKCyc6Jyc2b","diff_hunk":"@@ -0,0 +1,153 @@\n+#ifndef _WIN32\n+#ifndef __APPLE__\n+\n+#include <dirent.h>\n+#include <stdio.h>\n+#include <string.h>\n+#include <limits.h>\n+#include <openssl/x509.h>\n+#include <openssl/x509_vfy.h>\n+#include <openssl/pem.h>\n+\n+extern \"C\" void BUN__warn__extra_ca_load_failed(const char* filename, const char* error_msg);\n+\n+// Helper function to load certificates from a directory\n+static void load_certs_from_directory(const char* dir_path, STACK_OF(X509)* cert_stack) {\n+  DIR* dir = opendir(dir_path);\n+  if (!dir) {\n+    return;\n+  }\n+  \n+  struct dirent* entry;\n+  while ((entry = readdir(dir)) != NULL) {\n+    // Skip . and ..\n+    if (strcmp(entry->d_name, \".\") == 0 || strcmp(entry->d_name, \"..\") == 0) {\n+      continue;\n+    }\n+    \n+    // Check if file has .crt, .pem, or .cer extension\n+    const char* ext = strrchr(entry->d_name, '.');\n+    if (!ext || (strcmp(ext, \".crt\") != 0 && strcmp(ext, \".pem\") != 0 && strcmp(ext, \".cer\") != 0)) {\n+      continue;\n+    }\n+    \n+    // Build full path\n+    char filepath[PATH_MAX];\n+    snprintf(filepath, sizeof(filepath), \"%s/%s\", dir_path, entry->d_name);\n+    \n+    // Try to load certificate\n+    FILE* file = fopen(filepath, \"r\");\n+    if (file) {\n+      X509* cert = PEM_read_X509(file, NULL, NULL, NULL);\n+      fclose(file);\n+      \n+      if (cert) {\n+        sk_X509_push(cert_stack, cert);\n+      }\n+    }\n+  }\n+  \n+  closedir(dir);\n+}\n+\n+// Helper function to load certificates from a bundle file\n+static void load_certs_from_bundle(const char* bundle_path, STACK_OF(X509)* cert_stack) {\n+  FILE* file = fopen(bundle_path, \"r\");\n+  if (!file) {\n+    return;\n+  }\n+  \n+  X509* cert;\n+  while ((cert = PEM_read_X509(file, NULL, NULL, NULL)) != NULL) {\n+    sk_X509_push(cert_stack, cert);\n+  }\n+  \n+  fclose(file);\n+}\n+\n+// Main function to load system certificates on Linux and other Unix-like systems\n+extern \"C\" void us_load_system_certificates_linux(STACK_OF(X509) **system_certs) {\n+  *system_certs = sk_X509_new_null();\n+  if (*system_certs == NULL) {\n+    return;\n+  }\n+\n+  // First check environment variables (same as Node.js and OpenSSL)\n+  const char* ssl_cert_file = getenv(\"SSL_CERT_FILE\");\n+  const char* ssl_cert_dir = getenv(\"SSL_CERT_DIR\");\n+  \n+  // If SSL_CERT_FILE is set, load from it\n+  if (ssl_cert_file && strlen(ssl_cert_file) > 0) {\n+    load_certs_from_bundle(ssl_cert_file, *system_certs);\n+  }\n+  \n+  // If SSL_CERT_DIR is set, load from it\n+  if (ssl_cert_dir && strlen(ssl_cert_dir) > 0) {\n+    load_certs_from_directory(ssl_cert_dir, *system_certs);\n+  }\n+  \n+  // If environment variables were set and we loaded some certs, we're done\n+  // This matches OpenSSL behavior - when env vars are set, only use those\n+  if ((ssl_cert_file || ssl_cert_dir) && sk_X509_num(*system_certs) > 0) {\n+    return;\n+  }","path":"packages/bun-usockets/src/crypto/root_certs_linux.cpp","commit_id":"1e05f26c3ba1dc7d90fcd3c1fb90348db3734849","original_commit_id":"56f543fde29b3af1380c98e2950582b9d8b0ab1f","user":{"login":"coderabbitai[bot]","id":136622811,"node_id":"BOT_kgDOCCSy2w","avatar_url":"https://avatars.githubusercontent.com/in/347564?v=4","gravatar_id":"","url":"https://api.github.com/users/coderabbitai%5Bbot%5D","html_url":"https://github.com/apps/coderabbitai","followers_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/followers","following_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/following{/other_user}","gists_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/gists{/gist_id}","starred_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/subscriptions","organizations_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/orgs","repos_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/repos","events_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/events{/privacy}","received_events_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"_‚ö†Ô∏è Potential issue_\n\n**Env var semantics should be strict; don‚Äôt fallback if SSL_CERT_FILE/SSL_CERT_DIR is set.**\n\nOpenSSL treats these as authoritative. If set (even if empty/invalid), do not silently fall back to distro paths; this breaks Node‚Äôs tests.\n\n```diff\n-  // If environment variables were set and we loaded some certs, we're done\n-  // This matches OpenSSL behavior - when env vars are set, only use those\n-  if ((ssl_cert_file || ssl_cert_dir) && sk_X509_num(*system_certs) > 0) {\n-    return;\n-  }\n+  // If environment variables were set, use only those (even if they yield zero certs)\n+  if (ssl_cert_file || ssl_cert_dir) {\n+    return;\n+  }\n```\n\n<!-- suggestion_start -->\n\n<details>\n<summary>üìù Committable suggestion</summary>\n\n> ‚ÄºÔ∏è **IMPORTANT**\n> Carefully review the code before committing. Ensure that it accurately replaces the highlighted code, contains no missing lines, and has no issues with indentation. Thoroughly test & benchmark the code to ensure it meets the requirements.\n\n```suggestion\n  // First check environment variables (same as Node.js and OpenSSL)\n  const char* ssl_cert_file = getenv(\"SSL_CERT_FILE\");\n  const char* ssl_cert_dir = getenv(\"SSL_CERT_DIR\");\n  \n  // If SSL_CERT_FILE is set, load from it\n  if (ssl_cert_file && strlen(ssl_cert_file) > 0) {\n    load_certs_from_bundle(ssl_cert_file, *system_certs);\n  }\n  \n  // If SSL_CERT_DIR is set, load from it\n  if (ssl_cert_dir && strlen(ssl_cert_dir) > 0) {\n    load_certs_from_directory(ssl_cert_dir, *system_certs);\n  }\n  \n  // If environment variables were set, use only those (even if they yield zero certs)\n  if (ssl_cert_file || ssl_cert_dir) {\n    return;\n  }\n```\n\n</details>\n\n<!-- suggestion_end -->\n\n<details>\n<summary>ü§ñ Prompt for AI Agents</summary>\n\n```\nIn packages/bun-usockets/src/crypto/root_certs_linux.cpp around lines 75-93, the\ncode currently treats SSL_CERT_FILE/SSL_CERT_DIR as \"set\" only if strlen>0 but\nlater uses (ssl_cert_file || ssl_cert_dir) to decide whether to return, allowing\nempty env values to fall back to distro paths; OpenSSL semantics require that if\nan environment variable is present at all (getenv != nullptr) it is\nauthoritative. Change the logic to consider an env var set if getenv returned\nnon-null regardless of length: call load_certs_from_bundle/ directory only when\ngetenv returned non-null (you may still skip loading if the path is empty but\ntreat presence as deliberate), and update the final conditional to check\npresence (ssl_cert_file != nullptr || ssl_cert_dir != nullptr) so the function\nreturns without falling back even when no certs were successfully loaded.\n```\n\n</details>\n\n<!-- fingerprinting:phantom:medusa:chinchilla -->\n\n<!-- This is an auto-generated comment by CodeRabbit -->","created_at":"2025-08-30T00:45:04Z","updated_at":"2025-08-30T00:45:10Z","html_url":"https://github.com/oven-sh/bun/pull/21898#discussion_r2311703963","pull_request_url":"https://api.github.com/repos/oven-sh/bun/pulls/21898","author_association":"NONE","_links":{"self":{"href":"https://api.github.com/repos/oven-sh/bun/pulls/comments/2311703963"},"html":{"href":"https://github.com/oven-sh/bun/pull/21898#discussion_r2311703963"},"pull_request":{"href":"https://api.github.com/repos/oven-sh/bun/pulls/21898"}},"reactions":{"url":"https://api.github.com/repos/oven-sh/bun/pulls/comments/2311703963/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":75,"original_start_line":75,"start_side":"RIGHT","line":null,"original_line":93,"side":"RIGHT","original_position":93,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/oven-sh/bun/pulls/comments/2311703964","pull_request_review_id":3170766628,"id":2311703964,"node_id":"PRRC_kwDOFVKCyc6Jyc2c","diff_hunk":"@@ -0,0 +1,153 @@\n+#ifndef _WIN32\n+#ifndef __APPLE__\n+\n+#include <dirent.h>\n+#include <stdio.h>\n+#include <string.h>\n+#include <limits.h>\n+#include <openssl/x509.h>\n+#include <openssl/x509_vfy.h>\n+#include <openssl/pem.h>\n+\n+extern \"C\" void BUN__warn__extra_ca_load_failed(const char* filename, const char* error_msg);\n+\n+// Helper function to load certificates from a directory\n+static void load_certs_from_directory(const char* dir_path, STACK_OF(X509)* cert_stack) {\n+  DIR* dir = opendir(dir_path);\n+  if (!dir) {\n+    return;\n+  }\n+  \n+  struct dirent* entry;\n+  while ((entry = readdir(dir)) != NULL) {\n+    // Skip . and ..\n+    if (strcmp(entry->d_name, \".\") == 0 || strcmp(entry->d_name, \"..\") == 0) {\n+      continue;\n+    }\n+    \n+    // Check if file has .crt, .pem, or .cer extension\n+    const char* ext = strrchr(entry->d_name, '.');\n+    if (!ext || (strcmp(ext, \".crt\") != 0 && strcmp(ext, \".pem\") != 0 && strcmp(ext, \".cer\") != 0)) {\n+      continue;\n+    }\n+    \n+    // Build full path\n+    char filepath[PATH_MAX];\n+    snprintf(filepath, sizeof(filepath), \"%s/%s\", dir_path, entry->d_name);\n+    \n+    // Try to load certificate\n+    FILE* file = fopen(filepath, \"r\");\n+    if (file) {\n+      X509* cert = PEM_read_X509(file, NULL, NULL, NULL);\n+      fclose(file);\n+      \n+      if (cert) {\n+        sk_X509_push(cert_stack, cert);\n+      }\n+    }\n+  }\n+  \n+  closedir(dir);\n+}\n+\n+// Helper function to load certificates from a bundle file\n+static void load_certs_from_bundle(const char* bundle_path, STACK_OF(X509)* cert_stack) {\n+  FILE* file = fopen(bundle_path, \"r\");\n+  if (!file) {\n+    return;\n+  }\n+  \n+  X509* cert;\n+  while ((cert = PEM_read_X509(file, NULL, NULL, NULL)) != NULL) {\n+    sk_X509_push(cert_stack, cert);\n+  }\n+  \n+  fclose(file);\n+}\n+\n+// Main function to load system certificates on Linux and other Unix-like systems\n+extern \"C\" void us_load_system_certificates_linux(STACK_OF(X509) **system_certs) {\n+  *system_certs = sk_X509_new_null();\n+  if (*system_certs == NULL) {\n+    return;\n+  }\n+\n+  // First check environment variables (same as Node.js and OpenSSL)\n+  const char* ssl_cert_file = getenv(\"SSL_CERT_FILE\");\n+  const char* ssl_cert_dir = getenv(\"SSL_CERT_DIR\");\n+  \n+  // If SSL_CERT_FILE is set, load from it\n+  if (ssl_cert_file && strlen(ssl_cert_file) > 0) {\n+    load_certs_from_bundle(ssl_cert_file, *system_certs);\n+  }\n+  \n+  // If SSL_CERT_DIR is set, load from it\n+  if (ssl_cert_dir && strlen(ssl_cert_dir) > 0) {\n+    load_certs_from_directory(ssl_cert_dir, *system_certs);\n+  }\n+  \n+  // If environment variables were set and we loaded some certs, we're done\n+  // This matches OpenSSL behavior - when env vars are set, only use those\n+  if ((ssl_cert_file || ssl_cert_dir) && sk_X509_num(*system_certs) > 0) {\n+    return;\n+  }\n+\n+  // Otherwise, load certificates from standard Linux/Unix paths\n+  // These are the common locations for system certificates\n+  \n+  // Common certificate bundle locations (single file with multiple certs)\n+  // These paths are based on common Linux distributions and OpenSSL defaults\n+  static const char* bundle_paths[] = {\n+    \"/etc/ssl/certs/ca-certificates.crt\",  // Debian/Ubuntu/Gentoo\n+    \"/etc/pki/tls/certs/ca-bundle.crt\",    // Fedora/RHEL 6\n+    \"/etc/ssl/ca-bundle.pem\",               // OpenSUSE\n+    \"/etc/pki/tls/cert.pem\",                // Fedora/RHEL 7+\n+    \"/etc/pki/ca-trust/extracted/pem/tls-ca-bundle.pem\",  // CentOS/RHEL 7+\n+    \"/etc/ssl/cert.pem\",                    // Alpine Linux, macOS OpenSSL\n+    \"/usr/local/etc/openssl/cert.pem\",      // Homebrew OpenSSL on macOS\n+    \"/usr/local/share/ca-certificates/ca-certificates.crt\", // Custom CA installs\n+    NULL\n+  };\n+  \n+  // Common certificate directory locations (multiple files)\n+  // Note: OpenSSL expects hashed symlinks in directories (c_rehash format)\n+  static const char* dir_paths[] = {\n+    \"/etc/ssl/certs\",           // Common location (Debian/Ubuntu with hashed links)\n+    \"/etc/pki/tls/certs\",       // RHEL/Fedora\n+    \"/usr/share/ca-certificates\", // Debian/Ubuntu (original certs, not hashed)\n+    \"/usr/local/share/certs\",   // FreeBSD\n+    \"/etc/openssl/certs\",       // NetBSD  \n+    \"/var/ssl/certs\",           // AIX\n+    \"/usr/local/etc/openssl/certs\", // Homebrew OpenSSL on macOS\n+    \"/System/Library/OpenSSL/certs\", // macOS system OpenSSL (older versions)\n+    NULL\n+  };\n+  \n+  // Try loading from bundle files first\n+  for (const char** path = bundle_paths; *path != NULL; path++) {\n+    load_certs_from_bundle(*path, *system_certs);\n+  }\n+  \n+  // Then try loading from directories\n+  for (const char** path = dir_paths; *path != NULL; path++) {\n+    load_certs_from_directory(*path, *system_certs);\n+  }\n+  \n+  // Also check NODE_EXTRA_CA_CERTS environment variable\n+  const char* extra_ca_certs = getenv(\"NODE_EXTRA_CA_CERTS\");\n+  if (extra_ca_certs && strlen(extra_ca_certs) > 0) {\n+    FILE* file = fopen(extra_ca_certs, \"r\");\n+    if (file) {\n+      X509* cert;\n+      while ((cert = PEM_read_X509(file, NULL, NULL, NULL)) != NULL) {\n+        sk_X509_push(*system_certs, cert);\n+      }\n+      fclose(file);\n+    } else {\n+      BUN__warn__extra_ca_load_failed(extra_ca_certs, \"Failed to open file\");\n+    }\n+  }\n+}","path":"packages/bun-usockets/src/crypto/root_certs_linux.cpp","commit_id":"1e05f26c3ba1dc7d90fcd3c1fb90348db3734849","original_commit_id":"56f543fde29b3af1380c98e2950582b9d8b0ab1f","user":{"login":"coderabbitai[bot]","id":136622811,"node_id":"BOT_kgDOCCSy2w","avatar_url":"https://avatars.githubusercontent.com/in/347564?v=4","gravatar_id":"","url":"https://api.github.com/users/coderabbitai%5Bbot%5D","html_url":"https://github.com/apps/coderabbitai","followers_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/followers","following_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/following{/other_user}","gists_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/gists{/gist_id}","starred_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/subscriptions","organizations_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/orgs","repos_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/repos","events_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/events{/privacy}","received_events_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"_üõ†Ô∏è Refactor suggestion_\n\n**Parse colon-separated SSL_CERT_DIR; current code treats it as a single path.**\n\nOpenSSL supports a PATH_SEPARATOR list. Split on ':' (or ';' on Windows, not relevant here) and iterate.\n\nExample (pseudo):\n\n```c++\nfor (const char* p = ssl_cert_dir; p; /*advance*/) {\n  // split on ':', call load_certs_from_directory for each\n}\n```\n\nI can send a concrete split helper if desired.\n\n<details>\n<summary>ü§ñ Prompt for AI Agents</summary>\n\n```\npackages/bun-usockets/src/crypto/root_certs_linux.cpp lines 136-150: the code\ntreats SSL_CERT_DIR as a single path but OpenSSL expects a\nPATH_SEPARATOR-separated list (':' on Linux); split ssl_cert_dir on ':' and\niterate over each non-empty token, calling the existing\nload_certs_from_directory (or equivalent) for each directory; implement a simple\nloop that finds ':' delimiters (or uses strtok_r) to extract each directory\nsubstring, trim/skip empty entries, attempt to load certs from each, and\npreserve existing error handling for individual failures.\n```\n\n</details>\n\n<!-- fingerprinting:phantom:medusa:chinchilla -->\n\n<!-- This is an auto-generated comment by CodeRabbit -->","created_at":"2025-08-30T00:45:04Z","updated_at":"2025-08-30T00:45:10Z","html_url":"https://github.com/oven-sh/bun/pull/21898#discussion_r2311703964","pull_request_url":"https://api.github.com/repos/oven-sh/bun/pulls/21898","author_association":"NONE","_links":{"self":{"href":"https://api.github.com/repos/oven-sh/bun/pulls/comments/2311703964"},"html":{"href":"https://github.com/oven-sh/bun/pull/21898#discussion_r2311703964"},"pull_request":{"href":"https://api.github.com/repos/oven-sh/bun/pulls/21898"}},"reactions":{"url":"https://api.github.com/repos/oven-sh/bun/pulls/comments/2311703964/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":136,"original_start_line":136,"start_side":"RIGHT","line":null,"original_line":150,"side":"RIGHT","original_position":150,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/oven-sh/bun/pulls/comments/2311703967","pull_request_review_id":3170766628,"id":2311703967,"node_id":"PRRC_kwDOFVKCyc6Jyc2f","diff_hunk":"@@ -0,0 +1,59 @@\n+#ifdef _WIN32\n+\n+#include <windows.h>\n+#include <wincrypt.h>\n+#include <vector>\n+#include <cstring>\n+\n+// Forward declaration to avoid including OpenSSL headers here\n+// This prevents conflicts with Windows macros like X509_NAME\n+// Note: We don't use STACK_OF macro here since we don't have OpenSSL headers\n+\n+// Structure to hold raw certificate data","path":"packages/bun-usockets/src/crypto/root_certs_windows.cpp","commit_id":"1e05f26c3ba1dc7d90fcd3c1fb90348db3734849","original_commit_id":"56f543fde29b3af1380c98e2950582b9d8b0ab1f","user":{"login":"coderabbitai[bot]","id":136622811,"node_id":"BOT_kgDOCCSy2w","avatar_url":"https://avatars.githubusercontent.com/in/347564?v=4","gravatar_id":"","url":"https://api.github.com/users/coderabbitai%5Bbot%5D","html_url":"https://github.com/apps/coderabbitai","followers_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/followers","following_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/following{/other_user}","gists_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/gists{/gist_id}","starred_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/subscriptions","organizations_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/orgs","repos_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/repos","events_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/events{/privacy}","received_events_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"_üõ†Ô∏è Refactor suggestion_\n\n**Missing shared platform header; type visibility risk.**\n\nThis TU defines RawCertificate locally and declares the function without including the shared declaration. Include your `root_certs_platform.h` to keep types/signatures consistent across TUs.\n\n```diff\n #ifdef _WIN32\n-\n-#include <windows.h>\n+#include <windows.h>\n #include <wincrypt.h>\n #include <vector>\n #include <cstring>\n+// Keep declarations in sync:\n+#include \"root_certs_platform.h\"\n```\n\n<!-- suggestion_start -->\n\n<details>\n<summary>üìù Committable suggestion</summary>\n\n> ‚ÄºÔ∏è **IMPORTANT**\n> Carefully review the code before committing. Ensure that it accurately replaces the highlighted code, contains no missing lines, and has no issues with indentation. Thoroughly test & benchmark the code to ensure it meets the requirements.\n\n```suggestion\n#ifdef _WIN32\n#include <windows.h>\n#include <wincrypt.h>\n#include <vector>\n#include <cstring>\n// Keep declarations in sync:\n#include \"root_certs_platform.h\"\n\n// Forward declaration to avoid including OpenSSL headers here\n// This prevents conflicts with Windows macros like X509_NAME\n// Note: We don't use STACK_OF macro here since we don't have OpenSSL headers\n\n// Structure to hold raw certificate data\n```\n\n</details>\n\n<!-- suggestion_end -->\n\n<details>\n<summary>ü§ñ Prompt for AI Agents</summary>\n\n```\npackages/bun-usockets/src/crypto/root_certs_windows.cpp around lines 1-12: this\nTU defines RawCertificate locally and declares functions without including the\nshared platform header, risking type/signature mismatch across translation\nunits; remove the local RawCertificate definition and add #include\n\"root_certs_platform.h\" (using the correct relative path) at the top so the\nshared declaration is used consistently, then update any references to match the\nheader's types/signatures.\n```\n\n</details>\n\n<!-- fingerprinting:phantom:medusa:chinchilla -->\n\n<!-- This is an auto-generated comment by CodeRabbit -->","created_at":"2025-08-30T00:45:04Z","updated_at":"2025-08-30T00:45:10Z","html_url":"https://github.com/oven-sh/bun/pull/21898#discussion_r2311703967","pull_request_url":"https://api.github.com/repos/oven-sh/bun/pulls/21898","author_association":"NONE","_links":{"self":{"href":"https://api.github.com/repos/oven-sh/bun/pulls/comments/2311703967"},"html":{"href":"https://github.com/oven-sh/bun/pull/21898#discussion_r2311703967"},"pull_request":{"href":"https://api.github.com/repos/oven-sh/bun/pulls/21898"}},"reactions":{"url":"https://api.github.com/repos/oven-sh/bun/pulls/comments/2311703967/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":1,"original_start_line":1,"start_side":"RIGHT","line":12,"original_line":12,"side":"RIGHT","original_position":12,"position":12,"subject_type":"line"},{"url":"https://api.github.com/repos/oven-sh/bun/pulls/comments/2311703969","pull_request_review_id":3170766628,"id":2311703969,"node_id":"PRRC_kwDOFVKCyc6Jyc2h","diff_hunk":"@@ -0,0 +1,59 @@\n+#ifdef _WIN32\n+\n+#include <windows.h>\n+#include <wincrypt.h>\n+#include <vector>\n+#include <cstring>\n+\n+// Forward declaration to avoid including OpenSSL headers here\n+// This prevents conflicts with Windows macros like X509_NAME\n+// Note: We don't use STACK_OF macro here since we don't have OpenSSL headers\n+\n+// Structure to hold raw certificate data\n+struct RawCertificate {\n+  std::vector<unsigned char> data;\n+};\n+\n+// Helper function to load raw certificates from a Windows certificate store\n+static void LoadRawCertsFromStore(std::vector<RawCertificate>& raw_certs, \n+                                  DWORD store_flags, \n+                                  const wchar_t* store_name) {\n+  HCERTSTORE cert_store = CertOpenStore(\n+    CERT_STORE_PROV_SYSTEM_W,\n+    0,\n+    0,\n+    store_flags | CERT_STORE_READONLY_FLAG,\n+    store_name\n+  );\n+  \n+  if (cert_store == NULL) {\n+    return;\n+  }\n+  \n+  PCCERT_CONTEXT cert_context = NULL;\n+  while ((cert_context = CertEnumCertificatesInStore(cert_store, cert_context)) != NULL) {\n+    RawCertificate raw_cert;\n+    raw_cert.data.assign(cert_context->pbCertEncoded, \n+                        cert_context->pbCertEncoded + cert_context->cbCertEncoded);\n+    raw_certs.push_back(std::move(raw_cert));\n+  }\n+  \n+  CertCloseStore(cert_store, 0);\n+}\n+\n+// Main function to load raw system certificates on Windows\n+// Returns certificates as raw DER data to avoid OpenSSL header conflicts\n+extern void us_load_system_certificates_windows_raw(\n+    std::vector<RawCertificate>& raw_certs) {\n+  // Load from Current User stores\n+  LoadRawCertsFromStore(raw_certs, CERT_SYSTEM_STORE_CURRENT_USER, L\"ROOT\");\n+  LoadRawCertsFromStore(raw_certs, CERT_SYSTEM_STORE_CURRENT_USER, L\"CA\");\n+  LoadRawCertsFromStore(raw_certs, CERT_SYSTEM_STORE_CURRENT_USER, L\"TrustedPeople\");\n+  \n+  // Load from Local Machine stores (system-wide certificates)\n+  LoadRawCertsFromStore(raw_certs, CERT_SYSTEM_STORE_LOCAL_MACHINE, L\"ROOT\");\n+  LoadRawCertsFromStore(raw_certs, CERT_SYSTEM_STORE_LOCAL_MACHINE, L\"CA\");\n+  LoadRawCertsFromStore(raw_certs, CERT_SYSTEM_STORE_LOCAL_MACHINE, L\"TrustedPeople\");\n+}","path":"packages/bun-usockets/src/crypto/root_certs_windows.cpp","commit_id":"1e05f26c3ba1dc7d90fcd3c1fb90348db3734849","original_commit_id":"56f543fde29b3af1380c98e2950582b9d8b0ab1f","user":{"login":"coderabbitai[bot]","id":136622811,"node_id":"BOT_kgDOCCSy2w","avatar_url":"https://avatars.githubusercontent.com/in/347564?v=4","gravatar_id":"","url":"https://api.github.com/users/coderabbitai%5Bbot%5D","html_url":"https://github.com/apps/coderabbitai","followers_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/followers","following_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/following{/other_user}","gists_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/gists{/gist_id}","starred_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/subscriptions","organizations_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/orgs","repos_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/repos","events_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/events{/privacy}","received_events_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"_üí° Verification agent_\n\n<details>\n<summary>üß© Analysis chain</summary>\n\n**Store selection likely too permissive; diverges from Node and may trust end-entity certs.**\n\nLoading from CA and TrustedPeople (both CU and LM) risks adding intermediates or leafs as trust anchors. Align with Node‚Äôs ‚Äúsystem roots‚Äù by starting with ROOT only; add others only with explicit policy and filtering (BasicConstraints CA=TRUE).\n\n```diff\n-  // Load from Current User stores\n-  LoadRawCertsFromStore(raw_certs, CERT_SYSTEM_STORE_CURRENT_USER, L\"ROOT\");\n-  LoadRawCertsFromStore(raw_certs, CERT_SYSTEM_STORE_CURRENT_USER, L\"CA\");\n-  LoadRawCertsFromStore(raw_certs, CERT_SYSTEM_STORE_CURRENT_USER, L\"TrustedPeople\");\n-  \n-  // Load from Local Machine stores (system-wide certificates)\n-  LoadRawCertsFromStore(raw_certs, CERT_SYSTEM_STORE_LOCAL_MACHINE, L\"ROOT\");\n-  LoadRawCertsFromStore(raw_certs, CERT_SYSTEM_STORE_LOCAL_MACHINE, L\"CA\");\n-  LoadRawCertsFromStore(raw_certs, CERT_SYSTEM_STORE_LOCAL_MACHINE, L\"TrustedPeople\");\n+  // Load only from ROOT by default\n+  LoadRawCertsFromStore(raw_certs, CERT_SYSTEM_STORE_CURRENT_USER, L\"ROOT\");\n+  LoadRawCertsFromStore(raw_certs, CERT_SYSTEM_STORE_LOCAL_MACHINE, L\"ROOT\");\n```\n\nIf you must include TrustedPeople for compatibility, filter for CA=TRUE via CryptoAPI (e.g., check Basic Constraints extension) before adding.\n\nWould you like me to draft the BasicConstraints filter using CertFindExtension?\n\n---\n\nüèÅ Script executed:\n\n```shell\n#!/bin/bash\n# Search for the definition and usage of LoadRawCertsFromStore in the Windows crypto implementation\nrg -nP 'LoadRawCertsFromStore' -C3 packages/bun-usockets/src/crypto\n```\n\nLength of output: 2322\n\n---\n\n\n\n</details>\n\n**Restrict Windows system cert store loads to ROOT only**  \nLoading from CA and TrustedPeople risks trusting intermediates or end-entity certs. Limit us_load_system_certificates_windows_raw to only CERT_SYSTEM_STORE_CURRENT_USER/LOCAL_MACHINE ‚ÄúROOT‚Äù. If TrustedPeople compatibility is required, filter each cert‚Äôs BasicConstraints CA=TRUE before adding.  \n```diff\n-  // Load from Current User stores\n-  LoadRawCertsFromStore(raw_certs, CERT_SYSTEM_STORE_CURRENT_USER, L\"ROOT\");\n-  LoadRawCertsFromStore(raw_certs, CERT_SYSTEM_STORE_CURRENT_USER, L\"CA\");\n-  LoadRawCertsFromStore(raw_certs, CERT_SYSTEM_STORE_CURRENT_USER, L\"TrustedPeople\");\n-  \n-  // Load from Local Machine stores (system-wide certificates)\n-  LoadRawCertsFromStore(raw_certs, CERT_SYSTEM_STORE_LOCAL_MACHINE, L\"ROOT\");\n-  LoadRawCertsFromStore(raw_certs, CERT_SYSTEM_STORE_LOCAL_MACHINE, L\"CA\");\n-  LoadRawCertsFromStore(raw_certs, CERT_SYSTEM_STORE_LOCAL_MACHINE, L\"TrustedPeople\");\n+  // Load only from ROOT by default\n+  LoadRawCertsFromStore(raw_certs, CERT_SYSTEM_STORE_CURRENT_USER, L\"ROOT\");\n+  LoadRawCertsFromStore(raw_certs, CERT_SYSTEM_STORE_LOCAL_MACHINE, L\"ROOT\");\n```  \nIf TrustedPeople must be included, apply a BasicConstraints CA=TRUE filter via CryptoAPI (e.g., CertFindExtension) before adding.\n\n<!-- suggestion_start -->\n\n<details>\n<summary>üìù Committable suggestion</summary>\n\n> ‚ÄºÔ∏è **IMPORTANT**\n> Carefully review the code before committing. Ensure that it accurately replaces the highlighted code, contains no missing lines, and has no issues with indentation. Thoroughly test & benchmark the code to ensure it meets the requirements.\n\n```suggestion\n// Main function to load raw system certificates on Windows\n// Returns certificates as raw DER data to avoid OpenSSL header conflicts\nextern void us_load_system_certificates_windows_raw(\n    std::vector<RawCertificate>& raw_certs) {\n  // Load only from ROOT by default\n  LoadRawCertsFromStore(raw_certs, CERT_SYSTEM_STORE_CURRENT_USER, L\"ROOT\");\n  LoadRawCertsFromStore(raw_certs, CERT_SYSTEM_STORE_LOCAL_MACHINE, L\"ROOT\");\n}\n```\n\n</details>\n\n<!-- suggestion_end -->\n\n<details>\n<summary>ü§ñ Prompt for AI Agents</summary>\n\n```\nIn packages/bun-usockets/src/crypto/root_certs_windows.cpp around lines 44-57,\nthe function currently loads certificates from ROOT, CA, and TrustedPeople\nstores for both CURRENT_USER and LOCAL_MACHINE; update it to only load the ROOT\nstore for each (CERT_SYSTEM_STORE_CURRENT_USER and\nCERT_SYSTEM_STORE_LOCAL_MACHINE) to avoid importing intermediates/end-entity\ncerts, removing the LoadRawCertsFromStore calls for \"CA\" and \"TrustedPeople\"; if\nTrustedPeople must be supported, re-add its loading but apply a BasicConstraints\nCA=TRUE check on each certificate (use CertFindExtension or equivalent CryptoAPI\nto inspect the BasicConstraints extension and only add certs where CA is true)\nbefore pushing into raw_certs.\n```\n\n</details>\n\n<!-- fingerprinting:phantom:medusa:chinchilla -->\n\n<!-- This is an auto-generated comment by CodeRabbit -->","created_at":"2025-08-30T00:45:04Z","updated_at":"2025-08-30T00:45:10Z","html_url":"https://github.com/oven-sh/bun/pull/21898#discussion_r2311703969","pull_request_url":"https://api.github.com/repos/oven-sh/bun/pulls/21898","author_association":"NONE","_links":{"self":{"href":"https://api.github.com/repos/oven-sh/bun/pulls/comments/2311703969"},"html":{"href":"https://github.com/oven-sh/bun/pull/21898#discussion_r2311703969"},"pull_request":{"href":"https://api.github.com/repos/oven-sh/bun/pulls/21898"}},"reactions":{"url":"https://api.github.com/repos/oven-sh/bun/pulls/comments/2311703969/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":44,"original_start_line":44,"start_side":"RIGHT","line":57,"original_line":57,"side":"RIGHT","original_position":57,"position":57,"subject_type":"line"},{"url":"https://api.github.com/repos/oven-sh/bun/pulls/comments/2311703972","pull_request_review_id":3170766628,"id":2311703972,"node_id":"PRRC_kwDOFVKCyc6Jyc2k","diff_hunk":"@@ -6,10 +6,46 @@\n #include <atomic>\n #include <string.h>\n #include \"./default_ciphers.h\"\n+\n+// System-specific includes for certificate loading\n+#include \"./root_certs_platform.h\"\n+#ifdef _WIN32\n+#include <windows.h>\n+#include <wincrypt.h>\n+#else\n+// Linux/Unix includes\n+#include <dirent.h>\n+#include <stdio.h>\n+#include <limits.h>\n+#endif\n static const int root_certs_size = sizeof(root_certs) / sizeof(root_certs[0]);\n \n extern \"C\" void BUN__warn__extra_ca_load_failed(const char* filename, const char* error_msg);\n \n+// Forward declarations for platform-specific functions\n+// (Actual implementations are in platform-specific files)\n+\n+// External variable from Zig CLI arguments\n+extern \"C\" bool Bun__Node__UseSystemCA;\n+\n+// Helper function to check if system CA should be used\n+// Checks both CLI flag (--use-system-ca) and environment variable (NODE_USE_SYSTEM_CA=1)\n+static bool us_should_use_system_ca() {\n+  // Check CLI flag first\n+  if (Bun__Node__UseSystemCA) {\n+    return true;\n+  }\n+  \n+  // Check environment variable\n+  const char *use_system_ca = getenv(\"NODE_USE_SYSTEM_CA\");\n+  return use_system_ca && (strcmp(use_system_ca, \"1\") == 0 || strcmp(use_system_ca, \"true\") == 0);\n+}","path":"packages/bun-usockets/src/crypto/root_certs.cpp","commit_id":"1e05f26c3ba1dc7d90fcd3c1fb90348db3734849","original_commit_id":"56f543fde29b3af1380c98e2950582b9d8b0ab1f","user":{"login":"coderabbitai[bot]","id":136622811,"node_id":"BOT_kgDOCCSy2w","avatar_url":"https://avatars.githubusercontent.com/in/347564?v=4","gravatar_id":"","url":"https://api.github.com/users/coderabbitai%5Bbot%5D","html_url":"https://github.com/apps/coderabbitai","followers_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/followers","following_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/following{/other_user}","gists_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/gists{/gist_id}","starred_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/subscriptions","organizations_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/orgs","repos_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/repos","events_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/events{/privacy}","received_events_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"_üí° Verification agent_\n\n<details>\n<summary>üß© Analysis chain</summary>\n\n**Match Node‚Äôs semantics precisely for NODE_USE_SYSTEM_CA.**\n\nCurrently accepts \"1\" or \"true\". If Node only recognizes \"1\", this can cause spec-divergent behavior and failing compat tests.\n\n\n\n\n```diff\n-  const char *use_system_ca = getenv(\"NODE_USE_SYSTEM_CA\");\n-  return use_system_ca && (strcmp(use_system_ca, \"1\") == 0 || strcmp(use_system_ca, \"true\") == 0);\n+  const char *use_system_ca = getenv(\"NODE_USE_SYSTEM_CA\");\n+  return use_system_ca && strcmp(use_system_ca, \"1\") == 0;\n```\n\n---\n\nüåê Web query:\n\n```web\nWhat exact values does Node.js accept for NODE_USE_SYSTEM_CA? Is it strictly \"1\" or are other truthy strings like \"true\" accepted?\n```\n\nüí° Result:\n\nShort answer: Node.js recognizes NODE_USE_SYSTEM_CA only as \"1\" (i.e. NODE_USE_SYSTEM_CA=1). The feature was added with that explicit name/value; other truthy strings like \"true\", \"yes\", or \"on\" are not documented as accepted. [1][2]\n\nSources:\n- Release/commit notes showing the CLI change that added \"NODE_USE_SYSTEM_CA=1\". [1]\n- Node CLI documentation for --use-system-ca / related env behavior (describes the option and the environment-variable addition but does not list alternative accepted values). [2]\n\n---\n\n\n\n</details>\n\n**Match Node.js semantics by only accepting \"1\" for NODE_USE_SYSTEM_CA**  \nNode.js recognizes NODE_USE_SYSTEM_CA only when set to ‚Äú1‚Äù; remove support for ‚Äútrue‚Äù to avoid compatibility mismatches.  \n\n```diff\n-  const char *use_system_ca = getenv(\"NODE_USE_SYSTEM_CA\");\n-  return use_system_ca && (strcmp(use_system_ca, \"1\") == 0 || strcmp(use_system_ca, \"true\") == 0);\n+  const char *use_system_ca = getenv(\"NODE_USE_SYSTEM_CA\");\n+  return use_system_ca && strcmp(use_system_ca, \"1\") == 0;\n```\n\n<!-- suggestion_start -->\n\n<details>\n<summary>üìù Committable suggestion</summary>\n\n> ‚ÄºÔ∏è **IMPORTANT**\n> Carefully review the code before committing. Ensure that it accurately replaces the highlighted code, contains no missing lines, and has no issues with indentation. Thoroughly test & benchmark the code to ensure it meets the requirements.\n\n```suggestion\nstatic bool us_should_use_system_ca() {\n  // Check CLI flag first\n  if (Bun__Node__UseSystemCA) {\n    return true;\n  }\n\n  // Check environment variable\n  const char *use_system_ca = getenv(\"NODE_USE_SYSTEM_CA\");\n  return use_system_ca && strcmp(use_system_ca, \"1\") == 0;\n}\n```\n\n</details>\n\n<!-- suggestion_end -->\n\n<details>\n<summary>ü§ñ Prompt for AI Agents</summary>\n\n```\nIn packages/bun-usockets/src/crypto/root_certs.cpp around lines 29 to 42, the\ncode accepts NODE_USE_SYSTEM_CA values \"1\" or \"true\", but Node.js semantics only\nrecognize \"1\"; update the environment-variable check to return true only when\nNODE_USE_SYSTEM_CA is exactly \"1\" (remove the strcmp(..., \"true\") comparison)\nwhile keeping the existing CLI flag check (Bun__Node__UseSystemCA).\n```\n\n</details>\n\n<!-- fingerprinting:phantom:medusa:chinchilla -->\n\n<!-- This is an auto-generated comment by CodeRabbit -->","created_at":"2025-08-30T00:45:05Z","updated_at":"2025-08-30T00:45:10Z","html_url":"https://github.com/oven-sh/bun/pull/21898#discussion_r2311703972","pull_request_url":"https://api.github.com/repos/oven-sh/bun/pulls/21898","author_association":"NONE","_links":{"self":{"href":"https://api.github.com/repos/oven-sh/bun/pulls/comments/2311703972"},"html":{"href":"https://github.com/oven-sh/bun/pull/21898#discussion_r2311703972"},"pull_request":{"href":"https://api.github.com/repos/oven-sh/bun/pulls/21898"}},"reactions":{"url":"https://api.github.com/repos/oven-sh/bun/pulls/comments/2311703972/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":29,"original_start_line":29,"start_side":"RIGHT","line":null,"original_line":42,"side":"RIGHT","original_position":37,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/oven-sh/bun/pulls/comments/2311703974","pull_request_review_id":3170766628,"id":2311703974,"node_id":"PRRC_kwDOFVKCyc6Jyc2m","diff_hunk":"@@ -151,20 +202,42 @@ STACK_OF(X509) *us_get_root_extra_cert_instances() {\n   return us_get_default_ca_certificates()->root_extra_cert_instances;\n }\n \n+STACK_OF(X509) *us_get_root_system_cert_instances() {\n+  auto certs = us_get_default_ca_certificates();\n+  \n+  // If system certificates haven't been loaded yet, load them now\n+  if (certs->root_system_cert_instances == NULL) {\n+#ifdef __APPLE__\n+    us_load_system_certificates_macos(&certs->root_system_cert_instances);\n+#elif defined(_WIN32)\n+    us_load_system_certificates_windows(&certs->root_system_cert_instances);\n+#else\n+    us_load_system_certificates_linux(&certs->root_system_cert_instances);\n+#endif\n+  }\n+  \n+  return certs->root_system_cert_instances;\n+}","path":"packages/bun-usockets/src/crypto/root_certs.cpp","commit_id":"1e05f26c3ba1dc7d90fcd3c1fb90348db3734849","original_commit_id":"56f543fde29b3af1380c98e2950582b9d8b0ab1f","user":{"login":"coderabbitai[bot]","id":136622811,"node_id":"BOT_kgDOCCSy2w","avatar_url":"https://avatars.githubusercontent.com/in/347564?v=4","gravatar_id":"","url":"https://api.github.com/users/coderabbitai%5Bbot%5D","html_url":"https://github.com/apps/coderabbitai","followers_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/followers","following_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/following{/other_user}","gists_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/gists{/gist_id}","starred_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/subscriptions","organizations_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/orgs","repos_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/repos","events_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/events{/privacy}","received_events_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"_‚ö†Ô∏è Potential issue_\n\n**Don‚Äôt load system certs when the feature is disabled; also avoid racing the initializer.**\n\nThis accessor unconditionally initializes system certificates, bypassing the flag and potentially causing tests like test-openssl-ca-options.js to fail. It can also race with us_internal_init_root_certs.\n\n\n\n```diff\n STACK_OF(X509) *us_get_root_system_cert_instances() {\n-  auto certs = us_get_default_ca_certificates();\n-  \n-  // If system certificates haven't been loaded yet, load them now\n-  if (certs->root_system_cert_instances == NULL) {\n-#ifdef __APPLE__\n-    us_load_system_certificates_macos(&certs->root_system_cert_instances);\n-#elif defined(_WIN32)\n-    us_load_system_certificates_windows(&certs->root_system_cert_instances);\n-#else\n-    us_load_system_certificates_linux(&certs->root_system_cert_instances);\n-#endif\n-  }\n-  \n-  return certs->root_system_cert_instances;\n+  if (!us_should_use_system_ca()) return NULL;\n+  // Ensure single-path initialization via us_internal_init_root_certs\n+  auto certs = us_get_default_ca_certificates();\n+  return certs->root_system_cert_instances;\n }\n```\n\n<!-- suggestion_start -->\n\n<details>\n<summary>üìù Committable suggestion</summary>\n\n> ‚ÄºÔ∏è **IMPORTANT**\n> Carefully review the code before committing. Ensure that it accurately replaces the highlighted code, contains no missing lines, and has no issues with indentation. Thoroughly test & benchmark the code to ensure it meets the requirements.\n\n```suggestion\nSTACK_OF(X509) *us_get_root_system_cert_instances() {\n  if (!us_should_use_system_ca())\n    return NULL;\n  // Ensure single-path initialization via us_internal_init_root_certs\n  auto certs = us_get_default_ca_certificates();\n  return certs->root_system_cert_instances;\n}\n```\n\n</details>\n\n<!-- suggestion_end -->\n\n<details>\n<summary>ü§ñ Prompt for AI Agents</summary>\n\n```\npackages/bun-usockets/src/crypto/root_certs.cpp lines 205-220: the accessor\ncurrently unconditionally initializes system certs and races with the global\ninitializer; change it so it does NOT load system certificates here when the\nfeature is disabled and does NOT perform initialization inline. Instead, simply\nfetch certs with us_get_default_ca_certificates() and return\ncerts->root_system_cert_instances if already set; do NOT call any\nus_load_system_certificates_* functions from this accessor. If lazy\ninitialization is required, delegate to the dedicated initializer\n(us_internal_init_root_certs or a new atomic/locked init function) that respects\nthe feature flag and uses atomic compare-and-swap or a mutex to avoid races;\nensure callers handle a NULL return rather than forcing init here.\n```\n\n</details>\n\n<!-- fingerprinting:phantom:medusa:chinchilla -->\n\n<!-- This is an auto-generated comment by CodeRabbit -->","created_at":"2025-08-30T00:45:05Z","updated_at":"2025-08-30T00:45:11Z","html_url":"https://github.com/oven-sh/bun/pull/21898#discussion_r2311703974","pull_request_url":"https://api.github.com/repos/oven-sh/bun/pulls/21898","author_association":"NONE","_links":{"self":{"href":"https://api.github.com/repos/oven-sh/bun/pulls/comments/2311703974"},"html":{"href":"https://github.com/oven-sh/bun/pull/21898#discussion_r2311703974"},"pull_request":{"href":"https://api.github.com/repos/oven-sh/bun/pulls/21898"}},"reactions":{"url":"https://api.github.com/repos/oven-sh/bun/pulls/comments/2311703974/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":205,"original_start_line":205,"start_side":"RIGHT","line":null,"original_line":220,"side":"RIGHT","original_position":112,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/oven-sh/bun/pulls/comments/2311703978","pull_request_review_id":3170766628,"id":2311703978,"node_id":"PRRC_kwDOFVKCyc6Jyc2q","diff_hunk":"@@ -151,20 +202,42 @@ STACK_OF(X509) *us_get_root_extra_cert_instances() {\n   return us_get_default_ca_certificates()->root_extra_cert_instances;\n }\n \n+STACK_OF(X509) *us_get_root_system_cert_instances() {\n+  auto certs = us_get_default_ca_certificates();\n+  \n+  // If system certificates haven't been loaded yet, load them now\n+  if (certs->root_system_cert_instances == NULL) {\n+#ifdef __APPLE__\n+    us_load_system_certificates_macos(&certs->root_system_cert_instances);\n+#elif defined(_WIN32)\n+    us_load_system_certificates_windows(&certs->root_system_cert_instances);\n+#else\n+    us_load_system_certificates_linux(&certs->root_system_cert_instances);\n+#endif\n+  }\n+  \n+  return certs->root_system_cert_instances;\n+}\n+\n extern \"C\" X509_STORE *us_get_default_ca_store() {\n   X509_STORE *store = X509_STORE_new();\n   if (store == NULL) {\n     return NULL;\n   }\n \n-  if (!X509_STORE_set_default_paths(store)) {\n-    X509_STORE_free(store);\n-    return NULL;\n+  // Only load system default paths when NODE_USE_SYSTEM_CA=1\n+  // Otherwise, rely on bundled certificates only (like Node.js behavior)\n+  if (us_should_use_system_ca()) {\n+    if (!X509_STORE_set_default_paths(store)) {\n+      X509_STORE_free(store);\n+      return NULL;\n+    }\n   }","path":"packages/bun-usockets/src/crypto/root_certs.cpp","commit_id":"1e05f26c3ba1dc7d90fcd3c1fb90348db3734849","original_commit_id":"56f543fde29b3af1380c98e2950582b9d8b0ab1f","user":{"login":"coderabbitai[bot]","id":136622811,"node_id":"BOT_kgDOCCSy2w","avatar_url":"https://avatars.githubusercontent.com/in/347564?v=4","gravatar_id":"","url":"https://api.github.com/users/coderabbitai%5Bbot%5D","html_url":"https://github.com/apps/coderabbitai","followers_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/followers","following_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/following{/other_user}","gists_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/gists{/gist_id}","starred_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/subscriptions","organizations_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/orgs","repos_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/repos","events_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/events{/privacy}","received_events_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"_‚ö†Ô∏è Potential issue_\n\n**Guard system CA additions to the store behind the flag.**\n\nIf any code calls us_get_root_system_cert_instances() earlier, root_system_cert_instances may be set even when the flag is off; we must still not append them unless enabled.\n\n\n\n```diff\n-  if (us_should_use_system_ca()) {\n+  if (us_should_use_system_ca()) {\n     if (!X509_STORE_set_default_paths(store)) {\n       X509_STORE_free(store);\n       return NULL;\n     }\n   }\n...\n-  if (root_system_cert_instances) {\n+  if (us_should_use_system_ca() && root_system_cert_instances) {\n     for (int i = 0; i < sk_X509_num(root_system_cert_instances); i++) {\n       X509 *cert = sk_X509_value(root_system_cert_instances, i);\n       X509_up_ref(cert);\n       X509_STORE_add_cert(store, cert);\n     }\n   }\n```\n\n\nAlso applies to: 259-265\n\n<details>\n<summary>ü§ñ Prompt for AI Agents</summary>\n\n```\nIn packages/bun-usockets/src/crypto/root_certs.cpp around lines 228-235 (and\nsimilarly 259-265), the code may append root_system_cert_instances to the store\neven when NODE_USE_SYSTEM_CA is off because root_system_cert_instances can be\npopulated earlier; change the logic so any addition of system CA data is\nstrictly gated by us_should_use_system_ca(): before calling\nX509_STORE_set_default_paths or appending root_system_cert_instances, check\nus_should_use_system_ca() and skip all system-CA appends when it returns false;\nensure any early-populated root_system_cert_instances are not used unless the\nflag is true and free/ignore them appropriately to avoid leaking or double-using\ncerts.\n```\n\n</details>\n\n<!-- fingerprinting:phantom:medusa:chinchilla -->\n\n<!-- This is an auto-generated comment by CodeRabbit -->","created_at":"2025-08-30T00:45:05Z","updated_at":"2025-08-30T00:45:11Z","html_url":"https://github.com/oven-sh/bun/pull/21898#discussion_r2311703978","pull_request_url":"https://api.github.com/repos/oven-sh/bun/pulls/21898","author_association":"NONE","_links":{"self":{"href":"https://api.github.com/repos/oven-sh/bun/pulls/comments/2311703978"},"html":{"href":"https://github.com/oven-sh/bun/pull/21898#discussion_r2311703978"},"pull_request":{"href":"https://api.github.com/repos/oven-sh/bun/pulls/21898"}},"reactions":{"url":"https://api.github.com/repos/oven-sh/bun/pulls/comments/2311703978/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":228,"original_start_line":228,"start_side":"RIGHT","line":null,"original_line":235,"side":"RIGHT","original_position":130,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/oven-sh/bun/pulls/comments/2311703979","pull_request_review_id":3170766628,"id":2311703979,"node_id":"PRRC_kwDOFVKCyc6Jyc2r","diff_hunk":"@@ -745,6 +748,25 @@ pub fn parse(allocator: std.mem.Allocator, ctx: Command.Context, comptime cmd: C\n         if (args.flag(\"--zero-fill-buffers\")) {\n             Bun__Node__ZeroFillBuffers = true;\n         }\n+        if (args.flag(\"--use-system-ca\")) {\n+            Bun__Node__UseSystemCA = true;\n+        }\n+\n+        // Node.js compatibility: validate mutually exclusive CA flags\n+        const use_openssl_ca = args.flag(\"--use-openssl-ca\");\n+        const use_bundled_ca = args.flag(\"--use-bundled-ca\");\n+\n+        if (use_openssl_ca and use_bundled_ca) {\n+            Output.prettyErrorln(\"<r><red>error<r>: either --use-openssl-ca or --use-bundled-ca can be used, not both\", .{});\n+            Global.exit(1);\n+        }\n+\n+        // For now, --use-openssl-ca behaves like --use-system-ca (use system CA store)\n+        if (use_openssl_ca) {\n+            Bun__Node__UseSystemCA = true;\n+        }\n+        // --use-bundled-ca is the default behavior (only use bundled certs)\n+        // So we don't need to set anything special for it\n     }","path":"src/cli/Arguments.zig","commit_id":"1e05f26c3ba1dc7d90fcd3c1fb90348db3734849","original_commit_id":"56f543fde29b3af1380c98e2950582b9d8b0ab1f","user":{"login":"coderabbitai[bot]","id":136622811,"node_id":"BOT_kgDOCCSy2w","avatar_url":"https://avatars.githubusercontent.com/in/347564?v=4","gravatar_id":"","url":"https://api.github.com/users/coderabbitai%5Bbot%5D","html_url":"https://github.com/apps/coderabbitai","followers_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/followers","following_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/following{/other_user}","gists_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/gists{/gist_id}","starred_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/subscriptions","organizations_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/orgs","repos_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/repos","events_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/events{/privacy}","received_events_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"_üõ†Ô∏è Refactor suggestion_\n\n**Conflicting flags and precedence handling are incomplete; env var not honored.**\n\n- Missing mutual exclusivity with `--use-system-ca` vs `--use-bundled-ca`/`--use-openssl-ca`.\n- `NODE_USE_SYSTEM_CA` is not parsed here, so precedence (CLI > env) isn‚Äôt enforced.\n- Mapping `--use-openssl-ca` to ‚Äúsystem CA‚Äù is not Node-compatible. In Node, `--use-openssl-ca` selects OpenSSL‚Äôs default CA store, distinct from ‚Äúsystem CA‚Äù (driven by NODE_USE_SYSTEM_CA).\n\nImplement full matrix: exactly one of {bundled, openssl, system} via CLI; if none provided, fall back to env var NODE_USE_SYSTEM_CA; else default bundled. Keep CLI > env.\n\n\nApply within this block:\n\n```diff\n-        if (args.flag(\"--use-system-ca\")) {\n-            Bun__Node__UseSystemCA = true;\n-        }\n-\n-        // Node.js compatibility: validate mutually exclusive CA flags\n-        const use_openssl_ca = args.flag(\"--use-openssl-ca\");\n-        const use_bundled_ca = args.flag(\"--use-bundled-ca\");\n-\n-        if (use_openssl_ca and use_bundled_ca) {\n-            Output.prettyErrorln(\"<r><red>error<r>: either --use-openssl-ca or --use-bundled-ca can be used, not both\", .{});\n-            Global.exit(1);\n-        }\n-\n-        // For now, --use-openssl-ca behaves like --use-system-ca (use system CA store)\n-        if (use_openssl_ca) {\n-            Bun__Node__UseSystemCA = true;\n-        }\n-        // --use-bundled-ca is the default behavior (only use bundled certs)\n-        // So we don't need to set anything special for it\n+        const use_system_ca   = args.flag(\"--use-system-ca\");\n+        const use_openssl_ca  = args.flag(\"--use-openssl-ca\");\n+        const use_bundled_ca  = args.flag(\"--use-bundled-ca\");\n+\n+        // Disallow any combination > 1\n+        if (@intFromBool(use_system_ca) + @intFromBool(use_openssl_ca) + @intFromBool(use_bundled_ca) > 1) {\n+            Output.prettyErrorln(\"<r><red>error<r>: choose exactly one of --use-system-ca, --use-openssl-ca, or --use-bundled-ca\", .{});\n+            Global.exit(1);\n+        }\n+\n+        // CLI overrides env var (NODE_USE_SYSTEM_CA)\n+        if (use_bundled_ca) {\n+            Bun__Node__CAStore = .bundled;\n+        } else if (use_openssl_ca) {\n+            Bun__Node__CAStore = .openssl;\n+        } else if (use_system_ca) {\n+            Bun__Node__CAStore = .system;\n+        } else {\n+            if (bun.getenvZ(\"NODE_USE_SYSTEM_CA\")) |val| {\n+                // truthy: 1/true/yes (case-insensitive)\n+                const ascii = std.ascii;\n+                const truthy = (val.len > 0 and (val[0] == '1')) or\n+                  ascii.eqlIgnoreCase(val, \"true\") or\n+                  ascii.eqlIgnoreCase(val, \"yes\");\n+                if (truthy) Bun__Node__CAStore = .system;\n+            }\n+        }\n+\n+        // Back-compat boolean used by native code until fully migrated\n+        Bun__Node__UseSystemCA = (Bun__Node__CAStore == .system);\n```\n\nAnd add the enum + default (outside this block):\n\n```zig\npub const BunCAStore = enum(u8) { bundled, openssl, system };\nexport var Bun__Node__CAStore: BunCAStore = .bundled;\n```\n\nFollow-ups: wire Bun__Node__CAStore into the native TLS path to distinguish OpenSSL vs System CA stores; keep boolean until migration is complete.\n\n<details>\n<summary>ü§ñ Prompt for AI Agents</summary>\n\n```\nIn src/cli/Arguments.zig around lines 751-770, the CA flag handling must be\nreplaced with an explicit enum-based selection and proper precedence: add the\nenum and exported variable (BunCAStore with values bundled, openssl, system and\nexport var Bun__Node__CAStore defaulting to .bundled) outside this block; inside\nlines 751-770, parse mutually-exclusive CLI flags --use-bundled-ca,\n--use-openssl-ca, and --use-system-ca, error and exit if more than one CLI flag\nis provided, otherwise set Bun__Node__CAStore to .bundled/.openssl/.system\naccordingly; if no CLI flag is provided, read NODE_USE_SYSTEM_CA env var and if\ntruthy set Bun__Node__CAStore = .system (CLI must take precedence over env);\nkeep setting Bun__Node__UseSystemCA boolean for now when Bun__Node__CAStore ==\n.system to preserve existing behavior until native-TLS wiring is updated.\n```\n\n</details>\n\n<!-- fingerprinting:phantom:medusa:chinchilla -->\n\n<!-- This is an auto-generated comment by CodeRabbit -->","created_at":"2025-08-30T00:45:05Z","updated_at":"2025-08-30T00:45:11Z","html_url":"https://github.com/oven-sh/bun/pull/21898#discussion_r2311703979","pull_request_url":"https://api.github.com/repos/oven-sh/bun/pulls/21898","author_association":"NONE","_links":{"self":{"href":"https://api.github.com/repos/oven-sh/bun/pulls/comments/2311703979"},"html":{"href":"https://github.com/oven-sh/bun/pull/21898#discussion_r2311703979"},"pull_request":{"href":"https://api.github.com/repos/oven-sh/bun/pulls/21898"}},"reactions":{"url":"https://api.github.com/repos/oven-sh/bun/pulls/comments/2311703979/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":751,"original_start_line":751,"start_side":"RIGHT","line":null,"original_line":770,"side":"RIGHT","original_position":33,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/oven-sh/bun/pulls/comments/2311703980","pull_request_review_id":3170766628,"id":2311703980,"node_id":"PRRC_kwDOFVKCyc6Jyc2s","diff_hunk":"@@ -1245,6 +1267,7 @@ pub fn parse(allocator: std.mem.Allocator, ctx: Command.Context, comptime cmd: C\n export var Bun__Node__ZeroFillBuffers = false;\n export var Bun__Node__ProcessNoDeprecation = false;\n export var Bun__Node__ProcessThrowDeprecation = false;\n+pub export var Bun__Node__UseSystemCA = false;\n ","path":"src/cli/Arguments.zig","commit_id":"1e05f26c3ba1dc7d90fcd3c1fb90348db3734849","original_commit_id":"56f543fde29b3af1380c98e2950582b9d8b0ab1f","user":{"login":"coderabbitai[bot]","id":136622811,"node_id":"BOT_kgDOCCSy2w","avatar_url":"https://avatars.githubusercontent.com/in/347564?v=4","gravatar_id":"","url":"https://api.github.com/users/coderabbitai%5Bbot%5D","html_url":"https://github.com/apps/coderabbitai","followers_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/followers","following_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/following{/other_user}","gists_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/gists{/gist_id}","starred_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/subscriptions","organizations_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/orgs","repos_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/repos","events_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/events{/privacy}","received_events_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"_üõ†Ô∏è Refactor suggestion_\n\n**Expose a tri-state instead of a boolean.**\n\nBoolean cannot represent ‚ÄúOpenSSL default CA store.‚Äù Add an exported enum as suggested above, keep this boolean as a temporary alias if other code depends on it.\n\n<details>\n<summary>ü§ñ Prompt for AI Agents</summary>\n\n```\nIn src/cli/Arguments.zig around lines 1270-1271, replace the single boolean\nexport with an exported tri-state enum to represent the three CA behaviors\n(e.g., UseSystemCA, UseOpenSSLDefaultCA, Disabled) so the OpenSSL-default option\ncan be distinguished; keep the existing pub export var Bun__Node__UseSystemCA =\nfalse as a temporary boolean alias mapping to one enum case for backward\ncompatibility, and update any internal uses to read the new enum value (or use\nthe alias until callers are migrated).\n```\n\n</details>\n\n<!-- fingerprinting:phantom:medusa:chinchilla -->\n\n<!-- This is an auto-generated comment by CodeRabbit -->","created_at":"2025-08-30T00:45:05Z","updated_at":"2025-08-30T00:45:11Z","html_url":"https://github.com/oven-sh/bun/pull/21898#discussion_r2311703980","pull_request_url":"https://api.github.com/repos/oven-sh/bun/pulls/21898","author_association":"NONE","_links":{"self":{"href":"https://api.github.com/repos/oven-sh/bun/pulls/comments/2311703980"},"html":{"href":"https://github.com/oven-sh/bun/pull/21898#discussion_r2311703980"},"pull_request":{"href":"https://api.github.com/repos/oven-sh/bun/pulls/21898"}},"reactions":{"url":"https://api.github.com/repos/oven-sh/bun/pulls/comments/2311703980/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":1270,"original_start_line":1270,"start_side":"RIGHT","line":null,"original_line":1271,"side":"RIGHT","original_position":41,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/oven-sh/bun/pulls/comments/2311703981","pull_request_review_id":3170766628,"id":2311703981,"node_id":"PRRC_kwDOFVKCyc6Jyc2t","diff_hunk":"@@ -0,0 +1,238 @@\n+import { describe, expect, test } from \"bun:test\";\n+import { promises as fs } from \"fs\";\n+import { bunEnv, bunExe, tempDirWithFiles } from \"harness\";\n+import { platform } from \"os\";\n+import { join } from \"path\";\n+\n+describe(\"NODE_USE_SYSTEM_CA Complete Implementation\", () => {\n+  test(\"should work with standard HTTPS sites\", async () => {\n+    const testDir = tempDirWithFiles(\"node-use-system-ca-basic\", {});\n+\n+    const testScript = `\n+async function testHttpsRequest() {\n+  try {\n+    const response = await fetch('https://www.github.com/');\n+    console.log('SUCCESS: GitHub request completed with status', response.status);\n+    process.exit(0);\n+  } catch (error) {\n+    console.log('ERROR: HTTPS request failed:', error.message);\n+    process.exit(1);\n+  }\n+}\n+\n+testHttpsRequest();\n+`;","path":"test/js/bun/fetch/node-use-system-ca-complete.test.ts","commit_id":"1e05f26c3ba1dc7d90fcd3c1fb90348db3734849","original_commit_id":"56f543fde29b3af1380c98e2950582b9d8b0ab1f","user":{"login":"coderabbitai[bot]","id":136622811,"node_id":"BOT_kgDOCCSy2w","avatar_url":"https://avatars.githubusercontent.com/in/347564?v=4","gravatar_id":"","url":"https://api.github.com/users/coderabbitai%5Bbot%5D","html_url":"https://github.com/apps/coderabbitai","followers_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/followers","following_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/following{/other_user}","gists_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/gists{/gist_id}","starred_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/subscriptions","organizations_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/orgs","repos_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/repos","events_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/events{/privacy}","received_events_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"_üõ†Ô∏è Refactor suggestion_\n\n**Avoid external network in CI; gate or make hermetic.**\n\nFetching GitHub will flake and is often blocked. Gate these with an opt-in env or replace with a hermetic local TLS fixture.\n\nApply:\n\n```diff\n-describe(\"NODE_USE_SYSTEM_CA Complete Implementation\", () => {\n-  test(\"should work with standard HTTPS sites\", async () => {\n+const maybeNetTest = process.env.BUN_TEST_ALLOW_NET === \"1\" ? test : test.skip;\n+describe(\"NODE_USE_SYSTEM_CA Complete Implementation\", () => {\n+  maybeNetTest(\"should work with standard HTTPS sites\", async () => {\n```\nOptionally replace the remote fetch with a local TLS server fixture in a follow-up.\n\n<!-- suggestion_start -->\n\n<details>\n<summary>üìù Committable suggestion</summary>\n\n> ‚ÄºÔ∏è **IMPORTANT**\n> Carefully review the code before committing. Ensure that it accurately replaces the highlighted code, contains no missing lines, and has no issues with indentation. Thoroughly test & benchmark the code to ensure it meets the requirements.\n\n```suggestion\nconst maybeNetTest = process.env.BUN_TEST_ALLOW_NET === \"1\" ? test : test.skip;\n\ndescribe(\"NODE_USE_SYSTEM_CA Complete Implementation\", () => {\n  maybeNetTest(\"should work with standard HTTPS sites\", async () => {\n    const testDir = tempDirWithFiles(\"node-use-system-ca-basic\", {});\n\n    const testScript = `\nasync function testHttpsRequest() {\n  try {\n    const response = await fetch('https://www.github.com/');\n    console.log('SUCCESS: GitHub request completed with status', response.status);\n    process.exit(0);\n  } catch (error) {\n    console.log('ERROR: HTTPS request failed:', error.message);\n    process.exit(1);\n  }\n}\n\ntestHttpsRequest();\n`;\n    // ‚Ä¶rest of the test‚Ä¶\n  });\n});\n```\n\n</details>\n\n<!-- suggestion_end -->\n\n<details>\n<summary>ü§ñ Prompt for AI Agents</summary>\n\n```\nIn test/js/bun/fetch/node-use-system-ca-complete.test.ts around lines 8 to 24,\nthe test makes an external network call to https://www.github.com which will\nflake or be blocked in CI; modify the test to avoid external network by either\ngating it behind an opt-in environment variable (e.g., only run if\nCI_ALLOW_EXTERNAL_NETWORK=true, otherwise skip/mark pending) or replace the\nremote fetch with a hermetic local TLS server fixture that serves a simple HTTPS\nendpoint and point the fetch to that local URL; implement one of these\napproaches consistently (prefer gate for quick fix, local TLS fixture for a\nrobust follow-up) and ensure the test exits/returns the same success/failure\nbehavior when using the gate or fixture.\n```\n\n</details>\n\n<!-- fingerprinting:phantom:medusa:chinchilla -->\n\n<!-- This is an auto-generated comment by CodeRabbit -->","created_at":"2025-08-30T00:45:05Z","updated_at":"2025-08-30T00:45:11Z","html_url":"https://github.com/oven-sh/bun/pull/21898#discussion_r2311703981","pull_request_url":"https://api.github.com/repos/oven-sh/bun/pulls/21898","author_association":"NONE","_links":{"self":{"href":"https://api.github.com/repos/oven-sh/bun/pulls/comments/2311703981"},"html":{"href":"https://github.com/oven-sh/bun/pull/21898#discussion_r2311703981"},"pull_request":{"href":"https://api.github.com/repos/oven-sh/bun/pulls/21898"}},"reactions":{"url":"https://api.github.com/repos/oven-sh/bun/pulls/comments/2311703981/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":8,"original_start_line":8,"start_side":"RIGHT","line":null,"original_line":24,"side":"RIGHT","original_position":24,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/oven-sh/bun/pulls/comments/2311703982","pull_request_review_id":3170766628,"id":2311703982,"node_id":"PRRC_kwDOFVKCyc6Jyc2u","diff_hunk":"@@ -0,0 +1,238 @@\n+import { describe, expect, test } from \"bun:test\";\n+import { promises as fs } from \"fs\";\n+import { bunEnv, bunExe, tempDirWithFiles } from \"harness\";\n+import { platform } from \"os\";\n+import { join } from \"path\";\n+\n+describe(\"NODE_USE_SYSTEM_CA Complete Implementation\", () => {\n+  test(\"should work with standard HTTPS sites\", async () => {\n+    const testDir = tempDirWithFiles(\"node-use-system-ca-basic\", {});\n+\n+    const testScript = `\n+async function testHttpsRequest() {\n+  try {\n+    const response = await fetch('https://www.github.com/');\n+    console.log('SUCCESS: GitHub request completed with status', response.status);\n+    process.exit(0);\n+  } catch (error) {\n+    console.log('ERROR: HTTPS request failed:', error.message);\n+    process.exit(1);\n+  }\n+}\n+\n+testHttpsRequest();\n+`;\n+\n+    await fs.writeFile(join(testDir, \"test.js\"), testScript);\n+\n+    // Test with NODE_USE_SYSTEM_CA=1\n+    const proc1 = Bun.spawn({\n+      cmd: [bunExe(), \"test.js\"],\n+      env: {\n+        ...bunEnv,\n+        NODE_USE_SYSTEM_CA: \"1\",\n+      },\n+      cwd: testDir,\n+      stdout: \"pipe\",\n+      stderr: \"pipe\",\n+    });\n+\n+    const [stdout1, stderr1, exitCode1] = await Promise.all([proc1.stdout.text(), proc1.stderr.text(), proc1.exited]);\n+\n+    expect(exitCode1).toBe(0);\n+    expect(stdout1).toContain(\"SUCCESS\");\n+\n+    // Test without NODE_USE_SYSTEM_CA\n+    const proc2 = Bun.spawn({\n+      cmd: [bunExe(), \"test.js\"],\n+      env: bunEnv,\n+      cwd: testDir,\n+      stdout: \"pipe\",\n+      stderr: \"pipe\",\n+    });\n+\n+    const [stdout2, stderr2, exitCode2] = await Promise.all([proc2.stdout.text(), proc2.stderr.text(), proc2.exited]);\n+\n+    expect(exitCode2).toBe(0);\n+    expect(stdout2).toContain(\"SUCCESS\");\n+  });\n+\n+  test(\"should properly parse NODE_USE_SYSTEM_CA environment variable\", async () => {\n+    const testDir = tempDirWithFiles(\"node-use-system-ca-env-parsing\", {});\n+\n+    const testScript = `\n+const testCases = [\n+  { env: '1', description: 'string \"1\"' },\n+  { env: 'true', description: 'string \"true\"' },\n+  { env: '0', description: 'string \"0\"' },\n+  { env: 'false', description: 'string \"false\"' },\n+  { env: undefined, description: 'undefined' }\n+];\n+\n+console.log('Testing NODE_USE_SYSTEM_CA environment variable parsing:');\n+\n+for (const testCase of testCases) {\n+  if (testCase.env !== undefined) {\n+    process.env.NODE_USE_SYSTEM_CA = testCase.env;\n+  } else {\n+    delete process.env.NODE_USE_SYSTEM_CA;\n+  }\n+  \n+  const actual = process.env.NODE_USE_SYSTEM_CA;\n+  console.log(\\`  \\${testCase.description}: \\${actual || 'undefined'}\\`);\n+}\n+\n+console.log('Environment variable parsing test completed successfully');\n+process.exit(0);\n+`;\n+\n+    await fs.writeFile(join(testDir, \"test-env.js\"), testScript);\n+\n+    const proc = Bun.spawn({\n+      cmd: [bunExe(), \"test-env.js\"],\n+      env: bunEnv,\n+      cwd: testDir,\n+      stdout: \"pipe\",\n+      stderr: \"pipe\",\n+    });\n+\n+    const [stdout, stderr, exitCode] = await Promise.all([proc.stdout.text(), proc.stderr.text(), proc.exited]);\n+\n+    expect(exitCode).toBe(0);\n+    expect(stdout).toContain(\"Environment variable parsing test completed successfully\");\n+  });\n+\n+  test(\"should handle platform-specific behavior correctly\", async () => {\n+    const testDir = tempDirWithFiles(\"node-use-system-ca-platform\", {});\n+\n+    const testScript = `\n+const { platform } = require('os');\n+\n+console.log(\\`Platform: \\${platform()}\\`);\n+console.log(\\`NODE_USE_SYSTEM_CA: \\${process.env.NODE_USE_SYSTEM_CA}\\`);\n+\n+async function testPlatformBehavior() {\n+  try {\n+    // Test a reliable HTTPS endpoint\n+    const response = await fetch('https://httpbin.org/user-agent');\n+    const data = await response.json();\n+    \n+    console.log('SUCCESS: Platform-specific certificate loading working');\n+    console.log('User-Agent:', data['user-agent']);\n+    \n+    if (platform() === 'darwin' && process.env.NODE_USE_SYSTEM_CA === '1') {\n+      console.log('SUCCESS: macOS Security framework integration should be active');\n+    } else if (platform() === 'linux' && process.env.NODE_USE_SYSTEM_CA === '1') {\n+      console.log('SUCCESS: Linux system certificate loading should be active');\n+    } else if (platform() === 'win32' && process.env.NODE_USE_SYSTEM_CA === '1') {\n+      console.log('SUCCESS: Windows certificate store integration should be active');\n+    } else {\n+      console.log('SUCCESS: Using bundled certificates');\n+    }\n+    \n+    process.exit(0);\n+  } catch (error) {\n+    console.error('FAILED: Platform test failed:', error.message);\n+    process.exit(1);\n+  }\n+}\n+\n+testPlatformBehavior();\n+`;\n+\n+    await fs.writeFile(join(testDir, \"test-platform.js\"), testScript);\n+\n+    const proc = Bun.spawn({\n+      cmd: [bunExe(), \"test-platform.js\"],\n+      env: {\n+        ...bunEnv,\n+        NODE_USE_SYSTEM_CA: \"1\",\n+      },\n+      cwd: testDir,\n+      stdout: \"pipe\",\n+      stderr: \"pipe\",\n+    });\n+\n+    const [stdout, stderr, exitCode] = await Promise.all([proc.stdout.text(), proc.stderr.text(), proc.exited]);\n+\n+    console.log(\"Platform test output:\", stdout);\n+    console.log(\"Platform test errors:\", stderr);\n+\n+    expect(exitCode).toBe(0);\n+    expect(stdout).toContain(\"SUCCESS: Platform-specific certificate loading working\");\n+\n+    if (platform() === \"darwin\") {\n+      expect(stdout).toContain(\"macOS Security framework integration should be active\");\n+    } else if (platform() === \"linux\") {\n+      expect(stdout).toContain(\"Linux system certificate loading should be active\");\n+    }\n+  });","path":"test/js/bun/fetch/node-use-system-ca-complete.test.ts","commit_id":"1e05f26c3ba1dc7d90fcd3c1fb90348db3734849","original_commit_id":"56f543fde29b3af1380c98e2950582b9d8b0ab1f","user":{"login":"coderabbitai[bot]","id":136622811,"node_id":"BOT_kgDOCCSy2w","avatar_url":"https://avatars.githubusercontent.com/in/347564?v=4","gravatar_id":"","url":"https://api.github.com/users/coderabbitai%5Bbot%5D","html_url":"https://github.com/apps/coderabbitai","followers_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/followers","following_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/following{/other_user}","gists_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/gists{/gist_id}","starred_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/subscriptions","organizations_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/orgs","repos_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/repos","events_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/events{/privacy}","received_events_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"_üõ†Ô∏è Refactor suggestion_\n\n**Gate platform/remote httpbin test behind `BUN_TEST_ALLOW_NET`, remove debug prints.**\n\nAvoid external calls; drop noisy logs.\n\nApply:\n\n```diff\n-  test(\"should handle platform-specific behavior correctly\", async () => {\n+  maybeNetTest(\"should handle platform-specific behavior correctly\", async () => {\n@@\n-    console.log(\"Platform test output:\", stdout);\n-    console.log(\"Platform test errors:\", stderr);\n+    // keep output silent unless failure\n```\n\n<!-- suggestion_start -->\n\n<details>\n<summary>üìù Committable suggestion</summary>\n\n> ‚ÄºÔ∏è **IMPORTANT**\n> Carefully review the code before committing. Ensure that it accurately replaces the highlighted code, contains no missing lines, and has no issues with indentation. Thoroughly test & benchmark the code to ensure it meets the requirements.\n\n```suggestion\n  // Gate this network-dependent test behind BUN_TEST_ALLOW_NET\n  maybeNetTest(\"should handle platform-specific behavior correctly\", async () => {\n    const testDir = tempDirWithFiles(\"node-use-system-ca-platform\", {});\n\n    const testScript = `\nconst { platform } = require('os');\n\nconsole.log(\\`Platform: \\${platform()}\\`);\nconsole.log(\\`NODE_USE_SYSTEM_CA: \\${process.env.NODE_USE_SYSTEM_CA}\\`);\n\nasync function testPlatformBehavior() {\n  try {\n    // Test a reliable HTTPS endpoint\n    const response = await fetch('https://httpbin.org/user-agent');\n    const data = await response.json();\n    \n    console.log('SUCCESS: Platform-specific certificate loading working');\n    console.log('User-Agent:', data['user-agent']);\n    \n    if (platform() === 'darwin' && process.env.NODE_USE_SYSTEM_CA === '1') {\n      console.log('SUCCESS: macOS Security framework integration should be active');\n    } else if (platform() === 'linux' && process.env.NODE_USE_SYSTEM_CA === '1') {\n      console.log('SUCCESS: Linux system certificate loading should be active');\n    } else if (platform() === 'win32' && process.env.NODE_USE_SYSTEM_CA === '1') {\n      console.log('SUCCESS: Windows certificate store integration should be active');\n    } else {\n      console.log('SUCCESS: Using bundled certificates');\n    }\n    \n    process.exit(0);\n  } catch (error) {\n    console.error('FAILED: Platform test failed:', error.message);\n    process.exit(1);\n  }\n}\n\ntestPlatformBehavior();\n`;\n\n    await fs.writeFile(join(testDir, \"test-platform.js\"), testScript);\n\n    const proc = Bun.spawn({\n      cmd: [bunExe(), \"test-platform.js\"],\n      env: {\n        ...bunEnv,\n        NODE_USE_SYSTEM_CA: \"1\",\n      },\n      cwd: testDir,\n      stdout: \"pipe\",\n      stderr: \"pipe\",\n    });\n\n    const [stdout, stderr, exitCode] = await Promise.all([\n      proc.stdout.text(),\n      proc.stderr.text(),\n      proc.exited,\n    ]);\n\n    // keep output silent unless failure\n\n    expect(exitCode).toBe(0);\n    expect(stdout).toContain(\"SUCCESS: Platform-specific certificate loading working\");\n\n    if (platform() === \"darwin\") {\n      expect(stdout).toContain(\"macOS Security framework integration should be active\");\n    } else if (platform() === \"linux\") {\n      expect(stdout).toContain(\"Linux system certificate loading should be active\");\n    }\n  });\n```\n\n</details>\n\n<!-- suggestion_end -->\n\n<!-- fingerprinting:phantom:medusa:chinchilla -->\n\n<!-- This is an auto-generated comment by CodeRabbit -->","created_at":"2025-08-30T00:45:06Z","updated_at":"2025-08-30T00:45:11Z","html_url":"https://github.com/oven-sh/bun/pull/21898#discussion_r2311703982","pull_request_url":"https://api.github.com/repos/oven-sh/bun/pulls/21898","author_association":"NONE","_links":{"self":{"href":"https://api.github.com/repos/oven-sh/bun/pulls/comments/2311703982"},"html":{"href":"https://github.com/oven-sh/bun/pull/21898#discussion_r2311703982"},"pull_request":{"href":"https://api.github.com/repos/oven-sh/bun/pulls/21898"}},"reactions":{"url":"https://api.github.com/repos/oven-sh/bun/pulls/comments/2311703982/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":105,"original_start_line":105,"start_side":"RIGHT","line":null,"original_line":169,"side":"RIGHT","original_position":169,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/oven-sh/bun/pulls/comments/2311703984","pull_request_review_id":3170766628,"id":2311703984,"node_id":"PRRC_kwDOFVKCyc6Jyc2w","diff_hunk":"@@ -0,0 +1,238 @@\n+import { describe, expect, test } from \"bun:test\";\n+import { promises as fs } from \"fs\";\n+import { bunEnv, bunExe, tempDirWithFiles } from \"harness\";\n+import { platform } from \"os\";\n+import { join } from \"path\";\n+\n+describe(\"NODE_USE_SYSTEM_CA Complete Implementation\", () => {\n+  test(\"should work with standard HTTPS sites\", async () => {\n+    const testDir = tempDirWithFiles(\"node-use-system-ca-basic\", {});\n+\n+    const testScript = `\n+async function testHttpsRequest() {\n+  try {\n+    const response = await fetch('https://www.github.com/');\n+    console.log('SUCCESS: GitHub request completed with status', response.status);\n+    process.exit(0);\n+  } catch (error) {\n+    console.log('ERROR: HTTPS request failed:', error.message);\n+    process.exit(1);\n+  }\n+}\n+\n+testHttpsRequest();\n+`;\n+\n+    await fs.writeFile(join(testDir, \"test.js\"), testScript);\n+\n+    // Test with NODE_USE_SYSTEM_CA=1\n+    const proc1 = Bun.spawn({\n+      cmd: [bunExe(), \"test.js\"],\n+      env: {\n+        ...bunEnv,\n+        NODE_USE_SYSTEM_CA: \"1\",\n+      },\n+      cwd: testDir,\n+      stdout: \"pipe\",\n+      stderr: \"pipe\",\n+    });\n+\n+    const [stdout1, stderr1, exitCode1] = await Promise.all([proc1.stdout.text(), proc1.stderr.text(), proc1.exited]);\n+\n+    expect(exitCode1).toBe(0);\n+    expect(stdout1).toContain(\"SUCCESS\");\n+\n+    // Test without NODE_USE_SYSTEM_CA\n+    const proc2 = Bun.spawn({\n+      cmd: [bunExe(), \"test.js\"],\n+      env: bunEnv,\n+      cwd: testDir,\n+      stdout: \"pipe\",\n+      stderr: \"pipe\",\n+    });\n+\n+    const [stdout2, stderr2, exitCode2] = await Promise.all([proc2.stdout.text(), proc2.stderr.text(), proc2.exited]);\n+\n+    expect(exitCode2).toBe(0);\n+    expect(stdout2).toContain(\"SUCCESS\");\n+  });\n+\n+  test(\"should properly parse NODE_USE_SYSTEM_CA environment variable\", async () => {\n+    const testDir = tempDirWithFiles(\"node-use-system-ca-env-parsing\", {});\n+\n+    const testScript = `\n+const testCases = [\n+  { env: '1', description: 'string \"1\"' },\n+  { env: 'true', description: 'string \"true\"' },\n+  { env: '0', description: 'string \"0\"' },\n+  { env: 'false', description: 'string \"false\"' },\n+  { env: undefined, description: 'undefined' }\n+];\n+\n+console.log('Testing NODE_USE_SYSTEM_CA environment variable parsing:');\n+\n+for (const testCase of testCases) {\n+  if (testCase.env !== undefined) {\n+    process.env.NODE_USE_SYSTEM_CA = testCase.env;\n+  } else {\n+    delete process.env.NODE_USE_SYSTEM_CA;\n+  }\n+  \n+  const actual = process.env.NODE_USE_SYSTEM_CA;\n+  console.log(\\`  \\${testCase.description}: \\${actual || 'undefined'}\\`);\n+}\n+\n+console.log('Environment variable parsing test completed successfully');\n+process.exit(0);\n+`;\n+\n+    await fs.writeFile(join(testDir, \"test-env.js\"), testScript);\n+\n+    const proc = Bun.spawn({\n+      cmd: [bunExe(), \"test-env.js\"],\n+      env: bunEnv,\n+      cwd: testDir,\n+      stdout: \"pipe\",\n+      stderr: \"pipe\",\n+    });\n+\n+    const [stdout, stderr, exitCode] = await Promise.all([proc.stdout.text(), proc.stderr.text(), proc.exited]);\n+\n+    expect(exitCode).toBe(0);\n+    expect(stdout).toContain(\"Environment variable parsing test completed successfully\");\n+  });\n+\n+  test(\"should handle platform-specific behavior correctly\", async () => {\n+    const testDir = tempDirWithFiles(\"node-use-system-ca-platform\", {});\n+\n+    const testScript = `\n+const { platform } = require('os');\n+\n+console.log(\\`Platform: \\${platform()}\\`);\n+console.log(\\`NODE_USE_SYSTEM_CA: \\${process.env.NODE_USE_SYSTEM_CA}\\`);\n+\n+async function testPlatformBehavior() {\n+  try {\n+    // Test a reliable HTTPS endpoint\n+    const response = await fetch('https://httpbin.org/user-agent');\n+    const data = await response.json();\n+    \n+    console.log('SUCCESS: Platform-specific certificate loading working');\n+    console.log('User-Agent:', data['user-agent']);\n+    \n+    if (platform() === 'darwin' && process.env.NODE_USE_SYSTEM_CA === '1') {\n+      console.log('SUCCESS: macOS Security framework integration should be active');\n+    } else if (platform() === 'linux' && process.env.NODE_USE_SYSTEM_CA === '1') {\n+      console.log('SUCCESS: Linux system certificate loading should be active');\n+    } else if (platform() === 'win32' && process.env.NODE_USE_SYSTEM_CA === '1') {\n+      console.log('SUCCESS: Windows certificate store integration should be active');\n+    } else {\n+      console.log('SUCCESS: Using bundled certificates');\n+    }\n+    \n+    process.exit(0);\n+  } catch (error) {\n+    console.error('FAILED: Platform test failed:', error.message);\n+    process.exit(1);\n+  }\n+}\n+\n+testPlatformBehavior();\n+`;\n+\n+    await fs.writeFile(join(testDir, \"test-platform.js\"), testScript);\n+\n+    const proc = Bun.spawn({\n+      cmd: [bunExe(), \"test-platform.js\"],\n+      env: {\n+        ...bunEnv,\n+        NODE_USE_SYSTEM_CA: \"1\",\n+      },\n+      cwd: testDir,\n+      stdout: \"pipe\",\n+      stderr: \"pipe\",\n+    });\n+\n+    const [stdout, stderr, exitCode] = await Promise.all([proc.stdout.text(), proc.stderr.text(), proc.exited]);\n+\n+    console.log(\"Platform test output:\", stdout);\n+    console.log(\"Platform test errors:\", stderr);\n+\n+    expect(exitCode).toBe(0);\n+    expect(stdout).toContain(\"SUCCESS: Platform-specific certificate loading working\");\n+\n+    if (platform() === \"darwin\") {\n+      expect(stdout).toContain(\"macOS Security framework integration should be active\");\n+    } else if (platform() === \"linux\") {\n+      expect(stdout).toContain(\"Linux system certificate loading should be active\");\n+    }\n+  });\n+\n+  test(\"should work with TLS connections\", async () => {\n+    const testDir = tempDirWithFiles(\"node-use-system-ca-tls\", {});\n+\n+    const testScript = `\n+const tls = require('tls');\n+\n+async function testTLSConnection() {\n+  return new Promise((resolve, reject) => {\n+    const options = {\n+      host: 'www.google.com',\n+      port: 443,\n+      rejectUnauthorized: true,\n+    };\n+    \n+    const socket = tls.connect(options, () => {\n+      console.log('SUCCESS: TLS connection established');\n+      console.log('Certificate authorized:', socket.authorized);\n+      \n+      socket.destroy();\n+      resolve();\n+    });\n+    \n+    socket.on('error', (error) => {\n+      console.error('FAILED: TLS connection failed:', error.message);\n+      reject(error);\n+    });\n+    \n+    socket.setTimeout(10000, () => {\n+      console.error('FAILED: Connection timeout');\n+      socket.destroy();\n+      reject(new Error('Timeout'));\n+    });\n+  });\n+}\n+\n+testTLSConnection()\n+  .then(() => {\n+    console.log('TLS test completed successfully');\n+    process.exit(0);\n+  })\n+  .catch((error) => {\n+    console.error('TLS test failed:', error.message);\n+    process.exit(1);\n+  });\n+`;\n+\n+    await fs.writeFile(join(testDir, \"test-tls.js\"), testScript);\n+\n+    const proc = Bun.spawn({\n+      cmd: [bunExe(), \"test-tls.js\"],\n+      env: {\n+        ...bunEnv,\n+        NODE_USE_SYSTEM_CA: \"1\",\n+      },\n+      cwd: testDir,\n+      stdout: \"pipe\",\n+      stderr: \"pipe\",\n+    });\n+\n+    const [stdout, stderr, exitCode] = await Promise.all([proc.stdout.text(), proc.stderr.text(), proc.exited]);\n+\n+    console.log(\"TLS test output:\", stdout);\n+\n+    expect(exitCode).toBe(0);\n+    expect(stdout).toContain(\"SUCCESS: TLS connection established\");\n+    expect(stdout).toContain(\"TLS test completed successfully\");\n+  });","path":"test/js/bun/fetch/node-use-system-ca-complete.test.ts","commit_id":"1e05f26c3ba1dc7d90fcd3c1fb90348db3734849","original_commit_id":"56f543fde29b3af1380c98e2950582b9d8b0ab1f","user":{"login":"coderabbitai[bot]","id":136622811,"node_id":"BOT_kgDOCCSy2w","avatar_url":"https://avatars.githubusercontent.com/in/347564?v=4","gravatar_id":"","url":"https://api.github.com/users/coderabbitai%5Bbot%5D","html_url":"https://github.com/apps/coderabbitai","followers_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/followers","following_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/following{/other_user}","gists_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/gists{/gist_id}","starred_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/subscriptions","organizations_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/orgs","repos_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/repos","events_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/events{/privacy}","received_events_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"_üõ†Ô∏è Refactor suggestion_\n\n**TLS test: avoid external Google connect and ad-hoc socket timeouts.**\n\nUse a hermetic TLS server (self-signed + provided CA) or gate behind `BUN_TEST_ALLOW_NET`. Also remove the manual socket timeout; rely on test runner timeouts.\n\nApply:\n\n```diff\n-  test(\"should work with TLS connections\", async () => {\n+  maybeNetTest(\"should work with TLS connections\", async () => {\n@@\n-    socket.setTimeout(10000, () => {\n-      console.error('FAILED: Connection timeout');\n-      socket.destroy();\n-      reject(new Error('Timeout'));\n-    });\n+    // rely on test runner timeouts; avoid manual timers\n```\nIf you prefer hermetic: I can provide a local TLS server fixture using Bun.serve({ tls }) and a generated CA.\n\n<!-- suggestion_start -->\n\n<details>\n<summary>üìù Committable suggestion</summary>\n\n> ‚ÄºÔ∏è **IMPORTANT**\n> Carefully review the code before committing. Ensure that it accurately replaces the highlighted code, contains no missing lines, and has no issues with indentation. Thoroughly test & benchmark the code to ensure it meets the requirements.\n\n```suggestion\n  maybeNetTest(\"should work with TLS connections\", async () => {\n    const testDir = tempDirWithFiles(\"node-use-system-ca-tls\", {});\n\n    const testScript = `\nconst tls = require('tls');\n\nasync function testTLSConnection() {\n  return new Promise((resolve, reject) => {\n    const options = {\n      host: 'www.google.com',\n      port: 443,\n      rejectUnauthorized: true,\n    };\n    \n    const socket = tls.connect(options, () => {\n      console.log('SUCCESS: TLS connection established');\n      console.log('Certificate authorized:', socket.authorized);\n      \n      socket.destroy();\n      resolve();\n    });\n    \n    socket.on('error', (error) => {\n      console.error('FAILED: TLS connection failed:', error.message);\n      reject(error);\n    });\n    \n    // rely on test runner timeouts; avoid manual timers\n  });\n}\n\ntestTLSConnection()\n  .then(() => {\n    console.log('TLS test completed successfully');\n    process.exit(0);\n  })\n  .catch((error) => {\n    console.error('TLS test failed:', error.message);\n    process.exit(1);\n  });\n`;\n\n    await fs.writeFile(join(testDir, \"test-tls.js\"), testScript);\n\n    const proc = Bun.spawn({\n      cmd: [bunExe(), \"test-tls.js\"],\n      env: {\n        ...bunEnv,\n        NODE_USE_SYSTEM_CA: \"1\",\n      },\n      cwd: testDir,\n      stdout: \"pipe\",\n      stderr: \"pipe\",\n    });\n\n    const [stdout, stderr, exitCode] = await Promise.all([\n      proc.stdout.text(),\n      proc.stderr.text(),\n      proc.exited,\n    ]);\n\n    console.log(\"TLS test output:\", stdout);\n\n    expect(exitCode).toBe(0);\n    expect(stdout).toContain(\"SUCCESS: TLS connection established\");\n    expect(stdout).toContain(\"TLS test completed successfully\");\n  });\n```\n\n</details>\n\n<!-- suggestion_end -->\n\n<details>\n<summary>ü§ñ Prompt for AI Agents</summary>\n\n```\nIn test/js/bun/fetch/node-use-system-ca-complete.test.ts around lines 171-237\nthe TLS test contacts external www.google.com and uses an ad-hoc socket timeout;\nchange it to a hermetic approach or gate network access: either replace the\nexternal connection with a local TLS test server (create a self-signed CA +\nserver fixture using Bun.serve({ tls }) and point the test script to localhost,\nwriting the CA into the test dir and setting NODE_EXTRA_CA_CERTS or equivalent),\nor wrap the test with a BUN_TEST_ALLOW_NET check and skip when not allowed; also\nremove the manual socket.setTimeout usage and rely on the test runner timeout.\nEnsure the spawned process env contains the CA when using the hermetic server\nand update assertions to match the local server output.\n```\n\n</details>\n\n<!-- fingerprinting:phantom:medusa:chinchilla -->\n\n<!-- This is an auto-generated comment by CodeRabbit -->","created_at":"2025-08-30T00:45:06Z","updated_at":"2025-08-30T00:45:11Z","html_url":"https://github.com/oven-sh/bun/pull/21898#discussion_r2311703984","pull_request_url":"https://api.github.com/repos/oven-sh/bun/pulls/21898","author_association":"NONE","_links":{"self":{"href":"https://api.github.com/repos/oven-sh/bun/pulls/comments/2311703984"},"html":{"href":"https://github.com/oven-sh/bun/pull/21898#discussion_r2311703984"},"pull_request":{"href":"https://api.github.com/repos/oven-sh/bun/pulls/21898"}},"reactions":{"url":"https://api.github.com/repos/oven-sh/bun/pulls/comments/2311703984/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":171,"original_start_line":171,"start_side":"RIGHT","line":null,"original_line":237,"side":"RIGHT","original_position":237,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/oven-sh/bun/pulls/comments/2311703986","pull_request_review_id":3170766628,"id":2311703986,"node_id":"PRRC_kwDOFVKCyc6Jyc2y","diff_hunk":"@@ -0,0 +1,247 @@\n+import { describe, expect, test } from \"bun:test\";\n+import { promises as fs } from \"fs\";\n+import { bunEnv, bunExe, tempDirWithFiles } from \"harness\";\n+import { join } from \"path\";\n+\n+describe(\"NODE_USE_SYSTEM_CA\", () => {\n+  test(\"should use system CA when NODE_USE_SYSTEM_CA=1\", async () => {\n+    const testDir = tempDirWithFiles(\"node-use-system-ca\", {});\n+\n+    // Create a simple test script that tries to make an HTTPS request\n+    const testScript = `\n+const https = require('https');\n+\n+async function testHttpsRequest() {\n+  try {\n+    const response = await fetch('https://httpbin.org/get');\n+    console.log('SUCCESS: HTTPS request completed');\n+    process.exit(0);\n+  } catch (error) {\n+    console.log('ERROR: HTTPS request failed:', error.message);\n+    process.exit(1);\n+  }\n+}\n+\n+testHttpsRequest();\n+`;\n+\n+    await fs.writeFile(join(testDir, \"test-system-ca.js\"), testScript);\n+\n+    // Test with NODE_USE_SYSTEM_CA=1\n+    const proc1 = Bun.spawn({\n+      cmd: [bunExe(), \"test-system-ca.js\"],\n+      env: {\n+        ...bunEnv,\n+        NODE_USE_SYSTEM_CA: \"1\",\n+      },\n+      cwd: testDir,\n+      stdout: \"pipe\",\n+      stderr: \"pipe\",\n+    });\n+\n+    const [stdout1, stderr1, exitCode1] = await Promise.all([proc1.stdout.text(), proc1.stderr.text(), proc1.exited]);\n+\n+    console.log(\"With NODE_USE_SYSTEM_CA=1:\");\n+    console.log(\"stdout:\", stdout1);\n+    console.log(\"stderr:\", stderr1);\n+    console.log(\"exitCode:\", exitCode1);\n+\n+    // Test without NODE_USE_SYSTEM_CA (should still work with bundled certs)\n+    const proc2 = Bun.spawn({\n+      cmd: [bunExe(), \"test-system-ca.js\"],\n+      env: {\n+        ...bunEnv,\n+        NODE_USE_SYSTEM_CA: undefined,\n+      },\n+      cwd: testDir,\n+      stdout: \"pipe\",\n+      stderr: \"pipe\",\n+    });\n+\n+    const [stdout2, stderr2, exitCode2] = await Promise.all([proc2.stdout.text(), proc2.stderr.text(), proc2.exited]);\n+\n+    console.log(\"\\nWithout NODE_USE_SYSTEM_CA:\");\n+    console.log(\"stdout:\", stdout2);\n+    console.log(\"stderr:\", stderr2);\n+    console.log(\"exitCode:\", exitCode2);\n+\n+    // Both should succeed (system CA and bundled should work for common sites)\n+    expect(exitCode1).toBe(0);\n+    expect(exitCode2).toBe(0);\n+    expect(stdout1).toContain(\"SUCCESS\");\n+    expect(stdout2).toContain(\"SUCCESS\");\n+  });\n+\n+  test(\"should validate NODE_USE_SYSTEM_CA environment variable parsing\", async () => {\n+    const testDir = tempDirWithFiles(\"node-use-system-ca-env\", {});\n+\n+    const testScript = `\n+// Test that the environment variable is read correctly\n+const testCases = [\n+  { env: '1', expected: true },\n+  { env: 'true', expected: true },\n+  { env: '0', expected: false },\n+  { env: 'false', expected: false },\n+  { env: undefined, expected: false }\n+];\n+\n+let allPassed = true;\n+\n+for (const testCase of testCases) {\n+  if (testCase.env !== undefined) {\n+    process.env.NODE_USE_SYSTEM_CA = testCase.env;\n+  } else {\n+    delete process.env.NODE_USE_SYSTEM_CA;\n+  }\n+  \n+  // Here we would test the internal function if it was exposed\n+  // For now, we just test that the environment variable is set correctly\n+  const actual = process.env.NODE_USE_SYSTEM_CA;\n+  const passes = (testCase.env === undefined && !actual) || (actual === testCase.env);\n+  \n+  console.log(\\`Testing NODE_USE_SYSTEM_CA=\\${testCase.env}: \\${passes ? 'PASS' : 'FAIL'}\\`);\n+  \n+  if (!passes) {\n+    allPassed = false;\n+  }\n+}\n+\n+process.exit(allPassed ? 0 : 1);\n+`;\n+\n+    await fs.writeFile(join(testDir, \"test-env-parsing.js\"), testScript);\n+\n+    const proc = Bun.spawn({\n+      cmd: [bunExe(), \"test-env-parsing.js\"],\n+      env: bunEnv,\n+      cwd: testDir,\n+      stdout: \"pipe\",\n+      stderr: \"pipe\",\n+    });\n+\n+    const [stdout, stderr, exitCode] = await Promise.all([proc.stdout.text(), proc.stderr.text(), proc.exited]);\n+\n+    console.log(\"Environment variable parsing test:\");\n+    console.log(\"stdout:\", stdout);\n+    console.log(\"stderr:\", stderr);\n+\n+    expect(exitCode).toBe(0);\n+    expect(stdout).toContain(\"PASS\");\n+  });\n+\n+  test(\"should work with Bun.serve and fetch using system certificates\", async () => {\n+    const testDir = tempDirWithFiles(\"node-use-system-ca-serve\", {});\n+\n+    const serverScript = `\n+const server = Bun.serve({\n+  port: 0,\n+  fetch(req) {\n+    return new Response('Hello from test server');\n+  },\n+});\n+\n+console.log(\\`Server listening on port \\${server.port}\\`);\n+\n+// Keep server alive\n+await new Promise(() => {}); // Never resolves\n+`;\n+\n+    const clientScript = `\n+const port = process.argv[2];\n+\n+async function testClient() {\n+  try {\n+    // Test local HTTP first (should work)\n+    const response = await fetch(\\`http://localhost:\\${port}\\`);\n+    const text = await response.text();\n+    console.log('Local HTTP request successful:', text);\n+\n+    // Test external HTTPS with system CA\n+    const httpsResponse = await fetch('https://httpbin.org/get');\n+    console.log('External HTTPS request successful');\n+    \n+    process.exit(0);\n+  } catch (error) {\n+    console.error('Client request failed:', error.message);\n+    process.exit(1);","path":"test/js/bun/fetch/node-use-system-ca.test.ts","commit_id":"1e05f26c3ba1dc7d90fcd3c1fb90348db3734849","original_commit_id":"56f543fde29b3af1380c98e2950582b9d8b0ab1f","user":{"login":"coderabbitai[bot]","id":136622811,"node_id":"BOT_kgDOCCSy2w","avatar_url":"https://avatars.githubusercontent.com/in/347564?v=4","gravatar_id":"","url":"https://api.github.com/users/coderabbitai%5Bbot%5D","html_url":"https://github.com/apps/coderabbitai","followers_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/followers","following_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/following{/other_user}","gists_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/gists{/gist_id}","starred_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/subscriptions","organizations_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/orgs","repos_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/repos","events_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/events{/privacy}","received_events_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"_üõ†Ô∏è Refactor suggestion_\n\n**Avoid external httpbin call in client; gate or make hermetic.**\n\nReplace with a local HTTPS request against a test TLS server or gate behind `BUN_TEST_ALLOW_NET`.\n\nApply:\n\n```diff\n-    const httpsResponse = await fetch('https://httpbin.org/get');\n-    console.log('External HTTPS request successful');\n+    // Optional: external HTTPS gated by BUN_TEST_ALLOW_NET or use local TLS fixture\n```\n\n\n> Committable suggestion skipped: line range outside the PR's diff.\n\n<details>\n<summary>ü§ñ Prompt for AI Agents</summary>\n\n```\nIn test/js/bun/fetch/node-use-system-ca.test.ts around lines 159 to 166, the\ntest makes an external HTTPS call to https://httpbin.org/get which makes the\ntest non-hermetic; replace that external request with a local HTTPS request to a\ntest TLS server (start a local test HTTPS server within the test and use its\nURL) or gate the external network call behind the BUN_TEST_ALLOW_NET env var (if\nBUN_TEST_ALLOW_NET is not set, skip the external request and mark the test as\nskipped/passed), and preserve the existing success/failure exit handling so the\ntest remains deterministic.\n```\n\n</details>\n\n<!-- fingerprinting:phantom:medusa:chinchilla -->\n\n<!-- This is an auto-generated comment by CodeRabbit -->","created_at":"2025-08-30T00:45:06Z","updated_at":"2025-08-30T00:45:11Z","html_url":"https://github.com/oven-sh/bun/pull/21898#discussion_r2311703986","pull_request_url":"https://api.github.com/repos/oven-sh/bun/pulls/21898","author_association":"NONE","_links":{"self":{"href":"https://api.github.com/repos/oven-sh/bun/pulls/comments/2311703986"},"html":{"href":"https://github.com/oven-sh/bun/pull/21898#discussion_r2311703986"},"pull_request":{"href":"https://api.github.com/repos/oven-sh/bun/pulls/21898"}},"reactions":{"url":"https://api.github.com/repos/oven-sh/bun/pulls/comments/2311703986/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":159,"original_start_line":159,"start_side":"RIGHT","line":null,"original_line":166,"side":"RIGHT","original_position":166,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/oven-sh/bun/pulls/comments/2311703987","pull_request_review_id":3170766628,"id":2311703987,"node_id":"PRRC_kwDOFVKCyc6Jyc2z","diff_hunk":"@@ -0,0 +1,247 @@\n+import { describe, expect, test } from \"bun:test\";\n+import { promises as fs } from \"fs\";\n+import { bunEnv, bunExe, tempDirWithFiles } from \"harness\";\n+import { join } from \"path\";\n+\n+describe(\"NODE_USE_SYSTEM_CA\", () => {\n+  test(\"should use system CA when NODE_USE_SYSTEM_CA=1\", async () => {\n+    const testDir = tempDirWithFiles(\"node-use-system-ca\", {});\n+\n+    // Create a simple test script that tries to make an HTTPS request\n+    const testScript = `\n+const https = require('https');\n+\n+async function testHttpsRequest() {\n+  try {\n+    const response = await fetch('https://httpbin.org/get');\n+    console.log('SUCCESS: HTTPS request completed');\n+    process.exit(0);\n+  } catch (error) {\n+    console.log('ERROR: HTTPS request failed:', error.message);\n+    process.exit(1);\n+  }\n+}\n+\n+testHttpsRequest();\n+`;\n+\n+    await fs.writeFile(join(testDir, \"test-system-ca.js\"), testScript);\n+\n+    // Test with NODE_USE_SYSTEM_CA=1\n+    const proc1 = Bun.spawn({\n+      cmd: [bunExe(), \"test-system-ca.js\"],\n+      env: {\n+        ...bunEnv,\n+        NODE_USE_SYSTEM_CA: \"1\",\n+      },\n+      cwd: testDir,\n+      stdout: \"pipe\",\n+      stderr: \"pipe\",\n+    });\n+\n+    const [stdout1, stderr1, exitCode1] = await Promise.all([proc1.stdout.text(), proc1.stderr.text(), proc1.exited]);\n+\n+    console.log(\"With NODE_USE_SYSTEM_CA=1:\");\n+    console.log(\"stdout:\", stdout1);\n+    console.log(\"stderr:\", stderr1);\n+    console.log(\"exitCode:\", exitCode1);\n+\n+    // Test without NODE_USE_SYSTEM_CA (should still work with bundled certs)\n+    const proc2 = Bun.spawn({\n+      cmd: [bunExe(), \"test-system-ca.js\"],\n+      env: {\n+        ...bunEnv,\n+        NODE_USE_SYSTEM_CA: undefined,\n+      },\n+      cwd: testDir,\n+      stdout: \"pipe\",\n+      stderr: \"pipe\",\n+    });\n+\n+    const [stdout2, stderr2, exitCode2] = await Promise.all([proc2.stdout.text(), proc2.stderr.text(), proc2.exited]);\n+\n+    console.log(\"\\nWithout NODE_USE_SYSTEM_CA:\");\n+    console.log(\"stdout:\", stdout2);\n+    console.log(\"stderr:\", stderr2);\n+    console.log(\"exitCode:\", exitCode2);\n+\n+    // Both should succeed (system CA and bundled should work for common sites)\n+    expect(exitCode1).toBe(0);\n+    expect(exitCode2).toBe(0);\n+    expect(stdout1).toContain(\"SUCCESS\");\n+    expect(stdout2).toContain(\"SUCCESS\");\n+  });\n+\n+  test(\"should validate NODE_USE_SYSTEM_CA environment variable parsing\", async () => {\n+    const testDir = tempDirWithFiles(\"node-use-system-ca-env\", {});\n+\n+    const testScript = `\n+// Test that the environment variable is read correctly\n+const testCases = [\n+  { env: '1', expected: true },\n+  { env: 'true', expected: true },\n+  { env: '0', expected: false },\n+  { env: 'false', expected: false },\n+  { env: undefined, expected: false }\n+];\n+\n+let allPassed = true;\n+\n+for (const testCase of testCases) {\n+  if (testCase.env !== undefined) {\n+    process.env.NODE_USE_SYSTEM_CA = testCase.env;\n+  } else {\n+    delete process.env.NODE_USE_SYSTEM_CA;\n+  }\n+  \n+  // Here we would test the internal function if it was exposed\n+  // For now, we just test that the environment variable is set correctly\n+  const actual = process.env.NODE_USE_SYSTEM_CA;\n+  const passes = (testCase.env === undefined && !actual) || (actual === testCase.env);\n+  \n+  console.log(\\`Testing NODE_USE_SYSTEM_CA=\\${testCase.env}: \\${passes ? 'PASS' : 'FAIL'}\\`);\n+  \n+  if (!passes) {\n+    allPassed = false;\n+  }\n+}\n+\n+process.exit(allPassed ? 0 : 1);\n+`;\n+\n+    await fs.writeFile(join(testDir, \"test-env-parsing.js\"), testScript);\n+\n+    const proc = Bun.spawn({\n+      cmd: [bunExe(), \"test-env-parsing.js\"],\n+      env: bunEnv,\n+      cwd: testDir,\n+      stdout: \"pipe\",\n+      stderr: \"pipe\",\n+    });\n+\n+    const [stdout, stderr, exitCode] = await Promise.all([proc.stdout.text(), proc.stderr.text(), proc.exited]);\n+\n+    console.log(\"Environment variable parsing test:\");\n+    console.log(\"stdout:\", stdout);\n+    console.log(\"stderr:\", stderr);\n+\n+    expect(exitCode).toBe(0);\n+    expect(stdout).toContain(\"PASS\");\n+  });\n+\n+  test(\"should work with Bun.serve and fetch using system certificates\", async () => {\n+    const testDir = tempDirWithFiles(\"node-use-system-ca-serve\", {});\n+\n+    const serverScript = `\n+const server = Bun.serve({\n+  port: 0,\n+  fetch(req) {\n+    return new Response('Hello from test server');\n+  },\n+});\n+\n+console.log(\\`Server listening on port \\${server.port}\\`);\n+\n+// Keep server alive\n+await new Promise(() => {}); // Never resolves\n+`;\n+\n+    const clientScript = `\n+const port = process.argv[2];\n+\n+async function testClient() {\n+  try {\n+    // Test local HTTP first (should work)\n+    const response = await fetch(\\`http://localhost:\\${port}\\`);\n+    const text = await response.text();\n+    console.log('Local HTTP request successful:', text);\n+\n+    // Test external HTTPS with system CA\n+    const httpsResponse = await fetch('https://httpbin.org/get');\n+    console.log('External HTTPS request successful');\n+    \n+    process.exit(0);\n+  } catch (error) {\n+    console.error('Client request failed:', error.message);\n+    process.exit(1);\n+  }\n+}\n+\n+testClient();\n+`;\n+\n+    await fs.writeFile(join(testDir, \"server.js\"), serverScript);\n+    await fs.writeFile(join(testDir, \"client.js\"), clientScript);\n+\n+    // Start server\n+    const serverProc = Bun.spawn({\n+      cmd: [bunExe(), \"server.js\"],\n+      env: {\n+        ...bunEnv,\n+        NODE_USE_SYSTEM_CA: \"1\",\n+      },\n+      cwd: testDir,\n+      stdout: \"pipe\",\n+      stderr: \"pipe\",\n+    });\n+\n+    // Wait for server to start and get port\n+    let serverPort;\n+    const serverOutput = [];\n+    const reader = serverProc.stdout.getReader();\n+\n+    const timeout = setTimeout(() => {\n+      serverProc.kill();\n+    }, 10000);\n+\n+    try {\n+      while (true) {\n+        const { done, value } = await reader.read();\n+        if (done) break;\n+\n+        const chunk = new TextDecoder().decode(value);\n+        serverOutput.push(chunk);\n+\n+        const match = chunk.match(/Server listening on port (\\d+)/);\n+        if (match) {\n+          serverPort = match[1];\n+          break;\n+        }\n+      }\n+    } finally {\n+      reader.releaseLock();\n+    }\n+\n+    expect(serverPort).toBeDefined();\n+    console.log(\"Server started on port:\", serverPort);\n+\n+    // Test client\n+    const clientProc = Bun.spawn({\n+      cmd: [bunExe(), \"client.js\", serverPort],\n+      env: {\n+        ...bunEnv,\n+        NODE_USE_SYSTEM_CA: \"1\",\n+      },\n+      cwd: testDir,\n+      stdout: \"pipe\",\n+      stderr: \"pipe\",\n+    });\n+\n+    const [clientStdout, clientStderr, clientExitCode] = await Promise.all([\n+      clientProc.stdout.text(),\n+      clientProc.stderr.text(),\n+      clientProc.exited,\n+    ]);\n+\n+    // Clean up server\n+    clearTimeout(timeout);\n+    serverProc.kill();\n+\n+    console.log(\"Client output:\", clientStdout);\n+    console.log(\"Client errors:\", clientStderr);\n+\n+    expect(clientExitCode).toBe(0);\n+    expect(clientStdout).toContain(\"Local HTTP request successful\");\n+    expect(clientStdout).toContain(\"External HTTPS request successful\");\n+  }, 30000); // 30 second timeout for this test","path":"test/js/bun/fetch/node-use-system-ca.test.ts","commit_id":"1e05f26c3ba1dc7d90fcd3c1fb90348db3734849","original_commit_id":"56f543fde29b3af1380c98e2950582b9d8b0ab1f","user":{"login":"coderabbitai[bot]","id":136622811,"node_id":"BOT_kgDOCCSy2w","avatar_url":"https://avatars.githubusercontent.com/in/347564?v=4","gravatar_id":"","url":"https://api.github.com/users/coderabbitai%5Bbot%5D","html_url":"https://github.com/apps/coderabbitai","followers_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/followers","following_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/following{/other_user}","gists_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/gists{/gist_id}","starred_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/subscriptions","organizations_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/orgs","repos_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/repos","events_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/events{/privacy}","received_events_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"_üõ†Ô∏è Refactor suggestion_\n\n**Remove per-test timeout.**\n\nPer guidelines, don‚Äôt set explicit timeouts; rely on Bun‚Äôs built-in timeouts.\n\nApply:\n\n```diff\n-  }, 30000); // 30 second timeout for this test\n+  });\n```\n\n<!-- suggestion_start -->\n\n<details>\n<summary>üìù Committable suggestion</summary>\n\n> ‚ÄºÔ∏è **IMPORTANT**\n> Carefully review the code before committing. Ensure that it accurately replaces the highlighted code, contains no missing lines, and has no issues with indentation. Thoroughly test & benchmark the code to ensure it meets the requirements.\n\n```suggestion\n  });\n```\n\n</details>\n\n<!-- suggestion_end -->\n\n<details>\n<summary>ü§ñ Prompt for AI Agents</summary>\n\n```\nIn test/js/bun/fetch/node-use-system-ca.test.ts around line 246, the test sets\nan explicit per-test timeout using \", 30000); // 30 second timeout for this\ntest\"; remove the explicit timeout argument and trailing comment so the test\nuses Bun's built-in timeout handling, ensuring no other logic depends on the\nnumeric timeout and running the test without the \", 30000\" parameter.\n```\n\n</details>\n\n<!-- fingerprinting:phantom:medusa:chinchilla -->\n\n<!-- This is an auto-generated comment by CodeRabbit -->","created_at":"2025-08-30T00:45:06Z","updated_at":"2025-08-30T00:45:11Z","html_url":"https://github.com/oven-sh/bun/pull/21898#discussion_r2311703987","pull_request_url":"https://api.github.com/repos/oven-sh/bun/pulls/21898","author_association":"NONE","_links":{"self":{"href":"https://api.github.com/repos/oven-sh/bun/pulls/comments/2311703987"},"html":{"href":"https://github.com/oven-sh/bun/pull/21898#discussion_r2311703987"},"pull_request":{"href":"https://api.github.com/repos/oven-sh/bun/pulls/21898"}},"reactions":{"url":"https://api.github.com/repos/oven-sh/bun/pulls/comments/2311703987/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":246,"side":"RIGHT","original_position":246,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/oven-sh/bun/pulls/comments/2311703988","pull_request_review_id":3170766628,"id":2311703988,"node_id":"PRRC_kwDOFVKCyc6Jyc20","diff_hunk":"@@ -0,0 +1,30 @@\n+'use strict';\n+// This test checks the usage of --use-bundled-ca and --use-openssl-ca arguments\n+// to verify that both are not used at the same time.\n+const common = require('../common');\n+if (!common.hasCrypto)\n+  common.skip('missing crypto');\n+\n+const assert = require('assert');\n+const os = require('os');\n+const childProcess = require('child_process');\n+const result = childProcess.spawnSync(\n+  process.execPath,\n+  [ '--use-bundled-ca', '--use-openssl-ca', '-p', 'process.version' ],\n+  { encoding: 'utf8' }\n+);\n+\n+assert.strictEqual(result.stderr, `${process.execPath\n+}: either --use-openssl-ca or --use-bundled-ca can be used, not both${os.EOL}`\n+);\n+assert.strictEqual(result.status, 9);\n+\n+const useBundledCA = childProcess.spawnSync(process.execPath, [\n+  '--use-bundled-ca',\n+  '-p', 'process.version']);\n+assert.strictEqual(useBundledCA.status, 0);\n+\n+const useOpenSSLCA = childProcess.spawnSync(process.execPath, [\n+  '--use-openssl-ca',\n+  '-p', 'process.version']);\n+assert.strictEqual(useOpenSSLCA.status, 0);","path":"test/js/node/test/parallel/test-openssl-ca-options.js","commit_id":"1e05f26c3ba1dc7d90fcd3c1fb90348db3734849","original_commit_id":"56f543fde29b3af1380c98e2950582b9d8b0ab1f","user":{"login":"coderabbitai[bot]","id":136622811,"node_id":"BOT_kgDOCCSy2w","avatar_url":"https://avatars.githubusercontent.com/in/347564?v=4","gravatar_id":"","url":"https://api.github.com/users/coderabbitai%5Bbot%5D","html_url":"https://github.com/apps/coderabbitai","followers_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/followers","following_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/following{/other_user}","gists_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/gists{/gist_id}","starred_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/subscriptions","organizations_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/orgs","repos_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/repos","events_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/events{/privacy}","received_events_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"_üõ†Ô∏è Refactor suggestion_\n\n**Do not add new tests under vendored Node path. Move to Bun‚Äôs node-compat tree.**\n\n`test/js/node/test/**` is reserved for vendored Node tests. Please relocate this new test under something like `test/js/node/tls/openssl-ca-options.test.ts` and convert to Bun‚Äôs test style (bun:test + harness). This avoids conflicts when we update vendored Node.\n\n<details>\n<summary>ü§ñ Prompt for AI Agents</summary>\n\n```\nIn test/js/node/test/parallel/test-openssl-ca-options.js lines 1-30: this test\nwas added under the vendored Node path (test/js/node/test/**) which is reserved\nand must be moved; relocate the file to Bun‚Äôs node-compat tree (e.g.,\ntest/js/node/tls/openssl-ca-options.test.ts), convert it to Bun‚Äôs test style\nusing bun:test and the project‚Äôs harness utilities, replace Node-specific\ncommon/assert usage with Bun equivalents, adapt the test to TypeScript naming\nand Bun‚Äôs spawn/child process helpers if needed, and ensure assertions map to\nthe harness API and the test file extension and location follow the repository\nconvention so vendored Node updates won‚Äôt conflict.\n```\n\n</details>\n\n<!-- fingerprinting:phantom:medusa:chinchilla -->\n\n<!-- This is an auto-generated comment by CodeRabbit -->","created_at":"2025-08-30T00:45:06Z","updated_at":"2025-08-30T00:45:11Z","html_url":"https://github.com/oven-sh/bun/pull/21898#discussion_r2311703988","pull_request_url":"https://api.github.com/repos/oven-sh/bun/pulls/21898","author_association":"NONE","_links":{"self":{"href":"https://api.github.com/repos/oven-sh/bun/pulls/comments/2311703988"},"html":{"href":"https://github.com/oven-sh/bun/pull/21898#discussion_r2311703988"},"pull_request":{"href":"https://api.github.com/repos/oven-sh/bun/pulls/21898"}},"reactions":{"url":"https://api.github.com/repos/oven-sh/bun/pulls/comments/2311703988/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":1,"start_side":"RIGHT","line":null,"original_line":30,"side":"RIGHT","original_position":30,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/oven-sh/bun/pulls/comments/2311703989","pull_request_review_id":3170766628,"id":2311703989,"node_id":"PRRC_kwDOFVKCyc6Jyc21","diff_hunk":"@@ -0,0 +1,30 @@\n+'use strict';\n+// This test checks the usage of --use-bundled-ca and --use-openssl-ca arguments\n+// to verify that both are not used at the same time.\n+const common = require('../common');\n+if (!common.hasCrypto)\n+  common.skip('missing crypto');\n+\n+const assert = require('assert');\n+const os = require('os');\n+const childProcess = require('child_process');\n+const result = childProcess.spawnSync(\n+  process.execPath,\n+  [ '--use-bundled-ca', '--use-openssl-ca', '-p', 'process.version' ],\n+  { encoding: 'utf8' }\n+);\n+\n+assert.strictEqual(result.stderr, `${process.execPath\n+}: either --use-openssl-ca or --use-bundled-ca can be used, not both${os.EOL}`\n+);\n+assert.strictEqual(result.status, 9);","path":"test/js/node/test/parallel/test-openssl-ca-options.js","commit_id":"1e05f26c3ba1dc7d90fcd3c1fb90348db3734849","original_commit_id":"56f543fde29b3af1380c98e2950582b9d8b0ab1f","user":{"login":"coderabbitai[bot]","id":136622811,"node_id":"BOT_kgDOCCSy2w","avatar_url":"https://avatars.githubusercontent.com/in/347564?v=4","gravatar_id":"","url":"https://api.github.com/users/coderabbitai%5Bbot%5D","html_url":"https://github.com/apps/coderabbitai","followers_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/followers","following_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/following{/other_user}","gists_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/gists{/gist_id}","starred_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/subscriptions","organizations_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/orgs","repos_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/repos","events_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/events{/privacy}","received_events_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"_üõ†Ô∏è Refactor suggestion_\n\n**Relax brittle assertions: don‚Äôt depend on exact stderr format or exit code.**\n\nBun‚Äôs message/exit code may differ from Node‚Äôs. Assert on substring and nonzero exit instead of exact match and `9`.\n\nApply:\n\n```diff\n-assert.strictEqual(result.stderr, `${process.execPath\n-}: either --use-openssl-ca or --use-bundled-ca can be used, not both${os.EOL}`);\n-assert.strictEqual(result.status, 9);\n+assert.ok(\n+  result.stderr.includes('either --use-openssl-ca or --use-bundled-ca'),\n+  `Unexpected stderr: ${result.stderr}`,\n+);\n+assert.ok(result.status !== 0, `Expected non-zero exit, got ${result.status}`);\n```\n\n<!-- suggestion_start -->\n\n<details>\n<summary>üìù Committable suggestion</summary>\n\n> ‚ÄºÔ∏è **IMPORTANT**\n> Carefully review the code before committing. Ensure that it accurately replaces the highlighted code, contains no missing lines, and has no issues with indentation. Thoroughly test & benchmark the code to ensure it meets the requirements.\n\n```suggestion\nassert.ok(\n  result.stderr.includes('either --use-openssl-ca or --use-bundled-ca'),\n  `Unexpected stderr: ${result.stderr}`,\n);\nassert.ok(result.status !== 0, `Expected non-zero exit, got ${result.status}`);\n```\n\n</details>\n\n<!-- suggestion_end -->\n\n<details>\n<summary>ü§ñ Prompt for AI Agents</summary>\n\n```\nIn test/js/node/test/parallel/test-openssl-ca-options.js around lines 17 to 20,\nthe test currently asserts an exact stderr string and exact exit code 9 which is\nbrittle across runtimes; change the assertions to check that result.stderr\nincludes the expected substring (e.g. \"either --use-openssl-ca or\n--use-bundled-ca can be used, not both\") and that result.status is nonzero (or\nuse assert.notStrictEqual(result.status, 0)) so the test only verifies the error\nmessage presence and a failing exit without depending on exact formatting or a\nspecific exit code.\n```\n\n</details>\n\n<!-- fingerprinting:phantom:medusa:chinchilla -->\n\n<!-- This is an auto-generated comment by CodeRabbit -->","created_at":"2025-08-30T00:45:06Z","updated_at":"2025-08-30T00:45:11Z","html_url":"https://github.com/oven-sh/bun/pull/21898#discussion_r2311703989","pull_request_url":"https://api.github.com/repos/oven-sh/bun/pulls/21898","author_association":"NONE","_links":{"self":{"href":"https://api.github.com/repos/oven-sh/bun/pulls/comments/2311703989"},"html":{"href":"https://github.com/oven-sh/bun/pull/21898#discussion_r2311703989"},"pull_request":{"href":"https://api.github.com/repos/oven-sh/bun/pulls/21898"}},"reactions":{"url":"https://api.github.com/repos/oven-sh/bun/pulls/comments/2311703989/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":17,"start_side":"RIGHT","line":null,"original_line":20,"side":"RIGHT","original_position":20,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/oven-sh/bun/pulls/comments/2311703991","pull_request_review_id":3170766628,"id":2311703991,"node_id":"PRRC_kwDOFVKCyc6Jyc23","diff_hunk":"@@ -0,0 +1,29 @@\n+'use strict';\n+// This tests that NODE_USE_SYSTEM_CA environment variable works the same\n+// as --use-system-ca flag by comparing certificate counts.\n+\n+const common = require('../common');\n+if (!common.hasCrypto) common.skip('missing crypto');\n+\n+const tls = require('tls');\n+const { spawnSyncAndExitWithoutError } = require('../common/child_process');\n+\n+const systemCerts = tls.getCACertificates('system');\n+if (systemCerts.length === 0) {\n+  common.skip('no system certificates available');\n+}\n+\n+const { child: { stdout: expectedLength } } = spawnSyncAndExitWithoutError(process.execPath, [\n+  '--use-system-ca',\n+  '-p',\n+  `tls.getCACertificates('default').length`,\n+], {\n+  env: { ...process.env, NODE_USE_SYSTEM_CA: '0' },\n+});\n+\n+spawnSyncAndExitWithoutError(process.execPath, [\n+  '-p',\n+  `assert.strictEqual(tls.getCACertificates('default').length, ${expectedLength.toString()})`,\n+], {\n+  env: { ...process.env, NODE_USE_SYSTEM_CA: '1' },\n+});","path":"test/js/node/test/parallel/test-tls-get-ca-certificates-node-use-system-ca.js","commit_id":"1e05f26c3ba1dc7d90fcd3c1fb90348db3734849","original_commit_id":"56f543fde29b3af1380c98e2950582b9d8b0ab1f","user":{"login":"coderabbitai[bot]","id":136622811,"node_id":"BOT_kgDOCCSy2w","avatar_url":"https://avatars.githubusercontent.com/in/347564?v=4","gravatar_id":"","url":"https://api.github.com/users/coderabbitai%5Bbot%5D","html_url":"https://github.com/apps/coderabbitai","followers_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/followers","following_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/following{/other_user}","gists_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/gists{/gist_id}","starred_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/subscriptions","organizations_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/orgs","repos_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/repos","events_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/events{/privacy}","received_events_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"_‚ö†Ô∏è Potential issue_\n\n**Trim stdout and require assert in child; current code risks syntax errors.**\n\n`expectedLength.toString()` includes a newline and `assert` is not imported in the child process.\n\n\n```diff\n-const { child: { stdout: expectedLength } } = spawnSyncAndExitWithoutError(process.execPath, [\n+const { child: { stdout: expectedLength } } = spawnSyncAndExitWithoutError(process.execPath, [\n   '--use-system-ca',\n   '-p',\n   `tls.getCACertificates('default').length`,\n ], {\n   env: { ...process.env, NODE_USE_SYSTEM_CA: '0' },\n });\n \n-spawnSyncAndExitWithoutError(process.execPath, [\n-  '-p',\n-  `assert.strictEqual(tls.getCACertificates('default').length, ${expectedLength.toString()})`,\n-], {\n+const expected = Number(expectedLength.toString('utf8').trim());\n+\n+spawnSyncAndExitWithoutError(process.execPath, [\n+  '-e',\n+  `require('assert').strictEqual(require('tls').getCACertificates('default').length, ${expected})`,\n+], {\n   env: { ...process.env, NODE_USE_SYSTEM_CA: '1' },\n });\n```\n\n<!-- suggestion_start -->\n\n<details>\n<summary>üìù Committable suggestion</summary>\n\n> ‚ÄºÔ∏è **IMPORTANT**\n> Carefully review the code before committing. Ensure that it accurately replaces the highlighted code, contains no missing lines, and has no issues with indentation. Thoroughly test & benchmark the code to ensure it meets the requirements.\n\n```suggestion\nconst { child: { stdout: expectedLength } } = spawnSyncAndExitWithoutError(process.execPath, [\n  '--use-system-ca',\n  '-p',\n  `tls.getCACertificates('default').length`,\n], {\n  env: { ...process.env, NODE_USE_SYSTEM_CA: '0' },\n});\n\nconst expected = Number(expectedLength.toString('utf8').trim());\n\nspawnSyncAndExitWithoutError(process.execPath, [\n  '-e',\n  `require('assert').strictEqual(require('tls').getCACertificates('default').length, ${expected})`,\n], {\n  env: { ...process.env, NODE_USE_SYSTEM_CA: '1' },\n});\n```\n\n</details>\n\n<!-- suggestion_end -->\n\n<details>\n<summary>ü§ñ Prompt for AI Agents</summary>\n\n```\nIn test/js/node/test/parallel/test-tls-get-ca-certificates-node-use-system-ca.js\naround lines 16 to 29, the child stdout value is used raw and can contain a\ntrailing newline and the second child evaluation uses assert without importing\nit; trim the captured stdout (e.g., use expectedLength.toString().trim()) before\nembedding it and ensure the second spawn's inline script requires assert (e.g.,\nprepend \"const assert = require('assert');\" to the -p expression) so the\nassertion runs without syntax errors.\n```\n\n</details>\n\n<!-- fingerprinting:phantom:medusa:chinchilla -->\n\n<!-- This is an auto-generated comment by CodeRabbit -->","created_at":"2025-08-30T00:45:07Z","updated_at":"2025-08-30T00:45:12Z","html_url":"https://github.com/oven-sh/bun/pull/21898#discussion_r2311703991","pull_request_url":"https://api.github.com/repos/oven-sh/bun/pulls/21898","author_association":"NONE","_links":{"self":{"href":"https://api.github.com/repos/oven-sh/bun/pulls/comments/2311703991"},"html":{"href":"https://github.com/oven-sh/bun/pull/21898#discussion_r2311703991"},"pull_request":{"href":"https://api.github.com/repos/oven-sh/bun/pulls/21898"}},"reactions":{"url":"https://api.github.com/repos/oven-sh/bun/pulls/comments/2311703991/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":16,"original_start_line":16,"start_side":"RIGHT","line":null,"original_line":29,"side":"RIGHT","original_position":29,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/oven-sh/bun/pulls/comments/2311703994","pull_request_review_id":3170766628,"id":2311703994,"node_id":"PRRC_kwDOFVKCyc6Jyc26","diff_hunk":"@@ -0,0 +1,55 @@\n+// Flags: --use-system-ca\n+\n+import * as common from '../common/index.mjs';\n+import assert from 'node:assert/strict';\n+import https from 'node:https';\n+import fixtures from '../common/fixtures.js';\n+import { it, beforeEach, afterEach, describe } from 'node:test';\n+import { once } from 'events';\n+\n+if (!common.hasCrypto) {\n+  common.skip('requires crypto');\n+}\n+\n+// To run this test, the system needs to be configured to trust\n+// the CA certificate first (which needs an interactive GUI approval, e.g. TouchID):\n+// see the README.md in this folder for instructions on how to do this.\n+const handleRequest = (req, res) => {","path":"test/js/node/test/system-ca/test-native-root-certs.test.mjs","commit_id":"1e05f26c3ba1dc7d90fcd3c1fb90348db3734849","original_commit_id":"56f543fde29b3af1380c98e2950582b9d8b0ab1f","user":{"login":"coderabbitai[bot]","id":136622811,"node_id":"BOT_kgDOCCSy2w","avatar_url":"https://avatars.githubusercontent.com/in/347564?v=4","gravatar_id":"","url":"https://api.github.com/users/coderabbitai%5Bbot%5D","html_url":"https://github.com/apps/coderabbitai","followers_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/followers","following_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/following{/other_user}","gists_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/gists{/gist_id}","starred_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/subscriptions","organizations_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/orgs","repos_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/repos","events_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/events{/privacy}","received_events_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"_‚ö†Ô∏è Potential issue_\n\n**Un-runnable in CI: requires interactive system trust; gate behind an opt‚Äëin.**\n\nThis test assumes the OS trusts agent8‚Äôs root and will fail on CI across platforms (see PR CI). Skip unless an explicit env flag is set and optionally a quick probe confirms trust.\n\n```diff\n // Flags: --use-system-ca\n@@\n-if (!common.hasCrypto) {\n+if (!common.hasCrypto) {\n   common.skip('requires crypto');\n }\n+\n+// CI does not have agent8 CA installed and cannot approve trust interactively.\n+if (!process.env.BUN_RUN_NATIVE_ROOT_CERTS) {\n+  common.skip('requires system-trusted test CA; set BUN_RUN_NATIVE_ROOT_CERTS=1 to run locally');\n+}\n@@\n   it('trusts a valid root certificate', async function() {\n-    await fetch(`https://localhost:${server.address().port}/hello-world`);\n+    await fetch(`https://localhost:${server.address().port}/hello-world`);\n   });\n@@\n-  afterEach(async function() {\n-    server?.close();\n-  });\n+  afterEach(async function() {\n+    server?.close();\n+    // Ensure the socket is released before next test to avoid port leaks.\n+    await once(server, 'close').catch(() => {});\n+  });\n```\n\n\nAlso applies to: 29-55\n\n<details>\n<summary>ü§ñ Prompt for AI Agents</summary>\n\n```\nIn test/js/node/test/system-ca/test-native-root-certs.test.mjs around lines\n14-17 (and also covering lines 29-55), the test requires interactive OS trust\nand will fail in CI; gate it behind an opt-in environment variable and a quick\nruntime probe: check for a specific env var (e.g. RUN_SYSTEM_CA_TESTS) and if\nnot set call test.skip() (or return) so CI won't run it, and if the env var is\nset perform a lightweight probe (attempt to fetch a known https resource using\nthe system CA or validate the agent8 root is present) and skip the test if the\nprobe fails, leaving clear log output explaining the skip and how to enable the\ntest locally.\n```\n\n</details>\n\n<!-- fingerprinting:phantom:poseidon:chinchilla -->\n\n<!-- This is an auto-generated comment by CodeRabbit -->","created_at":"2025-08-30T00:45:07Z","updated_at":"2025-08-30T00:45:12Z","html_url":"https://github.com/oven-sh/bun/pull/21898#discussion_r2311703994","pull_request_url":"https://api.github.com/repos/oven-sh/bun/pulls/21898","author_association":"NONE","_links":{"self":{"href":"https://api.github.com/repos/oven-sh/bun/pulls/comments/2311703994"},"html":{"href":"https://github.com/oven-sh/bun/pull/21898#discussion_r2311703994"},"pull_request":{"href":"https://api.github.com/repos/oven-sh/bun/pulls/21898"}},"reactions":{"url":"https://api.github.com/repos/oven-sh/bun/pulls/comments/2311703994/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":14,"original_start_line":14,"start_side":"RIGHT","line":null,"original_line":17,"side":"RIGHT","original_position":17,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/oven-sh/bun/pulls/comments/2311703997","pull_request_review_id":3170766628,"id":2311703997,"node_id":"PRRC_kwDOFVKCyc6Jyc29","diff_hunk":"@@ -0,0 +1,94 @@\n+import { spawn } from \"bun\";\n+import { describe, expect, test } from \"bun:test\";\n+import { bunEnv, bunExe, tempDirWithFiles } from \"harness\";\n+import { join } from \"path\";\n+\n+describe(\"NODE_EXTRA_CA_CERTS\", () => {\n+  test(\"loads additional certificates from file\", async () => {\n+    // Create a test certificate file\n+    const testCert = `-----BEGIN CERTIFICATE-----\n+MIIDXTCCAkWgAwIBAgIJAKLdQVPy90WjMA0GCSqGSIb3DQEBCwUAMEUxCzAJBgNV\n+BAYTAkFVMRMwEQYDVQQIDApTb21lLVN0YXRlMSEwHwYDVQQKDBhJbnRlcm5ldCBX\n+aWRnaXRzIFB0eSBMdGQwHhcNMTgwNDEwMDgwNzQ4WhcNMjgwNDA3MDgwNzQ4WjBF\n+MQswCQYDVQQGEwJBVTETMBEGA1UECAwKU29tZS1TdGF0ZTEhMB8GA1UECgwYSW50\n+ZXJuZXQgV2lkZ2l0cyBQdHkgTHRkMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIB\n+CgKCAQEAyOB7tY2Uo2lTNjJgGEhJAVZDWnHbLjbmTMP4pSXLlNMr9KdyaKE+J3xn\n+xAz7TbGPHUBH5dqMzlWqEkZxcY9u9GL19SJPpC7dl8K8V5dKBwvgOubcLp4qLvZU\n+-----END CERTIFICATE-----`;","path":"test/js/node/tls/test-node-extra-ca-certs.test.ts","commit_id":"1e05f26c3ba1dc7d90fcd3c1fb90348db3734849","original_commit_id":"56f543fde29b3af1380c98e2950582b9d8b0ab1f","user":{"login":"coderabbitai[bot]","id":136622811,"node_id":"BOT_kgDOCCSy2w","avatar_url":"https://avatars.githubusercontent.com/in/347564?v=4","gravatar_id":"","url":"https://api.github.com/users/coderabbitai%5Bbot%5D","html_url":"https://github.com/apps/coderabbitai","followers_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/followers","following_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/following{/other_user}","gists_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/gists{/gist_id}","starred_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/subscriptions","organizations_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/orgs","repos_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/repos","events_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/events{/privacy}","received_events_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"_‚ö†Ô∏è Potential issue_\n\n**Invalid PEM; the test cert is truncated and never used.**\n\nThe PEM blob is not a valid certificate and the tests never exercise it, so the suite can pass while not testing CA loading at all.\n\nApply this diff to use a real cert source instead of a dummy string (reuse vendored fixtures), and keep the PEM out of the test body:\n\n```diff\n-import { join } from \"path\";\n+import { join } from \"path\";\n+// Reuse Node's vendored fixtures for a known-good CA PEM\n+// (paths are part of test/js/node/test/common/fixtures.js)\n+// eslint-disable-next-line @typescript-eslint/ban-ts-comment\n+// @ts-ignore - CJS default export\n+import fixtures from \"../test/common/fixtures.js\";\n```\n\n\n> Committable suggestion skipped: line range outside the PR's diff.\n\n<!-- fingerprinting:phantom:poseidon:chinchilla -->\n\n<!-- This is an auto-generated comment by CodeRabbit -->","created_at":"2025-08-30T00:45:07Z","updated_at":"2025-08-30T00:45:12Z","html_url":"https://github.com/oven-sh/bun/pull/21898#discussion_r2311703997","pull_request_url":"https://api.github.com/repos/oven-sh/bun/pulls/21898","author_association":"NONE","_links":{"self":{"href":"https://api.github.com/repos/oven-sh/bun/pulls/comments/2311703997"},"html":{"href":"https://github.com/oven-sh/bun/pull/21898#discussion_r2311703997"},"pull_request":{"href":"https://api.github.com/repos/oven-sh/bun/pulls/21898"}},"reactions":{"url":"https://api.github.com/repos/oven-sh/bun/pulls/comments/2311703997/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":9,"original_start_line":9,"start_side":"RIGHT","line":null,"original_line":17,"side":"RIGHT","original_position":17,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/oven-sh/bun/pulls/comments/2311703998","pull_request_review_id":3170766628,"id":2311703998,"node_id":"PRRC_kwDOFVKCyc6Jyc2-","diff_hunk":"@@ -0,0 +1,94 @@\n+import { spawn } from \"bun\";\n+import { describe, expect, test } from \"bun:test\";\n+import { bunEnv, bunExe, tempDirWithFiles } from \"harness\";\n+import { join } from \"path\";\n+\n+describe(\"NODE_EXTRA_CA_CERTS\", () => {\n+  test(\"loads additional certificates from file\", async () => {\n+    // Create a test certificate file\n+    const testCert = `-----BEGIN CERTIFICATE-----\n+MIIDXTCCAkWgAwIBAgIJAKLdQVPy90WjMA0GCSqGSIb3DQEBCwUAMEUxCzAJBgNV\n+BAYTAkFVMRMwEQYDVQQIDApTb21lLVN0YXRlMSEwHwYDVQQKDBhJbnRlcm5ldCBX\n+aWRnaXRzIFB0eSBMdGQwHhcNMTgwNDEwMDgwNzQ4WhcNMjgwNDA3MDgwNzQ4WjBF\n+MQswCQYDVQQGEwJBVTETMBEGA1UECAwKU29tZS1TdGF0ZTEhMB8GA1UECgwYSW50\n+ZXJuZXQgV2lkZ2l0cyBQdHkgTHRkMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIB\n+CgKCAQEAyOB7tY2Uo2lTNjJgGEhJAVZDWnHbLjbmTMP4pSXLlNMr9KdyaKE+J3xn\n+xAz7TbGPHUBH5dqMzlWqEkZxcY9u9GL19SJPpC7dl8K8V5dKBwvgOubcLp4qLvZU\n+-----END CERTIFICATE-----`;\n+\n+    const dir = tempDirWithFiles(\"test-extra-ca\", {\n+      \"extra-ca.pem\": testCert,\n+      \"test.js\": `console.log('OK');`,\n+    });\n+","path":"test/js/node/tls/test-node-extra-ca-certs.test.ts","commit_id":"1e05f26c3ba1dc7d90fcd3c1fb90348db3734849","original_commit_id":"56f543fde29b3af1380c98e2950582b9d8b0ab1f","user":{"login":"coderabbitai[bot]","id":136622811,"node_id":"BOT_kgDOCCSy2w","avatar_url":"https://avatars.githubusercontent.com/in/347564?v=4","gravatar_id":"","url":"https://api.github.com/users/coderabbitai%5Bbot%5D","html_url":"https://github.com/apps/coderabbitai","followers_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/followers","following_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/following{/other_user}","gists_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/gists{/gist_id}","starred_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/subscriptions","organizations_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/orgs","repos_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/repos","events_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/events{/privacy}","received_events_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"_üí° Verification agent_\n\n<details>\n<summary>üß© Analysis chain</summary>\n\n**This test is a no-op; it never verifies that NODE_EXTRA_CA_CERTS affects trust.**\n\nSpawning a process that prints \"OK\" doesn't prove the extra CA was loaded. Assert via tls.getCACertificates('default') that the extra cert is present.\n\nProposed refactor:\n\n```diff\n-    const dir = tempDirWithFiles(\"test-extra-ca\", {\n-      \"extra-ca.pem\": testCert,\n-      \"test.js\": `console.log('OK');`,\n-    });\n+    const caPem = fixtures.readKey?.(\"keys/ca1-cert.pem\") ?? fixtures.readKey(\"agent8-cert.pem\");\n+    const dir = tempDirWithFiles(\"test-extra-ca\", {\n+      \"extra-ca.pem\": caPem,\n+      \"test.js\": `\n+        const fs = require('fs');\n+        const tls = require('tls');\n+        const extra = fs.readFileSync(process.env.EXTRA_CA, 'utf8').trim();\n+        const def = tls.getCACertificates('default');\n+        // Compare on normalized base64 payload to avoid header/line-wrap diffs\n+        const norm = s => s.replace(/-----.*?-----/g, '').replace(/\\\\s+/g, '');\n+        const has = def.some(c => norm(c) === norm(extra));\n+        console.log(has ? 'OK' : 'MISSING');\n+      `,\n+    });\n@@\n-    const certPath = join(dir, \"extra-ca.pem\");\n+    const certPath = join(dir, \"extra-ca.pem\");\n@@\n-      env: { ...bunEnv, NODE_EXTRA_CA_CERTS: certPath },\n+      env: { ...bunEnv, NODE_EXTRA_CA_CERTS: certPath, EXTRA_CA: certPath },\n@@\n-    expect(exitCode).toBe(0);\n-    expect(stdout.trim()).toBe(\"OK\");\n+    expect(exitCode).toBe(0);\n+    expect(stdout.trim()).toBe(\"OK\");\n```\n\nIf fixtures do not contain the suggested file names in this repo snapshot, swap to any existing CA PEM under fixtures/keys. Verify by printing tls.getCACertificates('default').length before/after in a scratch run.\n\n\nAlso applies to: 26-39\n\n---\n\nüèÅ Script executed:\n\n```shell\n#!/usr/bin/env bash\n# Print first 100 lines of the test file to verify current assertions\nsed -n '1,100p' test/js/node/tls/test-node-extra-ca-certs.test.ts\n```\n\nLength of output: 3383\n\n---\n\n\n\n</details>\n\n**Assert extra CA is actually loaded in the child process**  \nThe current test merely prints ‚ÄúOK‚Äù without ever checking that NODE_EXTRA_CA_CERTS modified the trust store. In your spawned `test.js`, read the PEM at `process.env.NODE_EXTRA_CA_CERTS`, call `require('tls').getCACertificates('default')` (or `'extra'`) and compare the normalized PEM payload to ensure the extra CA is present before logging ‚ÄúOK‚Äù. Update the first test‚Äîand similarly the missing-CA and system-CA tests‚Äîto use this pattern.\n\n<details>\n<summary>ü§ñ Prompt for AI Agents</summary>\n\n```\nIn test/js/node/tls/test-node-extra-ca-certs.test.ts around lines 19 to 23, the\nchild test script only prints \"OK\" and does not verify that NODE_EXTRA_CA_CERTS\nactually modified the trust store; update the spawned test.js so it reads the\nPEM path from process.env.NODE_EXTRA_CA_CERTS, loads that PEM, calls\nrequire('tls').getCACertificates('extra') (or 'default' where appropriate),\nnormalizes both PEM payloads (strip headers/footers and whitespace) and asserts\nthe extra CA PEM is present in the returned CA list before printing \"OK\"; apply\nthe same read-then-compare pattern to the missing-CA and system-CA tests as\ninstructed.\n```\n\n</details>\n\n<!-- fingerprinting:phantom:poseidon:chinchilla -->\n\n<!-- This is an auto-generated comment by CodeRabbit -->","created_at":"2025-08-30T00:45:07Z","updated_at":"2025-08-30T00:45:12Z","html_url":"https://github.com/oven-sh/bun/pull/21898#discussion_r2311703998","pull_request_url":"https://api.github.com/repos/oven-sh/bun/pulls/21898","author_association":"NONE","_links":{"self":{"href":"https://api.github.com/repos/oven-sh/bun/pulls/comments/2311703998"},"html":{"href":"https://github.com/oven-sh/bun/pull/21898#discussion_r2311703998"},"pull_request":{"href":"https://api.github.com/repos/oven-sh/bun/pulls/21898"}},"reactions":{"url":"https://api.github.com/repos/oven-sh/bun/pulls/comments/2311703998/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":19,"original_start_line":19,"start_side":"RIGHT","line":null,"original_line":23,"side":"RIGHT","original_position":23,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/oven-sh/bun/pulls/comments/2311703999","pull_request_review_id":3170766628,"id":2311703999,"node_id":"PRRC_kwDOFVKCyc6Jyc2_","diff_hunk":"@@ -0,0 +1,94 @@\n+import { spawn } from \"bun\";\n+import { describe, expect, test } from \"bun:test\";\n+import { bunEnv, bunExe, tempDirWithFiles } from \"harness\";\n+import { join } from \"path\";\n+\n+describe(\"NODE_EXTRA_CA_CERTS\", () => {\n+  test(\"loads additional certificates from file\", async () => {\n+    // Create a test certificate file\n+    const testCert = `-----BEGIN CERTIFICATE-----\n+MIIDXTCCAkWgAwIBAgIJAKLdQVPy90WjMA0GCSqGSIb3DQEBCwUAMEUxCzAJBgNV\n+BAYTAkFVMRMwEQYDVQQIDApTb21lLVN0YXRlMSEwHwYDVQQKDBhJbnRlcm5ldCBX\n+aWRnaXRzIFB0eSBMdGQwHhcNMTgwNDEwMDgwNzQ4WhcNMjgwNDA3MDgwNzQ4WjBF\n+MQswCQYDVQQGEwJBVTETMBEGA1UECAwKU29tZS1TdGF0ZTEhMB8GA1UECgwYSW50\n+ZXJuZXQgV2lkZ2l0cyBQdHkgTHRkMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIB\n+CgKCAQEAyOB7tY2Uo2lTNjJgGEhJAVZDWnHbLjbmTMP4pSXLlNMr9KdyaKE+J3xn\n+xAz7TbGPHUBH5dqMzlWqEkZxcY9u9GL19SJPpC7dl8K8V5dKBwvgOubcLp4qLvZU\n+-----END CERTIFICATE-----`;\n+\n+    const dir = tempDirWithFiles(\"test-extra-ca\", {\n+      \"extra-ca.pem\": testCert,\n+      \"test.js\": `console.log('OK');`,\n+    });\n+\n+    const certPath = join(dir, \"extra-ca.pem\");\n+\n+    // Test that NODE_EXTRA_CA_CERTS loads the certificate\n+    await using proc = spawn({\n+      cmd: [bunExe(), \"test.js\"],\n+      env: { ...bunEnv, NODE_EXTRA_CA_CERTS: certPath },\n+      cwd: dir,\n+      stdout: \"pipe\",\n+      stderr: \"pipe\",\n+    });\n+\n+    const [stdout, stderr, exitCode] = await Promise.all([proc.stdout.text(), proc.stderr.text(), proc.exited]);\n+\n+    expect(exitCode).toBe(0);\n+    expect(stdout.trim()).toBe(\"OK\");\n+  });\n+\n+  test(\"handles missing certificate file gracefully\", async () => {\n+    const dir = tempDirWithFiles(\"test-missing-ca\", {\n+      \"test.js\": `console.log('OK');`,\n+    });\n+\n+    const nonExistentPath = join(dir, \"non-existent.pem\");\n+\n+    // Test that missing file doesn't crash the process\n+    await using proc = spawn({\n+      cmd: [bunExe(), \"test.js\"],\n+      env: { ...bunEnv, NODE_EXTRA_CA_CERTS: nonExistentPath },\n+      cwd: dir,\n+      stdout: \"pipe\",\n+      stderr: \"pipe\",\n+    });\n+\n+    const [stdout, stderr, exitCode] = await Promise.all([proc.stdout.text(), proc.stderr.text(), proc.exited]);\n+\n+    // Process should still run successfully even with missing cert file\n+    expect(exitCode).toBe(0);\n+    expect(stdout.trim()).toBe(\"OK\");\n+    // Bun may or may not warn about the missing file in stderr\n+    // The important thing is that the process doesn't crash\n+  });\n+\n+  test(\"works with both NODE_EXTRA_CA_CERTS and --use-system-ca\", async () => {\n+    const testCert = `-----BEGIN CERTIFICATE-----\n+MIIDXTCCAkWgAwIBAgIJAKLdQVPy90WjMA0GCSqGSIb3DQEBCwUAMEUxCzAJBgNV\n+BAYTAkFVMRMwEQYDVQQIDApTb21lLVN0YXRlMSEwHwYDVQQKDBhJbnRlcm5ldCBX\n+aWRnaXRzIFB0eSBMdGQwHhcNMTgwNDEwMDgwNzQ4WhcNMjgwNDA3MDgwNzQ4WjBF\n+-----END CERTIFICATE-----`;\n+\n+    const dir = tempDirWithFiles(\"test-extra-and-system\", {\n+      \"extra-ca.pem\": testCert,\n+      \"test.js\": `console.log('OK');`,\n+    });\n+\n+    const certPath = join(dir, \"extra-ca.pem\");\n+\n+    // Test that both work together\n+    await using proc = spawn({\n+      cmd: [bunExe(), \"--use-system-ca\", \"test.js\"],\n+      env: { ...bunEnv, NODE_EXTRA_CA_CERTS: certPath },\n+      cwd: dir,\n+      stdout: \"pipe\",\n+      stderr: \"pipe\",\n+    });\n+\n+    const [stdout, stderr, exitCode] = await Promise.all([proc.stdout.text(), proc.stderr.text(), proc.exited]);\n+\n+    expect(exitCode).toBe(0);\n+    expect(stdout.trim()).toBe(\"OK\");\n+  });","path":"test/js/node/tls/test-node-extra-ca-certs.test.ts","commit_id":"1e05f26c3ba1dc7d90fcd3c1fb90348db3734849","original_commit_id":"56f543fde29b3af1380c98e2950582b9d8b0ab1f","user":{"login":"coderabbitai[bot]","id":136622811,"node_id":"BOT_kgDOCCSy2w","avatar_url":"https://avatars.githubusercontent.com/in/347564?v=4","gravatar_id":"","url":"https://api.github.com/users/coderabbitai%5Bbot%5D","html_url":"https://github.com/apps/coderabbitai","followers_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/followers","following_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/following{/other_user}","gists_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/gists{/gist_id}","starred_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/subscriptions","organizations_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/orgs","repos_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/repos","events_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/events{/privacy}","received_events_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"_üõ†Ô∏è Refactor suggestion_\n\n**Also a no-op; it doesn‚Äôt assert interaction with --use-system-ca.**\n\nEnsure default CA set contains the extra cert when both are enabled; otherwise this test provides no signal.\n\nApply this diff mirroring the first test‚Äôs membership check and adding the flag:\n\n```diff\n-    const dir = tempDirWithFiles(\"test-extra-and-system\", {\n-      \"extra-ca.pem\": testCert,\n-      \"test.js\": `console.log('OK');`,\n-    });\n+    const caPem = fixtures.readKey?.(\"keys/ca1-cert.pem\") ?? fixtures.readKey(\"agent8-cert.pem\");\n+    const dir = tempDirWithFiles(\"test-extra-and-system\", {\n+      \"extra-ca.pem\": caPem,\n+      \"test.js\": `\n+        const fs = require('fs');\n+        const tls = require('tls');\n+        const extra = fs.readFileSync(process.env.EXTRA_CA, 'utf8').trim();\n+        const def = tls.getCACertificates('default');\n+        const norm = s => s.replace(/-----.*?-----/g, '').replace(/\\\\s+/g, '');\n+        const has = def.some(c => norm(c) === norm(extra));\n+        console.log(has ? 'OK' : 'MISSING');\n+      `,\n+    });\n@@\n-      cmd: [bunExe(), \"--use-system-ca\", \"test.js\"],\n-      env: { ...bunEnv, NODE_EXTRA_CA_CERTS: certPath },\n+      cmd: [bunExe(), \"--use-system-ca\", \"test.js\"],\n+      env: { ...bunEnv, NODE_EXTRA_CA_CERTS: certPath, EXTRA_CA: certPath },\n@@\n-    expect(exitCode).toBe(0);\n-    expect(stdout.trim()).toBe(\"OK\");\n+    expect(exitCode).toBe(0);\n+    expect(stdout.trim()).toBe(\"OK\");\n```\n\n<!-- suggestion_start -->\n\n<details>\n<summary>üìù Committable suggestion</summary>\n\n> ‚ÄºÔ∏è **IMPORTANT**\n> Carefully review the code before committing. Ensure that it accurately replaces the highlighted code, contains no missing lines, and has no issues with indentation. Thoroughly test & benchmark the code to ensure it meets the requirements.\n\n```suggestion\n  test(\"works with both NODE_EXTRA_CA_CERTS and --use-system-ca\", async () => {\n    const testCert = `-----BEGIN CERTIFICATE-----\nMIIDXTCCAkWgAwIBAgIJAKLdQVPy90WjMA0GCSqGSIb3DQEBCwUAMEUxCzAJBgNV\nBAYTAkFVMRMwEQYDVQQIDApTb21lLVN0YXRlMSEwHwYDVQQKDBhJbnRlcm5ldCBX\naWRnaXRzIFB0eSBMdGQwHhcNMTgwNDEwMDgwNzQ4WhcNMjgwNDA3MDgwNzQ4WjBF\n-----END CERTIFICATE-----`;\n\n    const caPem = fixtures.readKey?.(\"keys/ca1-cert.pem\") ?? fixtures.readKey(\"agent8-cert.pem\");\n    const dir = tempDirWithFiles(\"test-extra-and-system\", {\n      \"extra-ca.pem\": caPem,\n      \"test.js\": `\n        const fs = require('fs');\n        const tls = require('tls');\n        const extra = fs.readFileSync(process.env.EXTRA_CA, 'utf8').trim();\n        const def = tls.getCACertificates('default');\n        const norm = s => s.replace(/-----.*?-----/g, '').replace(/\\\\s+/g, '');\n        const has = def.some(c => norm(c) === norm(extra));\n        console.log(has ? 'OK' : 'MISSING');\n      `,\n    });\n\n    const certPath = join(dir, \"extra-ca.pem\");\n\n    // Test that both work together\n    await using proc = spawn({\n      cmd: [bunExe(), \"--use-system-ca\", \"test.js\"],\n      env: { ...bunEnv, NODE_EXTRA_CA_CERTS: certPath, EXTRA_CA: certPath },\n      cwd: dir,\n      stdout: \"pipe\",\n      stderr: \"pipe\",\n    });\n\n    const [stdout, stderr, exitCode] = await Promise.all([\n      proc.stdout.text(),\n      proc.stderr.text(),\n      proc.exited,\n    ]);\n\n    expect(exitCode).toBe(0);\n    expect(stdout.trim()).toBe(\"OK\");\n  });\n```\n\n</details>\n\n<!-- suggestion_end -->\n\n<details>\n<summary>ü§ñ Prompt for AI Agents</summary>\n\n```\nIn test/js/node/tls/test-node-extra-ca-certs.test.ts around lines 66 to 93, the\ntest spawns bun with both NODE_EXTRA_CA_CERTS and --use-system-ca but only\nasserts the process exits 0 and prints \"OK\", so it doesn't verify that the extra\ncertificate was actually merged into the default CA set; update the test to\nmirror the first test's membership check by loading the process stdout (or the\nfile the spawned test prints) and assert that the PEM contents (or the\ncertificate subject/fingerprint used in the first test) are present in the\ndefault CA list when --use-system-ca is enabled, i.e. add the same\nmembership-check assertion used in the earlier test after capturing output and\nkeep the existing flags/env (NODE_EXTRA_CA_CERTS and --use-system-ca) so the\ntest validates the interaction.\n```\n\n</details>\n\n<!-- fingerprinting:phantom:poseidon:chinchilla -->\n\n<!-- This is an auto-generated comment by CodeRabbit -->","created_at":"2025-08-30T00:45:07Z","updated_at":"2025-08-30T00:45:12Z","html_url":"https://github.com/oven-sh/bun/pull/21898#discussion_r2311703999","pull_request_url":"https://api.github.com/repos/oven-sh/bun/pulls/21898","author_association":"NONE","_links":{"self":{"href":"https://api.github.com/repos/oven-sh/bun/pulls/comments/2311703999"},"html":{"href":"https://github.com/oven-sh/bun/pull/21898#discussion_r2311703999"},"pull_request":{"href":"https://api.github.com/repos/oven-sh/bun/pulls/21898"}},"reactions":{"url":"https://api.github.com/repos/oven-sh/bun/pulls/comments/2311703999/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":66,"original_start_line":66,"start_side":"RIGHT","line":null,"original_line":93,"side":"RIGHT","original_position":93,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/oven-sh/bun/pulls/comments/2311704001","pull_request_review_id":3170766628,"id":2311704001,"node_id":"PRRC_kwDOFVKCyc6Jyc3B","diff_hunk":"@@ -0,0 +1,145 @@\n+import { spawn } from \"bun\";\n+import { describe, expect, test } from \"bun:test\";\n+import { readFileSync } from \"fs\";\n+import { bunEnv, bunExe, tempDirWithFiles } from \"harness\";\n+\n+describe(\"system CA with HTTPS\", () => {\n+  // Skip test if no system certificates are available\n+  const skipIfNoSystemCerts = () => {\n+    if (process.platform === \"linux\") {\n+      // Check if common certificate paths exist on Linux\n+      const certPaths = [\n+        \"/etc/ssl/certs/ca-certificates.crt\",\n+        \"/etc/pki/tls/certs/ca-bundle.crt\",\n+        \"/etc/ssl/ca-bundle.pem\",\n+        \"/etc/pki/tls/cacert.pem\",\n+        \"/etc/pki/ca-trust/extracted/pem/tls-ca-bundle.pem\",\n+      ];\n+      const hasSystemCerts = certPaths.some(path => {\n+        try {\n+          readFileSync(path);\n+          return true;\n+        } catch {\n+          return false;\n+        }\n+      });\n+      if (!hasSystemCerts) {\n+        return \"no system certificates available on Linux\";\n+      }\n+    }\n+    return null;\n+  };","path":"test/js/node/tls/test-system-ca-https.test.ts","commit_id":"1e05f26c3ba1dc7d90fcd3c1fb90348db3734849","original_commit_id":"56f543fde29b3af1380c98e2950582b9d8b0ab1f","user":{"login":"coderabbitai[bot]","id":136622811,"node_id":"BOT_kgDOCCSy2w","avatar_url":"https://avatars.githubusercontent.com/in/347564?v=4","gravatar_id":"","url":"https://api.github.com/users/coderabbitai%5Bbot%5D","html_url":"https://github.com/apps/coderabbitai","followers_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/followers","following_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/following{/other_user}","gists_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/gists{/gist_id}","starred_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/subscriptions","organizations_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/orgs","repos_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/repos","events_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/events{/privacy}","received_events_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"_üõ†Ô∏è Refactor suggestion_\n\n**Avoid dynamic skip inside a running test; predeclare skip and gate networked tests.**\n\nCalling test.skip() inside an executing test is ineffective. Also, these tests hit the public internet and will be flaky in CI. Precompute the skip and guard on a dedicated env flag to allow opting-in to network.\n\n\n\n```diff\n-describe(\"system CA with HTTPS\", () => {\n-  // Skip test if no system certificates are available\n-  const skipIfNoSystemCerts = () => {\n+// Skip test if no system certificates are available\n+const skipIfNoSystemCerts = () => {\n   ...\n-  };\n+};\n+\n+const allowNetwork = !!Bun.env.BUN_TEST_ALLOW_NETWORK;\n+\n+describe(allowNetwork ? \"system CA with HTTPS\" : describe.skip(\"system CA with HTTPS (skipped: BUN_TEST_ALLOW_NETWORK not set)\"), () => {\n```\n\n\n> Committable suggestion skipped: line range outside the PR's diff.\n\n<details>\n<summary>ü§ñ Prompt for AI Agents</summary>\n\n```\nIn test/js/node/tls/test-system-ca-https.test.ts around lines 6-31, the test\ncurrently performs a dynamic skip check at runtime inside the describe block\nwhich is ineffective and allows networked tests to run in CI; precompute a skip\nreason and gate the entire describe at load time using an opt-in env flag. Move\nthe cert-path existence logic out of the running test to top-level code that\nsets a const skipReason (e.g. compute hasSystemCerts and then set skipReason =\n!hasSystemCerts ? \"no system certificates on Linux\" : null) and also require an\nexplicit opt-in like process.env.RUN_NETWORK_TESTS === \"1\"; then conditionally\ncall describe.skip(...) or wrap the describe in if (!skipReason &&\nprocess.env.RUN_NETWORK_TESTS === \"1\") { describe(...) } else {\ndescribe.skip(...) } so no test.skip is invoked during test execution and the\nnetworked tests only run when opted into.\n```\n\n</details>\n\n<!-- fingerprinting:phantom:medusa:chinchilla -->\n\n<!-- This is an auto-generated comment by CodeRabbit -->","created_at":"2025-08-30T00:45:07Z","updated_at":"2025-08-30T00:45:12Z","html_url":"https://github.com/oven-sh/bun/pull/21898#discussion_r2311704001","pull_request_url":"https://api.github.com/repos/oven-sh/bun/pulls/21898","author_association":"NONE","_links":{"self":{"href":"https://api.github.com/repos/oven-sh/bun/pulls/comments/2311704001"},"html":{"href":"https://github.com/oven-sh/bun/pull/21898#discussion_r2311704001"},"pull_request":{"href":"https://api.github.com/repos/oven-sh/bun/pulls/21898"}},"reactions":{"url":"https://api.github.com/repos/oven-sh/bun/pulls/comments/2311704001/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":6,"original_start_line":6,"start_side":"RIGHT","line":null,"original_line":31,"side":"RIGHT","original_position":31,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/oven-sh/bun/pulls/comments/2311704003","pull_request_review_id":3170766628,"id":2311704003,"node_id":"PRRC_kwDOFVKCyc6Jyc3D","diff_hunk":"@@ -0,0 +1,145 @@\n+import { spawn } from \"bun\";\n+import { describe, expect, test } from \"bun:test\";\n+import { readFileSync } from \"fs\";\n+import { bunEnv, bunExe, tempDirWithFiles } from \"harness\";\n+\n+describe(\"system CA with HTTPS\", () => {\n+  // Skip test if no system certificates are available\n+  const skipIfNoSystemCerts = () => {\n+    if (process.platform === \"linux\") {\n+      // Check if common certificate paths exist on Linux\n+      const certPaths = [\n+        \"/etc/ssl/certs/ca-certificates.crt\",\n+        \"/etc/pki/tls/certs/ca-bundle.crt\",\n+        \"/etc/ssl/ca-bundle.pem\",\n+        \"/etc/pki/tls/cacert.pem\",\n+        \"/etc/pki/ca-trust/extracted/pem/tls-ca-bundle.pem\",\n+      ];\n+      const hasSystemCerts = certPaths.some(path => {\n+        try {\n+          readFileSync(path);\n+          return true;\n+        } catch {\n+          return false;\n+        }\n+      });\n+      if (!hasSystemCerts) {\n+        return \"no system certificates available on Linux\";\n+      }\n+    }\n+    return null;\n+  };\n+\n+  test(\"HTTPS request with system CA\", async () => {\n+    const skipReason = skipIfNoSystemCerts();\n+    if (skipReason) {\n+      test.skip(skipReason);\n+      return;\n+    }","path":"test/js/node/tls/test-system-ca-https.test.ts","commit_id":"1e05f26c3ba1dc7d90fcd3c1fb90348db3734849","original_commit_id":"56f543fde29b3af1380c98e2950582b9d8b0ab1f","user":{"login":"coderabbitai[bot]","id":136622811,"node_id":"BOT_kgDOCCSy2w","avatar_url":"https://avatars.githubusercontent.com/in/347564?v=4","gravatar_id":"","url":"https://api.github.com/users/coderabbitai%5Bbot%5D","html_url":"https://github.com/apps/coderabbitai","followers_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/followers","following_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/following{/other_user}","gists_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/gists{/gist_id}","starred_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/subscriptions","organizations_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/orgs","repos_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/repos","events_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/events{/privacy}","received_events_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"_üõ†Ô∏è Refactor suggestion_\n\n**Replace in-test skip with predeclared skip to ensure correct reporting.**\n\nMove the skip decision outside the test and register a skipped test instead of calling test.skip() at runtime.\n\n\n\n```diff\n-  test(\"HTTPS request with system CA\", async () => {\n-    const skipReason = skipIfNoSystemCerts();\n-    if (skipReason) {\n-      test.skip(skipReason);\n-      return;\n-    }\n-  ...\n-  });\n+  const skipReason1 = skipIfNoSystemCerts();\n+  (skipReason1 ? test.skip : test)(\n+    \"HTTPS request with system CA\" + (skipReason1 ? ` (${skipReason1})` : \"\"),\n+    async () => {\n+      if (skipReason1) return;\n+      ...\n+    },\n+  );\n```\n\n<!-- suggestion_start -->\n\n<details>\n<summary>üìù Committable suggestion</summary>\n\n> ‚ÄºÔ∏è **IMPORTANT**\n> Carefully review the code before committing. Ensure that it accurately replaces the highlighted code, contains no missing lines, and has no issues with indentation. Thoroughly test & benchmark the code to ensure it meets the requirements.\n\n```suggestion\n  // Determine up front whether we need to skip, so it's reported correctly.\n  const skipReason1 = skipIfNoSystemCerts();\n  (skipReason1 ? test.skip : test)(\n    // If skipping, include the reason in the test title for clarity\n    \"HTTPS request with system CA\" + (skipReason1 ? ` (${skipReason1})` : \"\"),\n    async () => {\n      // If we've decided to skip, bail immediately\n      if (skipReason1) return;\n\n      // ‚Ä¶rest of your test logic here‚Ä¶\n      const res = await fetch(`https://example.com`, { /* ‚Ä¶ */ });\n      expect(res.status).toBe(200);\n      // etc.\n    },\n  );\n```\n\n</details>\n\n<!-- suggestion_end -->\n\n<details>\n<summary>ü§ñ Prompt for AI Agents</summary>\n\n```\nIn test/js/node/tls/test-system-ca-https.test.ts around lines 33 to 38, the call\nto skipIfNoSystemCerts() is made inside the test body and conditionally calls\ntest.skip() at runtime; move the skip decision outside the test declaration so\nthe test is registered as skipped up-front. Call const skipReason =\nskipIfNoSystemCerts() before defining the test, and if skipReason is truthy call\ntest.skip(skipReason) and return early (or simply register the skipped test)\notherwise declare test(\"HTTPS request with system CA\", async () => { ... }) as\nnormal.\n```\n\n</details>\n\n<!-- fingerprinting:phantom:medusa:chinchilla -->\n\n<!-- This is an auto-generated comment by CodeRabbit -->","created_at":"2025-08-30T00:45:07Z","updated_at":"2025-08-30T00:45:12Z","html_url":"https://github.com/oven-sh/bun/pull/21898#discussion_r2311704003","pull_request_url":"https://api.github.com/repos/oven-sh/bun/pulls/21898","author_association":"NONE","_links":{"self":{"href":"https://api.github.com/repos/oven-sh/bun/pulls/comments/2311704003"},"html":{"href":"https://github.com/oven-sh/bun/pull/21898#discussion_r2311704003"},"pull_request":{"href":"https://api.github.com/repos/oven-sh/bun/pulls/21898"}},"reactions":{"url":"https://api.github.com/repos/oven-sh/bun/pulls/comments/2311704003/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":33,"original_start_line":33,"start_side":"RIGHT","line":null,"original_line":38,"side":"RIGHT","original_position":38,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/oven-sh/bun/pulls/comments/2311704006","pull_request_review_id":3170766628,"id":2311704006,"node_id":"PRRC_kwDOFVKCyc6Jyc3G","diff_hunk":"@@ -0,0 +1,145 @@\n+import { spawn } from \"bun\";\n+import { describe, expect, test } from \"bun:test\";\n+import { readFileSync } from \"fs\";\n+import { bunEnv, bunExe, tempDirWithFiles } from \"harness\";\n+\n+describe(\"system CA with HTTPS\", () => {\n+  // Skip test if no system certificates are available\n+  const skipIfNoSystemCerts = () => {\n+    if (process.platform === \"linux\") {\n+      // Check if common certificate paths exist on Linux\n+      const certPaths = [\n+        \"/etc/ssl/certs/ca-certificates.crt\",\n+        \"/etc/pki/tls/certs/ca-bundle.crt\",\n+        \"/etc/ssl/ca-bundle.pem\",\n+        \"/etc/pki/tls/cacert.pem\",\n+        \"/etc/pki/ca-trust/extracted/pem/tls-ca-bundle.pem\",\n+      ];\n+      const hasSystemCerts = certPaths.some(path => {\n+        try {\n+          readFileSync(path);\n+          return true;\n+        } catch {\n+          return false;\n+        }\n+      });\n+      if (!hasSystemCerts) {\n+        return \"no system certificates available on Linux\";\n+      }\n+    }\n+    return null;\n+  };\n+\n+  test(\"HTTPS request with system CA\", async () => {\n+    const skipReason = skipIfNoSystemCerts();\n+    if (skipReason) {\n+      test.skip(skipReason);\n+      return;\n+    }\n+\n+    // Test that we can make HTTPS requests to well-known sites with system CA\n+    const testCode = `\n+      const https = require('https');\n+      \n+      // Test against a well-known HTTPS endpoint\n+      https.get('https://www.google.com', (res) => {\n+        console.log('STATUS:', res.statusCode);\n+        process.exit(res.statusCode === 200 || res.statusCode === 301 || res.statusCode === 302 ? 0 : 1);\n+      }).on('error', (err) => {\n+        console.error('ERROR:', err.message);\n+        process.exit(1);\n+      });\n+    `;","path":"test/js/node/tls/test-system-ca-https.test.ts","commit_id":"1e05f26c3ba1dc7d90fcd3c1fb90348db3734849","original_commit_id":"56f543fde29b3af1380c98e2950582b9d8b0ab1f","user":{"login":"coderabbitai[bot]","id":136622811,"node_id":"BOT_kgDOCCSy2w","avatar_url":"https://avatars.githubusercontent.com/in/347564?v=4","gravatar_id":"","url":"https://api.github.com/users/coderabbitai%5Bbot%5D","html_url":"https://github.com/apps/coderabbitai","followers_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/followers","following_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/following{/other_user}","gists_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/gists{/gist_id}","starred_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/subscriptions","organizations_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/orgs","repos_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/repos","events_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/events{/privacy}","received_events_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"_üõ†Ô∏è Refactor suggestion_\n\n**Eliminate reliance on external sites or guard strictly; current approach is CI-flaky.**\n\nHitting https://www.google.com can fail due to DNS/firewall/egress limits and cause timeouts. Either (a) fully gate with BUN_TEST_ALLOW_NETWORK (above), or (b) replace with a deterministic local TLS fixture that uses SSL_CERT_FILE on Linux to simulate ‚Äúsystem‚Äù CAs.\n\n\n\nI can provide a local TLS server + CA fixture using port: 0 and SSL_CERT_FILE so this stays offline and deterministic (Linux). Want me to draft it?\n\n<details>\n<summary>ü§ñ Prompt for AI Agents</summary>\n\n```\nIn test/js/node/tls/test-system-ca-https.test.ts around lines 41 to 52, the test\ncurrently hits https://www.google.com which is flaky in CI; update the test to\nnot rely on external network by either (1) wrapping the existing network call\nbehind the BUN_TEST_ALLOW_NETWORK guard so it only runs when that env var is\nset, or (2) replace the external request with a local deterministic TLS fixture:\nstart a local HTTPS server on port 0 using a test CA and certs, point the test\nprocess to use that CA via SSL_CERT_FILE (on Linux) and make the https.get call\nto the server‚Äôs ephemeral port, ensure the server is started before the request,\nproperly handle async teardown and errors, and include a short request timeout\nto avoid hangs.\n```\n\n</details>\n\n<!-- fingerprinting:phantom:medusa:chinchilla -->\n\n<!-- This is an auto-generated comment by CodeRabbit -->","created_at":"2025-08-30T00:45:08Z","updated_at":"2025-08-30T00:45:12Z","html_url":"https://github.com/oven-sh/bun/pull/21898#discussion_r2311704006","pull_request_url":"https://api.github.com/repos/oven-sh/bun/pulls/21898","author_association":"NONE","_links":{"self":{"href":"https://api.github.com/repos/oven-sh/bun/pulls/comments/2311704006"},"html":{"href":"https://github.com/oven-sh/bun/pull/21898#discussion_r2311704006"},"pull_request":{"href":"https://api.github.com/repos/oven-sh/bun/pulls/21898"}},"reactions":{"url":"https://api.github.com/repos/oven-sh/bun/pulls/comments/2311704006/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":41,"original_start_line":41,"start_side":"RIGHT","line":null,"original_line":52,"side":"RIGHT","original_position":52,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/oven-sh/bun/pulls/comments/2311704007","pull_request_review_id":3170766628,"id":2311704007,"node_id":"PRRC_kwDOFVKCyc6Jyc3H","diff_hunk":"@@ -0,0 +1,145 @@\n+import { spawn } from \"bun\";\n+import { describe, expect, test } from \"bun:test\";\n+import { readFileSync } from \"fs\";\n+import { bunEnv, bunExe, tempDirWithFiles } from \"harness\";\n+\n+describe(\"system CA with HTTPS\", () => {\n+  // Skip test if no system certificates are available\n+  const skipIfNoSystemCerts = () => {\n+    if (process.platform === \"linux\") {\n+      // Check if common certificate paths exist on Linux\n+      const certPaths = [\n+        \"/etc/ssl/certs/ca-certificates.crt\",\n+        \"/etc/pki/tls/certs/ca-bundle.crt\",\n+        \"/etc/ssl/ca-bundle.pem\",\n+        \"/etc/pki/tls/cacert.pem\",\n+        \"/etc/pki/ca-trust/extracted/pem/tls-ca-bundle.pem\",\n+      ];\n+      const hasSystemCerts = certPaths.some(path => {\n+        try {\n+          readFileSync(path);\n+          return true;\n+        } catch {\n+          return false;\n+        }\n+      });\n+      if (!hasSystemCerts) {\n+        return \"no system certificates available on Linux\";\n+      }\n+    }\n+    return null;\n+  };\n+\n+  test(\"HTTPS request with system CA\", async () => {\n+    const skipReason = skipIfNoSystemCerts();\n+    if (skipReason) {\n+      test.skip(skipReason);\n+      return;\n+    }\n+\n+    // Test that we can make HTTPS requests to well-known sites with system CA\n+    const testCode = `\n+      const https = require('https');\n+      \n+      // Test against a well-known HTTPS endpoint\n+      https.get('https://www.google.com', (res) => {\n+        console.log('STATUS:', res.statusCode);\n+        process.exit(res.statusCode === 200 || res.statusCode === 301 || res.statusCode === 302 ? 0 : 1);\n+      }).on('error', (err) => {\n+        console.error('ERROR:', err.message);\n+        process.exit(1);\n+      });\n+    `;\n+\n+    const dir = tempDirWithFiles(\"test-system-ca\", {\n+      \"test.js\": testCode,\n+    });\n+\n+    // Test with --use-system-ca flag\n+    await using proc1 = spawn({\n+      cmd: [bunExe(), \"--use-system-ca\", \"test.js\"],\n+      env: bunEnv,\n+      cwd: dir,\n+      stdout: \"pipe\",\n+      stderr: \"pipe\",\n+    });\n+\n+    const [stdout1, stderr1, exitCode1] = await Promise.all([proc1.stdout.text(), proc1.stderr.text(), proc1.exited]);\n+\n+    expect(exitCode1).toBe(0);\n+    expect(stdout1).toContain(\"STATUS:\");\n+\n+    // Test with NODE_USE_SYSTEM_CA=1\n+    await using proc2 = spawn({\n+      cmd: [bunExe(), \"test.js\"],\n+      env: { ...bunEnv, NODE_USE_SYSTEM_CA: \"1\" },\n+      cwd: dir,\n+      stdout: \"pipe\",\n+      stderr: \"pipe\",\n+    });\n+\n+    const [stdout2, stderr2, exitCode2] = await Promise.all([proc2.stdout.text(), proc2.stderr.text(), proc2.exited]);\n+\n+    expect(exitCode2).toBe(0);\n+    expect(stdout2).toContain(\"STATUS:\");\n+  });\n+\n+  test(\"HTTPS fails without system CA for custom root cert\", async () => {\n+    // This test verifies that without system CA, connections to sites\n+    // with certificates not in the bundled list will fail\n+    const testCode = `\n+      const https = require('https');\n+      \n+      // Test against a site that typically uses a custom or less common CA\n+      // Using a government site as they often have their own CAs\n+      https.get('https://www.irs.gov', (res) => {\n+        console.log('SUCCESS');\n+        process.exit(0);\n+      }).on('error', (err) => {\n+        if (err.code === 'UNABLE_TO_VERIFY_LEAF_SIGNATURE' || \n+            err.code === 'CERT_HAS_EXPIRED' ||\n+            err.code === 'SELF_SIGNED_CERT_IN_CHAIN' ||\n+            err.message.includes('certificate')) {\n+          console.log('CERT_ERROR');\n+          process.exit(1);\n+        }\n+        // Other errors (network, DNS, etc)\n+        console.error('OTHER_ERROR:', err.code);\n+        process.exit(2);\n+      });\n+    `;\n+\n+    const dir = tempDirWithFiles(\"test-no-system-ca\", {\n+      \"test.js\": testCode,\n+    });\n+\n+    // Test WITHOUT system CA - might fail for some sites\n+    await using proc1 = spawn({\n+      cmd: [bunExe(), \"test.js\"],\n+      env: { ...bunEnv, NODE_USE_SYSTEM_CA: \"0\" },\n+      cwd: dir,\n+      stdout: \"pipe\",\n+      stderr: \"pipe\",\n+    });\n+\n+    const [stdout1, stderr1, exitCode1] = await Promise.all([proc1.stdout.text(), proc1.stderr.text(), proc1.exited]);\n+\n+    // This might succeed or fail depending on whether the site's CA is bundled\n+    // We just verify the test runs without crashing\n+    expect([0, 1, 2]).toContain(exitCode1);\n+\n+    // Test WITH system CA - should have better success rate\n+    await using proc2 = spawn({\n+      cmd: [bunExe(), \"--use-system-ca\", \"test.js\"],\n+      env: bunEnv,\n+      cwd: dir,\n+      stdout: \"pipe\",\n+      stderr: \"pipe\",\n+    });\n+\n+    const [stdout2, stderr2, exitCode2] = await Promise.all([proc2.stdout.text(), proc2.stderr.text(), proc2.exited]);\n+\n+    // With system CA, we expect either success or non-cert errors\n+    expect([0, 2]).toContain(exitCode2);\n+  });","path":"test/js/node/tls/test-system-ca-https.test.ts","commit_id":"1e05f26c3ba1dc7d90fcd3c1fb90348db3734849","original_commit_id":"56f543fde29b3af1380c98e2950582b9d8b0ab1f","user":{"login":"coderabbitai[bot]","id":136622811,"node_id":"BOT_kgDOCCSy2w","avatar_url":"https://avatars.githubusercontent.com/in/347564?v=4","gravatar_id":"","url":"https://api.github.com/users/coderabbitai%5Bbot%5D","html_url":"https://github.com/apps/coderabbitai","followers_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/followers","following_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/following{/other_user}","gists_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/gists{/gist_id}","starred_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/subscriptions","organizations_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/orgs","repos_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/repos","events_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/events{/privacy}","received_events_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"_üõ†Ô∏è Refactor suggestion_\n\n**Non-deterministic test doesn‚Äôt assert behavior; violates test guidelines.**\n\nAllowing exit codes [0,1,2] proves nothing and effectively asserts ‚Äúdidn‚Äôt crash,‚Äù which our guidelines prohibit. This will flap across networks and CA bundles.\n\n\n\n```diff\n-  test(\"HTTPS fails without system CA for custom root cert\", async () => {\n-    ...\n-    expect([0, 1, 2]).toContain(exitCode1);\n-    ...\n-    expect([0, 2]).toContain(exitCode2);\n-  });\n+  test.skip(\n+    \"HTTPS fails without system CA for custom root cert (skipped: requires deterministic local TLS fixture)\",\n+    () => {},\n+  );\n```\n\n\nI can replace this with an offline fixture using a test CA (Linux: SSL_CERT_FILE) to deterministically show failure without and success with --use-system-ca. Proceed?\n\n<!-- suggestion_start -->\n\n<details>\n<summary>üìù Committable suggestion</summary>\n\n> ‚ÄºÔ∏è **IMPORTANT**\n> Carefully review the code before committing. Ensure that it accurately replaces the highlighted code, contains no missing lines, and has no issues with indentation. Thoroughly test & benchmark the code to ensure it meets the requirements.\n\n```suggestion\n// Replace the entire flaky test block (lines 87‚Äì144) with a skipped placeholder:\ntest.skip(\n  \"HTTPS fails without system CA for custom root cert (skipped: requires deterministic local TLS fixture)\",\n  () => {},\n);\n```\n\n</details>\n\n<!-- suggestion_end -->\n\n<!-- fingerprinting:phantom:medusa:chinchilla -->\n\n<!-- This is an auto-generated comment by CodeRabbit -->","created_at":"2025-08-30T00:45:08Z","updated_at":"2025-08-30T00:45:12Z","html_url":"https://github.com/oven-sh/bun/pull/21898#discussion_r2311704007","pull_request_url":"https://api.github.com/repos/oven-sh/bun/pulls/21898","author_association":"NONE","_links":{"self":{"href":"https://api.github.com/repos/oven-sh/bun/pulls/comments/2311704007"},"html":{"href":"https://github.com/oven-sh/bun/pull/21898#discussion_r2311704007"},"pull_request":{"href":"https://api.github.com/repos/oven-sh/bun/pulls/21898"}},"reactions":{"url":"https://api.github.com/repos/oven-sh/bun/pulls/comments/2311704007/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":87,"original_start_line":87,"start_side":"RIGHT","line":null,"original_line":144,"side":"RIGHT","original_position":144,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/oven-sh/bun/pulls/comments/2311704010","pull_request_review_id":3170766628,"id":2311704010,"node_id":"PRRC_kwDOFVKCyc6Jyc3K","diff_hunk":"@@ -0,0 +1,84 @@\n+// Test that --use-system-ca flag and NODE_USE_SYSTEM_CA environment variable work\n+\n+import { spawn } from \"bun\";\n+import { expect, test } from \"bun:test\";\n+import { bunEnv, bunExe } from \"harness\";\n+\n+test(\"--use-system-ca flag is accepted\", async () => {\n+  await using proc = spawn({\n+    cmd: [bunExe(), \"--use-system-ca\", \"-e\", \"console.log('OK')\"],\n+    env: bunEnv,\n+    stdout: \"pipe\",\n+    stderr: \"pipe\",\n+  });\n+\n+  const [stdout, stderr, exitCode] = await Promise.all([proc.stdout.text(), proc.stderr.text(), proc.exited]);\n+\n+  expect(exitCode).toBe(0);\n+  expect(stdout.trim()).toBe(\"OK\");\n+  expect(stderr).not.toContain(\"Unknown option\");\n+});\n+\n+test(\"NODE_USE_SYSTEM_CA=1 environment variable works\", async () => {\n+  await using proc = spawn({\n+    cmd: [bunExe(), \"-e\", \"console.log('OK')\"],\n+    env: { ...bunEnv, NODE_USE_SYSTEM_CA: \"1\" },\n+    stdout: \"pipe\",\n+    stderr: \"pipe\",\n+  });\n+\n+  const [stdout, stderr, exitCode] = await Promise.all([proc.stdout.text(), proc.stderr.text(), proc.exited]);\n+\n+  expect(exitCode).toBe(0);\n+  expect(stdout.trim()).toBe(\"OK\");\n+});\n+\n+test(\"--use-system-ca with HTTPS request\", async () => {\n+  const testCode = `\n+    const https = require('https');\n+    https.get('https://www.google.com', (res) => {\n+      console.log('STATUS:', res.statusCode);\n+      process.exit(0);\n+    }).on('error', (err) => {\n+      console.error('ERROR:', err.message);\n+      process.exit(1);\n+    });\n+  `;\n+\n+  await using proc = spawn({\n+    cmd: [bunExe(), \"--use-system-ca\", \"-e\", testCode],\n+    env: bunEnv,\n+    stdout: \"pipe\",\n+    stderr: \"pipe\",\n+  });\n+\n+  const [stdout, stderr, exitCode] = await Promise.all([proc.stdout.text(), proc.stderr.text(), proc.exited]);\n+\n+  expect(exitCode).toBe(0);\n+  expect(stdout).toContain(\"STATUS:\");\n+});\n+","path":"test/js/node/tls/test-use-system-ca-flag.test.ts","commit_id":"1e05f26c3ba1dc7d90fcd3c1fb90348db3734849","original_commit_id":"56f543fde29b3af1380c98e2950582b9d8b0ab1f","user":{"login":"coderabbitai[bot]","id":136622811,"node_id":"BOT_kgDOCCSy2w","avatar_url":"https://avatars.githubusercontent.com/in/347564?v=4","gravatar_id":"","url":"https://api.github.com/users/coderabbitai%5Bbot%5D","html_url":"https://github.com/apps/coderabbitai","followers_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/followers","following_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/following{/other_user}","gists_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/gists{/gist_id}","starred_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/subscriptions","organizations_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/orgs","repos_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/repos","events_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/events{/privacy}","received_events_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"_üõ†Ô∏è Refactor suggestion_\n\n**Avoid external network; test becomes flaky.**\n\nHitting google.com is brittle (CI egress, DNS, regional firewalls). Prefer an in-repo HTTPS fixture or assert certificate lists via bindings.\n\nApply one of:\n- Replace with a local TLS server fixture (self-signed) and assert that it succeeds only when system CA contains that root (Windows/macOS runners).\n- Or drop the network test and assert that the system CA list is non-empty via an internal binding: import from bun:internal/node/tls if exposed (e.g., getSystemCACertificates()) and assert length > 0 when flag set.\n\n<details>\n<summary>ü§ñ Prompt for AI Agents</summary>\n\n```\nIn test/js/node/tls/test-use-system-ca-flag.test.ts around lines 36 to 60, the\ntest performs an external HTTPS request to google.com which is flaky in CI;\nreplace this with a deterministic approach: either spin up an in-repo HTTPS\nserver fixture (create a local TLS server using a self-signed cert and assert\nconnection behavior when --use-system-ca is used) or, preferably, avoid network\nentirely by importing the internal system-CA accessor (e.g., from\nbun:internal/node/tls or equivalent binding) and assert that calling the system\nCA list API returns a non-empty array when --use-system-ca is provided; update\nthe spawn invocation and assertions accordingly so the test only relies on local\nfixtures or the internal binding and remove any external network dependency.\n```\n\n</details>\n\n<!-- fingerprinting:phantom:medusa:chinchilla -->\n\n<!-- This is an auto-generated comment by CodeRabbit -->","created_at":"2025-08-30T00:45:08Z","updated_at":"2025-08-30T00:45:12Z","html_url":"https://github.com/oven-sh/bun/pull/21898#discussion_r2311704010","pull_request_url":"https://api.github.com/repos/oven-sh/bun/pulls/21898","author_association":"NONE","_links":{"self":{"href":"https://api.github.com/repos/oven-sh/bun/pulls/comments/2311704010"},"html":{"href":"https://github.com/oven-sh/bun/pull/21898#discussion_r2311704010"},"pull_request":{"href":"https://api.github.com/repos/oven-sh/bun/pulls/21898"}},"reactions":{"url":"https://api.github.com/repos/oven-sh/bun/pulls/comments/2311704010/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":36,"original_start_line":36,"start_side":"RIGHT","line":null,"original_line":60,"side":"RIGHT","original_position":60,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/oven-sh/bun/pulls/comments/2311704011","pull_request_review_id":3170766628,"id":2311704011,"node_id":"PRRC_kwDOFVKCyc6Jyc3L","diff_hunk":"@@ -0,0 +1,69 @@\n+import { spawn } from \"bun\";\n+import { describe, expect, test } from \"bun:test\";\n+import { bunEnv, bunExe } from \"harness\";\n+\n+describe(\"--use-system-ca\", () => {\n+  test(\"flag loads system certificates\", async () => {\n+    // Test that --use-system-ca loads system certificates\n+    await using proc = spawn({\n+      cmd: [bunExe(), \"--use-system-ca\", \"-e\", \"console.log('OK')\"],\n+      env: bunEnv,\n+      stdout: \"pipe\",\n+      stderr: \"pipe\",\n+    });\n+\n+    const [stdout, stderr, exitCode] = await Promise.all([proc.stdout.text(), proc.stderr.text(), proc.exited]);\n+\n+    expect(exitCode).toBe(0);\n+    expect(stdout.trim()).toBe(\"OK\");\n+    expect(stderr).toBe(\"\");\n+  });","path":"test/js/node/tls/test-use-system-ca.test.ts","commit_id":"1e05f26c3ba1dc7d90fcd3c1fb90348db3734849","original_commit_id":"56f543fde29b3af1380c98e2950582b9d8b0ab1f","user":{"login":"coderabbitai[bot]","id":136622811,"node_id":"BOT_kgDOCCSy2w","avatar_url":"https://avatars.githubusercontent.com/in/347564?v=4","gravatar_id":"","url":"https://api.github.com/users/coderabbitai%5Bbot%5D","html_url":"https://github.com/apps/coderabbitai","followers_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/followers","following_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/following{/other_user}","gists_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/gists{/gist_id}","starred_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/subscriptions","organizations_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/orgs","repos_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/repos","events_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/events{/privacy}","received_events_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"_üõ†Ô∏è Refactor suggestion_\n\n**Test doesn‚Äôt validate that system CAs influence the default trust store.**\n\nPrinting ‚ÄúOK‚Äù doesn‚Äôt assert anything about the flag. Validate superset behavior via tls.getCACertificates.\n\n```diff\n-  test(\"flag loads system certificates\", async () => {\n-    // Test that --use-system-ca loads system certificates\n+  test(\"flag loads system certificates (default ‚äá system)\", async () => {\n@@\n-      cmd: [bunExe(), \"--use-system-ca\", \"-e\", \"console.log('OK')\"],\n+      cmd: [bunExe(), \"--use-system-ca\", \"-e\", `\n+        const tls = require('tls');\n+        const sys = new Set(tls.getCACertificates('system'));\n+        const def = new Set(tls.getCACertificates('default'));\n+        const missing = [...sys].filter(x => !def.has(x)).length;\n+        console.log(JSON.stringify({ missing }));\n+      `],\n@@\n-    expect(exitCode).toBe(0);\n-    expect(stdout.trim()).toBe(\"OK\");\n-    expect(stderr).toBe(\"\");\n+    expect(exitCode).toBe(0);\n+    expect(stderr).toBe(\"\");\n+    const { missing } = JSON.parse(stdout);\n+    expect(missing).toBe(0);\n```\n\n<!-- suggestion_start -->\n\n<details>\n<summary>üìù Committable suggestion</summary>\n\n> ‚ÄºÔ∏è **IMPORTANT**\n> Carefully review the code before committing. Ensure that it accurately replaces the highlighted code, contains no missing lines, and has no issues with indentation. Thoroughly test & benchmark the code to ensure it meets the requirements.\n\n```suggestion\ndescribe(\"--use-system-ca\", () => {\n  test(\"flag loads system certificates (default ‚äá system)\", async () => {\n    await using proc = spawn({\n      cmd: [\n        bunExe(),\n        \"--use-system-ca\",\n        \"-e\",\n        `\n        const tls = require('tls');\n        // Load system and default CAs\n        const sys = new Set(tls.getCACertificates('system'));\n        const def = new Set(tls.getCACertificates('default'));\n        // Count any system CAs missing from default\n        const missing = [...sys].filter(x => !def.has(x)).length;\n        console.log(JSON.stringify({ missing }));\n      `,\n      ],\n      env: bunEnv,\n      stdout: \"pipe\",\n      stderr: \"pipe\",\n    });\n\n    const [stdout, stderr, exitCode] = await Promise.all([\n      proc.stdout.text(),\n      proc.stderr.text(),\n      proc.exited,\n    ]);\n\n    expect(exitCode).toBe(0);\n    expect(stderr).toBe(\"\");\n    const { missing } = JSON.parse(stdout);\n    expect(missing).toBe(0);\n  });\n});\n```\n\n</details>\n\n<!-- suggestion_end -->\n\n<!-- fingerprinting:phantom:poseidon:chinchilla -->\n\n<!-- This is an auto-generated comment by CodeRabbit -->","created_at":"2025-08-30T00:45:08Z","updated_at":"2025-08-30T00:45:12Z","html_url":"https://github.com/oven-sh/bun/pull/21898#discussion_r2311704011","pull_request_url":"https://api.github.com/repos/oven-sh/bun/pulls/21898","author_association":"NONE","_links":{"self":{"href":"https://api.github.com/repos/oven-sh/bun/pulls/comments/2311704011"},"html":{"href":"https://github.com/oven-sh/bun/pull/21898#discussion_r2311704011"},"pull_request":{"href":"https://api.github.com/repos/oven-sh/bun/pulls/21898"}},"reactions":{"url":"https://api.github.com/repos/oven-sh/bun/pulls/comments/2311704011/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":5,"original_start_line":5,"start_side":"RIGHT","line":null,"original_line":20,"side":"RIGHT","original_position":20,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/oven-sh/bun/pulls/comments/2311704012","pull_request_review_id":3170766628,"id":2311704012,"node_id":"PRRC_kwDOFVKCyc6Jyc3M","diff_hunk":"@@ -0,0 +1,69 @@\n+import { spawn } from \"bun\";\n+import { describe, expect, test } from \"bun:test\";\n+import { bunEnv, bunExe } from \"harness\";\n+\n+describe(\"--use-system-ca\", () => {\n+  test(\"flag loads system certificates\", async () => {\n+    // Test that --use-system-ca loads system certificates\n+    await using proc = spawn({\n+      cmd: [bunExe(), \"--use-system-ca\", \"-e\", \"console.log('OK')\"],\n+      env: bunEnv,\n+      stdout: \"pipe\",\n+      stderr: \"pipe\",\n+    });\n+\n+    const [stdout, stderr, exitCode] = await Promise.all([proc.stdout.text(), proc.stderr.text(), proc.exited]);\n+\n+    expect(exitCode).toBe(0);\n+    expect(stdout.trim()).toBe(\"OK\");\n+    expect(stderr).toBe(\"\");\n+  });\n+\n+  test(\"NODE_USE_SYSTEM_CA=1 loads system certificates\", async () => {\n+    // Test that NODE_USE_SYSTEM_CA environment variable works\n+    await using proc = spawn({\n+      cmd: [bunExe(), \"-e\", \"console.log('OK')\"],\n+      env: { ...bunEnv, NODE_USE_SYSTEM_CA: \"1\" },\n+      stdout: \"pipe\",\n+      stderr: \"pipe\",\n+    });\n+\n+    const [stdout, stderr, exitCode] = await Promise.all([proc.stdout.text(), proc.stderr.text(), proc.exited]);\n+\n+    expect(exitCode).toBe(0);\n+    expect(stdout.trim()).toBe(\"OK\");\n+    expect(stderr).toBe(\"\");\n+  });","path":"test/js/node/tls/test-use-system-ca.test.ts","commit_id":"1e05f26c3ba1dc7d90fcd3c1fb90348db3734849","original_commit_id":"56f543fde29b3af1380c98e2950582b9d8b0ab1f","user":{"login":"coderabbitai[bot]","id":136622811,"node_id":"BOT_kgDOCCSy2w","avatar_url":"https://avatars.githubusercontent.com/in/347564?v=4","gravatar_id":"","url":"https://api.github.com/users/coderabbitai%5Bbot%5D","html_url":"https://github.com/apps/coderabbitai","followers_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/followers","following_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/following{/other_user}","gists_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/gists{/gist_id}","starred_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/subscriptions","organizations_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/orgs","repos_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/repos","events_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/events{/privacy}","received_events_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"_üõ†Ô∏è Refactor suggestion_\n\n**Same issue: env var case doesn‚Äôt prove anything.**\n\nAssert effect via CA sets instead of console.log.\n\n```diff\n-  test(\"NODE_USE_SYSTEM_CA=1 loads system certificates\", async () => {\n+  test(\"NODE_USE_SYSTEM_CA=1 loads system certificates (default ‚äá system)\", async () => {\n@@\n-      cmd: [bunExe(), \"-e\", \"console.log('OK')\"],\n+      cmd: [bunExe(), \"-e\", `\n+        const tls = require('tls');\n+        const sys = new Set(tls.getCACertificates('system'));\n+        const def = new Set(tls.getCACertificates('default'));\n+        const missing = [...sys].filter(x => !def.has(x)).length;\n+        console.log(JSON.stringify({ missing }));\n+      `],\n@@\n-    expect(exitCode).toBe(0);\n-    expect(stdout.trim()).toBe(\"OK\");\n-    expect(stderr).toBe(\"\");\n+    expect(exitCode).toBe(0);\n+    expect(stderr).toBe(\"\");\n+    const { missing } = JSON.parse(stdout);\n+    expect(missing).toBe(0);\n```\n\n<!-- suggestion_start -->\n\n<details>\n<summary>üìù Committable suggestion</summary>\n\n> ‚ÄºÔ∏è **IMPORTANT**\n> Carefully review the code before committing. Ensure that it accurately replaces the highlighted code, contains no missing lines, and has no issues with indentation. Thoroughly test & benchmark the code to ensure it meets the requirements.\n\n```suggestion\n  test(\"NODE_USE_SYSTEM_CA=1 loads system certificates (default ‚äá system)\", async () => {\n    // Test that NODE_USE_SYSTEM_CA environment variable works\n    await using proc = spawn({\n      cmd: [bunExe(), \"-e\", `\n        const tls = require('tls');\n        const sys = new Set(tls.getCACertificates('system'));\n        const def = new Set(tls.getCACertificates('default'));\n        const missing = [...sys].filter(x => !def.has(x)).length;\n        console.log(JSON.stringify({ missing }));\n      `],\n      env: { ...bunEnv, NODE_USE_SYSTEM_CA: \"1\" },\n      stdout: \"pipe\",\n      stderr: \"pipe\",\n    });\n\n    const [stdout, stderr, exitCode] = await Promise.all([\n      proc.stdout.text(),\n      proc.stderr.text(),\n      proc.exited,\n    ]);\n\n    expect(exitCode).toBe(0);\n    expect(stderr).toBe(\"\");\n    const { missing } = JSON.parse(stdout);\n    expect(missing).toBe(0);\n  });\n```\n\n</details>\n\n<!-- suggestion_end -->\n\n<details>\n<summary>ü§ñ Prompt for AI Agents</summary>\n\n```\ntest/js/node/tls/test-use-system-ca.test.ts lines 22-36: the test currently only\nspawns a process that console.logs(\"OK\"), which doesn't prove NODE_USE_SYSTEM_CA\naltered the loaded CA set; change the spawned command to run a short script that\ninspects the TLS root CA set (e.g. require('tls').rootCertificates or equivalent\nin Bun) and prints a deterministic indicator (such as number of rootCertificates\nor presence of a known system CA string) so the test can assert that the CA set\nwas actually affected; update the assertions to check that the printed indicator\nreflects system CA usage (exitCode 0 and stdout matching the expected CA\nindicator, stderr empty).\n```\n\n</details>\n\n<!-- fingerprinting:phantom:poseidon:chinchilla -->\n\n<!-- This is an auto-generated comment by CodeRabbit -->","created_at":"2025-08-30T00:45:08Z","updated_at":"2025-08-30T00:45:12Z","html_url":"https://github.com/oven-sh/bun/pull/21898#discussion_r2311704012","pull_request_url":"https://api.github.com/repos/oven-sh/bun/pulls/21898","author_association":"NONE","_links":{"self":{"href":"https://api.github.com/repos/oven-sh/bun/pulls/comments/2311704012"},"html":{"href":"https://github.com/oven-sh/bun/pull/21898#discussion_r2311704012"},"pull_request":{"href":"https://api.github.com/repos/oven-sh/bun/pulls/21898"}},"reactions":{"url":"https://api.github.com/repos/oven-sh/bun/pulls/comments/2311704012/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":22,"original_start_line":22,"start_side":"RIGHT","line":null,"original_line":36,"side":"RIGHT","original_position":36,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/oven-sh/bun/pulls/comments/2311704013","pull_request_review_id":3170766628,"id":2311704013,"node_id":"PRRC_kwDOFVKCyc6Jyc3N","diff_hunk":"@@ -0,0 +1,69 @@\n+import { spawn } from \"bun\";\n+import { describe, expect, test } from \"bun:test\";\n+import { bunEnv, bunExe } from \"harness\";\n+\n+describe(\"--use-system-ca\", () => {\n+  test(\"flag loads system certificates\", async () => {\n+    // Test that --use-system-ca loads system certificates\n+    await using proc = spawn({\n+      cmd: [bunExe(), \"--use-system-ca\", \"-e\", \"console.log('OK')\"],\n+      env: bunEnv,\n+      stdout: \"pipe\",\n+      stderr: \"pipe\",\n+    });\n+\n+    const [stdout, stderr, exitCode] = await Promise.all([proc.stdout.text(), proc.stderr.text(), proc.exited]);\n+\n+    expect(exitCode).toBe(0);\n+    expect(stdout.trim()).toBe(\"OK\");\n+    expect(stderr).toBe(\"\");\n+  });\n+\n+  test(\"NODE_USE_SYSTEM_CA=1 loads system certificates\", async () => {\n+    // Test that NODE_USE_SYSTEM_CA environment variable works\n+    await using proc = spawn({\n+      cmd: [bunExe(), \"-e\", \"console.log('OK')\"],\n+      env: { ...bunEnv, NODE_USE_SYSTEM_CA: \"1\" },\n+      stdout: \"pipe\",\n+      stderr: \"pipe\",\n+    });\n+\n+    const [stdout, stderr, exitCode] = await Promise.all([proc.stdout.text(), proc.stderr.text(), proc.exited]);\n+\n+    expect(exitCode).toBe(0);\n+    expect(stdout.trim()).toBe(\"OK\");\n+    expect(stderr).toBe(\"\");\n+  });\n+\n+  test(\"NODE_USE_SYSTEM_CA=0 doesn't load system certificates\", async () => {\n+    // Test that NODE_USE_SYSTEM_CA=0 doesn't load system certificates\n+    await using proc = spawn({\n+      cmd: [bunExe(), \"-e\", \"console.log('OK')\"],\n+      env: { ...bunEnv, NODE_USE_SYSTEM_CA: \"0\" },\n+      stdout: \"pipe\",\n+      stderr: \"pipe\",\n+    });\n+\n+    const [stdout, stderr, exitCode] = await Promise.all([proc.stdout.text(), proc.stderr.text(), proc.exited]);\n+\n+    expect(exitCode).toBe(0);\n+    expect(stdout.trim()).toBe(\"OK\");\n+    expect(stderr).toBe(\"\");\n+  });\n+\n+  test(\"--use-system-ca overrides NODE_USE_SYSTEM_CA=0\", async () => {\n+    // Test that CLI flag takes precedence over environment variable\n+    await using proc = spawn({\n+      cmd: [bunExe(), \"--use-system-ca\", \"-e\", \"console.log('OK')\"],\n+      env: { ...bunEnv, NODE_USE_SYSTEM_CA: \"0\" },\n+      stdout: \"pipe\",\n+      stderr: \"pipe\",\n+    });\n+\n+    const [stdout, stderr, exitCode] = await Promise.all([proc.stdout.text(), proc.stderr.text(), proc.exited]);\n+\n+    expect(exitCode).toBe(0);\n+    expect(stdout.trim()).toBe(\"OK\");\n+    expect(stderr).toBe(\"\");\n+  });\n+});","path":"test/js/node/tls/test-use-system-ca.test.ts","commit_id":"1e05f26c3ba1dc7d90fcd3c1fb90348db3734849","original_commit_id":"56f543fde29b3af1380c98e2950582b9d8b0ab1f","user":{"login":"coderabbitai[bot]","id":136622811,"node_id":"BOT_kgDOCCSy2w","avatar_url":"https://avatars.githubusercontent.com/in/347564?v=4","gravatar_id":"","url":"https://api.github.com/users/coderabbitai%5Bbot%5D","html_url":"https://github.com/apps/coderabbitai","followers_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/followers","following_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/following{/other_user}","gists_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/gists{/gist_id}","starred_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/subscriptions","organizations_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/orgs","repos_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/repos","events_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/events{/privacy}","received_events_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"_üõ†Ô∏è Refactor suggestion_\n\n**Precedence test must assert behavior, not just ‚ÄúOK‚Äù.**\n\nAssert that the CLI flag restores superset behavior even when NODE_USE_SYSTEM_CA=0.\n\n```diff\n-  test(\"--use-system-ca overrides NODE_USE_SYSTEM_CA=0\", async () => {\n+  test(\"--use-system-ca overrides NODE_USE_SYSTEM_CA=0 (default ‚äá system)\", async () => {\n@@\n-      cmd: [bunExe(), \"--use-system-ca\", \"-e\", \"console.log('OK')\"],\n+      cmd: [bunExe(), \"--use-system-ca\", \"-e\", `\n+        const tls = require('tls');\n+        const sys = new Set(tls.getCACertificates('system'));\n+        const def = new Set(tls.getCACertificates('default'));\n+        const missing = [...sys].filter(x => !def.has(x)).length;\n+        console.log(JSON.stringify({ missing }));\n+      `],\n@@\n-    expect(exitCode).toBe(0);\n-    expect(stdout.trim()).toBe(\"OK\");\n-    expect(stderr).toBe(\"\");\n+    expect(exitCode).toBe(0);\n+    expect(stderr).toBe(\"\");\n+    const { missing } = JSON.parse(stdout);\n+    expect(missing).toBe(0);\n```\n\n<!-- suggestion_start -->\n\n<details>\n<summary>üìù Committable suggestion</summary>\n\n> ‚ÄºÔ∏è **IMPORTANT**\n> Carefully review the code before committing. Ensure that it accurately replaces the highlighted code, contains no missing lines, and has no issues with indentation. Thoroughly test & benchmark the code to ensure it meets the requirements.\n\n```suggestion\n  test(\"--use-system-ca overrides NODE_USE_SYSTEM_CA=0 (default ‚äá system)\", async () => {\n    // Test that CLI flag takes precedence over environment variable\n    await using proc = spawn({\n      cmd: [bunExe(), \"--use-system-ca\", \"-e\", `\n        const tls = require('tls');\n        const sys = new Set(tls.getCACertificates('system'));\n        const def = new Set(tls.getCACertificates('default'));\n        const missing = [...sys].filter(x => !def.has(x)).length;\n        console.log(JSON.stringify({ missing }));\n      `],\n      env: { ...bunEnv, NODE_USE_SYSTEM_CA: \"0\" },\n      stdout: \"pipe\",\n      stderr: \"pipe\",\n    });\n\n    const [stdout, stderr, exitCode] = await Promise.all([\n      proc.stdout.text(),\n      proc.stderr.text(),\n      proc.exited,\n    ]);\n\n    expect(exitCode).toBe(0);\n    expect(stderr).toBe(\"\");\n    const { missing } = JSON.parse(stdout);\n    expect(missing).toBe(0);\n  });\n```\n\n</details>\n\n<!-- suggestion_end -->\n\n<!-- fingerprinting:phantom:poseidon:chinchilla -->\n\n<!-- This is an auto-generated comment by CodeRabbit -->","created_at":"2025-08-30T00:45:08Z","updated_at":"2025-08-30T00:45:12Z","html_url":"https://github.com/oven-sh/bun/pull/21898#discussion_r2311704013","pull_request_url":"https://api.github.com/repos/oven-sh/bun/pulls/21898","author_association":"NONE","_links":{"self":{"href":"https://api.github.com/repos/oven-sh/bun/pulls/comments/2311704013"},"html":{"href":"https://github.com/oven-sh/bun/pull/21898#discussion_r2311704013"},"pull_request":{"href":"https://api.github.com/repos/oven-sh/bun/pulls/21898"}},"reactions":{"url":"https://api.github.com/repos/oven-sh/bun/pulls/comments/2311704013/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":54,"original_start_line":54,"start_side":"RIGHT","line":null,"original_line":69,"side":"RIGHT","original_position":69,"position":1,"subject_type":"line"}]