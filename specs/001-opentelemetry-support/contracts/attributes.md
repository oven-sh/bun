# Contract: Attribute System

**Feature**: OpenTelemetry Support for Bun
**Component**: SemConv Attribute Handling and Header Mapping
**Scope**: Low-level interoperability with `@opentelemetry/semantic-attributes`
**Audience**: Bun application developers

# Authoritative Sources

All attribute key symbol names, string values, and enum constants MUST be generated from:

- `@opentelemetry/semantic-attributes`
- `src/bun.js/bindings/webcore/HTTPHeaderNames.h`
- `src/bun.js/bindings/webcore/HTTPHeaderNames.gperf`

The code generation command SHOULD be `bun run packages/bun-otel/scripts/generate-semconv.ts`

# **API Surface**

## **AttributeKey**

`AttributeKey` represents a semconv attribute key like `error.type`, `http.response.status_code`, or `http.request.header.content-type`. A subset of AttributeKeys are HeaderAttributeKeys, i.e. correspond directly to HTTP headers, for example `http.request.header.content-type` represents the `content-type` header.

Functional Requirements:

- FR01: AttributeKey definitions and MUST be generated by `generate-semconv.ts` to remain in-sync with the Authoritative Sources

- FR02: Zig native code MUST consistently reference AttributeKeys well-known scalar keys by symbol name
  - scalar meaning a number, singleton-pointer, enum, etc; able to equality test with `==` and pass-by-value
  - acceptable: `AttributeKey.http_request_header_content_type` (enum value)
  - acceptable: `bun.telemetry.semver.http_request_header_content_type` (singleton)
  - unacceptable: `"http.request.header.content-type"` (string constant)
  - unacceptable: `42 // http.request.header.content-type` (hardcoded constant)

- FR03: AttributeKey MUST support all AttributeList operations:
  - FR03a: `AttributeKey.fromJS(*JSValue)` MUST validates semconv string (null if invalid), looks up if common, allocates from pool if uncommon.
  - FR03b: `attr.fast_header: u8` MUST correspond to the `HTTPHeaderNames` enum value for http._.header._ AttributeKeys which are present in the 93 fast `HTTPHeaderNames`
  - FR03c: `attr.http_header: const u8[]` with the naked lower-case header string, for http._.header._ AttributeKeys
  - Future/Optional: `attr.value_type: ValueType` for validation in lists and maps

- FR04: AttributeKey MUST support all AttributeMap operations:
- FR05: AttributeKey SHOULD string pool where possible
- FR06: AttributeKey MUST support 0-allocation comparison for string names
- FR07: AttributeKey MUST support O(1) conversion to HTTPHeaderNames ints (0-92) for `http.request.header.*` and `http.request.header.*` prefixes, where applicable.

Implementation Guidance:

`AttributeKeys` MAY be

- well-known, used directly by the native bindings in Bun, known at comptime (10-20)
- well-known, based on http headers that are in the `HTTPHeaderNames` list (93 x 2 for request+response)
- well-known, based on http headers not in the HTTPHeaderNames, but used by native or Typescript bindings (`traceparent`) because `HTTPHeaderNames` has not been updated to include the telemetry headers yet
- uncommon, generated at attach/detach time (`x-custom-header-1`) by users through programatic or env configuration. [^1]

The AttributeKeys semconvs MUST NOT BE be invalid/untrusted/unbounded to prevent DoS/depletion.

[^1] to make this unbounded, API users would need to call Bun.telemetry.attach() in response to external traffic with untrusted input. No more than 1024 AttributeKeys should be allowed. Above this, additional uncommon values are mapped to the error key (with logging). This is deemed a low risk.

Lifespan:

- the entire life of the application when telemetry is enabled
- well-known values initialized lazily on telemetry use
- uncommon values initialized when first used

## AttributeValue

AttributeValue is defined as a `JSValue`. `JSValue` is a wrapper around JavaScriptCore (JSC) values which are highly optimized already. No amount of additional optimization will result in an improvement.

Well-known AttributeValues (such as `"GET"` and `"POST"` and `0`) SHOULD be kept in a pool in a shared location (e.g. `attributes.zig`) when used by native code. However, in general, HTTP header values SHOULD NOT use pooling to avoid unbounded memory accumulation.

## AttributeList

Efficiently store arbitrary (both fast and uncommon) AttributeKeys (without values). This is used by the configuration to store headers that whitelisted and should be included.

- FR08: Utility function `fn parseAttributeList` MUST accept a JSValue holding a JS `Array<string>` and produce an AttributeList with the exact same number of array elements
- FR09: must have a way to access the length of the list in O(1) time
- FR10: must have a way to enumerate over the elements in the list in O(n) time

Implementation Guidance:

- lifespan: generally, the duration of the application (except for testing)
- acceptable: A mutable vector holding pointers to AttributeKeys
- unacceptable: a BitSet based on fast_attribute id, where the order could change

Note `AttributeList` **MUST** preserve enumeration order for `AttributeKeys` when created from a `string[]` or `JSValue<[string]>`. Header injection (TS -> zig) passes only header values, matching key-to-value for headers.set depends on the order of both arrays.

## AttributeMap

Efficiently store arbitrary (well-known and uncommon) AttributeKey -> AttributeValue (JSValue) mappings. Used by native instrumentation touch-points as the attribute bag for assembling values to pass up to TS. The basic operations are:

- `set(AttributeKey, JSValue)`
- `get(AttributeKey): JSValue`
- `keys(): AttributeKey[]`

Memory Model:

- AttributeKeys are pooled and effectively constant
- AttributeValues are JSValue managed by JSC. This may involve memory allocation. AttributeMap must unref its values (not keys!)

Advanced/optimized operations are built upon for specific touch-points within the Bun codebase. They are designed to provide the lowest possible overhead for inline instrumentation. This means handling low-level constructs in the underlying libraries. Use cases:

### HttpHeaders

Touch-points SHOULD use one of the following:

#### Path 1: FetchHeaders + HTTPHeaderName enum (fastest)

- Direct O(1) lookup using HTTPHeaderName enum
- For headers like "user-agent" → id 120 → context | 120
- Use `fastGet(attr.fast_header) -> zigString`

#### Path 2: FetchHeaders + well-known OTel headers (fast)

- Call `.get()` with known header names (`traceparent`, `tracestate`, `baggage`) as `[]const u8` from `attr.http_header`

#### Path 3: Plain object from `js_request` and `_http_server.ts`:

- Property access on plain JS object
- Still benefits from pooled header list
- e.g. `jsValue.getStringish(attr.http_header)` (accepts `[]const u8`) -> BunString (refcounted) OR
- e.g. `jsValue.getOptional(attr.http_header, .string)` (accepts `[]const u8`) -> JSValue string
- out of scope: repeated headers

#### Path 4: UWSRequest/UWSResponse headers

-

### Use Case: Fetch

- Request: input FetchHeaders ✅ ok to instrument
- Response:
  - in: PicoHttp `*const bun.picohttp.Header.List` ⚠️
    caution, parsing will require additional allocation
  - out: webcore.Response (response.#init.headers once parsed) -> FetchHeaders ✅ ok to instrument once parsed, if ref()ed

### Use Case: RequestContext

- Request:
  - `js_request` (`JSValue`) ⚠️ may be missing
  - `*uws.Request` ⚠️ defensive copy required

- Response
  - `FetchHeaders` when response.#init.headers has been set (i.e. user has set some headers already) ✅ ok to instrument once parsed

Note: Some headers are set at layers below what the user has access to. The preference is to use `FetchHeaders` and manually add attributes from other properties (e.g. content_length) manually, rather than trying to extract them.

CAUTION: in `src/bun.js/api/server.zig:2162` the fn `prepareJsRequestContext` accepts a `create_js_request` parameter, which may be `.no`, in which case **the JSValue version of the request **is not created\*\*
The note on `src/bun.js/api/server.zig:2169` says "to save a request, all information from `req` must be copied since the provided uws.Request will be re-used for future requests (stack allocated)."

calls (8 total) by `create_js_request` param:

- yes: `onRequest` (for fetch: fn() ?)
- no: `onUserRouteRequest` (for bun.route? IDK)
- no: `upgradeWebSocketUserRoute`
- bake: `prepareAndSaveJsRequestContext` (4 places)
- bake: when `saved` in `onSavedRequest`

Telemetry should both with a JS version and without a JS version. Prefer

- JSValue `js_request` when present, because the header values will be JSValues and already managed
- Fallback to uws.Request

# Summary of HTTP Headers used in Bun

## **webcore.FetchHeaders**

Zig Ref: `src/bun.js/bindings/FetchHeaders.zig`
C++ Ref: `src/bun.js/bindings/bindings.cpp` (near 2000)

- JSC Native Header Bindings
- keys:
  - fast (93 enumerated headers)
  - uncommon: ZigString (zig) --> WTF::String (cpp)
- values: ZigString (zig), WTF::String (cpp)

Extra functions

```
fn from(names: []StringPointer, []StringPointer)
fn createFromUWS: WebCore__FetchHeaders__createFromUWS
fn toUWSResponse:
createFromPicoHeaders (C: WebCore__FetchHeaders__toUWSResponse)
WebCore__FetchHeaders__createFromPicoHeaders_)
```

## **http.Headers** (`src/http/Headers.zig`)

- keys and values: bun.api.schema.StringPointer (raw offset-length)

## picohttp.Header.List

- Instrumented Type: `*const bun.picohttp.Header.List`
- ref: `src/deps/picohttp.zig`
- def: `const Header = struct {  name: []const u8, value: []const u8, }` (List is just a list)
- AttributeList enumeration: pass `attr.http_header: []const u8` to `picoheader.get`
-
