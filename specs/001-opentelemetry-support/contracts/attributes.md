# Contract: Attribute System

**Feature**: OpenTelemetry Support for Bun
**Component**: SemConv Attribute Handling and Header Mapping
**Scope**: Low-level interoperability with `@opentelemetry/semantic-attributes`
**Audience**: Bun application developers

# Authoritative Sources

All attribute key symbol names, string values, and enum constants MUST be generated from:

- `@opentelemetry/semantic-attributes`
- `src/bun.js/bindings/webcore/HTTPHeaderNames.h`
- `src/bun.js/bindings/webcore/HTTPHeaderNames.gperf`

The code generation command SHOULD be `bun run packages/bun-otel/scripts/generate-semconv.ts`

# **API Surface**

## **AttributeKey**

`AttributeKey` represents a semconv attribute key like `error.type`, `http.response.status_code`, or `http.request.header.content-type`. A subset of AttributeKeys are HeaderAttributeKeys, i.e. correspond directly to HTTP headers, for example `http.request.header.content-type` represents the `content-type` header.

Functional Requirements:

- FR01: AttributeKey definitions and MUST be generated by `generate-semconv.ts` to remain in-sync with the Authoritative Sources

- FR02: Zig native code MUST consistently reference AttributeKeys by symbol name
  - well-known keys are code-generated members of `AttributeKeys` struct, lazily initialized
  - uncommon keys are dynamically allocated at runtime (not code-generated)
  - acceptable: `bun.telemetry.semconv.http_request_header_content_type` (well-known)
  - acceptable: `attribute_key_ptr` (pointer to uncommon key)
  - unacceptable: `"http.request.header.content-type"` (string constant)
  - unacceptable: `42 // http.request.header.content-type` (hardcoded constant)

- FR03: AttributeKey MUST support all AttributeList operations:
  - FR03a: `AttributeKey.fromJS(*JSValue)` MUST validate semconv string (null if invalid), look up if common, allocate from pool if uncommon. Validation: <1024 chars, no spaces, all lowercase, format `/[a-z0-9]+([.][a-z0-9]+)*/` (no regex engine required, no dictionary check required). String-to-AttributeKey lookup does NOT need optimization (linear search acceptable); only done during init/attach (infrequent), allows deduplication across detach calls.
  - FR03b: `attr.id: u16` MUST correspond to position in the up-to-1024 global list for O(1) indexOf operations
  - FR03c: `attr.semconv_name: []const u8` MUST contain the full semconv key (e.g. "http.request.header.content-type")
  - FR03d: `attr.fast_header: ?u8` MUST be HTTPHeaderNames enum value (0-92) for http._.header._ keys in the 93 fast headers, null otherwise
  - FR03e: `attr.http_header: ?[]const u8` MUST be the naked lower-case header string for http._.header._ keys, null otherwise
  - Future/Optional: `attr.value_type: ValueType` for validation in lists and maps

- FR04: AttributeKey MUST support all AttributeMap operations:
- FR05: AttributeKey SHOULD string pool where possible
- FR06: AttributeKey MUST support 0-allocation comparison for string names
- FR07: AttributeKey MUST support O(1) conversion to HTTPHeaderNames ints (0-92) for `http.request.header.*` and `http.response.header.*` prefixes, where applicable.

AttributeKey Memory Layout:

```zig
pub const AttributeKey = struct {
    id: u16,                    // Position in global list (0-1023)
    semconv_name: []const u8,   // e.g. "http.request.header.content-type" (complete, not prefixed)
    fast_header: ?u8,           // HTTPHeaderNames enum (0-92) if applicable, null otherwise
    http_header: ?[]const u8,   // Naked header string e.g. "content-type", null if not a header

    /// Get HTTP direction by checking semconv_name: "http.{request|response}.header.*"
    pub fn httpDirection(self: *const AttributeKey) ?enum { request, response } {
        if (self.semconv_name.len < 8) return null;
        if (self.semconv_name[7] == 'q') return .request;  // "http.request."
        if (self.semconv_name[7] == 's') return .response; // "http.response."
        return null;
    }
};
```

String Storage: Complete semconv names stored intact (not namespace-prefixed) for simplicity and runtime performance. Binary size increase (~1KB) is acceptable trade-off vs concatenation overhead on every access.

AttributeKeys Singleton Structure:

```zig
pub const AttributeKeys = struct {
    // Well-known semconv attributes (code-generated)
    http_request_method: *AttributeKey,
    http_response_status_code: *AttributeKey,
    error_type: *AttributeKey,
    // ... ~10-20 core attributes

    // Well-known HTTP header attributes (code-generated)
    http_request_header_content_type: *AttributeKey,
    http_request_header_traceid: *AttributeKey,
    http_response_header_content_type: *AttributeKey,
    // ... 93 x 2 for request+response headers

    // Global list of all AttributeKeys (well-known + uncommon)
    all: [1024]*AttributeKey,
    len: u16,

    pub fn init() AttributeKeys;
    pub fn lookupSemconv(name: []const u8) ?*AttributeKey;
    /// Lookup HTTP header by direction and name. Header name is normalized to lowercase per RFC 7230.
    pub fn lookupHeader(direction: enum { request, response }, header: []const u8) ?*AttributeKey;
};
```

Deduplication: `http.request.header.x-custom` and `http.response.header.x-custom` are separate keys. Semconv name is the primary key; request vs response is unambiguous from context.

## Telemetry Integration

AttributeKeys are accessed through the telemetry API's `TelemetryContext.semconv` field.

**See**: `specs/001-opentelemetry-support/contracts/telemetry-context.md` for complete Zig runtime API contract, including:
- `TelemetryContext` structure and operations
- `enabled()` function and usage patterns
- `notifyOperation*` lifecycle functions
- Zero-overhead guarantee when telemetry disabled

Typical usage:
```zig
if (bun.telemetry.enabled()) |otel| {
    var attrs = otel.createAttributeMap();
    attrs.set(otel.semconv.http_request_method, method); // Using AttributeKeys singleton
    attrs.set(otel.semconv.url_path, path);
    otel.notifyOperationStart(.http, op_id, &attrs); // Pass by pointer
}
```

Implementation Guidance:

`AttributeKeys` MAY be

- well-known, used directly by the native bindings in Bun, known at comptime (10-20)
- well-known, based on http headers that are in the `HTTPHeaderNames` list (93 x 2 for request+response)
- well-known, based on http headers not in the HTTPHeaderNames, but used by native or Typescript bindings (`traceparent`) because `HTTPHeaderNames` has not been updated to include the telemetry headers yet
- uncommon, generated at attach/detach time (`x-custom-header-1`) by users through programatic or env configuration. [^1]

The AttributeKeys semconvs MUST NOT BE be invalid/untrusted/unbounded to prevent DoS/depletion.

Storage: Global singleton `AttributeKeys` struct at `bun.telemetry.semconv`, lazily initialized on first telemetry use. Well-known keys code-generated and initialized in `init()`. Uncommon keys allocated dynamically on-demand.

[^1] to make this unbounded, API users would need to call Bun.telemetry.attach() in response to external traffic with untrusted input. No more than 1024 AttributeKeys should be allowed. Above this, additional uncommon values are mapped to the error key (with logging). This is deemed a low risk.

Lifespan:

- the entire life of the application when telemetry is enabled
- well-known values initialized lazily on telemetry use
- uncommon values initialized when first used

## AttributeValue

AttributeValue is defined as a `JSValue`. `JSValue` is a wrapper around JavaScriptCore (JSC) values which are highly optimized already. No amount of additional optimization will result in an improvement.

Well-known AttributeValues (such as `"GET"` and `"POST"` and `0`) SHOULD be kept in a pool in a shared location (e.g. `attributes.zig`) when used by native code. However, in general, HTTP header values SHOULD NOT use pooling to avoid unbounded memory accumulation.

Memory Management: Downstream consumers of AttributeMap will NOT be synchronous (batch/queue, fetch, asyncIO). MUST NOT keep entire request/response objects alive just to reference header values.

AttributeMap uses internal JSValue object (Record<string, JSValue>) for storage. When adding attributes:

- JSValue strings: Add directly to map (already JSC-managed, refcounted)
- ZigString/StringPointer/BunString: Copy to JSValue string using Bun API before adding
- Ensures FetchHeaders, uws.Request, uws.Response can be released immediately
- No dangling pointers to stack-allocated data

Implementation:

```zig
pub const AttributeMap = struct {
    js_map: JSValue,  // Record<string, JSValue>

    pub fn set(self: *AttributeMap, key: *AttributeKey, val: anytype) void {
        const js_val = switch (@TypeOf(val)) {
            JSValue => val,  // Already JSValue, use directly
            ZigString, StringPointer, BunString => copyToJSValue(val),  // Copy to JSValue
            else => @compileError("Unsupported value type"),
        };
        self.js_map.put(key.semconv_name, js_val);
    }

    // INTERNAL IMPLEMENTATION DETAIL - DO NOT CALL FROM APPLICATION CODE
    // This method is called internally by TelemetryContext.notifyOperation* methods
    // Application code should pass AttributeMap by pointer (&attrs), never call toJS() directly
    // The conversion to JSValue happens automatically inside the notify methods
    pub fn toJS(self: *AttributeMap) JSValue {
        return self.js_map;  // Already a JS object
    }
};
```

## AttributeList

Efficiently store arbitrary (both fast and uncommon) AttributeKeys (without values). This is used by the configuration to store headers that whitelisted and should be included.

- FR08: Utility function `fn parseAttributeList` MUST accept a JSValue holding a JS `Array<string>` and produce an AttributeList with the exact same number of array elements
- FR09: must have a way to access the length of the list in O(1) time
- FR10: must have a way to enumerate over the elements in the list in O(n) time

Implementation Guidance:

- lifespan: generally, the duration of the application (except for testing)
- acceptable: A mutable vector holding pointers to AttributeKeys
- unacceptable: a BitSet based on fast_attribute id, where the order could change

Ordering: `AttributeList` **MUST** preserve enumeration order. Example: inject `traceid`, `traceparent`, `x-trace-custom` headers. Attach configuration contains `['traceid', 'traceparent', 'x-trace-custom']` (stored as AttributeList). TS `onOperationInject` returns `["012345677012412", "abc124314aab341", "custom-12345"]`. Key-to-value correlation depends purely on array order; sorting would break this. Lists are small (0-10). All use cases iterate (copying headers to AttributeMap, setting custom headers during onOperationInject); no benefit to optimizing `contains()`.

## AttributeMap

Efficiently store arbitrary (well-known and uncommon) AttributeKey -> AttributeValue (JSValue) mappings. Used by native instrumentation touch-points as the attribute bag for assembling values to pass up to TS. The basic operations are:

- `set(*AttributeKey, val: JSValue|ZigString|StringPointer|BunString)` - Copies non-JSValue strings
- `get(*AttributeKey): JSValue`
- `toJS(): JSValue` - **INTERNAL ONLY** - Returns the internal JS object. Do not call from application code; pass AttributeMap by pointer (`&attrs`) to notify methods instead.

Memory Model:

- Internal storage is JSValue object (Record<string, JSValue>)
- AttributeKeys are pooled in global singleton (pointers remain valid)
- JSValue strings added directly (already JSC-managed, no copy needed)
- Native strings (ZigString/StringPointer/BunString) copied to JSValue on set()
- Attribute counts are small (0-20), simple JS object is sufficient

Advanced/optimized operations are built upon for specific touch-points within the Bun codebase. They are designed to provide the lowest possible overhead for inline instrumentation. This means handling low-level constructs in the underlying libraries. Use cases:

### HttpHeaders

Touch-points SHOULD use one of the following:

#### Path 1: FetchHeaders + HTTPHeaderName enum (fastest)

- Direct O(1) lookup using HTTPHeaderName enum
- For headers like "user-agent" → id 120 → context | 120
- Use `fastGet(attr.fast_header) -> zigString`

#### Path 2: FetchHeaders + well-known OTel headers (fast)

- Call `.get()` with known header names (`traceparent`, `tracestate`, `baggage`) as `[]const u8` from `attr.http_header`

#### Path 3: Plain object from `js_request` and `_http_server.ts`:

- Property access on plain JS object
- Still benefits from pooled header list
- e.g. `jsValue.getStringish(attr.http_header)` (accepts `[]const u8`) -> BunString (refcounted) OR
- e.g. `jsValue.getOptional(attr.http_header, .string)` (accepts `[]const u8`) -> JSValue string
- out of scope: repeated headers

#### Path 4: UWSRequest/UWSResponse headers

- When `js_request` does not exist, MUST make defensive copy of desired headers for instrumentation
- See `src/bun.js/api/server.zig:2168-2169`: uws.Request is stack-allocated and reused for future requests

### Use Case: Fetch

- Request: input FetchHeaders ✅ ok to instrument
- Response:
  - in: PicoHttp `*const bun.picohttp.Header.List` ⚠️
    caution, parsing will require additional allocation
  - out: webcore.Response (response.#init.headers once parsed) -> FetchHeaders ✅ ok to instrument once parsed, if ref()ed

### Use Case: RequestContext

- Request:
  - `js_request` (`JSValue`) ⚠️ may be missing
  - `*uws.Request` ⚠️ defensive copy required

- Response
  - `FetchHeaders` when response.#init.headers has been set (i.e. user has set some headers already) ✅ ok to instrument once parsed

Note: Some headers are set at layers below what the user has access to. The preference is to use `FetchHeaders` and manually add attributes from other properties (e.g. content_length) manually, rather than trying to extract them.

CAUTION: in `src/bun.js/api/server.zig:2182` the fn `prepareJsRequestContext` accepts a `create_js_request` parameter, which may be `.no`, in which case **the JSValue version of the request **is not created\*\*
The note on `src/bun.js/api/server.zig:2168-2169` says "to save a request, all information from `req` must be copied since the provided uws.Request will be re-used for future requests (stack allocated)."

calls (8 total) by `create_js_request` param:

- yes: `onRequest` (for fetch: fn() ?)
- no: `onUserRouteRequest` (for bun.route? IDK)
- no: `upgradeWebSocketUserRoute`
- bake: `prepareAndSaveJsRequestContext` (4 places)
- bake: when `saved` in `onSavedRequest`

Telemetry should both with a JS version and without a JS version. Prefer

- JSValue `js_request` when present, because the header values will be JSValues and already managed
- Fallback to uws.Request

# Error Handling

AttributeKey allocation and telemetry operations have specific error handling requirements:

## Out of Memory (OOM)

- **Behavior**: Abort operation, bubble up, early return
- **No logging**: Silent failure to avoid cascading errors
- **Context**: When allocating uncommon AttributeKeys or copying strings
- **Example**: If `allocator.create(AttributeKey)` fails, return null/error without logging

## Invalid Configuration

- **Behavior**: Raise global error via `raiseGlobalError`
- **Context**: During `init()` or `attach()` when user provides invalid semconv names
- **Example**: User passes `"invalid name with spaces"` in captureHeaders config

## Pool Overflow (>1024 AttributeKeys)

- **Behavior**: Treat as OOM
- **During configuration**: Raise global error (blocks telemetry init)
- **Context**: When 1024 limit reached during attach()
- **Note**: Does NOT raise error during request handling (semconv attrs only registered at config time)

# Threat Model

## Attack Vector: Memory Exhaustion via Custom Headers

**Scenario**: Malicious user sends requests with 1024+ unique `x-custom-header-N` values to exhaust AttributeKey pool.

**Mitigation**: AttributeKeys are ONLY allocated during configuration (system startup, `init()`, `attach()`) - NOT during request handling.

**Attack Prevention**:

1. Uncommon AttributeKeys created only from user configuration, not request data
2. Configuration is trusted (controlled by application developer, not end users)
3. Request headers are looked up against pre-allocated AttributeKeys
4. Unknown request headers are ignored, not allocated
5. 1024 limit enforced at configuration time, not runtime

**Conclusion**: Design is NOT susceptible to runtime memory exhaustion attacks. Attacker cannot control configuration.

**Edge Case**: If application dynamically calls `Bun.telemetry.attach()` in response to external traffic with untrusted input, that is a developer error. The 1024 limit provides a safety net, but dynamic reconfiguration from untrusted sources is explicitly out of scope.

# Summary of HTTP Headers used in Bun

## **webcore.FetchHeaders**

Zig Ref: `src/bun.js/bindings/FetchHeaders.zig`
C++ Ref: `src/bun.js/bindings/bindings.cpp` (near 2000)

- JSC Native Header Bindings
- keys:
  - fast (93 enumerated headers)
  - uncommon: ZigString (zig) --> WTF::String (cpp)
- values: ZigString (zig), WTF::String (cpp)

Extra functions

```
fn from(names: []StringPointer, []StringPointer)
fn createFromUWS: WebCore__FetchHeaders__createFromUWS
fn toUWSResponse:
createFromPicoHeaders (C: WebCore__FetchHeaders__toUWSResponse)
WebCore__FetchHeaders__createFromPicoHeaders_)
```

## **http.Headers** (`src/http/Headers.zig`)

- keys and values: api.StringPointer (raw offset-length; defined as `bun.api.schema.StringPointer` in `src/api/schema.zig:830`)

## picohttp.Header.List

- Instrumented Type: `*const bun.picohttp.Header.List`
- ref: `src/deps/picohttp.zig`
- def: `const Header = struct {  name: []const u8, value: []const u8, }` (List is just a list)
- AttributeList enumeration: pass `attr.http_header: []const u8` to `picoheader.get`
-
