
// AUTO-GENERATED FILE. DO NOT EDIT.
// Generated by 'make generate-sink'
// To regenerate this file, run:
//
//   make generate-sink
//
#include "root.h"
#include "headers.h"
#include "BunClientData.h"

#include "JSSink.h"
#include "AsyncBoundFunction.h"

#include "ActiveDOMObject.h"
#include "ExtendedDOMClientIsoSubspaces.h"
#include "ExtendedDOMIsoSubspaces.h"
#include "IDLTypes.h"
// #include "JSBlob.h"
#include "JSDOMAttribute.h"
#include "JSDOMBinding.h"
#include "JSDOMConstructor.h"
#include "JSDOMConvertBase.h"
#include "JSDOMConvertInterface.h"
#include "JSDOMConvertStrings.h"
#include "JSDOMExceptionHandling.h"
#include "JSDOMGlobalObject.h"
#include "JSDOMGlobalObjectInlines.h"
#include "JSDOMOperation.h"
#include "JSDOMWrapperCache.h"
#include "ScriptExecutionContext.h"
#include "WebCoreJSClientData.h"
#include "JavaScriptCore/FunctionPrototype.h"
#include "JavaScriptCore/HeapAnalyzer.h"

#include "JavaScriptCore/JSDestructibleObjectHeapCellType.h"
#include "JavaScriptCore/SlotVisitorMacros.h"
#include "JavaScriptCore/SubspaceInlines.h"
#include "wtf/GetPtr.h"
#include "wtf/PointerPreparations.h"
#include "wtf/URL.h"
#include "JavaScriptCore/BuiltinNames.h"

#include "JSBufferEncodingType.h"
#include "JavaScriptCore/JSBase.h"
#if ENABLE(MEDIA_SOURCE)
#include "BufferMediaSource.h"
#include "JSMediaSource.h"
#endif

// #include "JavaScriptCore/JSTypedArrayViewPrototype.h"
#include "JavaScriptCore/JSArrayBufferViewInlines.h"

#include "JSReadableStream.h"
#include "BunClientData.h"
#include "JavaScriptCore/Weak.h"
#include "JavaScriptCore/WeakInlines.h"

namespace WebCore {
using namespace JSC;

JSC_DEFINE_HOST_FUNCTION(functionStartDirectStream, (JSC::JSGlobalObject * lexicalGlobalObject, JSC::CallFrame* callFrame))
{

    auto& vm = lexicalGlobalObject->vm();
    auto scope = DECLARE_THROW_SCOPE(vm);
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);

    JSC::JSValue readableStream = callFrame->argument(0);
    JSC::JSValue onPull = callFrame->argument(1);
    JSC::JSValue onClose = callFrame->argument(2);
    JSC::JSValue asyncContext = callFrame->argument(3);

    if (!readableStream.isObject()) {
        scope.throwException(globalObject, JSC::createTypeError(globalObject, "Expected ReadableStream"_s));
        return JSC::JSValue::encode(JSC::jsUndefined());
    }

    if (!onPull.isObject() || !onPull.isCallable()) {
        onPull = JSC::jsUndefined();
    } else if (!asyncContext.isUndefined()) {
        onPull = AsyncBoundFunction::create(globalObject, onPull, asyncContext);
    }

    if (!onClose.isObject() || !onClose.isCallable()) {
        onClose = JSC::jsUndefined();
    } else if (!asyncContext.isUndefined()) {
        onClose = AsyncBoundFunction::create(globalObject, onClose, asyncContext);
    }

    if (WebCore::JSReadableArrayBufferSinkController* ArrayBufferSinkController = JSC::jsDynamicCast<WebCore::JSReadableArrayBufferSinkController*>(callFrame->thisValue())) {
        if (ArrayBufferSinkController->wrapped() == nullptr) {
            scope.throwException(globalObject, JSC::createTypeError(globalObject, "Cannot start stream with closed controller"_s));
            return JSC::JSValue::encode(JSC::jsUndefined());
        }

        ArrayBufferSinkController->start(globalObject, readableStream, onPull, onClose);
    }

    else if (WebCore::JSReadableFileSinkController* FileSinkController = JSC::jsDynamicCast<WebCore::JSReadableFileSinkController*>(callFrame->thisValue())) {
        if (FileSinkController->wrapped() == nullptr) {
            scope.throwException(globalObject, JSC::createTypeError(globalObject, "Cannot start stream with closed controller"_s));
            return JSC::JSValue::encode(JSC::jsUndefined());
        }

        FileSinkController->start(globalObject, readableStream, onPull, onClose);
    }

    else if (WebCore::JSReadableHTTPResponseSinkController* HTTPResponseSinkController = JSC::jsDynamicCast<WebCore::JSReadableHTTPResponseSinkController*>(callFrame->thisValue())) {
        if (HTTPResponseSinkController->wrapped() == nullptr) {
            scope.throwException(globalObject, JSC::createTypeError(globalObject, "Cannot start stream with closed controller"_s));
            return JSC::JSValue::encode(JSC::jsUndefined());
        }

        HTTPResponseSinkController->start(globalObject, readableStream, onPull, onClose);
    }

    else if (WebCore::JSReadableHTTPSResponseSinkController* HTTPSResponseSinkController = JSC::jsDynamicCast<WebCore::JSReadableHTTPSResponseSinkController*>(callFrame->thisValue())) {
        if (HTTPSResponseSinkController->wrapped() == nullptr) {
            scope.throwException(globalObject, JSC::createTypeError(globalObject, "Cannot start stream with closed controller"_s));
            return JSC::JSValue::encode(JSC::jsUndefined());
        }

        HTTPSResponseSinkController->start(globalObject, readableStream, onPull, onClose);
    }

    else {
        scope.throwException(globalObject, JSC::createTypeError(globalObject, "Unknown direct controller. This is a bug in Bun."_s));
        return JSC::JSValue::encode(JSC::jsUndefined());
    }

    RELEASE_AND_RETURN(scope, JSC::JSValue::encode(JSC::jsUndefined()));
}

void JSArrayBufferSink::ref()
{
    if (!m_sinkPtr)
        return;

    m_refCount++;
    if (m_refCount == 1) {
        ArrayBufferSink__updateRef(m_sinkPtr, true);
    }
}

void JSArrayBufferSink::unref()
{
    if (!m_sinkPtr)
        return;

    m_refCount = std::max(0, m_refCount - 1);
    if (!m_refCount) {
        ArrayBufferSink__updateRef(m_sinkPtr, false);
    }
}

JSC_DEFINE_HOST_FUNCTION(ArrayBufferSink__ref, (JSC::JSGlobalObject * lexicalGlobalObject, JSC::CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();
    auto* sink = jsDynamicCast<WebCore::JSArrayBufferSink*>(callFrame->thisValue());
    if (LIKELY(sink)) {
        sink->ref();
    }
    return JSC::JSValue::encode(JSC::jsUndefined());
}

JSC_DEFINE_HOST_FUNCTION(ArrayBufferSink__unref, (JSC::JSGlobalObject * lexicalGlobalObject, JSC::CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();
    auto* sink = jsDynamicCast<WebCore::JSArrayBufferSink*>(callFrame->thisValue());
    if (LIKELY(sink)) {
        sink->unref();
    }
    return JSC::JSValue::encode(JSC::jsUndefined());
}

JSC_DEFINE_CUSTOM_GETTER(functionArrayBufferSink__getter, (JSC::JSGlobalObject * lexicalGlobalObject, JSC::EncodedJSValue thisValue, JSC::PropertyName))
{
    auto& vm = lexicalGlobalObject->vm();
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);

    return JSC::JSValue::encode(globalObject->ArrayBufferSink());
}

JSC_DECLARE_HOST_FUNCTION(JSReadableArrayBufferSinkController__close);
JSC_DEFINE_HOST_FUNCTION(JSReadableArrayBufferSinkController__close, (JSC::JSGlobalObject * lexicalGlobalObject, JSC::CallFrame* callFrame))
{

    auto& vm = lexicalGlobalObject->vm();
    auto scope = DECLARE_THROW_SCOPE(vm);
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    WebCore::JSReadableArrayBufferSinkController* controller = JSC::jsDynamicCast<WebCore::JSReadableArrayBufferSinkController*>(callFrame->thisValue());
    if (!controller) {
        scope.throwException(globalObject, JSC::createTypeError(globalObject, "Expected JSReadableArrayBufferSinkController"_s));
        return JSC::JSValue::encode(JSC::jsUndefined());
    }

    void* ptr = controller->wrapped();
    if (ptr == nullptr) {
        return JSC::JSValue::encode(JSC::jsUndefined());
    }

    controller->detach();
    ArrayBufferSink__close(lexicalGlobalObject, ptr);
    return JSC::JSValue::encode(JSC::jsUndefined());
}

JSC_DECLARE_HOST_FUNCTION(JSReadableArrayBufferSinkController__end);
JSC_DEFINE_HOST_FUNCTION(JSReadableArrayBufferSinkController__end, (JSC::JSGlobalObject * lexicalGlobalObject, JSC::CallFrame* callFrame))
{

    auto& vm = lexicalGlobalObject->vm();
    auto scope = DECLARE_THROW_SCOPE(vm);
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    WebCore::JSReadableArrayBufferSinkController* controller = JSC::jsDynamicCast<WebCore::JSReadableArrayBufferSinkController*>(callFrame->thisValue());
    if (!controller) {
        scope.throwException(globalObject, JSC::createTypeError(globalObject, "Expected JSReadableArrayBufferSinkController"_s));
        return JSC::JSValue::encode(JSC::jsUndefined());
    }

    void* ptr = controller->wrapped();
    if (ptr == nullptr) {
        return JSC::JSValue::encode(JSC::jsUndefined());
    }

    controller->detach();
    return ArrayBufferSink__endWithSink(ptr, lexicalGlobalObject);
}

JSC_DECLARE_HOST_FUNCTION(ArrayBufferSink__doClose);
JSC_DEFINE_HOST_FUNCTION(ArrayBufferSink__doClose, (JSC::JSGlobalObject * lexicalGlobalObject, JSC::CallFrame* callFrame))
{

    auto& vm = lexicalGlobalObject->vm();
    auto scope = DECLARE_THROW_SCOPE(vm);
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    WebCore::JSArrayBufferSink* sink = JSC::jsDynamicCast<WebCore::JSArrayBufferSink*>(callFrame->thisValue());
    if (!sink) {
        scope.throwException(globalObject, JSC::createTypeError(globalObject, "Expected ArrayBufferSink"_s));
        return JSC::JSValue::encode(JSC::jsUndefined());
    }

    void* ptr = sink->wrapped();
    if (ptr == nullptr) {
        return JSC::JSValue::encode(JSC::jsUndefined());
    }

    sink->detach();
    ArrayBufferSink__close(lexicalGlobalObject, ptr);
    return JSC::JSValue::encode(JSC::jsUndefined());
}

void JSFileSink::ref()
{
    if (!m_sinkPtr)
        return;

    m_refCount++;
    if (m_refCount == 1) {
        FileSink__updateRef(m_sinkPtr, true);
    }
}

void JSFileSink::unref()
{
    if (!m_sinkPtr)
        return;

    m_refCount = std::max(0, m_refCount - 1);
    if (!m_refCount) {
        FileSink__updateRef(m_sinkPtr, false);
    }
}

JSC_DEFINE_HOST_FUNCTION(FileSink__ref, (JSC::JSGlobalObject * lexicalGlobalObject, JSC::CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();
    auto* sink = jsDynamicCast<WebCore::JSFileSink*>(callFrame->thisValue());
    if (LIKELY(sink)) {
        sink->ref();
    }
    return JSC::JSValue::encode(JSC::jsUndefined());
}

JSC_DEFINE_HOST_FUNCTION(FileSink__unref, (JSC::JSGlobalObject * lexicalGlobalObject, JSC::CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();
    auto* sink = jsDynamicCast<WebCore::JSFileSink*>(callFrame->thisValue());
    if (LIKELY(sink)) {
        sink->unref();
    }
    return JSC::JSValue::encode(JSC::jsUndefined());
}

JSC_DEFINE_CUSTOM_GETTER(functionFileSink__getter, (JSC::JSGlobalObject * lexicalGlobalObject, JSC::EncodedJSValue thisValue, JSC::PropertyName))
{
    auto& vm = lexicalGlobalObject->vm();
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);

    return JSC::JSValue::encode(globalObject->FileSink());
}

JSC_DECLARE_HOST_FUNCTION(JSReadableFileSinkController__close);
JSC_DEFINE_HOST_FUNCTION(JSReadableFileSinkController__close, (JSC::JSGlobalObject * lexicalGlobalObject, JSC::CallFrame* callFrame))
{

    auto& vm = lexicalGlobalObject->vm();
    auto scope = DECLARE_THROW_SCOPE(vm);
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    WebCore::JSReadableFileSinkController* controller = JSC::jsDynamicCast<WebCore::JSReadableFileSinkController*>(callFrame->thisValue());
    if (!controller) {
        scope.throwException(globalObject, JSC::createTypeError(globalObject, "Expected JSReadableFileSinkController"_s));
        return JSC::JSValue::encode(JSC::jsUndefined());
    }

    void* ptr = controller->wrapped();
    if (ptr == nullptr) {
        return JSC::JSValue::encode(JSC::jsUndefined());
    }

    controller->detach();
    FileSink__close(lexicalGlobalObject, ptr);
    return JSC::JSValue::encode(JSC::jsUndefined());
}

JSC_DECLARE_HOST_FUNCTION(JSReadableFileSinkController__end);
JSC_DEFINE_HOST_FUNCTION(JSReadableFileSinkController__end, (JSC::JSGlobalObject * lexicalGlobalObject, JSC::CallFrame* callFrame))
{

    auto& vm = lexicalGlobalObject->vm();
    auto scope = DECLARE_THROW_SCOPE(vm);
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    WebCore::JSReadableFileSinkController* controller = JSC::jsDynamicCast<WebCore::JSReadableFileSinkController*>(callFrame->thisValue());
    if (!controller) {
        scope.throwException(globalObject, JSC::createTypeError(globalObject, "Expected JSReadableFileSinkController"_s));
        return JSC::JSValue::encode(JSC::jsUndefined());
    }

    void* ptr = controller->wrapped();
    if (ptr == nullptr) {
        return JSC::JSValue::encode(JSC::jsUndefined());
    }

    controller->detach();
    return FileSink__endWithSink(ptr, lexicalGlobalObject);
}

JSC_DECLARE_HOST_FUNCTION(FileSink__doClose);
JSC_DEFINE_HOST_FUNCTION(FileSink__doClose, (JSC::JSGlobalObject * lexicalGlobalObject, JSC::CallFrame* callFrame))
{

    auto& vm = lexicalGlobalObject->vm();
    auto scope = DECLARE_THROW_SCOPE(vm);
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    WebCore::JSFileSink* sink = JSC::jsDynamicCast<WebCore::JSFileSink*>(callFrame->thisValue());
    if (!sink) {
        scope.throwException(globalObject, JSC::createTypeError(globalObject, "Expected FileSink"_s));
        return JSC::JSValue::encode(JSC::jsUndefined());
    }

    void* ptr = sink->wrapped();
    if (ptr == nullptr) {
        return JSC::JSValue::encode(JSC::jsUndefined());
    }

    sink->detach();
    FileSink__close(lexicalGlobalObject, ptr);
    return JSC::JSValue::encode(JSC::jsUndefined());
}

void JSHTTPResponseSink::ref()
{
    if (!m_sinkPtr)
        return;

    m_refCount++;
    if (m_refCount == 1) {
        HTTPResponseSink__updateRef(m_sinkPtr, true);
    }
}

void JSHTTPResponseSink::unref()
{
    if (!m_sinkPtr)
        return;

    m_refCount = std::max(0, m_refCount - 1);
    if (!m_refCount) {
        HTTPResponseSink__updateRef(m_sinkPtr, false);
    }
}

JSC_DEFINE_HOST_FUNCTION(HTTPResponseSink__ref, (JSC::JSGlobalObject * lexicalGlobalObject, JSC::CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();
    auto* sink = jsDynamicCast<WebCore::JSHTTPResponseSink*>(callFrame->thisValue());
    if (LIKELY(sink)) {
        sink->ref();
    }
    return JSC::JSValue::encode(JSC::jsUndefined());
}

JSC_DEFINE_HOST_FUNCTION(HTTPResponseSink__unref, (JSC::JSGlobalObject * lexicalGlobalObject, JSC::CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();
    auto* sink = jsDynamicCast<WebCore::JSHTTPResponseSink*>(callFrame->thisValue());
    if (LIKELY(sink)) {
        sink->unref();
    }
    return JSC::JSValue::encode(JSC::jsUndefined());
}

JSC_DEFINE_CUSTOM_GETTER(functionHTTPResponseSink__getter, (JSC::JSGlobalObject * lexicalGlobalObject, JSC::EncodedJSValue thisValue, JSC::PropertyName))
{
    auto& vm = lexicalGlobalObject->vm();
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);

    return JSC::JSValue::encode(globalObject->HTTPResponseSink());
}

JSC_DECLARE_HOST_FUNCTION(JSReadableHTTPResponseSinkController__close);
JSC_DEFINE_HOST_FUNCTION(JSReadableHTTPResponseSinkController__close, (JSC::JSGlobalObject * lexicalGlobalObject, JSC::CallFrame* callFrame))
{

    auto& vm = lexicalGlobalObject->vm();
    auto scope = DECLARE_THROW_SCOPE(vm);
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    WebCore::JSReadableHTTPResponseSinkController* controller = JSC::jsDynamicCast<WebCore::JSReadableHTTPResponseSinkController*>(callFrame->thisValue());
    if (!controller) {
        scope.throwException(globalObject, JSC::createTypeError(globalObject, "Expected JSReadableHTTPResponseSinkController"_s));
        return JSC::JSValue::encode(JSC::jsUndefined());
    }

    void* ptr = controller->wrapped();
    if (ptr == nullptr) {
        return JSC::JSValue::encode(JSC::jsUndefined());
    }

    controller->detach();
    HTTPResponseSink__close(lexicalGlobalObject, ptr);
    return JSC::JSValue::encode(JSC::jsUndefined());
}

JSC_DECLARE_HOST_FUNCTION(JSReadableHTTPResponseSinkController__end);
JSC_DEFINE_HOST_FUNCTION(JSReadableHTTPResponseSinkController__end, (JSC::JSGlobalObject * lexicalGlobalObject, JSC::CallFrame* callFrame))
{

    auto& vm = lexicalGlobalObject->vm();
    auto scope = DECLARE_THROW_SCOPE(vm);
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    WebCore::JSReadableHTTPResponseSinkController* controller = JSC::jsDynamicCast<WebCore::JSReadableHTTPResponseSinkController*>(callFrame->thisValue());
    if (!controller) {
        scope.throwException(globalObject, JSC::createTypeError(globalObject, "Expected JSReadableHTTPResponseSinkController"_s));
        return JSC::JSValue::encode(JSC::jsUndefined());
    }

    void* ptr = controller->wrapped();
    if (ptr == nullptr) {
        return JSC::JSValue::encode(JSC::jsUndefined());
    }

    controller->detach();
    return HTTPResponseSink__endWithSink(ptr, lexicalGlobalObject);
}

JSC_DECLARE_HOST_FUNCTION(HTTPResponseSink__doClose);
JSC_DEFINE_HOST_FUNCTION(HTTPResponseSink__doClose, (JSC::JSGlobalObject * lexicalGlobalObject, JSC::CallFrame* callFrame))
{

    auto& vm = lexicalGlobalObject->vm();
    auto scope = DECLARE_THROW_SCOPE(vm);
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    WebCore::JSHTTPResponseSink* sink = JSC::jsDynamicCast<WebCore::JSHTTPResponseSink*>(callFrame->thisValue());
    if (!sink) {
        scope.throwException(globalObject, JSC::createTypeError(globalObject, "Expected HTTPResponseSink"_s));
        return JSC::JSValue::encode(JSC::jsUndefined());
    }

    void* ptr = sink->wrapped();
    if (ptr == nullptr) {
        return JSC::JSValue::encode(JSC::jsUndefined());
    }

    sink->detach();
    HTTPResponseSink__close(lexicalGlobalObject, ptr);
    return JSC::JSValue::encode(JSC::jsUndefined());
}

void JSHTTPSResponseSink::ref()
{
    if (!m_sinkPtr)
        return;

    m_refCount++;
    if (m_refCount == 1) {
        HTTPSResponseSink__updateRef(m_sinkPtr, true);
    }
}

void JSHTTPSResponseSink::unref()
{
    if (!m_sinkPtr)
        return;

    m_refCount = std::max(0, m_refCount - 1);
    if (!m_refCount) {
        HTTPSResponseSink__updateRef(m_sinkPtr, false);
    }
}

JSC_DEFINE_HOST_FUNCTION(HTTPSResponseSink__ref, (JSC::JSGlobalObject * lexicalGlobalObject, JSC::CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();
    auto* sink = jsDynamicCast<WebCore::JSHTTPSResponseSink*>(callFrame->thisValue());
    if (LIKELY(sink)) {
        sink->ref();
    }
    return JSC::JSValue::encode(JSC::jsUndefined());
}

JSC_DEFINE_HOST_FUNCTION(HTTPSResponseSink__unref, (JSC::JSGlobalObject * lexicalGlobalObject, JSC::CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();
    auto* sink = jsDynamicCast<WebCore::JSHTTPSResponseSink*>(callFrame->thisValue());
    if (LIKELY(sink)) {
        sink->unref();
    }
    return JSC::JSValue::encode(JSC::jsUndefined());
}

JSC_DEFINE_CUSTOM_GETTER(functionHTTPSResponseSink__getter, (JSC::JSGlobalObject * lexicalGlobalObject, JSC::EncodedJSValue thisValue, JSC::PropertyName))
{
    auto& vm = lexicalGlobalObject->vm();
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);

    return JSC::JSValue::encode(globalObject->HTTPSResponseSink());
}

JSC_DECLARE_HOST_FUNCTION(JSReadableHTTPSResponseSinkController__close);
JSC_DEFINE_HOST_FUNCTION(JSReadableHTTPSResponseSinkController__close, (JSC::JSGlobalObject * lexicalGlobalObject, JSC::CallFrame* callFrame))
{

    auto& vm = lexicalGlobalObject->vm();
    auto scope = DECLARE_THROW_SCOPE(vm);
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    WebCore::JSReadableHTTPSResponseSinkController* controller = JSC::jsDynamicCast<WebCore::JSReadableHTTPSResponseSinkController*>(callFrame->thisValue());
    if (!controller) {
        scope.throwException(globalObject, JSC::createTypeError(globalObject, "Expected JSReadableHTTPSResponseSinkController"_s));
        return JSC::JSValue::encode(JSC::jsUndefined());
    }

    void* ptr = controller->wrapped();
    if (ptr == nullptr) {
        return JSC::JSValue::encode(JSC::jsUndefined());
    }

    controller->detach();
    HTTPSResponseSink__close(lexicalGlobalObject, ptr);
    return JSC::JSValue::encode(JSC::jsUndefined());
}

JSC_DECLARE_HOST_FUNCTION(JSReadableHTTPSResponseSinkController__end);
JSC_DEFINE_HOST_FUNCTION(JSReadableHTTPSResponseSinkController__end, (JSC::JSGlobalObject * lexicalGlobalObject, JSC::CallFrame* callFrame))
{

    auto& vm = lexicalGlobalObject->vm();
    auto scope = DECLARE_THROW_SCOPE(vm);
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    WebCore::JSReadableHTTPSResponseSinkController* controller = JSC::jsDynamicCast<WebCore::JSReadableHTTPSResponseSinkController*>(callFrame->thisValue());
    if (!controller) {
        scope.throwException(globalObject, JSC::createTypeError(globalObject, "Expected JSReadableHTTPSResponseSinkController"_s));
        return JSC::JSValue::encode(JSC::jsUndefined());
    }

    void* ptr = controller->wrapped();
    if (ptr == nullptr) {
        return JSC::JSValue::encode(JSC::jsUndefined());
    }

    controller->detach();
    return HTTPSResponseSink__endWithSink(ptr, lexicalGlobalObject);
}

JSC_DECLARE_HOST_FUNCTION(HTTPSResponseSink__doClose);
JSC_DEFINE_HOST_FUNCTION(HTTPSResponseSink__doClose, (JSC::JSGlobalObject * lexicalGlobalObject, JSC::CallFrame* callFrame))
{

    auto& vm = lexicalGlobalObject->vm();
    auto scope = DECLARE_THROW_SCOPE(vm);
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    WebCore::JSHTTPSResponseSink* sink = JSC::jsDynamicCast<WebCore::JSHTTPSResponseSink*>(callFrame->thisValue());
    if (!sink) {
        scope.throwException(globalObject, JSC::createTypeError(globalObject, "Expected HTTPSResponseSink"_s));
        return JSC::JSValue::encode(JSC::jsUndefined());
    }

    void* ptr = sink->wrapped();
    if (ptr == nullptr) {
        return JSC::JSValue::encode(JSC::jsUndefined());
    }

    sink->detach();
    HTTPSResponseSink__close(lexicalGlobalObject, ptr);
    return JSC::JSValue::encode(JSC::jsUndefined());
}

#include "JSSinkLookupTable.h"

/* Source for JSArrayBufferSinkPrototypeTableValues.lut.h
@begin JSArrayBufferSinkPrototypeTable
  close      ArrayBufferSink__doClose         ReadOnly|DontDelete|Function 0
  flush      ArrayBufferSink__flush           ReadOnly|DontDelete|Function 1
  end        ArrayBufferSink__end             ReadOnly|DontDelete|Function 0
  start      ArrayBufferSink__start           ReadOnly|DontDelete|Function 1
  write      ArrayBufferSink__write           ReadOnly|DontDelete|Function 1
  ref        ArrayBufferSink__ref             ReadOnly|DontDelete|Function 0
  unref      ArrayBufferSink__unref           ReadOnly|DontDelete|Function 0
@end
*/

/* Source for JSReadableArrayBufferSinkControllerPrototypeTableValues.lut.h
@begin JSReadableArrayBufferSinkControllerPrototypeTable
  close        JSReadableArrayBufferSinkController__close      ReadOnly|DontDelete|Function 0
  flush        ArrayBufferSink__flush                          ReadOnly|DontDelete|Function 1
  end          JSReadableArrayBufferSinkController__end        ReadOnly|DontDelete|Function 0
  start        ArrayBufferSink__start                          ReadOnly|DontDelete|Function 1
  write        ArrayBufferSink__write                          ReadOnly|DontDelete|Function 1
@end
*/

/* Source for JSFileSinkPrototypeTableValues.lut.h
@begin JSFileSinkPrototypeTable
  close      FileSink__doClose         ReadOnly|DontDelete|Function 0
  flush      FileSink__flush           ReadOnly|DontDelete|Function 1
  end        FileSink__end             ReadOnly|DontDelete|Function 0
  start      FileSink__start           ReadOnly|DontDelete|Function 1
  write      FileSink__write           ReadOnly|DontDelete|Function 1
  ref        FileSink__ref             ReadOnly|DontDelete|Function 0
  unref      FileSink__unref           ReadOnly|DontDelete|Function 0
@end
*/

/* Source for JSReadableFileSinkControllerPrototypeTableValues.lut.h
@begin JSReadableFileSinkControllerPrototypeTable
  close        JSReadableFileSinkController__close      ReadOnly|DontDelete|Function 0
  flush        FileSink__flush                          ReadOnly|DontDelete|Function 1
  end          JSReadableFileSinkController__end        ReadOnly|DontDelete|Function 0
  start        FileSink__start                          ReadOnly|DontDelete|Function 1
  write        FileSink__write                          ReadOnly|DontDelete|Function 1
@end
*/

/* Source for JSHTTPResponseSinkPrototypeTableValues.lut.h
@begin JSHTTPResponseSinkPrototypeTable
  close      HTTPResponseSink__doClose         ReadOnly|DontDelete|Function 0
  flush      HTTPResponseSink__flush           ReadOnly|DontDelete|Function 1
  end        HTTPResponseSink__end             ReadOnly|DontDelete|Function 0
  start      HTTPResponseSink__start           ReadOnly|DontDelete|Function 1
  write      HTTPResponseSink__write           ReadOnly|DontDelete|Function 1
  ref        HTTPResponseSink__ref             ReadOnly|DontDelete|Function 0
  unref      HTTPResponseSink__unref           ReadOnly|DontDelete|Function 0
@end
*/

/* Source for JSReadableHTTPResponseSinkControllerPrototypeTableValues.lut.h
@begin JSReadableHTTPResponseSinkControllerPrototypeTable
  close        JSReadableHTTPResponseSinkController__close      ReadOnly|DontDelete|Function 0
  flush        HTTPResponseSink__flush                          ReadOnly|DontDelete|Function 1
  end          JSReadableHTTPResponseSinkController__end        ReadOnly|DontDelete|Function 0
  start        HTTPResponseSink__start                          ReadOnly|DontDelete|Function 1
  write        HTTPResponseSink__write                          ReadOnly|DontDelete|Function 1
@end
*/

/* Source for JSHTTPSResponseSinkPrototypeTableValues.lut.h
@begin JSHTTPSResponseSinkPrototypeTable
  close      HTTPSResponseSink__doClose         ReadOnly|DontDelete|Function 0
  flush      HTTPSResponseSink__flush           ReadOnly|DontDelete|Function 1
  end        HTTPSResponseSink__end             ReadOnly|DontDelete|Function 0
  start      HTTPSResponseSink__start           ReadOnly|DontDelete|Function 1
  write      HTTPSResponseSink__write           ReadOnly|DontDelete|Function 1
  ref        HTTPSResponseSink__ref             ReadOnly|DontDelete|Function 0
  unref      HTTPSResponseSink__unref           ReadOnly|DontDelete|Function 0
@end
*/

/* Source for JSReadableHTTPSResponseSinkControllerPrototypeTableValues.lut.h
@begin JSReadableHTTPSResponseSinkControllerPrototypeTable
  close        JSReadableHTTPSResponseSinkController__close      ReadOnly|DontDelete|Function 0
  flush        HTTPSResponseSink__flush                          ReadOnly|DontDelete|Function 1
  end          JSReadableHTTPSResponseSinkController__end        ReadOnly|DontDelete|Function 0
  start        HTTPSResponseSink__start                          ReadOnly|DontDelete|Function 1
  write        HTTPSResponseSink__write                          ReadOnly|DontDelete|Function 1
@end
*/

#pragma mark - ArrayBufferSink

class JSArrayBufferSinkPrototype final : public JSC::JSNonFinalObject {
public:
    using Base = JSC::JSNonFinalObject;

    static JSArrayBufferSinkPrototype* create(JSC::VM& vm, JSGlobalObject* globalObject, JSC::Structure* structure)
    {
        JSArrayBufferSinkPrototype* ptr = new (NotNull, JSC::allocateCell<JSArrayBufferSinkPrototype>(vm)) JSArrayBufferSinkPrototype(vm, globalObject, structure);
        ptr->finishCreation(vm, globalObject);
        return ptr;
    }

    DECLARE_INFO;
    template<typename CellType, JSC::SubspaceAccess>
    static JSC::GCClient::IsoSubspace* subspaceFor(JSC::VM& vm)
    {
        return &vm.plainObjectSpace();
    }
    static JSC::Structure* createStructure(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::JSValue prototype)
    {
        return JSC::Structure::create(vm, globalObject, prototype, JSC::TypeInfo(JSC::ObjectType, StructureFlags), info());
    }

private:
    JSArrayBufferSinkPrototype(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure)
        : Base(vm, structure)
    {
    }

    void finishCreation(JSC::VM&, JSC::JSGlobalObject*);
};
STATIC_ASSERT_ISO_SUBSPACE_SHARABLE(JSArrayBufferSinkPrototype, JSArrayBufferSinkPrototype::Base);

class JSReadableArrayBufferSinkControllerPrototype final : public JSC::JSNonFinalObject {
public:
    using Base = JSC::JSNonFinalObject;

    static JSReadableArrayBufferSinkControllerPrototype* create(JSC::VM& vm, JSGlobalObject* globalObject, JSC::Structure* structure)
    {
        JSReadableArrayBufferSinkControllerPrototype* ptr = new (NotNull, JSC::allocateCell<JSReadableArrayBufferSinkControllerPrototype>(vm)) JSReadableArrayBufferSinkControllerPrototype(vm, globalObject, structure);
        ptr->finishCreation(vm, globalObject);
        return ptr;
    }

    DECLARE_INFO;
    template<typename CellType, JSC::SubspaceAccess>
    static JSC::GCClient::IsoSubspace* subspaceFor(JSC::VM& vm)
    {
        return &vm.plainObjectSpace();
    }
    static JSC::Structure* createStructure(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::JSValue prototype)
    {
        return JSC::Structure::create(vm, globalObject, prototype, JSC::TypeInfo(JSC::ObjectType, StructureFlags), info());
    }

private:
    JSReadableArrayBufferSinkControllerPrototype(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure)
        : Base(vm, structure)
    {
    }

    void finishCreation(JSC::VM&, JSC::JSGlobalObject*);
};
STATIC_ASSERT_ISO_SUBSPACE_SHARABLE(JSReadableArrayBufferSinkControllerPrototype, JSReadableArrayBufferSinkControllerPrototype::Base);

const ClassInfo JSArrayBufferSinkPrototype::s_info = { "ArrayBufferSink"_s, &Base::s_info, &JSArrayBufferSinkPrototypeTable, nullptr, CREATE_METHOD_TABLE(JSArrayBufferSinkPrototype) };
const ClassInfo JSArrayBufferSink::s_info = { "ArrayBufferSink"_s, &Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSArrayBufferSink) };
const ClassInfo JSArrayBufferSinkConstructor::s_info = { "ArrayBufferSink"_s, &Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSArrayBufferSinkConstructor) };

const ClassInfo JSReadableArrayBufferSinkControllerPrototype::s_info = { "ReadableArrayBufferSinkController"_s, &Base::s_info, &JSReadableArrayBufferSinkControllerPrototypeTable, nullptr, CREATE_METHOD_TABLE(JSReadableArrayBufferSinkControllerPrototype) };
const ClassInfo JSReadableArrayBufferSinkController::s_info = { "ReadableArrayBufferSinkController"_s, &Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSReadableArrayBufferSinkController) };

JSArrayBufferSink::~JSArrayBufferSink()
{
    if (m_sinkPtr) {
        ArrayBufferSink__finalize(m_sinkPtr);
    }
}

JSReadableArrayBufferSinkController::~JSReadableArrayBufferSinkController()
{
    if (m_sinkPtr) {
        ArrayBufferSink__finalize(m_sinkPtr);
    }
}

JSObject* JSArrayBufferSink::createPrototype(VM& vm, JSDOMGlobalObject& globalObject)
{
    return JSArrayBufferSinkPrototype::create(vm, &globalObject, JSArrayBufferSinkPrototype::createStructure(vm, &globalObject, globalObject.objectPrototype()));
}

JSObject* JSReadableArrayBufferSinkController::createPrototype(VM& vm, JSDOMGlobalObject& globalObject)
{
    return JSReadableArrayBufferSinkControllerPrototype::create(vm, &globalObject, JSReadableArrayBufferSinkControllerPrototype::createStructure(vm, &globalObject, globalObject.objectPrototype()));
}

void JSReadableArrayBufferSinkController::detach()
{
    m_sinkPtr = nullptr;
    m_onPull.clear();

    auto readableStream = m_weakReadableStream.get();
    auto onClose = m_onClose.get();
    m_onClose.clear();

    if (readableStream && onClose) {
        JSC::JSGlobalObject* globalObject = this->globalObject();
        auto callData = JSC::getCallData(onClose);
        JSC::MarkedArgumentBuffer arguments;
        arguments.append(readableStream);
        arguments.append(jsUndefined());
        JSC::call(globalObject, onClose, callData, JSC::jsUndefined(), arguments);
    }

    m_weakReadableStream.clear();
}

JSArrayBufferSinkConstructor* JSArrayBufferSinkConstructor::create(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure, JSObject* prototype)
{
    JSArrayBufferSinkConstructor* ptr = new (NotNull, JSC::allocateCell<JSArrayBufferSinkConstructor>(vm)) JSArrayBufferSinkConstructor(vm, structure, ArrayBufferSink__construct);
    ptr->finishCreation(vm, globalObject, prototype);
    return ptr;
}

JSArrayBufferSink* JSArrayBufferSink::create(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure, void* sinkPtr)
{
    JSArrayBufferSink* ptr = new (NotNull, JSC::allocateCell<JSArrayBufferSink>(vm)) JSArrayBufferSink(vm, structure, sinkPtr);
    ptr->finishCreation(vm);
    return ptr;
}

JSReadableArrayBufferSinkController* JSReadableArrayBufferSinkController::create(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure, void* sinkPtr)
{
    JSReadableArrayBufferSinkController* ptr = new (NotNull, JSC::allocateCell<JSReadableArrayBufferSinkController>(vm)) JSReadableArrayBufferSinkController(vm, structure, sinkPtr);
    ptr->finishCreation(vm);
    return ptr;
}

void JSArrayBufferSinkConstructor::finishCreation(VM& vm, JSC::JSGlobalObject* globalObject, JSObject* prototype)
{
    Base::finishCreation(vm);
    ASSERT(inherits(info()));
    initializeProperties(vm, globalObject, prototype);
}

JSC::EncodedJSValue JSC_HOST_CALL_ATTRIBUTES JSArrayBufferSinkConstructor::construct(JSC::JSGlobalObject* globalObject, JSC::CallFrame* callFrame)
{
    return ArrayBufferSink__construct(globalObject, callFrame);
}

void JSArrayBufferSinkConstructor::initializeProperties(VM& vm, JSC::JSGlobalObject* globalObject, JSObject* prototype)
{
    putDirect(vm, vm.propertyNames->length, jsNumber(0), JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::DontEnum);
    JSString* nameString = jsNontrivialString(vm, "ArrayBufferSink"_s);
    m_originalName.set(vm, this, nameString);
    putDirect(vm, vm.propertyNames->name, nameString, JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::DontEnum);
}

void JSArrayBufferSinkPrototype::finishCreation(JSC::VM& vm, JSC::JSGlobalObject* globalObject)
{
    Base::finishCreation(vm);
    reifyStaticProperties(vm, JSArrayBufferSink::info(), JSArrayBufferSinkPrototypeTableValues, *this);
    putDirect(vm, JSC::Identifier::fromString(vm, "sinkId"_s), JSC::jsNumber(JSArrayBufferSink::Sink), JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::DontEnum);
    JSC_TO_STRING_TAG_WITHOUT_TRANSITION();
}

void JSReadableArrayBufferSinkControllerPrototype::finishCreation(JSC::VM& vm, JSC::JSGlobalObject* globalObject)
{
    Base::finishCreation(vm);
    reifyStaticProperties(vm, JSReadableArrayBufferSinkController::info(), JSReadableArrayBufferSinkControllerPrototypeTableValues, *this);
    putDirect(vm, JSC::Identifier::fromString(vm, "sinkId"_s), JSC::jsNumber(JSArrayBufferSink::Sink), JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::DontEnum);
    JSC_TO_STRING_TAG_WITHOUT_TRANSITION();
}

void JSArrayBufferSink::finishCreation(VM& vm)
{
    Base::finishCreation(vm);
    ASSERT(inherits(info()));
}

void JSReadableArrayBufferSinkController::finishCreation(VM& vm)
{
    Base::finishCreation(vm);
    ASSERT(inherits(info()));
}

void JSArrayBufferSink::analyzeHeap(JSCell* cell, HeapAnalyzer& analyzer)
{
    auto* thisObject = jsCast<JSArrayBufferSink*>(cell);
    if (void* wrapped = thisObject->wrapped()) {
        analyzer.setWrappedObjectForCell(cell, wrapped);
        // if (thisObject->scriptExecutionContext())
        //     analyzer.setLabelForCell(cell, "url " + thisObject->scriptExecutionContext()->url().string());
    }
    Base::analyzeHeap(cell, analyzer);
}

void JSReadableArrayBufferSinkController::analyzeHeap(JSCell* cell, HeapAnalyzer& analyzer)
{
    auto* thisObject = jsCast<JSReadableArrayBufferSinkController*>(cell);
    if (void* wrapped = thisObject->wrapped()) {
        analyzer.setWrappedObjectForCell(cell, wrapped);
        // if (thisObject->scriptExecutionContext())
        //     analyzer.setLabelForCell(cell, "url " + thisObject->scriptExecutionContext()->url().string());
    }
    Base::analyzeHeap(cell, analyzer);
}

template<typename Visitor>
void JSReadableArrayBufferSinkController::visitChildrenImpl(JSCell* cell, Visitor& visitor)
{
    JSReadableArrayBufferSinkController* thisObject = jsCast<JSReadableArrayBufferSinkController*>(cell);
    ASSERT_GC_OBJECT_INHERITS(thisObject, info());
    Base::visitChildren(thisObject, visitor);
    visitor.append(thisObject->m_onPull);
    visitor.append(thisObject->m_onClose);
    void* ptr = thisObject->m_sinkPtr;
    if (ptr)
        visitor.addOpaqueRoot(ptr);
}

DEFINE_VISIT_CHILDREN(JSReadableArrayBufferSinkController);

template<typename Visitor>
void JSArrayBufferSink::visitChildrenImpl(JSCell* cell, Visitor& visitor)
{
    JSArrayBufferSink* thisObject = jsCast<JSArrayBufferSink*>(cell);
    ASSERT_GC_OBJECT_INHERITS(thisObject, info());
    Base::visitChildren(thisObject, visitor);
    void* ptr = thisObject->m_sinkPtr;
    if (ptr)
        visitor.addOpaqueRoot(ptr);
}

DEFINE_VISIT_CHILDREN(JSArrayBufferSink);

void JSReadableArrayBufferSinkController::start(JSC::JSGlobalObject* globalObject, JSC::JSValue readableStream, JSC::JSValue onPull, JSC::JSValue onClose)
{
    this->m_weakReadableStream = JSC::Weak<JSC::JSObject>(readableStream.getObject());
    this->m_onPull.set(globalObject->vm(), this, onPull);
    this->m_onClose.set(globalObject->vm(), this, onClose);
}

void JSArrayBufferSink::destroy(JSCell* cell)
{
    static_cast<JSArrayBufferSink*>(cell)->JSArrayBufferSink::~JSArrayBufferSink();
}

void JSReadableArrayBufferSinkController::destroy(JSCell* cell)
{
    static_cast<JSReadableArrayBufferSinkController*>(cell)->JSReadableArrayBufferSinkController::~JSReadableArrayBufferSinkController();
}

#pragma mark - FileSink

class JSFileSinkPrototype final : public JSC::JSNonFinalObject {
public:
    using Base = JSC::JSNonFinalObject;

    static JSFileSinkPrototype* create(JSC::VM& vm, JSGlobalObject* globalObject, JSC::Structure* structure)
    {
        JSFileSinkPrototype* ptr = new (NotNull, JSC::allocateCell<JSFileSinkPrototype>(vm)) JSFileSinkPrototype(vm, globalObject, structure);
        ptr->finishCreation(vm, globalObject);
        return ptr;
    }

    DECLARE_INFO;
    template<typename CellType, JSC::SubspaceAccess>
    static JSC::GCClient::IsoSubspace* subspaceFor(JSC::VM& vm)
    {
        return &vm.plainObjectSpace();
    }
    static JSC::Structure* createStructure(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::JSValue prototype)
    {
        return JSC::Structure::create(vm, globalObject, prototype, JSC::TypeInfo(JSC::ObjectType, StructureFlags), info());
    }

private:
    JSFileSinkPrototype(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure)
        : Base(vm, structure)
    {
    }

    void finishCreation(JSC::VM&, JSC::JSGlobalObject*);
};
STATIC_ASSERT_ISO_SUBSPACE_SHARABLE(JSFileSinkPrototype, JSFileSinkPrototype::Base);

class JSReadableFileSinkControllerPrototype final : public JSC::JSNonFinalObject {
public:
    using Base = JSC::JSNonFinalObject;

    static JSReadableFileSinkControllerPrototype* create(JSC::VM& vm, JSGlobalObject* globalObject, JSC::Structure* structure)
    {
        JSReadableFileSinkControllerPrototype* ptr = new (NotNull, JSC::allocateCell<JSReadableFileSinkControllerPrototype>(vm)) JSReadableFileSinkControllerPrototype(vm, globalObject, structure);
        ptr->finishCreation(vm, globalObject);
        return ptr;
    }

    DECLARE_INFO;
    template<typename CellType, JSC::SubspaceAccess>
    static JSC::GCClient::IsoSubspace* subspaceFor(JSC::VM& vm)
    {
        return &vm.plainObjectSpace();
    }
    static JSC::Structure* createStructure(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::JSValue prototype)
    {
        return JSC::Structure::create(vm, globalObject, prototype, JSC::TypeInfo(JSC::ObjectType, StructureFlags), info());
    }

private:
    JSReadableFileSinkControllerPrototype(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure)
        : Base(vm, structure)
    {
    }

    void finishCreation(JSC::VM&, JSC::JSGlobalObject*);
};
STATIC_ASSERT_ISO_SUBSPACE_SHARABLE(JSReadableFileSinkControllerPrototype, JSReadableFileSinkControllerPrototype::Base);

const ClassInfo JSFileSinkPrototype::s_info = { "FileSink"_s, &Base::s_info, &JSFileSinkPrototypeTable, nullptr, CREATE_METHOD_TABLE(JSFileSinkPrototype) };
const ClassInfo JSFileSink::s_info = { "FileSink"_s, &Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSFileSink) };
const ClassInfo JSFileSinkConstructor::s_info = { "FileSink"_s, &Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSFileSinkConstructor) };

const ClassInfo JSReadableFileSinkControllerPrototype::s_info = { "ReadableFileSinkController"_s, &Base::s_info, &JSReadableFileSinkControllerPrototypeTable, nullptr, CREATE_METHOD_TABLE(JSReadableFileSinkControllerPrototype) };
const ClassInfo JSReadableFileSinkController::s_info = { "ReadableFileSinkController"_s, &Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSReadableFileSinkController) };

JSFileSink::~JSFileSink()
{
    if (m_sinkPtr) {
        FileSink__finalize(m_sinkPtr);
    }
}

JSReadableFileSinkController::~JSReadableFileSinkController()
{
    if (m_sinkPtr) {
        FileSink__finalize(m_sinkPtr);
    }
}

JSObject* JSFileSink::createPrototype(VM& vm, JSDOMGlobalObject& globalObject)
{
    return JSFileSinkPrototype::create(vm, &globalObject, JSFileSinkPrototype::createStructure(vm, &globalObject, globalObject.objectPrototype()));
}

JSObject* JSReadableFileSinkController::createPrototype(VM& vm, JSDOMGlobalObject& globalObject)
{
    return JSReadableFileSinkControllerPrototype::create(vm, &globalObject, JSReadableFileSinkControllerPrototype::createStructure(vm, &globalObject, globalObject.objectPrototype()));
}

void JSReadableFileSinkController::detach()
{
    m_sinkPtr = nullptr;
    m_onPull.clear();

    auto readableStream = m_weakReadableStream.get();
    auto onClose = m_onClose.get();
    m_onClose.clear();

    if (readableStream && onClose) {
        JSC::JSGlobalObject* globalObject = this->globalObject();
        auto callData = JSC::getCallData(onClose);
        JSC::MarkedArgumentBuffer arguments;
        arguments.append(readableStream);
        arguments.append(jsUndefined());
        JSC::call(globalObject, onClose, callData, JSC::jsUndefined(), arguments);
    }

    m_weakReadableStream.clear();
}

JSFileSinkConstructor* JSFileSinkConstructor::create(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure, JSObject* prototype)
{
    JSFileSinkConstructor* ptr = new (NotNull, JSC::allocateCell<JSFileSinkConstructor>(vm)) JSFileSinkConstructor(vm, structure, FileSink__construct);
    ptr->finishCreation(vm, globalObject, prototype);
    return ptr;
}

JSFileSink* JSFileSink::create(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure, void* sinkPtr)
{
    JSFileSink* ptr = new (NotNull, JSC::allocateCell<JSFileSink>(vm)) JSFileSink(vm, structure, sinkPtr);
    ptr->finishCreation(vm);
    return ptr;
}

JSReadableFileSinkController* JSReadableFileSinkController::create(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure, void* sinkPtr)
{
    JSReadableFileSinkController* ptr = new (NotNull, JSC::allocateCell<JSReadableFileSinkController>(vm)) JSReadableFileSinkController(vm, structure, sinkPtr);
    ptr->finishCreation(vm);
    return ptr;
}

void JSFileSinkConstructor::finishCreation(VM& vm, JSC::JSGlobalObject* globalObject, JSObject* prototype)
{
    Base::finishCreation(vm);
    ASSERT(inherits(info()));
    initializeProperties(vm, globalObject, prototype);
}

JSC::EncodedJSValue JSC_HOST_CALL_ATTRIBUTES JSFileSinkConstructor::construct(JSC::JSGlobalObject* globalObject, JSC::CallFrame* callFrame)
{
    return FileSink__construct(globalObject, callFrame);
}

void JSFileSinkConstructor::initializeProperties(VM& vm, JSC::JSGlobalObject* globalObject, JSObject* prototype)
{
    putDirect(vm, vm.propertyNames->length, jsNumber(0), JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::DontEnum);
    JSString* nameString = jsNontrivialString(vm, "FileSink"_s);
    m_originalName.set(vm, this, nameString);
    putDirect(vm, vm.propertyNames->name, nameString, JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::DontEnum);
}

void JSFileSinkPrototype::finishCreation(JSC::VM& vm, JSC::JSGlobalObject* globalObject)
{
    Base::finishCreation(vm);
    reifyStaticProperties(vm, JSFileSink::info(), JSFileSinkPrototypeTableValues, *this);
    putDirect(vm, JSC::Identifier::fromString(vm, "sinkId"_s), JSC::jsNumber(JSFileSink::Sink), JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::DontEnum);
    JSC_TO_STRING_TAG_WITHOUT_TRANSITION();
}

void JSReadableFileSinkControllerPrototype::finishCreation(JSC::VM& vm, JSC::JSGlobalObject* globalObject)
{
    Base::finishCreation(vm);
    reifyStaticProperties(vm, JSReadableFileSinkController::info(), JSReadableFileSinkControllerPrototypeTableValues, *this);
    putDirect(vm, JSC::Identifier::fromString(vm, "sinkId"_s), JSC::jsNumber(JSFileSink::Sink), JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::DontEnum);
    JSC_TO_STRING_TAG_WITHOUT_TRANSITION();
}

void JSFileSink::finishCreation(VM& vm)
{
    Base::finishCreation(vm);
    ASSERT(inherits(info()));
}

void JSReadableFileSinkController::finishCreation(VM& vm)
{
    Base::finishCreation(vm);
    ASSERT(inherits(info()));
}

void JSFileSink::analyzeHeap(JSCell* cell, HeapAnalyzer& analyzer)
{
    auto* thisObject = jsCast<JSFileSink*>(cell);
    if (void* wrapped = thisObject->wrapped()) {
        analyzer.setWrappedObjectForCell(cell, wrapped);
        // if (thisObject->scriptExecutionContext())
        //     analyzer.setLabelForCell(cell, "url " + thisObject->scriptExecutionContext()->url().string());
    }
    Base::analyzeHeap(cell, analyzer);
}

void JSReadableFileSinkController::analyzeHeap(JSCell* cell, HeapAnalyzer& analyzer)
{
    auto* thisObject = jsCast<JSReadableFileSinkController*>(cell);
    if (void* wrapped = thisObject->wrapped()) {
        analyzer.setWrappedObjectForCell(cell, wrapped);
        // if (thisObject->scriptExecutionContext())
        //     analyzer.setLabelForCell(cell, "url " + thisObject->scriptExecutionContext()->url().string());
    }
    Base::analyzeHeap(cell, analyzer);
}

template<typename Visitor>
void JSReadableFileSinkController::visitChildrenImpl(JSCell* cell, Visitor& visitor)
{
    JSReadableFileSinkController* thisObject = jsCast<JSReadableFileSinkController*>(cell);
    ASSERT_GC_OBJECT_INHERITS(thisObject, info());
    Base::visitChildren(thisObject, visitor);
    visitor.append(thisObject->m_onPull);
    visitor.append(thisObject->m_onClose);
    void* ptr = thisObject->m_sinkPtr;
    if (ptr)
        visitor.addOpaqueRoot(ptr);
}

DEFINE_VISIT_CHILDREN(JSReadableFileSinkController);

template<typename Visitor>
void JSFileSink::visitChildrenImpl(JSCell* cell, Visitor& visitor)
{
    JSFileSink* thisObject = jsCast<JSFileSink*>(cell);
    ASSERT_GC_OBJECT_INHERITS(thisObject, info());
    Base::visitChildren(thisObject, visitor);
    void* ptr = thisObject->m_sinkPtr;
    if (ptr)
        visitor.addOpaqueRoot(ptr);
}

DEFINE_VISIT_CHILDREN(JSFileSink);

void JSReadableFileSinkController::start(JSC::JSGlobalObject* globalObject, JSC::JSValue readableStream, JSC::JSValue onPull, JSC::JSValue onClose)
{
    this->m_weakReadableStream = JSC::Weak<JSC::JSObject>(readableStream.getObject());
    this->m_onPull.set(globalObject->vm(), this, onPull);
    this->m_onClose.set(globalObject->vm(), this, onClose);
}

void JSFileSink::destroy(JSCell* cell)
{
    static_cast<JSFileSink*>(cell)->JSFileSink::~JSFileSink();
}

void JSReadableFileSinkController::destroy(JSCell* cell)
{
    static_cast<JSReadableFileSinkController*>(cell)->JSReadableFileSinkController::~JSReadableFileSinkController();
}

#pragma mark - HTTPResponseSink

class JSHTTPResponseSinkPrototype final : public JSC::JSNonFinalObject {
public:
    using Base = JSC::JSNonFinalObject;

    static JSHTTPResponseSinkPrototype* create(JSC::VM& vm, JSGlobalObject* globalObject, JSC::Structure* structure)
    {
        JSHTTPResponseSinkPrototype* ptr = new (NotNull, JSC::allocateCell<JSHTTPResponseSinkPrototype>(vm)) JSHTTPResponseSinkPrototype(vm, globalObject, structure);
        ptr->finishCreation(vm, globalObject);
        return ptr;
    }

    DECLARE_INFO;
    template<typename CellType, JSC::SubspaceAccess>
    static JSC::GCClient::IsoSubspace* subspaceFor(JSC::VM& vm)
    {
        return &vm.plainObjectSpace();
    }
    static JSC::Structure* createStructure(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::JSValue prototype)
    {
        return JSC::Structure::create(vm, globalObject, prototype, JSC::TypeInfo(JSC::ObjectType, StructureFlags), info());
    }

private:
    JSHTTPResponseSinkPrototype(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure)
        : Base(vm, structure)
    {
    }

    void finishCreation(JSC::VM&, JSC::JSGlobalObject*);
};
STATIC_ASSERT_ISO_SUBSPACE_SHARABLE(JSHTTPResponseSinkPrototype, JSHTTPResponseSinkPrototype::Base);

class JSReadableHTTPResponseSinkControllerPrototype final : public JSC::JSNonFinalObject {
public:
    using Base = JSC::JSNonFinalObject;

    static JSReadableHTTPResponseSinkControllerPrototype* create(JSC::VM& vm, JSGlobalObject* globalObject, JSC::Structure* structure)
    {
        JSReadableHTTPResponseSinkControllerPrototype* ptr = new (NotNull, JSC::allocateCell<JSReadableHTTPResponseSinkControllerPrototype>(vm)) JSReadableHTTPResponseSinkControllerPrototype(vm, globalObject, structure);
        ptr->finishCreation(vm, globalObject);
        return ptr;
    }

    DECLARE_INFO;
    template<typename CellType, JSC::SubspaceAccess>
    static JSC::GCClient::IsoSubspace* subspaceFor(JSC::VM& vm)
    {
        return &vm.plainObjectSpace();
    }
    static JSC::Structure* createStructure(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::JSValue prototype)
    {
        return JSC::Structure::create(vm, globalObject, prototype, JSC::TypeInfo(JSC::ObjectType, StructureFlags), info());
    }

private:
    JSReadableHTTPResponseSinkControllerPrototype(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure)
        : Base(vm, structure)
    {
    }

    void finishCreation(JSC::VM&, JSC::JSGlobalObject*);
};
STATIC_ASSERT_ISO_SUBSPACE_SHARABLE(JSReadableHTTPResponseSinkControllerPrototype, JSReadableHTTPResponseSinkControllerPrototype::Base);

const ClassInfo JSHTTPResponseSinkPrototype::s_info = { "HTTPResponseSink"_s, &Base::s_info, &JSHTTPResponseSinkPrototypeTable, nullptr, CREATE_METHOD_TABLE(JSHTTPResponseSinkPrototype) };
const ClassInfo JSHTTPResponseSink::s_info = { "HTTPResponseSink"_s, &Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSHTTPResponseSink) };
const ClassInfo JSHTTPResponseSinkConstructor::s_info = { "HTTPResponseSink"_s, &Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSHTTPResponseSinkConstructor) };

const ClassInfo JSReadableHTTPResponseSinkControllerPrototype::s_info = { "ReadableHTTPResponseSinkController"_s, &Base::s_info, &JSReadableHTTPResponseSinkControllerPrototypeTable, nullptr, CREATE_METHOD_TABLE(JSReadableHTTPResponseSinkControllerPrototype) };
const ClassInfo JSReadableHTTPResponseSinkController::s_info = { "ReadableHTTPResponseSinkController"_s, &Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSReadableHTTPResponseSinkController) };

JSHTTPResponseSink::~JSHTTPResponseSink()
{
    if (m_sinkPtr) {
        HTTPResponseSink__finalize(m_sinkPtr);
    }
}

JSReadableHTTPResponseSinkController::~JSReadableHTTPResponseSinkController()
{
    if (m_sinkPtr) {
        HTTPResponseSink__finalize(m_sinkPtr);
    }
}

JSObject* JSHTTPResponseSink::createPrototype(VM& vm, JSDOMGlobalObject& globalObject)
{
    return JSHTTPResponseSinkPrototype::create(vm, &globalObject, JSHTTPResponseSinkPrototype::createStructure(vm, &globalObject, globalObject.objectPrototype()));
}

JSObject* JSReadableHTTPResponseSinkController::createPrototype(VM& vm, JSDOMGlobalObject& globalObject)
{
    return JSReadableHTTPResponseSinkControllerPrototype::create(vm, &globalObject, JSReadableHTTPResponseSinkControllerPrototype::createStructure(vm, &globalObject, globalObject.objectPrototype()));
}

void JSReadableHTTPResponseSinkController::detach()
{
    m_sinkPtr = nullptr;
    m_onPull.clear();

    auto readableStream = m_weakReadableStream.get();
    auto onClose = m_onClose.get();
    m_onClose.clear();

    if (readableStream && onClose) {
        JSC::JSGlobalObject* globalObject = this->globalObject();
        auto callData = JSC::getCallData(onClose);
        JSC::MarkedArgumentBuffer arguments;
        arguments.append(readableStream);
        arguments.append(jsUndefined());
        JSC::call(globalObject, onClose, callData, JSC::jsUndefined(), arguments);
    }

    m_weakReadableStream.clear();
}

JSHTTPResponseSinkConstructor* JSHTTPResponseSinkConstructor::create(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure, JSObject* prototype)
{
    JSHTTPResponseSinkConstructor* ptr = new (NotNull, JSC::allocateCell<JSHTTPResponseSinkConstructor>(vm)) JSHTTPResponseSinkConstructor(vm, structure, HTTPResponseSink__construct);
    ptr->finishCreation(vm, globalObject, prototype);
    return ptr;
}

JSHTTPResponseSink* JSHTTPResponseSink::create(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure, void* sinkPtr)
{
    JSHTTPResponseSink* ptr = new (NotNull, JSC::allocateCell<JSHTTPResponseSink>(vm)) JSHTTPResponseSink(vm, structure, sinkPtr);
    ptr->finishCreation(vm);
    return ptr;
}

JSReadableHTTPResponseSinkController* JSReadableHTTPResponseSinkController::create(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure, void* sinkPtr)
{
    JSReadableHTTPResponseSinkController* ptr = new (NotNull, JSC::allocateCell<JSReadableHTTPResponseSinkController>(vm)) JSReadableHTTPResponseSinkController(vm, structure, sinkPtr);
    ptr->finishCreation(vm);
    return ptr;
}

void JSHTTPResponseSinkConstructor::finishCreation(VM& vm, JSC::JSGlobalObject* globalObject, JSObject* prototype)
{
    Base::finishCreation(vm);
    ASSERT(inherits(info()));
    initializeProperties(vm, globalObject, prototype);
}

JSC::EncodedJSValue JSC_HOST_CALL_ATTRIBUTES JSHTTPResponseSinkConstructor::construct(JSC::JSGlobalObject* globalObject, JSC::CallFrame* callFrame)
{
    return HTTPResponseSink__construct(globalObject, callFrame);
}

void JSHTTPResponseSinkConstructor::initializeProperties(VM& vm, JSC::JSGlobalObject* globalObject, JSObject* prototype)
{
    putDirect(vm, vm.propertyNames->length, jsNumber(0), JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::DontEnum);
    JSString* nameString = jsNontrivialString(vm, "HTTPResponseSink"_s);
    m_originalName.set(vm, this, nameString);
    putDirect(vm, vm.propertyNames->name, nameString, JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::DontEnum);
}

void JSHTTPResponseSinkPrototype::finishCreation(JSC::VM& vm, JSC::JSGlobalObject* globalObject)
{
    Base::finishCreation(vm);
    reifyStaticProperties(vm, JSHTTPResponseSink::info(), JSHTTPResponseSinkPrototypeTableValues, *this);
    putDirect(vm, JSC::Identifier::fromString(vm, "sinkId"_s), JSC::jsNumber(JSHTTPResponseSink::Sink), JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::DontEnum);
    JSC_TO_STRING_TAG_WITHOUT_TRANSITION();
}

void JSReadableHTTPResponseSinkControllerPrototype::finishCreation(JSC::VM& vm, JSC::JSGlobalObject* globalObject)
{
    Base::finishCreation(vm);
    reifyStaticProperties(vm, JSReadableHTTPResponseSinkController::info(), JSReadableHTTPResponseSinkControllerPrototypeTableValues, *this);
    putDirect(vm, JSC::Identifier::fromString(vm, "sinkId"_s), JSC::jsNumber(JSHTTPResponseSink::Sink), JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::DontEnum);
    JSC_TO_STRING_TAG_WITHOUT_TRANSITION();
}

void JSHTTPResponseSink::finishCreation(VM& vm)
{
    Base::finishCreation(vm);
    ASSERT(inherits(info()));
}

void JSReadableHTTPResponseSinkController::finishCreation(VM& vm)
{
    Base::finishCreation(vm);
    ASSERT(inherits(info()));
}

void JSHTTPResponseSink::analyzeHeap(JSCell* cell, HeapAnalyzer& analyzer)
{
    auto* thisObject = jsCast<JSHTTPResponseSink*>(cell);
    if (void* wrapped = thisObject->wrapped()) {
        analyzer.setWrappedObjectForCell(cell, wrapped);
        // if (thisObject->scriptExecutionContext())
        //     analyzer.setLabelForCell(cell, "url " + thisObject->scriptExecutionContext()->url().string());
    }
    Base::analyzeHeap(cell, analyzer);
}

void JSReadableHTTPResponseSinkController::analyzeHeap(JSCell* cell, HeapAnalyzer& analyzer)
{
    auto* thisObject = jsCast<JSReadableHTTPResponseSinkController*>(cell);
    if (void* wrapped = thisObject->wrapped()) {
        analyzer.setWrappedObjectForCell(cell, wrapped);
        // if (thisObject->scriptExecutionContext())
        //     analyzer.setLabelForCell(cell, "url " + thisObject->scriptExecutionContext()->url().string());
    }
    Base::analyzeHeap(cell, analyzer);
}

template<typename Visitor>
void JSReadableHTTPResponseSinkController::visitChildrenImpl(JSCell* cell, Visitor& visitor)
{
    JSReadableHTTPResponseSinkController* thisObject = jsCast<JSReadableHTTPResponseSinkController*>(cell);
    ASSERT_GC_OBJECT_INHERITS(thisObject, info());
    Base::visitChildren(thisObject, visitor);
    visitor.append(thisObject->m_onPull);
    visitor.append(thisObject->m_onClose);
    void* ptr = thisObject->m_sinkPtr;
    if (ptr)
        visitor.addOpaqueRoot(ptr);
}

DEFINE_VISIT_CHILDREN(JSReadableHTTPResponseSinkController);

template<typename Visitor>
void JSHTTPResponseSink::visitChildrenImpl(JSCell* cell, Visitor& visitor)
{
    JSHTTPResponseSink* thisObject = jsCast<JSHTTPResponseSink*>(cell);
    ASSERT_GC_OBJECT_INHERITS(thisObject, info());
    Base::visitChildren(thisObject, visitor);
    void* ptr = thisObject->m_sinkPtr;
    if (ptr)
        visitor.addOpaqueRoot(ptr);
}

DEFINE_VISIT_CHILDREN(JSHTTPResponseSink);

void JSReadableHTTPResponseSinkController::start(JSC::JSGlobalObject* globalObject, JSC::JSValue readableStream, JSC::JSValue onPull, JSC::JSValue onClose)
{
    this->m_weakReadableStream = JSC::Weak<JSC::JSObject>(readableStream.getObject());
    this->m_onPull.set(globalObject->vm(), this, onPull);
    this->m_onClose.set(globalObject->vm(), this, onClose);
}

void JSHTTPResponseSink::destroy(JSCell* cell)
{
    static_cast<JSHTTPResponseSink*>(cell)->JSHTTPResponseSink::~JSHTTPResponseSink();
}

void JSReadableHTTPResponseSinkController::destroy(JSCell* cell)
{
    static_cast<JSReadableHTTPResponseSinkController*>(cell)->JSReadableHTTPResponseSinkController::~JSReadableHTTPResponseSinkController();
}

#pragma mark - HTTPSResponseSink

class JSHTTPSResponseSinkPrototype final : public JSC::JSNonFinalObject {
public:
    using Base = JSC::JSNonFinalObject;

    static JSHTTPSResponseSinkPrototype* create(JSC::VM& vm, JSGlobalObject* globalObject, JSC::Structure* structure)
    {
        JSHTTPSResponseSinkPrototype* ptr = new (NotNull, JSC::allocateCell<JSHTTPSResponseSinkPrototype>(vm)) JSHTTPSResponseSinkPrototype(vm, globalObject, structure);
        ptr->finishCreation(vm, globalObject);
        return ptr;
    }

    DECLARE_INFO;
    template<typename CellType, JSC::SubspaceAccess>
    static JSC::GCClient::IsoSubspace* subspaceFor(JSC::VM& vm)
    {
        return &vm.plainObjectSpace();
    }
    static JSC::Structure* createStructure(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::JSValue prototype)
    {
        return JSC::Structure::create(vm, globalObject, prototype, JSC::TypeInfo(JSC::ObjectType, StructureFlags), info());
    }

private:
    JSHTTPSResponseSinkPrototype(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure)
        : Base(vm, structure)
    {
    }

    void finishCreation(JSC::VM&, JSC::JSGlobalObject*);
};
STATIC_ASSERT_ISO_SUBSPACE_SHARABLE(JSHTTPSResponseSinkPrototype, JSHTTPSResponseSinkPrototype::Base);

class JSReadableHTTPSResponseSinkControllerPrototype final : public JSC::JSNonFinalObject {
public:
    using Base = JSC::JSNonFinalObject;

    static JSReadableHTTPSResponseSinkControllerPrototype* create(JSC::VM& vm, JSGlobalObject* globalObject, JSC::Structure* structure)
    {
        JSReadableHTTPSResponseSinkControllerPrototype* ptr = new (NotNull, JSC::allocateCell<JSReadableHTTPSResponseSinkControllerPrototype>(vm)) JSReadableHTTPSResponseSinkControllerPrototype(vm, globalObject, structure);
        ptr->finishCreation(vm, globalObject);
        return ptr;
    }

    DECLARE_INFO;
    template<typename CellType, JSC::SubspaceAccess>
    static JSC::GCClient::IsoSubspace* subspaceFor(JSC::VM& vm)
    {
        return &vm.plainObjectSpace();
    }
    static JSC::Structure* createStructure(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::JSValue prototype)
    {
        return JSC::Structure::create(vm, globalObject, prototype, JSC::TypeInfo(JSC::ObjectType, StructureFlags), info());
    }

private:
    JSReadableHTTPSResponseSinkControllerPrototype(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure)
        : Base(vm, structure)
    {
    }

    void finishCreation(JSC::VM&, JSC::JSGlobalObject*);
};
STATIC_ASSERT_ISO_SUBSPACE_SHARABLE(JSReadableHTTPSResponseSinkControllerPrototype, JSReadableHTTPSResponseSinkControllerPrototype::Base);

const ClassInfo JSHTTPSResponseSinkPrototype::s_info = { "HTTPSResponseSink"_s, &Base::s_info, &JSHTTPSResponseSinkPrototypeTable, nullptr, CREATE_METHOD_TABLE(JSHTTPSResponseSinkPrototype) };
const ClassInfo JSHTTPSResponseSink::s_info = { "HTTPSResponseSink"_s, &Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSHTTPSResponseSink) };
const ClassInfo JSHTTPSResponseSinkConstructor::s_info = { "HTTPSResponseSink"_s, &Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSHTTPSResponseSinkConstructor) };

const ClassInfo JSReadableHTTPSResponseSinkControllerPrototype::s_info = { "ReadableHTTPSResponseSinkController"_s, &Base::s_info, &JSReadableHTTPSResponseSinkControllerPrototypeTable, nullptr, CREATE_METHOD_TABLE(JSReadableHTTPSResponseSinkControllerPrototype) };
const ClassInfo JSReadableHTTPSResponseSinkController::s_info = { "ReadableHTTPSResponseSinkController"_s, &Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSReadableHTTPSResponseSinkController) };

JSHTTPSResponseSink::~JSHTTPSResponseSink()
{
    if (m_sinkPtr) {
        HTTPSResponseSink__finalize(m_sinkPtr);
    }
}

JSReadableHTTPSResponseSinkController::~JSReadableHTTPSResponseSinkController()
{
    if (m_sinkPtr) {
        HTTPSResponseSink__finalize(m_sinkPtr);
    }
}

JSObject* JSHTTPSResponseSink::createPrototype(VM& vm, JSDOMGlobalObject& globalObject)
{
    return JSHTTPSResponseSinkPrototype::create(vm, &globalObject, JSHTTPSResponseSinkPrototype::createStructure(vm, &globalObject, globalObject.objectPrototype()));
}

JSObject* JSReadableHTTPSResponseSinkController::createPrototype(VM& vm, JSDOMGlobalObject& globalObject)
{
    return JSReadableHTTPSResponseSinkControllerPrototype::create(vm, &globalObject, JSReadableHTTPSResponseSinkControllerPrototype::createStructure(vm, &globalObject, globalObject.objectPrototype()));
}

void JSReadableHTTPSResponseSinkController::detach()
{
    m_sinkPtr = nullptr;
    m_onPull.clear();

    auto readableStream = m_weakReadableStream.get();
    auto onClose = m_onClose.get();
    m_onClose.clear();

    if (readableStream && onClose) {
        JSC::JSGlobalObject* globalObject = this->globalObject();
        auto callData = JSC::getCallData(onClose);
        JSC::MarkedArgumentBuffer arguments;
        arguments.append(readableStream);
        arguments.append(jsUndefined());
        JSC::call(globalObject, onClose, callData, JSC::jsUndefined(), arguments);
    }

    m_weakReadableStream.clear();
}

JSHTTPSResponseSinkConstructor* JSHTTPSResponseSinkConstructor::create(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure, JSObject* prototype)
{
    JSHTTPSResponseSinkConstructor* ptr = new (NotNull, JSC::allocateCell<JSHTTPSResponseSinkConstructor>(vm)) JSHTTPSResponseSinkConstructor(vm, structure, HTTPSResponseSink__construct);
    ptr->finishCreation(vm, globalObject, prototype);
    return ptr;
}

JSHTTPSResponseSink* JSHTTPSResponseSink::create(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure, void* sinkPtr)
{
    JSHTTPSResponseSink* ptr = new (NotNull, JSC::allocateCell<JSHTTPSResponseSink>(vm)) JSHTTPSResponseSink(vm, structure, sinkPtr);
    ptr->finishCreation(vm);
    return ptr;
}

JSReadableHTTPSResponseSinkController* JSReadableHTTPSResponseSinkController::create(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure, void* sinkPtr)
{
    JSReadableHTTPSResponseSinkController* ptr = new (NotNull, JSC::allocateCell<JSReadableHTTPSResponseSinkController>(vm)) JSReadableHTTPSResponseSinkController(vm, structure, sinkPtr);
    ptr->finishCreation(vm);
    return ptr;
}

void JSHTTPSResponseSinkConstructor::finishCreation(VM& vm, JSC::JSGlobalObject* globalObject, JSObject* prototype)
{
    Base::finishCreation(vm);
    ASSERT(inherits(info()));
    initializeProperties(vm, globalObject, prototype);
}

JSC::EncodedJSValue JSC_HOST_CALL_ATTRIBUTES JSHTTPSResponseSinkConstructor::construct(JSC::JSGlobalObject* globalObject, JSC::CallFrame* callFrame)
{
    return HTTPSResponseSink__construct(globalObject, callFrame);
}

void JSHTTPSResponseSinkConstructor::initializeProperties(VM& vm, JSC::JSGlobalObject* globalObject, JSObject* prototype)
{
    putDirect(vm, vm.propertyNames->length, jsNumber(0), JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::DontEnum);
    JSString* nameString = jsNontrivialString(vm, "HTTPSResponseSink"_s);
    m_originalName.set(vm, this, nameString);
    putDirect(vm, vm.propertyNames->name, nameString, JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::DontEnum);
}

void JSHTTPSResponseSinkPrototype::finishCreation(JSC::VM& vm, JSC::JSGlobalObject* globalObject)
{
    Base::finishCreation(vm);
    reifyStaticProperties(vm, JSHTTPSResponseSink::info(), JSHTTPSResponseSinkPrototypeTableValues, *this);
    putDirect(vm, JSC::Identifier::fromString(vm, "sinkId"_s), JSC::jsNumber(JSHTTPSResponseSink::Sink), JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::DontEnum);
    JSC_TO_STRING_TAG_WITHOUT_TRANSITION();
}

void JSReadableHTTPSResponseSinkControllerPrototype::finishCreation(JSC::VM& vm, JSC::JSGlobalObject* globalObject)
{
    Base::finishCreation(vm);
    reifyStaticProperties(vm, JSReadableHTTPSResponseSinkController::info(), JSReadableHTTPSResponseSinkControllerPrototypeTableValues, *this);
    putDirect(vm, JSC::Identifier::fromString(vm, "sinkId"_s), JSC::jsNumber(JSHTTPSResponseSink::Sink), JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::DontEnum);
    JSC_TO_STRING_TAG_WITHOUT_TRANSITION();
}

void JSHTTPSResponseSink::finishCreation(VM& vm)
{
    Base::finishCreation(vm);
    ASSERT(inherits(info()));
}

void JSReadableHTTPSResponseSinkController::finishCreation(VM& vm)
{
    Base::finishCreation(vm);
    ASSERT(inherits(info()));
}

void JSHTTPSResponseSink::analyzeHeap(JSCell* cell, HeapAnalyzer& analyzer)
{
    auto* thisObject = jsCast<JSHTTPSResponseSink*>(cell);
    if (void* wrapped = thisObject->wrapped()) {
        analyzer.setWrappedObjectForCell(cell, wrapped);
        // if (thisObject->scriptExecutionContext())
        //     analyzer.setLabelForCell(cell, "url " + thisObject->scriptExecutionContext()->url().string());
    }
    Base::analyzeHeap(cell, analyzer);
}

void JSReadableHTTPSResponseSinkController::analyzeHeap(JSCell* cell, HeapAnalyzer& analyzer)
{
    auto* thisObject = jsCast<JSReadableHTTPSResponseSinkController*>(cell);
    if (void* wrapped = thisObject->wrapped()) {
        analyzer.setWrappedObjectForCell(cell, wrapped);
        // if (thisObject->scriptExecutionContext())
        //     analyzer.setLabelForCell(cell, "url " + thisObject->scriptExecutionContext()->url().string());
    }
    Base::analyzeHeap(cell, analyzer);
}

template<typename Visitor>
void JSReadableHTTPSResponseSinkController::visitChildrenImpl(JSCell* cell, Visitor& visitor)
{
    JSReadableHTTPSResponseSinkController* thisObject = jsCast<JSReadableHTTPSResponseSinkController*>(cell);
    ASSERT_GC_OBJECT_INHERITS(thisObject, info());
    Base::visitChildren(thisObject, visitor);
    visitor.append(thisObject->m_onPull);
    visitor.append(thisObject->m_onClose);
    void* ptr = thisObject->m_sinkPtr;
    if (ptr)
        visitor.addOpaqueRoot(ptr);
}

DEFINE_VISIT_CHILDREN(JSReadableHTTPSResponseSinkController);

template<typename Visitor>
void JSHTTPSResponseSink::visitChildrenImpl(JSCell* cell, Visitor& visitor)
{
    JSHTTPSResponseSink* thisObject = jsCast<JSHTTPSResponseSink*>(cell);
    ASSERT_GC_OBJECT_INHERITS(thisObject, info());
    Base::visitChildren(thisObject, visitor);
    void* ptr = thisObject->m_sinkPtr;
    if (ptr)
        visitor.addOpaqueRoot(ptr);
}

DEFINE_VISIT_CHILDREN(JSHTTPSResponseSink);

void JSReadableHTTPSResponseSinkController::start(JSC::JSGlobalObject* globalObject, JSC::JSValue readableStream, JSC::JSValue onPull, JSC::JSValue onClose)
{
    this->m_weakReadableStream = JSC::Weak<JSC::JSObject>(readableStream.getObject());
    this->m_onPull.set(globalObject->vm(), this, onPull);
    this->m_onClose.set(globalObject->vm(), this, onClose);
}

void JSHTTPSResponseSink::destroy(JSCell* cell)
{
    static_cast<JSHTTPSResponseSink*>(cell)->JSHTTPSResponseSink::~JSHTTPSResponseSink();
}

void JSReadableHTTPSResponseSinkController::destroy(JSCell* cell)
{
    static_cast<JSReadableHTTPSResponseSinkController*>(cell)->JSReadableHTTPSResponseSinkController::~JSReadableHTTPSResponseSinkController();
}

JSObject* createJSSinkPrototype(JSC::VM& vm, JSC::JSGlobalObject* globalObject, SinkID sinkID)
{
    switch (sinkID) {

    case ArrayBufferSink:
        return JSArrayBufferSinkPrototype::create(vm, globalObject, JSArrayBufferSinkPrototype::createStructure(vm, globalObject, globalObject->objectPrototype()));

    case FileSink:
        return JSFileSinkPrototype::create(vm, globalObject, JSFileSinkPrototype::createStructure(vm, globalObject, globalObject->objectPrototype()));

    case HTTPResponseSink:
        return JSHTTPResponseSinkPrototype::create(vm, globalObject, JSHTTPResponseSinkPrototype::createStructure(vm, globalObject, globalObject->objectPrototype()));

    case HTTPSResponseSink:
        return JSHTTPSResponseSinkPrototype::create(vm, globalObject, JSHTTPSResponseSinkPrototype::createStructure(vm, globalObject, globalObject->objectPrototype()));

    default:
        RELEASE_ASSERT_NOT_REACHED();
    }
}
JSObject* createJSSinkControllerPrototype(JSC::VM& vm, JSC::JSGlobalObject* globalObject, SinkID sinkID)
{
    switch (sinkID) {

    case ArrayBufferSink:
        return JSReadableArrayBufferSinkControllerPrototype::create(vm, globalObject, JSReadableArrayBufferSinkControllerPrototype::createStructure(vm, globalObject, globalObject->objectPrototype()));

    case FileSink:
        return JSReadableFileSinkControllerPrototype::create(vm, globalObject, JSReadableFileSinkControllerPrototype::createStructure(vm, globalObject, globalObject->objectPrototype()));

    case HTTPResponseSink:
        return JSReadableHTTPResponseSinkControllerPrototype::create(vm, globalObject, JSReadableHTTPResponseSinkControllerPrototype::createStructure(vm, globalObject, globalObject->objectPrototype()));

    case HTTPSResponseSink:
        return JSReadableHTTPSResponseSinkControllerPrototype::create(vm, globalObject, JSReadableHTTPSResponseSinkControllerPrototype::createStructure(vm, globalObject, globalObject->objectPrototype()));

    default:
        RELEASE_ASSERT_NOT_REACHED();
    }
}
Structure* createJSSinkControllerStructure(JSC::VM& vm, JSC::JSGlobalObject* globalObject, SinkID sinkID)
{
    switch (sinkID) {

    case ArrayBufferSink: {
        auto* prototype = createJSSinkControllerPrototype(vm, globalObject, sinkID);
        return JSReadableArrayBufferSinkController::createStructure(vm, globalObject, prototype);
    }

    case FileSink: {
        auto* prototype = createJSSinkControllerPrototype(vm, globalObject, sinkID);
        return JSReadableFileSinkController::createStructure(vm, globalObject, prototype);
    }

    case HTTPResponseSink: {
        auto* prototype = createJSSinkControllerPrototype(vm, globalObject, sinkID);
        return JSReadableHTTPResponseSinkController::createStructure(vm, globalObject, prototype);
    }

    case HTTPSResponseSink: {
        auto* prototype = createJSSinkControllerPrototype(vm, globalObject, sinkID);
        return JSReadableHTTPSResponseSinkController::createStructure(vm, globalObject, prototype);
    }

    default:
        RELEASE_ASSERT_NOT_REACHED();
    }
}
} // namespace WebCore

extern "C" JSC__JSValue ArrayBufferSink__createObject(JSC__JSGlobalObject* arg0, void* sinkPtr)
{
    auto& vm = arg0->vm();
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(arg0);
    JSC::Structure* structure = globalObject->ArrayBufferSinkStructure();
    return JSC::JSValue::encode(WebCore::JSArrayBufferSink::create(vm, globalObject, structure, sinkPtr));
}

extern "C" void* ArrayBufferSink__fromJS(JSC__JSGlobalObject* arg0, JSC__JSValue JSValue1)
{
    JSC::VM& vm = WebCore::getVM(arg0);
    if (auto* sink = JSC::jsDynamicCast<WebCore::JSArrayBufferSink*>(JSC::JSValue::decode(JSValue1)))
        return sink->wrapped();

    if (auto* controller = JSC::jsDynamicCast<WebCore::JSReadableArrayBufferSinkController*>(JSC::JSValue::decode(JSValue1)))
        return controller->wrapped();

    return nullptr;
}

extern "C" void ArrayBufferSink__detachPtr(JSC__JSValue JSValue0)
{
    if (auto* sink = JSC::jsDynamicCast<WebCore::JSArrayBufferSink*>(JSC::JSValue::decode(JSValue0))) {
        sink->detach();
        return;
    }

    if (auto* controller = JSC::jsDynamicCast<WebCore::JSReadableArrayBufferSinkController*>(JSC::JSValue::decode(JSValue0))) {
        controller->detach();
        return;
    }
}

extern "C" JSC__JSValue ArrayBufferSink__assignToStream(JSC__JSGlobalObject* arg0, JSC__JSValue stream, void* sinkPtr, void** controllerValue)
{
    auto& vm = arg0->vm();
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(arg0);

    JSC::Structure* structure = WebCore::getDOMStructure<WebCore::JSReadableArrayBufferSinkController>(vm, *globalObject);
    WebCore::JSReadableArrayBufferSinkController* controller = WebCore::JSReadableArrayBufferSinkController::create(vm, globalObject, structure, sinkPtr);
    *controllerValue = reinterpret_cast<void*>(JSC::JSValue::encode(controller));
    return globalObject->assignToStream(JSC::JSValue::decode(stream), controller);
}

extern "C" void ArrayBufferSink__onReady(JSC__JSValue controllerValue, JSC__JSValue amt, JSC__JSValue offset)
{
    WebCore::JSReadableArrayBufferSinkController* controller = JSC::jsCast<WebCore::JSReadableArrayBufferSinkController*>(JSC::JSValue::decode(controllerValue).getObject());

    JSC::JSValue function = controller->m_onPull.get();
    if (!function)
        return;
    JSC::JSGlobalObject* globalObject = controller->globalObject();

    JSC::MarkedArgumentBuffer arguments;
    arguments.append(controller);
    arguments.append(JSC::JSValue::decode(amt));
    arguments.append(JSC::JSValue::decode(offset));

    AsyncBoundFunction::call(globalObject, function, JSC::jsUndefined(), arguments);
}

extern "C" void ArrayBufferSink__onStart(JSC__JSValue controllerValue)
{
}

extern "C" void ArrayBufferSink__onClose(JSC__JSValue controllerValue, JSC__JSValue reason)
{
    WebCore::JSReadableArrayBufferSinkController* controller = JSC::jsCast<WebCore::JSReadableArrayBufferSinkController*>(JSC::JSValue::decode(controllerValue).getObject());

    JSC::JSValue function = controller->m_onClose.get();
    if (!function)
        return;
    // only call close once
    controller->m_onClose.clear();
    JSC::JSGlobalObject* globalObject = controller->globalObject();

    JSC::MarkedArgumentBuffer arguments;
    auto readableStream = controller->m_weakReadableStream.get();
    arguments.append(readableStream ? readableStream : JSC::jsUndefined());

    arguments.append(JSC::JSValue::decode(reason));
    AsyncBoundFunction::call(globalObject, function, JSC::jsUndefined(), arguments);
}

extern "C" JSC__JSValue FileSink__createObject(JSC__JSGlobalObject* arg0, void* sinkPtr)
{
    auto& vm = arg0->vm();
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(arg0);
    JSC::Structure* structure = globalObject->FileSinkStructure();
    return JSC::JSValue::encode(WebCore::JSFileSink::create(vm, globalObject, structure, sinkPtr));
}

extern "C" void* FileSink__fromJS(JSC__JSGlobalObject* arg0, JSC__JSValue JSValue1)
{
    JSC::VM& vm = WebCore::getVM(arg0);
    if (auto* sink = JSC::jsDynamicCast<WebCore::JSFileSink*>(JSC::JSValue::decode(JSValue1)))
        return sink->wrapped();

    if (auto* controller = JSC::jsDynamicCast<WebCore::JSReadableFileSinkController*>(JSC::JSValue::decode(JSValue1)))
        return controller->wrapped();

    return nullptr;
}

extern "C" void FileSink__detachPtr(JSC__JSValue JSValue0)
{
    if (auto* sink = JSC::jsDynamicCast<WebCore::JSFileSink*>(JSC::JSValue::decode(JSValue0))) {
        sink->detach();
        return;
    }

    if (auto* controller = JSC::jsDynamicCast<WebCore::JSReadableFileSinkController*>(JSC::JSValue::decode(JSValue0))) {
        controller->detach();
        return;
    }
}

extern "C" JSC__JSValue FileSink__assignToStream(JSC__JSGlobalObject* arg0, JSC__JSValue stream, void* sinkPtr, void** controllerValue)
{
    auto& vm = arg0->vm();
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(arg0);

    JSC::Structure* structure = WebCore::getDOMStructure<WebCore::JSReadableFileSinkController>(vm, *globalObject);
    WebCore::JSReadableFileSinkController* controller = WebCore::JSReadableFileSinkController::create(vm, globalObject, structure, sinkPtr);
    *controllerValue = reinterpret_cast<void*>(JSC::JSValue::encode(controller));
    return globalObject->assignToStream(JSC::JSValue::decode(stream), controller);
}

extern "C" void FileSink__onReady(JSC__JSValue controllerValue, JSC__JSValue amt, JSC__JSValue offset)
{
    WebCore::JSReadableFileSinkController* controller = JSC::jsCast<WebCore::JSReadableFileSinkController*>(JSC::JSValue::decode(controllerValue).getObject());

    JSC::JSValue function = controller->m_onPull.get();
    if (!function)
        return;
    JSC::JSGlobalObject* globalObject = controller->globalObject();

    JSC::MarkedArgumentBuffer arguments;
    arguments.append(controller);
    arguments.append(JSC::JSValue::decode(amt));
    arguments.append(JSC::JSValue::decode(offset));

    AsyncBoundFunction::call(globalObject, function, JSC::jsUndefined(), arguments);
}

extern "C" void FileSink__onStart(JSC__JSValue controllerValue)
{
}

extern "C" void FileSink__onClose(JSC__JSValue controllerValue, JSC__JSValue reason)
{
    WebCore::JSReadableFileSinkController* controller = JSC::jsCast<WebCore::JSReadableFileSinkController*>(JSC::JSValue::decode(controllerValue).getObject());

    JSC::JSValue function = controller->m_onClose.get();
    if (!function)
        return;
    // only call close once
    controller->m_onClose.clear();
    JSC::JSGlobalObject* globalObject = controller->globalObject();

    JSC::MarkedArgumentBuffer arguments;
    auto readableStream = controller->m_weakReadableStream.get();
    arguments.append(readableStream ? readableStream : JSC::jsUndefined());

    arguments.append(JSC::JSValue::decode(reason));
    AsyncBoundFunction::call(globalObject, function, JSC::jsUndefined(), arguments);
}

extern "C" JSC__JSValue HTTPResponseSink__createObject(JSC__JSGlobalObject* arg0, void* sinkPtr)
{
    auto& vm = arg0->vm();
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(arg0);
    JSC::Structure* structure = globalObject->HTTPResponseSinkStructure();
    return JSC::JSValue::encode(WebCore::JSHTTPResponseSink::create(vm, globalObject, structure, sinkPtr));
}

extern "C" void* HTTPResponseSink__fromJS(JSC__JSGlobalObject* arg0, JSC__JSValue JSValue1)
{
    JSC::VM& vm = WebCore::getVM(arg0);
    if (auto* sink = JSC::jsDynamicCast<WebCore::JSHTTPResponseSink*>(JSC::JSValue::decode(JSValue1)))
        return sink->wrapped();

    if (auto* controller = JSC::jsDynamicCast<WebCore::JSReadableHTTPResponseSinkController*>(JSC::JSValue::decode(JSValue1)))
        return controller->wrapped();

    return nullptr;
}

extern "C" void HTTPResponseSink__detachPtr(JSC__JSValue JSValue0)
{
    if (auto* sink = JSC::jsDynamicCast<WebCore::JSHTTPResponseSink*>(JSC::JSValue::decode(JSValue0))) {
        sink->detach();
        return;
    }

    if (auto* controller = JSC::jsDynamicCast<WebCore::JSReadableHTTPResponseSinkController*>(JSC::JSValue::decode(JSValue0))) {
        controller->detach();
        return;
    }
}

extern "C" JSC__JSValue HTTPResponseSink__assignToStream(JSC__JSGlobalObject* arg0, JSC__JSValue stream, void* sinkPtr, void** controllerValue)
{
    auto& vm = arg0->vm();
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(arg0);

    JSC::Structure* structure = WebCore::getDOMStructure<WebCore::JSReadableHTTPResponseSinkController>(vm, *globalObject);
    WebCore::JSReadableHTTPResponseSinkController* controller = WebCore::JSReadableHTTPResponseSinkController::create(vm, globalObject, structure, sinkPtr);
    *controllerValue = reinterpret_cast<void*>(JSC::JSValue::encode(controller));
    return globalObject->assignToStream(JSC::JSValue::decode(stream), controller);
}

extern "C" void HTTPResponseSink__onReady(JSC__JSValue controllerValue, JSC__JSValue amt, JSC__JSValue offset)
{
    WebCore::JSReadableHTTPResponseSinkController* controller = JSC::jsCast<WebCore::JSReadableHTTPResponseSinkController*>(JSC::JSValue::decode(controllerValue).getObject());

    JSC::JSValue function = controller->m_onPull.get();
    if (!function)
        return;
    JSC::JSGlobalObject* globalObject = controller->globalObject();

    JSC::MarkedArgumentBuffer arguments;
    arguments.append(controller);
    arguments.append(JSC::JSValue::decode(amt));
    arguments.append(JSC::JSValue::decode(offset));

    AsyncBoundFunction::call(globalObject, function, JSC::jsUndefined(), arguments);
}

extern "C" void HTTPResponseSink__onStart(JSC__JSValue controllerValue)
{
}

extern "C" void HTTPResponseSink__onClose(JSC__JSValue controllerValue, JSC__JSValue reason)
{
    WebCore::JSReadableHTTPResponseSinkController* controller = JSC::jsCast<WebCore::JSReadableHTTPResponseSinkController*>(JSC::JSValue::decode(controllerValue).getObject());

    JSC::JSValue function = controller->m_onClose.get();
    if (!function)
        return;
    // only call close once
    controller->m_onClose.clear();
    JSC::JSGlobalObject* globalObject = controller->globalObject();

    JSC::MarkedArgumentBuffer arguments;
    auto readableStream = controller->m_weakReadableStream.get();
    arguments.append(readableStream ? readableStream : JSC::jsUndefined());

    arguments.append(JSC::JSValue::decode(reason));
    AsyncBoundFunction::call(globalObject, function, JSC::jsUndefined(), arguments);
}

extern "C" JSC__JSValue HTTPSResponseSink__createObject(JSC__JSGlobalObject* arg0, void* sinkPtr)
{
    auto& vm = arg0->vm();
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(arg0);
    JSC::Structure* structure = globalObject->HTTPSResponseSinkStructure();
    return JSC::JSValue::encode(WebCore::JSHTTPSResponseSink::create(vm, globalObject, structure, sinkPtr));
}

extern "C" void* HTTPSResponseSink__fromJS(JSC__JSGlobalObject* arg0, JSC__JSValue JSValue1)
{
    JSC::VM& vm = WebCore::getVM(arg0);
    if (auto* sink = JSC::jsDynamicCast<WebCore::JSHTTPSResponseSink*>(JSC::JSValue::decode(JSValue1)))
        return sink->wrapped();

    if (auto* controller = JSC::jsDynamicCast<WebCore::JSReadableHTTPSResponseSinkController*>(JSC::JSValue::decode(JSValue1)))
        return controller->wrapped();

    return nullptr;
}

extern "C" void HTTPSResponseSink__detachPtr(JSC__JSValue JSValue0)
{
    if (auto* sink = JSC::jsDynamicCast<WebCore::JSHTTPSResponseSink*>(JSC::JSValue::decode(JSValue0))) {
        sink->detach();
        return;
    }

    if (auto* controller = JSC::jsDynamicCast<WebCore::JSReadableHTTPSResponseSinkController*>(JSC::JSValue::decode(JSValue0))) {
        controller->detach();
        return;
    }
}

extern "C" JSC__JSValue HTTPSResponseSink__assignToStream(JSC__JSGlobalObject* arg0, JSC__JSValue stream, void* sinkPtr, void** controllerValue)
{
    auto& vm = arg0->vm();
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(arg0);

    JSC::Structure* structure = WebCore::getDOMStructure<WebCore::JSReadableHTTPSResponseSinkController>(vm, *globalObject);
    WebCore::JSReadableHTTPSResponseSinkController* controller = WebCore::JSReadableHTTPSResponseSinkController::create(vm, globalObject, structure, sinkPtr);
    *controllerValue = reinterpret_cast<void*>(JSC::JSValue::encode(controller));
    return globalObject->assignToStream(JSC::JSValue::decode(stream), controller);
}

extern "C" void HTTPSResponseSink__onReady(JSC__JSValue controllerValue, JSC__JSValue amt, JSC__JSValue offset)
{
    WebCore::JSReadableHTTPSResponseSinkController* controller = JSC::jsCast<WebCore::JSReadableHTTPSResponseSinkController*>(JSC::JSValue::decode(controllerValue).getObject());

    JSC::JSValue function = controller->m_onPull.get();
    if (!function)
        return;
    JSC::JSGlobalObject* globalObject = controller->globalObject();

    JSC::MarkedArgumentBuffer arguments;
    arguments.append(controller);
    arguments.append(JSC::JSValue::decode(amt));
    arguments.append(JSC::JSValue::decode(offset));

    AsyncBoundFunction::call(globalObject, function, JSC::jsUndefined(), arguments);
}

extern "C" void HTTPSResponseSink__onStart(JSC__JSValue controllerValue)
{
}

extern "C" void HTTPSResponseSink__onClose(JSC__JSValue controllerValue, JSC__JSValue reason)
{
    WebCore::JSReadableHTTPSResponseSinkController* controller = JSC::jsCast<WebCore::JSReadableHTTPSResponseSinkController*>(JSC::JSValue::decode(controllerValue).getObject());

    JSC::JSValue function = controller->m_onClose.get();
    if (!function)
        return;
    // only call close once
    controller->m_onClose.clear();
    JSC::JSGlobalObject* globalObject = controller->globalObject();

    JSC::MarkedArgumentBuffer arguments;
    auto readableStream = controller->m_weakReadableStream.get();
    arguments.append(readableStream ? readableStream : JSC::jsUndefined());

    arguments.append(JSC::JSValue::decode(reason));
    AsyncBoundFunction::call(globalObject, function, JSC::jsUndefined(), arguments);
}
