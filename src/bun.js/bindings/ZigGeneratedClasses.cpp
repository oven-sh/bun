
// GENERATED CODE - DO NOT MODIFY BY HAND
// Generated by make codegen
#include "root.h"
#include "headers.h"

#include "BunClientData.h"
#include "ZigGlobalObject.h"

#include <JavaScriptCore/JSFunction.h>
#include <JavaScriptCore/InternalFunction.h>
#include <JavaScriptCore/LazyClassStructure.h>
#include <JavaScriptCore/LazyClassStructureInlines.h>
#include <JavaScriptCore/FunctionPrototype.h>

#include <JavaScriptCore/DOMJITAbstractHeap.h>
#include "DOMJITIDLConvert.h"
#include "DOMJITIDLType.h"
#include "DOMJITIDLTypeFilter.h"
#include "DOMJITHelpers.h"
#include <JavaScriptCore/DFGAbstractHeap.h>

#include "JSDOMConvertBufferSource.h"
#include "ZigGeneratedClasses.h"

namespace WebCore {

using namespace JSC;
using namespace Zig;

class JSBlobPrototype final : public JSC::JSNonFinalObject {
public:
    using Base = JSC::JSNonFinalObject;

    static JSBlobPrototype* create(JSC::VM& vm, JSGlobalObject* globalObject, JSC::Structure* structure)
    {
        JSBlobPrototype* ptr = new (NotNull, JSC::allocateCell<JSBlobPrototype>(vm)) JSBlobPrototype(vm, globalObject, structure);
        ptr->finishCreation(vm, globalObject);
        return ptr;
    }

    DECLARE_INFO;
    template<typename CellType, JSC::SubspaceAccess>
    static JSC::GCClient::IsoSubspace* subspaceFor(JSC::VM& vm)
    {
        return &vm.plainObjectSpace();
    }
    static JSC::Structure* createStructure(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::JSValue prototype)
    {
        return JSC::Structure::create(vm, globalObject, prototype, JSC::TypeInfo(JSC::ObjectType, StructureFlags), info());
    }

private:
    JSBlobPrototype(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure)
        : Base(vm, structure)
    {
    }

    void finishCreation(JSC::VM&, JSC::JSGlobalObject*);
};

class JSBlobConstructor final : public JSC::InternalFunction {
public:
    using Base = JSC::InternalFunction;
    static JSBlobConstructor* create(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure, JSBlobPrototype* prototype);

    static constexpr unsigned StructureFlags = Base::StructureFlags;
    static constexpr bool needsDestruction = false;

    static JSC::Structure* createStructure(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::JSValue prototype)
    {
        return JSC::Structure::create(vm, globalObject, prototype, JSC::TypeInfo(JSC::InternalFunctionType, StructureFlags), info());
    }

    template<typename, JSC::SubspaceAccess mode> static JSC::GCClient::IsoSubspace* subspaceFor(JSC::VM& vm)
    {
        if constexpr (mode == JSC::SubspaceAccess::Concurrently)
            return nullptr;
        return WebCore::subspaceForImpl<JSBlobConstructor, WebCore::UseCustomHeapCellType::No>(
            vm,
            [](auto& spaces) { return spaces.m_clientSubspaceForBlobConstructor.get(); },
            [](auto& spaces, auto&& space) { spaces.m_clientSubspaceForBlobConstructor = std::forward<decltype(space)>(space); },
            [](auto& spaces) { return spaces.m_subspaceForBlobConstructor.get(); },
            [](auto& spaces, auto&& space) { spaces.m_subspaceForBlobConstructor = std::forward<decltype(space)>(space); });
    }

    void initializeProperties(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSBlobPrototype* prototype);

    // Must be defined for each specialization class.
    static JSC::EncodedJSValue JSC_HOST_CALL_ATTRIBUTES construct(JSC::JSGlobalObject*, JSC::CallFrame*);

    DECLARE_EXPORT_INFO;

private:
    JSBlobConstructor(JSC::VM& vm, JSC::Structure* structure);
    void finishCreation(JSC::VM&, JSC::JSGlobalObject* globalObject, JSBlobPrototype* prototype);
};

extern "C" void* BlobClass__construct(JSC::JSGlobalObject*, JSC::CallFrame*);
JSC_DECLARE_CUSTOM_GETTER(jsBlobConstructor);
extern "C" void BlobClass__finalize(void*);

extern "C" EncodedJSValue BlobPrototype__getArrayBuffer(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(BlobPrototype__arrayBufferCallback);

extern "C" EncodedJSValue BlobPrototype__getFormData(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(BlobPrototype__formDataCallback);

extern "C" EncodedJSValue BlobPrototype__getJSON(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(BlobPrototype__jsonCallback);

extern "C" JSC::EncodedJSValue BlobPrototype__getLastModified(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject);
JSC_DECLARE_CUSTOM_GETTER(BlobPrototype__lastModifiedGetterWrap);

extern "C" JSC::EncodedJSValue BlobPrototype__getSize(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject);
JSC_DECLARE_CUSTOM_GETTER(BlobPrototype__sizeGetterWrap);

extern "C" EncodedJSValue BlobPrototype__getSlice(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(BlobPrototype__sliceCallback);

extern "C" EncodedJSValue BlobPrototype__getStream(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(BlobPrototype__streamCallback);

extern "C" EncodedJSValue BlobPrototype__getText(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(BlobPrototype__textCallback);

extern "C" JSC::EncodedJSValue BlobPrototype__getType(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject);
JSC_DECLARE_CUSTOM_GETTER(BlobPrototype__typeGetterWrap);

extern "C" EncodedJSValue BlobPrototype__getWriter(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(BlobPrototype__writerCallback);

STATIC_ASSERT_ISO_SUBSPACE_SHARABLE(JSBlobPrototype, JSBlobPrototype::Base);

static const HashTableValue JSBlobPrototypeTableValues[] = {
    { "arrayBuffer"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, BlobPrototype__arrayBufferCallback, 0 } },
    { "formData"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, BlobPrototype__formDataCallback, 0 } },
    { "json"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, BlobPrototype__jsonCallback, 0 } },
    { "lastModified"_s, static_cast<unsigned>(JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::GetterSetterType, BlobPrototype__lastModifiedGetterWrap, 0 } },
    { "size"_s, static_cast<unsigned>(JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::GetterSetterType, BlobPrototype__sizeGetterWrap, 0 } },
    { "slice"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, BlobPrototype__sliceCallback, 2 } },
    { "stream"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, BlobPrototype__streamCallback, 1 } },
    { "text"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, BlobPrototype__textCallback, 0 } },
    { "type"_s, static_cast<unsigned>(JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::GetterSetterType, BlobPrototype__typeGetterWrap, 0 } },
    { "writer"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, BlobPrototype__writerCallback, 1 } }
};

const ClassInfo JSBlobPrototype::s_info = { "Blob"_s, &Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSBlobPrototype) };

JSC_DEFINE_CUSTOM_GETTER(jsBlobConstructor, (JSGlobalObject * lexicalGlobalObject, EncodedJSValue thisValue, PropertyName))
{
    VM& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    auto* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    auto* prototype = jsDynamicCast<JSBlobPrototype*>(JSValue::decode(thisValue));

    if (UNLIKELY(!prototype))
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    return JSValue::encode(globalObject->JSBlobConstructor());
}

JSC_DEFINE_HOST_FUNCTION(BlobPrototype__arrayBufferCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSBlob* thisObject = jsDynamicCast<JSBlob*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return BlobPrototype__getArrayBuffer(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_HOST_FUNCTION(BlobPrototype__formDataCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSBlob* thisObject = jsDynamicCast<JSBlob*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return BlobPrototype__getFormData(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_HOST_FUNCTION(BlobPrototype__jsonCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSBlob* thisObject = jsDynamicCast<JSBlob*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return BlobPrototype__getJSON(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_CUSTOM_GETTER(BlobPrototype__lastModifiedGetterWrap, (JSGlobalObject * lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    auto& vm = lexicalGlobalObject->vm();
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    JSBlob* thisObject = jsCast<JSBlob*>(JSValue::decode(thisValue));
    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);
    JSC::EncodedJSValue result = BlobPrototype__getLastModified(thisObject->wrapped(), globalObject);
    RETURN_IF_EXCEPTION(throwScope, {});
    RELEASE_AND_RETURN(throwScope, result);
}

JSC_DEFINE_CUSTOM_GETTER(BlobPrototype__sizeGetterWrap, (JSGlobalObject * lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    auto& vm = lexicalGlobalObject->vm();
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    JSBlob* thisObject = jsCast<JSBlob*>(JSValue::decode(thisValue));
    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);
    JSC::EncodedJSValue result = BlobPrototype__getSize(thisObject->wrapped(), globalObject);
    RETURN_IF_EXCEPTION(throwScope, {});
    RELEASE_AND_RETURN(throwScope, result);
}

JSC_DEFINE_HOST_FUNCTION(BlobPrototype__sliceCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSBlob* thisObject = jsDynamicCast<JSBlob*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return BlobPrototype__getSlice(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_HOST_FUNCTION(BlobPrototype__streamCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSBlob* thisObject = jsDynamicCast<JSBlob*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return BlobPrototype__getStream(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_HOST_FUNCTION(BlobPrototype__textCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSBlob* thisObject = jsDynamicCast<JSBlob*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return BlobPrototype__getText(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_CUSTOM_GETTER(BlobPrototype__typeGetterWrap, (JSGlobalObject * lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    auto& vm = lexicalGlobalObject->vm();
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    JSBlob* thisObject = jsCast<JSBlob*>(JSValue::decode(thisValue));
    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);
    JSC::EncodedJSValue result = BlobPrototype__getType(thisObject->wrapped(), globalObject);
    RETURN_IF_EXCEPTION(throwScope, {});
    RELEASE_AND_RETURN(throwScope, result);
}

JSC_DEFINE_HOST_FUNCTION(BlobPrototype__writerCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSBlob* thisObject = jsDynamicCast<JSBlob*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return BlobPrototype__getWriter(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

void JSBlobPrototype::finishCreation(JSC::VM& vm, JSC::JSGlobalObject* globalObject)
{
    Base::finishCreation(vm);
    reifyStaticProperties(vm, JSBlob::info(), JSBlobPrototypeTableValues, *this);
    JSC_TO_STRING_TAG_WITHOUT_TRANSITION();
}

void JSBlobConstructor::finishCreation(VM& vm, JSC::JSGlobalObject* globalObject, JSBlobPrototype* prototype)
{
    Base::finishCreation(vm, 0, "Blob"_s, PropertyAdditionMode::WithoutStructureTransition);

    putDirectWithoutTransition(vm, vm.propertyNames->prototype, prototype, PropertyAttribute::DontEnum | PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly);
    ASSERT(inherits(info()));
}

JSBlobConstructor::JSBlobConstructor(JSC::VM& vm, JSC::Structure* structure)
    : Base(vm, structure, construct, construct)
{
}

JSBlobConstructor* JSBlobConstructor::create(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure, JSBlobPrototype* prototype)
{
    JSBlobConstructor* ptr = new (NotNull, JSC::allocateCell<JSBlobConstructor>(vm)) JSBlobConstructor(vm, structure);
    ptr->finishCreation(vm, globalObject, prototype);
    return ptr;
}

JSC::EncodedJSValue JSC_HOST_CALL_ATTRIBUTES JSBlobConstructor::construct(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame)
{
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    JSC::VM& vm = globalObject->vm();
    JSObject* newTarget = asObject(callFrame->newTarget());
    auto* constructor = globalObject->JSBlobConstructor();
    Structure* structure = globalObject->JSBlobStructure();
    if (constructor != newTarget) {
        auto scope = DECLARE_THROW_SCOPE(vm);

        auto* functionGlobalObject = reinterpret_cast<Zig::GlobalObject*>(
            // ShadowRealm functions belong to a different global object.
            getFunctionRealm(globalObject, newTarget));
        RETURN_IF_EXCEPTION(scope, {});
        structure = InternalFunction::createSubclassStructure(
            globalObject,
            newTarget,
            functionGlobalObject->JSBlobStructure());
    }

    void* ptr = BlobClass__construct(globalObject, callFrame);

    if (UNLIKELY(!ptr)) {
        return JSValue::encode(JSC::jsUndefined());
    }

    JSBlob* instance = JSBlob::create(vm, globalObject, structure, ptr);

    return JSValue::encode(instance);
}

void JSBlobConstructor::initializeProperties(VM& vm, JSC::JSGlobalObject* globalObject, JSBlobPrototype* prototype)
{
}

const ClassInfo JSBlobConstructor::s_info = { "Function"_s, &Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSBlobConstructor) };

extern "C" EncodedJSValue Blob__getConstructor(Zig::GlobalObject* globalObject)
{
    return JSValue::encode(globalObject->JSBlobConstructor());
}

JSBlob::~JSBlob()
{
    if (m_ctx) {
        BlobClass__finalize(m_ctx);
    }
}
void JSBlob::destroy(JSCell* cell)
{
    static_cast<JSBlob*>(cell)->JSBlob::~JSBlob();
}

const ClassInfo JSBlob::s_info = { "Blob"_s, &Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSBlob) };

void JSBlob::finishCreation(VM& vm)
{
    Base::finishCreation(vm);
    ASSERT(inherits(info()));
}

JSBlob* JSBlob::create(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure, void* ctx)
{
    JSBlob* ptr = new (NotNull, JSC::allocateCell<JSBlob>(vm)) JSBlob(vm, structure, ctx);
    ptr->finishCreation(vm);
    return ptr;
}

extern "C" void* Blob__fromJS(JSC::EncodedJSValue value)
{
    JSC::JSValue decodedValue = JSC::JSValue::decode(value);
    if (decodedValue.isEmpty() || !decodedValue.isCell())
        return nullptr;

    JSC::JSCell* cell = decodedValue.asCell();
    JSBlob* object = JSC::jsDynamicCast<JSBlob*>(cell);

    if (!object)
        return nullptr;

    return object->wrapped();
}

extern "C" bool Blob__dangerouslySetPtr(JSC::EncodedJSValue value, void* ptr)
{
    JSBlob* object = JSC::jsDynamicCast<JSBlob*>(JSValue::decode(value));
    if (!object)
        return false;

    object->m_ctx = ptr;
    return true;
}

extern "C" const size_t Blob__ptrOffset = JSBlob::offsetOfWrapped();

void JSBlob::analyzeHeap(JSCell* cell, HeapAnalyzer& analyzer)
{
    auto* thisObject = jsCast<JSBlob*>(cell);
    if (void* wrapped = thisObject->wrapped()) {
        // if (thisObject->scriptExecutionContext())
        //     analyzer.setLabelForCell(cell, "url " + thisObject->scriptExecutionContext()->url().string());
    }
    Base::analyzeHeap(cell, analyzer);
}

JSObject* JSBlob::createConstructor(VM& vm, JSGlobalObject* globalObject, JSValue prototype)
{
    return WebCore::JSBlobConstructor::create(vm, globalObject, WebCore::JSBlobConstructor::createStructure(vm, globalObject, globalObject->functionPrototype()), jsCast<WebCore::JSBlobPrototype*>(prototype));
}

JSObject* JSBlob::createPrototype(VM& vm, JSDOMGlobalObject* globalObject)
{
    return JSBlobPrototype::create(vm, globalObject, JSBlobPrototype::createStructure(vm, globalObject, globalObject->objectPrototype()));
}

extern "C" EncodedJSValue Blob__create(Zig::GlobalObject* globalObject, void* ptr)
{
    auto& vm = globalObject->vm();
    JSC::Structure* structure = globalObject->JSBlobStructure();
    JSBlob* instance = JSBlob::create(vm, globalObject, structure, ptr);

    return JSValue::encode(instance);
}
class JSCryptoHasherPrototype final : public JSC::JSNonFinalObject {
public:
    using Base = JSC::JSNonFinalObject;

    static JSCryptoHasherPrototype* create(JSC::VM& vm, JSGlobalObject* globalObject, JSC::Structure* structure)
    {
        JSCryptoHasherPrototype* ptr = new (NotNull, JSC::allocateCell<JSCryptoHasherPrototype>(vm)) JSCryptoHasherPrototype(vm, globalObject, structure);
        ptr->finishCreation(vm, globalObject);
        return ptr;
    }

    DECLARE_INFO;
    template<typename CellType, JSC::SubspaceAccess>
    static JSC::GCClient::IsoSubspace* subspaceFor(JSC::VM& vm)
    {
        return &vm.plainObjectSpace();
    }
    static JSC::Structure* createStructure(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::JSValue prototype)
    {
        return JSC::Structure::create(vm, globalObject, prototype, JSC::TypeInfo(JSC::ObjectType, StructureFlags), info());
    }

private:
    JSCryptoHasherPrototype(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure)
        : Base(vm, structure)
    {
    }

    void finishCreation(JSC::VM&, JSC::JSGlobalObject*);
};

class JSCryptoHasherConstructor final : public JSC::InternalFunction {
public:
    using Base = JSC::InternalFunction;
    static JSCryptoHasherConstructor* create(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure, JSCryptoHasherPrototype* prototype);

    static constexpr unsigned StructureFlags = Base::StructureFlags;
    static constexpr bool needsDestruction = false;

    static JSC::Structure* createStructure(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::JSValue prototype)
    {
        return JSC::Structure::create(vm, globalObject, prototype, JSC::TypeInfo(JSC::InternalFunctionType, StructureFlags), info());
    }

    template<typename, JSC::SubspaceAccess mode> static JSC::GCClient::IsoSubspace* subspaceFor(JSC::VM& vm)
    {
        if constexpr (mode == JSC::SubspaceAccess::Concurrently)
            return nullptr;
        return WebCore::subspaceForImpl<JSCryptoHasherConstructor, WebCore::UseCustomHeapCellType::No>(
            vm,
            [](auto& spaces) { return spaces.m_clientSubspaceForCryptoHasherConstructor.get(); },
            [](auto& spaces, auto&& space) { spaces.m_clientSubspaceForCryptoHasherConstructor = std::forward<decltype(space)>(space); },
            [](auto& spaces) { return spaces.m_subspaceForCryptoHasherConstructor.get(); },
            [](auto& spaces, auto&& space) { spaces.m_subspaceForCryptoHasherConstructor = std::forward<decltype(space)>(space); });
    }

    void initializeProperties(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSCryptoHasherPrototype* prototype);

    // Must be defined for each specialization class.
    static JSC::EncodedJSValue JSC_HOST_CALL_ATTRIBUTES construct(JSC::JSGlobalObject*, JSC::CallFrame*);

    DECLARE_EXPORT_INFO;

private:
    JSCryptoHasherConstructor(JSC::VM& vm, JSC::Structure* structure);
    void finishCreation(JSC::VM&, JSC::JSGlobalObject* globalObject, JSCryptoHasherPrototype* prototype);
};

extern "C" void* CryptoHasherClass__construct(JSC::JSGlobalObject*, JSC::CallFrame*);
JSC_DECLARE_CUSTOM_GETTER(jsCryptoHasherConstructor);
extern "C" void CryptoHasherClass__finalize(void*);

extern "C" JSC::EncodedJSValue CryptoHasherPrototype__getAlgorithm(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject);
JSC_DECLARE_CUSTOM_GETTER(CryptoHasherPrototype__algorithmGetterWrap);

extern "C" JSC::EncodedJSValue CryptoHasherPrototype__getByteLength(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject);
JSC_DECLARE_CUSTOM_GETTER(CryptoHasherPrototype__byteLengthGetterWrap);

extern "C" EncodedJSValue CryptoHasherPrototype__copy(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(CryptoHasherPrototype__copyCallback);

extern "C" EncodedJSValue CryptoHasherPrototype__digest(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(CryptoHasherPrototype__digestCallback);

extern "C" EncodedJSValue CryptoHasherPrototype__update(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(CryptoHasherPrototype__updateCallback);

STATIC_ASSERT_ISO_SUBSPACE_SHARABLE(JSCryptoHasherPrototype, JSCryptoHasherPrototype::Base);

static const HashTableValue JSCryptoHasherPrototypeTableValues[] = {
    { "algorithm"_s, static_cast<unsigned>(JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::GetterSetterType, CryptoHasherPrototype__algorithmGetterWrap, 0 } },
    { "byteLength"_s, static_cast<unsigned>(JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::GetterSetterType, CryptoHasherPrototype__byteLengthGetterWrap, 0 } },
    { "copy"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, CryptoHasherPrototype__copyCallback, 0 } },
    { "digest"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, CryptoHasherPrototype__digestCallback, 0 } },
    { "update"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, CryptoHasherPrototype__updateCallback, 2 } }
};

const ClassInfo JSCryptoHasherPrototype::s_info = { "CryptoHasher"_s, &Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSCryptoHasherPrototype) };

JSC_DEFINE_CUSTOM_GETTER(jsCryptoHasherConstructor, (JSGlobalObject * lexicalGlobalObject, EncodedJSValue thisValue, PropertyName))
{
    VM& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    auto* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    auto* prototype = jsDynamicCast<JSCryptoHasherPrototype*>(JSValue::decode(thisValue));

    if (UNLIKELY(!prototype))
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    return JSValue::encode(globalObject->JSCryptoHasherConstructor());
}

JSC_DEFINE_CUSTOM_GETTER(CryptoHasherPrototype__algorithmGetterWrap, (JSGlobalObject * lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    auto& vm = lexicalGlobalObject->vm();
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    JSCryptoHasher* thisObject = jsCast<JSCryptoHasher*>(JSValue::decode(thisValue));
    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    if (JSValue cachedValue = thisObject->m_algorithm.get())
        return JSValue::encode(cachedValue);

    JSC::JSValue result = JSC::JSValue::decode(
        CryptoHasherPrototype__getAlgorithm(thisObject->wrapped(), globalObject));
    RETURN_IF_EXCEPTION(throwScope, {});
    thisObject->m_algorithm.set(vm, thisObject, result);
    RELEASE_AND_RETURN(throwScope, JSValue::encode(result));
}

extern "C" void CryptoHasherPrototype__algorithmSetCachedValue(JSC::EncodedJSValue thisValue, JSC::JSGlobalObject* globalObject, JSC::EncodedJSValue value)
{
    auto& vm = globalObject->vm();
    auto* thisObject = jsCast<JSCryptoHasher*>(JSValue::decode(thisValue));
    thisObject->m_algorithm.set(vm, thisObject, JSValue::decode(value));
}

extern "C" EncodedJSValue CryptoHasherPrototype__algorithmGetCachedValue(JSC::EncodedJSValue thisValue)
{
    auto* thisObject = jsCast<JSCryptoHasher*>(JSValue::decode(thisValue));
    return JSValue::encode(thisObject->m_algorithm.get());
}

JSC_DEFINE_CUSTOM_GETTER(CryptoHasherPrototype__byteLengthGetterWrap, (JSGlobalObject * lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    auto& vm = lexicalGlobalObject->vm();
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    JSCryptoHasher* thisObject = jsCast<JSCryptoHasher*>(JSValue::decode(thisValue));
    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);
    JSC::EncodedJSValue result = CryptoHasherPrototype__getByteLength(thisObject->wrapped(), globalObject);
    RETURN_IF_EXCEPTION(throwScope, {});
    RELEASE_AND_RETURN(throwScope, result);
}

JSC_DEFINE_HOST_FUNCTION(CryptoHasherPrototype__copyCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSCryptoHasher* thisObject = jsDynamicCast<JSCryptoHasher*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return CryptoHasherPrototype__copy(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_HOST_FUNCTION(CryptoHasherPrototype__digestCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSCryptoHasher* thisObject = jsDynamicCast<JSCryptoHasher*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return CryptoHasherPrototype__digest(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_HOST_FUNCTION(CryptoHasherPrototype__updateCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSCryptoHasher* thisObject = jsDynamicCast<JSCryptoHasher*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return CryptoHasherPrototype__update(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

void JSCryptoHasherPrototype::finishCreation(JSC::VM& vm, JSC::JSGlobalObject* globalObject)
{
    Base::finishCreation(vm);
    reifyStaticProperties(vm, JSCryptoHasher::info(), JSCryptoHasherPrototypeTableValues, *this);
    JSC_TO_STRING_TAG_WITHOUT_TRANSITION();
}

extern "C" JSC_DECLARE_CUSTOM_GETTER(CryptoHasherClass__getAlgorithms);
extern "C" JSC_DECLARE_HOST_FUNCTION(CryptoHasherClass__hash);

static const HashTableValue JSCryptoHasherConstructorTableValues[] = {
    { "algorithms"_s, static_cast<unsigned>(JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::GetterSetterType, CryptoHasherClass__getAlgorithms, 0 } },
    { "hash"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, CryptoHasherClass__hash, 2 } }
};

void JSCryptoHasherConstructor::finishCreation(VM& vm, JSC::JSGlobalObject* globalObject, JSCryptoHasherPrototype* prototype)
{
    Base::finishCreation(vm, 0, "CryptoHasher"_s, PropertyAdditionMode::WithoutStructureTransition);
    reifyStaticProperties(vm, &JSCryptoHasherConstructor::s_info, JSCryptoHasherConstructorTableValues, *this);
    putDirectWithoutTransition(vm, vm.propertyNames->prototype, prototype, PropertyAttribute::DontEnum | PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly);
    ASSERT(inherits(info()));
}

JSCryptoHasherConstructor::JSCryptoHasherConstructor(JSC::VM& vm, JSC::Structure* structure)
    : Base(vm, structure, construct, construct)
{
}

JSCryptoHasherConstructor* JSCryptoHasherConstructor::create(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure, JSCryptoHasherPrototype* prototype)
{
    JSCryptoHasherConstructor* ptr = new (NotNull, JSC::allocateCell<JSCryptoHasherConstructor>(vm)) JSCryptoHasherConstructor(vm, structure);
    ptr->finishCreation(vm, globalObject, prototype);
    return ptr;
}

JSC::EncodedJSValue JSC_HOST_CALL_ATTRIBUTES JSCryptoHasherConstructor::construct(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame)
{
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    JSC::VM& vm = globalObject->vm();
    JSObject* newTarget = asObject(callFrame->newTarget());
    auto* constructor = globalObject->JSCryptoHasherConstructor();
    Structure* structure = globalObject->JSCryptoHasherStructure();
    if (constructor != newTarget) {
        auto scope = DECLARE_THROW_SCOPE(vm);

        auto* functionGlobalObject = reinterpret_cast<Zig::GlobalObject*>(
            // ShadowRealm functions belong to a different global object.
            getFunctionRealm(globalObject, newTarget));
        RETURN_IF_EXCEPTION(scope, {});
        structure = InternalFunction::createSubclassStructure(
            globalObject,
            newTarget,
            functionGlobalObject->JSCryptoHasherStructure());
    }

    void* ptr = CryptoHasherClass__construct(globalObject, callFrame);

    if (UNLIKELY(!ptr)) {
        return JSValue::encode(JSC::jsUndefined());
    }

    JSCryptoHasher* instance = JSCryptoHasher::create(vm, globalObject, structure, ptr);

    return JSValue::encode(instance);
}

void JSCryptoHasherConstructor::initializeProperties(VM& vm, JSC::JSGlobalObject* globalObject, JSCryptoHasherPrototype* prototype)
{
}

const ClassInfo JSCryptoHasherConstructor::s_info = { "Function"_s, &Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSCryptoHasherConstructor) };

extern "C" EncodedJSValue CryptoHasher__getConstructor(Zig::GlobalObject* globalObject)
{
    return JSValue::encode(globalObject->JSCryptoHasherConstructor());
}

JSCryptoHasher::~JSCryptoHasher()
{
    if (m_ctx) {
        CryptoHasherClass__finalize(m_ctx);
    }
}
void JSCryptoHasher::destroy(JSCell* cell)
{
    static_cast<JSCryptoHasher*>(cell)->JSCryptoHasher::~JSCryptoHasher();
}

const ClassInfo JSCryptoHasher::s_info = { "CryptoHasher"_s, &Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSCryptoHasher) };

void JSCryptoHasher::finishCreation(VM& vm)
{
    Base::finishCreation(vm);
    ASSERT(inherits(info()));
}

JSCryptoHasher* JSCryptoHasher::create(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure, void* ctx)
{
    JSCryptoHasher* ptr = new (NotNull, JSC::allocateCell<JSCryptoHasher>(vm)) JSCryptoHasher(vm, structure, ctx);
    ptr->finishCreation(vm);
    return ptr;
}

extern "C" void* CryptoHasher__fromJS(JSC::EncodedJSValue value)
{
    JSC::JSValue decodedValue = JSC::JSValue::decode(value);
    if (decodedValue.isEmpty() || !decodedValue.isCell())
        return nullptr;

    JSC::JSCell* cell = decodedValue.asCell();
    JSCryptoHasher* object = JSC::jsDynamicCast<JSCryptoHasher*>(cell);

    if (!object)
        return nullptr;

    return object->wrapped();
}

extern "C" bool CryptoHasher__dangerouslySetPtr(JSC::EncodedJSValue value, void* ptr)
{
    JSCryptoHasher* object = JSC::jsDynamicCast<JSCryptoHasher*>(JSValue::decode(value));
    if (!object)
        return false;

    object->m_ctx = ptr;
    return true;
}

extern "C" const size_t CryptoHasher__ptrOffset = JSCryptoHasher::offsetOfWrapped();

void JSCryptoHasher::analyzeHeap(JSCell* cell, HeapAnalyzer& analyzer)
{
    auto* thisObject = jsCast<JSCryptoHasher*>(cell);
    if (void* wrapped = thisObject->wrapped()) {
        // if (thisObject->scriptExecutionContext())
        //     analyzer.setLabelForCell(cell, "url " + thisObject->scriptExecutionContext()->url().string());
    }
    Base::analyzeHeap(cell, analyzer);
}

JSObject* JSCryptoHasher::createConstructor(VM& vm, JSGlobalObject* globalObject, JSValue prototype)
{
    return WebCore::JSCryptoHasherConstructor::create(vm, globalObject, WebCore::JSCryptoHasherConstructor::createStructure(vm, globalObject, globalObject->functionPrototype()), jsCast<WebCore::JSCryptoHasherPrototype*>(prototype));
}

JSObject* JSCryptoHasher::createPrototype(VM& vm, JSDOMGlobalObject* globalObject)
{
    return JSCryptoHasherPrototype::create(vm, globalObject, JSCryptoHasherPrototype::createStructure(vm, globalObject, globalObject->objectPrototype()));
}

extern "C" EncodedJSValue CryptoHasher__create(Zig::GlobalObject* globalObject, void* ptr)
{
    auto& vm = globalObject->vm();
    JSC::Structure* structure = globalObject->JSCryptoHasherStructure();
    JSCryptoHasher* instance = JSCryptoHasher::create(vm, globalObject, structure, ptr);

    return JSValue::encode(instance);
}

template<typename Visitor>
void JSCryptoHasher::visitChildrenImpl(JSCell* cell, Visitor& visitor)
{
    JSCryptoHasher* thisObject = jsCast<JSCryptoHasher*>(cell);
    ASSERT_GC_OBJECT_INHERITS(thisObject, info());
    Base::visitChildren(thisObject, visitor);

    visitor.append(thisObject->m_algorithms);
    visitor.append(thisObject->m_algorithm);
}

DEFINE_VISIT_CHILDREN(JSCryptoHasher);

template<typename Visitor>
void JSCryptoHasher::visitAdditionalChildren(Visitor& visitor)
{
    JSCryptoHasher* thisObject = this;
    ASSERT_GC_OBJECT_INHERITS(thisObject, info());

    visitor.append(thisObject->m_algorithms);
    visitor.append(thisObject->m_algorithm);
    ;
}

DEFINE_VISIT_ADDITIONAL_CHILDREN(JSCryptoHasher);

template<typename Visitor>
void JSCryptoHasher::visitOutputConstraintsImpl(JSCell* cell, Visitor& visitor)
{
    JSCryptoHasher* thisObject = jsCast<JSCryptoHasher*>(cell);
    ASSERT_GC_OBJECT_INHERITS(thisObject, info());
    thisObject->visitAdditionalChildren<Visitor>(visitor);
}

DEFINE_VISIT_OUTPUT_CONSTRAINTS(JSCryptoHasher);
class JSDirentPrototype final : public JSC::JSNonFinalObject {
public:
    using Base = JSC::JSNonFinalObject;

    static JSDirentPrototype* create(JSC::VM& vm, JSGlobalObject* globalObject, JSC::Structure* structure)
    {
        JSDirentPrototype* ptr = new (NotNull, JSC::allocateCell<JSDirentPrototype>(vm)) JSDirentPrototype(vm, globalObject, structure);
        ptr->finishCreation(vm, globalObject);
        return ptr;
    }

    DECLARE_INFO;
    template<typename CellType, JSC::SubspaceAccess>
    static JSC::GCClient::IsoSubspace* subspaceFor(JSC::VM& vm)
    {
        return &vm.plainObjectSpace();
    }
    static JSC::Structure* createStructure(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::JSValue prototype)
    {
        return JSC::Structure::create(vm, globalObject, prototype, JSC::TypeInfo(JSC::ObjectType, StructureFlags), info());
    }

private:
    JSDirentPrototype(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure)
        : Base(vm, structure)
    {
    }

    void finishCreation(JSC::VM&, JSC::JSGlobalObject*);
};

class JSDirentConstructor final : public JSC::InternalFunction {
public:
    using Base = JSC::InternalFunction;
    static JSDirentConstructor* create(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure, JSDirentPrototype* prototype);

    static constexpr unsigned StructureFlags = Base::StructureFlags;
    static constexpr bool needsDestruction = false;

    static JSC::Structure* createStructure(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::JSValue prototype)
    {
        return JSC::Structure::create(vm, globalObject, prototype, JSC::TypeInfo(JSC::InternalFunctionType, StructureFlags), info());
    }

    template<typename, JSC::SubspaceAccess mode> static JSC::GCClient::IsoSubspace* subspaceFor(JSC::VM& vm)
    {
        if constexpr (mode == JSC::SubspaceAccess::Concurrently)
            return nullptr;
        return WebCore::subspaceForImpl<JSDirentConstructor, WebCore::UseCustomHeapCellType::No>(
            vm,
            [](auto& spaces) { return spaces.m_clientSubspaceForDirentConstructor.get(); },
            [](auto& spaces, auto&& space) { spaces.m_clientSubspaceForDirentConstructor = std::forward<decltype(space)>(space); },
            [](auto& spaces) { return spaces.m_subspaceForDirentConstructor.get(); },
            [](auto& spaces, auto&& space) { spaces.m_subspaceForDirentConstructor = std::forward<decltype(space)>(space); });
    }

    void initializeProperties(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSDirentPrototype* prototype);

    // Must be defined for each specialization class.
    static JSC::EncodedJSValue JSC_HOST_CALL_ATTRIBUTES construct(JSC::JSGlobalObject*, JSC::CallFrame*);

    DECLARE_EXPORT_INFO;

private:
    JSDirentConstructor(JSC::VM& vm, JSC::Structure* structure);
    void finishCreation(JSC::VM&, JSC::JSGlobalObject* globalObject, JSDirentPrototype* prototype);
};

extern "C" void* DirentClass__construct(JSC::JSGlobalObject*, JSC::CallFrame*);
JSC_DECLARE_CUSTOM_GETTER(jsDirentConstructor);
extern "C" void DirentClass__finalize(void*);

extern "C" EncodedJSValue DirentPrototype__isBlockDevice(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(DirentPrototype__isBlockDeviceCallback);

extern "C" EncodedJSValue DirentPrototype__isCharacterDevice(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(DirentPrototype__isCharacterDeviceCallback);

extern "C" EncodedJSValue DirentPrototype__isDirectory(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(DirentPrototype__isDirectoryCallback);

extern "C" EncodedJSValue DirentPrototype__isFIFO(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(DirentPrototype__isFIFOCallback);

extern "C" EncodedJSValue DirentPrototype__isFile(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(DirentPrototype__isFileCallback);

extern "C" EncodedJSValue DirentPrototype__isSocket(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(DirentPrototype__isSocketCallback);

extern "C" EncodedJSValue DirentPrototype__isSymbolicLink(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(DirentPrototype__isSymbolicLinkCallback);

extern "C" JSC::EncodedJSValue DirentPrototype__getName(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject);
JSC_DECLARE_CUSTOM_GETTER(DirentPrototype__nameGetterWrap);

STATIC_ASSERT_ISO_SUBSPACE_SHARABLE(JSDirentPrototype, JSDirentPrototype::Base);

static const HashTableValue JSDirentPrototypeTableValues[] = {
    { "isBlockDevice"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, DirentPrototype__isBlockDeviceCallback, 0 } },
    { "isCharacterDevice"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, DirentPrototype__isCharacterDeviceCallback, 0 } },
    { "isDirectory"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, DirentPrototype__isDirectoryCallback, 0 } },
    { "isFIFO"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, DirentPrototype__isFIFOCallback, 0 } },
    { "isFile"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, DirentPrototype__isFileCallback, 0 } },
    { "isSocket"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, DirentPrototype__isSocketCallback, 0 } },
    { "isSymbolicLink"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, DirentPrototype__isSymbolicLinkCallback, 0 } },
    { "name"_s, static_cast<unsigned>(JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::GetterSetterType, DirentPrototype__nameGetterWrap, 0 } }
};

const ClassInfo JSDirentPrototype::s_info = { "Dirent"_s, &Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSDirentPrototype) };

JSC_DEFINE_CUSTOM_GETTER(jsDirentConstructor, (JSGlobalObject * lexicalGlobalObject, EncodedJSValue thisValue, PropertyName))
{
    VM& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    auto* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    auto* prototype = jsDynamicCast<JSDirentPrototype*>(JSValue::decode(thisValue));

    if (UNLIKELY(!prototype))
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    return JSValue::encode(globalObject->JSDirentConstructor());
}

JSC_DEFINE_HOST_FUNCTION(DirentPrototype__isBlockDeviceCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSDirent* thisObject = jsDynamicCast<JSDirent*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return DirentPrototype__isBlockDevice(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_HOST_FUNCTION(DirentPrototype__isCharacterDeviceCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSDirent* thisObject = jsDynamicCast<JSDirent*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return DirentPrototype__isCharacterDevice(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_HOST_FUNCTION(DirentPrototype__isDirectoryCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSDirent* thisObject = jsDynamicCast<JSDirent*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return DirentPrototype__isDirectory(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_HOST_FUNCTION(DirentPrototype__isFIFOCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSDirent* thisObject = jsDynamicCast<JSDirent*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return DirentPrototype__isFIFO(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_HOST_FUNCTION(DirentPrototype__isFileCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSDirent* thisObject = jsDynamicCast<JSDirent*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return DirentPrototype__isFile(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_HOST_FUNCTION(DirentPrototype__isSocketCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSDirent* thisObject = jsDynamicCast<JSDirent*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return DirentPrototype__isSocket(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_HOST_FUNCTION(DirentPrototype__isSymbolicLinkCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSDirent* thisObject = jsDynamicCast<JSDirent*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return DirentPrototype__isSymbolicLink(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_CUSTOM_GETTER(DirentPrototype__nameGetterWrap, (JSGlobalObject * lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    auto& vm = lexicalGlobalObject->vm();
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    JSDirent* thisObject = jsCast<JSDirent*>(JSValue::decode(thisValue));
    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    if (JSValue cachedValue = thisObject->m_name.get())
        return JSValue::encode(cachedValue);

    JSC::JSValue result = JSC::JSValue::decode(
        DirentPrototype__getName(thisObject->wrapped(), globalObject));
    RETURN_IF_EXCEPTION(throwScope, {});
    thisObject->m_name.set(vm, thisObject, result);
    RELEASE_AND_RETURN(throwScope, JSValue::encode(result));
}

extern "C" void DirentPrototype__nameSetCachedValue(JSC::EncodedJSValue thisValue, JSC::JSGlobalObject* globalObject, JSC::EncodedJSValue value)
{
    auto& vm = globalObject->vm();
    auto* thisObject = jsCast<JSDirent*>(JSValue::decode(thisValue));
    thisObject->m_name.set(vm, thisObject, JSValue::decode(value));
}

extern "C" EncodedJSValue DirentPrototype__nameGetCachedValue(JSC::EncodedJSValue thisValue)
{
    auto* thisObject = jsCast<JSDirent*>(JSValue::decode(thisValue));
    return JSValue::encode(thisObject->m_name.get());
}

void JSDirentPrototype::finishCreation(JSC::VM& vm, JSC::JSGlobalObject* globalObject)
{
    Base::finishCreation(vm);
    reifyStaticProperties(vm, JSDirent::info(), JSDirentPrototypeTableValues, *this);
    JSC_TO_STRING_TAG_WITHOUT_TRANSITION();
}

void JSDirentConstructor::finishCreation(VM& vm, JSC::JSGlobalObject* globalObject, JSDirentPrototype* prototype)
{
    Base::finishCreation(vm, 0, "Dirent"_s, PropertyAdditionMode::WithoutStructureTransition);

    putDirectWithoutTransition(vm, vm.propertyNames->prototype, prototype, PropertyAttribute::DontEnum | PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly);
    ASSERT(inherits(info()));
}

JSDirentConstructor::JSDirentConstructor(JSC::VM& vm, JSC::Structure* structure)
    : Base(vm, structure, construct, construct)
{
}

JSDirentConstructor* JSDirentConstructor::create(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure, JSDirentPrototype* prototype)
{
    JSDirentConstructor* ptr = new (NotNull, JSC::allocateCell<JSDirentConstructor>(vm)) JSDirentConstructor(vm, structure);
    ptr->finishCreation(vm, globalObject, prototype);
    return ptr;
}

JSC::EncodedJSValue JSC_HOST_CALL_ATTRIBUTES JSDirentConstructor::construct(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame)
{
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    JSC::VM& vm = globalObject->vm();
    JSObject* newTarget = asObject(callFrame->newTarget());
    auto* constructor = globalObject->JSDirentConstructor();
    Structure* structure = globalObject->JSDirentStructure();
    if (constructor != newTarget) {
        auto scope = DECLARE_THROW_SCOPE(vm);

        auto* functionGlobalObject = reinterpret_cast<Zig::GlobalObject*>(
            // ShadowRealm functions belong to a different global object.
            getFunctionRealm(globalObject, newTarget));
        RETURN_IF_EXCEPTION(scope, {});
        structure = InternalFunction::createSubclassStructure(
            globalObject,
            newTarget,
            functionGlobalObject->JSDirentStructure());
    }

    void* ptr = DirentClass__construct(globalObject, callFrame);

    if (UNLIKELY(!ptr)) {
        return JSValue::encode(JSC::jsUndefined());
    }

    JSDirent* instance = JSDirent::create(vm, globalObject, structure, ptr);

    return JSValue::encode(instance);
}

void JSDirentConstructor::initializeProperties(VM& vm, JSC::JSGlobalObject* globalObject, JSDirentPrototype* prototype)
{
}

const ClassInfo JSDirentConstructor::s_info = { "Function"_s, &Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSDirentConstructor) };

extern "C" EncodedJSValue Dirent__getConstructor(Zig::GlobalObject* globalObject)
{
    return JSValue::encode(globalObject->JSDirentConstructor());
}

JSDirent::~JSDirent()
{
    if (m_ctx) {
        DirentClass__finalize(m_ctx);
    }
}
void JSDirent::destroy(JSCell* cell)
{
    static_cast<JSDirent*>(cell)->JSDirent::~JSDirent();
}

const ClassInfo JSDirent::s_info = { "Dirent"_s, &Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSDirent) };

void JSDirent::finishCreation(VM& vm)
{
    Base::finishCreation(vm);
    ASSERT(inherits(info()));
}

JSDirent* JSDirent::create(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure, void* ctx)
{
    JSDirent* ptr = new (NotNull, JSC::allocateCell<JSDirent>(vm)) JSDirent(vm, structure, ctx);
    ptr->finishCreation(vm);
    return ptr;
}

extern "C" void* Dirent__fromJS(JSC::EncodedJSValue value)
{
    JSC::JSValue decodedValue = JSC::JSValue::decode(value);
    if (decodedValue.isEmpty() || !decodedValue.isCell())
        return nullptr;

    JSC::JSCell* cell = decodedValue.asCell();
    JSDirent* object = JSC::jsDynamicCast<JSDirent*>(cell);

    if (!object)
        return nullptr;

    return object->wrapped();
}

extern "C" bool Dirent__dangerouslySetPtr(JSC::EncodedJSValue value, void* ptr)
{
    JSDirent* object = JSC::jsDynamicCast<JSDirent*>(JSValue::decode(value));
    if (!object)
        return false;

    object->m_ctx = ptr;
    return true;
}

extern "C" const size_t Dirent__ptrOffset = JSDirent::offsetOfWrapped();

void JSDirent::analyzeHeap(JSCell* cell, HeapAnalyzer& analyzer)
{
    auto* thisObject = jsCast<JSDirent*>(cell);
    if (void* wrapped = thisObject->wrapped()) {
        // if (thisObject->scriptExecutionContext())
        //     analyzer.setLabelForCell(cell, "url " + thisObject->scriptExecutionContext()->url().string());
    }
    Base::analyzeHeap(cell, analyzer);
}

JSObject* JSDirent::createConstructor(VM& vm, JSGlobalObject* globalObject, JSValue prototype)
{
    return WebCore::JSDirentConstructor::create(vm, globalObject, WebCore::JSDirentConstructor::createStructure(vm, globalObject, globalObject->functionPrototype()), jsCast<WebCore::JSDirentPrototype*>(prototype));
}

JSObject* JSDirent::createPrototype(VM& vm, JSDOMGlobalObject* globalObject)
{
    return JSDirentPrototype::create(vm, globalObject, JSDirentPrototype::createStructure(vm, globalObject, globalObject->objectPrototype()));
}

extern "C" EncodedJSValue Dirent__create(Zig::GlobalObject* globalObject, void* ptr)
{
    auto& vm = globalObject->vm();
    JSC::Structure* structure = globalObject->JSDirentStructure();
    JSDirent* instance = JSDirent::create(vm, globalObject, structure, ptr);

    return JSValue::encode(instance);
}

template<typename Visitor>
void JSDirent::visitChildrenImpl(JSCell* cell, Visitor& visitor)
{
    JSDirent* thisObject = jsCast<JSDirent*>(cell);
    ASSERT_GC_OBJECT_INHERITS(thisObject, info());
    Base::visitChildren(thisObject, visitor);

    visitor.append(thisObject->m_name);
}

DEFINE_VISIT_CHILDREN(JSDirent);

template<typename Visitor>
void JSDirent::visitAdditionalChildren(Visitor& visitor)
{
    JSDirent* thisObject = this;
    ASSERT_GC_OBJECT_INHERITS(thisObject, info());

    visitor.append(thisObject->m_name);
    ;
}

DEFINE_VISIT_ADDITIONAL_CHILDREN(JSDirent);

template<typename Visitor>
void JSDirent::visitOutputConstraintsImpl(JSCell* cell, Visitor& visitor)
{
    JSDirent* thisObject = jsCast<JSDirent*>(cell);
    ASSERT_GC_OBJECT_INHERITS(thisObject, info());
    thisObject->visitAdditionalChildren<Visitor>(visitor);
}

DEFINE_VISIT_OUTPUT_CONSTRAINTS(JSDirent);
class JSExpectPrototype final : public JSC::JSNonFinalObject {
public:
    using Base = JSC::JSNonFinalObject;

    static JSExpectPrototype* create(JSC::VM& vm, JSGlobalObject* globalObject, JSC::Structure* structure)
    {
        JSExpectPrototype* ptr = new (NotNull, JSC::allocateCell<JSExpectPrototype>(vm)) JSExpectPrototype(vm, globalObject, structure);
        ptr->finishCreation(vm, globalObject);
        return ptr;
    }

    DECLARE_INFO;
    template<typename CellType, JSC::SubspaceAccess>
    static JSC::GCClient::IsoSubspace* subspaceFor(JSC::VM& vm)
    {
        return &vm.plainObjectSpace();
    }
    static JSC::Structure* createStructure(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::JSValue prototype)
    {
        return JSC::Structure::create(vm, globalObject, prototype, JSC::TypeInfo(JSC::ObjectType, StructureFlags), info());
    }

private:
    JSExpectPrototype(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure)
        : Base(vm, structure)
    {
    }

    void finishCreation(JSC::VM&, JSC::JSGlobalObject*);
};

class JSExpectConstructor final : public JSC::InternalFunction {
public:
    using Base = JSC::InternalFunction;
    static JSExpectConstructor* create(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure, JSExpectPrototype* prototype);

    static constexpr unsigned StructureFlags = Base::StructureFlags;
    static constexpr bool needsDestruction = false;

    static JSC::Structure* createStructure(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::JSValue prototype)
    {
        return JSC::Structure::create(vm, globalObject, prototype, JSC::TypeInfo(JSC::InternalFunctionType, StructureFlags), info());
    }

    template<typename, JSC::SubspaceAccess mode> static JSC::GCClient::IsoSubspace* subspaceFor(JSC::VM& vm)
    {
        if constexpr (mode == JSC::SubspaceAccess::Concurrently)
            return nullptr;
        return WebCore::subspaceForImpl<JSExpectConstructor, WebCore::UseCustomHeapCellType::No>(
            vm,
            [](auto& spaces) { return spaces.m_clientSubspaceForExpectConstructor.get(); },
            [](auto& spaces, auto&& space) { spaces.m_clientSubspaceForExpectConstructor = std::forward<decltype(space)>(space); },
            [](auto& spaces) { return spaces.m_subspaceForExpectConstructor.get(); },
            [](auto& spaces, auto&& space) { spaces.m_subspaceForExpectConstructor = std::forward<decltype(space)>(space); });
    }

    void initializeProperties(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSExpectPrototype* prototype);

    // Must be defined for each specialization class.
    static JSC::EncodedJSValue JSC_HOST_CALL_ATTRIBUTES construct(JSC::JSGlobalObject*, JSC::CallFrame*);

    DECLARE_EXPORT_INFO;

private:
    JSExpectConstructor(JSC::VM& vm, JSC::Structure* structure);
    void finishCreation(JSC::VM&, JSC::JSGlobalObject* globalObject, JSExpectPrototype* prototype);
};

extern "C" void* ExpectClass__construct(JSC::JSGlobalObject*, JSC::CallFrame*);
JSC_DECLARE_CUSTOM_GETTER(jsExpectConstructor);
extern "C" void ExpectClass__finalize(void*);
extern "C" JSC_DECLARE_HOST_FUNCTION(ExpectClass__call);

extern "C" JSC::EncodedJSValue ExpectPrototype__getNot(void* ptr, JSC::EncodedJSValue thisValue, JSC::JSGlobalObject* lexicalGlobalObject);
JSC_DECLARE_CUSTOM_GETTER(ExpectPrototype__notGetterWrap);

extern "C" JSC::EncodedJSValue ExpectPrototype__getRejects(void* ptr, JSC::EncodedJSValue thisValue, JSC::JSGlobalObject* lexicalGlobalObject);
JSC_DECLARE_CUSTOM_GETTER(ExpectPrototype__rejectsGetterWrap);

extern "C" JSC::EncodedJSValue ExpectPrototype__getResolves(void* ptr, JSC::EncodedJSValue thisValue, JSC::JSGlobalObject* lexicalGlobalObject);
JSC_DECLARE_CUSTOM_GETTER(ExpectPrototype__resolvesGetterWrap);

extern "C" EncodedJSValue ExpectPrototype__toBe(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(ExpectPrototype__toBeCallback);

extern "C" EncodedJSValue ExpectPrototype__toBeCloseTo(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(ExpectPrototype__toBeCloseToCallback);

extern "C" EncodedJSValue ExpectPrototype__toBeDefined(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(ExpectPrototype__toBeDefinedCallback);

extern "C" EncodedJSValue ExpectPrototype__toBeEven(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(ExpectPrototype__toBeEvenCallback);

extern "C" EncodedJSValue ExpectPrototype__toBeFalsy(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(ExpectPrototype__toBeFalsyCallback);

extern "C" EncodedJSValue ExpectPrototype__toBeGreaterThan(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(ExpectPrototype__toBeGreaterThanCallback);

extern "C" EncodedJSValue ExpectPrototype__toBeGreaterThanOrEqual(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(ExpectPrototype__toBeGreaterThanOrEqualCallback);

extern "C" EncodedJSValue ExpectPrototype__toBeInstanceOf(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(ExpectPrototype__toBeInstanceOfCallback);

extern "C" EncodedJSValue ExpectPrototype__toBeLessThan(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(ExpectPrototype__toBeLessThanCallback);

extern "C" EncodedJSValue ExpectPrototype__toBeLessThanOrEqual(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(ExpectPrototype__toBeLessThanOrEqualCallback);

extern "C" EncodedJSValue ExpectPrototype__toBeNaN(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(ExpectPrototype__toBeNaNCallback);

extern "C" EncodedJSValue ExpectPrototype__toBeNull(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(ExpectPrototype__toBeNullCallback);

extern "C" EncodedJSValue ExpectPrototype__toBeOdd(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(ExpectPrototype__toBeOddCallback);

extern "C" EncodedJSValue ExpectPrototype__toBeTruthy(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(ExpectPrototype__toBeTruthyCallback);

extern "C" EncodedJSValue ExpectPrototype__toBeUndefined(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(ExpectPrototype__toBeUndefinedCallback);

extern "C" EncodedJSValue ExpectPrototype__toContain(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(ExpectPrototype__toContainCallback);

extern "C" EncodedJSValue ExpectPrototype__toContainEqual(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(ExpectPrototype__toContainEqualCallback);

extern "C" EncodedJSValue ExpectPrototype__toEqual(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(ExpectPrototype__toEqualCallback);

extern "C" EncodedJSValue ExpectPrototype__toHaveBeenCalledTimes(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(ExpectPrototype__toHaveBeenCalledTimesCallback);

extern "C" EncodedJSValue ExpectPrototype__toHaveBeenCalledWith(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(ExpectPrototype__toHaveBeenCalledWithCallback);

extern "C" EncodedJSValue ExpectPrototype__toHaveBeenLastCalledWith(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(ExpectPrototype__toHaveBeenLastCalledWithCallback);

extern "C" EncodedJSValue ExpectPrototype__toHaveBeenNthCalledWith(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(ExpectPrototype__toHaveBeenNthCalledWithCallback);

extern "C" EncodedJSValue ExpectPrototype__toHaveLastReturnedWith(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(ExpectPrototype__toHaveLastReturnedWithCallback);

extern "C" EncodedJSValue ExpectPrototype__toHaveLength(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(ExpectPrototype__toHaveLengthCallback);

extern "C" EncodedJSValue ExpectPrototype__toHaveNthReturnedWith(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(ExpectPrototype__toHaveNthReturnedWithCallback);

extern "C" EncodedJSValue ExpectPrototype__toHaveProperty(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(ExpectPrototype__toHavePropertyCallback);

extern "C" EncodedJSValue ExpectPrototype__toHaveReturnedTimes(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(ExpectPrototype__toHaveReturnedTimesCallback);

extern "C" EncodedJSValue ExpectPrototype__toHaveReturnedWith(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(ExpectPrototype__toHaveReturnedWithCallback);

extern "C" EncodedJSValue ExpectPrototype__toMatch(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(ExpectPrototype__toMatchCallback);

extern "C" EncodedJSValue ExpectPrototype__toMatchInlineSnapshot(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(ExpectPrototype__toMatchInlineSnapshotCallback);

extern "C" EncodedJSValue ExpectPrototype__toMatchObject(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(ExpectPrototype__toMatchObjectCallback);

extern "C" EncodedJSValue ExpectPrototype__toMatchSnapshot(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(ExpectPrototype__toMatchSnapshotCallback);

extern "C" EncodedJSValue ExpectPrototype__toStrictEqual(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(ExpectPrototype__toStrictEqualCallback);

extern "C" EncodedJSValue ExpectPrototype__toThrow(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(ExpectPrototype__toThrowCallback);

extern "C" EncodedJSValue ExpectPrototype__toThrowErrorMatchingInlineSnapshot(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(ExpectPrototype__toThrowErrorMatchingInlineSnapshotCallback);

extern "C" EncodedJSValue ExpectPrototype__toThrowErrorMatchingSnapshot(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(ExpectPrototype__toThrowErrorMatchingSnapshotCallback);

STATIC_ASSERT_ISO_SUBSPACE_SHARABLE(JSExpectPrototype, JSExpectPrototype::Base);

static const HashTableValue JSExpectPrototypeTableValues[] = {
    { "not"_s, static_cast<unsigned>(JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::GetterSetterType, ExpectPrototype__notGetterWrap, 0 } },
    { "rejects"_s, static_cast<unsigned>(JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::GetterSetterType, ExpectPrototype__rejectsGetterWrap, 0 } },
    { "resolves"_s, static_cast<unsigned>(JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::GetterSetterType, ExpectPrototype__resolvesGetterWrap, 0 } },
    { "toBe"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, ExpectPrototype__toBeCallback, 1 } },
    { "toBeCloseTo"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, ExpectPrototype__toBeCloseToCallback, 1 } },
    { "toBeDefined"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, ExpectPrototype__toBeDefinedCallback, 0 } },
    { "toBeEven"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, ExpectPrototype__toBeEvenCallback, 0 } },
    { "toBeFalsy"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, ExpectPrototype__toBeFalsyCallback, 0 } },
    { "toBeGreaterThan"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, ExpectPrototype__toBeGreaterThanCallback, 1 } },
    { "toBeGreaterThanOrEqual"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, ExpectPrototype__toBeGreaterThanOrEqualCallback, 1 } },
    { "toBeInstanceOf"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, ExpectPrototype__toBeInstanceOfCallback, 1 } },
    { "toBeLessThan"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, ExpectPrototype__toBeLessThanCallback, 1 } },
    { "toBeLessThanOrEqual"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, ExpectPrototype__toBeLessThanOrEqualCallback, 1 } },
    { "toBeNaN"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, ExpectPrototype__toBeNaNCallback, 0 } },
    { "toBeNull"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, ExpectPrototype__toBeNullCallback, 0 } },
    { "toBeOdd"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, ExpectPrototype__toBeOddCallback, 0 } },
    { "toBeTruthy"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, ExpectPrototype__toBeTruthyCallback, 0 } },
    { "toBeUndefined"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, ExpectPrototype__toBeUndefinedCallback, 0 } },
    { "toContain"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, ExpectPrototype__toContainCallback, 1 } },
    { "toContainEqual"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, ExpectPrototype__toContainEqualCallback, 1 } },
    { "toEqual"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, ExpectPrototype__toEqualCallback, 1 } },
    { "toHaveBeenCalledTimes"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, ExpectPrototype__toHaveBeenCalledTimesCallback, 1 } },
    { "toHaveBeenCalledWith"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, ExpectPrototype__toHaveBeenCalledWithCallback, 1 } },
    { "toHaveBeenLastCalledWith"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, ExpectPrototype__toHaveBeenLastCalledWithCallback, 1 } },
    { "toHaveBeenNthCalledWith"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, ExpectPrototype__toHaveBeenNthCalledWithCallback, 1 } },
    { "toHaveLastReturnedWith"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, ExpectPrototype__toHaveLastReturnedWithCallback, 1 } },
    { "toHaveLength"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, ExpectPrototype__toHaveLengthCallback, 1 } },
    { "toHaveNthReturnedWith"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, ExpectPrototype__toHaveNthReturnedWithCallback, 1 } },
    { "toHaveProperty"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, ExpectPrototype__toHavePropertyCallback, 2 } },
    { "toHaveReturnedTimes"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, ExpectPrototype__toHaveReturnedTimesCallback, 1 } },
    { "toHaveReturnedWith"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, ExpectPrototype__toHaveReturnedWithCallback, 1 } },
    { "toMatch"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, ExpectPrototype__toMatchCallback, 1 } },
    { "toMatchInlineSnapshot"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, ExpectPrototype__toMatchInlineSnapshotCallback, 1 } },
    { "toMatchObject"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, ExpectPrototype__toMatchObjectCallback, 1 } },
    { "toMatchSnapshot"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, ExpectPrototype__toMatchSnapshotCallback, 1 } },
    { "toStrictEqual"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, ExpectPrototype__toStrictEqualCallback, 1 } },
    { "toThrow"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, ExpectPrototype__toThrowCallback, 1 } },
    { "toThrowErrorMatchingInlineSnapshot"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, ExpectPrototype__toThrowErrorMatchingInlineSnapshotCallback, 1 } },
    { "toThrowErrorMatchingSnapshot"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, ExpectPrototype__toThrowErrorMatchingSnapshotCallback, 1 } }
};

const ClassInfo JSExpectPrototype::s_info = { "Expect"_s, &Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSExpectPrototype) };

JSC_DEFINE_CUSTOM_GETTER(jsExpectConstructor, (JSGlobalObject * lexicalGlobalObject, EncodedJSValue thisValue, PropertyName))
{
    VM& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    auto* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    auto* prototype = jsDynamicCast<JSExpectPrototype*>(JSValue::decode(thisValue));

    if (UNLIKELY(!prototype))
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    return JSValue::encode(globalObject->JSExpectConstructor());
}

JSC_DEFINE_CUSTOM_GETTER(ExpectPrototype__notGetterWrap, (JSGlobalObject * lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    auto& vm = lexicalGlobalObject->vm();
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    JSExpect* thisObject = jsCast<JSExpect*>(JSValue::decode(thisValue));
    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);
    JSC::EncodedJSValue result = ExpectPrototype__getNot(thisObject->wrapped(), thisValue, globalObject);
    RETURN_IF_EXCEPTION(throwScope, {});
    RELEASE_AND_RETURN(throwScope, result);
}

JSC_DEFINE_CUSTOM_GETTER(ExpectPrototype__rejectsGetterWrap, (JSGlobalObject * lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    auto& vm = lexicalGlobalObject->vm();
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    JSExpect* thisObject = jsCast<JSExpect*>(JSValue::decode(thisValue));
    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);
    JSC::EncodedJSValue result = ExpectPrototype__getRejects(thisObject->wrapped(), thisValue, globalObject);
    RETURN_IF_EXCEPTION(throwScope, {});
    RELEASE_AND_RETURN(throwScope, result);
}

JSC_DEFINE_CUSTOM_GETTER(ExpectPrototype__resolvesGetterWrap, (JSGlobalObject * lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    auto& vm = lexicalGlobalObject->vm();
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    JSExpect* thisObject = jsCast<JSExpect*>(JSValue::decode(thisValue));
    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);
    JSC::EncodedJSValue result = ExpectPrototype__getResolves(thisObject->wrapped(), thisValue, globalObject);
    RETURN_IF_EXCEPTION(throwScope, {});
    RELEASE_AND_RETURN(throwScope, result);
}

JSC_DEFINE_HOST_FUNCTION(ExpectPrototype__toBeCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSExpect* thisObject = jsDynamicCast<JSExpect*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return ExpectPrototype__toBe(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_HOST_FUNCTION(ExpectPrototype__toBeCloseToCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSExpect* thisObject = jsDynamicCast<JSExpect*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return ExpectPrototype__toBeCloseTo(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_HOST_FUNCTION(ExpectPrototype__toBeDefinedCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSExpect* thisObject = jsDynamicCast<JSExpect*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return ExpectPrototype__toBeDefined(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_HOST_FUNCTION(ExpectPrototype__toBeEvenCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSExpect* thisObject = jsDynamicCast<JSExpect*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return ExpectPrototype__toBeEven(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_HOST_FUNCTION(ExpectPrototype__toBeFalsyCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSExpect* thisObject = jsDynamicCast<JSExpect*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return ExpectPrototype__toBeFalsy(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_HOST_FUNCTION(ExpectPrototype__toBeGreaterThanCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSExpect* thisObject = jsDynamicCast<JSExpect*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return ExpectPrototype__toBeGreaterThan(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_HOST_FUNCTION(ExpectPrototype__toBeGreaterThanOrEqualCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSExpect* thisObject = jsDynamicCast<JSExpect*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return ExpectPrototype__toBeGreaterThanOrEqual(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_HOST_FUNCTION(ExpectPrototype__toBeInstanceOfCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSExpect* thisObject = jsDynamicCast<JSExpect*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return ExpectPrototype__toBeInstanceOf(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_HOST_FUNCTION(ExpectPrototype__toBeLessThanCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSExpect* thisObject = jsDynamicCast<JSExpect*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return ExpectPrototype__toBeLessThan(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_HOST_FUNCTION(ExpectPrototype__toBeLessThanOrEqualCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSExpect* thisObject = jsDynamicCast<JSExpect*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return ExpectPrototype__toBeLessThanOrEqual(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_HOST_FUNCTION(ExpectPrototype__toBeNaNCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSExpect* thisObject = jsDynamicCast<JSExpect*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return ExpectPrototype__toBeNaN(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_HOST_FUNCTION(ExpectPrototype__toBeNullCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSExpect* thisObject = jsDynamicCast<JSExpect*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return ExpectPrototype__toBeNull(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_HOST_FUNCTION(ExpectPrototype__toBeOddCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSExpect* thisObject = jsDynamicCast<JSExpect*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return ExpectPrototype__toBeOdd(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_HOST_FUNCTION(ExpectPrototype__toBeTruthyCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSExpect* thisObject = jsDynamicCast<JSExpect*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return ExpectPrototype__toBeTruthy(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_HOST_FUNCTION(ExpectPrototype__toBeUndefinedCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSExpect* thisObject = jsDynamicCast<JSExpect*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return ExpectPrototype__toBeUndefined(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_HOST_FUNCTION(ExpectPrototype__toContainCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSExpect* thisObject = jsDynamicCast<JSExpect*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return ExpectPrototype__toContain(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_HOST_FUNCTION(ExpectPrototype__toContainEqualCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSExpect* thisObject = jsDynamicCast<JSExpect*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return ExpectPrototype__toContainEqual(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_HOST_FUNCTION(ExpectPrototype__toEqualCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSExpect* thisObject = jsDynamicCast<JSExpect*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return ExpectPrototype__toEqual(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_HOST_FUNCTION(ExpectPrototype__toHaveBeenCalledTimesCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSExpect* thisObject = jsDynamicCast<JSExpect*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return ExpectPrototype__toHaveBeenCalledTimes(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_HOST_FUNCTION(ExpectPrototype__toHaveBeenCalledWithCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSExpect* thisObject = jsDynamicCast<JSExpect*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return ExpectPrototype__toHaveBeenCalledWith(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_HOST_FUNCTION(ExpectPrototype__toHaveBeenLastCalledWithCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSExpect* thisObject = jsDynamicCast<JSExpect*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return ExpectPrototype__toHaveBeenLastCalledWith(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_HOST_FUNCTION(ExpectPrototype__toHaveBeenNthCalledWithCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSExpect* thisObject = jsDynamicCast<JSExpect*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return ExpectPrototype__toHaveBeenNthCalledWith(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_HOST_FUNCTION(ExpectPrototype__toHaveLastReturnedWithCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSExpect* thisObject = jsDynamicCast<JSExpect*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return ExpectPrototype__toHaveLastReturnedWith(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_HOST_FUNCTION(ExpectPrototype__toHaveLengthCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSExpect* thisObject = jsDynamicCast<JSExpect*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return ExpectPrototype__toHaveLength(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_HOST_FUNCTION(ExpectPrototype__toHaveNthReturnedWithCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSExpect* thisObject = jsDynamicCast<JSExpect*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return ExpectPrototype__toHaveNthReturnedWith(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_HOST_FUNCTION(ExpectPrototype__toHavePropertyCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSExpect* thisObject = jsDynamicCast<JSExpect*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return ExpectPrototype__toHaveProperty(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_HOST_FUNCTION(ExpectPrototype__toHaveReturnedTimesCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSExpect* thisObject = jsDynamicCast<JSExpect*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return ExpectPrototype__toHaveReturnedTimes(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_HOST_FUNCTION(ExpectPrototype__toHaveReturnedWithCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSExpect* thisObject = jsDynamicCast<JSExpect*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return ExpectPrototype__toHaveReturnedWith(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_HOST_FUNCTION(ExpectPrototype__toMatchCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSExpect* thisObject = jsDynamicCast<JSExpect*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return ExpectPrototype__toMatch(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_HOST_FUNCTION(ExpectPrototype__toMatchInlineSnapshotCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSExpect* thisObject = jsDynamicCast<JSExpect*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return ExpectPrototype__toMatchInlineSnapshot(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_HOST_FUNCTION(ExpectPrototype__toMatchObjectCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSExpect* thisObject = jsDynamicCast<JSExpect*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return ExpectPrototype__toMatchObject(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_HOST_FUNCTION(ExpectPrototype__toMatchSnapshotCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSExpect* thisObject = jsDynamicCast<JSExpect*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return ExpectPrototype__toMatchSnapshot(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_HOST_FUNCTION(ExpectPrototype__toStrictEqualCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSExpect* thisObject = jsDynamicCast<JSExpect*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return ExpectPrototype__toStrictEqual(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_HOST_FUNCTION(ExpectPrototype__toThrowCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSExpect* thisObject = jsDynamicCast<JSExpect*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return ExpectPrototype__toThrow(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_HOST_FUNCTION(ExpectPrototype__toThrowErrorMatchingInlineSnapshotCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSExpect* thisObject = jsDynamicCast<JSExpect*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return ExpectPrototype__toThrowErrorMatchingInlineSnapshot(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_HOST_FUNCTION(ExpectPrototype__toThrowErrorMatchingSnapshotCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSExpect* thisObject = jsDynamicCast<JSExpect*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return ExpectPrototype__toThrowErrorMatchingSnapshot(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

extern "C" void ExpectPrototype__capturedValueSetCachedValue(JSC::EncodedJSValue thisValue, JSC::JSGlobalObject* globalObject, JSC::EncodedJSValue value)
{
    auto& vm = globalObject->vm();
    auto* thisObject = jsCast<JSExpect*>(JSValue::decode(thisValue));
    thisObject->m_capturedValue.set(vm, thisObject, JSValue::decode(value));
}

extern "C" EncodedJSValue ExpectPrototype__capturedValueGetCachedValue(JSC::EncodedJSValue thisValue)
{
    auto* thisObject = jsCast<JSExpect*>(JSValue::decode(thisValue));
    return JSValue::encode(thisObject->m_capturedValue.get());
}

extern "C" void ExpectPrototype__resultValueSetCachedValue(JSC::EncodedJSValue thisValue, JSC::JSGlobalObject* globalObject, JSC::EncodedJSValue value)
{
    auto& vm = globalObject->vm();
    auto* thisObject = jsCast<JSExpect*>(JSValue::decode(thisValue));
    thisObject->m_resultValue.set(vm, thisObject, JSValue::decode(value));
}

extern "C" EncodedJSValue ExpectPrototype__resultValueGetCachedValue(JSC::EncodedJSValue thisValue)
{
    auto* thisObject = jsCast<JSExpect*>(JSValue::decode(thisValue));
    return JSValue::encode(thisObject->m_resultValue.get());
}

void JSExpectPrototype::finishCreation(JSC::VM& vm, JSC::JSGlobalObject* globalObject)
{
    Base::finishCreation(vm);
    reifyStaticProperties(vm, JSExpect::info(), JSExpectPrototypeTableValues, *this);
    JSC_TO_STRING_TAG_WITHOUT_TRANSITION();
}

extern "C" JSC_DECLARE_HOST_FUNCTION(ExpectClass__addSnapshotSerializer);
extern "C" JSC_DECLARE_HOST_FUNCTION(ExpectClass__any);
extern "C" JSC_DECLARE_HOST_FUNCTION(ExpectClass__anything);
extern "C" JSC_DECLARE_HOST_FUNCTION(ExpectClass__arrayContaining);
extern "C" JSC_DECLARE_HOST_FUNCTION(ExpectClass__assertions);
extern "C" JSC_DECLARE_HOST_FUNCTION(ExpectClass__extend);
extern "C" JSC_DECLARE_HOST_FUNCTION(ExpectClass__hasAssertions);
extern "C" JSC_DECLARE_CUSTOM_GETTER(ExpectClass__getStaticNot);
extern "C" JSC_DECLARE_HOST_FUNCTION(ExpectClass__objectContaining);
extern "C" JSC_DECLARE_CUSTOM_GETTER(ExpectClass__getStaticRejects);
extern "C" JSC_DECLARE_CUSTOM_GETTER(ExpectClass__getStaticResolves);
extern "C" JSC_DECLARE_HOST_FUNCTION(ExpectClass__stringContaining);
extern "C" JSC_DECLARE_HOST_FUNCTION(ExpectClass__stringMatching);

static const HashTableValue JSExpectConstructorTableValues[] = {
    { "addSnapshotSerializer"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, ExpectClass__addSnapshotSerializer, 1 } },
    { "any"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, ExpectClass__any, 1 } },
    { "anything"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, ExpectClass__anything, 1 } },
    { "arrayContaining"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, ExpectClass__arrayContaining, 1 } },
    { "assertions"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, ExpectClass__assertions, 1 } },
    { "extend"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, ExpectClass__extend, 1 } },
    { "hasAssertions"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, ExpectClass__hasAssertions, 1 } },
    { "not"_s, static_cast<unsigned>(JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::GetterSetterType, ExpectClass__getStaticNot, 0 } },
    { "objectContaining"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, ExpectClass__objectContaining, 1 } },
    { "rejects"_s, static_cast<unsigned>(JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::GetterSetterType, ExpectClass__getStaticRejects, 0 } },
    { "resolves"_s, static_cast<unsigned>(JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::GetterSetterType, ExpectClass__getStaticResolves, 0 } },
    { "stringContaining"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, ExpectClass__stringContaining, 1 } },
    { "stringMatching"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, ExpectClass__stringMatching, 1 } }
};

void JSExpectConstructor::finishCreation(VM& vm, JSC::JSGlobalObject* globalObject, JSExpectPrototype* prototype)
{
    Base::finishCreation(vm, 0, "Expect"_s, PropertyAdditionMode::WithoutStructureTransition);
    reifyStaticProperties(vm, &JSExpectConstructor::s_info, JSExpectConstructorTableValues, *this);
    putDirectWithoutTransition(vm, vm.propertyNames->prototype, prototype, PropertyAttribute::DontEnum | PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly);
    ASSERT(inherits(info()));
}

JSExpectConstructor::JSExpectConstructor(JSC::VM& vm, JSC::Structure* structure)
    : Base(vm, structure, ExpectClass__call, construct)
{
}

JSExpectConstructor* JSExpectConstructor::create(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure, JSExpectPrototype* prototype)
{
    JSExpectConstructor* ptr = new (NotNull, JSC::allocateCell<JSExpectConstructor>(vm)) JSExpectConstructor(vm, structure);
    ptr->finishCreation(vm, globalObject, prototype);
    return ptr;
}

JSC::EncodedJSValue JSC_HOST_CALL_ATTRIBUTES JSExpectConstructor::construct(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame)
{
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    JSC::VM& vm = globalObject->vm();
    JSObject* newTarget = asObject(callFrame->newTarget());
    auto* constructor = globalObject->JSExpectConstructor();
    Structure* structure = globalObject->JSExpectStructure();
    if (constructor != newTarget) {
        auto scope = DECLARE_THROW_SCOPE(vm);

        auto* functionGlobalObject = reinterpret_cast<Zig::GlobalObject*>(
            // ShadowRealm functions belong to a different global object.
            getFunctionRealm(globalObject, newTarget));
        RETURN_IF_EXCEPTION(scope, {});
        structure = InternalFunction::createSubclassStructure(
            globalObject,
            newTarget,
            functionGlobalObject->JSExpectStructure());
    }

    void* ptr = ExpectClass__construct(globalObject, callFrame);

    if (UNLIKELY(!ptr)) {
        return JSValue::encode(JSC::jsUndefined());
    }

    JSExpect* instance = JSExpect::create(vm, globalObject, structure, ptr);

    return JSValue::encode(instance);
}

void JSExpectConstructor::initializeProperties(VM& vm, JSC::JSGlobalObject* globalObject, JSExpectPrototype* prototype)
{
}

const ClassInfo JSExpectConstructor::s_info = { "Function"_s, &Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSExpectConstructor) };

extern "C" EncodedJSValue Expect__getConstructor(Zig::GlobalObject* globalObject)
{
    return JSValue::encode(globalObject->JSExpectConstructor());
}

JSExpect::~JSExpect()
{
    if (m_ctx) {
        ExpectClass__finalize(m_ctx);
    }
}
void JSExpect::destroy(JSCell* cell)
{
    static_cast<JSExpect*>(cell)->JSExpect::~JSExpect();
}

const ClassInfo JSExpect::s_info = { "Expect"_s, &Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSExpect) };

void JSExpect::finishCreation(VM& vm)
{
    Base::finishCreation(vm);
    ASSERT(inherits(info()));
}

JSExpect* JSExpect::create(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure, void* ctx)
{
    JSExpect* ptr = new (NotNull, JSC::allocateCell<JSExpect>(vm)) JSExpect(vm, structure, ctx);
    ptr->finishCreation(vm);
    return ptr;
}

extern "C" void* Expect__fromJS(JSC::EncodedJSValue value)
{
    JSC::JSValue decodedValue = JSC::JSValue::decode(value);
    if (decodedValue.isEmpty() || !decodedValue.isCell())
        return nullptr;

    JSC::JSCell* cell = decodedValue.asCell();
    JSExpect* object = JSC::jsDynamicCast<JSExpect*>(cell);

    if (!object)
        return nullptr;

    return object->wrapped();
}

extern "C" bool Expect__dangerouslySetPtr(JSC::EncodedJSValue value, void* ptr)
{
    JSExpect* object = JSC::jsDynamicCast<JSExpect*>(JSValue::decode(value));
    if (!object)
        return false;

    object->m_ctx = ptr;
    return true;
}

extern "C" const size_t Expect__ptrOffset = JSExpect::offsetOfWrapped();

void JSExpect::analyzeHeap(JSCell* cell, HeapAnalyzer& analyzer)
{
    auto* thisObject = jsCast<JSExpect*>(cell);
    if (void* wrapped = thisObject->wrapped()) {
        // if (thisObject->scriptExecutionContext())
        //     analyzer.setLabelForCell(cell, "url " + thisObject->scriptExecutionContext()->url().string());
    }
    Base::analyzeHeap(cell, analyzer);
}

JSObject* JSExpect::createConstructor(VM& vm, JSGlobalObject* globalObject, JSValue prototype)
{
    return WebCore::JSExpectConstructor::create(vm, globalObject, WebCore::JSExpectConstructor::createStructure(vm, globalObject, globalObject->functionPrototype()), jsCast<WebCore::JSExpectPrototype*>(prototype));
}

JSObject* JSExpect::createPrototype(VM& vm, JSDOMGlobalObject* globalObject)
{
    return JSExpectPrototype::create(vm, globalObject, JSExpectPrototype::createStructure(vm, globalObject, globalObject->objectPrototype()));
}

extern "C" EncodedJSValue Expect__create(Zig::GlobalObject* globalObject, void* ptr)
{
    auto& vm = globalObject->vm();
    JSC::Structure* structure = globalObject->JSExpectStructure();
    JSExpect* instance = JSExpect::create(vm, globalObject, structure, ptr);

    return JSValue::encode(instance);
}

template<typename Visitor>
void JSExpect::visitChildrenImpl(JSCell* cell, Visitor& visitor)
{
    JSExpect* thisObject = jsCast<JSExpect*>(cell);
    ASSERT_GC_OBJECT_INHERITS(thisObject, info());
    Base::visitChildren(thisObject, visitor);
    visitor.append(thisObject->m_capturedValue);
    visitor.append(thisObject->m_resultValue);
}

DEFINE_VISIT_CHILDREN(JSExpect);

template<typename Visitor>
void JSExpect::visitAdditionalChildren(Visitor& visitor)
{
    JSExpect* thisObject = this;
    ASSERT_GC_OBJECT_INHERITS(thisObject, info());
    visitor.append(thisObject->m_capturedValue);
    visitor.append(thisObject->m_resultValue);

    ;
}

DEFINE_VISIT_ADDITIONAL_CHILDREN(JSExpect);

template<typename Visitor>
void JSExpect::visitOutputConstraintsImpl(JSCell* cell, Visitor& visitor)
{
    JSExpect* thisObject = jsCast<JSExpect*>(cell);
    ASSERT_GC_OBJECT_INHERITS(thisObject, info());
    thisObject->visitAdditionalChildren<Visitor>(visitor);
}

DEFINE_VISIT_OUTPUT_CONSTRAINTS(JSExpect);
class JSExpectAnyPrototype final : public JSC::JSNonFinalObject {
public:
    using Base = JSC::JSNonFinalObject;

    static JSExpectAnyPrototype* create(JSC::VM& vm, JSGlobalObject* globalObject, JSC::Structure* structure)
    {
        JSExpectAnyPrototype* ptr = new (NotNull, JSC::allocateCell<JSExpectAnyPrototype>(vm)) JSExpectAnyPrototype(vm, globalObject, structure);
        ptr->finishCreation(vm, globalObject);
        return ptr;
    }

    DECLARE_INFO;
    template<typename CellType, JSC::SubspaceAccess>
    static JSC::GCClient::IsoSubspace* subspaceFor(JSC::VM& vm)
    {
        return &vm.plainObjectSpace();
    }
    static JSC::Structure* createStructure(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::JSValue prototype)
    {
        return JSC::Structure::create(vm, globalObject, prototype, JSC::TypeInfo(JSC::ObjectType, StructureFlags), info());
    }

private:
    JSExpectAnyPrototype(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure)
        : Base(vm, structure)
    {
    }

    void finishCreation(JSC::VM&, JSC::JSGlobalObject*);
};

extern "C" void ExpectAnyClass__finalize(void*);
extern "C" JSC_DECLARE_HOST_FUNCTION(ExpectAnyClass__call);

STATIC_ASSERT_ISO_SUBSPACE_SHARABLE(JSExpectAnyPrototype, JSExpectAnyPrototype::Base);

static const HashTableValue JSExpectAnyPrototypeTableValues[] = {};

const ClassInfo JSExpectAnyPrototype::s_info = { "ExpectAny"_s, &Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSExpectAnyPrototype) };

extern "C" void ExpectAnyPrototype__constructorValueSetCachedValue(JSC::EncodedJSValue thisValue, JSC::JSGlobalObject* globalObject, JSC::EncodedJSValue value)
{
    auto& vm = globalObject->vm();
    auto* thisObject = jsCast<JSExpectAny*>(JSValue::decode(thisValue));
    thisObject->m_constructorValue.set(vm, thisObject, JSValue::decode(value));
}

extern "C" EncodedJSValue ExpectAnyPrototype__constructorValueGetCachedValue(JSC::EncodedJSValue thisValue)
{
    auto* thisObject = jsCast<JSExpectAny*>(JSValue::decode(thisValue));
    return JSValue::encode(thisObject->m_constructorValue.get());
}

void JSExpectAnyPrototype::finishCreation(JSC::VM& vm, JSC::JSGlobalObject* globalObject)
{
    Base::finishCreation(vm);

    JSC_TO_STRING_TAG_WITHOUT_TRANSITION();
}

JSExpectAny::~JSExpectAny()
{
    if (m_ctx) {
        ExpectAnyClass__finalize(m_ctx);
    }
}
void JSExpectAny::destroy(JSCell* cell)
{
    static_cast<JSExpectAny*>(cell)->JSExpectAny::~JSExpectAny();
}

const ClassInfo JSExpectAny::s_info = { "ExpectAny"_s, &Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSExpectAny) };

void JSExpectAny::finishCreation(VM& vm)
{
    Base::finishCreation(vm);
    ASSERT(inherits(info()));
}

JSExpectAny* JSExpectAny::create(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure, void* ctx)
{
    JSExpectAny* ptr = new (NotNull, JSC::allocateCell<JSExpectAny>(vm)) JSExpectAny(vm, structure, ctx);
    ptr->finishCreation(vm);
    return ptr;
}

extern "C" void* ExpectAny__fromJS(JSC::EncodedJSValue value)
{
    JSC::JSValue decodedValue = JSC::JSValue::decode(value);
    if (decodedValue.isEmpty() || !decodedValue.isCell())
        return nullptr;

    JSC::JSCell* cell = decodedValue.asCell();
    JSExpectAny* object = JSC::jsDynamicCast<JSExpectAny*>(cell);

    if (!object)
        return nullptr;

    return object->wrapped();
}

extern "C" bool ExpectAny__dangerouslySetPtr(JSC::EncodedJSValue value, void* ptr)
{
    JSExpectAny* object = JSC::jsDynamicCast<JSExpectAny*>(JSValue::decode(value));
    if (!object)
        return false;

    object->m_ctx = ptr;
    return true;
}

extern "C" const size_t ExpectAny__ptrOffset = JSExpectAny::offsetOfWrapped();

void JSExpectAny::analyzeHeap(JSCell* cell, HeapAnalyzer& analyzer)
{
    auto* thisObject = jsCast<JSExpectAny*>(cell);
    if (void* wrapped = thisObject->wrapped()) {
        // if (thisObject->scriptExecutionContext())
        //     analyzer.setLabelForCell(cell, "url " + thisObject->scriptExecutionContext()->url().string());
    }
    Base::analyzeHeap(cell, analyzer);
}

JSObject* JSExpectAny::createPrototype(VM& vm, JSDOMGlobalObject* globalObject)
{
    return JSExpectAnyPrototype::create(vm, globalObject, JSExpectAnyPrototype::createStructure(vm, globalObject, globalObject->objectPrototype()));
}

extern "C" EncodedJSValue ExpectAny__create(Zig::GlobalObject* globalObject, void* ptr)
{
    auto& vm = globalObject->vm();
    JSC::Structure* structure = globalObject->JSExpectAnyStructure();
    JSExpectAny* instance = JSExpectAny::create(vm, globalObject, structure, ptr);

    return JSValue::encode(instance);
}

template<typename Visitor>
void JSExpectAny::visitChildrenImpl(JSCell* cell, Visitor& visitor)
{
    JSExpectAny* thisObject = jsCast<JSExpectAny*>(cell);
    ASSERT_GC_OBJECT_INHERITS(thisObject, info());
    Base::visitChildren(thisObject, visitor);
    visitor.append(thisObject->m_constructorValue);
}

DEFINE_VISIT_CHILDREN(JSExpectAny);

template<typename Visitor>
void JSExpectAny::visitAdditionalChildren(Visitor& visitor)
{
    JSExpectAny* thisObject = this;
    ASSERT_GC_OBJECT_INHERITS(thisObject, info());
    visitor.append(thisObject->m_constructorValue);

    ;
}

DEFINE_VISIT_ADDITIONAL_CHILDREN(JSExpectAny);

template<typename Visitor>
void JSExpectAny::visitOutputConstraintsImpl(JSCell* cell, Visitor& visitor)
{
    JSExpectAny* thisObject = jsCast<JSExpectAny*>(cell);
    ASSERT_GC_OBJECT_INHERITS(thisObject, info());
    thisObject->visitAdditionalChildren<Visitor>(visitor);
}

DEFINE_VISIT_OUTPUT_CONSTRAINTS(JSExpectAny);
class JSFileSystemRouterPrototype final : public JSC::JSNonFinalObject {
public:
    using Base = JSC::JSNonFinalObject;

    static JSFileSystemRouterPrototype* create(JSC::VM& vm, JSGlobalObject* globalObject, JSC::Structure* structure)
    {
        JSFileSystemRouterPrototype* ptr = new (NotNull, JSC::allocateCell<JSFileSystemRouterPrototype>(vm)) JSFileSystemRouterPrototype(vm, globalObject, structure);
        ptr->finishCreation(vm, globalObject);
        return ptr;
    }

    DECLARE_INFO;
    template<typename CellType, JSC::SubspaceAccess>
    static JSC::GCClient::IsoSubspace* subspaceFor(JSC::VM& vm)
    {
        return &vm.plainObjectSpace();
    }
    static JSC::Structure* createStructure(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::JSValue prototype)
    {
        return JSC::Structure::create(vm, globalObject, prototype, JSC::TypeInfo(JSC::ObjectType, StructureFlags), info());
    }

private:
    JSFileSystemRouterPrototype(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure)
        : Base(vm, structure)
    {
    }

    void finishCreation(JSC::VM&, JSC::JSGlobalObject*);
};

class JSFileSystemRouterConstructor final : public JSC::InternalFunction {
public:
    using Base = JSC::InternalFunction;
    static JSFileSystemRouterConstructor* create(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure, JSFileSystemRouterPrototype* prototype);

    static constexpr unsigned StructureFlags = Base::StructureFlags;
    static constexpr bool needsDestruction = false;

    static JSC::Structure* createStructure(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::JSValue prototype)
    {
        return JSC::Structure::create(vm, globalObject, prototype, JSC::TypeInfo(JSC::InternalFunctionType, StructureFlags), info());
    }

    template<typename, JSC::SubspaceAccess mode> static JSC::GCClient::IsoSubspace* subspaceFor(JSC::VM& vm)
    {
        if constexpr (mode == JSC::SubspaceAccess::Concurrently)
            return nullptr;
        return WebCore::subspaceForImpl<JSFileSystemRouterConstructor, WebCore::UseCustomHeapCellType::No>(
            vm,
            [](auto& spaces) { return spaces.m_clientSubspaceForFileSystemRouterConstructor.get(); },
            [](auto& spaces, auto&& space) { spaces.m_clientSubspaceForFileSystemRouterConstructor = std::forward<decltype(space)>(space); },
            [](auto& spaces) { return spaces.m_subspaceForFileSystemRouterConstructor.get(); },
            [](auto& spaces, auto&& space) { spaces.m_subspaceForFileSystemRouterConstructor = std::forward<decltype(space)>(space); });
    }

    void initializeProperties(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSFileSystemRouterPrototype* prototype);

    // Must be defined for each specialization class.
    static JSC::EncodedJSValue JSC_HOST_CALL_ATTRIBUTES construct(JSC::JSGlobalObject*, JSC::CallFrame*);

    DECLARE_EXPORT_INFO;

private:
    JSFileSystemRouterConstructor(JSC::VM& vm, JSC::Structure* structure);
    void finishCreation(JSC::VM&, JSC::JSGlobalObject* globalObject, JSFileSystemRouterPrototype* prototype);
};

extern "C" void* FileSystemRouterClass__construct(JSC::JSGlobalObject*, JSC::CallFrame*);
JSC_DECLARE_CUSTOM_GETTER(jsFileSystemRouterConstructor);
extern "C" void FileSystemRouterClass__finalize(void*);

extern "C" EncodedJSValue FileSystemRouterPrototype__match(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(FileSystemRouterPrototype__matchCallback);

extern "C" JSC::EncodedJSValue FileSystemRouterPrototype__getOrigin(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject);
JSC_DECLARE_CUSTOM_GETTER(FileSystemRouterPrototype__originGetterWrap);

extern "C" EncodedJSValue FileSystemRouterPrototype__reload(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(FileSystemRouterPrototype__reloadCallback);

extern "C" JSC::EncodedJSValue FileSystemRouterPrototype__getRoutes(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject);
JSC_DECLARE_CUSTOM_GETTER(FileSystemRouterPrototype__routesGetterWrap);

extern "C" JSC::EncodedJSValue FileSystemRouterPrototype__getStyle(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject);
JSC_DECLARE_CUSTOM_GETTER(FileSystemRouterPrototype__styleGetterWrap);

STATIC_ASSERT_ISO_SUBSPACE_SHARABLE(JSFileSystemRouterPrototype, JSFileSystemRouterPrototype::Base);

static const HashTableValue JSFileSystemRouterPrototypeTableValues[] = {
    { "match"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, FileSystemRouterPrototype__matchCallback, 1 } },
    { "origin"_s, static_cast<unsigned>(JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::GetterSetterType, FileSystemRouterPrototype__originGetterWrap, 0 } },
    { "reload"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, FileSystemRouterPrototype__reloadCallback, 0 } },
    { "routes"_s, static_cast<unsigned>(JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::GetterSetterType, FileSystemRouterPrototype__routesGetterWrap, 0 } },
    { "style"_s, static_cast<unsigned>(JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::GetterSetterType, FileSystemRouterPrototype__styleGetterWrap, 0 } }
};

const ClassInfo JSFileSystemRouterPrototype::s_info = { "FileSystemRouter"_s, &Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSFileSystemRouterPrototype) };

JSC_DEFINE_CUSTOM_GETTER(jsFileSystemRouterConstructor, (JSGlobalObject * lexicalGlobalObject, EncodedJSValue thisValue, PropertyName))
{
    VM& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    auto* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    auto* prototype = jsDynamicCast<JSFileSystemRouterPrototype*>(JSValue::decode(thisValue));

    if (UNLIKELY(!prototype))
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    return JSValue::encode(globalObject->JSFileSystemRouterConstructor());
}

JSC_DEFINE_HOST_FUNCTION(FileSystemRouterPrototype__matchCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSFileSystemRouter* thisObject = jsDynamicCast<JSFileSystemRouter*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return FileSystemRouterPrototype__match(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_CUSTOM_GETTER(FileSystemRouterPrototype__originGetterWrap, (JSGlobalObject * lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    auto& vm = lexicalGlobalObject->vm();
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    JSFileSystemRouter* thisObject = jsCast<JSFileSystemRouter*>(JSValue::decode(thisValue));
    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    if (JSValue cachedValue = thisObject->m_origin.get())
        return JSValue::encode(cachedValue);

    JSC::JSValue result = JSC::JSValue::decode(
        FileSystemRouterPrototype__getOrigin(thisObject->wrapped(), globalObject));
    RETURN_IF_EXCEPTION(throwScope, {});
    thisObject->m_origin.set(vm, thisObject, result);
    RELEASE_AND_RETURN(throwScope, JSValue::encode(result));
}

extern "C" void FileSystemRouterPrototype__originSetCachedValue(JSC::EncodedJSValue thisValue, JSC::JSGlobalObject* globalObject, JSC::EncodedJSValue value)
{
    auto& vm = globalObject->vm();
    auto* thisObject = jsCast<JSFileSystemRouter*>(JSValue::decode(thisValue));
    thisObject->m_origin.set(vm, thisObject, JSValue::decode(value));
}

extern "C" EncodedJSValue FileSystemRouterPrototype__originGetCachedValue(JSC::EncodedJSValue thisValue)
{
    auto* thisObject = jsCast<JSFileSystemRouter*>(JSValue::decode(thisValue));
    return JSValue::encode(thisObject->m_origin.get());
}

JSC_DEFINE_HOST_FUNCTION(FileSystemRouterPrototype__reloadCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSFileSystemRouter* thisObject = jsDynamicCast<JSFileSystemRouter*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return FileSystemRouterPrototype__reload(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_CUSTOM_GETTER(FileSystemRouterPrototype__routesGetterWrap, (JSGlobalObject * lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    auto& vm = lexicalGlobalObject->vm();
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    JSFileSystemRouter* thisObject = jsCast<JSFileSystemRouter*>(JSValue::decode(thisValue));
    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    if (JSValue cachedValue = thisObject->m_routes.get())
        return JSValue::encode(cachedValue);

    JSC::JSValue result = JSC::JSValue::decode(
        FileSystemRouterPrototype__getRoutes(thisObject->wrapped(), globalObject));
    RETURN_IF_EXCEPTION(throwScope, {});
    thisObject->m_routes.set(vm, thisObject, result);
    RELEASE_AND_RETURN(throwScope, JSValue::encode(result));
}

extern "C" void FileSystemRouterPrototype__routesSetCachedValue(JSC::EncodedJSValue thisValue, JSC::JSGlobalObject* globalObject, JSC::EncodedJSValue value)
{
    auto& vm = globalObject->vm();
    auto* thisObject = jsCast<JSFileSystemRouter*>(JSValue::decode(thisValue));
    thisObject->m_routes.set(vm, thisObject, JSValue::decode(value));
}

extern "C" EncodedJSValue FileSystemRouterPrototype__routesGetCachedValue(JSC::EncodedJSValue thisValue)
{
    auto* thisObject = jsCast<JSFileSystemRouter*>(JSValue::decode(thisValue));
    return JSValue::encode(thisObject->m_routes.get());
}

JSC_DEFINE_CUSTOM_GETTER(FileSystemRouterPrototype__styleGetterWrap, (JSGlobalObject * lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    auto& vm = lexicalGlobalObject->vm();
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    JSFileSystemRouter* thisObject = jsCast<JSFileSystemRouter*>(JSValue::decode(thisValue));
    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    if (JSValue cachedValue = thisObject->m_style.get())
        return JSValue::encode(cachedValue);

    JSC::JSValue result = JSC::JSValue::decode(
        FileSystemRouterPrototype__getStyle(thisObject->wrapped(), globalObject));
    RETURN_IF_EXCEPTION(throwScope, {});
    thisObject->m_style.set(vm, thisObject, result);
    RELEASE_AND_RETURN(throwScope, JSValue::encode(result));
}

extern "C" void FileSystemRouterPrototype__styleSetCachedValue(JSC::EncodedJSValue thisValue, JSC::JSGlobalObject* globalObject, JSC::EncodedJSValue value)
{
    auto& vm = globalObject->vm();
    auto* thisObject = jsCast<JSFileSystemRouter*>(JSValue::decode(thisValue));
    thisObject->m_style.set(vm, thisObject, JSValue::decode(value));
}

extern "C" EncodedJSValue FileSystemRouterPrototype__styleGetCachedValue(JSC::EncodedJSValue thisValue)
{
    auto* thisObject = jsCast<JSFileSystemRouter*>(JSValue::decode(thisValue));
    return JSValue::encode(thisObject->m_style.get());
}

void JSFileSystemRouterPrototype::finishCreation(JSC::VM& vm, JSC::JSGlobalObject* globalObject)
{
    Base::finishCreation(vm);
    reifyStaticProperties(vm, JSFileSystemRouter::info(), JSFileSystemRouterPrototypeTableValues, *this);
    JSC_TO_STRING_TAG_WITHOUT_TRANSITION();
}

void JSFileSystemRouterConstructor::finishCreation(VM& vm, JSC::JSGlobalObject* globalObject, JSFileSystemRouterPrototype* prototype)
{
    Base::finishCreation(vm, 0, "FileSystemRouter"_s, PropertyAdditionMode::WithoutStructureTransition);

    putDirectWithoutTransition(vm, vm.propertyNames->prototype, prototype, PropertyAttribute::DontEnum | PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly);
    ASSERT(inherits(info()));
}

JSFileSystemRouterConstructor::JSFileSystemRouterConstructor(JSC::VM& vm, JSC::Structure* structure)
    : Base(vm, structure, construct, construct)
{
}

JSFileSystemRouterConstructor* JSFileSystemRouterConstructor::create(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure, JSFileSystemRouterPrototype* prototype)
{
    JSFileSystemRouterConstructor* ptr = new (NotNull, JSC::allocateCell<JSFileSystemRouterConstructor>(vm)) JSFileSystemRouterConstructor(vm, structure);
    ptr->finishCreation(vm, globalObject, prototype);
    return ptr;
}

JSC::EncodedJSValue JSC_HOST_CALL_ATTRIBUTES JSFileSystemRouterConstructor::construct(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame)
{
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    JSC::VM& vm = globalObject->vm();
    JSObject* newTarget = asObject(callFrame->newTarget());
    auto* constructor = globalObject->JSFileSystemRouterConstructor();
    Structure* structure = globalObject->JSFileSystemRouterStructure();
    if (constructor != newTarget) {
        auto scope = DECLARE_THROW_SCOPE(vm);

        auto* functionGlobalObject = reinterpret_cast<Zig::GlobalObject*>(
            // ShadowRealm functions belong to a different global object.
            getFunctionRealm(globalObject, newTarget));
        RETURN_IF_EXCEPTION(scope, {});
        structure = InternalFunction::createSubclassStructure(
            globalObject,
            newTarget,
            functionGlobalObject->JSFileSystemRouterStructure());
    }

    void* ptr = FileSystemRouterClass__construct(globalObject, callFrame);

    if (UNLIKELY(!ptr)) {
        return JSValue::encode(JSC::jsUndefined());
    }

    JSFileSystemRouter* instance = JSFileSystemRouter::create(vm, globalObject, structure, ptr);

    return JSValue::encode(instance);
}

void JSFileSystemRouterConstructor::initializeProperties(VM& vm, JSC::JSGlobalObject* globalObject, JSFileSystemRouterPrototype* prototype)
{
}

const ClassInfo JSFileSystemRouterConstructor::s_info = { "Function"_s, &Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSFileSystemRouterConstructor) };

extern "C" EncodedJSValue FileSystemRouter__getConstructor(Zig::GlobalObject* globalObject)
{
    return JSValue::encode(globalObject->JSFileSystemRouterConstructor());
}

JSFileSystemRouter::~JSFileSystemRouter()
{
    if (m_ctx) {
        FileSystemRouterClass__finalize(m_ctx);
    }
}
void JSFileSystemRouter::destroy(JSCell* cell)
{
    static_cast<JSFileSystemRouter*>(cell)->JSFileSystemRouter::~JSFileSystemRouter();
}

const ClassInfo JSFileSystemRouter::s_info = { "FileSystemRouter"_s, &Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSFileSystemRouter) };

void JSFileSystemRouter::finishCreation(VM& vm)
{
    Base::finishCreation(vm);
    ASSERT(inherits(info()));
}

JSFileSystemRouter* JSFileSystemRouter::create(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure, void* ctx)
{
    JSFileSystemRouter* ptr = new (NotNull, JSC::allocateCell<JSFileSystemRouter>(vm)) JSFileSystemRouter(vm, structure, ctx);
    ptr->finishCreation(vm);
    return ptr;
}

extern "C" void* FileSystemRouter__fromJS(JSC::EncodedJSValue value)
{
    JSC::JSValue decodedValue = JSC::JSValue::decode(value);
    if (decodedValue.isEmpty() || !decodedValue.isCell())
        return nullptr;

    JSC::JSCell* cell = decodedValue.asCell();
    JSFileSystemRouter* object = JSC::jsDynamicCast<JSFileSystemRouter*>(cell);

    if (!object)
        return nullptr;

    return object->wrapped();
}

extern "C" bool FileSystemRouter__dangerouslySetPtr(JSC::EncodedJSValue value, void* ptr)
{
    JSFileSystemRouter* object = JSC::jsDynamicCast<JSFileSystemRouter*>(JSValue::decode(value));
    if (!object)
        return false;

    object->m_ctx = ptr;
    return true;
}

extern "C" const size_t FileSystemRouter__ptrOffset = JSFileSystemRouter::offsetOfWrapped();

void JSFileSystemRouter::analyzeHeap(JSCell* cell, HeapAnalyzer& analyzer)
{
    auto* thisObject = jsCast<JSFileSystemRouter*>(cell);
    if (void* wrapped = thisObject->wrapped()) {
        // if (thisObject->scriptExecutionContext())
        //     analyzer.setLabelForCell(cell, "url " + thisObject->scriptExecutionContext()->url().string());
    }
    Base::analyzeHeap(cell, analyzer);
}

JSObject* JSFileSystemRouter::createConstructor(VM& vm, JSGlobalObject* globalObject, JSValue prototype)
{
    return WebCore::JSFileSystemRouterConstructor::create(vm, globalObject, WebCore::JSFileSystemRouterConstructor::createStructure(vm, globalObject, globalObject->functionPrototype()), jsCast<WebCore::JSFileSystemRouterPrototype*>(prototype));
}

JSObject* JSFileSystemRouter::createPrototype(VM& vm, JSDOMGlobalObject* globalObject)
{
    return JSFileSystemRouterPrototype::create(vm, globalObject, JSFileSystemRouterPrototype::createStructure(vm, globalObject, globalObject->objectPrototype()));
}

extern "C" EncodedJSValue FileSystemRouter__create(Zig::GlobalObject* globalObject, void* ptr)
{
    auto& vm = globalObject->vm();
    JSC::Structure* structure = globalObject->JSFileSystemRouterStructure();
    JSFileSystemRouter* instance = JSFileSystemRouter::create(vm, globalObject, structure, ptr);

    return JSValue::encode(instance);
}

template<typename Visitor>
void JSFileSystemRouter::visitChildrenImpl(JSCell* cell, Visitor& visitor)
{
    JSFileSystemRouter* thisObject = jsCast<JSFileSystemRouter*>(cell);
    ASSERT_GC_OBJECT_INHERITS(thisObject, info());
    Base::visitChildren(thisObject, visitor);

    visitor.append(thisObject->m_origin);
    visitor.append(thisObject->m_routes);
    visitor.append(thisObject->m_style);
}

DEFINE_VISIT_CHILDREN(JSFileSystemRouter);

template<typename Visitor>
void JSFileSystemRouter::visitAdditionalChildren(Visitor& visitor)
{
    JSFileSystemRouter* thisObject = this;
    ASSERT_GC_OBJECT_INHERITS(thisObject, info());

    visitor.append(thisObject->m_origin);
    visitor.append(thisObject->m_routes);
    visitor.append(thisObject->m_style);
    ;
}

DEFINE_VISIT_ADDITIONAL_CHILDREN(JSFileSystemRouter);

template<typename Visitor>
void JSFileSystemRouter::visitOutputConstraintsImpl(JSCell* cell, Visitor& visitor)
{
    JSFileSystemRouter* thisObject = jsCast<JSFileSystemRouter*>(cell);
    ASSERT_GC_OBJECT_INHERITS(thisObject, info());
    thisObject->visitAdditionalChildren<Visitor>(visitor);
}

DEFINE_VISIT_OUTPUT_CONSTRAINTS(JSFileSystemRouter);
class JSListenerPrototype final : public JSC::JSNonFinalObject {
public:
    using Base = JSC::JSNonFinalObject;

    static JSListenerPrototype* create(JSC::VM& vm, JSGlobalObject* globalObject, JSC::Structure* structure)
    {
        JSListenerPrototype* ptr = new (NotNull, JSC::allocateCell<JSListenerPrototype>(vm)) JSListenerPrototype(vm, globalObject, structure);
        ptr->finishCreation(vm, globalObject);
        return ptr;
    }

    DECLARE_INFO;
    template<typename CellType, JSC::SubspaceAccess>
    static JSC::GCClient::IsoSubspace* subspaceFor(JSC::VM& vm)
    {
        return &vm.plainObjectSpace();
    }
    static JSC::Structure* createStructure(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::JSValue prototype)
    {
        return JSC::Structure::create(vm, globalObject, prototype, JSC::TypeInfo(JSC::ObjectType, StructureFlags), info());
    }

private:
    JSListenerPrototype(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure)
        : Base(vm, structure)
    {
    }

    void finishCreation(JSC::VM&, JSC::JSGlobalObject*);
};

extern "C" void* ListenerClass__construct(JSC::JSGlobalObject*, JSC::CallFrame*);
JSC_DECLARE_CUSTOM_GETTER(jsListenerConstructor);
extern "C" void ListenerClass__finalize(void*);

extern "C" JSC::EncodedJSValue ListenerPrototype__getData(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject);
JSC_DECLARE_CUSTOM_GETTER(ListenerPrototype__dataGetterWrap);

extern "C" bool ListenerPrototype__setData(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::EncodedJSValue value);
JSC_DECLARE_CUSTOM_SETTER(ListenerPrototype__dataSetterWrap);

extern "C" JSC::EncodedJSValue ListenerPrototype__getHostname(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject);
JSC_DECLARE_CUSTOM_GETTER(ListenerPrototype__hostnameGetterWrap);

extern "C" JSC::EncodedJSValue ListenerPrototype__getPort(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject);
JSC_DECLARE_CUSTOM_GETTER(ListenerPrototype__portGetterWrap);

extern "C" EncodedJSValue ListenerPrototype__ref(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(ListenerPrototype__refCallback);

extern "C" EncodedJSValue ListenerPrototype__reload(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(ListenerPrototype__reloadCallback);

extern "C" EncodedJSValue ListenerPrototype__stop(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(ListenerPrototype__stopCallback);

extern "C" JSC::EncodedJSValue ListenerPrototype__getUnix(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject);
JSC_DECLARE_CUSTOM_GETTER(ListenerPrototype__unixGetterWrap);

extern "C" EncodedJSValue ListenerPrototype__unref(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(ListenerPrototype__unrefCallback);

STATIC_ASSERT_ISO_SUBSPACE_SHARABLE(JSListenerPrototype, JSListenerPrototype::Base);

static const HashTableValue JSListenerPrototypeTableValues[] = {
    { "data"_s, static_cast<unsigned>(JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::GetterSetterType, ListenerPrototype__dataGetterWrap, ListenerPrototype__dataSetterWrap } },
    { "hostname"_s, static_cast<unsigned>(JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::GetterSetterType, ListenerPrototype__hostnameGetterWrap, 0 } },
    { "port"_s, static_cast<unsigned>(JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::GetterSetterType, ListenerPrototype__portGetterWrap, 0 } },
    { "ref"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, ListenerPrototype__refCallback, 0 } },
    { "reload"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, ListenerPrototype__reloadCallback, 1 } },
    { "stop"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, ListenerPrototype__stopCallback, 1 } },
    { "unix"_s, static_cast<unsigned>(JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::GetterSetterType, ListenerPrototype__unixGetterWrap, 0 } },
    { "unref"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, ListenerPrototype__unrefCallback, 0 } }
};

const ClassInfo JSListenerPrototype::s_info = { "Listener"_s, &Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSListenerPrototype) };

JSC_DEFINE_CUSTOM_GETTER(jsListenerConstructor, (JSGlobalObject * lexicalGlobalObject, EncodedJSValue thisValue, PropertyName))
{
    VM& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    auto* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    auto* prototype = jsDynamicCast<JSListenerPrototype*>(JSValue::decode(thisValue));

    if (UNLIKELY(!prototype))
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    return JSValue::encode(globalObject->JSListenerConstructor());
}

JSC_DEFINE_CUSTOM_GETTER(ListenerPrototype__dataGetterWrap, (JSGlobalObject * lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    auto& vm = lexicalGlobalObject->vm();
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    JSListener* thisObject = jsCast<JSListener*>(JSValue::decode(thisValue));
    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);
    JSC::EncodedJSValue result = ListenerPrototype__getData(thisObject->wrapped(), globalObject);
    RETURN_IF_EXCEPTION(throwScope, {});
    RELEASE_AND_RETURN(throwScope, result);
}

JSC_DEFINE_CUSTOM_SETTER(ListenerPrototype__dataSetterWrap, (JSGlobalObject * lexicalGlobalObject, EncodedJSValue thisValue, EncodedJSValue encodedValue, PropertyName attributeName))
{
    auto& vm = lexicalGlobalObject->vm();
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    JSListener* thisObject = jsCast<JSListener*>(JSValue::decode(thisValue));
    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);
    auto result = ListenerPrototype__setData(thisObject->wrapped(), lexicalGlobalObject, encodedValue);

    RELEASE_AND_RETURN(throwScope, result);
}

JSC_DEFINE_CUSTOM_GETTER(ListenerPrototype__hostnameGetterWrap, (JSGlobalObject * lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    auto& vm = lexicalGlobalObject->vm();
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    JSListener* thisObject = jsCast<JSListener*>(JSValue::decode(thisValue));
    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    if (JSValue cachedValue = thisObject->m_hostname.get())
        return JSValue::encode(cachedValue);

    JSC::JSValue result = JSC::JSValue::decode(
        ListenerPrototype__getHostname(thisObject->wrapped(), globalObject));
    RETURN_IF_EXCEPTION(throwScope, {});
    thisObject->m_hostname.set(vm, thisObject, result);
    RELEASE_AND_RETURN(throwScope, JSValue::encode(result));
}

extern "C" void ListenerPrototype__hostnameSetCachedValue(JSC::EncodedJSValue thisValue, JSC::JSGlobalObject* globalObject, JSC::EncodedJSValue value)
{
    auto& vm = globalObject->vm();
    auto* thisObject = jsCast<JSListener*>(JSValue::decode(thisValue));
    thisObject->m_hostname.set(vm, thisObject, JSValue::decode(value));
}

extern "C" EncodedJSValue ListenerPrototype__hostnameGetCachedValue(JSC::EncodedJSValue thisValue)
{
    auto* thisObject = jsCast<JSListener*>(JSValue::decode(thisValue));
    return JSValue::encode(thisObject->m_hostname.get());
}

JSC_DEFINE_CUSTOM_GETTER(ListenerPrototype__portGetterWrap, (JSGlobalObject * lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    auto& vm = lexicalGlobalObject->vm();
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    JSListener* thisObject = jsCast<JSListener*>(JSValue::decode(thisValue));
    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);
    JSC::EncodedJSValue result = ListenerPrototype__getPort(thisObject->wrapped(), globalObject);
    RETURN_IF_EXCEPTION(throwScope, {});
    RELEASE_AND_RETURN(throwScope, result);
}

JSC_DEFINE_HOST_FUNCTION(ListenerPrototype__refCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSListener* thisObject = jsDynamicCast<JSListener*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return ListenerPrototype__ref(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_HOST_FUNCTION(ListenerPrototype__reloadCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSListener* thisObject = jsDynamicCast<JSListener*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return ListenerPrototype__reload(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_HOST_FUNCTION(ListenerPrototype__stopCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSListener* thisObject = jsDynamicCast<JSListener*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return ListenerPrototype__stop(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_CUSTOM_GETTER(ListenerPrototype__unixGetterWrap, (JSGlobalObject * lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    auto& vm = lexicalGlobalObject->vm();
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    JSListener* thisObject = jsCast<JSListener*>(JSValue::decode(thisValue));
    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    if (JSValue cachedValue = thisObject->m_unix.get())
        return JSValue::encode(cachedValue);

    JSC::JSValue result = JSC::JSValue::decode(
        ListenerPrototype__getUnix(thisObject->wrapped(), globalObject));
    RETURN_IF_EXCEPTION(throwScope, {});
    thisObject->m_unix.set(vm, thisObject, result);
    RELEASE_AND_RETURN(throwScope, JSValue::encode(result));
}

extern "C" void ListenerPrototype__unixSetCachedValue(JSC::EncodedJSValue thisValue, JSC::JSGlobalObject* globalObject, JSC::EncodedJSValue value)
{
    auto& vm = globalObject->vm();
    auto* thisObject = jsCast<JSListener*>(JSValue::decode(thisValue));
    thisObject->m_unix.set(vm, thisObject, JSValue::decode(value));
}

extern "C" EncodedJSValue ListenerPrototype__unixGetCachedValue(JSC::EncodedJSValue thisValue)
{
    auto* thisObject = jsCast<JSListener*>(JSValue::decode(thisValue));
    return JSValue::encode(thisObject->m_unix.get());
}

JSC_DEFINE_HOST_FUNCTION(ListenerPrototype__unrefCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSListener* thisObject = jsDynamicCast<JSListener*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return ListenerPrototype__unref(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

void JSListenerPrototype::finishCreation(JSC::VM& vm, JSC::JSGlobalObject* globalObject)
{
    Base::finishCreation(vm);
    reifyStaticProperties(vm, JSListener::info(), JSListenerPrototypeTableValues, *this);
    JSC_TO_STRING_TAG_WITHOUT_TRANSITION();
}

JSListener::~JSListener()
{
    if (m_ctx) {
        ListenerClass__finalize(m_ctx);
    }
}
void JSListener::destroy(JSCell* cell)
{
    static_cast<JSListener*>(cell)->JSListener::~JSListener();
}

const ClassInfo JSListener::s_info = { "Listener"_s, &Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSListener) };

void JSListener::finishCreation(VM& vm)
{
    Base::finishCreation(vm);
    ASSERT(inherits(info()));
}

JSListener* JSListener::create(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure, void* ctx)
{
    JSListener* ptr = new (NotNull, JSC::allocateCell<JSListener>(vm)) JSListener(vm, structure, ctx);
    ptr->finishCreation(vm);
    return ptr;
}

extern "C" void* Listener__fromJS(JSC::EncodedJSValue value)
{
    JSC::JSValue decodedValue = JSC::JSValue::decode(value);
    if (decodedValue.isEmpty() || !decodedValue.isCell())
        return nullptr;

    JSC::JSCell* cell = decodedValue.asCell();
    JSListener* object = JSC::jsDynamicCast<JSListener*>(cell);

    if (!object)
        return nullptr;

    return object->wrapped();
}

extern "C" bool Listener__dangerouslySetPtr(JSC::EncodedJSValue value, void* ptr)
{
    JSListener* object = JSC::jsDynamicCast<JSListener*>(JSValue::decode(value));
    if (!object)
        return false;

    object->m_ctx = ptr;
    return true;
}

extern "C" const size_t Listener__ptrOffset = JSListener::offsetOfWrapped();

void JSListener::analyzeHeap(JSCell* cell, HeapAnalyzer& analyzer)
{
    auto* thisObject = jsCast<JSListener*>(cell);
    if (void* wrapped = thisObject->wrapped()) {
        // if (thisObject->scriptExecutionContext())
        //     analyzer.setLabelForCell(cell, "url " + thisObject->scriptExecutionContext()->url().string());
    }
    Base::analyzeHeap(cell, analyzer);
}

JSObject* JSListener::createPrototype(VM& vm, JSDOMGlobalObject* globalObject)
{
    return JSListenerPrototype::create(vm, globalObject, JSListenerPrototype::createStructure(vm, globalObject, globalObject->objectPrototype()));
}

extern "C" EncodedJSValue Listener__create(Zig::GlobalObject* globalObject, void* ptr)
{
    auto& vm = globalObject->vm();
    JSC::Structure* structure = globalObject->JSListenerStructure();
    JSListener* instance = JSListener::create(vm, globalObject, structure, ptr);

    return JSValue::encode(instance);
}

template<typename Visitor>
void JSListener::visitChildrenImpl(JSCell* cell, Visitor& visitor)
{
    JSListener* thisObject = jsCast<JSListener*>(cell);
    ASSERT_GC_OBJECT_INHERITS(thisObject, info());
    Base::visitChildren(thisObject, visitor);

    visitor.append(thisObject->m_hostname);
    visitor.append(thisObject->m_unix);
}

DEFINE_VISIT_CHILDREN(JSListener);

template<typename Visitor>
void JSListener::visitAdditionalChildren(Visitor& visitor)
{
    JSListener* thisObject = this;
    ASSERT_GC_OBJECT_INHERITS(thisObject, info());

    visitor.append(thisObject->m_hostname);
    visitor.append(thisObject->m_unix);
    ;
}

DEFINE_VISIT_ADDITIONAL_CHILDREN(JSListener);

template<typename Visitor>
void JSListener::visitOutputConstraintsImpl(JSCell* cell, Visitor& visitor)
{
    JSListener* thisObject = jsCast<JSListener*>(cell);
    ASSERT_GC_OBJECT_INHERITS(thisObject, info());
    thisObject->visitAdditionalChildren<Visitor>(visitor);
}

DEFINE_VISIT_OUTPUT_CONSTRAINTS(JSListener);
class JSMD4Prototype final : public JSC::JSNonFinalObject {
public:
    using Base = JSC::JSNonFinalObject;

    static JSMD4Prototype* create(JSC::VM& vm, JSGlobalObject* globalObject, JSC::Structure* structure)
    {
        JSMD4Prototype* ptr = new (NotNull, JSC::allocateCell<JSMD4Prototype>(vm)) JSMD4Prototype(vm, globalObject, structure);
        ptr->finishCreation(vm, globalObject);
        return ptr;
    }

    DECLARE_INFO;
    template<typename CellType, JSC::SubspaceAccess>
    static JSC::GCClient::IsoSubspace* subspaceFor(JSC::VM& vm)
    {
        return &vm.plainObjectSpace();
    }
    static JSC::Structure* createStructure(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::JSValue prototype)
    {
        return JSC::Structure::create(vm, globalObject, prototype, JSC::TypeInfo(JSC::ObjectType, StructureFlags), info());
    }

private:
    JSMD4Prototype(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure)
        : Base(vm, structure)
    {
    }

    void finishCreation(JSC::VM&, JSC::JSGlobalObject*);
};

class JSMD4Constructor final : public JSC::InternalFunction {
public:
    using Base = JSC::InternalFunction;
    static JSMD4Constructor* create(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure, JSMD4Prototype* prototype);

    static constexpr unsigned StructureFlags = Base::StructureFlags;
    static constexpr bool needsDestruction = false;

    static JSC::Structure* createStructure(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::JSValue prototype)
    {
        return JSC::Structure::create(vm, globalObject, prototype, JSC::TypeInfo(JSC::InternalFunctionType, StructureFlags), info());
    }

    template<typename, JSC::SubspaceAccess mode> static JSC::GCClient::IsoSubspace* subspaceFor(JSC::VM& vm)
    {
        if constexpr (mode == JSC::SubspaceAccess::Concurrently)
            return nullptr;
        return WebCore::subspaceForImpl<JSMD4Constructor, WebCore::UseCustomHeapCellType::No>(
            vm,
            [](auto& spaces) { return spaces.m_clientSubspaceForMD4Constructor.get(); },
            [](auto& spaces, auto&& space) { spaces.m_clientSubspaceForMD4Constructor = std::forward<decltype(space)>(space); },
            [](auto& spaces) { return spaces.m_subspaceForMD4Constructor.get(); },
            [](auto& spaces, auto&& space) { spaces.m_subspaceForMD4Constructor = std::forward<decltype(space)>(space); });
    }

    void initializeProperties(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSMD4Prototype* prototype);

    // Must be defined for each specialization class.
    static JSC::EncodedJSValue JSC_HOST_CALL_ATTRIBUTES construct(JSC::JSGlobalObject*, JSC::CallFrame*);

    DECLARE_EXPORT_INFO;

private:
    JSMD4Constructor(JSC::VM& vm, JSC::Structure* structure);
    void finishCreation(JSC::VM&, JSC::JSGlobalObject* globalObject, JSMD4Prototype* prototype);
};

extern "C" void* MD4Class__construct(JSC::JSGlobalObject*, JSC::CallFrame*);
JSC_DECLARE_CUSTOM_GETTER(jsMD4Constructor);
extern "C" void MD4Class__finalize(void*);

extern "C" JSC::EncodedJSValue MD4Prototype__getByteLength(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject);
JSC_DECLARE_CUSTOM_GETTER(MD4Prototype__byteLengthGetterWrap);

extern "C" EncodedJSValue MD4Prototype__digest(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(MD4Prototype__digestCallback);

extern "C" EncodedJSValue MD4Prototype__update(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(MD4Prototype__updateCallback);

STATIC_ASSERT_ISO_SUBSPACE_SHARABLE(JSMD4Prototype, JSMD4Prototype::Base);

static const HashTableValue JSMD4PrototypeTableValues[] = {
    { "byteLength"_s, static_cast<unsigned>(JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::GetterSetterType, MD4Prototype__byteLengthGetterWrap, 0 } },
    { "digest"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, MD4Prototype__digestCallback, 0 } },
    { "update"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, MD4Prototype__updateCallback, 1 } }
};

const ClassInfo JSMD4Prototype::s_info = { "MD4"_s, &Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSMD4Prototype) };

JSC_DEFINE_CUSTOM_GETTER(jsMD4Constructor, (JSGlobalObject * lexicalGlobalObject, EncodedJSValue thisValue, PropertyName))
{
    VM& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    auto* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    auto* prototype = jsDynamicCast<JSMD4Prototype*>(JSValue::decode(thisValue));

    if (UNLIKELY(!prototype))
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    return JSValue::encode(globalObject->JSMD4Constructor());
}

JSC_DEFINE_CUSTOM_GETTER(MD4Prototype__byteLengthGetterWrap, (JSGlobalObject * lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    auto& vm = lexicalGlobalObject->vm();
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    JSMD4* thisObject = jsCast<JSMD4*>(JSValue::decode(thisValue));
    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);
    JSC::EncodedJSValue result = MD4Prototype__getByteLength(thisObject->wrapped(), globalObject);
    RETURN_IF_EXCEPTION(throwScope, {});
    RELEASE_AND_RETURN(throwScope, result);
}

JSC_DEFINE_HOST_FUNCTION(MD4Prototype__digestCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSMD4* thisObject = jsDynamicCast<JSMD4*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return MD4Prototype__digest(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_HOST_FUNCTION(MD4Prototype__updateCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSMD4* thisObject = jsDynamicCast<JSMD4*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return MD4Prototype__update(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

void JSMD4Prototype::finishCreation(JSC::VM& vm, JSC::JSGlobalObject* globalObject)
{
    Base::finishCreation(vm);
    reifyStaticProperties(vm, JSMD4::info(), JSMD4PrototypeTableValues, *this);
    JSC_TO_STRING_TAG_WITHOUT_TRANSITION();
}

extern "C" JSC_DECLARE_CUSTOM_GETTER(MD4Class__getByteLengthStatic);
extern "C" JSC_DECLARE_HOST_FUNCTION(MD4Class__hash);

static const HashTableValue JSMD4ConstructorTableValues[] = {
    { "byteLength"_s, static_cast<unsigned>(JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::GetterSetterType, MD4Class__getByteLengthStatic, 0 } },
    { "hash"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, MD4Class__hash, 2 } }
};

void JSMD4Constructor::finishCreation(VM& vm, JSC::JSGlobalObject* globalObject, JSMD4Prototype* prototype)
{
    Base::finishCreation(vm, 0, "MD4"_s, PropertyAdditionMode::WithoutStructureTransition);
    reifyStaticProperties(vm, &JSMD4Constructor::s_info, JSMD4ConstructorTableValues, *this);
    putDirectWithoutTransition(vm, vm.propertyNames->prototype, prototype, PropertyAttribute::DontEnum | PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly);
    ASSERT(inherits(info()));
}

JSMD4Constructor::JSMD4Constructor(JSC::VM& vm, JSC::Structure* structure)
    : Base(vm, structure, construct, construct)
{
}

JSMD4Constructor* JSMD4Constructor::create(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure, JSMD4Prototype* prototype)
{
    JSMD4Constructor* ptr = new (NotNull, JSC::allocateCell<JSMD4Constructor>(vm)) JSMD4Constructor(vm, structure);
    ptr->finishCreation(vm, globalObject, prototype);
    return ptr;
}

JSC::EncodedJSValue JSC_HOST_CALL_ATTRIBUTES JSMD4Constructor::construct(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame)
{
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    JSC::VM& vm = globalObject->vm();
    JSObject* newTarget = asObject(callFrame->newTarget());
    auto* constructor = globalObject->JSMD4Constructor();
    Structure* structure = globalObject->JSMD4Structure();
    if (constructor != newTarget) {
        auto scope = DECLARE_THROW_SCOPE(vm);

        auto* functionGlobalObject = reinterpret_cast<Zig::GlobalObject*>(
            // ShadowRealm functions belong to a different global object.
            getFunctionRealm(globalObject, newTarget));
        RETURN_IF_EXCEPTION(scope, {});
        structure = InternalFunction::createSubclassStructure(
            globalObject,
            newTarget,
            functionGlobalObject->JSMD4Structure());
    }

    void* ptr = MD4Class__construct(globalObject, callFrame);

    if (UNLIKELY(!ptr)) {
        return JSValue::encode(JSC::jsUndefined());
    }

    JSMD4* instance = JSMD4::create(vm, globalObject, structure, ptr);

    return JSValue::encode(instance);
}

void JSMD4Constructor::initializeProperties(VM& vm, JSC::JSGlobalObject* globalObject, JSMD4Prototype* prototype)
{
}

const ClassInfo JSMD4Constructor::s_info = { "Function"_s, &Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSMD4Constructor) };

extern "C" EncodedJSValue MD4__getConstructor(Zig::GlobalObject* globalObject)
{
    return JSValue::encode(globalObject->JSMD4Constructor());
}

JSMD4::~JSMD4()
{
    if (m_ctx) {
        MD4Class__finalize(m_ctx);
    }
}
void JSMD4::destroy(JSCell* cell)
{
    static_cast<JSMD4*>(cell)->JSMD4::~JSMD4();
}

const ClassInfo JSMD4::s_info = { "MD4"_s, &Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSMD4) };

void JSMD4::finishCreation(VM& vm)
{
    Base::finishCreation(vm);
    ASSERT(inherits(info()));
}

JSMD4* JSMD4::create(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure, void* ctx)
{
    JSMD4* ptr = new (NotNull, JSC::allocateCell<JSMD4>(vm)) JSMD4(vm, structure, ctx);
    ptr->finishCreation(vm);
    return ptr;
}

extern "C" void* MD4__fromJS(JSC::EncodedJSValue value)
{
    JSC::JSValue decodedValue = JSC::JSValue::decode(value);
    if (decodedValue.isEmpty() || !decodedValue.isCell())
        return nullptr;

    JSC::JSCell* cell = decodedValue.asCell();
    JSMD4* object = JSC::jsDynamicCast<JSMD4*>(cell);

    if (!object)
        return nullptr;

    return object->wrapped();
}

extern "C" bool MD4__dangerouslySetPtr(JSC::EncodedJSValue value, void* ptr)
{
    JSMD4* object = JSC::jsDynamicCast<JSMD4*>(JSValue::decode(value));
    if (!object)
        return false;

    object->m_ctx = ptr;
    return true;
}

extern "C" const size_t MD4__ptrOffset = JSMD4::offsetOfWrapped();

void JSMD4::analyzeHeap(JSCell* cell, HeapAnalyzer& analyzer)
{
    auto* thisObject = jsCast<JSMD4*>(cell);
    if (void* wrapped = thisObject->wrapped()) {
        // if (thisObject->scriptExecutionContext())
        //     analyzer.setLabelForCell(cell, "url " + thisObject->scriptExecutionContext()->url().string());
    }
    Base::analyzeHeap(cell, analyzer);
}

JSObject* JSMD4::createConstructor(VM& vm, JSGlobalObject* globalObject, JSValue prototype)
{
    return WebCore::JSMD4Constructor::create(vm, globalObject, WebCore::JSMD4Constructor::createStructure(vm, globalObject, globalObject->functionPrototype()), jsCast<WebCore::JSMD4Prototype*>(prototype));
}

JSObject* JSMD4::createPrototype(VM& vm, JSDOMGlobalObject* globalObject)
{
    return JSMD4Prototype::create(vm, globalObject, JSMD4Prototype::createStructure(vm, globalObject, globalObject->objectPrototype()));
}

extern "C" EncodedJSValue MD4__create(Zig::GlobalObject* globalObject, void* ptr)
{
    auto& vm = globalObject->vm();
    JSC::Structure* structure = globalObject->JSMD4Structure();
    JSMD4* instance = JSMD4::create(vm, globalObject, structure, ptr);

    return JSValue::encode(instance);
}
class JSMD5Prototype final : public JSC::JSNonFinalObject {
public:
    using Base = JSC::JSNonFinalObject;

    static JSMD5Prototype* create(JSC::VM& vm, JSGlobalObject* globalObject, JSC::Structure* structure)
    {
        JSMD5Prototype* ptr = new (NotNull, JSC::allocateCell<JSMD5Prototype>(vm)) JSMD5Prototype(vm, globalObject, structure);
        ptr->finishCreation(vm, globalObject);
        return ptr;
    }

    DECLARE_INFO;
    template<typename CellType, JSC::SubspaceAccess>
    static JSC::GCClient::IsoSubspace* subspaceFor(JSC::VM& vm)
    {
        return &vm.plainObjectSpace();
    }
    static JSC::Structure* createStructure(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::JSValue prototype)
    {
        return JSC::Structure::create(vm, globalObject, prototype, JSC::TypeInfo(JSC::ObjectType, StructureFlags), info());
    }

private:
    JSMD5Prototype(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure)
        : Base(vm, structure)
    {
    }

    void finishCreation(JSC::VM&, JSC::JSGlobalObject*);
};

class JSMD5Constructor final : public JSC::InternalFunction {
public:
    using Base = JSC::InternalFunction;
    static JSMD5Constructor* create(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure, JSMD5Prototype* prototype);

    static constexpr unsigned StructureFlags = Base::StructureFlags;
    static constexpr bool needsDestruction = false;

    static JSC::Structure* createStructure(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::JSValue prototype)
    {
        return JSC::Structure::create(vm, globalObject, prototype, JSC::TypeInfo(JSC::InternalFunctionType, StructureFlags), info());
    }

    template<typename, JSC::SubspaceAccess mode> static JSC::GCClient::IsoSubspace* subspaceFor(JSC::VM& vm)
    {
        if constexpr (mode == JSC::SubspaceAccess::Concurrently)
            return nullptr;
        return WebCore::subspaceForImpl<JSMD5Constructor, WebCore::UseCustomHeapCellType::No>(
            vm,
            [](auto& spaces) { return spaces.m_clientSubspaceForMD5Constructor.get(); },
            [](auto& spaces, auto&& space) { spaces.m_clientSubspaceForMD5Constructor = std::forward<decltype(space)>(space); },
            [](auto& spaces) { return spaces.m_subspaceForMD5Constructor.get(); },
            [](auto& spaces, auto&& space) { spaces.m_subspaceForMD5Constructor = std::forward<decltype(space)>(space); });
    }

    void initializeProperties(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSMD5Prototype* prototype);

    // Must be defined for each specialization class.
    static JSC::EncodedJSValue JSC_HOST_CALL_ATTRIBUTES construct(JSC::JSGlobalObject*, JSC::CallFrame*);

    DECLARE_EXPORT_INFO;

private:
    JSMD5Constructor(JSC::VM& vm, JSC::Structure* structure);
    void finishCreation(JSC::VM&, JSC::JSGlobalObject* globalObject, JSMD5Prototype* prototype);
};

extern "C" void* MD5Class__construct(JSC::JSGlobalObject*, JSC::CallFrame*);
JSC_DECLARE_CUSTOM_GETTER(jsMD5Constructor);
extern "C" void MD5Class__finalize(void*);

extern "C" JSC::EncodedJSValue MD5Prototype__getByteLength(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject);
JSC_DECLARE_CUSTOM_GETTER(MD5Prototype__byteLengthGetterWrap);

extern "C" EncodedJSValue MD5Prototype__digest(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(MD5Prototype__digestCallback);

extern "C" EncodedJSValue MD5Prototype__update(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(MD5Prototype__updateCallback);

STATIC_ASSERT_ISO_SUBSPACE_SHARABLE(JSMD5Prototype, JSMD5Prototype::Base);

static const HashTableValue JSMD5PrototypeTableValues[] = {
    { "byteLength"_s, static_cast<unsigned>(JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::GetterSetterType, MD5Prototype__byteLengthGetterWrap, 0 } },
    { "digest"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, MD5Prototype__digestCallback, 0 } },
    { "update"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, MD5Prototype__updateCallback, 1 } }
};

const ClassInfo JSMD5Prototype::s_info = { "MD5"_s, &Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSMD5Prototype) };

JSC_DEFINE_CUSTOM_GETTER(jsMD5Constructor, (JSGlobalObject * lexicalGlobalObject, EncodedJSValue thisValue, PropertyName))
{
    VM& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    auto* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    auto* prototype = jsDynamicCast<JSMD5Prototype*>(JSValue::decode(thisValue));

    if (UNLIKELY(!prototype))
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    return JSValue::encode(globalObject->JSMD5Constructor());
}

JSC_DEFINE_CUSTOM_GETTER(MD5Prototype__byteLengthGetterWrap, (JSGlobalObject * lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    auto& vm = lexicalGlobalObject->vm();
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    JSMD5* thisObject = jsCast<JSMD5*>(JSValue::decode(thisValue));
    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);
    JSC::EncodedJSValue result = MD5Prototype__getByteLength(thisObject->wrapped(), globalObject);
    RETURN_IF_EXCEPTION(throwScope, {});
    RELEASE_AND_RETURN(throwScope, result);
}

JSC_DEFINE_HOST_FUNCTION(MD5Prototype__digestCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSMD5* thisObject = jsDynamicCast<JSMD5*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return MD5Prototype__digest(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_HOST_FUNCTION(MD5Prototype__updateCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSMD5* thisObject = jsDynamicCast<JSMD5*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return MD5Prototype__update(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

void JSMD5Prototype::finishCreation(JSC::VM& vm, JSC::JSGlobalObject* globalObject)
{
    Base::finishCreation(vm);
    reifyStaticProperties(vm, JSMD5::info(), JSMD5PrototypeTableValues, *this);
    JSC_TO_STRING_TAG_WITHOUT_TRANSITION();
}

extern "C" JSC_DECLARE_CUSTOM_GETTER(MD5Class__getByteLengthStatic);
extern "C" JSC_DECLARE_HOST_FUNCTION(MD5Class__hash);

static const HashTableValue JSMD5ConstructorTableValues[] = {
    { "byteLength"_s, static_cast<unsigned>(JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::GetterSetterType, MD5Class__getByteLengthStatic, 0 } },
    { "hash"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, MD5Class__hash, 2 } }
};

void JSMD5Constructor::finishCreation(VM& vm, JSC::JSGlobalObject* globalObject, JSMD5Prototype* prototype)
{
    Base::finishCreation(vm, 0, "MD5"_s, PropertyAdditionMode::WithoutStructureTransition);
    reifyStaticProperties(vm, &JSMD5Constructor::s_info, JSMD5ConstructorTableValues, *this);
    putDirectWithoutTransition(vm, vm.propertyNames->prototype, prototype, PropertyAttribute::DontEnum | PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly);
    ASSERT(inherits(info()));
}

JSMD5Constructor::JSMD5Constructor(JSC::VM& vm, JSC::Structure* structure)
    : Base(vm, structure, construct, construct)
{
}

JSMD5Constructor* JSMD5Constructor::create(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure, JSMD5Prototype* prototype)
{
    JSMD5Constructor* ptr = new (NotNull, JSC::allocateCell<JSMD5Constructor>(vm)) JSMD5Constructor(vm, structure);
    ptr->finishCreation(vm, globalObject, prototype);
    return ptr;
}

JSC::EncodedJSValue JSC_HOST_CALL_ATTRIBUTES JSMD5Constructor::construct(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame)
{
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    JSC::VM& vm = globalObject->vm();
    JSObject* newTarget = asObject(callFrame->newTarget());
    auto* constructor = globalObject->JSMD5Constructor();
    Structure* structure = globalObject->JSMD5Structure();
    if (constructor != newTarget) {
        auto scope = DECLARE_THROW_SCOPE(vm);

        auto* functionGlobalObject = reinterpret_cast<Zig::GlobalObject*>(
            // ShadowRealm functions belong to a different global object.
            getFunctionRealm(globalObject, newTarget));
        RETURN_IF_EXCEPTION(scope, {});
        structure = InternalFunction::createSubclassStructure(
            globalObject,
            newTarget,
            functionGlobalObject->JSMD5Structure());
    }

    void* ptr = MD5Class__construct(globalObject, callFrame);

    if (UNLIKELY(!ptr)) {
        return JSValue::encode(JSC::jsUndefined());
    }

    JSMD5* instance = JSMD5::create(vm, globalObject, structure, ptr);

    return JSValue::encode(instance);
}

void JSMD5Constructor::initializeProperties(VM& vm, JSC::JSGlobalObject* globalObject, JSMD5Prototype* prototype)
{
}

const ClassInfo JSMD5Constructor::s_info = { "Function"_s, &Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSMD5Constructor) };

extern "C" EncodedJSValue MD5__getConstructor(Zig::GlobalObject* globalObject)
{
    return JSValue::encode(globalObject->JSMD5Constructor());
}

JSMD5::~JSMD5()
{
    if (m_ctx) {
        MD5Class__finalize(m_ctx);
    }
}
void JSMD5::destroy(JSCell* cell)
{
    static_cast<JSMD5*>(cell)->JSMD5::~JSMD5();
}

const ClassInfo JSMD5::s_info = { "MD5"_s, &Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSMD5) };

void JSMD5::finishCreation(VM& vm)
{
    Base::finishCreation(vm);
    ASSERT(inherits(info()));
}

JSMD5* JSMD5::create(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure, void* ctx)
{
    JSMD5* ptr = new (NotNull, JSC::allocateCell<JSMD5>(vm)) JSMD5(vm, structure, ctx);
    ptr->finishCreation(vm);
    return ptr;
}

extern "C" void* MD5__fromJS(JSC::EncodedJSValue value)
{
    JSC::JSValue decodedValue = JSC::JSValue::decode(value);
    if (decodedValue.isEmpty() || !decodedValue.isCell())
        return nullptr;

    JSC::JSCell* cell = decodedValue.asCell();
    JSMD5* object = JSC::jsDynamicCast<JSMD5*>(cell);

    if (!object)
        return nullptr;

    return object->wrapped();
}

extern "C" bool MD5__dangerouslySetPtr(JSC::EncodedJSValue value, void* ptr)
{
    JSMD5* object = JSC::jsDynamicCast<JSMD5*>(JSValue::decode(value));
    if (!object)
        return false;

    object->m_ctx = ptr;
    return true;
}

extern "C" const size_t MD5__ptrOffset = JSMD5::offsetOfWrapped();

void JSMD5::analyzeHeap(JSCell* cell, HeapAnalyzer& analyzer)
{
    auto* thisObject = jsCast<JSMD5*>(cell);
    if (void* wrapped = thisObject->wrapped()) {
        // if (thisObject->scriptExecutionContext())
        //     analyzer.setLabelForCell(cell, "url " + thisObject->scriptExecutionContext()->url().string());
    }
    Base::analyzeHeap(cell, analyzer);
}

JSObject* JSMD5::createConstructor(VM& vm, JSGlobalObject* globalObject, JSValue prototype)
{
    return WebCore::JSMD5Constructor::create(vm, globalObject, WebCore::JSMD5Constructor::createStructure(vm, globalObject, globalObject->functionPrototype()), jsCast<WebCore::JSMD5Prototype*>(prototype));
}

JSObject* JSMD5::createPrototype(VM& vm, JSDOMGlobalObject* globalObject)
{
    return JSMD5Prototype::create(vm, globalObject, JSMD5Prototype::createStructure(vm, globalObject, globalObject->objectPrototype()));
}

extern "C" EncodedJSValue MD5__create(Zig::GlobalObject* globalObject, void* ptr)
{
    auto& vm = globalObject->vm();
    JSC::Structure* structure = globalObject->JSMD5Structure();
    JSMD5* instance = JSMD5::create(vm, globalObject, structure, ptr);

    return JSValue::encode(instance);
}
class JSMatchedRoutePrototype final : public JSC::JSNonFinalObject {
public:
    using Base = JSC::JSNonFinalObject;

    static JSMatchedRoutePrototype* create(JSC::VM& vm, JSGlobalObject* globalObject, JSC::Structure* structure)
    {
        JSMatchedRoutePrototype* ptr = new (NotNull, JSC::allocateCell<JSMatchedRoutePrototype>(vm)) JSMatchedRoutePrototype(vm, globalObject, structure);
        ptr->finishCreation(vm, globalObject);
        return ptr;
    }

    DECLARE_INFO;
    template<typename CellType, JSC::SubspaceAccess>
    static JSC::GCClient::IsoSubspace* subspaceFor(JSC::VM& vm)
    {
        return &vm.plainObjectSpace();
    }
    static JSC::Structure* createStructure(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::JSValue prototype)
    {
        return JSC::Structure::create(vm, globalObject, prototype, JSC::TypeInfo(JSC::ObjectType, StructureFlags), info());
    }

private:
    JSMatchedRoutePrototype(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure)
        : Base(vm, structure)
    {
    }

    void finishCreation(JSC::VM&, JSC::JSGlobalObject*);
};

extern "C" void* MatchedRouteClass__construct(JSC::JSGlobalObject*, JSC::CallFrame*);
JSC_DECLARE_CUSTOM_GETTER(jsMatchedRouteConstructor);
extern "C" void MatchedRouteClass__finalize(void*);

extern "C" JSC::EncodedJSValue MatchedRoutePrototype__getFilePath(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject);
JSC_DECLARE_CUSTOM_GETTER(MatchedRoutePrototype__filePathGetterWrap);

extern "C" JSC::EncodedJSValue MatchedRoutePrototype__getKind(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject);
JSC_DECLARE_CUSTOM_GETTER(MatchedRoutePrototype__kindGetterWrap);

extern "C" JSC::EncodedJSValue MatchedRoutePrototype__getName(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject);
JSC_DECLARE_CUSTOM_GETTER(MatchedRoutePrototype__nameGetterWrap);

extern "C" JSC::EncodedJSValue MatchedRoutePrototype__getParams(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject);
JSC_DECLARE_CUSTOM_GETTER(MatchedRoutePrototype__paramsGetterWrap);

extern "C" JSC::EncodedJSValue MatchedRoutePrototype__getPathname(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject);
JSC_DECLARE_CUSTOM_GETTER(MatchedRoutePrototype__pathnameGetterWrap);

extern "C" JSC::EncodedJSValue MatchedRoutePrototype__getQuery(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject);
JSC_DECLARE_CUSTOM_GETTER(MatchedRoutePrototype__queryGetterWrap);

extern "C" JSC::EncodedJSValue MatchedRoutePrototype__getScriptSrc(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject);
JSC_DECLARE_CUSTOM_GETTER(MatchedRoutePrototype__scriptSrcGetterWrap);

extern "C" JSC::EncodedJSValue MatchedRoutePrototype__getScriptSrc(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject);
JSC_DECLARE_CUSTOM_GETTER(MatchedRoutePrototype__srcGetterWrap);

STATIC_ASSERT_ISO_SUBSPACE_SHARABLE(JSMatchedRoutePrototype, JSMatchedRoutePrototype::Base);

static const HashTableValue JSMatchedRoutePrototypeTableValues[] = {
    { "filePath"_s, static_cast<unsigned>(JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::GetterSetterType, MatchedRoutePrototype__filePathGetterWrap, 0 } },
    { "kind"_s, static_cast<unsigned>(JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::GetterSetterType, MatchedRoutePrototype__kindGetterWrap, 0 } },
    { "name"_s, static_cast<unsigned>(JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::GetterSetterType, MatchedRoutePrototype__nameGetterWrap, 0 } },
    { "params"_s, static_cast<unsigned>(JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::GetterSetterType, MatchedRoutePrototype__paramsGetterWrap, 0 } },
    { "pathname"_s, static_cast<unsigned>(JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::GetterSetterType, MatchedRoutePrototype__pathnameGetterWrap, 0 } },
    { "query"_s, static_cast<unsigned>(JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::GetterSetterType, MatchedRoutePrototype__queryGetterWrap, 0 } },
    { "scriptSrc"_s, static_cast<unsigned>(JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::GetterSetterType, MatchedRoutePrototype__scriptSrcGetterWrap, 0 } },
    { "src"_s, static_cast<unsigned>(JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::GetterSetterType, MatchedRoutePrototype__srcGetterWrap, 0 } }
};

const ClassInfo JSMatchedRoutePrototype::s_info = { "MatchedRoute"_s, &Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSMatchedRoutePrototype) };

JSC_DEFINE_CUSTOM_GETTER(jsMatchedRouteConstructor, (JSGlobalObject * lexicalGlobalObject, EncodedJSValue thisValue, PropertyName))
{
    VM& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    auto* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    auto* prototype = jsDynamicCast<JSMatchedRoutePrototype*>(JSValue::decode(thisValue));

    if (UNLIKELY(!prototype))
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    return JSValue::encode(globalObject->JSMatchedRouteConstructor());
}

JSC_DEFINE_CUSTOM_GETTER(MatchedRoutePrototype__filePathGetterWrap, (JSGlobalObject * lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    auto& vm = lexicalGlobalObject->vm();
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    JSMatchedRoute* thisObject = jsCast<JSMatchedRoute*>(JSValue::decode(thisValue));
    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    if (JSValue cachedValue = thisObject->m_filePath.get())
        return JSValue::encode(cachedValue);

    JSC::JSValue result = JSC::JSValue::decode(
        MatchedRoutePrototype__getFilePath(thisObject->wrapped(), globalObject));
    RETURN_IF_EXCEPTION(throwScope, {});
    thisObject->m_filePath.set(vm, thisObject, result);
    RELEASE_AND_RETURN(throwScope, JSValue::encode(result));
}

extern "C" void MatchedRoutePrototype__filePathSetCachedValue(JSC::EncodedJSValue thisValue, JSC::JSGlobalObject* globalObject, JSC::EncodedJSValue value)
{
    auto& vm = globalObject->vm();
    auto* thisObject = jsCast<JSMatchedRoute*>(JSValue::decode(thisValue));
    thisObject->m_filePath.set(vm, thisObject, JSValue::decode(value));
}

extern "C" EncodedJSValue MatchedRoutePrototype__filePathGetCachedValue(JSC::EncodedJSValue thisValue)
{
    auto* thisObject = jsCast<JSMatchedRoute*>(JSValue::decode(thisValue));
    return JSValue::encode(thisObject->m_filePath.get());
}

JSC_DEFINE_CUSTOM_GETTER(MatchedRoutePrototype__kindGetterWrap, (JSGlobalObject * lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    auto& vm = lexicalGlobalObject->vm();
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    JSMatchedRoute* thisObject = jsCast<JSMatchedRoute*>(JSValue::decode(thisValue));
    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    if (JSValue cachedValue = thisObject->m_kind.get())
        return JSValue::encode(cachedValue);

    JSC::JSValue result = JSC::JSValue::decode(
        MatchedRoutePrototype__getKind(thisObject->wrapped(), globalObject));
    RETURN_IF_EXCEPTION(throwScope, {});
    thisObject->m_kind.set(vm, thisObject, result);
    RELEASE_AND_RETURN(throwScope, JSValue::encode(result));
}

extern "C" void MatchedRoutePrototype__kindSetCachedValue(JSC::EncodedJSValue thisValue, JSC::JSGlobalObject* globalObject, JSC::EncodedJSValue value)
{
    auto& vm = globalObject->vm();
    auto* thisObject = jsCast<JSMatchedRoute*>(JSValue::decode(thisValue));
    thisObject->m_kind.set(vm, thisObject, JSValue::decode(value));
}

extern "C" EncodedJSValue MatchedRoutePrototype__kindGetCachedValue(JSC::EncodedJSValue thisValue)
{
    auto* thisObject = jsCast<JSMatchedRoute*>(JSValue::decode(thisValue));
    return JSValue::encode(thisObject->m_kind.get());
}

JSC_DEFINE_CUSTOM_GETTER(MatchedRoutePrototype__nameGetterWrap, (JSGlobalObject * lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    auto& vm = lexicalGlobalObject->vm();
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    JSMatchedRoute* thisObject = jsCast<JSMatchedRoute*>(JSValue::decode(thisValue));
    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    if (JSValue cachedValue = thisObject->m_name.get())
        return JSValue::encode(cachedValue);

    JSC::JSValue result = JSC::JSValue::decode(
        MatchedRoutePrototype__getName(thisObject->wrapped(), globalObject));
    RETURN_IF_EXCEPTION(throwScope, {});
    thisObject->m_name.set(vm, thisObject, result);
    RELEASE_AND_RETURN(throwScope, JSValue::encode(result));
}

extern "C" void MatchedRoutePrototype__nameSetCachedValue(JSC::EncodedJSValue thisValue, JSC::JSGlobalObject* globalObject, JSC::EncodedJSValue value)
{
    auto& vm = globalObject->vm();
    auto* thisObject = jsCast<JSMatchedRoute*>(JSValue::decode(thisValue));
    thisObject->m_name.set(vm, thisObject, JSValue::decode(value));
}

extern "C" EncodedJSValue MatchedRoutePrototype__nameGetCachedValue(JSC::EncodedJSValue thisValue)
{
    auto* thisObject = jsCast<JSMatchedRoute*>(JSValue::decode(thisValue));
    return JSValue::encode(thisObject->m_name.get());
}

JSC_DEFINE_CUSTOM_GETTER(MatchedRoutePrototype__paramsGetterWrap, (JSGlobalObject * lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    auto& vm = lexicalGlobalObject->vm();
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    JSMatchedRoute* thisObject = jsCast<JSMatchedRoute*>(JSValue::decode(thisValue));
    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    if (JSValue cachedValue = thisObject->m_params.get())
        return JSValue::encode(cachedValue);

    JSC::JSValue result = JSC::JSValue::decode(
        MatchedRoutePrototype__getParams(thisObject->wrapped(), globalObject));
    RETURN_IF_EXCEPTION(throwScope, {});
    thisObject->m_params.set(vm, thisObject, result);
    RELEASE_AND_RETURN(throwScope, JSValue::encode(result));
}

extern "C" void MatchedRoutePrototype__paramsSetCachedValue(JSC::EncodedJSValue thisValue, JSC::JSGlobalObject* globalObject, JSC::EncodedJSValue value)
{
    auto& vm = globalObject->vm();
    auto* thisObject = jsCast<JSMatchedRoute*>(JSValue::decode(thisValue));
    thisObject->m_params.set(vm, thisObject, JSValue::decode(value));
}

extern "C" EncodedJSValue MatchedRoutePrototype__paramsGetCachedValue(JSC::EncodedJSValue thisValue)
{
    auto* thisObject = jsCast<JSMatchedRoute*>(JSValue::decode(thisValue));
    return JSValue::encode(thisObject->m_params.get());
}

JSC_DEFINE_CUSTOM_GETTER(MatchedRoutePrototype__pathnameGetterWrap, (JSGlobalObject * lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    auto& vm = lexicalGlobalObject->vm();
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    JSMatchedRoute* thisObject = jsCast<JSMatchedRoute*>(JSValue::decode(thisValue));
    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    if (JSValue cachedValue = thisObject->m_pathname.get())
        return JSValue::encode(cachedValue);

    JSC::JSValue result = JSC::JSValue::decode(
        MatchedRoutePrototype__getPathname(thisObject->wrapped(), globalObject));
    RETURN_IF_EXCEPTION(throwScope, {});
    thisObject->m_pathname.set(vm, thisObject, result);
    RELEASE_AND_RETURN(throwScope, JSValue::encode(result));
}

extern "C" void MatchedRoutePrototype__pathnameSetCachedValue(JSC::EncodedJSValue thisValue, JSC::JSGlobalObject* globalObject, JSC::EncodedJSValue value)
{
    auto& vm = globalObject->vm();
    auto* thisObject = jsCast<JSMatchedRoute*>(JSValue::decode(thisValue));
    thisObject->m_pathname.set(vm, thisObject, JSValue::decode(value));
}

extern "C" EncodedJSValue MatchedRoutePrototype__pathnameGetCachedValue(JSC::EncodedJSValue thisValue)
{
    auto* thisObject = jsCast<JSMatchedRoute*>(JSValue::decode(thisValue));
    return JSValue::encode(thisObject->m_pathname.get());
}

JSC_DEFINE_CUSTOM_GETTER(MatchedRoutePrototype__queryGetterWrap, (JSGlobalObject * lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    auto& vm = lexicalGlobalObject->vm();
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    JSMatchedRoute* thisObject = jsCast<JSMatchedRoute*>(JSValue::decode(thisValue));
    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    if (JSValue cachedValue = thisObject->m_query.get())
        return JSValue::encode(cachedValue);

    JSC::JSValue result = JSC::JSValue::decode(
        MatchedRoutePrototype__getQuery(thisObject->wrapped(), globalObject));
    RETURN_IF_EXCEPTION(throwScope, {});
    thisObject->m_query.set(vm, thisObject, result);
    RELEASE_AND_RETURN(throwScope, JSValue::encode(result));
}

extern "C" void MatchedRoutePrototype__querySetCachedValue(JSC::EncodedJSValue thisValue, JSC::JSGlobalObject* globalObject, JSC::EncodedJSValue value)
{
    auto& vm = globalObject->vm();
    auto* thisObject = jsCast<JSMatchedRoute*>(JSValue::decode(thisValue));
    thisObject->m_query.set(vm, thisObject, JSValue::decode(value));
}

extern "C" EncodedJSValue MatchedRoutePrototype__queryGetCachedValue(JSC::EncodedJSValue thisValue)
{
    auto* thisObject = jsCast<JSMatchedRoute*>(JSValue::decode(thisValue));
    return JSValue::encode(thisObject->m_query.get());
}

JSC_DEFINE_CUSTOM_GETTER(MatchedRoutePrototype__scriptSrcGetterWrap, (JSGlobalObject * lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    auto& vm = lexicalGlobalObject->vm();
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    JSMatchedRoute* thisObject = jsCast<JSMatchedRoute*>(JSValue::decode(thisValue));
    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    if (JSValue cachedValue = thisObject->m_scriptSrc.get())
        return JSValue::encode(cachedValue);

    JSC::JSValue result = JSC::JSValue::decode(
        MatchedRoutePrototype__getScriptSrc(thisObject->wrapped(), globalObject));
    RETURN_IF_EXCEPTION(throwScope, {});
    thisObject->m_scriptSrc.set(vm, thisObject, result);
    RELEASE_AND_RETURN(throwScope, JSValue::encode(result));
}

extern "C" void MatchedRoutePrototype__scriptSrcSetCachedValue(JSC::EncodedJSValue thisValue, JSC::JSGlobalObject* globalObject, JSC::EncodedJSValue value)
{
    auto& vm = globalObject->vm();
    auto* thisObject = jsCast<JSMatchedRoute*>(JSValue::decode(thisValue));
    thisObject->m_scriptSrc.set(vm, thisObject, JSValue::decode(value));
}

extern "C" EncodedJSValue MatchedRoutePrototype__scriptSrcGetCachedValue(JSC::EncodedJSValue thisValue)
{
    auto* thisObject = jsCast<JSMatchedRoute*>(JSValue::decode(thisValue));
    return JSValue::encode(thisObject->m_scriptSrc.get());
}

JSC_DEFINE_CUSTOM_GETTER(MatchedRoutePrototype__srcGetterWrap, (JSGlobalObject * lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    auto& vm = lexicalGlobalObject->vm();
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    JSMatchedRoute* thisObject = jsCast<JSMatchedRoute*>(JSValue::decode(thisValue));
    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    if (JSValue cachedValue = thisObject->m_scriptSrc.get())
        return JSValue::encode(cachedValue);

    JSC::JSValue result = JSC::JSValue::decode(
        MatchedRoutePrototype__getScriptSrc(thisObject->wrapped(), globalObject));
    RETURN_IF_EXCEPTION(throwScope, {});
    thisObject->m_scriptSrc.set(vm, thisObject, result);
    RELEASE_AND_RETURN(throwScope, JSValue::encode(result));
}

extern "C" void MatchedRoutePrototype__srcSetCachedValue(JSC::EncodedJSValue thisValue, JSC::JSGlobalObject* globalObject, JSC::EncodedJSValue value)
{
    auto& vm = globalObject->vm();
    auto* thisObject = jsCast<JSMatchedRoute*>(JSValue::decode(thisValue));
    thisObject->m_scriptSrc.set(vm, thisObject, JSValue::decode(value));
}

extern "C" EncodedJSValue MatchedRoutePrototype__srcGetCachedValue(JSC::EncodedJSValue thisValue)
{
    auto* thisObject = jsCast<JSMatchedRoute*>(JSValue::decode(thisValue));
    return JSValue::encode(thisObject->m_scriptSrc.get());
}

void JSMatchedRoutePrototype::finishCreation(JSC::VM& vm, JSC::JSGlobalObject* globalObject)
{
    Base::finishCreation(vm);
    reifyStaticProperties(vm, JSMatchedRoute::info(), JSMatchedRoutePrototypeTableValues, *this);
    JSC_TO_STRING_TAG_WITHOUT_TRANSITION();
}

JSMatchedRoute::~JSMatchedRoute()
{
    if (m_ctx) {
        MatchedRouteClass__finalize(m_ctx);
    }
}
void JSMatchedRoute::destroy(JSCell* cell)
{
    static_cast<JSMatchedRoute*>(cell)->JSMatchedRoute::~JSMatchedRoute();
}

const ClassInfo JSMatchedRoute::s_info = { "MatchedRoute"_s, &Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSMatchedRoute) };

void JSMatchedRoute::finishCreation(VM& vm)
{
    Base::finishCreation(vm);
    ASSERT(inherits(info()));
}

JSMatchedRoute* JSMatchedRoute::create(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure, void* ctx)
{
    JSMatchedRoute* ptr = new (NotNull, JSC::allocateCell<JSMatchedRoute>(vm)) JSMatchedRoute(vm, structure, ctx);
    ptr->finishCreation(vm);
    return ptr;
}

extern "C" void* MatchedRoute__fromJS(JSC::EncodedJSValue value)
{
    JSC::JSValue decodedValue = JSC::JSValue::decode(value);
    if (decodedValue.isEmpty() || !decodedValue.isCell())
        return nullptr;

    JSC::JSCell* cell = decodedValue.asCell();
    JSMatchedRoute* object = JSC::jsDynamicCast<JSMatchedRoute*>(cell);

    if (!object)
        return nullptr;

    return object->wrapped();
}

extern "C" bool MatchedRoute__dangerouslySetPtr(JSC::EncodedJSValue value, void* ptr)
{
    JSMatchedRoute* object = JSC::jsDynamicCast<JSMatchedRoute*>(JSValue::decode(value));
    if (!object)
        return false;

    object->m_ctx = ptr;
    return true;
}

extern "C" const size_t MatchedRoute__ptrOffset = JSMatchedRoute::offsetOfWrapped();

void JSMatchedRoute::analyzeHeap(JSCell* cell, HeapAnalyzer& analyzer)
{
    auto* thisObject = jsCast<JSMatchedRoute*>(cell);
    if (void* wrapped = thisObject->wrapped()) {
        // if (thisObject->scriptExecutionContext())
        //     analyzer.setLabelForCell(cell, "url " + thisObject->scriptExecutionContext()->url().string());
    }
    Base::analyzeHeap(cell, analyzer);
}

JSObject* JSMatchedRoute::createPrototype(VM& vm, JSDOMGlobalObject* globalObject)
{
    return JSMatchedRoutePrototype::create(vm, globalObject, JSMatchedRoutePrototype::createStructure(vm, globalObject, globalObject->objectPrototype()));
}

extern "C" EncodedJSValue MatchedRoute__create(Zig::GlobalObject* globalObject, void* ptr)
{
    auto& vm = globalObject->vm();
    JSC::Structure* structure = globalObject->JSMatchedRouteStructure();
    JSMatchedRoute* instance = JSMatchedRoute::create(vm, globalObject, structure, ptr);

    return JSValue::encode(instance);
}

template<typename Visitor>
void JSMatchedRoute::visitChildrenImpl(JSCell* cell, Visitor& visitor)
{
    JSMatchedRoute* thisObject = jsCast<JSMatchedRoute*>(cell);
    ASSERT_GC_OBJECT_INHERITS(thisObject, info());
    Base::visitChildren(thisObject, visitor);

    visitor.append(thisObject->m_filePath);
    visitor.append(thisObject->m_kind);
    visitor.append(thisObject->m_name);
    visitor.append(thisObject->m_params);
    visitor.append(thisObject->m_pathname);
    visitor.append(thisObject->m_query);
    visitor.append(thisObject->m_scriptSrc);
}

DEFINE_VISIT_CHILDREN(JSMatchedRoute);

template<typename Visitor>
void JSMatchedRoute::visitAdditionalChildren(Visitor& visitor)
{
    JSMatchedRoute* thisObject = this;
    ASSERT_GC_OBJECT_INHERITS(thisObject, info());

    visitor.append(thisObject->m_filePath);
    visitor.append(thisObject->m_kind);
    visitor.append(thisObject->m_name);
    visitor.append(thisObject->m_params);
    visitor.append(thisObject->m_pathname);
    visitor.append(thisObject->m_query);
    visitor.append(thisObject->m_scriptSrc);
    ;
}

DEFINE_VISIT_ADDITIONAL_CHILDREN(JSMatchedRoute);

template<typename Visitor>
void JSMatchedRoute::visitOutputConstraintsImpl(JSCell* cell, Visitor& visitor)
{
    JSMatchedRoute* thisObject = jsCast<JSMatchedRoute*>(cell);
    ASSERT_GC_OBJECT_INHERITS(thisObject, info());
    thisObject->visitAdditionalChildren<Visitor>(visitor);
}

DEFINE_VISIT_OUTPUT_CONSTRAINTS(JSMatchedRoute);
class JSNodeJSFSPrototype final : public JSC::JSNonFinalObject {
public:
    using Base = JSC::JSNonFinalObject;

    static JSNodeJSFSPrototype* create(JSC::VM& vm, JSGlobalObject* globalObject, JSC::Structure* structure)
    {
        JSNodeJSFSPrototype* ptr = new (NotNull, JSC::allocateCell<JSNodeJSFSPrototype>(vm)) JSNodeJSFSPrototype(vm, globalObject, structure);
        ptr->finishCreation(vm, globalObject);
        return ptr;
    }

    DECLARE_INFO;
    template<typename CellType, JSC::SubspaceAccess>
    static JSC::GCClient::IsoSubspace* subspaceFor(JSC::VM& vm)
    {
        return &vm.plainObjectSpace();
    }
    static JSC::Structure* createStructure(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::JSValue prototype)
    {
        return JSC::Structure::create(vm, globalObject, prototype, JSC::TypeInfo(JSC::ObjectType, StructureFlags), info());
    }

private:
    JSNodeJSFSPrototype(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure)
        : Base(vm, structure)
    {
    }

    void finishCreation(JSC::VM&, JSC::JSGlobalObject*);
};

class JSNodeJSFSConstructor final : public JSC::InternalFunction {
public:
    using Base = JSC::InternalFunction;
    static JSNodeJSFSConstructor* create(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure, JSNodeJSFSPrototype* prototype);

    static constexpr unsigned StructureFlags = Base::StructureFlags;
    static constexpr bool needsDestruction = false;

    static JSC::Structure* createStructure(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::JSValue prototype)
    {
        return JSC::Structure::create(vm, globalObject, prototype, JSC::TypeInfo(JSC::InternalFunctionType, StructureFlags), info());
    }

    template<typename, JSC::SubspaceAccess mode> static JSC::GCClient::IsoSubspace* subspaceFor(JSC::VM& vm)
    {
        if constexpr (mode == JSC::SubspaceAccess::Concurrently)
            return nullptr;
        return WebCore::subspaceForImpl<JSNodeJSFSConstructor, WebCore::UseCustomHeapCellType::No>(
            vm,
            [](auto& spaces) { return spaces.m_clientSubspaceForNodeJSFSConstructor.get(); },
            [](auto& spaces, auto&& space) { spaces.m_clientSubspaceForNodeJSFSConstructor = std::forward<decltype(space)>(space); },
            [](auto& spaces) { return spaces.m_subspaceForNodeJSFSConstructor.get(); },
            [](auto& spaces, auto&& space) { spaces.m_subspaceForNodeJSFSConstructor = std::forward<decltype(space)>(space); });
    }

    void initializeProperties(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSNodeJSFSPrototype* prototype);

    // Must be defined for each specialization class.
    static JSC::EncodedJSValue JSC_HOST_CALL_ATTRIBUTES construct(JSC::JSGlobalObject*, JSC::CallFrame*);

    DECLARE_EXPORT_INFO;

private:
    JSNodeJSFSConstructor(JSC::VM& vm, JSC::Structure* structure);
    void finishCreation(JSC::VM&, JSC::JSGlobalObject* globalObject, JSNodeJSFSPrototype* prototype);
};

extern "C" void* NodeJSFSClass__construct(JSC::JSGlobalObject*, JSC::CallFrame*);
JSC_DECLARE_CUSTOM_GETTER(jsNodeJSFSConstructor);
extern "C" void NodeJSFSClass__finalize(void*);

extern "C" EncodedJSValue NodeJSFSPrototype__access(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(NodeJSFSPrototype__accessCallback);

extern "C" EncodedJSValue NodeJSFSPrototype__accessSync(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(NodeJSFSPrototype__accessSyncCallback);

extern "C" EncodedJSValue NodeJSFSPrototype__appendFile(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(NodeJSFSPrototype__appendFileCallback);

extern "C" EncodedJSValue NodeJSFSPrototype__appendFileSync(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(NodeJSFSPrototype__appendFileSyncCallback);

extern "C" EncodedJSValue NodeJSFSPrototype__chmod(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(NodeJSFSPrototype__chmodCallback);

extern "C" EncodedJSValue NodeJSFSPrototype__chmodSync(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(NodeJSFSPrototype__chmodSyncCallback);

extern "C" EncodedJSValue NodeJSFSPrototype__chown(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(NodeJSFSPrototype__chownCallback);

extern "C" EncodedJSValue NodeJSFSPrototype__chownSync(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(NodeJSFSPrototype__chownSyncCallback);

extern "C" EncodedJSValue NodeJSFSPrototype__close(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(NodeJSFSPrototype__closeCallback);

extern "C" EncodedJSValue NodeJSFSPrototype__closeSync(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(NodeJSFSPrototype__closeSyncCallback);

extern "C" EncodedJSValue NodeJSFSPrototype__copyFile(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(NodeJSFSPrototype__copyFileCallback);

extern "C" EncodedJSValue NodeJSFSPrototype__copyFileSync(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(NodeJSFSPrototype__copyFileSyncCallback);

extern "C" JSC::EncodedJSValue NodeJSFSPrototype__getDirent(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject);
JSC_DECLARE_CUSTOM_GETTER(NodeJSFSPrototype__DirentGetterWrap);

extern "C" EncodedJSValue NodeJSFSPrototype__exists(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(NodeJSFSPrototype__existsCallback);

extern "C" EncodedJSValue NodeJSFSPrototype__existsSync(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(NodeJSFSPrototype__existsSyncCallback);

extern "C" EncodedJSValue NodeJSFSPrototype__fchmod(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(NodeJSFSPrototype__fchmodCallback);

extern "C" EncodedJSValue NodeJSFSPrototype__fchmodSync(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(NodeJSFSPrototype__fchmodSyncCallback);

extern "C" EncodedJSValue NodeJSFSPrototype__fchown(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(NodeJSFSPrototype__fchownCallback);

extern "C" EncodedJSValue NodeJSFSPrototype__fchownSync(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(NodeJSFSPrototype__fchownSyncCallback);

extern "C" EncodedJSValue NodeJSFSPrototype__fdatasync(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(NodeJSFSPrototype__fdatasyncCallback);

extern "C" EncodedJSValue NodeJSFSPrototype__fdatasyncSync(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(NodeJSFSPrototype__fdatasyncSyncCallback);

extern "C" EncodedJSValue NodeJSFSPrototype__fstat(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(NodeJSFSPrototype__fstatCallback);

extern "C" EncodedJSValue NodeJSFSPrototype__fstatSync(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(NodeJSFSPrototype__fstatSyncCallback);

extern "C" EncodedJSValue NodeJSFSPrototype__fsync(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(NodeJSFSPrototype__fsyncCallback);

extern "C" EncodedJSValue NodeJSFSPrototype__fsyncSync(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(NodeJSFSPrototype__fsyncSyncCallback);

extern "C" EncodedJSValue NodeJSFSPrototype__ftruncate(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(NodeJSFSPrototype__ftruncateCallback);

extern "C" EncodedJSValue NodeJSFSPrototype__ftruncateSync(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(NodeJSFSPrototype__ftruncateSyncCallback);

extern "C" EncodedJSValue NodeJSFSPrototype__futimes(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(NodeJSFSPrototype__futimesCallback);

extern "C" EncodedJSValue NodeJSFSPrototype__futimesSync(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(NodeJSFSPrototype__futimesSyncCallback);

extern "C" EncodedJSValue NodeJSFSPrototype__lchmod(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(NodeJSFSPrototype__lchmodCallback);

extern "C" EncodedJSValue NodeJSFSPrototype__lchmodSync(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(NodeJSFSPrototype__lchmodSyncCallback);

extern "C" EncodedJSValue NodeJSFSPrototype__lchown(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(NodeJSFSPrototype__lchownCallback);

extern "C" EncodedJSValue NodeJSFSPrototype__lchownSync(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(NodeJSFSPrototype__lchownSyncCallback);

extern "C" EncodedJSValue NodeJSFSPrototype__link(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(NodeJSFSPrototype__linkCallback);

extern "C" EncodedJSValue NodeJSFSPrototype__linkSync(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(NodeJSFSPrototype__linkSyncCallback);

extern "C" EncodedJSValue NodeJSFSPrototype__lstat(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(NodeJSFSPrototype__lstatCallback);

extern "C" EncodedJSValue NodeJSFSPrototype__lstatSync(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(NodeJSFSPrototype__lstatSyncCallback);

extern "C" EncodedJSValue NodeJSFSPrototype__lutimes(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(NodeJSFSPrototype__lutimesCallback);

extern "C" EncodedJSValue NodeJSFSPrototype__lutimesSync(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(NodeJSFSPrototype__lutimesSyncCallback);

extern "C" EncodedJSValue NodeJSFSPrototype__mkdir(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(NodeJSFSPrototype__mkdirCallback);

extern "C" EncodedJSValue NodeJSFSPrototype__mkdirSync(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(NodeJSFSPrototype__mkdirSyncCallback);

extern "C" EncodedJSValue NodeJSFSPrototype__mkdtemp(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(NodeJSFSPrototype__mkdtempCallback);

extern "C" EncodedJSValue NodeJSFSPrototype__mkdtempSync(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(NodeJSFSPrototype__mkdtempSyncCallback);

extern "C" EncodedJSValue NodeJSFSPrototype__open(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(NodeJSFSPrototype__openCallback);

extern "C" EncodedJSValue NodeJSFSPrototype__opendir(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(NodeJSFSPrototype__opendirCallback);

extern "C" EncodedJSValue NodeJSFSPrototype__opendirSync(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(NodeJSFSPrototype__opendirSyncCallback);

extern "C" EncodedJSValue NodeJSFSPrototype__openSync(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(NodeJSFSPrototype__openSyncCallback);

extern "C" EncodedJSValue NodeJSFSPrototype__read(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(NodeJSFSPrototype__readCallback);

extern "C" EncodedJSValue NodeJSFSPrototype__readdir(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(NodeJSFSPrototype__readdirCallback);

extern "C" EncodedJSValue NodeJSFSPrototype__readdirSync(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(NodeJSFSPrototype__readdirSyncCallback);

extern "C" EncodedJSValue NodeJSFSPrototype__readFile(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(NodeJSFSPrototype__readFileCallback);

extern "C" EncodedJSValue NodeJSFSPrototype__readFileSync(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(NodeJSFSPrototype__readFileSyncCallback);

extern "C" EncodedJSValue NodeJSFSPrototype__readlink(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(NodeJSFSPrototype__readlinkCallback);

extern "C" EncodedJSValue NodeJSFSPrototype__readlinkSync(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(NodeJSFSPrototype__readlinkSyncCallback);

extern "C" EncodedJSValue NodeJSFSPrototype__readSync(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(NodeJSFSPrototype__readSyncCallback);

extern "C" EncodedJSValue NodeJSFSPrototype__readv(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(NodeJSFSPrototype__readvCallback);

extern "C" EncodedJSValue NodeJSFSPrototype__readvSync(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(NodeJSFSPrototype__readvSyncCallback);

extern "C" EncodedJSValue NodeJSFSPrototype__realpath(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(NodeJSFSPrototype__realpathCallback);

extern "C" EncodedJSValue NodeJSFSPrototype__realpathSync(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(NodeJSFSPrototype__realpathSyncCallback);

extern "C" EncodedJSValue NodeJSFSPrototype__rename(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(NodeJSFSPrototype__renameCallback);

extern "C" EncodedJSValue NodeJSFSPrototype__renameSync(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(NodeJSFSPrototype__renameSyncCallback);

extern "C" EncodedJSValue NodeJSFSPrototype__rm(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(NodeJSFSPrototype__rmCallback);

extern "C" EncodedJSValue NodeJSFSPrototype__rmdir(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(NodeJSFSPrototype__rmdirCallback);

extern "C" EncodedJSValue NodeJSFSPrototype__rmdirSync(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(NodeJSFSPrototype__rmdirSyncCallback);

extern "C" EncodedJSValue NodeJSFSPrototype__rmSync(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(NodeJSFSPrototype__rmSyncCallback);

extern "C" EncodedJSValue NodeJSFSPrototype__stat(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(NodeJSFSPrototype__statCallback);

extern "C" JSC::EncodedJSValue NodeJSFSPrototype__getStats(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject);
JSC_DECLARE_CUSTOM_GETTER(NodeJSFSPrototype__StatsGetterWrap);

extern "C" EncodedJSValue NodeJSFSPrototype__statSync(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(NodeJSFSPrototype__statSyncCallback);

extern "C" EncodedJSValue NodeJSFSPrototype__symlink(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(NodeJSFSPrototype__symlinkCallback);

extern "C" EncodedJSValue NodeJSFSPrototype__symlinkSync(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(NodeJSFSPrototype__symlinkSyncCallback);

extern "C" EncodedJSValue NodeJSFSPrototype__truncate(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(NodeJSFSPrototype__truncateCallback);

extern "C" EncodedJSValue NodeJSFSPrototype__truncateSync(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(NodeJSFSPrototype__truncateSyncCallback);

extern "C" EncodedJSValue NodeJSFSPrototype__unlink(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(NodeJSFSPrototype__unlinkCallback);

extern "C" EncodedJSValue NodeJSFSPrototype__unlinkSync(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(NodeJSFSPrototype__unlinkSyncCallback);

extern "C" EncodedJSValue NodeJSFSPrototype__utimes(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(NodeJSFSPrototype__utimesCallback);

extern "C" EncodedJSValue NodeJSFSPrototype__utimesSync(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(NodeJSFSPrototype__utimesSyncCallback);

extern "C" EncodedJSValue NodeJSFSPrototype__write(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(NodeJSFSPrototype__writeCallback);

extern "C" EncodedJSValue NodeJSFSPrototype__writeFile(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(NodeJSFSPrototype__writeFileCallback);

extern "C" EncodedJSValue NodeJSFSPrototype__writeFileSync(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(NodeJSFSPrototype__writeFileSyncCallback);

extern "C" EncodedJSValue NodeJSFSPrototype__writeSync(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(NodeJSFSPrototype__writeSyncCallback);

extern "C" EncodedJSValue NodeJSFSPrototype__writev(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(NodeJSFSPrototype__writevCallback);

extern "C" EncodedJSValue NodeJSFSPrototype__writevSync(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(NodeJSFSPrototype__writevSyncCallback);

STATIC_ASSERT_ISO_SUBSPACE_SHARABLE(JSNodeJSFSPrototype, JSNodeJSFSPrototype::Base);

static const HashTableValue JSNodeJSFSPrototypeTableValues[] = {
    { "access"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, NodeJSFSPrototype__accessCallback, 3 } },
    { "accessSync"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, NodeJSFSPrototype__accessSyncCallback, 2 } },
    { "appendFile"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, NodeJSFSPrototype__appendFileCallback, 4 } },
    { "appendFileSync"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, NodeJSFSPrototype__appendFileSyncCallback, 3 } },
    { "chmod"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, NodeJSFSPrototype__chmodCallback, 3 } },
    { "chmodSync"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, NodeJSFSPrototype__chmodSyncCallback, 2 } },
    { "chown"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, NodeJSFSPrototype__chownCallback, 4 } },
    { "chownSync"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, NodeJSFSPrototype__chownSyncCallback, 3 } },
    { "close"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, NodeJSFSPrototype__closeCallback, 1 } },
    { "closeSync"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, NodeJSFSPrototype__closeSyncCallback, 1 } },
    { "copyFile"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, NodeJSFSPrototype__copyFileCallback, 4 } },
    { "copyFileSync"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, NodeJSFSPrototype__copyFileSyncCallback, 3 } },
    { "Dirent"_s, static_cast<unsigned>(JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::GetterSetterType, NodeJSFSPrototype__DirentGetterWrap, 0 } },
    { "exists"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, NodeJSFSPrototype__existsCallback, 2 } },
    { "existsSync"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, NodeJSFSPrototype__existsSyncCallback, 1 } },
    { "fchmod"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, NodeJSFSPrototype__fchmodCallback, 3 } },
    { "fchmodSync"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, NodeJSFSPrototype__fchmodSyncCallback, 2 } },
    { "fchown"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, NodeJSFSPrototype__fchownCallback, 4 } },
    { "fchownSync"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, NodeJSFSPrototype__fchownSyncCallback, 3 } },
    { "fdatasync"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, NodeJSFSPrototype__fdatasyncCallback, 2 } },
    { "fdatasyncSync"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, NodeJSFSPrototype__fdatasyncSyncCallback, 1 } },
    { "fstat"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, NodeJSFSPrototype__fstatCallback, 1 } },
    { "fstatSync"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, NodeJSFSPrototype__fstatSyncCallback, 1 } },
    { "fsync"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, NodeJSFSPrototype__fsyncCallback, 2 } },
    { "fsyncSync"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, NodeJSFSPrototype__fsyncSyncCallback, 1 } },
    { "ftruncate"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, NodeJSFSPrototype__ftruncateCallback, 1 } },
    { "ftruncateSync"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, NodeJSFSPrototype__ftruncateSyncCallback, 1 } },
    { "futimes"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, NodeJSFSPrototype__futimesCallback, 4 } },
    { "futimesSync"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, NodeJSFSPrototype__futimesSyncCallback, 3 } },
    { "lchmod"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, NodeJSFSPrototype__lchmodCallback, 3 } },
    { "lchmodSync"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, NodeJSFSPrototype__lchmodSyncCallback, 2 } },
    { "lchown"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, NodeJSFSPrototype__lchownCallback, 4 } },
    { "lchownSync"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, NodeJSFSPrototype__lchownSyncCallback, 3 } },
    { "link"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, NodeJSFSPrototype__linkCallback, 3 } },
    { "linkSync"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, NodeJSFSPrototype__linkSyncCallback, 2 } },
    { "lstat"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, NodeJSFSPrototype__lstatCallback, 1 } },
    { "lstatSync"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, NodeJSFSPrototype__lstatSyncCallback, 1 } },
    { "lutimes"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, NodeJSFSPrototype__lutimesCallback, 4 } },
    { "lutimesSync"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, NodeJSFSPrototype__lutimesSyncCallback, 3 } },
    { "mkdir"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, NodeJSFSPrototype__mkdirCallback, 3 } },
    { "mkdirSync"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, NodeJSFSPrototype__mkdirSyncCallback, 2 } },
    { "mkdtemp"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, NodeJSFSPrototype__mkdtempCallback, 3 } },
    { "mkdtempSync"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, NodeJSFSPrototype__mkdtempSyncCallback, 2 } },
    { "open"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, NodeJSFSPrototype__openCallback, 4 } },
    { "opendir"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, NodeJSFSPrototype__opendirCallback, 3 } },
    { "opendirSync"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, NodeJSFSPrototype__opendirSyncCallback, 2 } },
    { "openSync"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, NodeJSFSPrototype__openSyncCallback, 3 } },
    { "read"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, NodeJSFSPrototype__readCallback, 6 } },
    { "readdir"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, NodeJSFSPrototype__readdirCallback, 3 } },
    { "readdirSync"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, NodeJSFSPrototype__readdirSyncCallback, 2 } },
    { "readFile"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, NodeJSFSPrototype__readFileCallback, 3 } },
    { "readFileSync"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, NodeJSFSPrototype__readFileSyncCallback, 2 } },
    { "readlink"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, NodeJSFSPrototype__readlinkCallback, 3 } },
    { "readlinkSync"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, NodeJSFSPrototype__readlinkSyncCallback, 2 } },
    { "readSync"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, NodeJSFSPrototype__readSyncCallback, 5 } },
    { "readv"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, NodeJSFSPrototype__readvCallback, 4 } },
    { "readvSync"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, NodeJSFSPrototype__readvSyncCallback, 3 } },
    { "realpath"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, NodeJSFSPrototype__realpathCallback, 3 } },
    { "realpathSync"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, NodeJSFSPrototype__realpathSyncCallback, 2 } },
    { "rename"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, NodeJSFSPrototype__renameCallback, 3 } },
    { "renameSync"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, NodeJSFSPrototype__renameSyncCallback, 2 } },
    { "rm"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, NodeJSFSPrototype__rmCallback, 3 } },
    { "rmdir"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, NodeJSFSPrototype__rmdirCallback, 3 } },
    { "rmdirSync"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, NodeJSFSPrototype__rmdirSyncCallback, 2 } },
    { "rmSync"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, NodeJSFSPrototype__rmSyncCallback, 2 } },
    { "stat"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, NodeJSFSPrototype__statCallback, 1 } },
    { "Stats"_s, static_cast<unsigned>(JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::GetterSetterType, NodeJSFSPrototype__StatsGetterWrap, 0 } },
    { "statSync"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, NodeJSFSPrototype__statSyncCallback, 1 } },
    { "symlink"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, NodeJSFSPrototype__symlinkCallback, 4 } },
    { "symlinkSync"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, NodeJSFSPrototype__symlinkSyncCallback, 3 } },
    { "truncate"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, NodeJSFSPrototype__truncateCallback, 3 } },
    { "truncateSync"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, NodeJSFSPrototype__truncateSyncCallback, 2 } },
    { "unlink"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, NodeJSFSPrototype__unlinkCallback, 2 } },
    { "unlinkSync"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, NodeJSFSPrototype__unlinkSyncCallback, 1 } },
    { "utimes"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, NodeJSFSPrototype__utimesCallback, 4 } },
    { "utimesSync"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, NodeJSFSPrototype__utimesSyncCallback, 3 } },
    { "write"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, NodeJSFSPrototype__writeCallback, 6 } },
    { "writeFile"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, NodeJSFSPrototype__writeFileCallback, 4 } },
    { "writeFileSync"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, NodeJSFSPrototype__writeFileSyncCallback, 3 } },
    { "writeSync"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, NodeJSFSPrototype__writeSyncCallback, 5 } },
    { "writev"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, NodeJSFSPrototype__writevCallback, 4 } },
    { "writevSync"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, NodeJSFSPrototype__writevSyncCallback, 3 } }
};

const ClassInfo JSNodeJSFSPrototype::s_info = { "NodeJSFS"_s, &Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSNodeJSFSPrototype) };

JSC_DEFINE_CUSTOM_GETTER(jsNodeJSFSConstructor, (JSGlobalObject * lexicalGlobalObject, EncodedJSValue thisValue, PropertyName))
{
    VM& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    auto* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    auto* prototype = jsDynamicCast<JSNodeJSFSPrototype*>(JSValue::decode(thisValue));

    if (UNLIKELY(!prototype))
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    return JSValue::encode(globalObject->JSNodeJSFSConstructor());
}

JSC_DEFINE_HOST_FUNCTION(NodeJSFSPrototype__accessCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSNodeJSFS* thisObject = jsDynamicCast<JSNodeJSFS*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return NodeJSFSPrototype__access(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_HOST_FUNCTION(NodeJSFSPrototype__accessSyncCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSNodeJSFS* thisObject = jsDynamicCast<JSNodeJSFS*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return NodeJSFSPrototype__accessSync(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_HOST_FUNCTION(NodeJSFSPrototype__appendFileCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSNodeJSFS* thisObject = jsDynamicCast<JSNodeJSFS*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return NodeJSFSPrototype__appendFile(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_HOST_FUNCTION(NodeJSFSPrototype__appendFileSyncCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSNodeJSFS* thisObject = jsDynamicCast<JSNodeJSFS*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return NodeJSFSPrototype__appendFileSync(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_HOST_FUNCTION(NodeJSFSPrototype__chmodCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSNodeJSFS* thisObject = jsDynamicCast<JSNodeJSFS*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return NodeJSFSPrototype__chmod(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_HOST_FUNCTION(NodeJSFSPrototype__chmodSyncCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSNodeJSFS* thisObject = jsDynamicCast<JSNodeJSFS*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return NodeJSFSPrototype__chmodSync(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_HOST_FUNCTION(NodeJSFSPrototype__chownCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSNodeJSFS* thisObject = jsDynamicCast<JSNodeJSFS*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return NodeJSFSPrototype__chown(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_HOST_FUNCTION(NodeJSFSPrototype__chownSyncCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSNodeJSFS* thisObject = jsDynamicCast<JSNodeJSFS*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return NodeJSFSPrototype__chownSync(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_HOST_FUNCTION(NodeJSFSPrototype__closeCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSNodeJSFS* thisObject = jsDynamicCast<JSNodeJSFS*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return NodeJSFSPrototype__close(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_HOST_FUNCTION(NodeJSFSPrototype__closeSyncCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSNodeJSFS* thisObject = jsDynamicCast<JSNodeJSFS*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return NodeJSFSPrototype__closeSync(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_HOST_FUNCTION(NodeJSFSPrototype__copyFileCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSNodeJSFS* thisObject = jsDynamicCast<JSNodeJSFS*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return NodeJSFSPrototype__copyFile(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_HOST_FUNCTION(NodeJSFSPrototype__copyFileSyncCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSNodeJSFS* thisObject = jsDynamicCast<JSNodeJSFS*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return NodeJSFSPrototype__copyFileSync(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_CUSTOM_GETTER(NodeJSFSPrototype__DirentGetterWrap, (JSGlobalObject * lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    auto& vm = lexicalGlobalObject->vm();
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    JSNodeJSFS* thisObject = jsCast<JSNodeJSFS*>(JSValue::decode(thisValue));
    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);
    JSC::EncodedJSValue result = NodeJSFSPrototype__getDirent(thisObject->wrapped(), globalObject);
    RETURN_IF_EXCEPTION(throwScope, {});
    RELEASE_AND_RETURN(throwScope, result);
}

JSC_DEFINE_HOST_FUNCTION(NodeJSFSPrototype__existsCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSNodeJSFS* thisObject = jsDynamicCast<JSNodeJSFS*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return NodeJSFSPrototype__exists(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_HOST_FUNCTION(NodeJSFSPrototype__existsSyncCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSNodeJSFS* thisObject = jsDynamicCast<JSNodeJSFS*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return NodeJSFSPrototype__existsSync(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_HOST_FUNCTION(NodeJSFSPrototype__fchmodCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSNodeJSFS* thisObject = jsDynamicCast<JSNodeJSFS*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return NodeJSFSPrototype__fchmod(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_HOST_FUNCTION(NodeJSFSPrototype__fchmodSyncCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSNodeJSFS* thisObject = jsDynamicCast<JSNodeJSFS*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return NodeJSFSPrototype__fchmodSync(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_HOST_FUNCTION(NodeJSFSPrototype__fchownCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSNodeJSFS* thisObject = jsDynamicCast<JSNodeJSFS*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return NodeJSFSPrototype__fchown(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_HOST_FUNCTION(NodeJSFSPrototype__fchownSyncCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSNodeJSFS* thisObject = jsDynamicCast<JSNodeJSFS*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return NodeJSFSPrototype__fchownSync(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_HOST_FUNCTION(NodeJSFSPrototype__fdatasyncCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSNodeJSFS* thisObject = jsDynamicCast<JSNodeJSFS*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return NodeJSFSPrototype__fdatasync(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_HOST_FUNCTION(NodeJSFSPrototype__fdatasyncSyncCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSNodeJSFS* thisObject = jsDynamicCast<JSNodeJSFS*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return NodeJSFSPrototype__fdatasyncSync(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_HOST_FUNCTION(NodeJSFSPrototype__fstatCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSNodeJSFS* thisObject = jsDynamicCast<JSNodeJSFS*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return NodeJSFSPrototype__fstat(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_HOST_FUNCTION(NodeJSFSPrototype__fstatSyncCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSNodeJSFS* thisObject = jsDynamicCast<JSNodeJSFS*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return NodeJSFSPrototype__fstatSync(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_HOST_FUNCTION(NodeJSFSPrototype__fsyncCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSNodeJSFS* thisObject = jsDynamicCast<JSNodeJSFS*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return NodeJSFSPrototype__fsync(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_HOST_FUNCTION(NodeJSFSPrototype__fsyncSyncCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSNodeJSFS* thisObject = jsDynamicCast<JSNodeJSFS*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return NodeJSFSPrototype__fsyncSync(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_HOST_FUNCTION(NodeJSFSPrototype__ftruncateCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSNodeJSFS* thisObject = jsDynamicCast<JSNodeJSFS*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return NodeJSFSPrototype__ftruncate(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_HOST_FUNCTION(NodeJSFSPrototype__ftruncateSyncCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSNodeJSFS* thisObject = jsDynamicCast<JSNodeJSFS*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return NodeJSFSPrototype__ftruncateSync(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_HOST_FUNCTION(NodeJSFSPrototype__futimesCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSNodeJSFS* thisObject = jsDynamicCast<JSNodeJSFS*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return NodeJSFSPrototype__futimes(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_HOST_FUNCTION(NodeJSFSPrototype__futimesSyncCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSNodeJSFS* thisObject = jsDynamicCast<JSNodeJSFS*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return NodeJSFSPrototype__futimesSync(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_HOST_FUNCTION(NodeJSFSPrototype__lchmodCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSNodeJSFS* thisObject = jsDynamicCast<JSNodeJSFS*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return NodeJSFSPrototype__lchmod(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_HOST_FUNCTION(NodeJSFSPrototype__lchmodSyncCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSNodeJSFS* thisObject = jsDynamicCast<JSNodeJSFS*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return NodeJSFSPrototype__lchmodSync(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_HOST_FUNCTION(NodeJSFSPrototype__lchownCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSNodeJSFS* thisObject = jsDynamicCast<JSNodeJSFS*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return NodeJSFSPrototype__lchown(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_HOST_FUNCTION(NodeJSFSPrototype__lchownSyncCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSNodeJSFS* thisObject = jsDynamicCast<JSNodeJSFS*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return NodeJSFSPrototype__lchownSync(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_HOST_FUNCTION(NodeJSFSPrototype__linkCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSNodeJSFS* thisObject = jsDynamicCast<JSNodeJSFS*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return NodeJSFSPrototype__link(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_HOST_FUNCTION(NodeJSFSPrototype__linkSyncCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSNodeJSFS* thisObject = jsDynamicCast<JSNodeJSFS*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return NodeJSFSPrototype__linkSync(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_HOST_FUNCTION(NodeJSFSPrototype__lstatCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSNodeJSFS* thisObject = jsDynamicCast<JSNodeJSFS*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return NodeJSFSPrototype__lstat(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_HOST_FUNCTION(NodeJSFSPrototype__lstatSyncCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSNodeJSFS* thisObject = jsDynamicCast<JSNodeJSFS*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return NodeJSFSPrototype__lstatSync(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_HOST_FUNCTION(NodeJSFSPrototype__lutimesCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSNodeJSFS* thisObject = jsDynamicCast<JSNodeJSFS*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return NodeJSFSPrototype__lutimes(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_HOST_FUNCTION(NodeJSFSPrototype__lutimesSyncCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSNodeJSFS* thisObject = jsDynamicCast<JSNodeJSFS*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return NodeJSFSPrototype__lutimesSync(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_HOST_FUNCTION(NodeJSFSPrototype__mkdirCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSNodeJSFS* thisObject = jsDynamicCast<JSNodeJSFS*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return NodeJSFSPrototype__mkdir(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_HOST_FUNCTION(NodeJSFSPrototype__mkdirSyncCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSNodeJSFS* thisObject = jsDynamicCast<JSNodeJSFS*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return NodeJSFSPrototype__mkdirSync(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_HOST_FUNCTION(NodeJSFSPrototype__mkdtempCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSNodeJSFS* thisObject = jsDynamicCast<JSNodeJSFS*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return NodeJSFSPrototype__mkdtemp(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_HOST_FUNCTION(NodeJSFSPrototype__mkdtempSyncCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSNodeJSFS* thisObject = jsDynamicCast<JSNodeJSFS*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return NodeJSFSPrototype__mkdtempSync(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_HOST_FUNCTION(NodeJSFSPrototype__openCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSNodeJSFS* thisObject = jsDynamicCast<JSNodeJSFS*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return NodeJSFSPrototype__open(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_HOST_FUNCTION(NodeJSFSPrototype__opendirCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSNodeJSFS* thisObject = jsDynamicCast<JSNodeJSFS*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return NodeJSFSPrototype__opendir(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_HOST_FUNCTION(NodeJSFSPrototype__opendirSyncCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSNodeJSFS* thisObject = jsDynamicCast<JSNodeJSFS*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return NodeJSFSPrototype__opendirSync(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_HOST_FUNCTION(NodeJSFSPrototype__openSyncCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSNodeJSFS* thisObject = jsDynamicCast<JSNodeJSFS*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return NodeJSFSPrototype__openSync(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_HOST_FUNCTION(NodeJSFSPrototype__readCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSNodeJSFS* thisObject = jsDynamicCast<JSNodeJSFS*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return NodeJSFSPrototype__read(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_HOST_FUNCTION(NodeJSFSPrototype__readdirCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSNodeJSFS* thisObject = jsDynamicCast<JSNodeJSFS*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return NodeJSFSPrototype__readdir(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_HOST_FUNCTION(NodeJSFSPrototype__readdirSyncCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSNodeJSFS* thisObject = jsDynamicCast<JSNodeJSFS*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return NodeJSFSPrototype__readdirSync(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_HOST_FUNCTION(NodeJSFSPrototype__readFileCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSNodeJSFS* thisObject = jsDynamicCast<JSNodeJSFS*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return NodeJSFSPrototype__readFile(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_HOST_FUNCTION(NodeJSFSPrototype__readFileSyncCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSNodeJSFS* thisObject = jsDynamicCast<JSNodeJSFS*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return NodeJSFSPrototype__readFileSync(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_HOST_FUNCTION(NodeJSFSPrototype__readlinkCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSNodeJSFS* thisObject = jsDynamicCast<JSNodeJSFS*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return NodeJSFSPrototype__readlink(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_HOST_FUNCTION(NodeJSFSPrototype__readlinkSyncCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSNodeJSFS* thisObject = jsDynamicCast<JSNodeJSFS*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return NodeJSFSPrototype__readlinkSync(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_HOST_FUNCTION(NodeJSFSPrototype__readSyncCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSNodeJSFS* thisObject = jsDynamicCast<JSNodeJSFS*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return NodeJSFSPrototype__readSync(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_HOST_FUNCTION(NodeJSFSPrototype__readvCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSNodeJSFS* thisObject = jsDynamicCast<JSNodeJSFS*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return NodeJSFSPrototype__readv(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_HOST_FUNCTION(NodeJSFSPrototype__readvSyncCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSNodeJSFS* thisObject = jsDynamicCast<JSNodeJSFS*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return NodeJSFSPrototype__readvSync(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_HOST_FUNCTION(NodeJSFSPrototype__realpathCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSNodeJSFS* thisObject = jsDynamicCast<JSNodeJSFS*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return NodeJSFSPrototype__realpath(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_HOST_FUNCTION(NodeJSFSPrototype__realpathSyncCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSNodeJSFS* thisObject = jsDynamicCast<JSNodeJSFS*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return NodeJSFSPrototype__realpathSync(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_HOST_FUNCTION(NodeJSFSPrototype__renameCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSNodeJSFS* thisObject = jsDynamicCast<JSNodeJSFS*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return NodeJSFSPrototype__rename(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_HOST_FUNCTION(NodeJSFSPrototype__renameSyncCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSNodeJSFS* thisObject = jsDynamicCast<JSNodeJSFS*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return NodeJSFSPrototype__renameSync(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_HOST_FUNCTION(NodeJSFSPrototype__rmCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSNodeJSFS* thisObject = jsDynamicCast<JSNodeJSFS*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return NodeJSFSPrototype__rm(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_HOST_FUNCTION(NodeJSFSPrototype__rmdirCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSNodeJSFS* thisObject = jsDynamicCast<JSNodeJSFS*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return NodeJSFSPrototype__rmdir(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_HOST_FUNCTION(NodeJSFSPrototype__rmdirSyncCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSNodeJSFS* thisObject = jsDynamicCast<JSNodeJSFS*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return NodeJSFSPrototype__rmdirSync(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_HOST_FUNCTION(NodeJSFSPrototype__rmSyncCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSNodeJSFS* thisObject = jsDynamicCast<JSNodeJSFS*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return NodeJSFSPrototype__rmSync(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_HOST_FUNCTION(NodeJSFSPrototype__statCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSNodeJSFS* thisObject = jsDynamicCast<JSNodeJSFS*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return NodeJSFSPrototype__stat(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_CUSTOM_GETTER(NodeJSFSPrototype__StatsGetterWrap, (JSGlobalObject * lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    auto& vm = lexicalGlobalObject->vm();
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    JSNodeJSFS* thisObject = jsCast<JSNodeJSFS*>(JSValue::decode(thisValue));
    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);
    JSC::EncodedJSValue result = NodeJSFSPrototype__getStats(thisObject->wrapped(), globalObject);
    RETURN_IF_EXCEPTION(throwScope, {});
    RELEASE_AND_RETURN(throwScope, result);
}

JSC_DEFINE_HOST_FUNCTION(NodeJSFSPrototype__statSyncCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSNodeJSFS* thisObject = jsDynamicCast<JSNodeJSFS*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return NodeJSFSPrototype__statSync(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_HOST_FUNCTION(NodeJSFSPrototype__symlinkCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSNodeJSFS* thisObject = jsDynamicCast<JSNodeJSFS*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return NodeJSFSPrototype__symlink(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_HOST_FUNCTION(NodeJSFSPrototype__symlinkSyncCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSNodeJSFS* thisObject = jsDynamicCast<JSNodeJSFS*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return NodeJSFSPrototype__symlinkSync(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_HOST_FUNCTION(NodeJSFSPrototype__truncateCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSNodeJSFS* thisObject = jsDynamicCast<JSNodeJSFS*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return NodeJSFSPrototype__truncate(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_HOST_FUNCTION(NodeJSFSPrototype__truncateSyncCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSNodeJSFS* thisObject = jsDynamicCast<JSNodeJSFS*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return NodeJSFSPrototype__truncateSync(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_HOST_FUNCTION(NodeJSFSPrototype__unlinkCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSNodeJSFS* thisObject = jsDynamicCast<JSNodeJSFS*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return NodeJSFSPrototype__unlink(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_HOST_FUNCTION(NodeJSFSPrototype__unlinkSyncCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSNodeJSFS* thisObject = jsDynamicCast<JSNodeJSFS*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return NodeJSFSPrototype__unlinkSync(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_HOST_FUNCTION(NodeJSFSPrototype__utimesCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSNodeJSFS* thisObject = jsDynamicCast<JSNodeJSFS*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return NodeJSFSPrototype__utimes(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_HOST_FUNCTION(NodeJSFSPrototype__utimesSyncCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSNodeJSFS* thisObject = jsDynamicCast<JSNodeJSFS*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return NodeJSFSPrototype__utimesSync(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_HOST_FUNCTION(NodeJSFSPrototype__writeCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSNodeJSFS* thisObject = jsDynamicCast<JSNodeJSFS*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return NodeJSFSPrototype__write(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_HOST_FUNCTION(NodeJSFSPrototype__writeFileCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSNodeJSFS* thisObject = jsDynamicCast<JSNodeJSFS*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return NodeJSFSPrototype__writeFile(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_HOST_FUNCTION(NodeJSFSPrototype__writeFileSyncCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSNodeJSFS* thisObject = jsDynamicCast<JSNodeJSFS*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return NodeJSFSPrototype__writeFileSync(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_HOST_FUNCTION(NodeJSFSPrototype__writeSyncCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSNodeJSFS* thisObject = jsDynamicCast<JSNodeJSFS*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return NodeJSFSPrototype__writeSync(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_HOST_FUNCTION(NodeJSFSPrototype__writevCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSNodeJSFS* thisObject = jsDynamicCast<JSNodeJSFS*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return NodeJSFSPrototype__writev(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_HOST_FUNCTION(NodeJSFSPrototype__writevSyncCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSNodeJSFS* thisObject = jsDynamicCast<JSNodeJSFS*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return NodeJSFSPrototype__writevSync(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

void JSNodeJSFSPrototype::finishCreation(JSC::VM& vm, JSC::JSGlobalObject* globalObject)
{
    Base::finishCreation(vm);
    reifyStaticProperties(vm, JSNodeJSFS::info(), JSNodeJSFSPrototypeTableValues, *this);
    JSC_TO_STRING_TAG_WITHOUT_TRANSITION();
}

void JSNodeJSFSConstructor::finishCreation(VM& vm, JSC::JSGlobalObject* globalObject, JSNodeJSFSPrototype* prototype)
{
    Base::finishCreation(vm, 0, "NodeJSFS"_s, PropertyAdditionMode::WithoutStructureTransition);

    putDirectWithoutTransition(vm, vm.propertyNames->prototype, prototype, PropertyAttribute::DontEnum | PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly);
    ASSERT(inherits(info()));
}

JSNodeJSFSConstructor::JSNodeJSFSConstructor(JSC::VM& vm, JSC::Structure* structure)
    : Base(vm, structure, construct, construct)
{
}

JSNodeJSFSConstructor* JSNodeJSFSConstructor::create(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure, JSNodeJSFSPrototype* prototype)
{
    JSNodeJSFSConstructor* ptr = new (NotNull, JSC::allocateCell<JSNodeJSFSConstructor>(vm)) JSNodeJSFSConstructor(vm, structure);
    ptr->finishCreation(vm, globalObject, prototype);
    return ptr;
}

JSC::EncodedJSValue JSC_HOST_CALL_ATTRIBUTES JSNodeJSFSConstructor::construct(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame)
{
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    JSC::VM& vm = globalObject->vm();
    JSObject* newTarget = asObject(callFrame->newTarget());
    auto* constructor = globalObject->JSNodeJSFSConstructor();
    Structure* structure = globalObject->JSNodeJSFSStructure();
    if (constructor != newTarget) {
        auto scope = DECLARE_THROW_SCOPE(vm);

        auto* functionGlobalObject = reinterpret_cast<Zig::GlobalObject*>(
            // ShadowRealm functions belong to a different global object.
            getFunctionRealm(globalObject, newTarget));
        RETURN_IF_EXCEPTION(scope, {});
        structure = InternalFunction::createSubclassStructure(
            globalObject,
            newTarget,
            functionGlobalObject->JSNodeJSFSStructure());
    }

    void* ptr = NodeJSFSClass__construct(globalObject, callFrame);

    if (UNLIKELY(!ptr)) {
        return JSValue::encode(JSC::jsUndefined());
    }

    JSNodeJSFS* instance = JSNodeJSFS::create(vm, globalObject, structure, ptr);

    return JSValue::encode(instance);
}

void JSNodeJSFSConstructor::initializeProperties(VM& vm, JSC::JSGlobalObject* globalObject, JSNodeJSFSPrototype* prototype)
{
}

const ClassInfo JSNodeJSFSConstructor::s_info = { "Function"_s, &Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSNodeJSFSConstructor) };

extern "C" EncodedJSValue NodeJSFS__getConstructor(Zig::GlobalObject* globalObject)
{
    return JSValue::encode(globalObject->JSNodeJSFSConstructor());
}

JSNodeJSFS::~JSNodeJSFS()
{
}
void JSNodeJSFS::destroy(JSCell* cell)
{
    static_cast<JSNodeJSFS*>(cell)->JSNodeJSFS::~JSNodeJSFS();
}

const ClassInfo JSNodeJSFS::s_info = { "NodeJSFS"_s, &Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSNodeJSFS) };

void JSNodeJSFS::finishCreation(VM& vm)
{
    Base::finishCreation(vm);
    ASSERT(inherits(info()));
}

JSNodeJSFS* JSNodeJSFS::create(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure, void* ctx)
{
    JSNodeJSFS* ptr = new (NotNull, JSC::allocateCell<JSNodeJSFS>(vm)) JSNodeJSFS(vm, structure, ctx);
    ptr->finishCreation(vm);
    return ptr;
}

extern "C" void* NodeJSFS__fromJS(JSC::EncodedJSValue value)
{
    JSC::JSValue decodedValue = JSC::JSValue::decode(value);
    if (decodedValue.isEmpty() || !decodedValue.isCell())
        return nullptr;

    JSC::JSCell* cell = decodedValue.asCell();
    JSNodeJSFS* object = JSC::jsDynamicCast<JSNodeJSFS*>(cell);

    if (!object)
        return nullptr;

    return object->wrapped();
}

extern "C" bool NodeJSFS__dangerouslySetPtr(JSC::EncodedJSValue value, void* ptr)
{
    JSNodeJSFS* object = JSC::jsDynamicCast<JSNodeJSFS*>(JSValue::decode(value));
    if (!object)
        return false;

    object->m_ctx = ptr;
    return true;
}

extern "C" const size_t NodeJSFS__ptrOffset = JSNodeJSFS::offsetOfWrapped();

void JSNodeJSFS::analyzeHeap(JSCell* cell, HeapAnalyzer& analyzer)
{
    auto* thisObject = jsCast<JSNodeJSFS*>(cell);
    if (void* wrapped = thisObject->wrapped()) {
        // if (thisObject->scriptExecutionContext())
        //     analyzer.setLabelForCell(cell, "url " + thisObject->scriptExecutionContext()->url().string());
    }
    Base::analyzeHeap(cell, analyzer);
}

JSObject* JSNodeJSFS::createConstructor(VM& vm, JSGlobalObject* globalObject, JSValue prototype)
{
    return WebCore::JSNodeJSFSConstructor::create(vm, globalObject, WebCore::JSNodeJSFSConstructor::createStructure(vm, globalObject, globalObject->functionPrototype()), jsCast<WebCore::JSNodeJSFSPrototype*>(prototype));
}

JSObject* JSNodeJSFS::createPrototype(VM& vm, JSDOMGlobalObject* globalObject)
{
    return JSNodeJSFSPrototype::create(vm, globalObject, JSNodeJSFSPrototype::createStructure(vm, globalObject, globalObject->objectPrototype()));
}

extern "C" EncodedJSValue NodeJSFS__create(Zig::GlobalObject* globalObject, void* ptr)
{
    auto& vm = globalObject->vm();
    JSC::Structure* structure = globalObject->JSNodeJSFSStructure();
    JSNodeJSFS* instance = JSNodeJSFS::create(vm, globalObject, structure, ptr);

    return JSValue::encode(instance);
}
class JSRequestPrototype final : public JSC::JSNonFinalObject {
public:
    using Base = JSC::JSNonFinalObject;

    static JSRequestPrototype* create(JSC::VM& vm, JSGlobalObject* globalObject, JSC::Structure* structure)
    {
        JSRequestPrototype* ptr = new (NotNull, JSC::allocateCell<JSRequestPrototype>(vm)) JSRequestPrototype(vm, globalObject, structure);
        ptr->finishCreation(vm, globalObject);
        return ptr;
    }

    DECLARE_INFO;
    template<typename CellType, JSC::SubspaceAccess>
    static JSC::GCClient::IsoSubspace* subspaceFor(JSC::VM& vm)
    {
        return &vm.plainObjectSpace();
    }
    static JSC::Structure* createStructure(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::JSValue prototype)
    {
        return JSC::Structure::create(vm, globalObject, prototype, JSC::TypeInfo(JSC::ObjectType, StructureFlags), info());
    }

private:
    JSRequestPrototype(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure)
        : Base(vm, structure)
    {
    }

    void finishCreation(JSC::VM&, JSC::JSGlobalObject*);
};

class JSRequestConstructor final : public JSC::InternalFunction {
public:
    using Base = JSC::InternalFunction;
    static JSRequestConstructor* create(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure, JSRequestPrototype* prototype);

    static constexpr unsigned StructureFlags = Base::StructureFlags;
    static constexpr bool needsDestruction = false;

    static JSC::Structure* createStructure(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::JSValue prototype)
    {
        return JSC::Structure::create(vm, globalObject, prototype, JSC::TypeInfo(JSC::InternalFunctionType, StructureFlags), info());
    }

    template<typename, JSC::SubspaceAccess mode> static JSC::GCClient::IsoSubspace* subspaceFor(JSC::VM& vm)
    {
        if constexpr (mode == JSC::SubspaceAccess::Concurrently)
            return nullptr;
        return WebCore::subspaceForImpl<JSRequestConstructor, WebCore::UseCustomHeapCellType::No>(
            vm,
            [](auto& spaces) { return spaces.m_clientSubspaceForRequestConstructor.get(); },
            [](auto& spaces, auto&& space) { spaces.m_clientSubspaceForRequestConstructor = std::forward<decltype(space)>(space); },
            [](auto& spaces) { return spaces.m_subspaceForRequestConstructor.get(); },
            [](auto& spaces, auto&& space) { spaces.m_subspaceForRequestConstructor = std::forward<decltype(space)>(space); });
    }

    void initializeProperties(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSRequestPrototype* prototype);

    // Must be defined for each specialization class.
    static JSC::EncodedJSValue JSC_HOST_CALL_ATTRIBUTES construct(JSC::JSGlobalObject*, JSC::CallFrame*);

    DECLARE_EXPORT_INFO;

private:
    JSRequestConstructor(JSC::VM& vm, JSC::Structure* structure);
    void finishCreation(JSC::VM&, JSC::JSGlobalObject* globalObject, JSRequestPrototype* prototype);
};

extern "C" void* RequestClass__construct(JSC::JSGlobalObject*, JSC::CallFrame*);
JSC_DECLARE_CUSTOM_GETTER(jsRequestConstructor);
extern "C" void RequestClass__finalize(void*);

extern "C" EncodedJSValue RequestPrototype__getArrayBuffer(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(RequestPrototype__arrayBufferCallback);

extern "C" EncodedJSValue RequestPrototype__getBlob(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(RequestPrototype__blobCallback);

extern "C" JSC::EncodedJSValue RequestPrototype__getBody(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject);
JSC_DECLARE_CUSTOM_GETTER(RequestPrototype__bodyGetterWrap);

extern "C" JSC::EncodedJSValue RequestPrototype__getBodyUsed(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject);
JSC_DECLARE_CUSTOM_GETTER(RequestPrototype__bodyUsedGetterWrap);

extern "C" JSC::EncodedJSValue RequestPrototype__getCache(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject);
JSC_DECLARE_CUSTOM_GETTER(RequestPrototype__cacheGetterWrap);

extern "C" EncodedJSValue RequestPrototype__doClone(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(RequestPrototype__cloneCallback);

extern "C" JSC::EncodedJSValue RequestPrototype__getCredentials(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject);
JSC_DECLARE_CUSTOM_GETTER(RequestPrototype__credentialsGetterWrap);

extern "C" JSC::EncodedJSValue RequestPrototype__getDestination(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject);
JSC_DECLARE_CUSTOM_GETTER(RequestPrototype__destinationGetterWrap);

extern "C" EncodedJSValue RequestPrototype__getFormData(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(RequestPrototype__formDataCallback);

extern "C" JSC::EncodedJSValue RequestPrototype__getHeaders(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject);
JSC_DECLARE_CUSTOM_GETTER(RequestPrototype__headersGetterWrap);

extern "C" JSC::EncodedJSValue RequestPrototype__getIntegrity(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject);
JSC_DECLARE_CUSTOM_GETTER(RequestPrototype__integrityGetterWrap);

extern "C" EncodedJSValue RequestPrototype__getJSON(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(RequestPrototype__jsonCallback);

extern "C" JSC::EncodedJSValue RequestPrototype__getMethod(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject);
JSC_DECLARE_CUSTOM_GETTER(RequestPrototype__methodGetterWrap);

extern "C" JSC::EncodedJSValue RequestPrototype__getMode(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject);
JSC_DECLARE_CUSTOM_GETTER(RequestPrototype__modeGetterWrap);

extern "C" JSC::EncodedJSValue RequestPrototype__getRedirect(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject);
JSC_DECLARE_CUSTOM_GETTER(RequestPrototype__redirectGetterWrap);

extern "C" JSC::EncodedJSValue RequestPrototype__getReferrer(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject);
JSC_DECLARE_CUSTOM_GETTER(RequestPrototype__referrerGetterWrap);

extern "C" JSC::EncodedJSValue RequestPrototype__getReferrerPolicy(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject);
JSC_DECLARE_CUSTOM_GETTER(RequestPrototype__referrerPolicyGetterWrap);

extern "C" JSC::EncodedJSValue RequestPrototype__getSignal(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject);
JSC_DECLARE_CUSTOM_GETTER(RequestPrototype__signalGetterWrap);

extern "C" EncodedJSValue RequestPrototype__getText(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(RequestPrototype__textCallback);

extern "C" JSC::EncodedJSValue RequestPrototype__getUrl(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject);
JSC_DECLARE_CUSTOM_GETTER(RequestPrototype__urlGetterWrap);

STATIC_ASSERT_ISO_SUBSPACE_SHARABLE(JSRequestPrototype, JSRequestPrototype::Base);

static const HashTableValue JSRequestPrototypeTableValues[] = {
    { "arrayBuffer"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, RequestPrototype__arrayBufferCallback, 0 } },
    { "blob"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, RequestPrototype__blobCallback, 0 } },
    { "body"_s, static_cast<unsigned>(JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::GetterSetterType, RequestPrototype__bodyGetterWrap, 0 } },
    { "bodyUsed"_s, static_cast<unsigned>(JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::GetterSetterType, RequestPrototype__bodyUsedGetterWrap, 0 } },
    { "cache"_s, static_cast<unsigned>(JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::GetterSetterType, RequestPrototype__cacheGetterWrap, 0 } },
    { "clone"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, RequestPrototype__cloneCallback, 1 } },
    { "credentials"_s, static_cast<unsigned>(JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::GetterSetterType, RequestPrototype__credentialsGetterWrap, 0 } },
    { "destination"_s, static_cast<unsigned>(JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::GetterSetterType, RequestPrototype__destinationGetterWrap, 0 } },
    { "formData"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, RequestPrototype__formDataCallback, 0 } },
    { "headers"_s, static_cast<unsigned>(JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::GetterSetterType, RequestPrototype__headersGetterWrap, 0 } },
    { "integrity"_s, static_cast<unsigned>(JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::GetterSetterType, RequestPrototype__integrityGetterWrap, 0 } },
    { "json"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, RequestPrototype__jsonCallback, 0 } },
    { "method"_s, static_cast<unsigned>(JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::GetterSetterType, RequestPrototype__methodGetterWrap, 0 } },
    { "mode"_s, static_cast<unsigned>(JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::GetterSetterType, RequestPrototype__modeGetterWrap, 0 } },
    { "redirect"_s, static_cast<unsigned>(JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::GetterSetterType, RequestPrototype__redirectGetterWrap, 0 } },
    { "referrer"_s, static_cast<unsigned>(JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::GetterSetterType, RequestPrototype__referrerGetterWrap, 0 } },
    { "referrerPolicy"_s, static_cast<unsigned>(JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::GetterSetterType, RequestPrototype__referrerPolicyGetterWrap, 0 } },
    { "signal"_s, static_cast<unsigned>(JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::GetterSetterType, RequestPrototype__signalGetterWrap, 0 } },
    { "text"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, RequestPrototype__textCallback, 0 } },
    { "url"_s, static_cast<unsigned>(JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::GetterSetterType, RequestPrototype__urlGetterWrap, 0 } }
};

const ClassInfo JSRequestPrototype::s_info = { "Request"_s, &Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSRequestPrototype) };

JSC_DEFINE_CUSTOM_GETTER(jsRequestConstructor, (JSGlobalObject * lexicalGlobalObject, EncodedJSValue thisValue, PropertyName))
{
    VM& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    auto* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    auto* prototype = jsDynamicCast<JSRequestPrototype*>(JSValue::decode(thisValue));

    if (UNLIKELY(!prototype))
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    return JSValue::encode(globalObject->JSRequestConstructor());
}

JSC_DEFINE_HOST_FUNCTION(RequestPrototype__arrayBufferCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSRequest* thisObject = jsDynamicCast<JSRequest*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return RequestPrototype__getArrayBuffer(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_HOST_FUNCTION(RequestPrototype__blobCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSRequest* thisObject = jsDynamicCast<JSRequest*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return RequestPrototype__getBlob(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_CUSTOM_GETTER(RequestPrototype__bodyGetterWrap, (JSGlobalObject * lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    auto& vm = lexicalGlobalObject->vm();
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    JSRequest* thisObject = jsCast<JSRequest*>(JSValue::decode(thisValue));
    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    if (JSValue cachedValue = thisObject->m_body.get())
        return JSValue::encode(cachedValue);

    JSC::JSValue result = JSC::JSValue::decode(
        RequestPrototype__getBody(thisObject->wrapped(), globalObject));
    RETURN_IF_EXCEPTION(throwScope, {});
    thisObject->m_body.set(vm, thisObject, result);
    RELEASE_AND_RETURN(throwScope, JSValue::encode(result));
}

extern "C" void RequestPrototype__bodySetCachedValue(JSC::EncodedJSValue thisValue, JSC::JSGlobalObject* globalObject, JSC::EncodedJSValue value)
{
    auto& vm = globalObject->vm();
    auto* thisObject = jsCast<JSRequest*>(JSValue::decode(thisValue));
    thisObject->m_body.set(vm, thisObject, JSValue::decode(value));
}

extern "C" EncodedJSValue RequestPrototype__bodyGetCachedValue(JSC::EncodedJSValue thisValue)
{
    auto* thisObject = jsCast<JSRequest*>(JSValue::decode(thisValue));
    return JSValue::encode(thisObject->m_body.get());
}

JSC_DEFINE_CUSTOM_GETTER(RequestPrototype__bodyUsedGetterWrap, (JSGlobalObject * lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    auto& vm = lexicalGlobalObject->vm();
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    JSRequest* thisObject = jsCast<JSRequest*>(JSValue::decode(thisValue));
    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);
    JSC::EncodedJSValue result = RequestPrototype__getBodyUsed(thisObject->wrapped(), globalObject);
    RETURN_IF_EXCEPTION(throwScope, {});
    RELEASE_AND_RETURN(throwScope, result);
}

JSC_DEFINE_CUSTOM_GETTER(RequestPrototype__cacheGetterWrap, (JSGlobalObject * lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    auto& vm = lexicalGlobalObject->vm();
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    JSRequest* thisObject = jsCast<JSRequest*>(JSValue::decode(thisValue));
    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);
    JSC::EncodedJSValue result = RequestPrototype__getCache(thisObject->wrapped(), globalObject);
    RETURN_IF_EXCEPTION(throwScope, {});
    RELEASE_AND_RETURN(throwScope, result);
}

JSC_DEFINE_HOST_FUNCTION(RequestPrototype__cloneCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSRequest* thisObject = jsDynamicCast<JSRequest*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return RequestPrototype__doClone(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_CUSTOM_GETTER(RequestPrototype__credentialsGetterWrap, (JSGlobalObject * lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    auto& vm = lexicalGlobalObject->vm();
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    JSRequest* thisObject = jsCast<JSRequest*>(JSValue::decode(thisValue));
    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);
    JSC::EncodedJSValue result = RequestPrototype__getCredentials(thisObject->wrapped(), globalObject);
    RETURN_IF_EXCEPTION(throwScope, {});
    RELEASE_AND_RETURN(throwScope, result);
}

JSC_DEFINE_CUSTOM_GETTER(RequestPrototype__destinationGetterWrap, (JSGlobalObject * lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    auto& vm = lexicalGlobalObject->vm();
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    JSRequest* thisObject = jsCast<JSRequest*>(JSValue::decode(thisValue));
    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);
    JSC::EncodedJSValue result = RequestPrototype__getDestination(thisObject->wrapped(), globalObject);
    RETURN_IF_EXCEPTION(throwScope, {});
    RELEASE_AND_RETURN(throwScope, result);
}

JSC_DEFINE_HOST_FUNCTION(RequestPrototype__formDataCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSRequest* thisObject = jsDynamicCast<JSRequest*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return RequestPrototype__getFormData(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_CUSTOM_GETTER(RequestPrototype__headersGetterWrap, (JSGlobalObject * lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    auto& vm = lexicalGlobalObject->vm();
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    JSRequest* thisObject = jsCast<JSRequest*>(JSValue::decode(thisValue));
    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    if (JSValue cachedValue = thisObject->m_headers.get())
        return JSValue::encode(cachedValue);

    JSC::JSValue result = JSC::JSValue::decode(
        RequestPrototype__getHeaders(thisObject->wrapped(), globalObject));
    RETURN_IF_EXCEPTION(throwScope, {});
    thisObject->m_headers.set(vm, thisObject, result);
    RELEASE_AND_RETURN(throwScope, JSValue::encode(result));
}

extern "C" void RequestPrototype__headersSetCachedValue(JSC::EncodedJSValue thisValue, JSC::JSGlobalObject* globalObject, JSC::EncodedJSValue value)
{
    auto& vm = globalObject->vm();
    auto* thisObject = jsCast<JSRequest*>(JSValue::decode(thisValue));
    thisObject->m_headers.set(vm, thisObject, JSValue::decode(value));
}

extern "C" EncodedJSValue RequestPrototype__headersGetCachedValue(JSC::EncodedJSValue thisValue)
{
    auto* thisObject = jsCast<JSRequest*>(JSValue::decode(thisValue));
    return JSValue::encode(thisObject->m_headers.get());
}

JSC_DEFINE_CUSTOM_GETTER(RequestPrototype__integrityGetterWrap, (JSGlobalObject * lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    auto& vm = lexicalGlobalObject->vm();
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    JSRequest* thisObject = jsCast<JSRequest*>(JSValue::decode(thisValue));
    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);
    JSC::EncodedJSValue result = RequestPrototype__getIntegrity(thisObject->wrapped(), globalObject);
    RETURN_IF_EXCEPTION(throwScope, {});
    RELEASE_AND_RETURN(throwScope, result);
}

JSC_DEFINE_HOST_FUNCTION(RequestPrototype__jsonCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSRequest* thisObject = jsDynamicCast<JSRequest*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return RequestPrototype__getJSON(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_CUSTOM_GETTER(RequestPrototype__methodGetterWrap, (JSGlobalObject * lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    auto& vm = lexicalGlobalObject->vm();
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    JSRequest* thisObject = jsCast<JSRequest*>(JSValue::decode(thisValue));
    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);
    JSC::EncodedJSValue result = RequestPrototype__getMethod(thisObject->wrapped(), globalObject);
    RETURN_IF_EXCEPTION(throwScope, {});
    RELEASE_AND_RETURN(throwScope, result);
}

JSC_DEFINE_CUSTOM_GETTER(RequestPrototype__modeGetterWrap, (JSGlobalObject * lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    auto& vm = lexicalGlobalObject->vm();
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    JSRequest* thisObject = jsCast<JSRequest*>(JSValue::decode(thisValue));
    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);
    JSC::EncodedJSValue result = RequestPrototype__getMode(thisObject->wrapped(), globalObject);
    RETURN_IF_EXCEPTION(throwScope, {});
    RELEASE_AND_RETURN(throwScope, result);
}

JSC_DEFINE_CUSTOM_GETTER(RequestPrototype__redirectGetterWrap, (JSGlobalObject * lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    auto& vm = lexicalGlobalObject->vm();
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    JSRequest* thisObject = jsCast<JSRequest*>(JSValue::decode(thisValue));
    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);
    JSC::EncodedJSValue result = RequestPrototype__getRedirect(thisObject->wrapped(), globalObject);
    RETURN_IF_EXCEPTION(throwScope, {});
    RELEASE_AND_RETURN(throwScope, result);
}

JSC_DEFINE_CUSTOM_GETTER(RequestPrototype__referrerGetterWrap, (JSGlobalObject * lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    auto& vm = lexicalGlobalObject->vm();
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    JSRequest* thisObject = jsCast<JSRequest*>(JSValue::decode(thisValue));
    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);
    JSC::EncodedJSValue result = RequestPrototype__getReferrer(thisObject->wrapped(), globalObject);
    RETURN_IF_EXCEPTION(throwScope, {});
    RELEASE_AND_RETURN(throwScope, result);
}

JSC_DEFINE_CUSTOM_GETTER(RequestPrototype__referrerPolicyGetterWrap, (JSGlobalObject * lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    auto& vm = lexicalGlobalObject->vm();
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    JSRequest* thisObject = jsCast<JSRequest*>(JSValue::decode(thisValue));
    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);
    JSC::EncodedJSValue result = RequestPrototype__getReferrerPolicy(thisObject->wrapped(), globalObject);
    RETURN_IF_EXCEPTION(throwScope, {});
    RELEASE_AND_RETURN(throwScope, result);
}

JSC_DEFINE_CUSTOM_GETTER(RequestPrototype__signalGetterWrap, (JSGlobalObject * lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    auto& vm = lexicalGlobalObject->vm();
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    JSRequest* thisObject = jsCast<JSRequest*>(JSValue::decode(thisValue));
    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    if (JSValue cachedValue = thisObject->m_signal.get())
        return JSValue::encode(cachedValue);

    JSC::JSValue result = JSC::JSValue::decode(
        RequestPrototype__getSignal(thisObject->wrapped(), globalObject));
    RETURN_IF_EXCEPTION(throwScope, {});
    thisObject->m_signal.set(vm, thisObject, result);
    RELEASE_AND_RETURN(throwScope, JSValue::encode(result));
}

extern "C" void RequestPrototype__signalSetCachedValue(JSC::EncodedJSValue thisValue, JSC::JSGlobalObject* globalObject, JSC::EncodedJSValue value)
{
    auto& vm = globalObject->vm();
    auto* thisObject = jsCast<JSRequest*>(JSValue::decode(thisValue));
    thisObject->m_signal.set(vm, thisObject, JSValue::decode(value));
}

extern "C" EncodedJSValue RequestPrototype__signalGetCachedValue(JSC::EncodedJSValue thisValue)
{
    auto* thisObject = jsCast<JSRequest*>(JSValue::decode(thisValue));
    return JSValue::encode(thisObject->m_signal.get());
}

JSC_DEFINE_HOST_FUNCTION(RequestPrototype__textCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSRequest* thisObject = jsDynamicCast<JSRequest*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return RequestPrototype__getText(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_CUSTOM_GETTER(RequestPrototype__urlGetterWrap, (JSGlobalObject * lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    auto& vm = lexicalGlobalObject->vm();
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    JSRequest* thisObject = jsCast<JSRequest*>(JSValue::decode(thisValue));
    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    if (JSValue cachedValue = thisObject->m_url.get())
        return JSValue::encode(cachedValue);

    JSC::JSValue result = JSC::JSValue::decode(
        RequestPrototype__getUrl(thisObject->wrapped(), globalObject));
    RETURN_IF_EXCEPTION(throwScope, {});
    thisObject->m_url.set(vm, thisObject, result);
    RELEASE_AND_RETURN(throwScope, JSValue::encode(result));
}

extern "C" void RequestPrototype__urlSetCachedValue(JSC::EncodedJSValue thisValue, JSC::JSGlobalObject* globalObject, JSC::EncodedJSValue value)
{
    auto& vm = globalObject->vm();
    auto* thisObject = jsCast<JSRequest*>(JSValue::decode(thisValue));
    thisObject->m_url.set(vm, thisObject, JSValue::decode(value));
}

extern "C" EncodedJSValue RequestPrototype__urlGetCachedValue(JSC::EncodedJSValue thisValue)
{
    auto* thisObject = jsCast<JSRequest*>(JSValue::decode(thisValue));
    return JSValue::encode(thisObject->m_url.get());
}

void JSRequestPrototype::finishCreation(JSC::VM& vm, JSC::JSGlobalObject* globalObject)
{
    Base::finishCreation(vm);
    reifyStaticProperties(vm, JSRequest::info(), JSRequestPrototypeTableValues, *this);
    JSC_TO_STRING_TAG_WITHOUT_TRANSITION();
}

extern "C" size_t Request__estimatedSize(void* ptr);

void JSRequestConstructor::finishCreation(VM& vm, JSC::JSGlobalObject* globalObject, JSRequestPrototype* prototype)
{
    Base::finishCreation(vm, 0, "Request"_s, PropertyAdditionMode::WithoutStructureTransition);

    putDirectWithoutTransition(vm, vm.propertyNames->prototype, prototype, PropertyAttribute::DontEnum | PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly);
    ASSERT(inherits(info()));
}

JSRequestConstructor::JSRequestConstructor(JSC::VM& vm, JSC::Structure* structure)
    : Base(vm, structure, construct, construct)
{
}

JSRequestConstructor* JSRequestConstructor::create(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure, JSRequestPrototype* prototype)
{
    JSRequestConstructor* ptr = new (NotNull, JSC::allocateCell<JSRequestConstructor>(vm)) JSRequestConstructor(vm, structure);
    ptr->finishCreation(vm, globalObject, prototype);
    return ptr;
}

JSC::EncodedJSValue JSC_HOST_CALL_ATTRIBUTES JSRequestConstructor::construct(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame)
{
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    JSC::VM& vm = globalObject->vm();
    JSObject* newTarget = asObject(callFrame->newTarget());
    auto* constructor = globalObject->JSRequestConstructor();
    Structure* structure = globalObject->JSRequestStructure();
    if (constructor != newTarget) {
        auto scope = DECLARE_THROW_SCOPE(vm);

        auto* functionGlobalObject = reinterpret_cast<Zig::GlobalObject*>(
            // ShadowRealm functions belong to a different global object.
            getFunctionRealm(globalObject, newTarget));
        RETURN_IF_EXCEPTION(scope, {});
        structure = InternalFunction::createSubclassStructure(
            globalObject,
            newTarget,
            functionGlobalObject->JSRequestStructure());
    }

    void* ptr = RequestClass__construct(globalObject, callFrame);

    if (UNLIKELY(!ptr)) {
        return JSValue::encode(JSC::jsUndefined());
    }

    JSRequest* instance = JSRequest::create(vm, globalObject, structure, ptr);
    vm.heap.reportExtraMemoryAllocated(Request__estimatedSize(instance->wrapped()));

    return JSValue::encode(instance);
}

void JSRequestConstructor::initializeProperties(VM& vm, JSC::JSGlobalObject* globalObject, JSRequestPrototype* prototype)
{
}

const ClassInfo JSRequestConstructor::s_info = { "Function"_s, &Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSRequestConstructor) };

extern "C" EncodedJSValue Request__getConstructor(Zig::GlobalObject* globalObject)
{
    return JSValue::encode(globalObject->JSRequestConstructor());
}

JSRequest::~JSRequest()
{
    if (m_ctx) {
        RequestClass__finalize(m_ctx);
    }
}
void JSRequest::destroy(JSCell* cell)
{
    static_cast<JSRequest*>(cell)->JSRequest::~JSRequest();
}

const ClassInfo JSRequest::s_info = { "Request"_s, &Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSRequest) };

void JSRequest::finishCreation(VM& vm)
{
    Base::finishCreation(vm);
    ASSERT(inherits(info()));
}

JSRequest* JSRequest::create(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure, void* ctx)
{
    JSRequest* ptr = new (NotNull, JSC::allocateCell<JSRequest>(vm)) JSRequest(vm, structure, ctx);
    ptr->finishCreation(vm);
    return ptr;
}

extern "C" void* Request__fromJS(JSC::EncodedJSValue value)
{
    JSC::JSValue decodedValue = JSC::JSValue::decode(value);
    if (decodedValue.isEmpty() || !decodedValue.isCell())
        return nullptr;

    JSC::JSCell* cell = decodedValue.asCell();
    JSRequest* object = JSC::jsDynamicCast<JSRequest*>(cell);

    if (!object)
        return nullptr;

    return object->wrapped();
}

extern "C" bool Request__dangerouslySetPtr(JSC::EncodedJSValue value, void* ptr)
{
    JSRequest* object = JSC::jsDynamicCast<JSRequest*>(JSValue::decode(value));
    if (!object)
        return false;

    object->m_ctx = ptr;
    return true;
}

extern "C" const size_t Request__ptrOffset = JSRequest::offsetOfWrapped();

void JSRequest::analyzeHeap(JSCell* cell, HeapAnalyzer& analyzer)
{
    auto* thisObject = jsCast<JSRequest*>(cell);
    if (void* wrapped = thisObject->wrapped()) {
        // if (thisObject->scriptExecutionContext())
        //     analyzer.setLabelForCell(cell, "url " + thisObject->scriptExecutionContext()->url().string());
    }
    Base::analyzeHeap(cell, analyzer);
}

JSObject* JSRequest::createConstructor(VM& vm, JSGlobalObject* globalObject, JSValue prototype)
{
    return WebCore::JSRequestConstructor::create(vm, globalObject, WebCore::JSRequestConstructor::createStructure(vm, globalObject, globalObject->functionPrototype()), jsCast<WebCore::JSRequestPrototype*>(prototype));
}

JSObject* JSRequest::createPrototype(VM& vm, JSDOMGlobalObject* globalObject)
{
    return JSRequestPrototype::create(vm, globalObject, JSRequestPrototype::createStructure(vm, globalObject, globalObject->objectPrototype()));
}

extern "C" EncodedJSValue Request__create(Zig::GlobalObject* globalObject, void* ptr)
{
    auto& vm = globalObject->vm();
    JSC::Structure* structure = globalObject->JSRequestStructure();
    JSRequest* instance = JSRequest::create(vm, globalObject, structure, ptr);
    vm.heap.reportExtraMemoryAllocated(Request__estimatedSize(ptr));
    return JSValue::encode(instance);
}

template<typename Visitor>
void JSRequest::visitChildrenImpl(JSCell* cell, Visitor& visitor)
{
    JSRequest* thisObject = jsCast<JSRequest*>(cell);
    ASSERT_GC_OBJECT_INHERITS(thisObject, info());
    Base::visitChildren(thisObject, visitor);

    if (auto* ptr = thisObject->wrapped()) {
        visitor.reportExtraMemoryVisited(Request__estimatedSize(ptr));
    }
    visitor.append(thisObject->m_body);
    visitor.append(thisObject->m_headers);
    visitor.append(thisObject->m_signal);
    visitor.append(thisObject->m_url);
}

DEFINE_VISIT_CHILDREN(JSRequest);

template<typename Visitor>
void JSRequest::visitAdditionalChildren(Visitor& visitor)
{
    JSRequest* thisObject = this;
    ASSERT_GC_OBJECT_INHERITS(thisObject, info());

    visitor.append(thisObject->m_body);
    visitor.append(thisObject->m_headers);
    visitor.append(thisObject->m_signal);
    visitor.append(thisObject->m_url);
    ;
}

DEFINE_VISIT_ADDITIONAL_CHILDREN(JSRequest);

template<typename Visitor>
void JSRequest::visitOutputConstraintsImpl(JSCell* cell, Visitor& visitor)
{
    JSRequest* thisObject = jsCast<JSRequest*>(cell);
    ASSERT_GC_OBJECT_INHERITS(thisObject, info());
    thisObject->visitAdditionalChildren<Visitor>(visitor);
}

DEFINE_VISIT_OUTPUT_CONSTRAINTS(JSRequest);
class JSResponsePrototype final : public JSC::JSNonFinalObject {
public:
    using Base = JSC::JSNonFinalObject;

    static JSResponsePrototype* create(JSC::VM& vm, JSGlobalObject* globalObject, JSC::Structure* structure)
    {
        JSResponsePrototype* ptr = new (NotNull, JSC::allocateCell<JSResponsePrototype>(vm)) JSResponsePrototype(vm, globalObject, structure);
        ptr->finishCreation(vm, globalObject);
        return ptr;
    }

    DECLARE_INFO;
    template<typename CellType, JSC::SubspaceAccess>
    static JSC::GCClient::IsoSubspace* subspaceFor(JSC::VM& vm)
    {
        return &vm.plainObjectSpace();
    }
    static JSC::Structure* createStructure(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::JSValue prototype)
    {
        return JSC::Structure::create(vm, globalObject, prototype, JSC::TypeInfo(JSC::ObjectType, StructureFlags), info());
    }

private:
    JSResponsePrototype(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure)
        : Base(vm, structure)
    {
    }

    void finishCreation(JSC::VM&, JSC::JSGlobalObject*);
};

class JSResponseConstructor final : public JSC::InternalFunction {
public:
    using Base = JSC::InternalFunction;
    static JSResponseConstructor* create(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure, JSResponsePrototype* prototype);

    static constexpr unsigned StructureFlags = Base::StructureFlags;
    static constexpr bool needsDestruction = false;

    static JSC::Structure* createStructure(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::JSValue prototype)
    {
        return JSC::Structure::create(vm, globalObject, prototype, JSC::TypeInfo(JSC::InternalFunctionType, StructureFlags), info());
    }

    template<typename, JSC::SubspaceAccess mode> static JSC::GCClient::IsoSubspace* subspaceFor(JSC::VM& vm)
    {
        if constexpr (mode == JSC::SubspaceAccess::Concurrently)
            return nullptr;
        return WebCore::subspaceForImpl<JSResponseConstructor, WebCore::UseCustomHeapCellType::No>(
            vm,
            [](auto& spaces) { return spaces.m_clientSubspaceForResponseConstructor.get(); },
            [](auto& spaces, auto&& space) { spaces.m_clientSubspaceForResponseConstructor = std::forward<decltype(space)>(space); },
            [](auto& spaces) { return spaces.m_subspaceForResponseConstructor.get(); },
            [](auto& spaces, auto&& space) { spaces.m_subspaceForResponseConstructor = std::forward<decltype(space)>(space); });
    }

    void initializeProperties(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSResponsePrototype* prototype);

    // Must be defined for each specialization class.
    static JSC::EncodedJSValue JSC_HOST_CALL_ATTRIBUTES construct(JSC::JSGlobalObject*, JSC::CallFrame*);

    DECLARE_EXPORT_INFO;

private:
    JSResponseConstructor(JSC::VM& vm, JSC::Structure* structure);
    void finishCreation(JSC::VM&, JSC::JSGlobalObject* globalObject, JSResponsePrototype* prototype);
};

extern "C" void* ResponseClass__construct(JSC::JSGlobalObject*, JSC::CallFrame*);
JSC_DECLARE_CUSTOM_GETTER(jsResponseConstructor);
extern "C" void ResponseClass__finalize(void*);

extern "C" EncodedJSValue ResponsePrototype__getArrayBuffer(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(ResponsePrototype__arrayBufferCallback);

extern "C" EncodedJSValue ResponsePrototype__getBlob(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(ResponsePrototype__blobCallback);

extern "C" JSC::EncodedJSValue ResponsePrototype__getBody(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject);
JSC_DECLARE_CUSTOM_GETTER(ResponsePrototype__bodyGetterWrap);

extern "C" JSC::EncodedJSValue ResponsePrototype__getBodyUsed(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject);
JSC_DECLARE_CUSTOM_GETTER(ResponsePrototype__bodyUsedGetterWrap);

extern "C" EncodedJSValue ResponsePrototype__doClone(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(ResponsePrototype__cloneCallback);

extern "C" EncodedJSValue ResponsePrototype__getFormData(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(ResponsePrototype__formDataCallback);

extern "C" JSC::EncodedJSValue ResponsePrototype__getHeaders(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject);
JSC_DECLARE_CUSTOM_GETTER(ResponsePrototype__headersGetterWrap);

extern "C" EncodedJSValue ResponsePrototype__getJSON(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(ResponsePrototype__jsonCallback);

extern "C" JSC::EncodedJSValue ResponsePrototype__getOK(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject);
JSC_DECLARE_CUSTOM_GETTER(ResponsePrototype__okGetterWrap);

extern "C" JSC::EncodedJSValue ResponsePrototype__getRedirected(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject);
JSC_DECLARE_CUSTOM_GETTER(ResponsePrototype__redirectedGetterWrap);

extern "C" JSC::EncodedJSValue ResponsePrototype__getStatus(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject);
JSC_DECLARE_CUSTOM_GETTER(ResponsePrototype__statusGetterWrap);

extern "C" JSC::EncodedJSValue ResponsePrototype__getStatusText(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject);
JSC_DECLARE_CUSTOM_GETTER(ResponsePrototype__statusTextGetterWrap);

extern "C" EncodedJSValue ResponsePrototype__getText(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(ResponsePrototype__textCallback);

extern "C" JSC::EncodedJSValue ResponsePrototype__getResponseType(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject);
JSC_DECLARE_CUSTOM_GETTER(ResponsePrototype__typeGetterWrap);

extern "C" JSC::EncodedJSValue ResponsePrototype__getURL(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject);
JSC_DECLARE_CUSTOM_GETTER(ResponsePrototype__urlGetterWrap);

STATIC_ASSERT_ISO_SUBSPACE_SHARABLE(JSResponsePrototype, JSResponsePrototype::Base);

static const HashTableValue JSResponsePrototypeTableValues[] = {
    { "arrayBuffer"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, ResponsePrototype__arrayBufferCallback, 0 } },
    { "blob"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, ResponsePrototype__blobCallback, 0 } },
    { "body"_s, static_cast<unsigned>(JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::GetterSetterType, ResponsePrototype__bodyGetterWrap, 0 } },
    { "bodyUsed"_s, static_cast<unsigned>(JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::GetterSetterType, ResponsePrototype__bodyUsedGetterWrap, 0 } },
    { "clone"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, ResponsePrototype__cloneCallback, 1 } },
    { "formData"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, ResponsePrototype__formDataCallback, 0 } },
    { "headers"_s, static_cast<unsigned>(JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::GetterSetterType, ResponsePrototype__headersGetterWrap, 0 } },
    { "json"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, ResponsePrototype__jsonCallback, 0 } },
    { "ok"_s, static_cast<unsigned>(JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::GetterSetterType, ResponsePrototype__okGetterWrap, 0 } },
    { "redirected"_s, static_cast<unsigned>(JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::GetterSetterType, ResponsePrototype__redirectedGetterWrap, 0 } },
    { "status"_s, static_cast<unsigned>(JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::GetterSetterType, ResponsePrototype__statusGetterWrap, 0 } },
    { "statusText"_s, static_cast<unsigned>(JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::GetterSetterType, ResponsePrototype__statusTextGetterWrap, 0 } },
    { "text"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, ResponsePrototype__textCallback, 0 } },
    { "type"_s, static_cast<unsigned>(JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::GetterSetterType, ResponsePrototype__typeGetterWrap, 0 } },
    { "url"_s, static_cast<unsigned>(JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::GetterSetterType, ResponsePrototype__urlGetterWrap, 0 } }
};

const ClassInfo JSResponsePrototype::s_info = { "Response"_s, &Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSResponsePrototype) };

JSC_DEFINE_CUSTOM_GETTER(jsResponseConstructor, (JSGlobalObject * lexicalGlobalObject, EncodedJSValue thisValue, PropertyName))
{
    VM& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    auto* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    auto* prototype = jsDynamicCast<JSResponsePrototype*>(JSValue::decode(thisValue));

    if (UNLIKELY(!prototype))
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    return JSValue::encode(globalObject->JSResponseConstructor());
}

JSC_DEFINE_HOST_FUNCTION(ResponsePrototype__arrayBufferCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSResponse* thisObject = jsDynamicCast<JSResponse*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return ResponsePrototype__getArrayBuffer(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_HOST_FUNCTION(ResponsePrototype__blobCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSResponse* thisObject = jsDynamicCast<JSResponse*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return ResponsePrototype__getBlob(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_CUSTOM_GETTER(ResponsePrototype__bodyGetterWrap, (JSGlobalObject * lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    auto& vm = lexicalGlobalObject->vm();
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    JSResponse* thisObject = jsCast<JSResponse*>(JSValue::decode(thisValue));
    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    if (JSValue cachedValue = thisObject->m_body.get())
        return JSValue::encode(cachedValue);

    JSC::JSValue result = JSC::JSValue::decode(
        ResponsePrototype__getBody(thisObject->wrapped(), globalObject));
    RETURN_IF_EXCEPTION(throwScope, {});
    thisObject->m_body.set(vm, thisObject, result);
    RELEASE_AND_RETURN(throwScope, JSValue::encode(result));
}

extern "C" void ResponsePrototype__bodySetCachedValue(JSC::EncodedJSValue thisValue, JSC::JSGlobalObject* globalObject, JSC::EncodedJSValue value)
{
    auto& vm = globalObject->vm();
    auto* thisObject = jsCast<JSResponse*>(JSValue::decode(thisValue));
    thisObject->m_body.set(vm, thisObject, JSValue::decode(value));
}

extern "C" EncodedJSValue ResponsePrototype__bodyGetCachedValue(JSC::EncodedJSValue thisValue)
{
    auto* thisObject = jsCast<JSResponse*>(JSValue::decode(thisValue));
    return JSValue::encode(thisObject->m_body.get());
}

JSC_DEFINE_CUSTOM_GETTER(ResponsePrototype__bodyUsedGetterWrap, (JSGlobalObject * lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    auto& vm = lexicalGlobalObject->vm();
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    JSResponse* thisObject = jsCast<JSResponse*>(JSValue::decode(thisValue));
    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);
    JSC::EncodedJSValue result = ResponsePrototype__getBodyUsed(thisObject->wrapped(), globalObject);
    RETURN_IF_EXCEPTION(throwScope, {});
    RELEASE_AND_RETURN(throwScope, result);
}

JSC_DEFINE_HOST_FUNCTION(ResponsePrototype__cloneCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSResponse* thisObject = jsDynamicCast<JSResponse*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return ResponsePrototype__doClone(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_HOST_FUNCTION(ResponsePrototype__formDataCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSResponse* thisObject = jsDynamicCast<JSResponse*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return ResponsePrototype__getFormData(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_CUSTOM_GETTER(ResponsePrototype__headersGetterWrap, (JSGlobalObject * lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    auto& vm = lexicalGlobalObject->vm();
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    JSResponse* thisObject = jsCast<JSResponse*>(JSValue::decode(thisValue));
    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    if (JSValue cachedValue = thisObject->m_headers.get())
        return JSValue::encode(cachedValue);

    JSC::JSValue result = JSC::JSValue::decode(
        ResponsePrototype__getHeaders(thisObject->wrapped(), globalObject));
    RETURN_IF_EXCEPTION(throwScope, {});
    thisObject->m_headers.set(vm, thisObject, result);
    RELEASE_AND_RETURN(throwScope, JSValue::encode(result));
}

extern "C" void ResponsePrototype__headersSetCachedValue(JSC::EncodedJSValue thisValue, JSC::JSGlobalObject* globalObject, JSC::EncodedJSValue value)
{
    auto& vm = globalObject->vm();
    auto* thisObject = jsCast<JSResponse*>(JSValue::decode(thisValue));
    thisObject->m_headers.set(vm, thisObject, JSValue::decode(value));
}

extern "C" EncodedJSValue ResponsePrototype__headersGetCachedValue(JSC::EncodedJSValue thisValue)
{
    auto* thisObject = jsCast<JSResponse*>(JSValue::decode(thisValue));
    return JSValue::encode(thisObject->m_headers.get());
}

JSC_DEFINE_HOST_FUNCTION(ResponsePrototype__jsonCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSResponse* thisObject = jsDynamicCast<JSResponse*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return ResponsePrototype__getJSON(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_CUSTOM_GETTER(ResponsePrototype__okGetterWrap, (JSGlobalObject * lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    auto& vm = lexicalGlobalObject->vm();
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    JSResponse* thisObject = jsCast<JSResponse*>(JSValue::decode(thisValue));
    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);
    JSC::EncodedJSValue result = ResponsePrototype__getOK(thisObject->wrapped(), globalObject);
    RETURN_IF_EXCEPTION(throwScope, {});
    RELEASE_AND_RETURN(throwScope, result);
}

JSC_DEFINE_CUSTOM_GETTER(ResponsePrototype__redirectedGetterWrap, (JSGlobalObject * lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    auto& vm = lexicalGlobalObject->vm();
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    JSResponse* thisObject = jsCast<JSResponse*>(JSValue::decode(thisValue));
    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);
    JSC::EncodedJSValue result = ResponsePrototype__getRedirected(thisObject->wrapped(), globalObject);
    RETURN_IF_EXCEPTION(throwScope, {});
    RELEASE_AND_RETURN(throwScope, result);
}

JSC_DEFINE_CUSTOM_GETTER(ResponsePrototype__statusGetterWrap, (JSGlobalObject * lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    auto& vm = lexicalGlobalObject->vm();
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    JSResponse* thisObject = jsCast<JSResponse*>(JSValue::decode(thisValue));
    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);
    JSC::EncodedJSValue result = ResponsePrototype__getStatus(thisObject->wrapped(), globalObject);
    RETURN_IF_EXCEPTION(throwScope, {});
    RELEASE_AND_RETURN(throwScope, result);
}

JSC_DEFINE_CUSTOM_GETTER(ResponsePrototype__statusTextGetterWrap, (JSGlobalObject * lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    auto& vm = lexicalGlobalObject->vm();
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    JSResponse* thisObject = jsCast<JSResponse*>(JSValue::decode(thisValue));
    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    if (JSValue cachedValue = thisObject->m_statusText.get())
        return JSValue::encode(cachedValue);

    JSC::JSValue result = JSC::JSValue::decode(
        ResponsePrototype__getStatusText(thisObject->wrapped(), globalObject));
    RETURN_IF_EXCEPTION(throwScope, {});
    thisObject->m_statusText.set(vm, thisObject, result);
    RELEASE_AND_RETURN(throwScope, JSValue::encode(result));
}

extern "C" void ResponsePrototype__statusTextSetCachedValue(JSC::EncodedJSValue thisValue, JSC::JSGlobalObject* globalObject, JSC::EncodedJSValue value)
{
    auto& vm = globalObject->vm();
    auto* thisObject = jsCast<JSResponse*>(JSValue::decode(thisValue));
    thisObject->m_statusText.set(vm, thisObject, JSValue::decode(value));
}

extern "C" EncodedJSValue ResponsePrototype__statusTextGetCachedValue(JSC::EncodedJSValue thisValue)
{
    auto* thisObject = jsCast<JSResponse*>(JSValue::decode(thisValue));
    return JSValue::encode(thisObject->m_statusText.get());
}

JSC_DEFINE_HOST_FUNCTION(ResponsePrototype__textCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSResponse* thisObject = jsDynamicCast<JSResponse*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return ResponsePrototype__getText(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_CUSTOM_GETTER(ResponsePrototype__typeGetterWrap, (JSGlobalObject * lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    auto& vm = lexicalGlobalObject->vm();
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    JSResponse* thisObject = jsCast<JSResponse*>(JSValue::decode(thisValue));
    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);
    JSC::EncodedJSValue result = ResponsePrototype__getResponseType(thisObject->wrapped(), globalObject);
    RETURN_IF_EXCEPTION(throwScope, {});
    RELEASE_AND_RETURN(throwScope, result);
}

JSC_DEFINE_CUSTOM_GETTER(ResponsePrototype__urlGetterWrap, (JSGlobalObject * lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    auto& vm = lexicalGlobalObject->vm();
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    JSResponse* thisObject = jsCast<JSResponse*>(JSValue::decode(thisValue));
    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    if (JSValue cachedValue = thisObject->m_url.get())
        return JSValue::encode(cachedValue);

    JSC::JSValue result = JSC::JSValue::decode(
        ResponsePrototype__getURL(thisObject->wrapped(), globalObject));
    RETURN_IF_EXCEPTION(throwScope, {});
    thisObject->m_url.set(vm, thisObject, result);
    RELEASE_AND_RETURN(throwScope, JSValue::encode(result));
}

extern "C" void ResponsePrototype__urlSetCachedValue(JSC::EncodedJSValue thisValue, JSC::JSGlobalObject* globalObject, JSC::EncodedJSValue value)
{
    auto& vm = globalObject->vm();
    auto* thisObject = jsCast<JSResponse*>(JSValue::decode(thisValue));
    thisObject->m_url.set(vm, thisObject, JSValue::decode(value));
}

extern "C" EncodedJSValue ResponsePrototype__urlGetCachedValue(JSC::EncodedJSValue thisValue)
{
    auto* thisObject = jsCast<JSResponse*>(JSValue::decode(thisValue));
    return JSValue::encode(thisObject->m_url.get());
}

void JSResponsePrototype::finishCreation(JSC::VM& vm, JSC::JSGlobalObject* globalObject)
{
    Base::finishCreation(vm);
    reifyStaticProperties(vm, JSResponse::info(), JSResponsePrototypeTableValues, *this);
    JSC_TO_STRING_TAG_WITHOUT_TRANSITION();
}

extern "C" size_t Response__estimatedSize(void* ptr);
extern "C" JSC_DECLARE_HOST_FUNCTION(ResponseClass__constructError);
extern "C" JSC_DECLARE_HOST_FUNCTION(ResponseClass__constructJSON);
extern "C" JSC_DECLARE_HOST_FUNCTION(ResponseClass__constructRedirect);

static const HashTableValue JSResponseConstructorTableValues[] = {
    { "error"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, ResponseClass__constructError, 0 } },
    { "json"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, ResponseClass__constructJSON, 0 } },
    { "redirect"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, ResponseClass__constructRedirect, 0 } }
};

void JSResponseConstructor::finishCreation(VM& vm, JSC::JSGlobalObject* globalObject, JSResponsePrototype* prototype)
{
    Base::finishCreation(vm, 0, "Response"_s, PropertyAdditionMode::WithoutStructureTransition);
    reifyStaticProperties(vm, &JSResponseConstructor::s_info, JSResponseConstructorTableValues, *this);
    putDirectWithoutTransition(vm, vm.propertyNames->prototype, prototype, PropertyAttribute::DontEnum | PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly);
    ASSERT(inherits(info()));
}

JSResponseConstructor::JSResponseConstructor(JSC::VM& vm, JSC::Structure* structure)
    : Base(vm, structure, construct, construct)
{
}

JSResponseConstructor* JSResponseConstructor::create(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure, JSResponsePrototype* prototype)
{
    JSResponseConstructor* ptr = new (NotNull, JSC::allocateCell<JSResponseConstructor>(vm)) JSResponseConstructor(vm, structure);
    ptr->finishCreation(vm, globalObject, prototype);
    return ptr;
}

JSC::EncodedJSValue JSC_HOST_CALL_ATTRIBUTES JSResponseConstructor::construct(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame)
{
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    JSC::VM& vm = globalObject->vm();
    JSObject* newTarget = asObject(callFrame->newTarget());
    auto* constructor = globalObject->JSResponseConstructor();
    Structure* structure = globalObject->JSResponseStructure();
    if (constructor != newTarget) {
        auto scope = DECLARE_THROW_SCOPE(vm);

        auto* functionGlobalObject = reinterpret_cast<Zig::GlobalObject*>(
            // ShadowRealm functions belong to a different global object.
            getFunctionRealm(globalObject, newTarget));
        RETURN_IF_EXCEPTION(scope, {});
        structure = InternalFunction::createSubclassStructure(
            globalObject,
            newTarget,
            functionGlobalObject->JSResponseStructure());
    }

    void* ptr = ResponseClass__construct(globalObject, callFrame);

    if (UNLIKELY(!ptr)) {
        return JSValue::encode(JSC::jsUndefined());
    }

    JSResponse* instance = JSResponse::create(vm, globalObject, structure, ptr);
    vm.heap.reportExtraMemoryAllocated(Response__estimatedSize(instance->wrapped()));

    return JSValue::encode(instance);
}

void JSResponseConstructor::initializeProperties(VM& vm, JSC::JSGlobalObject* globalObject, JSResponsePrototype* prototype)
{
}

const ClassInfo JSResponseConstructor::s_info = { "Function"_s, &Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSResponseConstructor) };

extern "C" EncodedJSValue Response__getConstructor(Zig::GlobalObject* globalObject)
{
    return JSValue::encode(globalObject->JSResponseConstructor());
}

JSResponse::~JSResponse()
{
    if (m_ctx) {
        ResponseClass__finalize(m_ctx);
    }
}
void JSResponse::destroy(JSCell* cell)
{
    static_cast<JSResponse*>(cell)->JSResponse::~JSResponse();
}

const ClassInfo JSResponse::s_info = { "Response"_s, &Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSResponse) };

void JSResponse::finishCreation(VM& vm)
{
    Base::finishCreation(vm);
    ASSERT(inherits(info()));
}

JSResponse* JSResponse::create(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure, void* ctx)
{
    JSResponse* ptr = new (NotNull, JSC::allocateCell<JSResponse>(vm)) JSResponse(vm, structure, ctx);
    ptr->finishCreation(vm);
    return ptr;
}

extern "C" void* Response__fromJS(JSC::EncodedJSValue value)
{
    JSC::JSValue decodedValue = JSC::JSValue::decode(value);
    if (decodedValue.isEmpty() || !decodedValue.isCell())
        return nullptr;

    JSC::JSCell* cell = decodedValue.asCell();
    JSResponse* object = JSC::jsDynamicCast<JSResponse*>(cell);

    if (!object)
        return nullptr;

    return object->wrapped();
}

extern "C" bool Response__dangerouslySetPtr(JSC::EncodedJSValue value, void* ptr)
{
    JSResponse* object = JSC::jsDynamicCast<JSResponse*>(JSValue::decode(value));
    if (!object)
        return false;

    object->m_ctx = ptr;
    return true;
}

extern "C" const size_t Response__ptrOffset = JSResponse::offsetOfWrapped();

void JSResponse::analyzeHeap(JSCell* cell, HeapAnalyzer& analyzer)
{
    auto* thisObject = jsCast<JSResponse*>(cell);
    if (void* wrapped = thisObject->wrapped()) {
        // if (thisObject->scriptExecutionContext())
        //     analyzer.setLabelForCell(cell, "url " + thisObject->scriptExecutionContext()->url().string());
    }
    Base::analyzeHeap(cell, analyzer);
}

JSObject* JSResponse::createConstructor(VM& vm, JSGlobalObject* globalObject, JSValue prototype)
{
    return WebCore::JSResponseConstructor::create(vm, globalObject, WebCore::JSResponseConstructor::createStructure(vm, globalObject, globalObject->functionPrototype()), jsCast<WebCore::JSResponsePrototype*>(prototype));
}

JSObject* JSResponse::createPrototype(VM& vm, JSDOMGlobalObject* globalObject)
{
    return JSResponsePrototype::create(vm, globalObject, JSResponsePrototype::createStructure(vm, globalObject, globalObject->objectPrototype()));
}

extern "C" EncodedJSValue Response__create(Zig::GlobalObject* globalObject, void* ptr)
{
    auto& vm = globalObject->vm();
    JSC::Structure* structure = globalObject->JSResponseStructure();
    JSResponse* instance = JSResponse::create(vm, globalObject, structure, ptr);
    vm.heap.reportExtraMemoryAllocated(Response__estimatedSize(ptr));
    return JSValue::encode(instance);
}

template<typename Visitor>
void JSResponse::visitChildrenImpl(JSCell* cell, Visitor& visitor)
{
    JSResponse* thisObject = jsCast<JSResponse*>(cell);
    ASSERT_GC_OBJECT_INHERITS(thisObject, info());
    Base::visitChildren(thisObject, visitor);

    if (auto* ptr = thisObject->wrapped()) {
        visitor.reportExtraMemoryVisited(Response__estimatedSize(ptr));
    }
    visitor.append(thisObject->m_body);
    visitor.append(thisObject->m_headers);
    visitor.append(thisObject->m_statusText);
    visitor.append(thisObject->m_url);
}

DEFINE_VISIT_CHILDREN(JSResponse);

template<typename Visitor>
void JSResponse::visitAdditionalChildren(Visitor& visitor)
{
    JSResponse* thisObject = this;
    ASSERT_GC_OBJECT_INHERITS(thisObject, info());

    visitor.append(thisObject->m_body);
    visitor.append(thisObject->m_headers);
    visitor.append(thisObject->m_statusText);
    visitor.append(thisObject->m_url);
    ;
}

DEFINE_VISIT_ADDITIONAL_CHILDREN(JSResponse);

template<typename Visitor>
void JSResponse::visitOutputConstraintsImpl(JSCell* cell, Visitor& visitor)
{
    JSResponse* thisObject = jsCast<JSResponse*>(cell);
    ASSERT_GC_OBJECT_INHERITS(thisObject, info());
    thisObject->visitAdditionalChildren<Visitor>(visitor);
}

DEFINE_VISIT_OUTPUT_CONSTRAINTS(JSResponse);
class JSSHA1Prototype final : public JSC::JSNonFinalObject {
public:
    using Base = JSC::JSNonFinalObject;

    static JSSHA1Prototype* create(JSC::VM& vm, JSGlobalObject* globalObject, JSC::Structure* structure)
    {
        JSSHA1Prototype* ptr = new (NotNull, JSC::allocateCell<JSSHA1Prototype>(vm)) JSSHA1Prototype(vm, globalObject, structure);
        ptr->finishCreation(vm, globalObject);
        return ptr;
    }

    DECLARE_INFO;
    template<typename CellType, JSC::SubspaceAccess>
    static JSC::GCClient::IsoSubspace* subspaceFor(JSC::VM& vm)
    {
        return &vm.plainObjectSpace();
    }
    static JSC::Structure* createStructure(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::JSValue prototype)
    {
        return JSC::Structure::create(vm, globalObject, prototype, JSC::TypeInfo(JSC::ObjectType, StructureFlags), info());
    }

private:
    JSSHA1Prototype(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure)
        : Base(vm, structure)
    {
    }

    void finishCreation(JSC::VM&, JSC::JSGlobalObject*);
};

class JSSHA1Constructor final : public JSC::InternalFunction {
public:
    using Base = JSC::InternalFunction;
    static JSSHA1Constructor* create(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure, JSSHA1Prototype* prototype);

    static constexpr unsigned StructureFlags = Base::StructureFlags;
    static constexpr bool needsDestruction = false;

    static JSC::Structure* createStructure(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::JSValue prototype)
    {
        return JSC::Structure::create(vm, globalObject, prototype, JSC::TypeInfo(JSC::InternalFunctionType, StructureFlags), info());
    }

    template<typename, JSC::SubspaceAccess mode> static JSC::GCClient::IsoSubspace* subspaceFor(JSC::VM& vm)
    {
        if constexpr (mode == JSC::SubspaceAccess::Concurrently)
            return nullptr;
        return WebCore::subspaceForImpl<JSSHA1Constructor, WebCore::UseCustomHeapCellType::No>(
            vm,
            [](auto& spaces) { return spaces.m_clientSubspaceForSHA1Constructor.get(); },
            [](auto& spaces, auto&& space) { spaces.m_clientSubspaceForSHA1Constructor = std::forward<decltype(space)>(space); },
            [](auto& spaces) { return spaces.m_subspaceForSHA1Constructor.get(); },
            [](auto& spaces, auto&& space) { spaces.m_subspaceForSHA1Constructor = std::forward<decltype(space)>(space); });
    }

    void initializeProperties(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSSHA1Prototype* prototype);

    // Must be defined for each specialization class.
    static JSC::EncodedJSValue JSC_HOST_CALL_ATTRIBUTES construct(JSC::JSGlobalObject*, JSC::CallFrame*);

    DECLARE_EXPORT_INFO;

private:
    JSSHA1Constructor(JSC::VM& vm, JSC::Structure* structure);
    void finishCreation(JSC::VM&, JSC::JSGlobalObject* globalObject, JSSHA1Prototype* prototype);
};

extern "C" void* SHA1Class__construct(JSC::JSGlobalObject*, JSC::CallFrame*);
JSC_DECLARE_CUSTOM_GETTER(jsSHA1Constructor);
extern "C" void SHA1Class__finalize(void*);

extern "C" JSC::EncodedJSValue SHA1Prototype__getByteLength(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject);
JSC_DECLARE_CUSTOM_GETTER(SHA1Prototype__byteLengthGetterWrap);

extern "C" EncodedJSValue SHA1Prototype__digest(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(SHA1Prototype__digestCallback);

extern "C" EncodedJSValue SHA1Prototype__update(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(SHA1Prototype__updateCallback);

STATIC_ASSERT_ISO_SUBSPACE_SHARABLE(JSSHA1Prototype, JSSHA1Prototype::Base);

static const HashTableValue JSSHA1PrototypeTableValues[] = {
    { "byteLength"_s, static_cast<unsigned>(JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::GetterSetterType, SHA1Prototype__byteLengthGetterWrap, 0 } },
    { "digest"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, SHA1Prototype__digestCallback, 0 } },
    { "update"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, SHA1Prototype__updateCallback, 1 } }
};

const ClassInfo JSSHA1Prototype::s_info = { "SHA1"_s, &Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSSHA1Prototype) };

JSC_DEFINE_CUSTOM_GETTER(jsSHA1Constructor, (JSGlobalObject * lexicalGlobalObject, EncodedJSValue thisValue, PropertyName))
{
    VM& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    auto* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    auto* prototype = jsDynamicCast<JSSHA1Prototype*>(JSValue::decode(thisValue));

    if (UNLIKELY(!prototype))
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    return JSValue::encode(globalObject->JSSHA1Constructor());
}

JSC_DEFINE_CUSTOM_GETTER(SHA1Prototype__byteLengthGetterWrap, (JSGlobalObject * lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    auto& vm = lexicalGlobalObject->vm();
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    JSSHA1* thisObject = jsCast<JSSHA1*>(JSValue::decode(thisValue));
    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);
    JSC::EncodedJSValue result = SHA1Prototype__getByteLength(thisObject->wrapped(), globalObject);
    RETURN_IF_EXCEPTION(throwScope, {});
    RELEASE_AND_RETURN(throwScope, result);
}

JSC_DEFINE_HOST_FUNCTION(SHA1Prototype__digestCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSSHA1* thisObject = jsDynamicCast<JSSHA1*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return SHA1Prototype__digest(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_HOST_FUNCTION(SHA1Prototype__updateCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSSHA1* thisObject = jsDynamicCast<JSSHA1*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return SHA1Prototype__update(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

void JSSHA1Prototype::finishCreation(JSC::VM& vm, JSC::JSGlobalObject* globalObject)
{
    Base::finishCreation(vm);
    reifyStaticProperties(vm, JSSHA1::info(), JSSHA1PrototypeTableValues, *this);
    JSC_TO_STRING_TAG_WITHOUT_TRANSITION();
}

extern "C" JSC_DECLARE_CUSTOM_GETTER(SHA1Class__getByteLengthStatic);
extern "C" JSC_DECLARE_HOST_FUNCTION(SHA1Class__hash);

static const HashTableValue JSSHA1ConstructorTableValues[] = {
    { "byteLength"_s, static_cast<unsigned>(JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::GetterSetterType, SHA1Class__getByteLengthStatic, 0 } },
    { "hash"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, SHA1Class__hash, 2 } }
};

void JSSHA1Constructor::finishCreation(VM& vm, JSC::JSGlobalObject* globalObject, JSSHA1Prototype* prototype)
{
    Base::finishCreation(vm, 0, "SHA1"_s, PropertyAdditionMode::WithoutStructureTransition);
    reifyStaticProperties(vm, &JSSHA1Constructor::s_info, JSSHA1ConstructorTableValues, *this);
    putDirectWithoutTransition(vm, vm.propertyNames->prototype, prototype, PropertyAttribute::DontEnum | PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly);
    ASSERT(inherits(info()));
}

JSSHA1Constructor::JSSHA1Constructor(JSC::VM& vm, JSC::Structure* structure)
    : Base(vm, structure, construct, construct)
{
}

JSSHA1Constructor* JSSHA1Constructor::create(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure, JSSHA1Prototype* prototype)
{
    JSSHA1Constructor* ptr = new (NotNull, JSC::allocateCell<JSSHA1Constructor>(vm)) JSSHA1Constructor(vm, structure);
    ptr->finishCreation(vm, globalObject, prototype);
    return ptr;
}

JSC::EncodedJSValue JSC_HOST_CALL_ATTRIBUTES JSSHA1Constructor::construct(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame)
{
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    JSC::VM& vm = globalObject->vm();
    JSObject* newTarget = asObject(callFrame->newTarget());
    auto* constructor = globalObject->JSSHA1Constructor();
    Structure* structure = globalObject->JSSHA1Structure();
    if (constructor != newTarget) {
        auto scope = DECLARE_THROW_SCOPE(vm);

        auto* functionGlobalObject = reinterpret_cast<Zig::GlobalObject*>(
            // ShadowRealm functions belong to a different global object.
            getFunctionRealm(globalObject, newTarget));
        RETURN_IF_EXCEPTION(scope, {});
        structure = InternalFunction::createSubclassStructure(
            globalObject,
            newTarget,
            functionGlobalObject->JSSHA1Structure());
    }

    void* ptr = SHA1Class__construct(globalObject, callFrame);

    if (UNLIKELY(!ptr)) {
        return JSValue::encode(JSC::jsUndefined());
    }

    JSSHA1* instance = JSSHA1::create(vm, globalObject, structure, ptr);

    return JSValue::encode(instance);
}

void JSSHA1Constructor::initializeProperties(VM& vm, JSC::JSGlobalObject* globalObject, JSSHA1Prototype* prototype)
{
}

const ClassInfo JSSHA1Constructor::s_info = { "Function"_s, &Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSSHA1Constructor) };

extern "C" EncodedJSValue SHA1__getConstructor(Zig::GlobalObject* globalObject)
{
    return JSValue::encode(globalObject->JSSHA1Constructor());
}

JSSHA1::~JSSHA1()
{
    if (m_ctx) {
        SHA1Class__finalize(m_ctx);
    }
}
void JSSHA1::destroy(JSCell* cell)
{
    static_cast<JSSHA1*>(cell)->JSSHA1::~JSSHA1();
}

const ClassInfo JSSHA1::s_info = { "SHA1"_s, &Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSSHA1) };

void JSSHA1::finishCreation(VM& vm)
{
    Base::finishCreation(vm);
    ASSERT(inherits(info()));
}

JSSHA1* JSSHA1::create(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure, void* ctx)
{
    JSSHA1* ptr = new (NotNull, JSC::allocateCell<JSSHA1>(vm)) JSSHA1(vm, structure, ctx);
    ptr->finishCreation(vm);
    return ptr;
}

extern "C" void* SHA1__fromJS(JSC::EncodedJSValue value)
{
    JSC::JSValue decodedValue = JSC::JSValue::decode(value);
    if (decodedValue.isEmpty() || !decodedValue.isCell())
        return nullptr;

    JSC::JSCell* cell = decodedValue.asCell();
    JSSHA1* object = JSC::jsDynamicCast<JSSHA1*>(cell);

    if (!object)
        return nullptr;

    return object->wrapped();
}

extern "C" bool SHA1__dangerouslySetPtr(JSC::EncodedJSValue value, void* ptr)
{
    JSSHA1* object = JSC::jsDynamicCast<JSSHA1*>(JSValue::decode(value));
    if (!object)
        return false;

    object->m_ctx = ptr;
    return true;
}

extern "C" const size_t SHA1__ptrOffset = JSSHA1::offsetOfWrapped();

void JSSHA1::analyzeHeap(JSCell* cell, HeapAnalyzer& analyzer)
{
    auto* thisObject = jsCast<JSSHA1*>(cell);
    if (void* wrapped = thisObject->wrapped()) {
        // if (thisObject->scriptExecutionContext())
        //     analyzer.setLabelForCell(cell, "url " + thisObject->scriptExecutionContext()->url().string());
    }
    Base::analyzeHeap(cell, analyzer);
}

JSObject* JSSHA1::createConstructor(VM& vm, JSGlobalObject* globalObject, JSValue prototype)
{
    return WebCore::JSSHA1Constructor::create(vm, globalObject, WebCore::JSSHA1Constructor::createStructure(vm, globalObject, globalObject->functionPrototype()), jsCast<WebCore::JSSHA1Prototype*>(prototype));
}

JSObject* JSSHA1::createPrototype(VM& vm, JSDOMGlobalObject* globalObject)
{
    return JSSHA1Prototype::create(vm, globalObject, JSSHA1Prototype::createStructure(vm, globalObject, globalObject->objectPrototype()));
}

extern "C" EncodedJSValue SHA1__create(Zig::GlobalObject* globalObject, void* ptr)
{
    auto& vm = globalObject->vm();
    JSC::Structure* structure = globalObject->JSSHA1Structure();
    JSSHA1* instance = JSSHA1::create(vm, globalObject, structure, ptr);

    return JSValue::encode(instance);
}
class JSSHA224Prototype final : public JSC::JSNonFinalObject {
public:
    using Base = JSC::JSNonFinalObject;

    static JSSHA224Prototype* create(JSC::VM& vm, JSGlobalObject* globalObject, JSC::Structure* structure)
    {
        JSSHA224Prototype* ptr = new (NotNull, JSC::allocateCell<JSSHA224Prototype>(vm)) JSSHA224Prototype(vm, globalObject, structure);
        ptr->finishCreation(vm, globalObject);
        return ptr;
    }

    DECLARE_INFO;
    template<typename CellType, JSC::SubspaceAccess>
    static JSC::GCClient::IsoSubspace* subspaceFor(JSC::VM& vm)
    {
        return &vm.plainObjectSpace();
    }
    static JSC::Structure* createStructure(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::JSValue prototype)
    {
        return JSC::Structure::create(vm, globalObject, prototype, JSC::TypeInfo(JSC::ObjectType, StructureFlags), info());
    }

private:
    JSSHA224Prototype(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure)
        : Base(vm, structure)
    {
    }

    void finishCreation(JSC::VM&, JSC::JSGlobalObject*);
};

class JSSHA224Constructor final : public JSC::InternalFunction {
public:
    using Base = JSC::InternalFunction;
    static JSSHA224Constructor* create(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure, JSSHA224Prototype* prototype);

    static constexpr unsigned StructureFlags = Base::StructureFlags;
    static constexpr bool needsDestruction = false;

    static JSC::Structure* createStructure(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::JSValue prototype)
    {
        return JSC::Structure::create(vm, globalObject, prototype, JSC::TypeInfo(JSC::InternalFunctionType, StructureFlags), info());
    }

    template<typename, JSC::SubspaceAccess mode> static JSC::GCClient::IsoSubspace* subspaceFor(JSC::VM& vm)
    {
        if constexpr (mode == JSC::SubspaceAccess::Concurrently)
            return nullptr;
        return WebCore::subspaceForImpl<JSSHA224Constructor, WebCore::UseCustomHeapCellType::No>(
            vm,
            [](auto& spaces) { return spaces.m_clientSubspaceForSHA224Constructor.get(); },
            [](auto& spaces, auto&& space) { spaces.m_clientSubspaceForSHA224Constructor = std::forward<decltype(space)>(space); },
            [](auto& spaces) { return spaces.m_subspaceForSHA224Constructor.get(); },
            [](auto& spaces, auto&& space) { spaces.m_subspaceForSHA224Constructor = std::forward<decltype(space)>(space); });
    }

    void initializeProperties(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSSHA224Prototype* prototype);

    // Must be defined for each specialization class.
    static JSC::EncodedJSValue JSC_HOST_CALL_ATTRIBUTES construct(JSC::JSGlobalObject*, JSC::CallFrame*);

    DECLARE_EXPORT_INFO;

private:
    JSSHA224Constructor(JSC::VM& vm, JSC::Structure* structure);
    void finishCreation(JSC::VM&, JSC::JSGlobalObject* globalObject, JSSHA224Prototype* prototype);
};

extern "C" void* SHA224Class__construct(JSC::JSGlobalObject*, JSC::CallFrame*);
JSC_DECLARE_CUSTOM_GETTER(jsSHA224Constructor);
extern "C" void SHA224Class__finalize(void*);

extern "C" JSC::EncodedJSValue SHA224Prototype__getByteLength(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject);
JSC_DECLARE_CUSTOM_GETTER(SHA224Prototype__byteLengthGetterWrap);

extern "C" EncodedJSValue SHA224Prototype__digest(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(SHA224Prototype__digestCallback);

extern "C" EncodedJSValue SHA224Prototype__update(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(SHA224Prototype__updateCallback);

STATIC_ASSERT_ISO_SUBSPACE_SHARABLE(JSSHA224Prototype, JSSHA224Prototype::Base);

static const HashTableValue JSSHA224PrototypeTableValues[] = {
    { "byteLength"_s, static_cast<unsigned>(JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::GetterSetterType, SHA224Prototype__byteLengthGetterWrap, 0 } },
    { "digest"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, SHA224Prototype__digestCallback, 0 } },
    { "update"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, SHA224Prototype__updateCallback, 1 } }
};

const ClassInfo JSSHA224Prototype::s_info = { "SHA224"_s, &Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSSHA224Prototype) };

JSC_DEFINE_CUSTOM_GETTER(jsSHA224Constructor, (JSGlobalObject * lexicalGlobalObject, EncodedJSValue thisValue, PropertyName))
{
    VM& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    auto* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    auto* prototype = jsDynamicCast<JSSHA224Prototype*>(JSValue::decode(thisValue));

    if (UNLIKELY(!prototype))
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    return JSValue::encode(globalObject->JSSHA224Constructor());
}

JSC_DEFINE_CUSTOM_GETTER(SHA224Prototype__byteLengthGetterWrap, (JSGlobalObject * lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    auto& vm = lexicalGlobalObject->vm();
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    JSSHA224* thisObject = jsCast<JSSHA224*>(JSValue::decode(thisValue));
    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);
    JSC::EncodedJSValue result = SHA224Prototype__getByteLength(thisObject->wrapped(), globalObject);
    RETURN_IF_EXCEPTION(throwScope, {});
    RELEASE_AND_RETURN(throwScope, result);
}

JSC_DEFINE_HOST_FUNCTION(SHA224Prototype__digestCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSSHA224* thisObject = jsDynamicCast<JSSHA224*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return SHA224Prototype__digest(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_HOST_FUNCTION(SHA224Prototype__updateCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSSHA224* thisObject = jsDynamicCast<JSSHA224*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return SHA224Prototype__update(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

void JSSHA224Prototype::finishCreation(JSC::VM& vm, JSC::JSGlobalObject* globalObject)
{
    Base::finishCreation(vm);
    reifyStaticProperties(vm, JSSHA224::info(), JSSHA224PrototypeTableValues, *this);
    JSC_TO_STRING_TAG_WITHOUT_TRANSITION();
}

extern "C" JSC_DECLARE_CUSTOM_GETTER(SHA224Class__getByteLengthStatic);
extern "C" JSC_DECLARE_HOST_FUNCTION(SHA224Class__hash);

static const HashTableValue JSSHA224ConstructorTableValues[] = {
    { "byteLength"_s, static_cast<unsigned>(JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::GetterSetterType, SHA224Class__getByteLengthStatic, 0 } },
    { "hash"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, SHA224Class__hash, 2 } }
};

void JSSHA224Constructor::finishCreation(VM& vm, JSC::JSGlobalObject* globalObject, JSSHA224Prototype* prototype)
{
    Base::finishCreation(vm, 0, "SHA224"_s, PropertyAdditionMode::WithoutStructureTransition);
    reifyStaticProperties(vm, &JSSHA224Constructor::s_info, JSSHA224ConstructorTableValues, *this);
    putDirectWithoutTransition(vm, vm.propertyNames->prototype, prototype, PropertyAttribute::DontEnum | PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly);
    ASSERT(inherits(info()));
}

JSSHA224Constructor::JSSHA224Constructor(JSC::VM& vm, JSC::Structure* structure)
    : Base(vm, structure, construct, construct)
{
}

JSSHA224Constructor* JSSHA224Constructor::create(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure, JSSHA224Prototype* prototype)
{
    JSSHA224Constructor* ptr = new (NotNull, JSC::allocateCell<JSSHA224Constructor>(vm)) JSSHA224Constructor(vm, structure);
    ptr->finishCreation(vm, globalObject, prototype);
    return ptr;
}

JSC::EncodedJSValue JSC_HOST_CALL_ATTRIBUTES JSSHA224Constructor::construct(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame)
{
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    JSC::VM& vm = globalObject->vm();
    JSObject* newTarget = asObject(callFrame->newTarget());
    auto* constructor = globalObject->JSSHA224Constructor();
    Structure* structure = globalObject->JSSHA224Structure();
    if (constructor != newTarget) {
        auto scope = DECLARE_THROW_SCOPE(vm);

        auto* functionGlobalObject = reinterpret_cast<Zig::GlobalObject*>(
            // ShadowRealm functions belong to a different global object.
            getFunctionRealm(globalObject, newTarget));
        RETURN_IF_EXCEPTION(scope, {});
        structure = InternalFunction::createSubclassStructure(
            globalObject,
            newTarget,
            functionGlobalObject->JSSHA224Structure());
    }

    void* ptr = SHA224Class__construct(globalObject, callFrame);

    if (UNLIKELY(!ptr)) {
        return JSValue::encode(JSC::jsUndefined());
    }

    JSSHA224* instance = JSSHA224::create(vm, globalObject, structure, ptr);

    return JSValue::encode(instance);
}

void JSSHA224Constructor::initializeProperties(VM& vm, JSC::JSGlobalObject* globalObject, JSSHA224Prototype* prototype)
{
}

const ClassInfo JSSHA224Constructor::s_info = { "Function"_s, &Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSSHA224Constructor) };

extern "C" EncodedJSValue SHA224__getConstructor(Zig::GlobalObject* globalObject)
{
    return JSValue::encode(globalObject->JSSHA224Constructor());
}

JSSHA224::~JSSHA224()
{
    if (m_ctx) {
        SHA224Class__finalize(m_ctx);
    }
}
void JSSHA224::destroy(JSCell* cell)
{
    static_cast<JSSHA224*>(cell)->JSSHA224::~JSSHA224();
}

const ClassInfo JSSHA224::s_info = { "SHA224"_s, &Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSSHA224) };

void JSSHA224::finishCreation(VM& vm)
{
    Base::finishCreation(vm);
    ASSERT(inherits(info()));
}

JSSHA224* JSSHA224::create(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure, void* ctx)
{
    JSSHA224* ptr = new (NotNull, JSC::allocateCell<JSSHA224>(vm)) JSSHA224(vm, structure, ctx);
    ptr->finishCreation(vm);
    return ptr;
}

extern "C" void* SHA224__fromJS(JSC::EncodedJSValue value)
{
    JSC::JSValue decodedValue = JSC::JSValue::decode(value);
    if (decodedValue.isEmpty() || !decodedValue.isCell())
        return nullptr;

    JSC::JSCell* cell = decodedValue.asCell();
    JSSHA224* object = JSC::jsDynamicCast<JSSHA224*>(cell);

    if (!object)
        return nullptr;

    return object->wrapped();
}

extern "C" bool SHA224__dangerouslySetPtr(JSC::EncodedJSValue value, void* ptr)
{
    JSSHA224* object = JSC::jsDynamicCast<JSSHA224*>(JSValue::decode(value));
    if (!object)
        return false;

    object->m_ctx = ptr;
    return true;
}

extern "C" const size_t SHA224__ptrOffset = JSSHA224::offsetOfWrapped();

void JSSHA224::analyzeHeap(JSCell* cell, HeapAnalyzer& analyzer)
{
    auto* thisObject = jsCast<JSSHA224*>(cell);
    if (void* wrapped = thisObject->wrapped()) {
        // if (thisObject->scriptExecutionContext())
        //     analyzer.setLabelForCell(cell, "url " + thisObject->scriptExecutionContext()->url().string());
    }
    Base::analyzeHeap(cell, analyzer);
}

JSObject* JSSHA224::createConstructor(VM& vm, JSGlobalObject* globalObject, JSValue prototype)
{
    return WebCore::JSSHA224Constructor::create(vm, globalObject, WebCore::JSSHA224Constructor::createStructure(vm, globalObject, globalObject->functionPrototype()), jsCast<WebCore::JSSHA224Prototype*>(prototype));
}

JSObject* JSSHA224::createPrototype(VM& vm, JSDOMGlobalObject* globalObject)
{
    return JSSHA224Prototype::create(vm, globalObject, JSSHA224Prototype::createStructure(vm, globalObject, globalObject->objectPrototype()));
}

extern "C" EncodedJSValue SHA224__create(Zig::GlobalObject* globalObject, void* ptr)
{
    auto& vm = globalObject->vm();
    JSC::Structure* structure = globalObject->JSSHA224Structure();
    JSSHA224* instance = JSSHA224::create(vm, globalObject, structure, ptr);

    return JSValue::encode(instance);
}
class JSSHA256Prototype final : public JSC::JSNonFinalObject {
public:
    using Base = JSC::JSNonFinalObject;

    static JSSHA256Prototype* create(JSC::VM& vm, JSGlobalObject* globalObject, JSC::Structure* structure)
    {
        JSSHA256Prototype* ptr = new (NotNull, JSC::allocateCell<JSSHA256Prototype>(vm)) JSSHA256Prototype(vm, globalObject, structure);
        ptr->finishCreation(vm, globalObject);
        return ptr;
    }

    DECLARE_INFO;
    template<typename CellType, JSC::SubspaceAccess>
    static JSC::GCClient::IsoSubspace* subspaceFor(JSC::VM& vm)
    {
        return &vm.plainObjectSpace();
    }
    static JSC::Structure* createStructure(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::JSValue prototype)
    {
        return JSC::Structure::create(vm, globalObject, prototype, JSC::TypeInfo(JSC::ObjectType, StructureFlags), info());
    }

private:
    JSSHA256Prototype(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure)
        : Base(vm, structure)
    {
    }

    void finishCreation(JSC::VM&, JSC::JSGlobalObject*);
};

class JSSHA256Constructor final : public JSC::InternalFunction {
public:
    using Base = JSC::InternalFunction;
    static JSSHA256Constructor* create(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure, JSSHA256Prototype* prototype);

    static constexpr unsigned StructureFlags = Base::StructureFlags;
    static constexpr bool needsDestruction = false;

    static JSC::Structure* createStructure(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::JSValue prototype)
    {
        return JSC::Structure::create(vm, globalObject, prototype, JSC::TypeInfo(JSC::InternalFunctionType, StructureFlags), info());
    }

    template<typename, JSC::SubspaceAccess mode> static JSC::GCClient::IsoSubspace* subspaceFor(JSC::VM& vm)
    {
        if constexpr (mode == JSC::SubspaceAccess::Concurrently)
            return nullptr;
        return WebCore::subspaceForImpl<JSSHA256Constructor, WebCore::UseCustomHeapCellType::No>(
            vm,
            [](auto& spaces) { return spaces.m_clientSubspaceForSHA256Constructor.get(); },
            [](auto& spaces, auto&& space) { spaces.m_clientSubspaceForSHA256Constructor = std::forward<decltype(space)>(space); },
            [](auto& spaces) { return spaces.m_subspaceForSHA256Constructor.get(); },
            [](auto& spaces, auto&& space) { spaces.m_subspaceForSHA256Constructor = std::forward<decltype(space)>(space); });
    }

    void initializeProperties(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSSHA256Prototype* prototype);

    // Must be defined for each specialization class.
    static JSC::EncodedJSValue JSC_HOST_CALL_ATTRIBUTES construct(JSC::JSGlobalObject*, JSC::CallFrame*);

    DECLARE_EXPORT_INFO;

private:
    JSSHA256Constructor(JSC::VM& vm, JSC::Structure* structure);
    void finishCreation(JSC::VM&, JSC::JSGlobalObject* globalObject, JSSHA256Prototype* prototype);
};

extern "C" void* SHA256Class__construct(JSC::JSGlobalObject*, JSC::CallFrame*);
JSC_DECLARE_CUSTOM_GETTER(jsSHA256Constructor);
extern "C" void SHA256Class__finalize(void*);

extern "C" JSC::EncodedJSValue SHA256Prototype__getByteLength(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject);
JSC_DECLARE_CUSTOM_GETTER(SHA256Prototype__byteLengthGetterWrap);

extern "C" EncodedJSValue SHA256Prototype__digest(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(SHA256Prototype__digestCallback);

extern "C" EncodedJSValue SHA256Prototype__update(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(SHA256Prototype__updateCallback);

STATIC_ASSERT_ISO_SUBSPACE_SHARABLE(JSSHA256Prototype, JSSHA256Prototype::Base);

static const HashTableValue JSSHA256PrototypeTableValues[] = {
    { "byteLength"_s, static_cast<unsigned>(JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::GetterSetterType, SHA256Prototype__byteLengthGetterWrap, 0 } },
    { "digest"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, SHA256Prototype__digestCallback, 0 } },
    { "update"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, SHA256Prototype__updateCallback, 1 } }
};

const ClassInfo JSSHA256Prototype::s_info = { "SHA256"_s, &Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSSHA256Prototype) };

JSC_DEFINE_CUSTOM_GETTER(jsSHA256Constructor, (JSGlobalObject * lexicalGlobalObject, EncodedJSValue thisValue, PropertyName))
{
    VM& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    auto* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    auto* prototype = jsDynamicCast<JSSHA256Prototype*>(JSValue::decode(thisValue));

    if (UNLIKELY(!prototype))
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    return JSValue::encode(globalObject->JSSHA256Constructor());
}

JSC_DEFINE_CUSTOM_GETTER(SHA256Prototype__byteLengthGetterWrap, (JSGlobalObject * lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    auto& vm = lexicalGlobalObject->vm();
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    JSSHA256* thisObject = jsCast<JSSHA256*>(JSValue::decode(thisValue));
    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);
    JSC::EncodedJSValue result = SHA256Prototype__getByteLength(thisObject->wrapped(), globalObject);
    RETURN_IF_EXCEPTION(throwScope, {});
    RELEASE_AND_RETURN(throwScope, result);
}

JSC_DEFINE_HOST_FUNCTION(SHA256Prototype__digestCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSSHA256* thisObject = jsDynamicCast<JSSHA256*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return SHA256Prototype__digest(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_HOST_FUNCTION(SHA256Prototype__updateCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSSHA256* thisObject = jsDynamicCast<JSSHA256*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return SHA256Prototype__update(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

void JSSHA256Prototype::finishCreation(JSC::VM& vm, JSC::JSGlobalObject* globalObject)
{
    Base::finishCreation(vm);
    reifyStaticProperties(vm, JSSHA256::info(), JSSHA256PrototypeTableValues, *this);
    JSC_TO_STRING_TAG_WITHOUT_TRANSITION();
}

extern "C" JSC_DECLARE_CUSTOM_GETTER(SHA256Class__getByteLengthStatic);
extern "C" JSC_DECLARE_HOST_FUNCTION(SHA256Class__hash);

static const HashTableValue JSSHA256ConstructorTableValues[] = {
    { "byteLength"_s, static_cast<unsigned>(JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::GetterSetterType, SHA256Class__getByteLengthStatic, 0 } },
    { "hash"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, SHA256Class__hash, 2 } }
};

void JSSHA256Constructor::finishCreation(VM& vm, JSC::JSGlobalObject* globalObject, JSSHA256Prototype* prototype)
{
    Base::finishCreation(vm, 0, "SHA256"_s, PropertyAdditionMode::WithoutStructureTransition);
    reifyStaticProperties(vm, &JSSHA256Constructor::s_info, JSSHA256ConstructorTableValues, *this);
    putDirectWithoutTransition(vm, vm.propertyNames->prototype, prototype, PropertyAttribute::DontEnum | PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly);
    ASSERT(inherits(info()));
}

JSSHA256Constructor::JSSHA256Constructor(JSC::VM& vm, JSC::Structure* structure)
    : Base(vm, structure, construct, construct)
{
}

JSSHA256Constructor* JSSHA256Constructor::create(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure, JSSHA256Prototype* prototype)
{
    JSSHA256Constructor* ptr = new (NotNull, JSC::allocateCell<JSSHA256Constructor>(vm)) JSSHA256Constructor(vm, structure);
    ptr->finishCreation(vm, globalObject, prototype);
    return ptr;
}

JSC::EncodedJSValue JSC_HOST_CALL_ATTRIBUTES JSSHA256Constructor::construct(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame)
{
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    JSC::VM& vm = globalObject->vm();
    JSObject* newTarget = asObject(callFrame->newTarget());
    auto* constructor = globalObject->JSSHA256Constructor();
    Structure* structure = globalObject->JSSHA256Structure();
    if (constructor != newTarget) {
        auto scope = DECLARE_THROW_SCOPE(vm);

        auto* functionGlobalObject = reinterpret_cast<Zig::GlobalObject*>(
            // ShadowRealm functions belong to a different global object.
            getFunctionRealm(globalObject, newTarget));
        RETURN_IF_EXCEPTION(scope, {});
        structure = InternalFunction::createSubclassStructure(
            globalObject,
            newTarget,
            functionGlobalObject->JSSHA256Structure());
    }

    void* ptr = SHA256Class__construct(globalObject, callFrame);

    if (UNLIKELY(!ptr)) {
        return JSValue::encode(JSC::jsUndefined());
    }

    JSSHA256* instance = JSSHA256::create(vm, globalObject, structure, ptr);

    return JSValue::encode(instance);
}

void JSSHA256Constructor::initializeProperties(VM& vm, JSC::JSGlobalObject* globalObject, JSSHA256Prototype* prototype)
{
}

const ClassInfo JSSHA256Constructor::s_info = { "Function"_s, &Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSSHA256Constructor) };

extern "C" EncodedJSValue SHA256__getConstructor(Zig::GlobalObject* globalObject)
{
    return JSValue::encode(globalObject->JSSHA256Constructor());
}

JSSHA256::~JSSHA256()
{
    if (m_ctx) {
        SHA256Class__finalize(m_ctx);
    }
}
void JSSHA256::destroy(JSCell* cell)
{
    static_cast<JSSHA256*>(cell)->JSSHA256::~JSSHA256();
}

const ClassInfo JSSHA256::s_info = { "SHA256"_s, &Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSSHA256) };

void JSSHA256::finishCreation(VM& vm)
{
    Base::finishCreation(vm);
    ASSERT(inherits(info()));
}

JSSHA256* JSSHA256::create(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure, void* ctx)
{
    JSSHA256* ptr = new (NotNull, JSC::allocateCell<JSSHA256>(vm)) JSSHA256(vm, structure, ctx);
    ptr->finishCreation(vm);
    return ptr;
}

extern "C" void* SHA256__fromJS(JSC::EncodedJSValue value)
{
    JSC::JSValue decodedValue = JSC::JSValue::decode(value);
    if (decodedValue.isEmpty() || !decodedValue.isCell())
        return nullptr;

    JSC::JSCell* cell = decodedValue.asCell();
    JSSHA256* object = JSC::jsDynamicCast<JSSHA256*>(cell);

    if (!object)
        return nullptr;

    return object->wrapped();
}

extern "C" bool SHA256__dangerouslySetPtr(JSC::EncodedJSValue value, void* ptr)
{
    JSSHA256* object = JSC::jsDynamicCast<JSSHA256*>(JSValue::decode(value));
    if (!object)
        return false;

    object->m_ctx = ptr;
    return true;
}

extern "C" const size_t SHA256__ptrOffset = JSSHA256::offsetOfWrapped();

void JSSHA256::analyzeHeap(JSCell* cell, HeapAnalyzer& analyzer)
{
    auto* thisObject = jsCast<JSSHA256*>(cell);
    if (void* wrapped = thisObject->wrapped()) {
        // if (thisObject->scriptExecutionContext())
        //     analyzer.setLabelForCell(cell, "url " + thisObject->scriptExecutionContext()->url().string());
    }
    Base::analyzeHeap(cell, analyzer);
}

JSObject* JSSHA256::createConstructor(VM& vm, JSGlobalObject* globalObject, JSValue prototype)
{
    return WebCore::JSSHA256Constructor::create(vm, globalObject, WebCore::JSSHA256Constructor::createStructure(vm, globalObject, globalObject->functionPrototype()), jsCast<WebCore::JSSHA256Prototype*>(prototype));
}

JSObject* JSSHA256::createPrototype(VM& vm, JSDOMGlobalObject* globalObject)
{
    return JSSHA256Prototype::create(vm, globalObject, JSSHA256Prototype::createStructure(vm, globalObject, globalObject->objectPrototype()));
}

extern "C" EncodedJSValue SHA256__create(Zig::GlobalObject* globalObject, void* ptr)
{
    auto& vm = globalObject->vm();
    JSC::Structure* structure = globalObject->JSSHA256Structure();
    JSSHA256* instance = JSSHA256::create(vm, globalObject, structure, ptr);

    return JSValue::encode(instance);
}
class JSSHA384Prototype final : public JSC::JSNonFinalObject {
public:
    using Base = JSC::JSNonFinalObject;

    static JSSHA384Prototype* create(JSC::VM& vm, JSGlobalObject* globalObject, JSC::Structure* structure)
    {
        JSSHA384Prototype* ptr = new (NotNull, JSC::allocateCell<JSSHA384Prototype>(vm)) JSSHA384Prototype(vm, globalObject, structure);
        ptr->finishCreation(vm, globalObject);
        return ptr;
    }

    DECLARE_INFO;
    template<typename CellType, JSC::SubspaceAccess>
    static JSC::GCClient::IsoSubspace* subspaceFor(JSC::VM& vm)
    {
        return &vm.plainObjectSpace();
    }
    static JSC::Structure* createStructure(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::JSValue prototype)
    {
        return JSC::Structure::create(vm, globalObject, prototype, JSC::TypeInfo(JSC::ObjectType, StructureFlags), info());
    }

private:
    JSSHA384Prototype(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure)
        : Base(vm, structure)
    {
    }

    void finishCreation(JSC::VM&, JSC::JSGlobalObject*);
};

class JSSHA384Constructor final : public JSC::InternalFunction {
public:
    using Base = JSC::InternalFunction;
    static JSSHA384Constructor* create(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure, JSSHA384Prototype* prototype);

    static constexpr unsigned StructureFlags = Base::StructureFlags;
    static constexpr bool needsDestruction = false;

    static JSC::Structure* createStructure(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::JSValue prototype)
    {
        return JSC::Structure::create(vm, globalObject, prototype, JSC::TypeInfo(JSC::InternalFunctionType, StructureFlags), info());
    }

    template<typename, JSC::SubspaceAccess mode> static JSC::GCClient::IsoSubspace* subspaceFor(JSC::VM& vm)
    {
        if constexpr (mode == JSC::SubspaceAccess::Concurrently)
            return nullptr;
        return WebCore::subspaceForImpl<JSSHA384Constructor, WebCore::UseCustomHeapCellType::No>(
            vm,
            [](auto& spaces) { return spaces.m_clientSubspaceForSHA384Constructor.get(); },
            [](auto& spaces, auto&& space) { spaces.m_clientSubspaceForSHA384Constructor = std::forward<decltype(space)>(space); },
            [](auto& spaces) { return spaces.m_subspaceForSHA384Constructor.get(); },
            [](auto& spaces, auto&& space) { spaces.m_subspaceForSHA384Constructor = std::forward<decltype(space)>(space); });
    }

    void initializeProperties(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSSHA384Prototype* prototype);

    // Must be defined for each specialization class.
    static JSC::EncodedJSValue JSC_HOST_CALL_ATTRIBUTES construct(JSC::JSGlobalObject*, JSC::CallFrame*);

    DECLARE_EXPORT_INFO;

private:
    JSSHA384Constructor(JSC::VM& vm, JSC::Structure* structure);
    void finishCreation(JSC::VM&, JSC::JSGlobalObject* globalObject, JSSHA384Prototype* prototype);
};

extern "C" void* SHA384Class__construct(JSC::JSGlobalObject*, JSC::CallFrame*);
JSC_DECLARE_CUSTOM_GETTER(jsSHA384Constructor);
extern "C" void SHA384Class__finalize(void*);

extern "C" JSC::EncodedJSValue SHA384Prototype__getByteLength(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject);
JSC_DECLARE_CUSTOM_GETTER(SHA384Prototype__byteLengthGetterWrap);

extern "C" EncodedJSValue SHA384Prototype__digest(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(SHA384Prototype__digestCallback);

extern "C" EncodedJSValue SHA384Prototype__update(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(SHA384Prototype__updateCallback);

STATIC_ASSERT_ISO_SUBSPACE_SHARABLE(JSSHA384Prototype, JSSHA384Prototype::Base);

static const HashTableValue JSSHA384PrototypeTableValues[] = {
    { "byteLength"_s, static_cast<unsigned>(JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::GetterSetterType, SHA384Prototype__byteLengthGetterWrap, 0 } },
    { "digest"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, SHA384Prototype__digestCallback, 0 } },
    { "update"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, SHA384Prototype__updateCallback, 1 } }
};

const ClassInfo JSSHA384Prototype::s_info = { "SHA384"_s, &Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSSHA384Prototype) };

JSC_DEFINE_CUSTOM_GETTER(jsSHA384Constructor, (JSGlobalObject * lexicalGlobalObject, EncodedJSValue thisValue, PropertyName))
{
    VM& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    auto* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    auto* prototype = jsDynamicCast<JSSHA384Prototype*>(JSValue::decode(thisValue));

    if (UNLIKELY(!prototype))
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    return JSValue::encode(globalObject->JSSHA384Constructor());
}

JSC_DEFINE_CUSTOM_GETTER(SHA384Prototype__byteLengthGetterWrap, (JSGlobalObject * lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    auto& vm = lexicalGlobalObject->vm();
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    JSSHA384* thisObject = jsCast<JSSHA384*>(JSValue::decode(thisValue));
    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);
    JSC::EncodedJSValue result = SHA384Prototype__getByteLength(thisObject->wrapped(), globalObject);
    RETURN_IF_EXCEPTION(throwScope, {});
    RELEASE_AND_RETURN(throwScope, result);
}

JSC_DEFINE_HOST_FUNCTION(SHA384Prototype__digestCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSSHA384* thisObject = jsDynamicCast<JSSHA384*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return SHA384Prototype__digest(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_HOST_FUNCTION(SHA384Prototype__updateCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSSHA384* thisObject = jsDynamicCast<JSSHA384*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return SHA384Prototype__update(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

void JSSHA384Prototype::finishCreation(JSC::VM& vm, JSC::JSGlobalObject* globalObject)
{
    Base::finishCreation(vm);
    reifyStaticProperties(vm, JSSHA384::info(), JSSHA384PrototypeTableValues, *this);
    JSC_TO_STRING_TAG_WITHOUT_TRANSITION();
}

extern "C" JSC_DECLARE_CUSTOM_GETTER(SHA384Class__getByteLengthStatic);
extern "C" JSC_DECLARE_HOST_FUNCTION(SHA384Class__hash);

static const HashTableValue JSSHA384ConstructorTableValues[] = {
    { "byteLength"_s, static_cast<unsigned>(JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::GetterSetterType, SHA384Class__getByteLengthStatic, 0 } },
    { "hash"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, SHA384Class__hash, 2 } }
};

void JSSHA384Constructor::finishCreation(VM& vm, JSC::JSGlobalObject* globalObject, JSSHA384Prototype* prototype)
{
    Base::finishCreation(vm, 0, "SHA384"_s, PropertyAdditionMode::WithoutStructureTransition);
    reifyStaticProperties(vm, &JSSHA384Constructor::s_info, JSSHA384ConstructorTableValues, *this);
    putDirectWithoutTransition(vm, vm.propertyNames->prototype, prototype, PropertyAttribute::DontEnum | PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly);
    ASSERT(inherits(info()));
}

JSSHA384Constructor::JSSHA384Constructor(JSC::VM& vm, JSC::Structure* structure)
    : Base(vm, structure, construct, construct)
{
}

JSSHA384Constructor* JSSHA384Constructor::create(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure, JSSHA384Prototype* prototype)
{
    JSSHA384Constructor* ptr = new (NotNull, JSC::allocateCell<JSSHA384Constructor>(vm)) JSSHA384Constructor(vm, structure);
    ptr->finishCreation(vm, globalObject, prototype);
    return ptr;
}

JSC::EncodedJSValue JSC_HOST_CALL_ATTRIBUTES JSSHA384Constructor::construct(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame)
{
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    JSC::VM& vm = globalObject->vm();
    JSObject* newTarget = asObject(callFrame->newTarget());
    auto* constructor = globalObject->JSSHA384Constructor();
    Structure* structure = globalObject->JSSHA384Structure();
    if (constructor != newTarget) {
        auto scope = DECLARE_THROW_SCOPE(vm);

        auto* functionGlobalObject = reinterpret_cast<Zig::GlobalObject*>(
            // ShadowRealm functions belong to a different global object.
            getFunctionRealm(globalObject, newTarget));
        RETURN_IF_EXCEPTION(scope, {});
        structure = InternalFunction::createSubclassStructure(
            globalObject,
            newTarget,
            functionGlobalObject->JSSHA384Structure());
    }

    void* ptr = SHA384Class__construct(globalObject, callFrame);

    if (UNLIKELY(!ptr)) {
        return JSValue::encode(JSC::jsUndefined());
    }

    JSSHA384* instance = JSSHA384::create(vm, globalObject, structure, ptr);

    return JSValue::encode(instance);
}

void JSSHA384Constructor::initializeProperties(VM& vm, JSC::JSGlobalObject* globalObject, JSSHA384Prototype* prototype)
{
}

const ClassInfo JSSHA384Constructor::s_info = { "Function"_s, &Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSSHA384Constructor) };

extern "C" EncodedJSValue SHA384__getConstructor(Zig::GlobalObject* globalObject)
{
    return JSValue::encode(globalObject->JSSHA384Constructor());
}

JSSHA384::~JSSHA384()
{
    if (m_ctx) {
        SHA384Class__finalize(m_ctx);
    }
}
void JSSHA384::destroy(JSCell* cell)
{
    static_cast<JSSHA384*>(cell)->JSSHA384::~JSSHA384();
}

const ClassInfo JSSHA384::s_info = { "SHA384"_s, &Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSSHA384) };

void JSSHA384::finishCreation(VM& vm)
{
    Base::finishCreation(vm);
    ASSERT(inherits(info()));
}

JSSHA384* JSSHA384::create(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure, void* ctx)
{
    JSSHA384* ptr = new (NotNull, JSC::allocateCell<JSSHA384>(vm)) JSSHA384(vm, structure, ctx);
    ptr->finishCreation(vm);
    return ptr;
}

extern "C" void* SHA384__fromJS(JSC::EncodedJSValue value)
{
    JSC::JSValue decodedValue = JSC::JSValue::decode(value);
    if (decodedValue.isEmpty() || !decodedValue.isCell())
        return nullptr;

    JSC::JSCell* cell = decodedValue.asCell();
    JSSHA384* object = JSC::jsDynamicCast<JSSHA384*>(cell);

    if (!object)
        return nullptr;

    return object->wrapped();
}

extern "C" bool SHA384__dangerouslySetPtr(JSC::EncodedJSValue value, void* ptr)
{
    JSSHA384* object = JSC::jsDynamicCast<JSSHA384*>(JSValue::decode(value));
    if (!object)
        return false;

    object->m_ctx = ptr;
    return true;
}

extern "C" const size_t SHA384__ptrOffset = JSSHA384::offsetOfWrapped();

void JSSHA384::analyzeHeap(JSCell* cell, HeapAnalyzer& analyzer)
{
    auto* thisObject = jsCast<JSSHA384*>(cell);
    if (void* wrapped = thisObject->wrapped()) {
        // if (thisObject->scriptExecutionContext())
        //     analyzer.setLabelForCell(cell, "url " + thisObject->scriptExecutionContext()->url().string());
    }
    Base::analyzeHeap(cell, analyzer);
}

JSObject* JSSHA384::createConstructor(VM& vm, JSGlobalObject* globalObject, JSValue prototype)
{
    return WebCore::JSSHA384Constructor::create(vm, globalObject, WebCore::JSSHA384Constructor::createStructure(vm, globalObject, globalObject->functionPrototype()), jsCast<WebCore::JSSHA384Prototype*>(prototype));
}

JSObject* JSSHA384::createPrototype(VM& vm, JSDOMGlobalObject* globalObject)
{
    return JSSHA384Prototype::create(vm, globalObject, JSSHA384Prototype::createStructure(vm, globalObject, globalObject->objectPrototype()));
}

extern "C" EncodedJSValue SHA384__create(Zig::GlobalObject* globalObject, void* ptr)
{
    auto& vm = globalObject->vm();
    JSC::Structure* structure = globalObject->JSSHA384Structure();
    JSSHA384* instance = JSSHA384::create(vm, globalObject, structure, ptr);

    return JSValue::encode(instance);
}
class JSSHA512Prototype final : public JSC::JSNonFinalObject {
public:
    using Base = JSC::JSNonFinalObject;

    static JSSHA512Prototype* create(JSC::VM& vm, JSGlobalObject* globalObject, JSC::Structure* structure)
    {
        JSSHA512Prototype* ptr = new (NotNull, JSC::allocateCell<JSSHA512Prototype>(vm)) JSSHA512Prototype(vm, globalObject, structure);
        ptr->finishCreation(vm, globalObject);
        return ptr;
    }

    DECLARE_INFO;
    template<typename CellType, JSC::SubspaceAccess>
    static JSC::GCClient::IsoSubspace* subspaceFor(JSC::VM& vm)
    {
        return &vm.plainObjectSpace();
    }
    static JSC::Structure* createStructure(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::JSValue prototype)
    {
        return JSC::Structure::create(vm, globalObject, prototype, JSC::TypeInfo(JSC::ObjectType, StructureFlags), info());
    }

private:
    JSSHA512Prototype(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure)
        : Base(vm, structure)
    {
    }

    void finishCreation(JSC::VM&, JSC::JSGlobalObject*);
};

class JSSHA512Constructor final : public JSC::InternalFunction {
public:
    using Base = JSC::InternalFunction;
    static JSSHA512Constructor* create(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure, JSSHA512Prototype* prototype);

    static constexpr unsigned StructureFlags = Base::StructureFlags;
    static constexpr bool needsDestruction = false;

    static JSC::Structure* createStructure(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::JSValue prototype)
    {
        return JSC::Structure::create(vm, globalObject, prototype, JSC::TypeInfo(JSC::InternalFunctionType, StructureFlags), info());
    }

    template<typename, JSC::SubspaceAccess mode> static JSC::GCClient::IsoSubspace* subspaceFor(JSC::VM& vm)
    {
        if constexpr (mode == JSC::SubspaceAccess::Concurrently)
            return nullptr;
        return WebCore::subspaceForImpl<JSSHA512Constructor, WebCore::UseCustomHeapCellType::No>(
            vm,
            [](auto& spaces) { return spaces.m_clientSubspaceForSHA512Constructor.get(); },
            [](auto& spaces, auto&& space) { spaces.m_clientSubspaceForSHA512Constructor = std::forward<decltype(space)>(space); },
            [](auto& spaces) { return spaces.m_subspaceForSHA512Constructor.get(); },
            [](auto& spaces, auto&& space) { spaces.m_subspaceForSHA512Constructor = std::forward<decltype(space)>(space); });
    }

    void initializeProperties(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSSHA512Prototype* prototype);

    // Must be defined for each specialization class.
    static JSC::EncodedJSValue JSC_HOST_CALL_ATTRIBUTES construct(JSC::JSGlobalObject*, JSC::CallFrame*);

    DECLARE_EXPORT_INFO;

private:
    JSSHA512Constructor(JSC::VM& vm, JSC::Structure* structure);
    void finishCreation(JSC::VM&, JSC::JSGlobalObject* globalObject, JSSHA512Prototype* prototype);
};

extern "C" void* SHA512Class__construct(JSC::JSGlobalObject*, JSC::CallFrame*);
JSC_DECLARE_CUSTOM_GETTER(jsSHA512Constructor);
extern "C" void SHA512Class__finalize(void*);

extern "C" JSC::EncodedJSValue SHA512Prototype__getByteLength(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject);
JSC_DECLARE_CUSTOM_GETTER(SHA512Prototype__byteLengthGetterWrap);

extern "C" EncodedJSValue SHA512Prototype__digest(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(SHA512Prototype__digestCallback);

extern "C" EncodedJSValue SHA512Prototype__update(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(SHA512Prototype__updateCallback);

STATIC_ASSERT_ISO_SUBSPACE_SHARABLE(JSSHA512Prototype, JSSHA512Prototype::Base);

static const HashTableValue JSSHA512PrototypeTableValues[] = {
    { "byteLength"_s, static_cast<unsigned>(JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::GetterSetterType, SHA512Prototype__byteLengthGetterWrap, 0 } },
    { "digest"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, SHA512Prototype__digestCallback, 0 } },
    { "update"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, SHA512Prototype__updateCallback, 1 } }
};

const ClassInfo JSSHA512Prototype::s_info = { "SHA512"_s, &Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSSHA512Prototype) };

JSC_DEFINE_CUSTOM_GETTER(jsSHA512Constructor, (JSGlobalObject * lexicalGlobalObject, EncodedJSValue thisValue, PropertyName))
{
    VM& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    auto* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    auto* prototype = jsDynamicCast<JSSHA512Prototype*>(JSValue::decode(thisValue));

    if (UNLIKELY(!prototype))
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    return JSValue::encode(globalObject->JSSHA512Constructor());
}

JSC_DEFINE_CUSTOM_GETTER(SHA512Prototype__byteLengthGetterWrap, (JSGlobalObject * lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    auto& vm = lexicalGlobalObject->vm();
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    JSSHA512* thisObject = jsCast<JSSHA512*>(JSValue::decode(thisValue));
    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);
    JSC::EncodedJSValue result = SHA512Prototype__getByteLength(thisObject->wrapped(), globalObject);
    RETURN_IF_EXCEPTION(throwScope, {});
    RELEASE_AND_RETURN(throwScope, result);
}

JSC_DEFINE_HOST_FUNCTION(SHA512Prototype__digestCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSSHA512* thisObject = jsDynamicCast<JSSHA512*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return SHA512Prototype__digest(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_HOST_FUNCTION(SHA512Prototype__updateCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSSHA512* thisObject = jsDynamicCast<JSSHA512*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return SHA512Prototype__update(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

void JSSHA512Prototype::finishCreation(JSC::VM& vm, JSC::JSGlobalObject* globalObject)
{
    Base::finishCreation(vm);
    reifyStaticProperties(vm, JSSHA512::info(), JSSHA512PrototypeTableValues, *this);
    JSC_TO_STRING_TAG_WITHOUT_TRANSITION();
}

extern "C" JSC_DECLARE_CUSTOM_GETTER(SHA512Class__getByteLengthStatic);
extern "C" JSC_DECLARE_HOST_FUNCTION(SHA512Class__hash);

static const HashTableValue JSSHA512ConstructorTableValues[] = {
    { "byteLength"_s, static_cast<unsigned>(JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::GetterSetterType, SHA512Class__getByteLengthStatic, 0 } },
    { "hash"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, SHA512Class__hash, 2 } }
};

void JSSHA512Constructor::finishCreation(VM& vm, JSC::JSGlobalObject* globalObject, JSSHA512Prototype* prototype)
{
    Base::finishCreation(vm, 0, "SHA512"_s, PropertyAdditionMode::WithoutStructureTransition);
    reifyStaticProperties(vm, &JSSHA512Constructor::s_info, JSSHA512ConstructorTableValues, *this);
    putDirectWithoutTransition(vm, vm.propertyNames->prototype, prototype, PropertyAttribute::DontEnum | PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly);
    ASSERT(inherits(info()));
}

JSSHA512Constructor::JSSHA512Constructor(JSC::VM& vm, JSC::Structure* structure)
    : Base(vm, structure, construct, construct)
{
}

JSSHA512Constructor* JSSHA512Constructor::create(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure, JSSHA512Prototype* prototype)
{
    JSSHA512Constructor* ptr = new (NotNull, JSC::allocateCell<JSSHA512Constructor>(vm)) JSSHA512Constructor(vm, structure);
    ptr->finishCreation(vm, globalObject, prototype);
    return ptr;
}

JSC::EncodedJSValue JSC_HOST_CALL_ATTRIBUTES JSSHA512Constructor::construct(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame)
{
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    JSC::VM& vm = globalObject->vm();
    JSObject* newTarget = asObject(callFrame->newTarget());
    auto* constructor = globalObject->JSSHA512Constructor();
    Structure* structure = globalObject->JSSHA512Structure();
    if (constructor != newTarget) {
        auto scope = DECLARE_THROW_SCOPE(vm);

        auto* functionGlobalObject = reinterpret_cast<Zig::GlobalObject*>(
            // ShadowRealm functions belong to a different global object.
            getFunctionRealm(globalObject, newTarget));
        RETURN_IF_EXCEPTION(scope, {});
        structure = InternalFunction::createSubclassStructure(
            globalObject,
            newTarget,
            functionGlobalObject->JSSHA512Structure());
    }

    void* ptr = SHA512Class__construct(globalObject, callFrame);

    if (UNLIKELY(!ptr)) {
        return JSValue::encode(JSC::jsUndefined());
    }

    JSSHA512* instance = JSSHA512::create(vm, globalObject, structure, ptr);

    return JSValue::encode(instance);
}

void JSSHA512Constructor::initializeProperties(VM& vm, JSC::JSGlobalObject* globalObject, JSSHA512Prototype* prototype)
{
}

const ClassInfo JSSHA512Constructor::s_info = { "Function"_s, &Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSSHA512Constructor) };

extern "C" EncodedJSValue SHA512__getConstructor(Zig::GlobalObject* globalObject)
{
    return JSValue::encode(globalObject->JSSHA512Constructor());
}

JSSHA512::~JSSHA512()
{
    if (m_ctx) {
        SHA512Class__finalize(m_ctx);
    }
}
void JSSHA512::destroy(JSCell* cell)
{
    static_cast<JSSHA512*>(cell)->JSSHA512::~JSSHA512();
}

const ClassInfo JSSHA512::s_info = { "SHA512"_s, &Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSSHA512) };

void JSSHA512::finishCreation(VM& vm)
{
    Base::finishCreation(vm);
    ASSERT(inherits(info()));
}

JSSHA512* JSSHA512::create(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure, void* ctx)
{
    JSSHA512* ptr = new (NotNull, JSC::allocateCell<JSSHA512>(vm)) JSSHA512(vm, structure, ctx);
    ptr->finishCreation(vm);
    return ptr;
}

extern "C" void* SHA512__fromJS(JSC::EncodedJSValue value)
{
    JSC::JSValue decodedValue = JSC::JSValue::decode(value);
    if (decodedValue.isEmpty() || !decodedValue.isCell())
        return nullptr;

    JSC::JSCell* cell = decodedValue.asCell();
    JSSHA512* object = JSC::jsDynamicCast<JSSHA512*>(cell);

    if (!object)
        return nullptr;

    return object->wrapped();
}

extern "C" bool SHA512__dangerouslySetPtr(JSC::EncodedJSValue value, void* ptr)
{
    JSSHA512* object = JSC::jsDynamicCast<JSSHA512*>(JSValue::decode(value));
    if (!object)
        return false;

    object->m_ctx = ptr;
    return true;
}

extern "C" const size_t SHA512__ptrOffset = JSSHA512::offsetOfWrapped();

void JSSHA512::analyzeHeap(JSCell* cell, HeapAnalyzer& analyzer)
{
    auto* thisObject = jsCast<JSSHA512*>(cell);
    if (void* wrapped = thisObject->wrapped()) {
        // if (thisObject->scriptExecutionContext())
        //     analyzer.setLabelForCell(cell, "url " + thisObject->scriptExecutionContext()->url().string());
    }
    Base::analyzeHeap(cell, analyzer);
}

JSObject* JSSHA512::createConstructor(VM& vm, JSGlobalObject* globalObject, JSValue prototype)
{
    return WebCore::JSSHA512Constructor::create(vm, globalObject, WebCore::JSSHA512Constructor::createStructure(vm, globalObject, globalObject->functionPrototype()), jsCast<WebCore::JSSHA512Prototype*>(prototype));
}

JSObject* JSSHA512::createPrototype(VM& vm, JSDOMGlobalObject* globalObject)
{
    return JSSHA512Prototype::create(vm, globalObject, JSSHA512Prototype::createStructure(vm, globalObject, globalObject->objectPrototype()));
}

extern "C" EncodedJSValue SHA512__create(Zig::GlobalObject* globalObject, void* ptr)
{
    auto& vm = globalObject->vm();
    JSC::Structure* structure = globalObject->JSSHA512Structure();
    JSSHA512* instance = JSSHA512::create(vm, globalObject, structure, ptr);

    return JSValue::encode(instance);
}
class JSSHA512_256Prototype final : public JSC::JSNonFinalObject {
public:
    using Base = JSC::JSNonFinalObject;

    static JSSHA512_256Prototype* create(JSC::VM& vm, JSGlobalObject* globalObject, JSC::Structure* structure)
    {
        JSSHA512_256Prototype* ptr = new (NotNull, JSC::allocateCell<JSSHA512_256Prototype>(vm)) JSSHA512_256Prototype(vm, globalObject, structure);
        ptr->finishCreation(vm, globalObject);
        return ptr;
    }

    DECLARE_INFO;
    template<typename CellType, JSC::SubspaceAccess>
    static JSC::GCClient::IsoSubspace* subspaceFor(JSC::VM& vm)
    {
        return &vm.plainObjectSpace();
    }
    static JSC::Structure* createStructure(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::JSValue prototype)
    {
        return JSC::Structure::create(vm, globalObject, prototype, JSC::TypeInfo(JSC::ObjectType, StructureFlags), info());
    }

private:
    JSSHA512_256Prototype(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure)
        : Base(vm, structure)
    {
    }

    void finishCreation(JSC::VM&, JSC::JSGlobalObject*);
};

class JSSHA512_256Constructor final : public JSC::InternalFunction {
public:
    using Base = JSC::InternalFunction;
    static JSSHA512_256Constructor* create(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure, JSSHA512_256Prototype* prototype);

    static constexpr unsigned StructureFlags = Base::StructureFlags;
    static constexpr bool needsDestruction = false;

    static JSC::Structure* createStructure(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::JSValue prototype)
    {
        return JSC::Structure::create(vm, globalObject, prototype, JSC::TypeInfo(JSC::InternalFunctionType, StructureFlags), info());
    }

    template<typename, JSC::SubspaceAccess mode> static JSC::GCClient::IsoSubspace* subspaceFor(JSC::VM& vm)
    {
        if constexpr (mode == JSC::SubspaceAccess::Concurrently)
            return nullptr;
        return WebCore::subspaceForImpl<JSSHA512_256Constructor, WebCore::UseCustomHeapCellType::No>(
            vm,
            [](auto& spaces) { return spaces.m_clientSubspaceForSHA512_256Constructor.get(); },
            [](auto& spaces, auto&& space) { spaces.m_clientSubspaceForSHA512_256Constructor = std::forward<decltype(space)>(space); },
            [](auto& spaces) { return spaces.m_subspaceForSHA512_256Constructor.get(); },
            [](auto& spaces, auto&& space) { spaces.m_subspaceForSHA512_256Constructor = std::forward<decltype(space)>(space); });
    }

    void initializeProperties(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSSHA512_256Prototype* prototype);

    // Must be defined for each specialization class.
    static JSC::EncodedJSValue JSC_HOST_CALL_ATTRIBUTES construct(JSC::JSGlobalObject*, JSC::CallFrame*);

    DECLARE_EXPORT_INFO;

private:
    JSSHA512_256Constructor(JSC::VM& vm, JSC::Structure* structure);
    void finishCreation(JSC::VM&, JSC::JSGlobalObject* globalObject, JSSHA512_256Prototype* prototype);
};

extern "C" void* SHA512_256Class__construct(JSC::JSGlobalObject*, JSC::CallFrame*);
JSC_DECLARE_CUSTOM_GETTER(jsSHA512_256Constructor);
extern "C" void SHA512_256Class__finalize(void*);

extern "C" JSC::EncodedJSValue SHA512_256Prototype__getByteLength(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject);
JSC_DECLARE_CUSTOM_GETTER(SHA512_256Prototype__byteLengthGetterWrap);

extern "C" EncodedJSValue SHA512_256Prototype__digest(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(SHA512_256Prototype__digestCallback);

extern "C" EncodedJSValue SHA512_256Prototype__update(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(SHA512_256Prototype__updateCallback);

STATIC_ASSERT_ISO_SUBSPACE_SHARABLE(JSSHA512_256Prototype, JSSHA512_256Prototype::Base);

static const HashTableValue JSSHA512_256PrototypeTableValues[] = {
    { "byteLength"_s, static_cast<unsigned>(JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::GetterSetterType, SHA512_256Prototype__byteLengthGetterWrap, 0 } },
    { "digest"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, SHA512_256Prototype__digestCallback, 0 } },
    { "update"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, SHA512_256Prototype__updateCallback, 1 } }
};

const ClassInfo JSSHA512_256Prototype::s_info = { "SHA512_256"_s, &Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSSHA512_256Prototype) };

JSC_DEFINE_CUSTOM_GETTER(jsSHA512_256Constructor, (JSGlobalObject * lexicalGlobalObject, EncodedJSValue thisValue, PropertyName))
{
    VM& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    auto* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    auto* prototype = jsDynamicCast<JSSHA512_256Prototype*>(JSValue::decode(thisValue));

    if (UNLIKELY(!prototype))
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    return JSValue::encode(globalObject->JSSHA512_256Constructor());
}

JSC_DEFINE_CUSTOM_GETTER(SHA512_256Prototype__byteLengthGetterWrap, (JSGlobalObject * lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    auto& vm = lexicalGlobalObject->vm();
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    JSSHA512_256* thisObject = jsCast<JSSHA512_256*>(JSValue::decode(thisValue));
    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);
    JSC::EncodedJSValue result = SHA512_256Prototype__getByteLength(thisObject->wrapped(), globalObject);
    RETURN_IF_EXCEPTION(throwScope, {});
    RELEASE_AND_RETURN(throwScope, result);
}

JSC_DEFINE_HOST_FUNCTION(SHA512_256Prototype__digestCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSSHA512_256* thisObject = jsDynamicCast<JSSHA512_256*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return SHA512_256Prototype__digest(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_HOST_FUNCTION(SHA512_256Prototype__updateCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSSHA512_256* thisObject = jsDynamicCast<JSSHA512_256*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return SHA512_256Prototype__update(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

void JSSHA512_256Prototype::finishCreation(JSC::VM& vm, JSC::JSGlobalObject* globalObject)
{
    Base::finishCreation(vm);
    reifyStaticProperties(vm, JSSHA512_256::info(), JSSHA512_256PrototypeTableValues, *this);
    JSC_TO_STRING_TAG_WITHOUT_TRANSITION();
}

extern "C" JSC_DECLARE_CUSTOM_GETTER(SHA512_256Class__getByteLengthStatic);
extern "C" JSC_DECLARE_HOST_FUNCTION(SHA512_256Class__hash);

static const HashTableValue JSSHA512_256ConstructorTableValues[] = {
    { "byteLength"_s, static_cast<unsigned>(JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::GetterSetterType, SHA512_256Class__getByteLengthStatic, 0 } },
    { "hash"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, SHA512_256Class__hash, 2 } }
};

void JSSHA512_256Constructor::finishCreation(VM& vm, JSC::JSGlobalObject* globalObject, JSSHA512_256Prototype* prototype)
{
    Base::finishCreation(vm, 0, "SHA512_256"_s, PropertyAdditionMode::WithoutStructureTransition);
    reifyStaticProperties(vm, &JSSHA512_256Constructor::s_info, JSSHA512_256ConstructorTableValues, *this);
    putDirectWithoutTransition(vm, vm.propertyNames->prototype, prototype, PropertyAttribute::DontEnum | PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly);
    ASSERT(inherits(info()));
}

JSSHA512_256Constructor::JSSHA512_256Constructor(JSC::VM& vm, JSC::Structure* structure)
    : Base(vm, structure, construct, construct)
{
}

JSSHA512_256Constructor* JSSHA512_256Constructor::create(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure, JSSHA512_256Prototype* prototype)
{
    JSSHA512_256Constructor* ptr = new (NotNull, JSC::allocateCell<JSSHA512_256Constructor>(vm)) JSSHA512_256Constructor(vm, structure);
    ptr->finishCreation(vm, globalObject, prototype);
    return ptr;
}

JSC::EncodedJSValue JSC_HOST_CALL_ATTRIBUTES JSSHA512_256Constructor::construct(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame)
{
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    JSC::VM& vm = globalObject->vm();
    JSObject* newTarget = asObject(callFrame->newTarget());
    auto* constructor = globalObject->JSSHA512_256Constructor();
    Structure* structure = globalObject->JSSHA512_256Structure();
    if (constructor != newTarget) {
        auto scope = DECLARE_THROW_SCOPE(vm);

        auto* functionGlobalObject = reinterpret_cast<Zig::GlobalObject*>(
            // ShadowRealm functions belong to a different global object.
            getFunctionRealm(globalObject, newTarget));
        RETURN_IF_EXCEPTION(scope, {});
        structure = InternalFunction::createSubclassStructure(
            globalObject,
            newTarget,
            functionGlobalObject->JSSHA512_256Structure());
    }

    void* ptr = SHA512_256Class__construct(globalObject, callFrame);

    if (UNLIKELY(!ptr)) {
        return JSValue::encode(JSC::jsUndefined());
    }

    JSSHA512_256* instance = JSSHA512_256::create(vm, globalObject, structure, ptr);

    return JSValue::encode(instance);
}

void JSSHA512_256Constructor::initializeProperties(VM& vm, JSC::JSGlobalObject* globalObject, JSSHA512_256Prototype* prototype)
{
}

const ClassInfo JSSHA512_256Constructor::s_info = { "Function"_s, &Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSSHA512_256Constructor) };

extern "C" EncodedJSValue SHA512_256__getConstructor(Zig::GlobalObject* globalObject)
{
    return JSValue::encode(globalObject->JSSHA512_256Constructor());
}

JSSHA512_256::~JSSHA512_256()
{
    if (m_ctx) {
        SHA512_256Class__finalize(m_ctx);
    }
}
void JSSHA512_256::destroy(JSCell* cell)
{
    static_cast<JSSHA512_256*>(cell)->JSSHA512_256::~JSSHA512_256();
}

const ClassInfo JSSHA512_256::s_info = { "SHA512_256"_s, &Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSSHA512_256) };

void JSSHA512_256::finishCreation(VM& vm)
{
    Base::finishCreation(vm);
    ASSERT(inherits(info()));
}

JSSHA512_256* JSSHA512_256::create(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure, void* ctx)
{
    JSSHA512_256* ptr = new (NotNull, JSC::allocateCell<JSSHA512_256>(vm)) JSSHA512_256(vm, structure, ctx);
    ptr->finishCreation(vm);
    return ptr;
}

extern "C" void* SHA512_256__fromJS(JSC::EncodedJSValue value)
{
    JSC::JSValue decodedValue = JSC::JSValue::decode(value);
    if (decodedValue.isEmpty() || !decodedValue.isCell())
        return nullptr;

    JSC::JSCell* cell = decodedValue.asCell();
    JSSHA512_256* object = JSC::jsDynamicCast<JSSHA512_256*>(cell);

    if (!object)
        return nullptr;

    return object->wrapped();
}

extern "C" bool SHA512_256__dangerouslySetPtr(JSC::EncodedJSValue value, void* ptr)
{
    JSSHA512_256* object = JSC::jsDynamicCast<JSSHA512_256*>(JSValue::decode(value));
    if (!object)
        return false;

    object->m_ctx = ptr;
    return true;
}

extern "C" const size_t SHA512_256__ptrOffset = JSSHA512_256::offsetOfWrapped();

void JSSHA512_256::analyzeHeap(JSCell* cell, HeapAnalyzer& analyzer)
{
    auto* thisObject = jsCast<JSSHA512_256*>(cell);
    if (void* wrapped = thisObject->wrapped()) {
        // if (thisObject->scriptExecutionContext())
        //     analyzer.setLabelForCell(cell, "url " + thisObject->scriptExecutionContext()->url().string());
    }
    Base::analyzeHeap(cell, analyzer);
}

JSObject* JSSHA512_256::createConstructor(VM& vm, JSGlobalObject* globalObject, JSValue prototype)
{
    return WebCore::JSSHA512_256Constructor::create(vm, globalObject, WebCore::JSSHA512_256Constructor::createStructure(vm, globalObject, globalObject->functionPrototype()), jsCast<WebCore::JSSHA512_256Prototype*>(prototype));
}

JSObject* JSSHA512_256::createPrototype(VM& vm, JSDOMGlobalObject* globalObject)
{
    return JSSHA512_256Prototype::create(vm, globalObject, JSSHA512_256Prototype::createStructure(vm, globalObject, globalObject->objectPrototype()));
}

extern "C" EncodedJSValue SHA512_256__create(Zig::GlobalObject* globalObject, void* ptr)
{
    auto& vm = globalObject->vm();
    JSC::Structure* structure = globalObject->JSSHA512_256Structure();
    JSSHA512_256* instance = JSSHA512_256::create(vm, globalObject, structure, ptr);

    return JSValue::encode(instance);
}
class JSServerWebSocketPrototype final : public JSC::JSNonFinalObject {
public:
    using Base = JSC::JSNonFinalObject;

    static JSServerWebSocketPrototype* create(JSC::VM& vm, JSGlobalObject* globalObject, JSC::Structure* structure)
    {
        JSServerWebSocketPrototype* ptr = new (NotNull, JSC::allocateCell<JSServerWebSocketPrototype>(vm)) JSServerWebSocketPrototype(vm, globalObject, structure);
        ptr->finishCreation(vm, globalObject);
        return ptr;
    }

    DECLARE_INFO;
    template<typename CellType, JSC::SubspaceAccess>
    static JSC::GCClient::IsoSubspace* subspaceFor(JSC::VM& vm)
    {
        return &vm.plainObjectSpace();
    }
    static JSC::Structure* createStructure(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::JSValue prototype)
    {
        return JSC::Structure::create(vm, globalObject, prototype, JSC::TypeInfo(JSC::ObjectType, StructureFlags), info());
    }

private:
    JSServerWebSocketPrototype(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure)
        : Base(vm, structure)
    {
    }

    void finishCreation(JSC::VM&, JSC::JSGlobalObject*);
};

class JSServerWebSocketConstructor final : public JSC::InternalFunction {
public:
    using Base = JSC::InternalFunction;
    static JSServerWebSocketConstructor* create(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure, JSServerWebSocketPrototype* prototype);

    static constexpr unsigned StructureFlags = Base::StructureFlags;
    static constexpr bool needsDestruction = false;

    static JSC::Structure* createStructure(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::JSValue prototype)
    {
        return JSC::Structure::create(vm, globalObject, prototype, JSC::TypeInfo(JSC::InternalFunctionType, StructureFlags), info());
    }

    template<typename, JSC::SubspaceAccess mode> static JSC::GCClient::IsoSubspace* subspaceFor(JSC::VM& vm)
    {
        if constexpr (mode == JSC::SubspaceAccess::Concurrently)
            return nullptr;
        return WebCore::subspaceForImpl<JSServerWebSocketConstructor, WebCore::UseCustomHeapCellType::No>(
            vm,
            [](auto& spaces) { return spaces.m_clientSubspaceForServerWebSocketConstructor.get(); },
            [](auto& spaces, auto&& space) { spaces.m_clientSubspaceForServerWebSocketConstructor = std::forward<decltype(space)>(space); },
            [](auto& spaces) { return spaces.m_subspaceForServerWebSocketConstructor.get(); },
            [](auto& spaces, auto&& space) { spaces.m_subspaceForServerWebSocketConstructor = std::forward<decltype(space)>(space); });
    }

    void initializeProperties(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSServerWebSocketPrototype* prototype);

    // Must be defined for each specialization class.
    static JSC::EncodedJSValue JSC_HOST_CALL_ATTRIBUTES construct(JSC::JSGlobalObject*, JSC::CallFrame*);

    DECLARE_EXPORT_INFO;

private:
    JSServerWebSocketConstructor(JSC::VM& vm, JSC::Structure* structure);
    void finishCreation(JSC::VM&, JSC::JSGlobalObject* globalObject, JSServerWebSocketPrototype* prototype);
};

extern "C" void* ServerWebSocketClass__construct(JSC::JSGlobalObject*, JSC::CallFrame*);
JSC_DECLARE_CUSTOM_GETTER(jsServerWebSocketConstructor);
extern "C" void ServerWebSocketClass__finalize(void*);

extern "C" JSC::EncodedJSValue ServerWebSocketPrototype__getBinaryType(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject);
JSC_DECLARE_CUSTOM_GETTER(ServerWebSocketPrototype__binaryTypeGetterWrap);

extern "C" bool ServerWebSocketPrototype__setBinaryType(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::EncodedJSValue value);
JSC_DECLARE_CUSTOM_SETTER(ServerWebSocketPrototype__binaryTypeSetterWrap);

extern "C" EncodedJSValue ServerWebSocketPrototype__close(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(ServerWebSocketPrototype__closeCallback);

extern "C" EncodedJSValue ServerWebSocketPrototype__cork(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(ServerWebSocketPrototype__corkCallback);

extern "C" JSC::EncodedJSValue ServerWebSocketPrototype__getData(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject);
JSC_DECLARE_CUSTOM_GETTER(ServerWebSocketPrototype__dataGetterWrap);

extern "C" bool ServerWebSocketPrototype__setData(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::EncodedJSValue value);
JSC_DECLARE_CUSTOM_SETTER(ServerWebSocketPrototype__dataSetterWrap);

extern "C" EncodedJSValue ServerWebSocketPrototype__getBufferedAmount(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(ServerWebSocketPrototype__getBufferedAmountCallback);

extern "C" EncodedJSValue ServerWebSocketPrototype__isSubscribed(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(ServerWebSocketPrototype__isSubscribedCallback);

extern "C" EncodedJSValue ServerWebSocketPrototype__publish(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(ServerWebSocketPrototype__publishCallback);

extern "C" EncodedJSValue ServerWebSocketPrototype__publishBinary(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(ServerWebSocketPrototype__publishBinaryCallback);

extern "C" JSC_DECLARE_JIT_OPERATION_WITHOUT_WTF_INTERNAL(ServerWebSocketPrototype__publishBinaryWithoutTypeChecksWrapper, EncodedJSValue, (JSC::JSGlobalObject * lexicalGlobalObject, void* thisValue, JSC::JSString* arg0, JSC::JSUint8Array* arg1));
extern "C" EncodedJSValue ServerWebSocketPrototype__publishBinaryWithoutTypeChecks(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::JSString* arg0, JSC::JSUint8Array* arg1);

static const JSC::DOMJIT::Signature DOMJITSignatureForServerWebSocketPrototype__publishBinary(ServerWebSocketPrototype__publishBinaryWithoutTypeChecksWrapper,
    JSServerWebSocket::info(),
    JSC::DOMJIT::Effect::forReadWrite(JSC::DOMJIT::HeapRange::top(), JSC::DOMJIT::HeapRange::top()),
    JSC::SpecHeapTop, JSC::SpecString, JSC::SpecUint8Array);

JSC_DEFINE_JIT_OPERATION(ServerWebSocketPrototype__publishBinaryWithoutTypeChecksWrapper, EncodedJSValue, (JSC::JSGlobalObject * lexicalGlobalObject, void* thisValue, JSC::JSString* arg0, JSC::JSUint8Array* arg1))
{
    VM& vm = JSC::getVM(lexicalGlobalObject);
    IGNORE_WARNINGS_BEGIN("frame-address")
    CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
    IGNORE_WARNINGS_END
    JSC::JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
    return ServerWebSocketPrototype__publishBinaryWithoutTypeChecks(reinterpret_cast<JSServerWebSocket*>(thisValue)->wrapped(), lexicalGlobalObject, arg0, arg1);
}

extern "C" EncodedJSValue ServerWebSocketPrototype__publishText(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(ServerWebSocketPrototype__publishTextCallback);

extern "C" JSC_DECLARE_JIT_OPERATION_WITHOUT_WTF_INTERNAL(ServerWebSocketPrototype__publishTextWithoutTypeChecksWrapper, EncodedJSValue, (JSC::JSGlobalObject * lexicalGlobalObject, void* thisValue, JSC::JSString* arg0, JSC::JSString* arg1));
extern "C" EncodedJSValue ServerWebSocketPrototype__publishTextWithoutTypeChecks(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::JSString* arg0, JSC::JSString* arg1);

static const JSC::DOMJIT::Signature DOMJITSignatureForServerWebSocketPrototype__publishText(ServerWebSocketPrototype__publishTextWithoutTypeChecksWrapper,
    JSServerWebSocket::info(),
    JSC::DOMJIT::Effect::forReadWrite(JSC::DOMJIT::HeapRange::top(), JSC::DOMJIT::HeapRange::top()),
    JSC::SpecHeapTop, JSC::SpecString, JSC::SpecString);

JSC_DEFINE_JIT_OPERATION(ServerWebSocketPrototype__publishTextWithoutTypeChecksWrapper, EncodedJSValue, (JSC::JSGlobalObject * lexicalGlobalObject, void* thisValue, JSC::JSString* arg0, JSC::JSString* arg1))
{
    VM& vm = JSC::getVM(lexicalGlobalObject);
    IGNORE_WARNINGS_BEGIN("frame-address")
    CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
    IGNORE_WARNINGS_END
    JSC::JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
    return ServerWebSocketPrototype__publishTextWithoutTypeChecks(reinterpret_cast<JSServerWebSocket*>(thisValue)->wrapped(), lexicalGlobalObject, arg0, arg1);
}

extern "C" JSC::EncodedJSValue ServerWebSocketPrototype__getReadyState(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject);
JSC_DECLARE_CUSTOM_GETTER(ServerWebSocketPrototype__readyStateGetterWrap);

extern "C" JSC::EncodedJSValue ServerWebSocketPrototype__getRemoteAddress(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject);
JSC_DECLARE_CUSTOM_GETTER(ServerWebSocketPrototype__remoteAddressGetterWrap);

extern "C" EncodedJSValue ServerWebSocketPrototype__send(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(ServerWebSocketPrototype__sendCallback);

extern "C" EncodedJSValue ServerWebSocketPrototype__sendBinary(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(ServerWebSocketPrototype__sendBinaryCallback);

extern "C" JSC_DECLARE_JIT_OPERATION_WITHOUT_WTF_INTERNAL(ServerWebSocketPrototype__sendBinaryWithoutTypeChecksWrapper, EncodedJSValue, (JSC::JSGlobalObject * lexicalGlobalObject, void* thisValue, JSC::JSUint8Array* arg0, bool arg1));
extern "C" EncodedJSValue ServerWebSocketPrototype__sendBinaryWithoutTypeChecks(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::JSUint8Array* arg0, bool arg1);

static const JSC::DOMJIT::Signature DOMJITSignatureForServerWebSocketPrototype__sendBinary(ServerWebSocketPrototype__sendBinaryWithoutTypeChecksWrapper,
    JSServerWebSocket::info(),
    JSC::DOMJIT::Effect::forReadWrite(JSC::DOMJIT::HeapRange::top(), JSC::DOMJIT::HeapRange::top()),
    JSC::SpecHeapTop, JSC::SpecUint8Array, JSC::SpecBoolean);

JSC_DEFINE_JIT_OPERATION(ServerWebSocketPrototype__sendBinaryWithoutTypeChecksWrapper, EncodedJSValue, (JSC::JSGlobalObject * lexicalGlobalObject, void* thisValue, JSC::JSUint8Array* arg0, bool arg1))
{
    VM& vm = JSC::getVM(lexicalGlobalObject);
    IGNORE_WARNINGS_BEGIN("frame-address")
    CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
    IGNORE_WARNINGS_END
    JSC::JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
    return ServerWebSocketPrototype__sendBinaryWithoutTypeChecks(reinterpret_cast<JSServerWebSocket*>(thisValue)->wrapped(), lexicalGlobalObject, arg0, arg1);
}

extern "C" EncodedJSValue ServerWebSocketPrototype__sendText(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(ServerWebSocketPrototype__sendTextCallback);

extern "C" JSC_DECLARE_JIT_OPERATION_WITHOUT_WTF_INTERNAL(ServerWebSocketPrototype__sendTextWithoutTypeChecksWrapper, EncodedJSValue, (JSC::JSGlobalObject * lexicalGlobalObject, void* thisValue, JSC::JSString* arg0, bool arg1));
extern "C" EncodedJSValue ServerWebSocketPrototype__sendTextWithoutTypeChecks(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::JSString* arg0, bool arg1);

static const JSC::DOMJIT::Signature DOMJITSignatureForServerWebSocketPrototype__sendText(ServerWebSocketPrototype__sendTextWithoutTypeChecksWrapper,
    JSServerWebSocket::info(),
    JSC::DOMJIT::Effect::forReadWrite(JSC::DOMJIT::HeapRange::top(), JSC::DOMJIT::HeapRange::top()),
    JSC::SpecHeapTop, JSC::SpecString, JSC::SpecBoolean);

JSC_DEFINE_JIT_OPERATION(ServerWebSocketPrototype__sendTextWithoutTypeChecksWrapper, EncodedJSValue, (JSC::JSGlobalObject * lexicalGlobalObject, void* thisValue, JSC::JSString* arg0, bool arg1))
{
    VM& vm = JSC::getVM(lexicalGlobalObject);
    IGNORE_WARNINGS_BEGIN("frame-address")
    CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
    IGNORE_WARNINGS_END
    JSC::JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
    return ServerWebSocketPrototype__sendTextWithoutTypeChecks(reinterpret_cast<JSServerWebSocket*>(thisValue)->wrapped(), lexicalGlobalObject, arg0, arg1);
}

extern "C" EncodedJSValue ServerWebSocketPrototype__subscribe(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(ServerWebSocketPrototype__subscribeCallback);

extern "C" EncodedJSValue ServerWebSocketPrototype__unsubscribe(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(ServerWebSocketPrototype__unsubscribeCallback);

STATIC_ASSERT_ISO_SUBSPACE_SHARABLE(JSServerWebSocketPrototype, JSServerWebSocketPrototype::Base);

static const HashTableValue JSServerWebSocketPrototypeTableValues[] = {
    { "binaryType"_s, static_cast<unsigned>(JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::GetterSetterType, ServerWebSocketPrototype__binaryTypeGetterWrap, ServerWebSocketPrototype__binaryTypeSetterWrap } },
    { "close"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, ServerWebSocketPrototype__closeCallback, 1 } },
    { "cork"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, ServerWebSocketPrototype__corkCallback, 1 } },
    { "data"_s, static_cast<unsigned>(JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::GetterSetterType, ServerWebSocketPrototype__dataGetterWrap, ServerWebSocketPrototype__dataSetterWrap } },
    { "getBufferedAmount"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, ServerWebSocketPrototype__getBufferedAmountCallback, 0 } },
    { "isSubscribed"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, ServerWebSocketPrototype__isSubscribedCallback, 1 } },
    { "publish"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, ServerWebSocketPrototype__publishCallback, 3 } },
    { "publishBinary"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | JSC::PropertyAttribute::DOMJITFunction | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::DOMJITFunctionType, ServerWebSocketPrototype__publishBinaryCallback, &DOMJITSignatureForServerWebSocketPrototype__publishBinary } },
    { "publishText"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | JSC::PropertyAttribute::DOMJITFunction | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::DOMJITFunctionType, ServerWebSocketPrototype__publishTextCallback, &DOMJITSignatureForServerWebSocketPrototype__publishText } },
    { "readyState"_s, static_cast<unsigned>(JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::GetterSetterType, ServerWebSocketPrototype__readyStateGetterWrap, 0 } },
    { "remoteAddress"_s, static_cast<unsigned>(JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::GetterSetterType, ServerWebSocketPrototype__remoteAddressGetterWrap, 0 } },
    { "send"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, ServerWebSocketPrototype__sendCallback, 2 } },
    { "sendBinary"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | JSC::PropertyAttribute::DOMJITFunction | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::DOMJITFunctionType, ServerWebSocketPrototype__sendBinaryCallback, &DOMJITSignatureForServerWebSocketPrototype__sendBinary } },
    { "sendText"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | JSC::PropertyAttribute::DOMJITFunction | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::DOMJITFunctionType, ServerWebSocketPrototype__sendTextCallback, &DOMJITSignatureForServerWebSocketPrototype__sendText } },
    { "subscribe"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, ServerWebSocketPrototype__subscribeCallback, 1 } },
    { "unsubscribe"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, ServerWebSocketPrototype__unsubscribeCallback, 1 } }
};

const ClassInfo JSServerWebSocketPrototype::s_info = { "ServerWebSocket"_s, &Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSServerWebSocketPrototype) };

JSC_DEFINE_CUSTOM_GETTER(jsServerWebSocketConstructor, (JSGlobalObject * lexicalGlobalObject, EncodedJSValue thisValue, PropertyName))
{
    VM& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    auto* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    auto* prototype = jsDynamicCast<JSServerWebSocketPrototype*>(JSValue::decode(thisValue));

    if (UNLIKELY(!prototype))
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    return JSValue::encode(globalObject->JSServerWebSocketConstructor());
}

JSC_DEFINE_CUSTOM_GETTER(ServerWebSocketPrototype__binaryTypeGetterWrap, (JSGlobalObject * lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    auto& vm = lexicalGlobalObject->vm();
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    JSServerWebSocket* thisObject = jsCast<JSServerWebSocket*>(JSValue::decode(thisValue));
    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);
    JSC::EncodedJSValue result = ServerWebSocketPrototype__getBinaryType(thisObject->wrapped(), globalObject);
    RETURN_IF_EXCEPTION(throwScope, {});
    RELEASE_AND_RETURN(throwScope, result);
}

JSC_DEFINE_CUSTOM_SETTER(ServerWebSocketPrototype__binaryTypeSetterWrap, (JSGlobalObject * lexicalGlobalObject, EncodedJSValue thisValue, EncodedJSValue encodedValue, PropertyName attributeName))
{
    auto& vm = lexicalGlobalObject->vm();
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    JSServerWebSocket* thisObject = jsCast<JSServerWebSocket*>(JSValue::decode(thisValue));
    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);
    auto result = ServerWebSocketPrototype__setBinaryType(thisObject->wrapped(), lexicalGlobalObject, encodedValue);

    RELEASE_AND_RETURN(throwScope, result);
}

JSC_DEFINE_HOST_FUNCTION(ServerWebSocketPrototype__closeCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSServerWebSocket* thisObject = jsDynamicCast<JSServerWebSocket*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return ServerWebSocketPrototype__close(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_HOST_FUNCTION(ServerWebSocketPrototype__corkCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSServerWebSocket* thisObject = jsDynamicCast<JSServerWebSocket*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return ServerWebSocketPrototype__cork(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_CUSTOM_GETTER(ServerWebSocketPrototype__dataGetterWrap, (JSGlobalObject * lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    auto& vm = lexicalGlobalObject->vm();
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    JSServerWebSocket* thisObject = jsCast<JSServerWebSocket*>(JSValue::decode(thisValue));
    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    if (JSValue cachedValue = thisObject->m_data.get())
        return JSValue::encode(cachedValue);

    JSC::JSValue result = JSC::JSValue::decode(
        ServerWebSocketPrototype__getData(thisObject->wrapped(), globalObject));
    RETURN_IF_EXCEPTION(throwScope, {});
    thisObject->m_data.set(vm, thisObject, result);
    RELEASE_AND_RETURN(throwScope, JSValue::encode(result));
}

extern "C" void ServerWebSocketPrototype__dataSetCachedValue(JSC::EncodedJSValue thisValue, JSC::JSGlobalObject* globalObject, JSC::EncodedJSValue value)
{
    auto& vm = globalObject->vm();
    auto* thisObject = jsCast<JSServerWebSocket*>(JSValue::decode(thisValue));
    thisObject->m_data.set(vm, thisObject, JSValue::decode(value));
}

extern "C" EncodedJSValue ServerWebSocketPrototype__dataGetCachedValue(JSC::EncodedJSValue thisValue)
{
    auto* thisObject = jsCast<JSServerWebSocket*>(JSValue::decode(thisValue));
    return JSValue::encode(thisObject->m_data.get());
}

JSC_DEFINE_CUSTOM_SETTER(ServerWebSocketPrototype__dataSetterWrap, (JSGlobalObject * lexicalGlobalObject, EncodedJSValue thisValue, EncodedJSValue encodedValue, PropertyName attributeName))
{
    auto& vm = lexicalGlobalObject->vm();
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    JSServerWebSocket* thisObject = jsCast<JSServerWebSocket*>(JSValue::decode(thisValue));
    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);
    auto result = ServerWebSocketPrototype__setData(thisObject->wrapped(), lexicalGlobalObject, encodedValue);

    RELEASE_AND_RETURN(throwScope, result);
}

JSC_DEFINE_HOST_FUNCTION(ServerWebSocketPrototype__getBufferedAmountCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSServerWebSocket* thisObject = jsDynamicCast<JSServerWebSocket*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return ServerWebSocketPrototype__getBufferedAmount(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_HOST_FUNCTION(ServerWebSocketPrototype__isSubscribedCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSServerWebSocket* thisObject = jsDynamicCast<JSServerWebSocket*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return ServerWebSocketPrototype__isSubscribed(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_HOST_FUNCTION(ServerWebSocketPrototype__publishCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSServerWebSocket* thisObject = jsDynamicCast<JSServerWebSocket*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return ServerWebSocketPrototype__publish(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_HOST_FUNCTION(ServerWebSocketPrototype__publishBinaryCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSServerWebSocket* thisObject = jsDynamicCast<JSServerWebSocket*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return ServerWebSocketPrototype__publishBinary(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_HOST_FUNCTION(ServerWebSocketPrototype__publishTextCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSServerWebSocket* thisObject = jsDynamicCast<JSServerWebSocket*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return ServerWebSocketPrototype__publishText(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_CUSTOM_GETTER(ServerWebSocketPrototype__readyStateGetterWrap, (JSGlobalObject * lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    auto& vm = lexicalGlobalObject->vm();
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    JSServerWebSocket* thisObject = jsCast<JSServerWebSocket*>(JSValue::decode(thisValue));
    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);
    JSC::EncodedJSValue result = ServerWebSocketPrototype__getReadyState(thisObject->wrapped(), globalObject);
    RETURN_IF_EXCEPTION(throwScope, {});
    RELEASE_AND_RETURN(throwScope, result);
}

JSC_DEFINE_CUSTOM_GETTER(ServerWebSocketPrototype__remoteAddressGetterWrap, (JSGlobalObject * lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    auto& vm = lexicalGlobalObject->vm();
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    JSServerWebSocket* thisObject = jsCast<JSServerWebSocket*>(JSValue::decode(thisValue));
    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    if (JSValue cachedValue = thisObject->m_remoteAddress.get())
        return JSValue::encode(cachedValue);

    JSC::JSValue result = JSC::JSValue::decode(
        ServerWebSocketPrototype__getRemoteAddress(thisObject->wrapped(), globalObject));
    RETURN_IF_EXCEPTION(throwScope, {});
    thisObject->m_remoteAddress.set(vm, thisObject, result);
    RELEASE_AND_RETURN(throwScope, JSValue::encode(result));
}

extern "C" void ServerWebSocketPrototype__remoteAddressSetCachedValue(JSC::EncodedJSValue thisValue, JSC::JSGlobalObject* globalObject, JSC::EncodedJSValue value)
{
    auto& vm = globalObject->vm();
    auto* thisObject = jsCast<JSServerWebSocket*>(JSValue::decode(thisValue));
    thisObject->m_remoteAddress.set(vm, thisObject, JSValue::decode(value));
}

extern "C" EncodedJSValue ServerWebSocketPrototype__remoteAddressGetCachedValue(JSC::EncodedJSValue thisValue)
{
    auto* thisObject = jsCast<JSServerWebSocket*>(JSValue::decode(thisValue));
    return JSValue::encode(thisObject->m_remoteAddress.get());
}

JSC_DEFINE_HOST_FUNCTION(ServerWebSocketPrototype__sendCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSServerWebSocket* thisObject = jsDynamicCast<JSServerWebSocket*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return ServerWebSocketPrototype__send(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_HOST_FUNCTION(ServerWebSocketPrototype__sendBinaryCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSServerWebSocket* thisObject = jsDynamicCast<JSServerWebSocket*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return ServerWebSocketPrototype__sendBinary(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_HOST_FUNCTION(ServerWebSocketPrototype__sendTextCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSServerWebSocket* thisObject = jsDynamicCast<JSServerWebSocket*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return ServerWebSocketPrototype__sendText(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_HOST_FUNCTION(ServerWebSocketPrototype__subscribeCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSServerWebSocket* thisObject = jsDynamicCast<JSServerWebSocket*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return ServerWebSocketPrototype__subscribe(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_HOST_FUNCTION(ServerWebSocketPrototype__unsubscribeCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSServerWebSocket* thisObject = jsDynamicCast<JSServerWebSocket*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return ServerWebSocketPrototype__unsubscribe(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

void JSServerWebSocketPrototype::finishCreation(JSC::VM& vm, JSC::JSGlobalObject* globalObject)
{
    Base::finishCreation(vm);
    reifyStaticProperties(vm, JSServerWebSocket::info(), JSServerWebSocketPrototypeTableValues, *this);
    JSC_TO_STRING_TAG_WITHOUT_TRANSITION();
}

void JSServerWebSocketConstructor::finishCreation(VM& vm, JSC::JSGlobalObject* globalObject, JSServerWebSocketPrototype* prototype)
{
    Base::finishCreation(vm, 0, "ServerWebSocket"_s, PropertyAdditionMode::WithoutStructureTransition);

    putDirectWithoutTransition(vm, vm.propertyNames->prototype, prototype, PropertyAttribute::DontEnum | PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly);
    ASSERT(inherits(info()));
}

JSServerWebSocketConstructor::JSServerWebSocketConstructor(JSC::VM& vm, JSC::Structure* structure)
    : Base(vm, structure, construct, construct)
{
}

JSServerWebSocketConstructor* JSServerWebSocketConstructor::create(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure, JSServerWebSocketPrototype* prototype)
{
    JSServerWebSocketConstructor* ptr = new (NotNull, JSC::allocateCell<JSServerWebSocketConstructor>(vm)) JSServerWebSocketConstructor(vm, structure);
    ptr->finishCreation(vm, globalObject, prototype);
    return ptr;
}

JSC::EncodedJSValue JSC_HOST_CALL_ATTRIBUTES JSServerWebSocketConstructor::construct(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame)
{
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    JSC::VM& vm = globalObject->vm();
    JSObject* newTarget = asObject(callFrame->newTarget());
    auto* constructor = globalObject->JSServerWebSocketConstructor();
    Structure* structure = globalObject->JSServerWebSocketStructure();
    if (constructor != newTarget) {
        auto scope = DECLARE_THROW_SCOPE(vm);

        auto* functionGlobalObject = reinterpret_cast<Zig::GlobalObject*>(
            // ShadowRealm functions belong to a different global object.
            getFunctionRealm(globalObject, newTarget));
        RETURN_IF_EXCEPTION(scope, {});
        structure = InternalFunction::createSubclassStructure(
            globalObject,
            newTarget,
            functionGlobalObject->JSServerWebSocketStructure());
    }

    void* ptr = ServerWebSocketClass__construct(globalObject, callFrame);

    if (UNLIKELY(!ptr)) {
        return JSValue::encode(JSC::jsUndefined());
    }

    JSServerWebSocket* instance = JSServerWebSocket::create(vm, globalObject, structure, ptr);

    return JSValue::encode(instance);
}

void JSServerWebSocketConstructor::initializeProperties(VM& vm, JSC::JSGlobalObject* globalObject, JSServerWebSocketPrototype* prototype)
{
}

const ClassInfo JSServerWebSocketConstructor::s_info = { "Function"_s, &Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSServerWebSocketConstructor) };

extern "C" EncodedJSValue ServerWebSocket__getConstructor(Zig::GlobalObject* globalObject)
{
    return JSValue::encode(globalObject->JSServerWebSocketConstructor());
}

JSServerWebSocket::~JSServerWebSocket()
{
    if (m_ctx) {
        ServerWebSocketClass__finalize(m_ctx);
    }
}
void JSServerWebSocket::destroy(JSCell* cell)
{
    static_cast<JSServerWebSocket*>(cell)->JSServerWebSocket::~JSServerWebSocket();
}

const ClassInfo JSServerWebSocket::s_info = { "ServerWebSocket"_s, &Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSServerWebSocket) };

void JSServerWebSocket::finishCreation(VM& vm)
{
    Base::finishCreation(vm);
    ASSERT(inherits(info()));
}

JSServerWebSocket* JSServerWebSocket::create(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure, void* ctx)
{
    JSServerWebSocket* ptr = new (NotNull, JSC::allocateCell<JSServerWebSocket>(vm)) JSServerWebSocket(vm, structure, ctx);
    ptr->finishCreation(vm);
    return ptr;
}

extern "C" void* ServerWebSocket__fromJS(JSC::EncodedJSValue value)
{
    JSC::JSValue decodedValue = JSC::JSValue::decode(value);
    if (decodedValue.isEmpty() || !decodedValue.isCell())
        return nullptr;

    JSC::JSCell* cell = decodedValue.asCell();
    JSServerWebSocket* object = JSC::jsDynamicCast<JSServerWebSocket*>(cell);

    if (!object)
        return nullptr;

    return object->wrapped();
}

extern "C" bool ServerWebSocket__dangerouslySetPtr(JSC::EncodedJSValue value, void* ptr)
{
    JSServerWebSocket* object = JSC::jsDynamicCast<JSServerWebSocket*>(JSValue::decode(value));
    if (!object)
        return false;

    object->m_ctx = ptr;
    return true;
}

extern "C" const size_t ServerWebSocket__ptrOffset = JSServerWebSocket::offsetOfWrapped();

void JSServerWebSocket::analyzeHeap(JSCell* cell, HeapAnalyzer& analyzer)
{
    auto* thisObject = jsCast<JSServerWebSocket*>(cell);
    if (void* wrapped = thisObject->wrapped()) {
        // if (thisObject->scriptExecutionContext())
        //     analyzer.setLabelForCell(cell, "url " + thisObject->scriptExecutionContext()->url().string());
    }
    Base::analyzeHeap(cell, analyzer);
}

JSObject* JSServerWebSocket::createConstructor(VM& vm, JSGlobalObject* globalObject, JSValue prototype)
{
    return WebCore::JSServerWebSocketConstructor::create(vm, globalObject, WebCore::JSServerWebSocketConstructor::createStructure(vm, globalObject, globalObject->functionPrototype()), jsCast<WebCore::JSServerWebSocketPrototype*>(prototype));
}

JSObject* JSServerWebSocket::createPrototype(VM& vm, JSDOMGlobalObject* globalObject)
{
    return JSServerWebSocketPrototype::create(vm, globalObject, JSServerWebSocketPrototype::createStructure(vm, globalObject, globalObject->objectPrototype()));
}

extern "C" EncodedJSValue ServerWebSocket__create(Zig::GlobalObject* globalObject, void* ptr)
{
    auto& vm = globalObject->vm();
    JSC::Structure* structure = globalObject->JSServerWebSocketStructure();
    JSServerWebSocket* instance = JSServerWebSocket::create(vm, globalObject, structure, ptr);

    return JSValue::encode(instance);
}

template<typename Visitor>
void JSServerWebSocket::visitChildrenImpl(JSCell* cell, Visitor& visitor)
{
    JSServerWebSocket* thisObject = jsCast<JSServerWebSocket*>(cell);
    ASSERT_GC_OBJECT_INHERITS(thisObject, info());
    Base::visitChildren(thisObject, visitor);

    visitor.append(thisObject->m_data);
    visitor.append(thisObject->m_remoteAddress);
}

DEFINE_VISIT_CHILDREN(JSServerWebSocket);

template<typename Visitor>
void JSServerWebSocket::visitAdditionalChildren(Visitor& visitor)
{
    JSServerWebSocket* thisObject = this;
    ASSERT_GC_OBJECT_INHERITS(thisObject, info());

    visitor.append(thisObject->m_data);
    visitor.append(thisObject->m_remoteAddress);
    ;
}

DEFINE_VISIT_ADDITIONAL_CHILDREN(JSServerWebSocket);

template<typename Visitor>
void JSServerWebSocket::visitOutputConstraintsImpl(JSCell* cell, Visitor& visitor)
{
    JSServerWebSocket* thisObject = jsCast<JSServerWebSocket*>(cell);
    ASSERT_GC_OBJECT_INHERITS(thisObject, info());
    thisObject->visitAdditionalChildren<Visitor>(visitor);
}

DEFINE_VISIT_OUTPUT_CONSTRAINTS(JSServerWebSocket);
class JSStatsPrototype final : public JSC::JSNonFinalObject {
public:
    using Base = JSC::JSNonFinalObject;

    static JSStatsPrototype* create(JSC::VM& vm, JSGlobalObject* globalObject, JSC::Structure* structure)
    {
        JSStatsPrototype* ptr = new (NotNull, JSC::allocateCell<JSStatsPrototype>(vm)) JSStatsPrototype(vm, globalObject, structure);
        ptr->finishCreation(vm, globalObject);
        return ptr;
    }

    DECLARE_INFO;
    template<typename CellType, JSC::SubspaceAccess>
    static JSC::GCClient::IsoSubspace* subspaceFor(JSC::VM& vm)
    {
        return &vm.plainObjectSpace();
    }
    static JSC::Structure* createStructure(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::JSValue prototype)
    {
        return JSC::Structure::create(vm, globalObject, prototype, JSC::TypeInfo(JSC::ObjectType, StructureFlags), info());
    }

private:
    JSStatsPrototype(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure)
        : Base(vm, structure)
    {
    }

    void finishCreation(JSC::VM&, JSC::JSGlobalObject*);
};

class JSStatsConstructor final : public JSC::InternalFunction {
public:
    using Base = JSC::InternalFunction;
    static JSStatsConstructor* create(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure, JSStatsPrototype* prototype);

    static constexpr unsigned StructureFlags = Base::StructureFlags;
    static constexpr bool needsDestruction = false;

    static JSC::Structure* createStructure(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::JSValue prototype)
    {
        return JSC::Structure::create(vm, globalObject, prototype, JSC::TypeInfo(JSC::InternalFunctionType, StructureFlags), info());
    }

    template<typename, JSC::SubspaceAccess mode> static JSC::GCClient::IsoSubspace* subspaceFor(JSC::VM& vm)
    {
        if constexpr (mode == JSC::SubspaceAccess::Concurrently)
            return nullptr;
        return WebCore::subspaceForImpl<JSStatsConstructor, WebCore::UseCustomHeapCellType::No>(
            vm,
            [](auto& spaces) { return spaces.m_clientSubspaceForStatsConstructor.get(); },
            [](auto& spaces, auto&& space) { spaces.m_clientSubspaceForStatsConstructor = std::forward<decltype(space)>(space); },
            [](auto& spaces) { return spaces.m_subspaceForStatsConstructor.get(); },
            [](auto& spaces, auto&& space) { spaces.m_subspaceForStatsConstructor = std::forward<decltype(space)>(space); });
    }

    void initializeProperties(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSStatsPrototype* prototype);

    // Must be defined for each specialization class.
    static JSC::EncodedJSValue JSC_HOST_CALL_ATTRIBUTES construct(JSC::JSGlobalObject*, JSC::CallFrame*);

    DECLARE_EXPORT_INFO;

private:
    JSStatsConstructor(JSC::VM& vm, JSC::Structure* structure);
    void finishCreation(JSC::VM&, JSC::JSGlobalObject* globalObject, JSStatsPrototype* prototype);
};

extern "C" void* StatsClass__construct(JSC::JSGlobalObject*, JSC::CallFrame*);
JSC_DECLARE_CUSTOM_GETTER(jsStatsConstructor);
extern "C" void StatsClass__finalize(void*);

extern "C" JSC::EncodedJSValue StatsPrototype__atime(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject);
JSC_DECLARE_CUSTOM_GETTER(StatsPrototype__atimeGetterWrap);

extern "C" JSC::EncodedJSValue StatsPrototype__atimeMs(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject);
JSC_DECLARE_CUSTOM_GETTER(StatsPrototype__atimeMsGetterWrap);

extern "C" JSC::EncodedJSValue StatsPrototype__birthtime(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject);
JSC_DECLARE_CUSTOM_GETTER(StatsPrototype__birthtimeGetterWrap);

extern "C" JSC::EncodedJSValue StatsPrototype__birthtimeMs(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject);
JSC_DECLARE_CUSTOM_GETTER(StatsPrototype__birthtimeMsGetterWrap);

extern "C" JSC::EncodedJSValue StatsPrototype__blksize(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject);
JSC_DECLARE_CUSTOM_GETTER(StatsPrototype__blksizeGetterWrap);

extern "C" JSC::EncodedJSValue StatsPrototype__blocks(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject);
JSC_DECLARE_CUSTOM_GETTER(StatsPrototype__blocksGetterWrap);

extern "C" JSC::EncodedJSValue StatsPrototype__ctime(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject);
JSC_DECLARE_CUSTOM_GETTER(StatsPrototype__ctimeGetterWrap);

extern "C" JSC::EncodedJSValue StatsPrototype__ctimeMs(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject);
JSC_DECLARE_CUSTOM_GETTER(StatsPrototype__ctimeMsGetterWrap);

extern "C" JSC::EncodedJSValue StatsPrototype__dev(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject);
JSC_DECLARE_CUSTOM_GETTER(StatsPrototype__devGetterWrap);

extern "C" JSC::EncodedJSValue StatsPrototype__gid(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject);
JSC_DECLARE_CUSTOM_GETTER(StatsPrototype__gidGetterWrap);

extern "C" JSC::EncodedJSValue StatsPrototype__ino(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject);
JSC_DECLARE_CUSTOM_GETTER(StatsPrototype__inoGetterWrap);

extern "C" EncodedJSValue StatsPrototype__isBlockDevice_(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(StatsPrototype__isBlockDeviceCallback);

extern "C" JSC_DECLARE_JIT_OPERATION_WITHOUT_WTF_INTERNAL(StatsPrototype__isBlockDeviceWithoutTypeChecksWrapper, EncodedJSValue, (JSC::JSGlobalObject * lexicalGlobalObject, void* thisValue));
extern "C" EncodedJSValue StatsPrototype__isBlockDevice_WithoutTypeChecks(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject);

static const JSC::DOMJIT::Signature DOMJITSignatureForStatsPrototype__isBlockDevice(StatsPrototype__isBlockDeviceWithoutTypeChecksWrapper,
    JSStats::info(),
    JSC::DOMJIT::Effect::forPure(),
    JSC::SpecHeapTop);

JSC_DEFINE_JIT_OPERATION(StatsPrototype__isBlockDeviceWithoutTypeChecksWrapper, EncodedJSValue, (JSC::JSGlobalObject * lexicalGlobalObject, void* thisValue))
{
    VM& vm = JSC::getVM(lexicalGlobalObject);
    IGNORE_WARNINGS_BEGIN("frame-address")
    CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
    IGNORE_WARNINGS_END
    JSC::JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
    return StatsPrototype__isBlockDevice_WithoutTypeChecks(reinterpret_cast<JSStats*>(thisValue)->wrapped(), lexicalGlobalObject);
}

extern "C" EncodedJSValue StatsPrototype__isCharacterDevice_(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(StatsPrototype__isCharacterDeviceCallback);

extern "C" JSC_DECLARE_JIT_OPERATION_WITHOUT_WTF_INTERNAL(StatsPrototype__isCharacterDeviceWithoutTypeChecksWrapper, EncodedJSValue, (JSC::JSGlobalObject * lexicalGlobalObject, void* thisValue));
extern "C" EncodedJSValue StatsPrototype__isCharacterDevice_WithoutTypeChecks(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject);

static const JSC::DOMJIT::Signature DOMJITSignatureForStatsPrototype__isCharacterDevice(StatsPrototype__isCharacterDeviceWithoutTypeChecksWrapper,
    JSStats::info(),
    JSC::DOMJIT::Effect::forPure(),
    JSC::SpecHeapTop);

JSC_DEFINE_JIT_OPERATION(StatsPrototype__isCharacterDeviceWithoutTypeChecksWrapper, EncodedJSValue, (JSC::JSGlobalObject * lexicalGlobalObject, void* thisValue))
{
    VM& vm = JSC::getVM(lexicalGlobalObject);
    IGNORE_WARNINGS_BEGIN("frame-address")
    CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
    IGNORE_WARNINGS_END
    JSC::JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
    return StatsPrototype__isCharacterDevice_WithoutTypeChecks(reinterpret_cast<JSStats*>(thisValue)->wrapped(), lexicalGlobalObject);
}

extern "C" EncodedJSValue StatsPrototype__isDirectory_(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(StatsPrototype__isDirectoryCallback);

extern "C" JSC_DECLARE_JIT_OPERATION_WITHOUT_WTF_INTERNAL(StatsPrototype__isDirectoryWithoutTypeChecksWrapper, EncodedJSValue, (JSC::JSGlobalObject * lexicalGlobalObject, void* thisValue));
extern "C" EncodedJSValue StatsPrototype__isDirectory_WithoutTypeChecks(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject);

static const JSC::DOMJIT::Signature DOMJITSignatureForStatsPrototype__isDirectory(StatsPrototype__isDirectoryWithoutTypeChecksWrapper,
    JSStats::info(),
    JSC::DOMJIT::Effect::forPure(),
    JSC::SpecHeapTop);

JSC_DEFINE_JIT_OPERATION(StatsPrototype__isDirectoryWithoutTypeChecksWrapper, EncodedJSValue, (JSC::JSGlobalObject * lexicalGlobalObject, void* thisValue))
{
    VM& vm = JSC::getVM(lexicalGlobalObject);
    IGNORE_WARNINGS_BEGIN("frame-address")
    CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
    IGNORE_WARNINGS_END
    JSC::JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
    return StatsPrototype__isDirectory_WithoutTypeChecks(reinterpret_cast<JSStats*>(thisValue)->wrapped(), lexicalGlobalObject);
}

extern "C" EncodedJSValue StatsPrototype__isFIFO_(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(StatsPrototype__isFIFOCallback);

extern "C" JSC_DECLARE_JIT_OPERATION_WITHOUT_WTF_INTERNAL(StatsPrototype__isFIFOWithoutTypeChecksWrapper, EncodedJSValue, (JSC::JSGlobalObject * lexicalGlobalObject, void* thisValue));
extern "C" EncodedJSValue StatsPrototype__isFIFO_WithoutTypeChecks(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject);

static const JSC::DOMJIT::Signature DOMJITSignatureForStatsPrototype__isFIFO(StatsPrototype__isFIFOWithoutTypeChecksWrapper,
    JSStats::info(),
    JSC::DOMJIT::Effect::forPure(),
    JSC::SpecHeapTop);

JSC_DEFINE_JIT_OPERATION(StatsPrototype__isFIFOWithoutTypeChecksWrapper, EncodedJSValue, (JSC::JSGlobalObject * lexicalGlobalObject, void* thisValue))
{
    VM& vm = JSC::getVM(lexicalGlobalObject);
    IGNORE_WARNINGS_BEGIN("frame-address")
    CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
    IGNORE_WARNINGS_END
    JSC::JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
    return StatsPrototype__isFIFO_WithoutTypeChecks(reinterpret_cast<JSStats*>(thisValue)->wrapped(), lexicalGlobalObject);
}

extern "C" EncodedJSValue StatsPrototype__isFile_(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(StatsPrototype__isFileCallback);

extern "C" JSC_DECLARE_JIT_OPERATION_WITHOUT_WTF_INTERNAL(StatsPrototype__isFileWithoutTypeChecksWrapper, EncodedJSValue, (JSC::JSGlobalObject * lexicalGlobalObject, void* thisValue));
extern "C" EncodedJSValue StatsPrototype__isFile_WithoutTypeChecks(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject);

static const JSC::DOMJIT::Signature DOMJITSignatureForStatsPrototype__isFile(StatsPrototype__isFileWithoutTypeChecksWrapper,
    JSStats::info(),
    JSC::DOMJIT::Effect::forPure(),
    JSC::SpecHeapTop);

JSC_DEFINE_JIT_OPERATION(StatsPrototype__isFileWithoutTypeChecksWrapper, EncodedJSValue, (JSC::JSGlobalObject * lexicalGlobalObject, void* thisValue))
{
    VM& vm = JSC::getVM(lexicalGlobalObject);
    IGNORE_WARNINGS_BEGIN("frame-address")
    CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
    IGNORE_WARNINGS_END
    JSC::JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
    return StatsPrototype__isFile_WithoutTypeChecks(reinterpret_cast<JSStats*>(thisValue)->wrapped(), lexicalGlobalObject);
}

extern "C" EncodedJSValue StatsPrototype__isSocket_(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(StatsPrototype__isSocketCallback);

extern "C" JSC_DECLARE_JIT_OPERATION_WITHOUT_WTF_INTERNAL(StatsPrototype__isSocketWithoutTypeChecksWrapper, EncodedJSValue, (JSC::JSGlobalObject * lexicalGlobalObject, void* thisValue));
extern "C" EncodedJSValue StatsPrototype__isSocket_WithoutTypeChecks(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject);

static const JSC::DOMJIT::Signature DOMJITSignatureForStatsPrototype__isSocket(StatsPrototype__isSocketWithoutTypeChecksWrapper,
    JSStats::info(),
    JSC::DOMJIT::Effect::forPure(),
    JSC::SpecHeapTop);

JSC_DEFINE_JIT_OPERATION(StatsPrototype__isSocketWithoutTypeChecksWrapper, EncodedJSValue, (JSC::JSGlobalObject * lexicalGlobalObject, void* thisValue))
{
    VM& vm = JSC::getVM(lexicalGlobalObject);
    IGNORE_WARNINGS_BEGIN("frame-address")
    CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
    IGNORE_WARNINGS_END
    JSC::JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
    return StatsPrototype__isSocket_WithoutTypeChecks(reinterpret_cast<JSStats*>(thisValue)->wrapped(), lexicalGlobalObject);
}

extern "C" EncodedJSValue StatsPrototype__isSymbolicLink_(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(StatsPrototype__isSymbolicLinkCallback);

extern "C" JSC_DECLARE_JIT_OPERATION_WITHOUT_WTF_INTERNAL(StatsPrototype__isSymbolicLinkWithoutTypeChecksWrapper, EncodedJSValue, (JSC::JSGlobalObject * lexicalGlobalObject, void* thisValue));
extern "C" EncodedJSValue StatsPrototype__isSymbolicLink_WithoutTypeChecks(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject);

static const JSC::DOMJIT::Signature DOMJITSignatureForStatsPrototype__isSymbolicLink(StatsPrototype__isSymbolicLinkWithoutTypeChecksWrapper,
    JSStats::info(),
    JSC::DOMJIT::Effect::forPure(),
    JSC::SpecHeapTop);

JSC_DEFINE_JIT_OPERATION(StatsPrototype__isSymbolicLinkWithoutTypeChecksWrapper, EncodedJSValue, (JSC::JSGlobalObject * lexicalGlobalObject, void* thisValue))
{
    VM& vm = JSC::getVM(lexicalGlobalObject);
    IGNORE_WARNINGS_BEGIN("frame-address")
    CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
    IGNORE_WARNINGS_END
    JSC::JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
    return StatsPrototype__isSymbolicLink_WithoutTypeChecks(reinterpret_cast<JSStats*>(thisValue)->wrapped(), lexicalGlobalObject);
}

extern "C" JSC::EncodedJSValue StatsPrototype__mode(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject);
JSC_DECLARE_CUSTOM_GETTER(StatsPrototype__modeGetterWrap);

extern "C" JSC::EncodedJSValue StatsPrototype__mtime(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject);
JSC_DECLARE_CUSTOM_GETTER(StatsPrototype__mtimeGetterWrap);

extern "C" JSC::EncodedJSValue StatsPrototype__mtimeMs(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject);
JSC_DECLARE_CUSTOM_GETTER(StatsPrototype__mtimeMsGetterWrap);

extern "C" JSC::EncodedJSValue StatsPrototype__nlink(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject);
JSC_DECLARE_CUSTOM_GETTER(StatsPrototype__nlinkGetterWrap);

extern "C" JSC::EncodedJSValue StatsPrototype__rdev(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject);
JSC_DECLARE_CUSTOM_GETTER(StatsPrototype__rdevGetterWrap);

extern "C" JSC::EncodedJSValue StatsPrototype__size(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject);
JSC_DECLARE_CUSTOM_GETTER(StatsPrototype__sizeGetterWrap);

extern "C" JSC::EncodedJSValue StatsPrototype__uid(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject);
JSC_DECLARE_CUSTOM_GETTER(StatsPrototype__uidGetterWrap);

STATIC_ASSERT_ISO_SUBSPACE_SHARABLE(JSStatsPrototype, JSStatsPrototype::Base);

static const HashTableValue JSStatsPrototypeTableValues[] = {
    { "atime"_s, static_cast<unsigned>(JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::GetterSetterType, StatsPrototype__atimeGetterWrap, 0 } },
    { "atimeMs"_s, static_cast<unsigned>(JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::GetterSetterType, StatsPrototype__atimeMsGetterWrap, 0 } },
    { "birthtime"_s, static_cast<unsigned>(JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::GetterSetterType, StatsPrototype__birthtimeGetterWrap, 0 } },
    { "birthtimeMs"_s, static_cast<unsigned>(JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::GetterSetterType, StatsPrototype__birthtimeMsGetterWrap, 0 } },
    { "blksize"_s, static_cast<unsigned>(JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::GetterSetterType, StatsPrototype__blksizeGetterWrap, 0 } },
    { "blocks"_s, static_cast<unsigned>(JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::GetterSetterType, StatsPrototype__blocksGetterWrap, 0 } },
    { "ctime"_s, static_cast<unsigned>(JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::GetterSetterType, StatsPrototype__ctimeGetterWrap, 0 } },
    { "ctimeMs"_s, static_cast<unsigned>(JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::GetterSetterType, StatsPrototype__ctimeMsGetterWrap, 0 } },
    { "dev"_s, static_cast<unsigned>(JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::GetterSetterType, StatsPrototype__devGetterWrap, 0 } },
    { "gid"_s, static_cast<unsigned>(JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::GetterSetterType, StatsPrototype__gidGetterWrap, 0 } },
    { "ino"_s, static_cast<unsigned>(JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::GetterSetterType, StatsPrototype__inoGetterWrap, 0 } },
    { "isBlockDevice"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | JSC::PropertyAttribute::DOMJITFunction | PropertyAttribute::DontEnum | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::DOMJITFunctionType, StatsPrototype__isBlockDeviceCallback, &DOMJITSignatureForStatsPrototype__isBlockDevice } },
    { "isCharacterDevice"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | JSC::PropertyAttribute::DOMJITFunction | PropertyAttribute::DontEnum | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::DOMJITFunctionType, StatsPrototype__isCharacterDeviceCallback, &DOMJITSignatureForStatsPrototype__isCharacterDevice } },
    { "isDirectory"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | JSC::PropertyAttribute::DOMJITFunction | PropertyAttribute::DontEnum | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::DOMJITFunctionType, StatsPrototype__isDirectoryCallback, &DOMJITSignatureForStatsPrototype__isDirectory } },
    { "isFIFO"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | JSC::PropertyAttribute::DOMJITFunction | PropertyAttribute::DontEnum | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::DOMJITFunctionType, StatsPrototype__isFIFOCallback, &DOMJITSignatureForStatsPrototype__isFIFO } },
    { "isFile"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | JSC::PropertyAttribute::DOMJITFunction | PropertyAttribute::DontEnum | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::DOMJITFunctionType, StatsPrototype__isFileCallback, &DOMJITSignatureForStatsPrototype__isFile } },
    { "isSocket"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | JSC::PropertyAttribute::DOMJITFunction | PropertyAttribute::DontEnum | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::DOMJITFunctionType, StatsPrototype__isSocketCallback, &DOMJITSignatureForStatsPrototype__isSocket } },
    { "isSymbolicLink"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | JSC::PropertyAttribute::DOMJITFunction | PropertyAttribute::DontEnum | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::DOMJITFunctionType, StatsPrototype__isSymbolicLinkCallback, &DOMJITSignatureForStatsPrototype__isSymbolicLink } },
    { "mode"_s, static_cast<unsigned>(JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::GetterSetterType, StatsPrototype__modeGetterWrap, 0 } },
    { "mtime"_s, static_cast<unsigned>(JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::GetterSetterType, StatsPrototype__mtimeGetterWrap, 0 } },
    { "mtimeMs"_s, static_cast<unsigned>(JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::GetterSetterType, StatsPrototype__mtimeMsGetterWrap, 0 } },
    { "nlink"_s, static_cast<unsigned>(JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::GetterSetterType, StatsPrototype__nlinkGetterWrap, 0 } },
    { "rdev"_s, static_cast<unsigned>(JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::GetterSetterType, StatsPrototype__rdevGetterWrap, 0 } },
    { "size"_s, static_cast<unsigned>(JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::GetterSetterType, StatsPrototype__sizeGetterWrap, 0 } },
    { "uid"_s, static_cast<unsigned>(JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::GetterSetterType, StatsPrototype__uidGetterWrap, 0 } }
};

const ClassInfo JSStatsPrototype::s_info = { "Stats"_s, &Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSStatsPrototype) };

JSC_DEFINE_CUSTOM_GETTER(jsStatsConstructor, (JSGlobalObject * lexicalGlobalObject, EncodedJSValue thisValue, PropertyName))
{
    VM& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    auto* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    auto* prototype = jsDynamicCast<JSStatsPrototype*>(JSValue::decode(thisValue));

    if (UNLIKELY(!prototype))
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    return JSValue::encode(globalObject->JSStatsConstructor());
}

JSC_DEFINE_CUSTOM_GETTER(StatsPrototype__atimeGetterWrap, (JSGlobalObject * lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    auto& vm = lexicalGlobalObject->vm();
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    JSStats* thisObject = jsCast<JSStats*>(JSValue::decode(thisValue));
    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    if (JSValue cachedValue = thisObject->m_atime.get())
        return JSValue::encode(cachedValue);

    JSC::JSValue result = JSC::JSValue::decode(
        StatsPrototype__atime(thisObject->wrapped(), globalObject));
    RETURN_IF_EXCEPTION(throwScope, {});
    thisObject->m_atime.set(vm, thisObject, result);
    RELEASE_AND_RETURN(throwScope, JSValue::encode(result));
}

extern "C" void StatsPrototype__atimeSetCachedValue(JSC::EncodedJSValue thisValue, JSC::JSGlobalObject* globalObject, JSC::EncodedJSValue value)
{
    auto& vm = globalObject->vm();
    auto* thisObject = jsCast<JSStats*>(JSValue::decode(thisValue));
    thisObject->m_atime.set(vm, thisObject, JSValue::decode(value));
}

extern "C" EncodedJSValue StatsPrototype__atimeGetCachedValue(JSC::EncodedJSValue thisValue)
{
    auto* thisObject = jsCast<JSStats*>(JSValue::decode(thisValue));
    return JSValue::encode(thisObject->m_atime.get());
}

JSC_DEFINE_CUSTOM_GETTER(StatsPrototype__atimeMsGetterWrap, (JSGlobalObject * lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    auto& vm = lexicalGlobalObject->vm();
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    JSStats* thisObject = jsCast<JSStats*>(JSValue::decode(thisValue));
    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);
    JSC::EncodedJSValue result = StatsPrototype__atimeMs(thisObject->wrapped(), globalObject);
    RETURN_IF_EXCEPTION(throwScope, {});
    RELEASE_AND_RETURN(throwScope, result);
}

JSC_DEFINE_CUSTOM_GETTER(StatsPrototype__birthtimeGetterWrap, (JSGlobalObject * lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    auto& vm = lexicalGlobalObject->vm();
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    JSStats* thisObject = jsCast<JSStats*>(JSValue::decode(thisValue));
    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);
    JSC::EncodedJSValue result = StatsPrototype__birthtime(thisObject->wrapped(), globalObject);
    RETURN_IF_EXCEPTION(throwScope, {});
    RELEASE_AND_RETURN(throwScope, result);
}

JSC_DEFINE_CUSTOM_GETTER(StatsPrototype__birthtimeMsGetterWrap, (JSGlobalObject * lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    auto& vm = lexicalGlobalObject->vm();
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    JSStats* thisObject = jsCast<JSStats*>(JSValue::decode(thisValue));
    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);
    JSC::EncodedJSValue result = StatsPrototype__birthtimeMs(thisObject->wrapped(), globalObject);
    RETURN_IF_EXCEPTION(throwScope, {});
    RELEASE_AND_RETURN(throwScope, result);
}

JSC_DEFINE_CUSTOM_GETTER(StatsPrototype__blksizeGetterWrap, (JSGlobalObject * lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    auto& vm = lexicalGlobalObject->vm();
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    JSStats* thisObject = jsCast<JSStats*>(JSValue::decode(thisValue));
    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);
    JSC::EncodedJSValue result = StatsPrototype__blksize(thisObject->wrapped(), globalObject);
    RETURN_IF_EXCEPTION(throwScope, {});
    RELEASE_AND_RETURN(throwScope, result);
}

JSC_DEFINE_CUSTOM_GETTER(StatsPrototype__blocksGetterWrap, (JSGlobalObject * lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    auto& vm = lexicalGlobalObject->vm();
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    JSStats* thisObject = jsCast<JSStats*>(JSValue::decode(thisValue));
    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);
    JSC::EncodedJSValue result = StatsPrototype__blocks(thisObject->wrapped(), globalObject);
    RETURN_IF_EXCEPTION(throwScope, {});
    RELEASE_AND_RETURN(throwScope, result);
}

JSC_DEFINE_CUSTOM_GETTER(StatsPrototype__ctimeGetterWrap, (JSGlobalObject * lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    auto& vm = lexicalGlobalObject->vm();
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    JSStats* thisObject = jsCast<JSStats*>(JSValue::decode(thisValue));
    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    if (JSValue cachedValue = thisObject->m_ctime.get())
        return JSValue::encode(cachedValue);

    JSC::JSValue result = JSC::JSValue::decode(
        StatsPrototype__ctime(thisObject->wrapped(), globalObject));
    RETURN_IF_EXCEPTION(throwScope, {});
    thisObject->m_ctime.set(vm, thisObject, result);
    RELEASE_AND_RETURN(throwScope, JSValue::encode(result));
}

extern "C" void StatsPrototype__ctimeSetCachedValue(JSC::EncodedJSValue thisValue, JSC::JSGlobalObject* globalObject, JSC::EncodedJSValue value)
{
    auto& vm = globalObject->vm();
    auto* thisObject = jsCast<JSStats*>(JSValue::decode(thisValue));
    thisObject->m_ctime.set(vm, thisObject, JSValue::decode(value));
}

extern "C" EncodedJSValue StatsPrototype__ctimeGetCachedValue(JSC::EncodedJSValue thisValue)
{
    auto* thisObject = jsCast<JSStats*>(JSValue::decode(thisValue));
    return JSValue::encode(thisObject->m_ctime.get());
}

JSC_DEFINE_CUSTOM_GETTER(StatsPrototype__ctimeMsGetterWrap, (JSGlobalObject * lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    auto& vm = lexicalGlobalObject->vm();
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    JSStats* thisObject = jsCast<JSStats*>(JSValue::decode(thisValue));
    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);
    JSC::EncodedJSValue result = StatsPrototype__ctimeMs(thisObject->wrapped(), globalObject);
    RETURN_IF_EXCEPTION(throwScope, {});
    RELEASE_AND_RETURN(throwScope, result);
}

JSC_DEFINE_CUSTOM_GETTER(StatsPrototype__devGetterWrap, (JSGlobalObject * lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    auto& vm = lexicalGlobalObject->vm();
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    JSStats* thisObject = jsCast<JSStats*>(JSValue::decode(thisValue));
    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);
    JSC::EncodedJSValue result = StatsPrototype__dev(thisObject->wrapped(), globalObject);
    RETURN_IF_EXCEPTION(throwScope, {});
    RELEASE_AND_RETURN(throwScope, result);
}

JSC_DEFINE_CUSTOM_GETTER(StatsPrototype__gidGetterWrap, (JSGlobalObject * lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    auto& vm = lexicalGlobalObject->vm();
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    JSStats* thisObject = jsCast<JSStats*>(JSValue::decode(thisValue));
    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);
    JSC::EncodedJSValue result = StatsPrototype__gid(thisObject->wrapped(), globalObject);
    RETURN_IF_EXCEPTION(throwScope, {});
    RELEASE_AND_RETURN(throwScope, result);
}

JSC_DEFINE_CUSTOM_GETTER(StatsPrototype__inoGetterWrap, (JSGlobalObject * lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    auto& vm = lexicalGlobalObject->vm();
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    JSStats* thisObject = jsCast<JSStats*>(JSValue::decode(thisValue));
    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);
    JSC::EncodedJSValue result = StatsPrototype__ino(thisObject->wrapped(), globalObject);
    RETURN_IF_EXCEPTION(throwScope, {});
    RELEASE_AND_RETURN(throwScope, result);
}

JSC_DEFINE_HOST_FUNCTION(StatsPrototype__isBlockDeviceCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSStats* thisObject = jsDynamicCast<JSStats*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return StatsPrototype__isBlockDevice_(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_HOST_FUNCTION(StatsPrototype__isCharacterDeviceCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSStats* thisObject = jsDynamicCast<JSStats*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return StatsPrototype__isCharacterDevice_(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_HOST_FUNCTION(StatsPrototype__isDirectoryCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSStats* thisObject = jsDynamicCast<JSStats*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return StatsPrototype__isDirectory_(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_HOST_FUNCTION(StatsPrototype__isFIFOCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSStats* thisObject = jsDynamicCast<JSStats*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return StatsPrototype__isFIFO_(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_HOST_FUNCTION(StatsPrototype__isFileCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSStats* thisObject = jsDynamicCast<JSStats*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return StatsPrototype__isFile_(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_HOST_FUNCTION(StatsPrototype__isSocketCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSStats* thisObject = jsDynamicCast<JSStats*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return StatsPrototype__isSocket_(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_HOST_FUNCTION(StatsPrototype__isSymbolicLinkCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSStats* thisObject = jsDynamicCast<JSStats*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return StatsPrototype__isSymbolicLink_(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_CUSTOM_GETTER(StatsPrototype__modeGetterWrap, (JSGlobalObject * lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    auto& vm = lexicalGlobalObject->vm();
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    JSStats* thisObject = jsCast<JSStats*>(JSValue::decode(thisValue));
    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);
    JSC::EncodedJSValue result = StatsPrototype__mode(thisObject->wrapped(), globalObject);
    RETURN_IF_EXCEPTION(throwScope, {});
    RELEASE_AND_RETURN(throwScope, result);
}

JSC_DEFINE_CUSTOM_GETTER(StatsPrototype__mtimeGetterWrap, (JSGlobalObject * lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    auto& vm = lexicalGlobalObject->vm();
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    JSStats* thisObject = jsCast<JSStats*>(JSValue::decode(thisValue));
    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    if (JSValue cachedValue = thisObject->m_mtime.get())
        return JSValue::encode(cachedValue);

    JSC::JSValue result = JSC::JSValue::decode(
        StatsPrototype__mtime(thisObject->wrapped(), globalObject));
    RETURN_IF_EXCEPTION(throwScope, {});
    thisObject->m_mtime.set(vm, thisObject, result);
    RELEASE_AND_RETURN(throwScope, JSValue::encode(result));
}

extern "C" void StatsPrototype__mtimeSetCachedValue(JSC::EncodedJSValue thisValue, JSC::JSGlobalObject* globalObject, JSC::EncodedJSValue value)
{
    auto& vm = globalObject->vm();
    auto* thisObject = jsCast<JSStats*>(JSValue::decode(thisValue));
    thisObject->m_mtime.set(vm, thisObject, JSValue::decode(value));
}

extern "C" EncodedJSValue StatsPrototype__mtimeGetCachedValue(JSC::EncodedJSValue thisValue)
{
    auto* thisObject = jsCast<JSStats*>(JSValue::decode(thisValue));
    return JSValue::encode(thisObject->m_mtime.get());
}

JSC_DEFINE_CUSTOM_GETTER(StatsPrototype__mtimeMsGetterWrap, (JSGlobalObject * lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    auto& vm = lexicalGlobalObject->vm();
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    JSStats* thisObject = jsCast<JSStats*>(JSValue::decode(thisValue));
    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);
    JSC::EncodedJSValue result = StatsPrototype__mtimeMs(thisObject->wrapped(), globalObject);
    RETURN_IF_EXCEPTION(throwScope, {});
    RELEASE_AND_RETURN(throwScope, result);
}

JSC_DEFINE_CUSTOM_GETTER(StatsPrototype__nlinkGetterWrap, (JSGlobalObject * lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    auto& vm = lexicalGlobalObject->vm();
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    JSStats* thisObject = jsCast<JSStats*>(JSValue::decode(thisValue));
    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);
    JSC::EncodedJSValue result = StatsPrototype__nlink(thisObject->wrapped(), globalObject);
    RETURN_IF_EXCEPTION(throwScope, {});
    RELEASE_AND_RETURN(throwScope, result);
}

JSC_DEFINE_CUSTOM_GETTER(StatsPrototype__rdevGetterWrap, (JSGlobalObject * lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    auto& vm = lexicalGlobalObject->vm();
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    JSStats* thisObject = jsCast<JSStats*>(JSValue::decode(thisValue));
    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);
    JSC::EncodedJSValue result = StatsPrototype__rdev(thisObject->wrapped(), globalObject);
    RETURN_IF_EXCEPTION(throwScope, {});
    RELEASE_AND_RETURN(throwScope, result);
}

JSC_DEFINE_CUSTOM_GETTER(StatsPrototype__sizeGetterWrap, (JSGlobalObject * lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    auto& vm = lexicalGlobalObject->vm();
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    JSStats* thisObject = jsCast<JSStats*>(JSValue::decode(thisValue));
    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);
    JSC::EncodedJSValue result = StatsPrototype__size(thisObject->wrapped(), globalObject);
    RETURN_IF_EXCEPTION(throwScope, {});
    RELEASE_AND_RETURN(throwScope, result);
}

JSC_DEFINE_CUSTOM_GETTER(StatsPrototype__uidGetterWrap, (JSGlobalObject * lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    auto& vm = lexicalGlobalObject->vm();
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    JSStats* thisObject = jsCast<JSStats*>(JSValue::decode(thisValue));
    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);
    JSC::EncodedJSValue result = StatsPrototype__uid(thisObject->wrapped(), globalObject);
    RETURN_IF_EXCEPTION(throwScope, {});
    RELEASE_AND_RETURN(throwScope, result);
}

void JSStatsPrototype::finishCreation(JSC::VM& vm, JSC::JSGlobalObject* globalObject)
{
    Base::finishCreation(vm);
    reifyStaticProperties(vm, JSStats::info(), JSStatsPrototypeTableValues, *this);
    JSC_TO_STRING_TAG_WITHOUT_TRANSITION();
}

void JSStatsConstructor::finishCreation(VM& vm, JSC::JSGlobalObject* globalObject, JSStatsPrototype* prototype)
{
    Base::finishCreation(vm, 0, "Stats"_s, PropertyAdditionMode::WithoutStructureTransition);

    putDirectWithoutTransition(vm, vm.propertyNames->prototype, prototype, PropertyAttribute::DontEnum | PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly);
    ASSERT(inherits(info()));
}

JSStatsConstructor::JSStatsConstructor(JSC::VM& vm, JSC::Structure* structure)
    : Base(vm, structure, construct, construct)
{
}

JSStatsConstructor* JSStatsConstructor::create(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure, JSStatsPrototype* prototype)
{
    JSStatsConstructor* ptr = new (NotNull, JSC::allocateCell<JSStatsConstructor>(vm)) JSStatsConstructor(vm, structure);
    ptr->finishCreation(vm, globalObject, prototype);
    return ptr;
}

JSC::EncodedJSValue JSC_HOST_CALL_ATTRIBUTES JSStatsConstructor::construct(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame)
{
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    JSC::VM& vm = globalObject->vm();
    JSObject* newTarget = asObject(callFrame->newTarget());
    auto* constructor = globalObject->JSStatsConstructor();
    Structure* structure = globalObject->JSStatsStructure();
    if (constructor != newTarget) {
        auto scope = DECLARE_THROW_SCOPE(vm);

        auto* functionGlobalObject = reinterpret_cast<Zig::GlobalObject*>(
            // ShadowRealm functions belong to a different global object.
            getFunctionRealm(globalObject, newTarget));
        RETURN_IF_EXCEPTION(scope, {});
        structure = InternalFunction::createSubclassStructure(
            globalObject,
            newTarget,
            functionGlobalObject->JSStatsStructure());
    }

    void* ptr = StatsClass__construct(globalObject, callFrame);

    if (UNLIKELY(!ptr)) {
        return JSValue::encode(JSC::jsUndefined());
    }

    JSStats* instance = JSStats::create(vm, globalObject, structure, ptr);

    return JSValue::encode(instance);
}

void JSStatsConstructor::initializeProperties(VM& vm, JSC::JSGlobalObject* globalObject, JSStatsPrototype* prototype)
{
}

const ClassInfo JSStatsConstructor::s_info = { "Function"_s, &Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSStatsConstructor) };

extern "C" EncodedJSValue Stats__getConstructor(Zig::GlobalObject* globalObject)
{
    return JSValue::encode(globalObject->JSStatsConstructor());
}

JSStats::~JSStats()
{
    if (m_ctx) {
        StatsClass__finalize(m_ctx);
    }
}
void JSStats::destroy(JSCell* cell)
{
    static_cast<JSStats*>(cell)->JSStats::~JSStats();
}

const ClassInfo JSStats::s_info = { "Stats"_s, &Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSStats) };

void JSStats::finishCreation(VM& vm)
{
    Base::finishCreation(vm);
    ASSERT(inherits(info()));
}

JSStats* JSStats::create(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure, void* ctx)
{
    JSStats* ptr = new (NotNull, JSC::allocateCell<JSStats>(vm)) JSStats(vm, structure, ctx);
    ptr->finishCreation(vm);
    return ptr;
}

extern "C" void* Stats__fromJS(JSC::EncodedJSValue value)
{
    JSC::JSValue decodedValue = JSC::JSValue::decode(value);
    if (decodedValue.isEmpty() || !decodedValue.isCell())
        return nullptr;

    JSC::JSCell* cell = decodedValue.asCell();
    JSStats* object = JSC::jsDynamicCast<JSStats*>(cell);

    if (!object)
        return nullptr;

    return object->wrapped();
}

extern "C" bool Stats__dangerouslySetPtr(JSC::EncodedJSValue value, void* ptr)
{
    JSStats* object = JSC::jsDynamicCast<JSStats*>(JSValue::decode(value));
    if (!object)
        return false;

    object->m_ctx = ptr;
    return true;
}

extern "C" const size_t Stats__ptrOffset = JSStats::offsetOfWrapped();

void JSStats::analyzeHeap(JSCell* cell, HeapAnalyzer& analyzer)
{
    auto* thisObject = jsCast<JSStats*>(cell);
    if (void* wrapped = thisObject->wrapped()) {
        // if (thisObject->scriptExecutionContext())
        //     analyzer.setLabelForCell(cell, "url " + thisObject->scriptExecutionContext()->url().string());
    }
    Base::analyzeHeap(cell, analyzer);
}

JSObject* JSStats::createConstructor(VM& vm, JSGlobalObject* globalObject, JSValue prototype)
{
    return WebCore::JSStatsConstructor::create(vm, globalObject, WebCore::JSStatsConstructor::createStructure(vm, globalObject, globalObject->functionPrototype()), jsCast<WebCore::JSStatsPrototype*>(prototype));
}

JSObject* JSStats::createPrototype(VM& vm, JSDOMGlobalObject* globalObject)
{
    return JSStatsPrototype::create(vm, globalObject, JSStatsPrototype::createStructure(vm, globalObject, globalObject->objectPrototype()));
}

extern "C" EncodedJSValue Stats__create(Zig::GlobalObject* globalObject, void* ptr)
{
    auto& vm = globalObject->vm();
    JSC::Structure* structure = globalObject->JSStatsStructure();
    JSStats* instance = JSStats::create(vm, globalObject, structure, ptr);

    return JSValue::encode(instance);
}

template<typename Visitor>
void JSStats::visitChildrenImpl(JSCell* cell, Visitor& visitor)
{
    JSStats* thisObject = jsCast<JSStats*>(cell);
    ASSERT_GC_OBJECT_INHERITS(thisObject, info());
    Base::visitChildren(thisObject, visitor);

    visitor.append(thisObject->m_atime);
    visitor.append(thisObject->m_ctime);
    visitor.append(thisObject->m_mtime);
}

DEFINE_VISIT_CHILDREN(JSStats);

template<typename Visitor>
void JSStats::visitAdditionalChildren(Visitor& visitor)
{
    JSStats* thisObject = this;
    ASSERT_GC_OBJECT_INHERITS(thisObject, info());

    visitor.append(thisObject->m_atime);
    visitor.append(thisObject->m_ctime);
    visitor.append(thisObject->m_mtime);
    ;
}

DEFINE_VISIT_ADDITIONAL_CHILDREN(JSStats);

template<typename Visitor>
void JSStats::visitOutputConstraintsImpl(JSCell* cell, Visitor& visitor)
{
    JSStats* thisObject = jsCast<JSStats*>(cell);
    ASSERT_GC_OBJECT_INHERITS(thisObject, info());
    thisObject->visitAdditionalChildren<Visitor>(visitor);
}

DEFINE_VISIT_OUTPUT_CONSTRAINTS(JSStats);
class JSSubprocessPrototype final : public JSC::JSNonFinalObject {
public:
    using Base = JSC::JSNonFinalObject;

    static JSSubprocessPrototype* create(JSC::VM& vm, JSGlobalObject* globalObject, JSC::Structure* structure)
    {
        JSSubprocessPrototype* ptr = new (NotNull, JSC::allocateCell<JSSubprocessPrototype>(vm)) JSSubprocessPrototype(vm, globalObject, structure);
        ptr->finishCreation(vm, globalObject);
        return ptr;
    }

    DECLARE_INFO;
    template<typename CellType, JSC::SubspaceAccess>
    static JSC::GCClient::IsoSubspace* subspaceFor(JSC::VM& vm)
    {
        return &vm.plainObjectSpace();
    }
    static JSC::Structure* createStructure(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::JSValue prototype)
    {
        return JSC::Structure::create(vm, globalObject, prototype, JSC::TypeInfo(JSC::ObjectType, StructureFlags), info());
    }

private:
    JSSubprocessPrototype(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure)
        : Base(vm, structure)
    {
    }

    void finishCreation(JSC::VM&, JSC::JSGlobalObject*);
};

extern "C" void* SubprocessClass__construct(JSC::JSGlobalObject*, JSC::CallFrame*);
JSC_DECLARE_CUSTOM_GETTER(jsSubprocessConstructor);
extern "C" void SubprocessClass__finalize(void*);

extern "C" JSC::EncodedJSValue SubprocessPrototype__getExitCode(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject);
JSC_DECLARE_CUSTOM_GETTER(SubprocessPrototype__exitCodeGetterWrap);

extern "C" JSC::EncodedJSValue SubprocessPrototype__getExited(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject);
JSC_DECLARE_CUSTOM_GETTER(SubprocessPrototype__exitedGetterWrap);

extern "C" EncodedJSValue SubprocessPrototype__kill(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(SubprocessPrototype__killCallback);

extern "C" JSC::EncodedJSValue SubprocessPrototype__getKilled(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject);
JSC_DECLARE_CUSTOM_GETTER(SubprocessPrototype__killedGetterWrap);

extern "C" JSC::EncodedJSValue SubprocessPrototype__getPid(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject);
JSC_DECLARE_CUSTOM_GETTER(SubprocessPrototype__pidGetterWrap);

extern "C" JSC::EncodedJSValue SubprocessPrototype__getStdout(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject);
JSC_DECLARE_CUSTOM_GETTER(SubprocessPrototype__readableGetterWrap);

extern "C" EncodedJSValue SubprocessPrototype__doRef(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(SubprocessPrototype__refCallback);

extern "C" JSC::EncodedJSValue SubprocessPrototype__getSignalCode(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject);
JSC_DECLARE_CUSTOM_GETTER(SubprocessPrototype__signalCodeGetterWrap);

extern "C" JSC::EncodedJSValue SubprocessPrototype__getStderr(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject);
JSC_DECLARE_CUSTOM_GETTER(SubprocessPrototype__stderrGetterWrap);

extern "C" JSC::EncodedJSValue SubprocessPrototype__getStdin(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject);
JSC_DECLARE_CUSTOM_GETTER(SubprocessPrototype__stdinGetterWrap);

extern "C" JSC::EncodedJSValue SubprocessPrototype__getStdout(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject);
JSC_DECLARE_CUSTOM_GETTER(SubprocessPrototype__stdoutGetterWrap);

extern "C" EncodedJSValue SubprocessPrototype__doUnref(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(SubprocessPrototype__unrefCallback);

extern "C" JSC::EncodedJSValue SubprocessPrototype__getStdin(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject);
JSC_DECLARE_CUSTOM_GETTER(SubprocessPrototype__writableGetterWrap);

STATIC_ASSERT_ISO_SUBSPACE_SHARABLE(JSSubprocessPrototype, JSSubprocessPrototype::Base);

static const HashTableValue JSSubprocessPrototypeTableValues[] = {
    { "exitCode"_s, static_cast<unsigned>(JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::GetterSetterType, SubprocessPrototype__exitCodeGetterWrap, 0 } },
    { "exited"_s, static_cast<unsigned>(JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::GetterSetterType, SubprocessPrototype__exitedGetterWrap, 0 } },
    { "kill"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, SubprocessPrototype__killCallback, 1 } },
    { "killed"_s, static_cast<unsigned>(JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::GetterSetterType, SubprocessPrototype__killedGetterWrap, 0 } },
    { "pid"_s, static_cast<unsigned>(JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::GetterSetterType, SubprocessPrototype__pidGetterWrap, 0 } },
    { "readable"_s, static_cast<unsigned>(JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::GetterSetterType, SubprocessPrototype__readableGetterWrap, 0 } },
    { "ref"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, SubprocessPrototype__refCallback, 0 } },
    { "signalCode"_s, static_cast<unsigned>(JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::GetterSetterType, SubprocessPrototype__signalCodeGetterWrap, 0 } },
    { "stderr"_s, static_cast<unsigned>(JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::GetterSetterType, SubprocessPrototype__stderrGetterWrap, 0 } },
    { "stdin"_s, static_cast<unsigned>(JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::GetterSetterType, SubprocessPrototype__stdinGetterWrap, 0 } },
    { "stdout"_s, static_cast<unsigned>(JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::GetterSetterType, SubprocessPrototype__stdoutGetterWrap, 0 } },
    { "unref"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, SubprocessPrototype__unrefCallback, 0 } },
    { "writable"_s, static_cast<unsigned>(JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::GetterSetterType, SubprocessPrototype__writableGetterWrap, 0 } }
};

const ClassInfo JSSubprocessPrototype::s_info = { "Subprocess"_s, &Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSSubprocessPrototype) };

JSC_DEFINE_CUSTOM_GETTER(jsSubprocessConstructor, (JSGlobalObject * lexicalGlobalObject, EncodedJSValue thisValue, PropertyName))
{
    VM& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    auto* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    auto* prototype = jsDynamicCast<JSSubprocessPrototype*>(JSValue::decode(thisValue));

    if (UNLIKELY(!prototype))
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    return JSValue::encode(globalObject->JSSubprocessConstructor());
}

JSC_DEFINE_CUSTOM_GETTER(SubprocessPrototype__exitCodeGetterWrap, (JSGlobalObject * lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    auto& vm = lexicalGlobalObject->vm();
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    JSSubprocess* thisObject = jsCast<JSSubprocess*>(JSValue::decode(thisValue));
    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);
    JSC::EncodedJSValue result = SubprocessPrototype__getExitCode(thisObject->wrapped(), globalObject);
    RETURN_IF_EXCEPTION(throwScope, {});
    RELEASE_AND_RETURN(throwScope, result);
}

JSC_DEFINE_CUSTOM_GETTER(SubprocessPrototype__exitedGetterWrap, (JSGlobalObject * lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    auto& vm = lexicalGlobalObject->vm();
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    JSSubprocess* thisObject = jsCast<JSSubprocess*>(JSValue::decode(thisValue));
    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);
    JSC::EncodedJSValue result = SubprocessPrototype__getExited(thisObject->wrapped(), globalObject);
    RETURN_IF_EXCEPTION(throwScope, {});
    RELEASE_AND_RETURN(throwScope, result);
}

JSC_DEFINE_HOST_FUNCTION(SubprocessPrototype__killCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSSubprocess* thisObject = jsDynamicCast<JSSubprocess*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return SubprocessPrototype__kill(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_CUSTOM_GETTER(SubprocessPrototype__killedGetterWrap, (JSGlobalObject * lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    auto& vm = lexicalGlobalObject->vm();
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    JSSubprocess* thisObject = jsCast<JSSubprocess*>(JSValue::decode(thisValue));
    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);
    JSC::EncodedJSValue result = SubprocessPrototype__getKilled(thisObject->wrapped(), globalObject);
    RETURN_IF_EXCEPTION(throwScope, {});
    RELEASE_AND_RETURN(throwScope, result);
}

JSC_DEFINE_CUSTOM_GETTER(SubprocessPrototype__pidGetterWrap, (JSGlobalObject * lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    auto& vm = lexicalGlobalObject->vm();
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    JSSubprocess* thisObject = jsCast<JSSubprocess*>(JSValue::decode(thisValue));
    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);
    JSC::EncodedJSValue result = SubprocessPrototype__getPid(thisObject->wrapped(), globalObject);
    RETURN_IF_EXCEPTION(throwScope, {});
    RELEASE_AND_RETURN(throwScope, result);
}

JSC_DEFINE_CUSTOM_GETTER(SubprocessPrototype__readableGetterWrap, (JSGlobalObject * lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    auto& vm = lexicalGlobalObject->vm();
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    JSSubprocess* thisObject = jsCast<JSSubprocess*>(JSValue::decode(thisValue));
    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    if (JSValue cachedValue = thisObject->m_stdout.get())
        return JSValue::encode(cachedValue);

    JSC::JSValue result = JSC::JSValue::decode(
        SubprocessPrototype__getStdout(thisObject->wrapped(), globalObject));
    RETURN_IF_EXCEPTION(throwScope, {});
    thisObject->m_stdout.set(vm, thisObject, result);
    RELEASE_AND_RETURN(throwScope, JSValue::encode(result));
}

extern "C" void SubprocessPrototype__readableSetCachedValue(JSC::EncodedJSValue thisValue, JSC::JSGlobalObject* globalObject, JSC::EncodedJSValue value)
{
    auto& vm = globalObject->vm();
    auto* thisObject = jsCast<JSSubprocess*>(JSValue::decode(thisValue));
    thisObject->m_stdout.set(vm, thisObject, JSValue::decode(value));
}

extern "C" EncodedJSValue SubprocessPrototype__readableGetCachedValue(JSC::EncodedJSValue thisValue)
{
    auto* thisObject = jsCast<JSSubprocess*>(JSValue::decode(thisValue));
    return JSValue::encode(thisObject->m_stdout.get());
}

JSC_DEFINE_HOST_FUNCTION(SubprocessPrototype__refCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSSubprocess* thisObject = jsDynamicCast<JSSubprocess*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return SubprocessPrototype__doRef(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_CUSTOM_GETTER(SubprocessPrototype__signalCodeGetterWrap, (JSGlobalObject * lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    auto& vm = lexicalGlobalObject->vm();
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    JSSubprocess* thisObject = jsCast<JSSubprocess*>(JSValue::decode(thisValue));
    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);
    JSC::EncodedJSValue result = SubprocessPrototype__getSignalCode(thisObject->wrapped(), globalObject);
    RETURN_IF_EXCEPTION(throwScope, {});
    RELEASE_AND_RETURN(throwScope, result);
}

JSC_DEFINE_CUSTOM_GETTER(SubprocessPrototype__stderrGetterWrap, (JSGlobalObject * lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    auto& vm = lexicalGlobalObject->vm();
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    JSSubprocess* thisObject = jsCast<JSSubprocess*>(JSValue::decode(thisValue));
    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    if (JSValue cachedValue = thisObject->m_stderr.get())
        return JSValue::encode(cachedValue);

    JSC::JSValue result = JSC::JSValue::decode(
        SubprocessPrototype__getStderr(thisObject->wrapped(), globalObject));
    RETURN_IF_EXCEPTION(throwScope, {});
    thisObject->m_stderr.set(vm, thisObject, result);
    RELEASE_AND_RETURN(throwScope, JSValue::encode(result));
}

extern "C" void SubprocessPrototype__stderrSetCachedValue(JSC::EncodedJSValue thisValue, JSC::JSGlobalObject* globalObject, JSC::EncodedJSValue value)
{
    auto& vm = globalObject->vm();
    auto* thisObject = jsCast<JSSubprocess*>(JSValue::decode(thisValue));
    thisObject->m_stderr.set(vm, thisObject, JSValue::decode(value));
}

extern "C" EncodedJSValue SubprocessPrototype__stderrGetCachedValue(JSC::EncodedJSValue thisValue)
{
    auto* thisObject = jsCast<JSSubprocess*>(JSValue::decode(thisValue));
    return JSValue::encode(thisObject->m_stderr.get());
}

JSC_DEFINE_CUSTOM_GETTER(SubprocessPrototype__stdinGetterWrap, (JSGlobalObject * lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    auto& vm = lexicalGlobalObject->vm();
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    JSSubprocess* thisObject = jsCast<JSSubprocess*>(JSValue::decode(thisValue));
    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    if (JSValue cachedValue = thisObject->m_stdin.get())
        return JSValue::encode(cachedValue);

    JSC::JSValue result = JSC::JSValue::decode(
        SubprocessPrototype__getStdin(thisObject->wrapped(), globalObject));
    RETURN_IF_EXCEPTION(throwScope, {});
    thisObject->m_stdin.set(vm, thisObject, result);
    RELEASE_AND_RETURN(throwScope, JSValue::encode(result));
}

extern "C" void SubprocessPrototype__stdinSetCachedValue(JSC::EncodedJSValue thisValue, JSC::JSGlobalObject* globalObject, JSC::EncodedJSValue value)
{
    auto& vm = globalObject->vm();
    auto* thisObject = jsCast<JSSubprocess*>(JSValue::decode(thisValue));
    thisObject->m_stdin.set(vm, thisObject, JSValue::decode(value));
}

extern "C" EncodedJSValue SubprocessPrototype__stdinGetCachedValue(JSC::EncodedJSValue thisValue)
{
    auto* thisObject = jsCast<JSSubprocess*>(JSValue::decode(thisValue));
    return JSValue::encode(thisObject->m_stdin.get());
}

JSC_DEFINE_CUSTOM_GETTER(SubprocessPrototype__stdoutGetterWrap, (JSGlobalObject * lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    auto& vm = lexicalGlobalObject->vm();
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    JSSubprocess* thisObject = jsCast<JSSubprocess*>(JSValue::decode(thisValue));
    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    if (JSValue cachedValue = thisObject->m_stdout.get())
        return JSValue::encode(cachedValue);

    JSC::JSValue result = JSC::JSValue::decode(
        SubprocessPrototype__getStdout(thisObject->wrapped(), globalObject));
    RETURN_IF_EXCEPTION(throwScope, {});
    thisObject->m_stdout.set(vm, thisObject, result);
    RELEASE_AND_RETURN(throwScope, JSValue::encode(result));
}

extern "C" void SubprocessPrototype__stdoutSetCachedValue(JSC::EncodedJSValue thisValue, JSC::JSGlobalObject* globalObject, JSC::EncodedJSValue value)
{
    auto& vm = globalObject->vm();
    auto* thisObject = jsCast<JSSubprocess*>(JSValue::decode(thisValue));
    thisObject->m_stdout.set(vm, thisObject, JSValue::decode(value));
}

extern "C" EncodedJSValue SubprocessPrototype__stdoutGetCachedValue(JSC::EncodedJSValue thisValue)
{
    auto* thisObject = jsCast<JSSubprocess*>(JSValue::decode(thisValue));
    return JSValue::encode(thisObject->m_stdout.get());
}

JSC_DEFINE_HOST_FUNCTION(SubprocessPrototype__unrefCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSSubprocess* thisObject = jsDynamicCast<JSSubprocess*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return SubprocessPrototype__doUnref(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_CUSTOM_GETTER(SubprocessPrototype__writableGetterWrap, (JSGlobalObject * lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    auto& vm = lexicalGlobalObject->vm();
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    JSSubprocess* thisObject = jsCast<JSSubprocess*>(JSValue::decode(thisValue));
    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    if (JSValue cachedValue = thisObject->m_stdin.get())
        return JSValue::encode(cachedValue);

    JSC::JSValue result = JSC::JSValue::decode(
        SubprocessPrototype__getStdin(thisObject->wrapped(), globalObject));
    RETURN_IF_EXCEPTION(throwScope, {});
    thisObject->m_stdin.set(vm, thisObject, result);
    RELEASE_AND_RETURN(throwScope, JSValue::encode(result));
}

extern "C" void SubprocessPrototype__writableSetCachedValue(JSC::EncodedJSValue thisValue, JSC::JSGlobalObject* globalObject, JSC::EncodedJSValue value)
{
    auto& vm = globalObject->vm();
    auto* thisObject = jsCast<JSSubprocess*>(JSValue::decode(thisValue));
    thisObject->m_stdin.set(vm, thisObject, JSValue::decode(value));
}

extern "C" EncodedJSValue SubprocessPrototype__writableGetCachedValue(JSC::EncodedJSValue thisValue)
{
    auto* thisObject = jsCast<JSSubprocess*>(JSValue::decode(thisValue));
    return JSValue::encode(thisObject->m_stdin.get());
}

void JSSubprocessPrototype::finishCreation(JSC::VM& vm, JSC::JSGlobalObject* globalObject)
{
    Base::finishCreation(vm);
    reifyStaticProperties(vm, JSSubprocess::info(), JSSubprocessPrototypeTableValues, *this);
    JSC_TO_STRING_TAG_WITHOUT_TRANSITION();
}

extern "C" bool Subprocess__hasPendingActivity(void* ptr);
bool JSSubprocess::hasPendingActivity(void* ctx)
{
    return Subprocess__hasPendingActivity(ctx);
}

JSSubprocess::~JSSubprocess()
{
    if (m_ctx) {
        SubprocessClass__finalize(m_ctx);
    }
}
void JSSubprocess::destroy(JSCell* cell)
{
    static_cast<JSSubprocess*>(cell)->JSSubprocess::~JSSubprocess();
}

const ClassInfo JSSubprocess::s_info = { "Subprocess"_s, &Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSSubprocess) };

void JSSubprocess::finishCreation(VM& vm)
{
    Base::finishCreation(vm);
    ASSERT(inherits(info()));
}

JSSubprocess* JSSubprocess::create(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure, void* ctx)
{
    JSSubprocess* ptr = new (NotNull, JSC::allocateCell<JSSubprocess>(vm)) JSSubprocess(vm, structure, ctx);
    ptr->finishCreation(vm);
    return ptr;
}

extern "C" void* Subprocess__fromJS(JSC::EncodedJSValue value)
{
    JSC::JSValue decodedValue = JSC::JSValue::decode(value);
    if (decodedValue.isEmpty() || !decodedValue.isCell())
        return nullptr;

    JSC::JSCell* cell = decodedValue.asCell();
    JSSubprocess* object = JSC::jsDynamicCast<JSSubprocess*>(cell);

    if (!object)
        return nullptr;

    return object->wrapped();
}

extern "C" bool Subprocess__dangerouslySetPtr(JSC::EncodedJSValue value, void* ptr)
{
    JSSubprocess* object = JSC::jsDynamicCast<JSSubprocess*>(JSValue::decode(value));
    if (!object)
        return false;

    object->m_ctx = ptr;
    return true;
}

extern "C" const size_t Subprocess__ptrOffset = JSSubprocess::offsetOfWrapped();

void JSSubprocess::analyzeHeap(JSCell* cell, HeapAnalyzer& analyzer)
{
    auto* thisObject = jsCast<JSSubprocess*>(cell);
    if (void* wrapped = thisObject->wrapped()) {
        // if (thisObject->scriptExecutionContext())
        //     analyzer.setLabelForCell(cell, "url " + thisObject->scriptExecutionContext()->url().string());
    }
    Base::analyzeHeap(cell, analyzer);
}

JSObject* JSSubprocess::createPrototype(VM& vm, JSDOMGlobalObject* globalObject)
{
    return JSSubprocessPrototype::create(vm, globalObject, JSSubprocessPrototype::createStructure(vm, globalObject, globalObject->objectPrototype()));
}

extern "C" EncodedJSValue Subprocess__create(Zig::GlobalObject* globalObject, void* ptr)
{
    auto& vm = globalObject->vm();
    JSC::Structure* structure = globalObject->JSSubprocessStructure();
    JSSubprocess* instance = JSSubprocess::create(vm, globalObject, structure, ptr);

    return JSValue::encode(instance);
}

template<typename Visitor>
void JSSubprocess::visitChildrenImpl(JSCell* cell, Visitor& visitor)
{
    JSSubprocess* thisObject = jsCast<JSSubprocess*>(cell);
    ASSERT_GC_OBJECT_INHERITS(thisObject, info());
    Base::visitChildren(thisObject, visitor);

    visitor.append(thisObject->m_stderr);
    visitor.append(thisObject->m_stdin);
    visitor.append(thisObject->m_stdout);
    visitor.addOpaqueRoot(thisObject->wrapped());
}

DEFINE_VISIT_CHILDREN(JSSubprocess);

template<typename Visitor>
void JSSubprocess::visitAdditionalChildren(Visitor& visitor)
{
    JSSubprocess* thisObject = this;
    ASSERT_GC_OBJECT_INHERITS(thisObject, info());

    visitor.append(thisObject->m_stderr);
    visitor.append(thisObject->m_stdin);
    visitor.append(thisObject->m_stdout);
    visitor.addOpaqueRoot(this->wrapped());
}

DEFINE_VISIT_ADDITIONAL_CHILDREN(JSSubprocess);

template<typename Visitor>
void JSSubprocess::visitOutputConstraintsImpl(JSCell* cell, Visitor& visitor)
{
    JSSubprocess* thisObject = jsCast<JSSubprocess*>(cell);
    ASSERT_GC_OBJECT_INHERITS(thisObject, info());
    thisObject->visitAdditionalChildren<Visitor>(visitor);
}

DEFINE_VISIT_OUTPUT_CONSTRAINTS(JSSubprocess);
class JSTCPSocketPrototype final : public JSC::JSNonFinalObject {
public:
    using Base = JSC::JSNonFinalObject;

    static JSTCPSocketPrototype* create(JSC::VM& vm, JSGlobalObject* globalObject, JSC::Structure* structure)
    {
        JSTCPSocketPrototype* ptr = new (NotNull, JSC::allocateCell<JSTCPSocketPrototype>(vm)) JSTCPSocketPrototype(vm, globalObject, structure);
        ptr->finishCreation(vm, globalObject);
        return ptr;
    }

    DECLARE_INFO;
    template<typename CellType, JSC::SubspaceAccess>
    static JSC::GCClient::IsoSubspace* subspaceFor(JSC::VM& vm)
    {
        return &vm.plainObjectSpace();
    }
    static JSC::Structure* createStructure(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::JSValue prototype)
    {
        return JSC::Structure::create(vm, globalObject, prototype, JSC::TypeInfo(JSC::ObjectType, StructureFlags), info());
    }

private:
    JSTCPSocketPrototype(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure)
        : Base(vm, structure)
    {
    }

    void finishCreation(JSC::VM&, JSC::JSGlobalObject*);
};

extern "C" void* TCPSocketClass__construct(JSC::JSGlobalObject*, JSC::CallFrame*);
JSC_DECLARE_CUSTOM_GETTER(jsTCPSocketConstructor);
extern "C" void TCPSocketClass__finalize(void*);

extern "C" JSC::EncodedJSValue TCPSocketPrototype__getAuthorized(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject);
JSC_DECLARE_CUSTOM_GETTER(TCPSocketPrototype__authorizedGetterWrap);

extern "C" JSC::EncodedJSValue TCPSocketPrototype__getData(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject);
JSC_DECLARE_CUSTOM_GETTER(TCPSocketPrototype__dataGetterWrap);

extern "C" bool TCPSocketPrototype__setData(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::EncodedJSValue value);
JSC_DECLARE_CUSTOM_SETTER(TCPSocketPrototype__dataSetterWrap);

extern "C" EncodedJSValue TCPSocketPrototype__end(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(TCPSocketPrototype__endCallback);

extern "C" EncodedJSValue TCPSocketPrototype__flush(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(TCPSocketPrototype__flushCallback);

extern "C" EncodedJSValue TCPSocketPrototype__getAuthorizationError(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(TCPSocketPrototype__getAuthorizationErrorCallback);

extern "C" JSC::EncodedJSValue TCPSocketPrototype__getListener(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject);
JSC_DECLARE_CUSTOM_GETTER(TCPSocketPrototype__listenerGetterWrap);

extern "C" JSC::EncodedJSValue TCPSocketPrototype__getLocalPort(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject);
JSC_DECLARE_CUSTOM_GETTER(TCPSocketPrototype__localPortGetterWrap);

extern "C" JSC::EncodedJSValue TCPSocketPrototype__getReadyState(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject);
JSC_DECLARE_CUSTOM_GETTER(TCPSocketPrototype__readyStateGetterWrap);

extern "C" EncodedJSValue TCPSocketPrototype__ref(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(TCPSocketPrototype__refCallback);

extern "C" EncodedJSValue TCPSocketPrototype__reload(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(TCPSocketPrototype__reloadCallback);

extern "C" JSC::EncodedJSValue TCPSocketPrototype__getRemoteAddress(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject);
JSC_DECLARE_CUSTOM_GETTER(TCPSocketPrototype__remoteAddressGetterWrap);

extern "C" EncodedJSValue TCPSocketPrototype__shutdown(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(TCPSocketPrototype__shutdownCallback);

extern "C" EncodedJSValue TCPSocketPrototype__timeout(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(TCPSocketPrototype__timeoutCallback);

extern "C" EncodedJSValue TCPSocketPrototype__unref(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(TCPSocketPrototype__unrefCallback);

extern "C" EncodedJSValue TCPSocketPrototype__write(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(TCPSocketPrototype__writeCallback);

STATIC_ASSERT_ISO_SUBSPACE_SHARABLE(JSTCPSocketPrototype, JSTCPSocketPrototype::Base);

static const HashTableValue JSTCPSocketPrototypeTableValues[] = {
    { "authorized"_s, static_cast<unsigned>(JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::GetterSetterType, TCPSocketPrototype__authorizedGetterWrap, 0 } },
    { "data"_s, static_cast<unsigned>(JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::GetterSetterType, TCPSocketPrototype__dataGetterWrap, TCPSocketPrototype__dataSetterWrap } },
    { "end"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, TCPSocketPrototype__endCallback, 3 } },
    { "flush"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, TCPSocketPrototype__flushCallback, 0 } },
    { "getAuthorizationError"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, TCPSocketPrototype__getAuthorizationErrorCallback, 0 } },
    { "listener"_s, static_cast<unsigned>(JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::GetterSetterType, TCPSocketPrototype__listenerGetterWrap, 0 } },
    { "localPort"_s, static_cast<unsigned>(JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::GetterSetterType, TCPSocketPrototype__localPortGetterWrap, 0 } },
    { "readyState"_s, static_cast<unsigned>(JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::GetterSetterType, TCPSocketPrototype__readyStateGetterWrap, 0 } },
    { "ref"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, TCPSocketPrototype__refCallback, 0 } },
    { "reload"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, TCPSocketPrototype__reloadCallback, 1 } },
    { "remoteAddress"_s, static_cast<unsigned>(JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::GetterSetterType, TCPSocketPrototype__remoteAddressGetterWrap, 0 } },
    { "shutdown"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, TCPSocketPrototype__shutdownCallback, 1 } },
    { "timeout"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, TCPSocketPrototype__timeoutCallback, 1 } },
    { "unref"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, TCPSocketPrototype__unrefCallback, 0 } },
    { "write"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, TCPSocketPrototype__writeCallback, 3 } }
};

const ClassInfo JSTCPSocketPrototype::s_info = { "TCPSocket"_s, &Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSTCPSocketPrototype) };

JSC_DEFINE_CUSTOM_GETTER(jsTCPSocketConstructor, (JSGlobalObject * lexicalGlobalObject, EncodedJSValue thisValue, PropertyName))
{
    VM& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    auto* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    auto* prototype = jsDynamicCast<JSTCPSocketPrototype*>(JSValue::decode(thisValue));

    if (UNLIKELY(!prototype))
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    return JSValue::encode(globalObject->JSTCPSocketConstructor());
}

JSC_DEFINE_CUSTOM_GETTER(TCPSocketPrototype__authorizedGetterWrap, (JSGlobalObject * lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    auto& vm = lexicalGlobalObject->vm();
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    JSTCPSocket* thisObject = jsCast<JSTCPSocket*>(JSValue::decode(thisValue));
    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);
    JSC::EncodedJSValue result = TCPSocketPrototype__getAuthorized(thisObject->wrapped(), globalObject);
    RETURN_IF_EXCEPTION(throwScope, {});
    RELEASE_AND_RETURN(throwScope, result);
}

JSC_DEFINE_CUSTOM_GETTER(TCPSocketPrototype__dataGetterWrap, (JSGlobalObject * lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    auto& vm = lexicalGlobalObject->vm();
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    JSTCPSocket* thisObject = jsCast<JSTCPSocket*>(JSValue::decode(thisValue));
    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    if (JSValue cachedValue = thisObject->m_data.get())
        return JSValue::encode(cachedValue);

    JSC::JSValue result = JSC::JSValue::decode(
        TCPSocketPrototype__getData(thisObject->wrapped(), globalObject));
    RETURN_IF_EXCEPTION(throwScope, {});
    thisObject->m_data.set(vm, thisObject, result);
    RELEASE_AND_RETURN(throwScope, JSValue::encode(result));
}

extern "C" void TCPSocketPrototype__dataSetCachedValue(JSC::EncodedJSValue thisValue, JSC::JSGlobalObject* globalObject, JSC::EncodedJSValue value)
{
    auto& vm = globalObject->vm();
    auto* thisObject = jsCast<JSTCPSocket*>(JSValue::decode(thisValue));
    thisObject->m_data.set(vm, thisObject, JSValue::decode(value));
}

extern "C" EncodedJSValue TCPSocketPrototype__dataGetCachedValue(JSC::EncodedJSValue thisValue)
{
    auto* thisObject = jsCast<JSTCPSocket*>(JSValue::decode(thisValue));
    return JSValue::encode(thisObject->m_data.get());
}

JSC_DEFINE_CUSTOM_SETTER(TCPSocketPrototype__dataSetterWrap, (JSGlobalObject * lexicalGlobalObject, EncodedJSValue thisValue, EncodedJSValue encodedValue, PropertyName attributeName))
{
    auto& vm = lexicalGlobalObject->vm();
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    JSTCPSocket* thisObject = jsCast<JSTCPSocket*>(JSValue::decode(thisValue));
    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);
    auto result = TCPSocketPrototype__setData(thisObject->wrapped(), lexicalGlobalObject, encodedValue);

    RELEASE_AND_RETURN(throwScope, result);
}

JSC_DEFINE_HOST_FUNCTION(TCPSocketPrototype__endCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSTCPSocket* thisObject = jsDynamicCast<JSTCPSocket*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return TCPSocketPrototype__end(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_HOST_FUNCTION(TCPSocketPrototype__flushCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSTCPSocket* thisObject = jsDynamicCast<JSTCPSocket*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return TCPSocketPrototype__flush(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_HOST_FUNCTION(TCPSocketPrototype__getAuthorizationErrorCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSTCPSocket* thisObject = jsDynamicCast<JSTCPSocket*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return TCPSocketPrototype__getAuthorizationError(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_CUSTOM_GETTER(TCPSocketPrototype__listenerGetterWrap, (JSGlobalObject * lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    auto& vm = lexicalGlobalObject->vm();
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    JSTCPSocket* thisObject = jsCast<JSTCPSocket*>(JSValue::decode(thisValue));
    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);
    JSC::EncodedJSValue result = TCPSocketPrototype__getListener(thisObject->wrapped(), globalObject);
    RETURN_IF_EXCEPTION(throwScope, {});
    RELEASE_AND_RETURN(throwScope, result);
}

JSC_DEFINE_CUSTOM_GETTER(TCPSocketPrototype__localPortGetterWrap, (JSGlobalObject * lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    auto& vm = lexicalGlobalObject->vm();
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    JSTCPSocket* thisObject = jsCast<JSTCPSocket*>(JSValue::decode(thisValue));
    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);
    JSC::EncodedJSValue result = TCPSocketPrototype__getLocalPort(thisObject->wrapped(), globalObject);
    RETURN_IF_EXCEPTION(throwScope, {});
    RELEASE_AND_RETURN(throwScope, result);
}

JSC_DEFINE_CUSTOM_GETTER(TCPSocketPrototype__readyStateGetterWrap, (JSGlobalObject * lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    auto& vm = lexicalGlobalObject->vm();
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    JSTCPSocket* thisObject = jsCast<JSTCPSocket*>(JSValue::decode(thisValue));
    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);
    JSC::EncodedJSValue result = TCPSocketPrototype__getReadyState(thisObject->wrapped(), globalObject);
    RETURN_IF_EXCEPTION(throwScope, {});
    RELEASE_AND_RETURN(throwScope, result);
}

JSC_DEFINE_HOST_FUNCTION(TCPSocketPrototype__refCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSTCPSocket* thisObject = jsDynamicCast<JSTCPSocket*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return TCPSocketPrototype__ref(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_HOST_FUNCTION(TCPSocketPrototype__reloadCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSTCPSocket* thisObject = jsDynamicCast<JSTCPSocket*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return TCPSocketPrototype__reload(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_CUSTOM_GETTER(TCPSocketPrototype__remoteAddressGetterWrap, (JSGlobalObject * lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    auto& vm = lexicalGlobalObject->vm();
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    JSTCPSocket* thisObject = jsCast<JSTCPSocket*>(JSValue::decode(thisValue));
    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    if (JSValue cachedValue = thisObject->m_remoteAddress.get())
        return JSValue::encode(cachedValue);

    JSC::JSValue result = JSC::JSValue::decode(
        TCPSocketPrototype__getRemoteAddress(thisObject->wrapped(), globalObject));
    RETURN_IF_EXCEPTION(throwScope, {});
    thisObject->m_remoteAddress.set(vm, thisObject, result);
    RELEASE_AND_RETURN(throwScope, JSValue::encode(result));
}

extern "C" void TCPSocketPrototype__remoteAddressSetCachedValue(JSC::EncodedJSValue thisValue, JSC::JSGlobalObject* globalObject, JSC::EncodedJSValue value)
{
    auto& vm = globalObject->vm();
    auto* thisObject = jsCast<JSTCPSocket*>(JSValue::decode(thisValue));
    thisObject->m_remoteAddress.set(vm, thisObject, JSValue::decode(value));
}

extern "C" EncodedJSValue TCPSocketPrototype__remoteAddressGetCachedValue(JSC::EncodedJSValue thisValue)
{
    auto* thisObject = jsCast<JSTCPSocket*>(JSValue::decode(thisValue));
    return JSValue::encode(thisObject->m_remoteAddress.get());
}

JSC_DEFINE_HOST_FUNCTION(TCPSocketPrototype__shutdownCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSTCPSocket* thisObject = jsDynamicCast<JSTCPSocket*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return TCPSocketPrototype__shutdown(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_HOST_FUNCTION(TCPSocketPrototype__timeoutCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSTCPSocket* thisObject = jsDynamicCast<JSTCPSocket*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return TCPSocketPrototype__timeout(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_HOST_FUNCTION(TCPSocketPrototype__unrefCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSTCPSocket* thisObject = jsDynamicCast<JSTCPSocket*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return TCPSocketPrototype__unref(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_HOST_FUNCTION(TCPSocketPrototype__writeCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSTCPSocket* thisObject = jsDynamicCast<JSTCPSocket*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return TCPSocketPrototype__write(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

void JSTCPSocketPrototype::finishCreation(JSC::VM& vm, JSC::JSGlobalObject* globalObject)
{
    Base::finishCreation(vm);
    reifyStaticProperties(vm, JSTCPSocket::info(), JSTCPSocketPrototypeTableValues, *this);
    JSC_TO_STRING_TAG_WITHOUT_TRANSITION();
}

extern "C" bool TCPSocket__hasPendingActivity(void* ptr);
bool JSTCPSocket::hasPendingActivity(void* ctx)
{
    return TCPSocket__hasPendingActivity(ctx);
}

JSTCPSocket::~JSTCPSocket()
{
    if (m_ctx) {
        TCPSocketClass__finalize(m_ctx);
    }
}
void JSTCPSocket::destroy(JSCell* cell)
{
    static_cast<JSTCPSocket*>(cell)->JSTCPSocket::~JSTCPSocket();
}

const ClassInfo JSTCPSocket::s_info = { "TCPSocket"_s, &Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSTCPSocket) };

void JSTCPSocket::finishCreation(VM& vm)
{
    Base::finishCreation(vm);
    ASSERT(inherits(info()));
}

JSTCPSocket* JSTCPSocket::create(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure, void* ctx)
{
    JSTCPSocket* ptr = new (NotNull, JSC::allocateCell<JSTCPSocket>(vm)) JSTCPSocket(vm, structure, ctx);
    ptr->finishCreation(vm);
    return ptr;
}

extern "C" void* TCPSocket__fromJS(JSC::EncodedJSValue value)
{
    JSC::JSValue decodedValue = JSC::JSValue::decode(value);
    if (decodedValue.isEmpty() || !decodedValue.isCell())
        return nullptr;

    JSC::JSCell* cell = decodedValue.asCell();
    JSTCPSocket* object = JSC::jsDynamicCast<JSTCPSocket*>(cell);

    if (!object)
        return nullptr;

    return object->wrapped();
}

extern "C" bool TCPSocket__dangerouslySetPtr(JSC::EncodedJSValue value, void* ptr)
{
    JSTCPSocket* object = JSC::jsDynamicCast<JSTCPSocket*>(JSValue::decode(value));
    if (!object)
        return false;

    object->m_ctx = ptr;
    return true;
}

extern "C" const size_t TCPSocket__ptrOffset = JSTCPSocket::offsetOfWrapped();

void JSTCPSocket::analyzeHeap(JSCell* cell, HeapAnalyzer& analyzer)
{
    auto* thisObject = jsCast<JSTCPSocket*>(cell);
    if (void* wrapped = thisObject->wrapped()) {
        // if (thisObject->scriptExecutionContext())
        //     analyzer.setLabelForCell(cell, "url " + thisObject->scriptExecutionContext()->url().string());
    }
    Base::analyzeHeap(cell, analyzer);
}

JSObject* JSTCPSocket::createPrototype(VM& vm, JSDOMGlobalObject* globalObject)
{
    return JSTCPSocketPrototype::create(vm, globalObject, JSTCPSocketPrototype::createStructure(vm, globalObject, globalObject->objectPrototype()));
}

extern "C" EncodedJSValue TCPSocket__create(Zig::GlobalObject* globalObject, void* ptr)
{
    auto& vm = globalObject->vm();
    JSC::Structure* structure = globalObject->JSTCPSocketStructure();
    JSTCPSocket* instance = JSTCPSocket::create(vm, globalObject, structure, ptr);

    return JSValue::encode(instance);
}

template<typename Visitor>
void JSTCPSocket::visitChildrenImpl(JSCell* cell, Visitor& visitor)
{
    JSTCPSocket* thisObject = jsCast<JSTCPSocket*>(cell);
    ASSERT_GC_OBJECT_INHERITS(thisObject, info());
    Base::visitChildren(thisObject, visitor);

    visitor.append(thisObject->m_data);
    visitor.append(thisObject->m_remoteAddress);
    visitor.addOpaqueRoot(thisObject->wrapped());
}

DEFINE_VISIT_CHILDREN(JSTCPSocket);

template<typename Visitor>
void JSTCPSocket::visitAdditionalChildren(Visitor& visitor)
{
    JSTCPSocket* thisObject = this;
    ASSERT_GC_OBJECT_INHERITS(thisObject, info());

    visitor.append(thisObject->m_data);
    visitor.append(thisObject->m_remoteAddress);
    visitor.addOpaqueRoot(this->wrapped());
}

DEFINE_VISIT_ADDITIONAL_CHILDREN(JSTCPSocket);

template<typename Visitor>
void JSTCPSocket::visitOutputConstraintsImpl(JSCell* cell, Visitor& visitor)
{
    JSTCPSocket* thisObject = jsCast<JSTCPSocket*>(cell);
    ASSERT_GC_OBJECT_INHERITS(thisObject, info());
    thisObject->visitAdditionalChildren<Visitor>(visitor);
}

DEFINE_VISIT_OUTPUT_CONSTRAINTS(JSTCPSocket);
class JSTLSSocketPrototype final : public JSC::JSNonFinalObject {
public:
    using Base = JSC::JSNonFinalObject;

    static JSTLSSocketPrototype* create(JSC::VM& vm, JSGlobalObject* globalObject, JSC::Structure* structure)
    {
        JSTLSSocketPrototype* ptr = new (NotNull, JSC::allocateCell<JSTLSSocketPrototype>(vm)) JSTLSSocketPrototype(vm, globalObject, structure);
        ptr->finishCreation(vm, globalObject);
        return ptr;
    }

    DECLARE_INFO;
    template<typename CellType, JSC::SubspaceAccess>
    static JSC::GCClient::IsoSubspace* subspaceFor(JSC::VM& vm)
    {
        return &vm.plainObjectSpace();
    }
    static JSC::Structure* createStructure(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::JSValue prototype)
    {
        return JSC::Structure::create(vm, globalObject, prototype, JSC::TypeInfo(JSC::ObjectType, StructureFlags), info());
    }

private:
    JSTLSSocketPrototype(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure)
        : Base(vm, structure)
    {
    }

    void finishCreation(JSC::VM&, JSC::JSGlobalObject*);
};

extern "C" void* TLSSocketClass__construct(JSC::JSGlobalObject*, JSC::CallFrame*);
JSC_DECLARE_CUSTOM_GETTER(jsTLSSocketConstructor);
extern "C" void TLSSocketClass__finalize(void*);

extern "C" JSC::EncodedJSValue TLSSocketPrototype__getAuthorized(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject);
JSC_DECLARE_CUSTOM_GETTER(TLSSocketPrototype__authorizedGetterWrap);

extern "C" JSC::EncodedJSValue TLSSocketPrototype__getData(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject);
JSC_DECLARE_CUSTOM_GETTER(TLSSocketPrototype__dataGetterWrap);

extern "C" bool TLSSocketPrototype__setData(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::EncodedJSValue value);
JSC_DECLARE_CUSTOM_SETTER(TLSSocketPrototype__dataSetterWrap);

extern "C" EncodedJSValue TLSSocketPrototype__end(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(TLSSocketPrototype__endCallback);

extern "C" EncodedJSValue TLSSocketPrototype__flush(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(TLSSocketPrototype__flushCallback);

extern "C" EncodedJSValue TLSSocketPrototype__getAuthorizationError(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(TLSSocketPrototype__getAuthorizationErrorCallback);

extern "C" JSC::EncodedJSValue TLSSocketPrototype__getListener(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject);
JSC_DECLARE_CUSTOM_GETTER(TLSSocketPrototype__listenerGetterWrap);

extern "C" JSC::EncodedJSValue TLSSocketPrototype__getLocalPort(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject);
JSC_DECLARE_CUSTOM_GETTER(TLSSocketPrototype__localPortGetterWrap);

extern "C" JSC::EncodedJSValue TLSSocketPrototype__getReadyState(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject);
JSC_DECLARE_CUSTOM_GETTER(TLSSocketPrototype__readyStateGetterWrap);

extern "C" EncodedJSValue TLSSocketPrototype__ref(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(TLSSocketPrototype__refCallback);

extern "C" EncodedJSValue TLSSocketPrototype__reload(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(TLSSocketPrototype__reloadCallback);

extern "C" JSC::EncodedJSValue TLSSocketPrototype__getRemoteAddress(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject);
JSC_DECLARE_CUSTOM_GETTER(TLSSocketPrototype__remoteAddressGetterWrap);

extern "C" EncodedJSValue TLSSocketPrototype__shutdown(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(TLSSocketPrototype__shutdownCallback);

extern "C" EncodedJSValue TLSSocketPrototype__timeout(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(TLSSocketPrototype__timeoutCallback);

extern "C" EncodedJSValue TLSSocketPrototype__unref(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(TLSSocketPrototype__unrefCallback);

extern "C" EncodedJSValue TLSSocketPrototype__write(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(TLSSocketPrototype__writeCallback);

STATIC_ASSERT_ISO_SUBSPACE_SHARABLE(JSTLSSocketPrototype, JSTLSSocketPrototype::Base);

static const HashTableValue JSTLSSocketPrototypeTableValues[] = {
    { "authorized"_s, static_cast<unsigned>(JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::GetterSetterType, TLSSocketPrototype__authorizedGetterWrap, 0 } },
    { "data"_s, static_cast<unsigned>(JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::GetterSetterType, TLSSocketPrototype__dataGetterWrap, TLSSocketPrototype__dataSetterWrap } },
    { "end"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, TLSSocketPrototype__endCallback, 3 } },
    { "flush"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, TLSSocketPrototype__flushCallback, 0 } },
    { "getAuthorizationError"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, TLSSocketPrototype__getAuthorizationErrorCallback, 0 } },
    { "listener"_s, static_cast<unsigned>(JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::GetterSetterType, TLSSocketPrototype__listenerGetterWrap, 0 } },
    { "localPort"_s, static_cast<unsigned>(JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::GetterSetterType, TLSSocketPrototype__localPortGetterWrap, 0 } },
    { "readyState"_s, static_cast<unsigned>(JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::GetterSetterType, TLSSocketPrototype__readyStateGetterWrap, 0 } },
    { "ref"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, TLSSocketPrototype__refCallback, 0 } },
    { "reload"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, TLSSocketPrototype__reloadCallback, 1 } },
    { "remoteAddress"_s, static_cast<unsigned>(JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::GetterSetterType, TLSSocketPrototype__remoteAddressGetterWrap, 0 } },
    { "shutdown"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, TLSSocketPrototype__shutdownCallback, 1 } },
    { "timeout"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, TLSSocketPrototype__timeoutCallback, 1 } },
    { "unref"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, TLSSocketPrototype__unrefCallback, 0 } },
    { "write"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, TLSSocketPrototype__writeCallback, 3 } }
};

const ClassInfo JSTLSSocketPrototype::s_info = { "TLSSocket"_s, &Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSTLSSocketPrototype) };

JSC_DEFINE_CUSTOM_GETTER(jsTLSSocketConstructor, (JSGlobalObject * lexicalGlobalObject, EncodedJSValue thisValue, PropertyName))
{
    VM& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    auto* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    auto* prototype = jsDynamicCast<JSTLSSocketPrototype*>(JSValue::decode(thisValue));

    if (UNLIKELY(!prototype))
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    return JSValue::encode(globalObject->JSTLSSocketConstructor());
}

JSC_DEFINE_CUSTOM_GETTER(TLSSocketPrototype__authorizedGetterWrap, (JSGlobalObject * lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    auto& vm = lexicalGlobalObject->vm();
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    JSTLSSocket* thisObject = jsCast<JSTLSSocket*>(JSValue::decode(thisValue));
    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);
    JSC::EncodedJSValue result = TLSSocketPrototype__getAuthorized(thisObject->wrapped(), globalObject);
    RETURN_IF_EXCEPTION(throwScope, {});
    RELEASE_AND_RETURN(throwScope, result);
}

JSC_DEFINE_CUSTOM_GETTER(TLSSocketPrototype__dataGetterWrap, (JSGlobalObject * lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    auto& vm = lexicalGlobalObject->vm();
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    JSTLSSocket* thisObject = jsCast<JSTLSSocket*>(JSValue::decode(thisValue));
    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    if (JSValue cachedValue = thisObject->m_data.get())
        return JSValue::encode(cachedValue);

    JSC::JSValue result = JSC::JSValue::decode(
        TLSSocketPrototype__getData(thisObject->wrapped(), globalObject));
    RETURN_IF_EXCEPTION(throwScope, {});
    thisObject->m_data.set(vm, thisObject, result);
    RELEASE_AND_RETURN(throwScope, JSValue::encode(result));
}

extern "C" void TLSSocketPrototype__dataSetCachedValue(JSC::EncodedJSValue thisValue, JSC::JSGlobalObject* globalObject, JSC::EncodedJSValue value)
{
    auto& vm = globalObject->vm();
    auto* thisObject = jsCast<JSTLSSocket*>(JSValue::decode(thisValue));
    thisObject->m_data.set(vm, thisObject, JSValue::decode(value));
}

extern "C" EncodedJSValue TLSSocketPrototype__dataGetCachedValue(JSC::EncodedJSValue thisValue)
{
    auto* thisObject = jsCast<JSTLSSocket*>(JSValue::decode(thisValue));
    return JSValue::encode(thisObject->m_data.get());
}

JSC_DEFINE_CUSTOM_SETTER(TLSSocketPrototype__dataSetterWrap, (JSGlobalObject * lexicalGlobalObject, EncodedJSValue thisValue, EncodedJSValue encodedValue, PropertyName attributeName))
{
    auto& vm = lexicalGlobalObject->vm();
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    JSTLSSocket* thisObject = jsCast<JSTLSSocket*>(JSValue::decode(thisValue));
    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);
    auto result = TLSSocketPrototype__setData(thisObject->wrapped(), lexicalGlobalObject, encodedValue);

    RELEASE_AND_RETURN(throwScope, result);
}

JSC_DEFINE_HOST_FUNCTION(TLSSocketPrototype__endCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSTLSSocket* thisObject = jsDynamicCast<JSTLSSocket*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return TLSSocketPrototype__end(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_HOST_FUNCTION(TLSSocketPrototype__flushCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSTLSSocket* thisObject = jsDynamicCast<JSTLSSocket*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return TLSSocketPrototype__flush(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_HOST_FUNCTION(TLSSocketPrototype__getAuthorizationErrorCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSTLSSocket* thisObject = jsDynamicCast<JSTLSSocket*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return TLSSocketPrototype__getAuthorizationError(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_CUSTOM_GETTER(TLSSocketPrototype__listenerGetterWrap, (JSGlobalObject * lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    auto& vm = lexicalGlobalObject->vm();
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    JSTLSSocket* thisObject = jsCast<JSTLSSocket*>(JSValue::decode(thisValue));
    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);
    JSC::EncodedJSValue result = TLSSocketPrototype__getListener(thisObject->wrapped(), globalObject);
    RETURN_IF_EXCEPTION(throwScope, {});
    RELEASE_AND_RETURN(throwScope, result);
}

JSC_DEFINE_CUSTOM_GETTER(TLSSocketPrototype__localPortGetterWrap, (JSGlobalObject * lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    auto& vm = lexicalGlobalObject->vm();
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    JSTLSSocket* thisObject = jsCast<JSTLSSocket*>(JSValue::decode(thisValue));
    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);
    JSC::EncodedJSValue result = TLSSocketPrototype__getLocalPort(thisObject->wrapped(), globalObject);
    RETURN_IF_EXCEPTION(throwScope, {});
    RELEASE_AND_RETURN(throwScope, result);
}

JSC_DEFINE_CUSTOM_GETTER(TLSSocketPrototype__readyStateGetterWrap, (JSGlobalObject * lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    auto& vm = lexicalGlobalObject->vm();
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    JSTLSSocket* thisObject = jsCast<JSTLSSocket*>(JSValue::decode(thisValue));
    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);
    JSC::EncodedJSValue result = TLSSocketPrototype__getReadyState(thisObject->wrapped(), globalObject);
    RETURN_IF_EXCEPTION(throwScope, {});
    RELEASE_AND_RETURN(throwScope, result);
}

JSC_DEFINE_HOST_FUNCTION(TLSSocketPrototype__refCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSTLSSocket* thisObject = jsDynamicCast<JSTLSSocket*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return TLSSocketPrototype__ref(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_HOST_FUNCTION(TLSSocketPrototype__reloadCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSTLSSocket* thisObject = jsDynamicCast<JSTLSSocket*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return TLSSocketPrototype__reload(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_CUSTOM_GETTER(TLSSocketPrototype__remoteAddressGetterWrap, (JSGlobalObject * lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    auto& vm = lexicalGlobalObject->vm();
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    JSTLSSocket* thisObject = jsCast<JSTLSSocket*>(JSValue::decode(thisValue));
    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    if (JSValue cachedValue = thisObject->m_remoteAddress.get())
        return JSValue::encode(cachedValue);

    JSC::JSValue result = JSC::JSValue::decode(
        TLSSocketPrototype__getRemoteAddress(thisObject->wrapped(), globalObject));
    RETURN_IF_EXCEPTION(throwScope, {});
    thisObject->m_remoteAddress.set(vm, thisObject, result);
    RELEASE_AND_RETURN(throwScope, JSValue::encode(result));
}

extern "C" void TLSSocketPrototype__remoteAddressSetCachedValue(JSC::EncodedJSValue thisValue, JSC::JSGlobalObject* globalObject, JSC::EncodedJSValue value)
{
    auto& vm = globalObject->vm();
    auto* thisObject = jsCast<JSTLSSocket*>(JSValue::decode(thisValue));
    thisObject->m_remoteAddress.set(vm, thisObject, JSValue::decode(value));
}

extern "C" EncodedJSValue TLSSocketPrototype__remoteAddressGetCachedValue(JSC::EncodedJSValue thisValue)
{
    auto* thisObject = jsCast<JSTLSSocket*>(JSValue::decode(thisValue));
    return JSValue::encode(thisObject->m_remoteAddress.get());
}

JSC_DEFINE_HOST_FUNCTION(TLSSocketPrototype__shutdownCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSTLSSocket* thisObject = jsDynamicCast<JSTLSSocket*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return TLSSocketPrototype__shutdown(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_HOST_FUNCTION(TLSSocketPrototype__timeoutCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSTLSSocket* thisObject = jsDynamicCast<JSTLSSocket*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return TLSSocketPrototype__timeout(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_HOST_FUNCTION(TLSSocketPrototype__unrefCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSTLSSocket* thisObject = jsDynamicCast<JSTLSSocket*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return TLSSocketPrototype__unref(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_HOST_FUNCTION(TLSSocketPrototype__writeCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSTLSSocket* thisObject = jsDynamicCast<JSTLSSocket*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return TLSSocketPrototype__write(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

void JSTLSSocketPrototype::finishCreation(JSC::VM& vm, JSC::JSGlobalObject* globalObject)
{
    Base::finishCreation(vm);
    reifyStaticProperties(vm, JSTLSSocket::info(), JSTLSSocketPrototypeTableValues, *this);
    JSC_TO_STRING_TAG_WITHOUT_TRANSITION();
}

extern "C" bool TLSSocket__hasPendingActivity(void* ptr);
bool JSTLSSocket::hasPendingActivity(void* ctx)
{
    return TLSSocket__hasPendingActivity(ctx);
}

JSTLSSocket::~JSTLSSocket()
{
    if (m_ctx) {
        TLSSocketClass__finalize(m_ctx);
    }
}
void JSTLSSocket::destroy(JSCell* cell)
{
    static_cast<JSTLSSocket*>(cell)->JSTLSSocket::~JSTLSSocket();
}

const ClassInfo JSTLSSocket::s_info = { "TLSSocket"_s, &Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSTLSSocket) };

void JSTLSSocket::finishCreation(VM& vm)
{
    Base::finishCreation(vm);
    ASSERT(inherits(info()));
}

JSTLSSocket* JSTLSSocket::create(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure, void* ctx)
{
    JSTLSSocket* ptr = new (NotNull, JSC::allocateCell<JSTLSSocket>(vm)) JSTLSSocket(vm, structure, ctx);
    ptr->finishCreation(vm);
    return ptr;
}

extern "C" void* TLSSocket__fromJS(JSC::EncodedJSValue value)
{
    JSC::JSValue decodedValue = JSC::JSValue::decode(value);
    if (decodedValue.isEmpty() || !decodedValue.isCell())
        return nullptr;

    JSC::JSCell* cell = decodedValue.asCell();
    JSTLSSocket* object = JSC::jsDynamicCast<JSTLSSocket*>(cell);

    if (!object)
        return nullptr;

    return object->wrapped();
}

extern "C" bool TLSSocket__dangerouslySetPtr(JSC::EncodedJSValue value, void* ptr)
{
    JSTLSSocket* object = JSC::jsDynamicCast<JSTLSSocket*>(JSValue::decode(value));
    if (!object)
        return false;

    object->m_ctx = ptr;
    return true;
}

extern "C" const size_t TLSSocket__ptrOffset = JSTLSSocket::offsetOfWrapped();

void JSTLSSocket::analyzeHeap(JSCell* cell, HeapAnalyzer& analyzer)
{
    auto* thisObject = jsCast<JSTLSSocket*>(cell);
    if (void* wrapped = thisObject->wrapped()) {
        // if (thisObject->scriptExecutionContext())
        //     analyzer.setLabelForCell(cell, "url " + thisObject->scriptExecutionContext()->url().string());
    }
    Base::analyzeHeap(cell, analyzer);
}

JSObject* JSTLSSocket::createPrototype(VM& vm, JSDOMGlobalObject* globalObject)
{
    return JSTLSSocketPrototype::create(vm, globalObject, JSTLSSocketPrototype::createStructure(vm, globalObject, globalObject->objectPrototype()));
}

extern "C" EncodedJSValue TLSSocket__create(Zig::GlobalObject* globalObject, void* ptr)
{
    auto& vm = globalObject->vm();
    JSC::Structure* structure = globalObject->JSTLSSocketStructure();
    JSTLSSocket* instance = JSTLSSocket::create(vm, globalObject, structure, ptr);

    return JSValue::encode(instance);
}

template<typename Visitor>
void JSTLSSocket::visitChildrenImpl(JSCell* cell, Visitor& visitor)
{
    JSTLSSocket* thisObject = jsCast<JSTLSSocket*>(cell);
    ASSERT_GC_OBJECT_INHERITS(thisObject, info());
    Base::visitChildren(thisObject, visitor);

    visitor.append(thisObject->m_data);
    visitor.append(thisObject->m_remoteAddress);
    visitor.addOpaqueRoot(thisObject->wrapped());
}

DEFINE_VISIT_CHILDREN(JSTLSSocket);

template<typename Visitor>
void JSTLSSocket::visitAdditionalChildren(Visitor& visitor)
{
    JSTLSSocket* thisObject = this;
    ASSERT_GC_OBJECT_INHERITS(thisObject, info());

    visitor.append(thisObject->m_data);
    visitor.append(thisObject->m_remoteAddress);
    visitor.addOpaqueRoot(this->wrapped());
}

DEFINE_VISIT_ADDITIONAL_CHILDREN(JSTLSSocket);

template<typename Visitor>
void JSTLSSocket::visitOutputConstraintsImpl(JSCell* cell, Visitor& visitor)
{
    JSTLSSocket* thisObject = jsCast<JSTLSSocket*>(cell);
    ASSERT_GC_OBJECT_INHERITS(thisObject, info());
    thisObject->visitAdditionalChildren<Visitor>(visitor);
}

DEFINE_VISIT_OUTPUT_CONSTRAINTS(JSTLSSocket);
class JSTextDecoderPrototype final : public JSC::JSNonFinalObject {
public:
    using Base = JSC::JSNonFinalObject;

    static JSTextDecoderPrototype* create(JSC::VM& vm, JSGlobalObject* globalObject, JSC::Structure* structure)
    {
        JSTextDecoderPrototype* ptr = new (NotNull, JSC::allocateCell<JSTextDecoderPrototype>(vm)) JSTextDecoderPrototype(vm, globalObject, structure);
        ptr->finishCreation(vm, globalObject);
        return ptr;
    }

    DECLARE_INFO;
    template<typename CellType, JSC::SubspaceAccess>
    static JSC::GCClient::IsoSubspace* subspaceFor(JSC::VM& vm)
    {
        return &vm.plainObjectSpace();
    }
    static JSC::Structure* createStructure(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::JSValue prototype)
    {
        return JSC::Structure::create(vm, globalObject, prototype, JSC::TypeInfo(JSC::ObjectType, StructureFlags), info());
    }

private:
    JSTextDecoderPrototype(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure)
        : Base(vm, structure)
    {
    }

    void finishCreation(JSC::VM&, JSC::JSGlobalObject*);
};

class JSTextDecoderConstructor final : public JSC::InternalFunction {
public:
    using Base = JSC::InternalFunction;
    static JSTextDecoderConstructor* create(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure, JSTextDecoderPrototype* prototype);

    static constexpr unsigned StructureFlags = Base::StructureFlags;
    static constexpr bool needsDestruction = false;

    static JSC::Structure* createStructure(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::JSValue prototype)
    {
        return JSC::Structure::create(vm, globalObject, prototype, JSC::TypeInfo(JSC::InternalFunctionType, StructureFlags), info());
    }

    template<typename, JSC::SubspaceAccess mode> static JSC::GCClient::IsoSubspace* subspaceFor(JSC::VM& vm)
    {
        if constexpr (mode == JSC::SubspaceAccess::Concurrently)
            return nullptr;
        return WebCore::subspaceForImpl<JSTextDecoderConstructor, WebCore::UseCustomHeapCellType::No>(
            vm,
            [](auto& spaces) { return spaces.m_clientSubspaceForTextDecoderConstructor.get(); },
            [](auto& spaces, auto&& space) { spaces.m_clientSubspaceForTextDecoderConstructor = std::forward<decltype(space)>(space); },
            [](auto& spaces) { return spaces.m_subspaceForTextDecoderConstructor.get(); },
            [](auto& spaces, auto&& space) { spaces.m_subspaceForTextDecoderConstructor = std::forward<decltype(space)>(space); });
    }

    void initializeProperties(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSTextDecoderPrototype* prototype);

    // Must be defined for each specialization class.
    static JSC::EncodedJSValue JSC_HOST_CALL_ATTRIBUTES construct(JSC::JSGlobalObject*, JSC::CallFrame*);

    DECLARE_EXPORT_INFO;

private:
    JSTextDecoderConstructor(JSC::VM& vm, JSC::Structure* structure);
    void finishCreation(JSC::VM&, JSC::JSGlobalObject* globalObject, JSTextDecoderPrototype* prototype);
};

extern "C" void* TextDecoderClass__construct(JSC::JSGlobalObject*, JSC::CallFrame*);
JSC_DECLARE_CUSTOM_GETTER(jsTextDecoderConstructor);
extern "C" void TextDecoderClass__finalize(void*);

extern "C" EncodedJSValue TextDecoderPrototype__decode(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(TextDecoderPrototype__decodeCallback);

extern "C" JSC_DECLARE_JIT_OPERATION_WITHOUT_WTF_INTERNAL(TextDecoderPrototype__decodeWithoutTypeChecksWrapper, EncodedJSValue, (JSC::JSGlobalObject * lexicalGlobalObject, void* thisValue, JSC::JSUint8Array* arg0));
extern "C" EncodedJSValue TextDecoderPrototype__decodeWithoutTypeChecks(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::JSUint8Array* arg0);

static const JSC::DOMJIT::Signature DOMJITSignatureForTextDecoderPrototype__decode(TextDecoderPrototype__decodeWithoutTypeChecksWrapper,
    JSTextDecoder::info(),
    JSC::DOMJIT::Effect::forReadWrite(JSC::DOMJIT::HeapRange::top(), JSC::DOMJIT::HeapRange::top()),
    JSC::SpecString, JSC::SpecUint8Array);

JSC_DEFINE_JIT_OPERATION(TextDecoderPrototype__decodeWithoutTypeChecksWrapper, EncodedJSValue, (JSC::JSGlobalObject * lexicalGlobalObject, void* thisValue, JSC::JSUint8Array* arg0))
{
    VM& vm = JSC::getVM(lexicalGlobalObject);
    IGNORE_WARNINGS_BEGIN("frame-address")
    CallFrame* callFrame = DECLARE_CALL_FRAME(vm);
    IGNORE_WARNINGS_END
    JSC::JITOperationPrologueCallFrameTracer tracer(vm, callFrame);
    return TextDecoderPrototype__decodeWithoutTypeChecks(reinterpret_cast<JSTextDecoder*>(thisValue)->wrapped(), lexicalGlobalObject, arg0);
}

extern "C" JSC::EncodedJSValue TextDecoderPrototype__getEncoding(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject);
JSC_DECLARE_CUSTOM_GETTER(TextDecoderPrototype__encodingGetterWrap);

extern "C" JSC::EncodedJSValue TextDecoderPrototype__getFatal(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject);
JSC_DECLARE_CUSTOM_GETTER(TextDecoderPrototype__fatalGetterWrap);

STATIC_ASSERT_ISO_SUBSPACE_SHARABLE(JSTextDecoderPrototype, JSTextDecoderPrototype::Base);

static const HashTableValue JSTextDecoderPrototypeTableValues[] = {
    { "decode"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | JSC::PropertyAttribute::DOMJITFunction | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::DOMJITFunctionType, TextDecoderPrototype__decodeCallback, &DOMJITSignatureForTextDecoderPrototype__decode } },
    { "encoding"_s, static_cast<unsigned>(JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::GetterSetterType, TextDecoderPrototype__encodingGetterWrap, 0 } },
    { "fatal"_s, static_cast<unsigned>(JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DOMAttribute | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::GetterSetterType, TextDecoderPrototype__fatalGetterWrap, 0 } }
};

const ClassInfo JSTextDecoderPrototype::s_info = { "TextDecoder"_s, &Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSTextDecoderPrototype) };

JSC_DEFINE_CUSTOM_GETTER(jsTextDecoderConstructor, (JSGlobalObject * lexicalGlobalObject, EncodedJSValue thisValue, PropertyName))
{
    VM& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    auto* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    auto* prototype = jsDynamicCast<JSTextDecoderPrototype*>(JSValue::decode(thisValue));

    if (UNLIKELY(!prototype))
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    return JSValue::encode(globalObject->JSTextDecoderConstructor());
}

JSC_DEFINE_HOST_FUNCTION(TextDecoderPrototype__decodeCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSTextDecoder* thisObject = jsDynamicCast<JSTextDecoder*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return TextDecoderPrototype__decode(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_CUSTOM_GETTER(TextDecoderPrototype__encodingGetterWrap, (JSGlobalObject * lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    auto& vm = lexicalGlobalObject->vm();
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    JSTextDecoder* thisObject = jsCast<JSTextDecoder*>(JSValue::decode(thisValue));
    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    if (JSValue cachedValue = thisObject->m_encoding.get())
        return JSValue::encode(cachedValue);

    JSC::JSValue result = JSC::JSValue::decode(
        TextDecoderPrototype__getEncoding(thisObject->wrapped(), globalObject));
    RETURN_IF_EXCEPTION(throwScope, {});
    thisObject->m_encoding.set(vm, thisObject, result);
    RELEASE_AND_RETURN(throwScope, JSValue::encode(result));
}

extern "C" void TextDecoderPrototype__encodingSetCachedValue(JSC::EncodedJSValue thisValue, JSC::JSGlobalObject* globalObject, JSC::EncodedJSValue value)
{
    auto& vm = globalObject->vm();
    auto* thisObject = jsCast<JSTextDecoder*>(JSValue::decode(thisValue));
    thisObject->m_encoding.set(vm, thisObject, JSValue::decode(value));
}

extern "C" EncodedJSValue TextDecoderPrototype__encodingGetCachedValue(JSC::EncodedJSValue thisValue)
{
    auto* thisObject = jsCast<JSTextDecoder*>(JSValue::decode(thisValue));
    return JSValue::encode(thisObject->m_encoding.get());
}

JSC_DEFINE_CUSTOM_GETTER(TextDecoderPrototype__fatalGetterWrap, (JSGlobalObject * lexicalGlobalObject, EncodedJSValue thisValue, PropertyName attributeName))
{
    auto& vm = lexicalGlobalObject->vm();
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    JSTextDecoder* thisObject = jsCast<JSTextDecoder*>(JSValue::decode(thisValue));
    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);
    JSC::EncodedJSValue result = TextDecoderPrototype__getFatal(thisObject->wrapped(), globalObject);
    RETURN_IF_EXCEPTION(throwScope, {});
    RELEASE_AND_RETURN(throwScope, result);
}

void JSTextDecoderPrototype::finishCreation(JSC::VM& vm, JSC::JSGlobalObject* globalObject)
{
    Base::finishCreation(vm);
    reifyStaticProperties(vm, JSTextDecoder::info(), JSTextDecoderPrototypeTableValues, *this);
    JSC_TO_STRING_TAG_WITHOUT_TRANSITION();
}

void JSTextDecoderConstructor::finishCreation(VM& vm, JSC::JSGlobalObject* globalObject, JSTextDecoderPrototype* prototype)
{
    Base::finishCreation(vm, 0, "TextDecoder"_s, PropertyAdditionMode::WithoutStructureTransition);

    putDirectWithoutTransition(vm, vm.propertyNames->prototype, prototype, PropertyAttribute::DontEnum | PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly);
    ASSERT(inherits(info()));
}

JSTextDecoderConstructor::JSTextDecoderConstructor(JSC::VM& vm, JSC::Structure* structure)
    : Base(vm, structure, construct, construct)
{
}

JSTextDecoderConstructor* JSTextDecoderConstructor::create(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure, JSTextDecoderPrototype* prototype)
{
    JSTextDecoderConstructor* ptr = new (NotNull, JSC::allocateCell<JSTextDecoderConstructor>(vm)) JSTextDecoderConstructor(vm, structure);
    ptr->finishCreation(vm, globalObject, prototype);
    return ptr;
}

JSC::EncodedJSValue JSC_HOST_CALL_ATTRIBUTES JSTextDecoderConstructor::construct(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame)
{
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    JSC::VM& vm = globalObject->vm();
    JSObject* newTarget = asObject(callFrame->newTarget());
    auto* constructor = globalObject->JSTextDecoderConstructor();
    Structure* structure = globalObject->JSTextDecoderStructure();
    if (constructor != newTarget) {
        auto scope = DECLARE_THROW_SCOPE(vm);

        auto* functionGlobalObject = reinterpret_cast<Zig::GlobalObject*>(
            // ShadowRealm functions belong to a different global object.
            getFunctionRealm(globalObject, newTarget));
        RETURN_IF_EXCEPTION(scope, {});
        structure = InternalFunction::createSubclassStructure(
            globalObject,
            newTarget,
            functionGlobalObject->JSTextDecoderStructure());
    }

    void* ptr = TextDecoderClass__construct(globalObject, callFrame);

    if (UNLIKELY(!ptr)) {
        return JSValue::encode(JSC::jsUndefined());
    }

    JSTextDecoder* instance = JSTextDecoder::create(vm, globalObject, structure, ptr);

    return JSValue::encode(instance);
}

void JSTextDecoderConstructor::initializeProperties(VM& vm, JSC::JSGlobalObject* globalObject, JSTextDecoderPrototype* prototype)
{
}

const ClassInfo JSTextDecoderConstructor::s_info = { "Function"_s, &Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSTextDecoderConstructor) };

extern "C" EncodedJSValue TextDecoder__getConstructor(Zig::GlobalObject* globalObject)
{
    return JSValue::encode(globalObject->JSTextDecoderConstructor());
}

JSTextDecoder::~JSTextDecoder()
{
    if (m_ctx) {
        TextDecoderClass__finalize(m_ctx);
    }
}
void JSTextDecoder::destroy(JSCell* cell)
{
    static_cast<JSTextDecoder*>(cell)->JSTextDecoder::~JSTextDecoder();
}

const ClassInfo JSTextDecoder::s_info = { "TextDecoder"_s, &Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSTextDecoder) };

void JSTextDecoder::finishCreation(VM& vm)
{
    Base::finishCreation(vm);
    ASSERT(inherits(info()));
}

JSTextDecoder* JSTextDecoder::create(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure, void* ctx)
{
    JSTextDecoder* ptr = new (NotNull, JSC::allocateCell<JSTextDecoder>(vm)) JSTextDecoder(vm, structure, ctx);
    ptr->finishCreation(vm);
    return ptr;
}

extern "C" void* TextDecoder__fromJS(JSC::EncodedJSValue value)
{
    JSC::JSValue decodedValue = JSC::JSValue::decode(value);
    if (decodedValue.isEmpty() || !decodedValue.isCell())
        return nullptr;

    JSC::JSCell* cell = decodedValue.asCell();
    JSTextDecoder* object = JSC::jsDynamicCast<JSTextDecoder*>(cell);

    if (!object)
        return nullptr;

    return object->wrapped();
}

extern "C" bool TextDecoder__dangerouslySetPtr(JSC::EncodedJSValue value, void* ptr)
{
    JSTextDecoder* object = JSC::jsDynamicCast<JSTextDecoder*>(JSValue::decode(value));
    if (!object)
        return false;

    object->m_ctx = ptr;
    return true;
}

extern "C" const size_t TextDecoder__ptrOffset = JSTextDecoder::offsetOfWrapped();

void JSTextDecoder::analyzeHeap(JSCell* cell, HeapAnalyzer& analyzer)
{
    auto* thisObject = jsCast<JSTextDecoder*>(cell);
    if (void* wrapped = thisObject->wrapped()) {
        // if (thisObject->scriptExecutionContext())
        //     analyzer.setLabelForCell(cell, "url " + thisObject->scriptExecutionContext()->url().string());
    }
    Base::analyzeHeap(cell, analyzer);
}

JSObject* JSTextDecoder::createConstructor(VM& vm, JSGlobalObject* globalObject, JSValue prototype)
{
    return WebCore::JSTextDecoderConstructor::create(vm, globalObject, WebCore::JSTextDecoderConstructor::createStructure(vm, globalObject, globalObject->functionPrototype()), jsCast<WebCore::JSTextDecoderPrototype*>(prototype));
}

JSObject* JSTextDecoder::createPrototype(VM& vm, JSDOMGlobalObject* globalObject)
{
    return JSTextDecoderPrototype::create(vm, globalObject, JSTextDecoderPrototype::createStructure(vm, globalObject, globalObject->objectPrototype()));
}

extern "C" EncodedJSValue TextDecoder__create(Zig::GlobalObject* globalObject, void* ptr)
{
    auto& vm = globalObject->vm();
    JSC::Structure* structure = globalObject->JSTextDecoderStructure();
    JSTextDecoder* instance = JSTextDecoder::create(vm, globalObject, structure, ptr);

    return JSValue::encode(instance);
}

template<typename Visitor>
void JSTextDecoder::visitChildrenImpl(JSCell* cell, Visitor& visitor)
{
    JSTextDecoder* thisObject = jsCast<JSTextDecoder*>(cell);
    ASSERT_GC_OBJECT_INHERITS(thisObject, info());
    Base::visitChildren(thisObject, visitor);

    visitor.append(thisObject->m_encoding);
}

DEFINE_VISIT_CHILDREN(JSTextDecoder);

template<typename Visitor>
void JSTextDecoder::visitAdditionalChildren(Visitor& visitor)
{
    JSTextDecoder* thisObject = this;
    ASSERT_GC_OBJECT_INHERITS(thisObject, info());

    visitor.append(thisObject->m_encoding);
    ;
}

DEFINE_VISIT_ADDITIONAL_CHILDREN(JSTextDecoder);

template<typename Visitor>
void JSTextDecoder::visitOutputConstraintsImpl(JSCell* cell, Visitor& visitor)
{
    JSTextDecoder* thisObject = jsCast<JSTextDecoder*>(cell);
    ASSERT_GC_OBJECT_INHERITS(thisObject, info());
    thisObject->visitAdditionalChildren<Visitor>(visitor);
}

DEFINE_VISIT_OUTPUT_CONSTRAINTS(JSTextDecoder);
class JSTimeoutPrototype final : public JSC::JSNonFinalObject {
public:
    using Base = JSC::JSNonFinalObject;

    static JSTimeoutPrototype* create(JSC::VM& vm, JSGlobalObject* globalObject, JSC::Structure* structure)
    {
        JSTimeoutPrototype* ptr = new (NotNull, JSC::allocateCell<JSTimeoutPrototype>(vm)) JSTimeoutPrototype(vm, globalObject, structure);
        ptr->finishCreation(vm, globalObject);
        return ptr;
    }

    DECLARE_INFO;
    template<typename CellType, JSC::SubspaceAccess>
    static JSC::GCClient::IsoSubspace* subspaceFor(JSC::VM& vm)
    {
        return &vm.plainObjectSpace();
    }
    static JSC::Structure* createStructure(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::JSValue prototype)
    {
        return JSC::Structure::create(vm, globalObject, prototype, JSC::TypeInfo(JSC::ObjectType, StructureFlags), info());
    }

private:
    JSTimeoutPrototype(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure)
        : Base(vm, structure)
    {
    }

    void finishCreation(JSC::VM&, JSC::JSGlobalObject*);
};

extern "C" void TimeoutClass__finalize(void*);

extern "C" EncodedJSValue TimeoutPrototype__toPrimitive(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(TimeoutPrototype__toPrimitiveCallback);

extern "C" EncodedJSValue TimeoutPrototype__hasRef(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(TimeoutPrototype__hasRefCallback);

extern "C" EncodedJSValue TimeoutPrototype__doRef(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(TimeoutPrototype__refCallback);

extern "C" EncodedJSValue TimeoutPrototype__doUnref(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(TimeoutPrototype__unrefCallback);

STATIC_ASSERT_ISO_SUBSPACE_SHARABLE(JSTimeoutPrototype, JSTimeoutPrototype::Base);

static const HashTableValue JSTimeoutPrototypeTableValues[] = {
    { "hasRef"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, TimeoutPrototype__hasRefCallback, 0 } },
    { "ref"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, TimeoutPrototype__refCallback, 0 } },
    { "unref"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, TimeoutPrototype__unrefCallback, 0 } }
};

const ClassInfo JSTimeoutPrototype::s_info = { "Timeout"_s, &Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSTimeoutPrototype) };

JSC_DEFINE_HOST_FUNCTION(TimeoutPrototype__toPrimitiveCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSTimeout* thisObject = jsDynamicCast<JSTimeout*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return TimeoutPrototype__toPrimitive(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_HOST_FUNCTION(TimeoutPrototype__hasRefCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSTimeout* thisObject = jsDynamicCast<JSTimeout*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return TimeoutPrototype__hasRef(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_HOST_FUNCTION(TimeoutPrototype__refCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSTimeout* thisObject = jsDynamicCast<JSTimeout*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return TimeoutPrototype__doRef(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_HOST_FUNCTION(TimeoutPrototype__unrefCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSTimeout* thisObject = jsDynamicCast<JSTimeout*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return TimeoutPrototype__doUnref(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

void JSTimeoutPrototype::finishCreation(JSC::VM& vm, JSC::JSGlobalObject* globalObject)
{
    Base::finishCreation(vm);
    reifyStaticProperties(vm, JSTimeout::info(), JSTimeoutPrototypeTableValues, *this);
    this->putDirect(vm, vm.propertyNames->toPrimitiveSymbol, JSFunction::create(vm, globalObject, 1, String("toPrimitive"_s), TimeoutPrototype__toPrimitiveCallback, ImplementationVisibility::Public), PropertyAttribute::Function | PropertyAttribute::ReadOnly | PropertyAttribute::DontEnum | 0);
    JSC_TO_STRING_TAG_WITHOUT_TRANSITION();
}

JSTimeout::~JSTimeout()
{
    if (m_ctx) {
        TimeoutClass__finalize(m_ctx);
    }
}
void JSTimeout::destroy(JSCell* cell)
{
    static_cast<JSTimeout*>(cell)->JSTimeout::~JSTimeout();
}

const ClassInfo JSTimeout::s_info = { "Timeout"_s, &Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSTimeout) };

void JSTimeout::finishCreation(VM& vm)
{
    Base::finishCreation(vm);
    ASSERT(inherits(info()));
}

JSTimeout* JSTimeout::create(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure, void* ctx)
{
    JSTimeout* ptr = new (NotNull, JSC::allocateCell<JSTimeout>(vm)) JSTimeout(vm, structure, ctx);
    ptr->finishCreation(vm);
    return ptr;
}

extern "C" void* Timeout__fromJS(JSC::EncodedJSValue value)
{
    JSC::JSValue decodedValue = JSC::JSValue::decode(value);
    if (decodedValue.isEmpty() || !decodedValue.isCell())
        return nullptr;

    JSC::JSCell* cell = decodedValue.asCell();
    JSTimeout* object = JSC::jsDynamicCast<JSTimeout*>(cell);

    if (!object)
        return nullptr;

    return object->wrapped();
}

extern "C" bool Timeout__dangerouslySetPtr(JSC::EncodedJSValue value, void* ptr)
{
    JSTimeout* object = JSC::jsDynamicCast<JSTimeout*>(JSValue::decode(value));
    if (!object)
        return false;

    object->m_ctx = ptr;
    return true;
}

extern "C" const size_t Timeout__ptrOffset = JSTimeout::offsetOfWrapped();

void JSTimeout::analyzeHeap(JSCell* cell, HeapAnalyzer& analyzer)
{
    auto* thisObject = jsCast<JSTimeout*>(cell);
    if (void* wrapped = thisObject->wrapped()) {
        // if (thisObject->scriptExecutionContext())
        //     analyzer.setLabelForCell(cell, "url " + thisObject->scriptExecutionContext()->url().string());
    }
    Base::analyzeHeap(cell, analyzer);
}

JSObject* JSTimeout::createPrototype(VM& vm, JSDOMGlobalObject* globalObject)
{
    return JSTimeoutPrototype::create(vm, globalObject, JSTimeoutPrototype::createStructure(vm, globalObject, globalObject->objectPrototype()));
}

extern "C" EncodedJSValue Timeout__create(Zig::GlobalObject* globalObject, void* ptr)
{
    auto& vm = globalObject->vm();
    JSC::Structure* structure = globalObject->JSTimeoutStructure();
    JSTimeout* instance = JSTimeout::create(vm, globalObject, structure, ptr);

    return JSValue::encode(instance);
}
class JSTranspilerPrototype final : public JSC::JSNonFinalObject {
public:
    using Base = JSC::JSNonFinalObject;

    static JSTranspilerPrototype* create(JSC::VM& vm, JSGlobalObject* globalObject, JSC::Structure* structure)
    {
        JSTranspilerPrototype* ptr = new (NotNull, JSC::allocateCell<JSTranspilerPrototype>(vm)) JSTranspilerPrototype(vm, globalObject, structure);
        ptr->finishCreation(vm, globalObject);
        return ptr;
    }

    DECLARE_INFO;
    template<typename CellType, JSC::SubspaceAccess>
    static JSC::GCClient::IsoSubspace* subspaceFor(JSC::VM& vm)
    {
        return &vm.plainObjectSpace();
    }
    static JSC::Structure* createStructure(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::JSValue prototype)
    {
        return JSC::Structure::create(vm, globalObject, prototype, JSC::TypeInfo(JSC::ObjectType, StructureFlags), info());
    }

private:
    JSTranspilerPrototype(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure)
        : Base(vm, structure)
    {
    }

    void finishCreation(JSC::VM&, JSC::JSGlobalObject*);
};

class JSTranspilerConstructor final : public JSC::InternalFunction {
public:
    using Base = JSC::InternalFunction;
    static JSTranspilerConstructor* create(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure, JSTranspilerPrototype* prototype);

    static constexpr unsigned StructureFlags = Base::StructureFlags;
    static constexpr bool needsDestruction = false;

    static JSC::Structure* createStructure(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::JSValue prototype)
    {
        return JSC::Structure::create(vm, globalObject, prototype, JSC::TypeInfo(JSC::InternalFunctionType, StructureFlags), info());
    }

    template<typename, JSC::SubspaceAccess mode> static JSC::GCClient::IsoSubspace* subspaceFor(JSC::VM& vm)
    {
        if constexpr (mode == JSC::SubspaceAccess::Concurrently)
            return nullptr;
        return WebCore::subspaceForImpl<JSTranspilerConstructor, WebCore::UseCustomHeapCellType::No>(
            vm,
            [](auto& spaces) { return spaces.m_clientSubspaceForTranspilerConstructor.get(); },
            [](auto& spaces, auto&& space) { spaces.m_clientSubspaceForTranspilerConstructor = std::forward<decltype(space)>(space); },
            [](auto& spaces) { return spaces.m_subspaceForTranspilerConstructor.get(); },
            [](auto& spaces, auto&& space) { spaces.m_subspaceForTranspilerConstructor = std::forward<decltype(space)>(space); });
    }

    void initializeProperties(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSTranspilerPrototype* prototype);

    // Must be defined for each specialization class.
    static JSC::EncodedJSValue JSC_HOST_CALL_ATTRIBUTES construct(JSC::JSGlobalObject*, JSC::CallFrame*);

    DECLARE_EXPORT_INFO;

private:
    JSTranspilerConstructor(JSC::VM& vm, JSC::Structure* structure);
    void finishCreation(JSC::VM&, JSC::JSGlobalObject* globalObject, JSTranspilerPrototype* prototype);
};

extern "C" void* TranspilerClass__construct(JSC::JSGlobalObject*, JSC::CallFrame*);
JSC_DECLARE_CUSTOM_GETTER(jsTranspilerConstructor);
extern "C" void TranspilerClass__finalize(void*);

extern "C" EncodedJSValue TranspilerPrototype__scan(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(TranspilerPrototype__scanCallback);

extern "C" EncodedJSValue TranspilerPrototype__scanImports(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(TranspilerPrototype__scanImportsCallback);

extern "C" EncodedJSValue TranspilerPrototype__transform(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(TranspilerPrototype__transformCallback);

extern "C" EncodedJSValue TranspilerPrototype__transformSync(void* ptr, JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame);
JSC_DECLARE_HOST_FUNCTION(TranspilerPrototype__transformSyncCallback);

STATIC_ASSERT_ISO_SUBSPACE_SHARABLE(JSTranspilerPrototype, JSTranspilerPrototype::Base);

static const HashTableValue JSTranspilerPrototypeTableValues[] = {
    { "scan"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, TranspilerPrototype__scanCallback, 2 } },
    { "scanImports"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, TranspilerPrototype__scanImportsCallback, 2 } },
    { "transform"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, TranspilerPrototype__transformCallback, 2 } },
    { "transformSync"_s, static_cast<unsigned>(JSC::PropertyAttribute::Function | PropertyAttribute::DontDelete), NoIntrinsic, { HashTableValue::NativeFunctionType, TranspilerPrototype__transformSyncCallback, 2 } }
};

const ClassInfo JSTranspilerPrototype::s_info = { "Transpiler"_s, &Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSTranspilerPrototype) };

JSC_DEFINE_CUSTOM_GETTER(jsTranspilerConstructor, (JSGlobalObject * lexicalGlobalObject, EncodedJSValue thisValue, PropertyName))
{
    VM& vm = JSC::getVM(lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    auto* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    auto* prototype = jsDynamicCast<JSTranspilerPrototype*>(JSValue::decode(thisValue));

    if (UNLIKELY(!prototype))
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    return JSValue::encode(globalObject->JSTranspilerConstructor());
}

JSC_DEFINE_HOST_FUNCTION(TranspilerPrototype__scanCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSTranspiler* thisObject = jsDynamicCast<JSTranspiler*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return TranspilerPrototype__scan(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_HOST_FUNCTION(TranspilerPrototype__scanImportsCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSTranspiler* thisObject = jsDynamicCast<JSTranspiler*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return TranspilerPrototype__scanImports(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_HOST_FUNCTION(TranspilerPrototype__transformCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSTranspiler* thisObject = jsDynamicCast<JSTranspiler*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return TranspilerPrototype__transform(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

JSC_DEFINE_HOST_FUNCTION(TranspilerPrototype__transformSyncCallback, (JSGlobalObject * lexicalGlobalObject, CallFrame* callFrame))
{
    auto& vm = lexicalGlobalObject->vm();

    JSTranspiler* thisObject = jsDynamicCast<JSTranspiler*>(callFrame->thisValue());

    if (UNLIKELY(!thisObject)) {
        auto throwScope = DECLARE_THROW_SCOPE(vm);
        return throwVMTypeError(lexicalGlobalObject, throwScope);
    }

    JSC::EnsureStillAliveScope thisArg = JSC::EnsureStillAliveScope(thisObject);

    return TranspilerPrototype__transformSync(thisObject->wrapped(), lexicalGlobalObject, callFrame);
}

void JSTranspilerPrototype::finishCreation(JSC::VM& vm, JSC::JSGlobalObject* globalObject)
{
    Base::finishCreation(vm);
    reifyStaticProperties(vm, JSTranspiler::info(), JSTranspilerPrototypeTableValues, *this);
    JSC_TO_STRING_TAG_WITHOUT_TRANSITION();
}

void JSTranspilerConstructor::finishCreation(VM& vm, JSC::JSGlobalObject* globalObject, JSTranspilerPrototype* prototype)
{
    Base::finishCreation(vm, 0, "Transpiler"_s, PropertyAdditionMode::WithoutStructureTransition);

    putDirectWithoutTransition(vm, vm.propertyNames->prototype, prototype, PropertyAttribute::DontEnum | PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly);
    ASSERT(inherits(info()));
}

JSTranspilerConstructor::JSTranspilerConstructor(JSC::VM& vm, JSC::Structure* structure)
    : Base(vm, structure, construct, construct)
{
}

JSTranspilerConstructor* JSTranspilerConstructor::create(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure, JSTranspilerPrototype* prototype)
{
    JSTranspilerConstructor* ptr = new (NotNull, JSC::allocateCell<JSTranspilerConstructor>(vm)) JSTranspilerConstructor(vm, structure);
    ptr->finishCreation(vm, globalObject, prototype);
    return ptr;
}

JSC::EncodedJSValue JSC_HOST_CALL_ATTRIBUTES JSTranspilerConstructor::construct(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame)
{
    Zig::GlobalObject* globalObject = reinterpret_cast<Zig::GlobalObject*>(lexicalGlobalObject);
    JSC::VM& vm = globalObject->vm();
    JSObject* newTarget = asObject(callFrame->newTarget());
    auto* constructor = globalObject->JSTranspilerConstructor();
    Structure* structure = globalObject->JSTranspilerStructure();
    if (constructor != newTarget) {
        auto scope = DECLARE_THROW_SCOPE(vm);

        auto* functionGlobalObject = reinterpret_cast<Zig::GlobalObject*>(
            // ShadowRealm functions belong to a different global object.
            getFunctionRealm(globalObject, newTarget));
        RETURN_IF_EXCEPTION(scope, {});
        structure = InternalFunction::createSubclassStructure(
            globalObject,
            newTarget,
            functionGlobalObject->JSTranspilerStructure());
    }

    void* ptr = TranspilerClass__construct(globalObject, callFrame);

    if (UNLIKELY(!ptr)) {
        return JSValue::encode(JSC::jsUndefined());
    }

    JSTranspiler* instance = JSTranspiler::create(vm, globalObject, structure, ptr);

    return JSValue::encode(instance);
}

void JSTranspilerConstructor::initializeProperties(VM& vm, JSC::JSGlobalObject* globalObject, JSTranspilerPrototype* prototype)
{
}

const ClassInfo JSTranspilerConstructor::s_info = { "Function"_s, &Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSTranspilerConstructor) };

extern "C" EncodedJSValue Transpiler__getConstructor(Zig::GlobalObject* globalObject)
{
    return JSValue::encode(globalObject->JSTranspilerConstructor());
}

JSTranspiler::~JSTranspiler()
{
    if (m_ctx) {
        TranspilerClass__finalize(m_ctx);
    }
}
void JSTranspiler::destroy(JSCell* cell)
{
    static_cast<JSTranspiler*>(cell)->JSTranspiler::~JSTranspiler();
}

const ClassInfo JSTranspiler::s_info = { "Transpiler"_s, &Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSTranspiler) };

void JSTranspiler::finishCreation(VM& vm)
{
    Base::finishCreation(vm);
    ASSERT(inherits(info()));
}

JSTranspiler* JSTranspiler::create(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure, void* ctx)
{
    JSTranspiler* ptr = new (NotNull, JSC::allocateCell<JSTranspiler>(vm)) JSTranspiler(vm, structure, ctx);
    ptr->finishCreation(vm);
    return ptr;
}

extern "C" void* Transpiler__fromJS(JSC::EncodedJSValue value)
{
    JSC::JSValue decodedValue = JSC::JSValue::decode(value);
    if (decodedValue.isEmpty() || !decodedValue.isCell())
        return nullptr;

    JSC::JSCell* cell = decodedValue.asCell();
    JSTranspiler* object = JSC::jsDynamicCast<JSTranspiler*>(cell);

    if (!object)
        return nullptr;

    return object->wrapped();
}

extern "C" bool Transpiler__dangerouslySetPtr(JSC::EncodedJSValue value, void* ptr)
{
    JSTranspiler* object = JSC::jsDynamicCast<JSTranspiler*>(JSValue::decode(value));
    if (!object)
        return false;

    object->m_ctx = ptr;
    return true;
}

extern "C" const size_t Transpiler__ptrOffset = JSTranspiler::offsetOfWrapped();

void JSTranspiler::analyzeHeap(JSCell* cell, HeapAnalyzer& analyzer)
{
    auto* thisObject = jsCast<JSTranspiler*>(cell);
    if (void* wrapped = thisObject->wrapped()) {
        // if (thisObject->scriptExecutionContext())
        //     analyzer.setLabelForCell(cell, "url " + thisObject->scriptExecutionContext()->url().string());
    }
    Base::analyzeHeap(cell, analyzer);
}

JSObject* JSTranspiler::createConstructor(VM& vm, JSGlobalObject* globalObject, JSValue prototype)
{
    return WebCore::JSTranspilerConstructor::create(vm, globalObject, WebCore::JSTranspilerConstructor::createStructure(vm, globalObject, globalObject->functionPrototype()), jsCast<WebCore::JSTranspilerPrototype*>(prototype));
}

JSObject* JSTranspiler::createPrototype(VM& vm, JSDOMGlobalObject* globalObject)
{
    return JSTranspilerPrototype::create(vm, globalObject, JSTranspilerPrototype::createStructure(vm, globalObject, globalObject->objectPrototype()));
}

extern "C" EncodedJSValue Transpiler__create(Zig::GlobalObject* globalObject, void* ptr)
{
    auto& vm = globalObject->vm();
    JSC::Structure* structure = globalObject->JSTranspilerStructure();
    JSTranspiler* instance = JSTranspiler::create(vm, globalObject, structure, ptr);

    return JSValue::encode(instance);
}

} // namespace WebCore
