
// GENERATED CODE - DO NOT MODIFY BY HAND
// Generated by make codegen
#pragma once

#include "root.h"

namespace Zig {
}

#include "JSDOMWrapper.h"
#include <wtf/NeverDestroyed.h>
#include "BunPlugin.h";


namespace WebCore {
using namespace Zig;
using namespace JSC;

class JSBlob final : public JSC::JSDestructibleObject {
    public:
        using Base = JSC::JSDestructibleObject;
        static JSBlob* create(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure, void* ctx);
    
        DECLARE_EXPORT_INFO;
        template<typename, JSC::SubspaceAccess mode> static JSC::GCClient::IsoSubspace* subspaceFor(JSC::VM& vm)
        {
            if constexpr (mode == JSC::SubspaceAccess::Concurrently)
                return nullptr;
            return WebCore::subspaceForImpl<JSBlob, WebCore::UseCustomHeapCellType::No>(
                vm,
                [](auto& spaces) { return spaces.m_clientSubspaceForBlob.get(); },
                [](auto& spaces, auto&& space) { spaces.m_clientSubspaceForBlob = std::forward<decltype(space)>(space); },
                [](auto& spaces) { return spaces.m_subspaceForBlob.get(); },
                [](auto& spaces, auto&& space) { spaces.m_subspaceForBlob = std::forward<decltype(space)>(space); });
        }
    
        static void destroy(JSC::JSCell*);
        static JSC::Structure* createStructure(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::JSValue prototype)
        {
            return JSC::Structure::create(vm, globalObject, prototype, JSC::TypeInfo(static_cast<JSC::JSType>(0b11101110), StructureFlags), info());
        }
    
        static JSObject* createPrototype(VM& vm, JSDOMGlobalObject* globalObject);
        static JSObject* createConstructor(VM& vm, JSGlobalObject* globalObject, JSValue prototype);
    
        ~JSBlob();
    
        void* wrapped() const { return m_ctx; }
    
        void detach()
        {
            m_ctx = nullptr;
        }
    
        static void analyzeHeap(JSCell*, JSC::HeapAnalyzer&);
        static ptrdiff_t offsetOfWrapped() { return OBJECT_OFFSETOF(JSBlob, m_ctx); }
    
        void* m_ctx { nullptr };

            
        JSBlob(JSC::VM& vm, JSC::Structure* structure, void* sinkPtr)
            : Base(vm, structure)
        {
            m_ctx = sinkPtr;
            
        }
    
        void finishCreation(JSC::VM&);

        

        

        

        
    };

class JSCryptoHasher final : public JSC::JSDestructibleObject {
    public:
        using Base = JSC::JSDestructibleObject;
        static JSCryptoHasher* create(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure, void* ctx);
    
        DECLARE_EXPORT_INFO;
        template<typename, JSC::SubspaceAccess mode> static JSC::GCClient::IsoSubspace* subspaceFor(JSC::VM& vm)
        {
            if constexpr (mode == JSC::SubspaceAccess::Concurrently)
                return nullptr;
            return WebCore::subspaceForImpl<JSCryptoHasher, WebCore::UseCustomHeapCellType::No>(
                vm,
                [](auto& spaces) { return spaces.m_clientSubspaceForCryptoHasher.get(); },
                [](auto& spaces, auto&& space) { spaces.m_clientSubspaceForCryptoHasher = std::forward<decltype(space)>(space); },
                [](auto& spaces) { return spaces.m_subspaceForCryptoHasher.get(); },
                [](auto& spaces, auto&& space) { spaces.m_subspaceForCryptoHasher = std::forward<decltype(space)>(space); });
        }
    
        static void destroy(JSC::JSCell*);
        static JSC::Structure* createStructure(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::JSValue prototype)
        {
            return JSC::Structure::create(vm, globalObject, prototype, JSC::TypeInfo(static_cast<JSC::JSType>(0b11101110), StructureFlags), info());
        }
    
        static JSObject* createPrototype(VM& vm, JSDOMGlobalObject* globalObject);
        static JSObject* createConstructor(VM& vm, JSGlobalObject* globalObject, JSValue prototype);
    
        ~JSCryptoHasher();
    
        void* wrapped() const { return m_ctx; }
    
        void detach()
        {
            m_ctx = nullptr;
        }
    
        static void analyzeHeap(JSCell*, JSC::HeapAnalyzer&);
        static ptrdiff_t offsetOfWrapped() { return OBJECT_OFFSETOF(JSCryptoHasher, m_ctx); }
    
        void* m_ctx { nullptr };

            
        JSCryptoHasher(JSC::VM& vm, JSC::Structure* structure, void* sinkPtr)
            : Base(vm, structure)
        {
            m_ctx = sinkPtr;
            
        }
    
        void finishCreation(JSC::VM&);

        

        

        DECLARE_VISIT_CHILDREN;
template<typename Visitor> void visitAdditionalChildren(Visitor&);
DECLARE_VISIT_OUTPUT_CONSTRAINTS;


        mutable JSC::WriteBarrier<JSC::Unknown> m_algorithms;
mutable JSC::WriteBarrier<JSC::Unknown> m_algorithm;
    };

class JSDirent final : public JSC::JSDestructibleObject {
    public:
        using Base = JSC::JSDestructibleObject;
        static JSDirent* create(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure, void* ctx);
    
        DECLARE_EXPORT_INFO;
        template<typename, JSC::SubspaceAccess mode> static JSC::GCClient::IsoSubspace* subspaceFor(JSC::VM& vm)
        {
            if constexpr (mode == JSC::SubspaceAccess::Concurrently)
                return nullptr;
            return WebCore::subspaceForImpl<JSDirent, WebCore::UseCustomHeapCellType::No>(
                vm,
                [](auto& spaces) { return spaces.m_clientSubspaceForDirent.get(); },
                [](auto& spaces, auto&& space) { spaces.m_clientSubspaceForDirent = std::forward<decltype(space)>(space); },
                [](auto& spaces) { return spaces.m_subspaceForDirent.get(); },
                [](auto& spaces, auto&& space) { spaces.m_subspaceForDirent = std::forward<decltype(space)>(space); });
        }
    
        static void destroy(JSC::JSCell*);
        static JSC::Structure* createStructure(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::JSValue prototype)
        {
            return JSC::Structure::create(vm, globalObject, prototype, JSC::TypeInfo(static_cast<JSC::JSType>(ObjectType), StructureFlags), info());
        }
    
        static JSObject* createPrototype(VM& vm, JSDOMGlobalObject* globalObject);
        static JSObject* createConstructor(VM& vm, JSGlobalObject* globalObject, JSValue prototype);
    
        ~JSDirent();
    
        void* wrapped() const { return m_ctx; }
    
        void detach()
        {
            m_ctx = nullptr;
        }
    
        static void analyzeHeap(JSCell*, JSC::HeapAnalyzer&);
        static ptrdiff_t offsetOfWrapped() { return OBJECT_OFFSETOF(JSDirent, m_ctx); }
    
        void* m_ctx { nullptr };

            
        JSDirent(JSC::VM& vm, JSC::Structure* structure, void* sinkPtr)
            : Base(vm, structure)
        {
            m_ctx = sinkPtr;
            
        }
    
        void finishCreation(JSC::VM&);

        

        

        DECLARE_VISIT_CHILDREN;
template<typename Visitor> void visitAdditionalChildren(Visitor&);
DECLARE_VISIT_OUTPUT_CONSTRAINTS;


        mutable JSC::WriteBarrier<JSC::Unknown> m_name;
    };

class JSExpect final : public JSC::JSDestructibleObject {
    public:
        using Base = JSC::JSDestructibleObject;
        static JSExpect* create(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure, void* ctx);
    
        DECLARE_EXPORT_INFO;
        template<typename, JSC::SubspaceAccess mode> static JSC::GCClient::IsoSubspace* subspaceFor(JSC::VM& vm)
        {
            if constexpr (mode == JSC::SubspaceAccess::Concurrently)
                return nullptr;
            return WebCore::subspaceForImpl<JSExpect, WebCore::UseCustomHeapCellType::No>(
                vm,
                [](auto& spaces) { return spaces.m_clientSubspaceForExpect.get(); },
                [](auto& spaces, auto&& space) { spaces.m_clientSubspaceForExpect = std::forward<decltype(space)>(space); },
                [](auto& spaces) { return spaces.m_subspaceForExpect.get(); },
                [](auto& spaces, auto&& space) { spaces.m_subspaceForExpect = std::forward<decltype(space)>(space); });
        }
    
        static void destroy(JSC::JSCell*);
        static JSC::Structure* createStructure(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::JSValue prototype)
        {
            return JSC::Structure::create(vm, globalObject, prototype, JSC::TypeInfo(static_cast<JSC::JSType>(0b11101110), StructureFlags), info());
        }
    
        static JSObject* createPrototype(VM& vm, JSDOMGlobalObject* globalObject);
        static JSObject* createConstructor(VM& vm, JSGlobalObject* globalObject, JSValue prototype);
    
        ~JSExpect();
    
        void* wrapped() const { return m_ctx; }
    
        void detach()
        {
            m_ctx = nullptr;
        }
    
        static void analyzeHeap(JSCell*, JSC::HeapAnalyzer&);
        static ptrdiff_t offsetOfWrapped() { return OBJECT_OFFSETOF(JSExpect, m_ctx); }
    
        void* m_ctx { nullptr };

            
        JSExpect(JSC::VM& vm, JSC::Structure* structure, void* sinkPtr)
            : Base(vm, structure)
        {
            m_ctx = sinkPtr;
            
        }
    
        void finishCreation(JSC::VM&);

        

        

        DECLARE_VISIT_CHILDREN;
template<typename Visitor> void visitAdditionalChildren(Visitor&);
DECLARE_VISIT_OUTPUT_CONSTRAINTS;


        mutable JSC::WriteBarrier<JSC::Unknown> m_capturedValue;
mutable JSC::WriteBarrier<JSC::Unknown> m_resultValue;
    };

class JSExpectAny final : public JSC::JSDestructibleObject {
    public:
        using Base = JSC::JSDestructibleObject;
        static JSExpectAny* create(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure, void* ctx);
    
        DECLARE_EXPORT_INFO;
        template<typename, JSC::SubspaceAccess mode> static JSC::GCClient::IsoSubspace* subspaceFor(JSC::VM& vm)
        {
            if constexpr (mode == JSC::SubspaceAccess::Concurrently)
                return nullptr;
            return WebCore::subspaceForImpl<JSExpectAny, WebCore::UseCustomHeapCellType::No>(
                vm,
                [](auto& spaces) { return spaces.m_clientSubspaceForExpectAny.get(); },
                [](auto& spaces, auto&& space) { spaces.m_clientSubspaceForExpectAny = std::forward<decltype(space)>(space); },
                [](auto& spaces) { return spaces.m_subspaceForExpectAny.get(); },
                [](auto& spaces, auto&& space) { spaces.m_subspaceForExpectAny = std::forward<decltype(space)>(space); });
        }
    
        static void destroy(JSC::JSCell*);
        static JSC::Structure* createStructure(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::JSValue prototype)
        {
            return JSC::Structure::create(vm, globalObject, prototype, JSC::TypeInfo(static_cast<JSC::JSType>(0b11101110), StructureFlags), info());
        }
    
        static JSObject* createPrototype(VM& vm, JSDOMGlobalObject* globalObject);
        ;
    
        ~JSExpectAny();
    
        void* wrapped() const { return m_ctx; }
    
        void detach()
        {
            m_ctx = nullptr;
        }
    
        static void analyzeHeap(JSCell*, JSC::HeapAnalyzer&);
        static ptrdiff_t offsetOfWrapped() { return OBJECT_OFFSETOF(JSExpectAny, m_ctx); }
    
        void* m_ctx { nullptr };

            
        JSExpectAny(JSC::VM& vm, JSC::Structure* structure, void* sinkPtr)
            : Base(vm, structure)
        {
            m_ctx = sinkPtr;
            
        }
    
        void finishCreation(JSC::VM&);

        

        

        DECLARE_VISIT_CHILDREN;
template<typename Visitor> void visitAdditionalChildren(Visitor&);
DECLARE_VISIT_OUTPUT_CONSTRAINTS;


        mutable JSC::WriteBarrier<JSC::Unknown> m_constructorValue;
    };

class JSFileSystemRouter final : public JSC::JSDestructibleObject {
    public:
        using Base = JSC::JSDestructibleObject;
        static JSFileSystemRouter* create(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure, void* ctx);
    
        DECLARE_EXPORT_INFO;
        template<typename, JSC::SubspaceAccess mode> static JSC::GCClient::IsoSubspace* subspaceFor(JSC::VM& vm)
        {
            if constexpr (mode == JSC::SubspaceAccess::Concurrently)
                return nullptr;
            return WebCore::subspaceForImpl<JSFileSystemRouter, WebCore::UseCustomHeapCellType::No>(
                vm,
                [](auto& spaces) { return spaces.m_clientSubspaceForFileSystemRouter.get(); },
                [](auto& spaces, auto&& space) { spaces.m_clientSubspaceForFileSystemRouter = std::forward<decltype(space)>(space); },
                [](auto& spaces) { return spaces.m_subspaceForFileSystemRouter.get(); },
                [](auto& spaces, auto&& space) { spaces.m_subspaceForFileSystemRouter = std::forward<decltype(space)>(space); });
        }
    
        static void destroy(JSC::JSCell*);
        static JSC::Structure* createStructure(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::JSValue prototype)
        {
            return JSC::Structure::create(vm, globalObject, prototype, JSC::TypeInfo(static_cast<JSC::JSType>(0b11101110), StructureFlags), info());
        }
    
        static JSObject* createPrototype(VM& vm, JSDOMGlobalObject* globalObject);
        static JSObject* createConstructor(VM& vm, JSGlobalObject* globalObject, JSValue prototype);
    
        ~JSFileSystemRouter();
    
        void* wrapped() const { return m_ctx; }
    
        void detach()
        {
            m_ctx = nullptr;
        }
    
        static void analyzeHeap(JSCell*, JSC::HeapAnalyzer&);
        static ptrdiff_t offsetOfWrapped() { return OBJECT_OFFSETOF(JSFileSystemRouter, m_ctx); }
    
        void* m_ctx { nullptr };

            
        JSFileSystemRouter(JSC::VM& vm, JSC::Structure* structure, void* sinkPtr)
            : Base(vm, structure)
        {
            m_ctx = sinkPtr;
            
        }
    
        void finishCreation(JSC::VM&);

        

        

        DECLARE_VISIT_CHILDREN;
template<typename Visitor> void visitAdditionalChildren(Visitor&);
DECLARE_VISIT_OUTPUT_CONSTRAINTS;


        mutable JSC::WriteBarrier<JSC::Unknown> m_origin;
mutable JSC::WriteBarrier<JSC::Unknown> m_routes;
mutable JSC::WriteBarrier<JSC::Unknown> m_style;
    };

class JSListener final : public JSC::JSDestructibleObject {
    public:
        using Base = JSC::JSDestructibleObject;
        static JSListener* create(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure, void* ctx);
    
        DECLARE_EXPORT_INFO;
        template<typename, JSC::SubspaceAccess mode> static JSC::GCClient::IsoSubspace* subspaceFor(JSC::VM& vm)
        {
            if constexpr (mode == JSC::SubspaceAccess::Concurrently)
                return nullptr;
            return WebCore::subspaceForImpl<JSListener, WebCore::UseCustomHeapCellType::No>(
                vm,
                [](auto& spaces) { return spaces.m_clientSubspaceForListener.get(); },
                [](auto& spaces, auto&& space) { spaces.m_clientSubspaceForListener = std::forward<decltype(space)>(space); },
                [](auto& spaces) { return spaces.m_subspaceForListener.get(); },
                [](auto& spaces, auto&& space) { spaces.m_subspaceForListener = std::forward<decltype(space)>(space); });
        }
    
        static void destroy(JSC::JSCell*);
        static JSC::Structure* createStructure(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::JSValue prototype)
        {
            return JSC::Structure::create(vm, globalObject, prototype, JSC::TypeInfo(static_cast<JSC::JSType>(0b11101110), StructureFlags), info());
        }
    
        static JSObject* createPrototype(VM& vm, JSDOMGlobalObject* globalObject);
        ;
    
        ~JSListener();
    
        void* wrapped() const { return m_ctx; }
    
        void detach()
        {
            m_ctx = nullptr;
        }
    
        static void analyzeHeap(JSCell*, JSC::HeapAnalyzer&);
        static ptrdiff_t offsetOfWrapped() { return OBJECT_OFFSETOF(JSListener, m_ctx); }
    
        void* m_ctx { nullptr };

            
        JSListener(JSC::VM& vm, JSC::Structure* structure, void* sinkPtr)
            : Base(vm, structure)
        {
            m_ctx = sinkPtr;
            
        }
    
        void finishCreation(JSC::VM&);

        

        

        DECLARE_VISIT_CHILDREN;
template<typename Visitor> void visitAdditionalChildren(Visitor&);
DECLARE_VISIT_OUTPUT_CONSTRAINTS;


        mutable JSC::WriteBarrier<JSC::Unknown> m_hostname;
mutable JSC::WriteBarrier<JSC::Unknown> m_unix;
    };

class JSMD4 final : public JSC::JSDestructibleObject {
    public:
        using Base = JSC::JSDestructibleObject;
        static JSMD4* create(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure, void* ctx);
    
        DECLARE_EXPORT_INFO;
        template<typename, JSC::SubspaceAccess mode> static JSC::GCClient::IsoSubspace* subspaceFor(JSC::VM& vm)
        {
            if constexpr (mode == JSC::SubspaceAccess::Concurrently)
                return nullptr;
            return WebCore::subspaceForImpl<JSMD4, WebCore::UseCustomHeapCellType::No>(
                vm,
                [](auto& spaces) { return spaces.m_clientSubspaceForMD4.get(); },
                [](auto& spaces, auto&& space) { spaces.m_clientSubspaceForMD4 = std::forward<decltype(space)>(space); },
                [](auto& spaces) { return spaces.m_subspaceForMD4.get(); },
                [](auto& spaces, auto&& space) { spaces.m_subspaceForMD4 = std::forward<decltype(space)>(space); });
        }
    
        static void destroy(JSC::JSCell*);
        static JSC::Structure* createStructure(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::JSValue prototype)
        {
            return JSC::Structure::create(vm, globalObject, prototype, JSC::TypeInfo(static_cast<JSC::JSType>(0b11101110), StructureFlags), info());
        }
    
        static JSObject* createPrototype(VM& vm, JSDOMGlobalObject* globalObject);
        static JSObject* createConstructor(VM& vm, JSGlobalObject* globalObject, JSValue prototype);
    
        ~JSMD4();
    
        void* wrapped() const { return m_ctx; }
    
        void detach()
        {
            m_ctx = nullptr;
        }
    
        static void analyzeHeap(JSCell*, JSC::HeapAnalyzer&);
        static ptrdiff_t offsetOfWrapped() { return OBJECT_OFFSETOF(JSMD4, m_ctx); }
    
        void* m_ctx { nullptr };

            
        JSMD4(JSC::VM& vm, JSC::Structure* structure, void* sinkPtr)
            : Base(vm, structure)
        {
            m_ctx = sinkPtr;
            
        }
    
        void finishCreation(JSC::VM&);

        

        

        

        
    };

class JSMD5 final : public JSC::JSDestructibleObject {
    public:
        using Base = JSC::JSDestructibleObject;
        static JSMD5* create(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure, void* ctx);
    
        DECLARE_EXPORT_INFO;
        template<typename, JSC::SubspaceAccess mode> static JSC::GCClient::IsoSubspace* subspaceFor(JSC::VM& vm)
        {
            if constexpr (mode == JSC::SubspaceAccess::Concurrently)
                return nullptr;
            return WebCore::subspaceForImpl<JSMD5, WebCore::UseCustomHeapCellType::No>(
                vm,
                [](auto& spaces) { return spaces.m_clientSubspaceForMD5.get(); },
                [](auto& spaces, auto&& space) { spaces.m_clientSubspaceForMD5 = std::forward<decltype(space)>(space); },
                [](auto& spaces) { return spaces.m_subspaceForMD5.get(); },
                [](auto& spaces, auto&& space) { spaces.m_subspaceForMD5 = std::forward<decltype(space)>(space); });
        }
    
        static void destroy(JSC::JSCell*);
        static JSC::Structure* createStructure(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::JSValue prototype)
        {
            return JSC::Structure::create(vm, globalObject, prototype, JSC::TypeInfo(static_cast<JSC::JSType>(0b11101110), StructureFlags), info());
        }
    
        static JSObject* createPrototype(VM& vm, JSDOMGlobalObject* globalObject);
        static JSObject* createConstructor(VM& vm, JSGlobalObject* globalObject, JSValue prototype);
    
        ~JSMD5();
    
        void* wrapped() const { return m_ctx; }
    
        void detach()
        {
            m_ctx = nullptr;
        }
    
        static void analyzeHeap(JSCell*, JSC::HeapAnalyzer&);
        static ptrdiff_t offsetOfWrapped() { return OBJECT_OFFSETOF(JSMD5, m_ctx); }
    
        void* m_ctx { nullptr };

            
        JSMD5(JSC::VM& vm, JSC::Structure* structure, void* sinkPtr)
            : Base(vm, structure)
        {
            m_ctx = sinkPtr;
            
        }
    
        void finishCreation(JSC::VM&);

        

        

        

        
    };

class JSMatchedRoute final : public JSC::JSDestructibleObject {
    public:
        using Base = JSC::JSDestructibleObject;
        static JSMatchedRoute* create(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure, void* ctx);
    
        DECLARE_EXPORT_INFO;
        template<typename, JSC::SubspaceAccess mode> static JSC::GCClient::IsoSubspace* subspaceFor(JSC::VM& vm)
        {
            if constexpr (mode == JSC::SubspaceAccess::Concurrently)
                return nullptr;
            return WebCore::subspaceForImpl<JSMatchedRoute, WebCore::UseCustomHeapCellType::No>(
                vm,
                [](auto& spaces) { return spaces.m_clientSubspaceForMatchedRoute.get(); },
                [](auto& spaces, auto&& space) { spaces.m_clientSubspaceForMatchedRoute = std::forward<decltype(space)>(space); },
                [](auto& spaces) { return spaces.m_subspaceForMatchedRoute.get(); },
                [](auto& spaces, auto&& space) { spaces.m_subspaceForMatchedRoute = std::forward<decltype(space)>(space); });
        }
    
        static void destroy(JSC::JSCell*);
        static JSC::Structure* createStructure(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::JSValue prototype)
        {
            return JSC::Structure::create(vm, globalObject, prototype, JSC::TypeInfo(static_cast<JSC::JSType>(0b11101110), StructureFlags), info());
        }
    
        static JSObject* createPrototype(VM& vm, JSDOMGlobalObject* globalObject);
        ;
    
        ~JSMatchedRoute();
    
        void* wrapped() const { return m_ctx; }
    
        void detach()
        {
            m_ctx = nullptr;
        }
    
        static void analyzeHeap(JSCell*, JSC::HeapAnalyzer&);
        static ptrdiff_t offsetOfWrapped() { return OBJECT_OFFSETOF(JSMatchedRoute, m_ctx); }
    
        void* m_ctx { nullptr };

            
        JSMatchedRoute(JSC::VM& vm, JSC::Structure* structure, void* sinkPtr)
            : Base(vm, structure)
        {
            m_ctx = sinkPtr;
            
        }
    
        void finishCreation(JSC::VM&);

        

        

        DECLARE_VISIT_CHILDREN;
template<typename Visitor> void visitAdditionalChildren(Visitor&);
DECLARE_VISIT_OUTPUT_CONSTRAINTS;


        mutable JSC::WriteBarrier<JSC::Unknown> m_filePath;
mutable JSC::WriteBarrier<JSC::Unknown> m_kind;
mutable JSC::WriteBarrier<JSC::Unknown> m_name;
mutable JSC::WriteBarrier<JSC::Unknown> m_params;
mutable JSC::WriteBarrier<JSC::Unknown> m_pathname;
mutable JSC::WriteBarrier<JSC::Unknown> m_query;
mutable JSC::WriteBarrier<JSC::Unknown> m_scriptSrc;
    };

class JSNodeJSFS final : public JSC::JSDestructibleObject {
    public:
        using Base = JSC::JSDestructibleObject;
        static JSNodeJSFS* create(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure, void* ctx);
    
        DECLARE_EXPORT_INFO;
        template<typename, JSC::SubspaceAccess mode> static JSC::GCClient::IsoSubspace* subspaceFor(JSC::VM& vm)
        {
            if constexpr (mode == JSC::SubspaceAccess::Concurrently)
                return nullptr;
            return WebCore::subspaceForImpl<JSNodeJSFS, WebCore::UseCustomHeapCellType::No>(
                vm,
                [](auto& spaces) { return spaces.m_clientSubspaceForNodeJSFS.get(); },
                [](auto& spaces, auto&& space) { spaces.m_clientSubspaceForNodeJSFS = std::forward<decltype(space)>(space); },
                [](auto& spaces) { return spaces.m_subspaceForNodeJSFS.get(); },
                [](auto& spaces, auto&& space) { spaces.m_subspaceForNodeJSFS = std::forward<decltype(space)>(space); });
        }
    
        static void destroy(JSC::JSCell*);
        static JSC::Structure* createStructure(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::JSValue prototype)
        {
            return JSC::Structure::create(vm, globalObject, prototype, JSC::TypeInfo(static_cast<JSC::JSType>(ObjectType), StructureFlags), info());
        }
    
        static JSObject* createPrototype(VM& vm, JSDOMGlobalObject* globalObject);
        static JSObject* createConstructor(VM& vm, JSGlobalObject* globalObject, JSValue prototype);
    
        ~JSNodeJSFS();
    
        void* wrapped() const { return m_ctx; }
    
        void detach()
        {
            m_ctx = nullptr;
        }
    
        static void analyzeHeap(JSCell*, JSC::HeapAnalyzer&);
        static ptrdiff_t offsetOfWrapped() { return OBJECT_OFFSETOF(JSNodeJSFS, m_ctx); }
    
        void* m_ctx { nullptr };

            
        JSNodeJSFS(JSC::VM& vm, JSC::Structure* structure, void* sinkPtr)
            : Base(vm, structure)
        {
            m_ctx = sinkPtr;
            
        }
    
        void finishCreation(JSC::VM&);

        

        

        

        
    };

class JSRequest final : public JSC::JSDestructibleObject {
    public:
        using Base = JSC::JSDestructibleObject;
        static JSRequest* create(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure, void* ctx);
    
        DECLARE_EXPORT_INFO;
        template<typename, JSC::SubspaceAccess mode> static JSC::GCClient::IsoSubspace* subspaceFor(JSC::VM& vm)
        {
            if constexpr (mode == JSC::SubspaceAccess::Concurrently)
                return nullptr;
            return WebCore::subspaceForImpl<JSRequest, WebCore::UseCustomHeapCellType::No>(
                vm,
                [](auto& spaces) { return spaces.m_clientSubspaceForRequest.get(); },
                [](auto& spaces, auto&& space) { spaces.m_clientSubspaceForRequest = std::forward<decltype(space)>(space); },
                [](auto& spaces) { return spaces.m_subspaceForRequest.get(); },
                [](auto& spaces, auto&& space) { spaces.m_subspaceForRequest = std::forward<decltype(space)>(space); });
        }
    
        static void destroy(JSC::JSCell*);
        static JSC::Structure* createStructure(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::JSValue prototype)
        {
            return JSC::Structure::create(vm, globalObject, prototype, JSC::TypeInfo(static_cast<JSC::JSType>(0b11101110), StructureFlags), info());
        }
    
        static JSObject* createPrototype(VM& vm, JSDOMGlobalObject* globalObject);
        static JSObject* createConstructor(VM& vm, JSGlobalObject* globalObject, JSValue prototype);
    
        ~JSRequest();
    
        void* wrapped() const { return m_ctx; }
    
        void detach()
        {
            m_ctx = nullptr;
        }
    
        static void analyzeHeap(JSCell*, JSC::HeapAnalyzer&);
        static ptrdiff_t offsetOfWrapped() { return OBJECT_OFFSETOF(JSRequest, m_ctx); }
    
        void* m_ctx { nullptr };

            
        JSRequest(JSC::VM& vm, JSC::Structure* structure, void* sinkPtr)
            : Base(vm, structure)
        {
            m_ctx = sinkPtr;
            
        }
    
        void finishCreation(JSC::VM&);

        

        

        DECLARE_VISIT_CHILDREN;
template<typename Visitor> void visitAdditionalChildren(Visitor&);
DECLARE_VISIT_OUTPUT_CONSTRAINTS;


        mutable JSC::WriteBarrier<JSC::Unknown> m_body;
mutable JSC::WriteBarrier<JSC::Unknown> m_headers;
mutable JSC::WriteBarrier<JSC::Unknown> m_signal;
mutable JSC::WriteBarrier<JSC::Unknown> m_url;
    };

class JSResponse final : public JSC::JSDestructibleObject {
    public:
        using Base = JSC::JSDestructibleObject;
        static JSResponse* create(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure, void* ctx);
    
        DECLARE_EXPORT_INFO;
        template<typename, JSC::SubspaceAccess mode> static JSC::GCClient::IsoSubspace* subspaceFor(JSC::VM& vm)
        {
            if constexpr (mode == JSC::SubspaceAccess::Concurrently)
                return nullptr;
            return WebCore::subspaceForImpl<JSResponse, WebCore::UseCustomHeapCellType::No>(
                vm,
                [](auto& spaces) { return spaces.m_clientSubspaceForResponse.get(); },
                [](auto& spaces, auto&& space) { spaces.m_clientSubspaceForResponse = std::forward<decltype(space)>(space); },
                [](auto& spaces) { return spaces.m_subspaceForResponse.get(); },
                [](auto& spaces, auto&& space) { spaces.m_subspaceForResponse = std::forward<decltype(space)>(space); });
        }
    
        static void destroy(JSC::JSCell*);
        static JSC::Structure* createStructure(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::JSValue prototype)
        {
            return JSC::Structure::create(vm, globalObject, prototype, JSC::TypeInfo(static_cast<JSC::JSType>(0b11101110), StructureFlags), info());
        }
    
        static JSObject* createPrototype(VM& vm, JSDOMGlobalObject* globalObject);
        static JSObject* createConstructor(VM& vm, JSGlobalObject* globalObject, JSValue prototype);
    
        ~JSResponse();
    
        void* wrapped() const { return m_ctx; }
    
        void detach()
        {
            m_ctx = nullptr;
        }
    
        static void analyzeHeap(JSCell*, JSC::HeapAnalyzer&);
        static ptrdiff_t offsetOfWrapped() { return OBJECT_OFFSETOF(JSResponse, m_ctx); }
    
        void* m_ctx { nullptr };

            
        JSResponse(JSC::VM& vm, JSC::Structure* structure, void* sinkPtr)
            : Base(vm, structure)
        {
            m_ctx = sinkPtr;
            
        }
    
        void finishCreation(JSC::VM&);

        

        

        DECLARE_VISIT_CHILDREN;
template<typename Visitor> void visitAdditionalChildren(Visitor&);
DECLARE_VISIT_OUTPUT_CONSTRAINTS;


        mutable JSC::WriteBarrier<JSC::Unknown> m_body;
mutable JSC::WriteBarrier<JSC::Unknown> m_headers;
mutable JSC::WriteBarrier<JSC::Unknown> m_statusText;
mutable JSC::WriteBarrier<JSC::Unknown> m_url;
    };

class JSSHA1 final : public JSC::JSDestructibleObject {
    public:
        using Base = JSC::JSDestructibleObject;
        static JSSHA1* create(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure, void* ctx);
    
        DECLARE_EXPORT_INFO;
        template<typename, JSC::SubspaceAccess mode> static JSC::GCClient::IsoSubspace* subspaceFor(JSC::VM& vm)
        {
            if constexpr (mode == JSC::SubspaceAccess::Concurrently)
                return nullptr;
            return WebCore::subspaceForImpl<JSSHA1, WebCore::UseCustomHeapCellType::No>(
                vm,
                [](auto& spaces) { return spaces.m_clientSubspaceForSHA1.get(); },
                [](auto& spaces, auto&& space) { spaces.m_clientSubspaceForSHA1 = std::forward<decltype(space)>(space); },
                [](auto& spaces) { return spaces.m_subspaceForSHA1.get(); },
                [](auto& spaces, auto&& space) { spaces.m_subspaceForSHA1 = std::forward<decltype(space)>(space); });
        }
    
        static void destroy(JSC::JSCell*);
        static JSC::Structure* createStructure(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::JSValue prototype)
        {
            return JSC::Structure::create(vm, globalObject, prototype, JSC::TypeInfo(static_cast<JSC::JSType>(0b11101110), StructureFlags), info());
        }
    
        static JSObject* createPrototype(VM& vm, JSDOMGlobalObject* globalObject);
        static JSObject* createConstructor(VM& vm, JSGlobalObject* globalObject, JSValue prototype);
    
        ~JSSHA1();
    
        void* wrapped() const { return m_ctx; }
    
        void detach()
        {
            m_ctx = nullptr;
        }
    
        static void analyzeHeap(JSCell*, JSC::HeapAnalyzer&);
        static ptrdiff_t offsetOfWrapped() { return OBJECT_OFFSETOF(JSSHA1, m_ctx); }
    
        void* m_ctx { nullptr };

            
        JSSHA1(JSC::VM& vm, JSC::Structure* structure, void* sinkPtr)
            : Base(vm, structure)
        {
            m_ctx = sinkPtr;
            
        }
    
        void finishCreation(JSC::VM&);

        

        

        

        
    };

class JSSHA224 final : public JSC::JSDestructibleObject {
    public:
        using Base = JSC::JSDestructibleObject;
        static JSSHA224* create(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure, void* ctx);
    
        DECLARE_EXPORT_INFO;
        template<typename, JSC::SubspaceAccess mode> static JSC::GCClient::IsoSubspace* subspaceFor(JSC::VM& vm)
        {
            if constexpr (mode == JSC::SubspaceAccess::Concurrently)
                return nullptr;
            return WebCore::subspaceForImpl<JSSHA224, WebCore::UseCustomHeapCellType::No>(
                vm,
                [](auto& spaces) { return spaces.m_clientSubspaceForSHA224.get(); },
                [](auto& spaces, auto&& space) { spaces.m_clientSubspaceForSHA224 = std::forward<decltype(space)>(space); },
                [](auto& spaces) { return spaces.m_subspaceForSHA224.get(); },
                [](auto& spaces, auto&& space) { spaces.m_subspaceForSHA224 = std::forward<decltype(space)>(space); });
        }
    
        static void destroy(JSC::JSCell*);
        static JSC::Structure* createStructure(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::JSValue prototype)
        {
            return JSC::Structure::create(vm, globalObject, prototype, JSC::TypeInfo(static_cast<JSC::JSType>(0b11101110), StructureFlags), info());
        }
    
        static JSObject* createPrototype(VM& vm, JSDOMGlobalObject* globalObject);
        static JSObject* createConstructor(VM& vm, JSGlobalObject* globalObject, JSValue prototype);
    
        ~JSSHA224();
    
        void* wrapped() const { return m_ctx; }
    
        void detach()
        {
            m_ctx = nullptr;
        }
    
        static void analyzeHeap(JSCell*, JSC::HeapAnalyzer&);
        static ptrdiff_t offsetOfWrapped() { return OBJECT_OFFSETOF(JSSHA224, m_ctx); }
    
        void* m_ctx { nullptr };

            
        JSSHA224(JSC::VM& vm, JSC::Structure* structure, void* sinkPtr)
            : Base(vm, structure)
        {
            m_ctx = sinkPtr;
            
        }
    
        void finishCreation(JSC::VM&);

        

        

        

        
    };

class JSSHA256 final : public JSC::JSDestructibleObject {
    public:
        using Base = JSC::JSDestructibleObject;
        static JSSHA256* create(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure, void* ctx);
    
        DECLARE_EXPORT_INFO;
        template<typename, JSC::SubspaceAccess mode> static JSC::GCClient::IsoSubspace* subspaceFor(JSC::VM& vm)
        {
            if constexpr (mode == JSC::SubspaceAccess::Concurrently)
                return nullptr;
            return WebCore::subspaceForImpl<JSSHA256, WebCore::UseCustomHeapCellType::No>(
                vm,
                [](auto& spaces) { return spaces.m_clientSubspaceForSHA256.get(); },
                [](auto& spaces, auto&& space) { spaces.m_clientSubspaceForSHA256 = std::forward<decltype(space)>(space); },
                [](auto& spaces) { return spaces.m_subspaceForSHA256.get(); },
                [](auto& spaces, auto&& space) { spaces.m_subspaceForSHA256 = std::forward<decltype(space)>(space); });
        }
    
        static void destroy(JSC::JSCell*);
        static JSC::Structure* createStructure(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::JSValue prototype)
        {
            return JSC::Structure::create(vm, globalObject, prototype, JSC::TypeInfo(static_cast<JSC::JSType>(0b11101110), StructureFlags), info());
        }
    
        static JSObject* createPrototype(VM& vm, JSDOMGlobalObject* globalObject);
        static JSObject* createConstructor(VM& vm, JSGlobalObject* globalObject, JSValue prototype);
    
        ~JSSHA256();
    
        void* wrapped() const { return m_ctx; }
    
        void detach()
        {
            m_ctx = nullptr;
        }
    
        static void analyzeHeap(JSCell*, JSC::HeapAnalyzer&);
        static ptrdiff_t offsetOfWrapped() { return OBJECT_OFFSETOF(JSSHA256, m_ctx); }
    
        void* m_ctx { nullptr };

            
        JSSHA256(JSC::VM& vm, JSC::Structure* structure, void* sinkPtr)
            : Base(vm, structure)
        {
            m_ctx = sinkPtr;
            
        }
    
        void finishCreation(JSC::VM&);

        

        

        

        
    };

class JSSHA384 final : public JSC::JSDestructibleObject {
    public:
        using Base = JSC::JSDestructibleObject;
        static JSSHA384* create(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure, void* ctx);
    
        DECLARE_EXPORT_INFO;
        template<typename, JSC::SubspaceAccess mode> static JSC::GCClient::IsoSubspace* subspaceFor(JSC::VM& vm)
        {
            if constexpr (mode == JSC::SubspaceAccess::Concurrently)
                return nullptr;
            return WebCore::subspaceForImpl<JSSHA384, WebCore::UseCustomHeapCellType::No>(
                vm,
                [](auto& spaces) { return spaces.m_clientSubspaceForSHA384.get(); },
                [](auto& spaces, auto&& space) { spaces.m_clientSubspaceForSHA384 = std::forward<decltype(space)>(space); },
                [](auto& spaces) { return spaces.m_subspaceForSHA384.get(); },
                [](auto& spaces, auto&& space) { spaces.m_subspaceForSHA384 = std::forward<decltype(space)>(space); });
        }
    
        static void destroy(JSC::JSCell*);
        static JSC::Structure* createStructure(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::JSValue prototype)
        {
            return JSC::Structure::create(vm, globalObject, prototype, JSC::TypeInfo(static_cast<JSC::JSType>(0b11101110), StructureFlags), info());
        }
    
        static JSObject* createPrototype(VM& vm, JSDOMGlobalObject* globalObject);
        static JSObject* createConstructor(VM& vm, JSGlobalObject* globalObject, JSValue prototype);
    
        ~JSSHA384();
    
        void* wrapped() const { return m_ctx; }
    
        void detach()
        {
            m_ctx = nullptr;
        }
    
        static void analyzeHeap(JSCell*, JSC::HeapAnalyzer&);
        static ptrdiff_t offsetOfWrapped() { return OBJECT_OFFSETOF(JSSHA384, m_ctx); }
    
        void* m_ctx { nullptr };

            
        JSSHA384(JSC::VM& vm, JSC::Structure* structure, void* sinkPtr)
            : Base(vm, structure)
        {
            m_ctx = sinkPtr;
            
        }
    
        void finishCreation(JSC::VM&);

        

        

        

        
    };

class JSSHA512 final : public JSC::JSDestructibleObject {
    public:
        using Base = JSC::JSDestructibleObject;
        static JSSHA512* create(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure, void* ctx);
    
        DECLARE_EXPORT_INFO;
        template<typename, JSC::SubspaceAccess mode> static JSC::GCClient::IsoSubspace* subspaceFor(JSC::VM& vm)
        {
            if constexpr (mode == JSC::SubspaceAccess::Concurrently)
                return nullptr;
            return WebCore::subspaceForImpl<JSSHA512, WebCore::UseCustomHeapCellType::No>(
                vm,
                [](auto& spaces) { return spaces.m_clientSubspaceForSHA512.get(); },
                [](auto& spaces, auto&& space) { spaces.m_clientSubspaceForSHA512 = std::forward<decltype(space)>(space); },
                [](auto& spaces) { return spaces.m_subspaceForSHA512.get(); },
                [](auto& spaces, auto&& space) { spaces.m_subspaceForSHA512 = std::forward<decltype(space)>(space); });
        }
    
        static void destroy(JSC::JSCell*);
        static JSC::Structure* createStructure(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::JSValue prototype)
        {
            return JSC::Structure::create(vm, globalObject, prototype, JSC::TypeInfo(static_cast<JSC::JSType>(0b11101110), StructureFlags), info());
        }
    
        static JSObject* createPrototype(VM& vm, JSDOMGlobalObject* globalObject);
        static JSObject* createConstructor(VM& vm, JSGlobalObject* globalObject, JSValue prototype);
    
        ~JSSHA512();
    
        void* wrapped() const { return m_ctx; }
    
        void detach()
        {
            m_ctx = nullptr;
        }
    
        static void analyzeHeap(JSCell*, JSC::HeapAnalyzer&);
        static ptrdiff_t offsetOfWrapped() { return OBJECT_OFFSETOF(JSSHA512, m_ctx); }
    
        void* m_ctx { nullptr };

            
        JSSHA512(JSC::VM& vm, JSC::Structure* structure, void* sinkPtr)
            : Base(vm, structure)
        {
            m_ctx = sinkPtr;
            
        }
    
        void finishCreation(JSC::VM&);

        

        

        

        
    };

class JSSHA512_256 final : public JSC::JSDestructibleObject {
    public:
        using Base = JSC::JSDestructibleObject;
        static JSSHA512_256* create(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure, void* ctx);
    
        DECLARE_EXPORT_INFO;
        template<typename, JSC::SubspaceAccess mode> static JSC::GCClient::IsoSubspace* subspaceFor(JSC::VM& vm)
        {
            if constexpr (mode == JSC::SubspaceAccess::Concurrently)
                return nullptr;
            return WebCore::subspaceForImpl<JSSHA512_256, WebCore::UseCustomHeapCellType::No>(
                vm,
                [](auto& spaces) { return spaces.m_clientSubspaceForSHA512_256.get(); },
                [](auto& spaces, auto&& space) { spaces.m_clientSubspaceForSHA512_256 = std::forward<decltype(space)>(space); },
                [](auto& spaces) { return spaces.m_subspaceForSHA512_256.get(); },
                [](auto& spaces, auto&& space) { spaces.m_subspaceForSHA512_256 = std::forward<decltype(space)>(space); });
        }
    
        static void destroy(JSC::JSCell*);
        static JSC::Structure* createStructure(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::JSValue prototype)
        {
            return JSC::Structure::create(vm, globalObject, prototype, JSC::TypeInfo(static_cast<JSC::JSType>(0b11101110), StructureFlags), info());
        }
    
        static JSObject* createPrototype(VM& vm, JSDOMGlobalObject* globalObject);
        static JSObject* createConstructor(VM& vm, JSGlobalObject* globalObject, JSValue prototype);
    
        ~JSSHA512_256();
    
        void* wrapped() const { return m_ctx; }
    
        void detach()
        {
            m_ctx = nullptr;
        }
    
        static void analyzeHeap(JSCell*, JSC::HeapAnalyzer&);
        static ptrdiff_t offsetOfWrapped() { return OBJECT_OFFSETOF(JSSHA512_256, m_ctx); }
    
        void* m_ctx { nullptr };

            
        JSSHA512_256(JSC::VM& vm, JSC::Structure* structure, void* sinkPtr)
            : Base(vm, structure)
        {
            m_ctx = sinkPtr;
            
        }
    
        void finishCreation(JSC::VM&);

        

        

        

        
    };

class JSServerWebSocket final : public JSC::JSDestructibleObject {
    public:
        using Base = JSC::JSDestructibleObject;
        static JSServerWebSocket* create(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure, void* ctx);
    
        DECLARE_EXPORT_INFO;
        template<typename, JSC::SubspaceAccess mode> static JSC::GCClient::IsoSubspace* subspaceFor(JSC::VM& vm)
        {
            if constexpr (mode == JSC::SubspaceAccess::Concurrently)
                return nullptr;
            return WebCore::subspaceForImpl<JSServerWebSocket, WebCore::UseCustomHeapCellType::No>(
                vm,
                [](auto& spaces) { return spaces.m_clientSubspaceForServerWebSocket.get(); },
                [](auto& spaces, auto&& space) { spaces.m_clientSubspaceForServerWebSocket = std::forward<decltype(space)>(space); },
                [](auto& spaces) { return spaces.m_subspaceForServerWebSocket.get(); },
                [](auto& spaces, auto&& space) { spaces.m_subspaceForServerWebSocket = std::forward<decltype(space)>(space); });
        }
    
        static void destroy(JSC::JSCell*);
        static JSC::Structure* createStructure(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::JSValue prototype)
        {
            return JSC::Structure::create(vm, globalObject, prototype, JSC::TypeInfo(static_cast<JSC::JSType>(0b11101110), StructureFlags), info());
        }
    
        static JSObject* createPrototype(VM& vm, JSDOMGlobalObject* globalObject);
        static JSObject* createConstructor(VM& vm, JSGlobalObject* globalObject, JSValue prototype);
    
        ~JSServerWebSocket();
    
        void* wrapped() const { return m_ctx; }
    
        void detach()
        {
            m_ctx = nullptr;
        }
    
        static void analyzeHeap(JSCell*, JSC::HeapAnalyzer&);
        static ptrdiff_t offsetOfWrapped() { return OBJECT_OFFSETOF(JSServerWebSocket, m_ctx); }
    
        void* m_ctx { nullptr };

            
        JSServerWebSocket(JSC::VM& vm, JSC::Structure* structure, void* sinkPtr)
            : Base(vm, structure)
        {
            m_ctx = sinkPtr;
            
        }
    
        void finishCreation(JSC::VM&);

        

        

        DECLARE_VISIT_CHILDREN;
template<typename Visitor> void visitAdditionalChildren(Visitor&);
DECLARE_VISIT_OUTPUT_CONSTRAINTS;


        mutable JSC::WriteBarrier<JSC::Unknown> m_data;
mutable JSC::WriteBarrier<JSC::Unknown> m_remoteAddress;
    };

class JSStats final : public JSC::JSDestructibleObject {
    public:
        using Base = JSC::JSDestructibleObject;
        static JSStats* create(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure, void* ctx);
    
        DECLARE_EXPORT_INFO;
        template<typename, JSC::SubspaceAccess mode> static JSC::GCClient::IsoSubspace* subspaceFor(JSC::VM& vm)
        {
            if constexpr (mode == JSC::SubspaceAccess::Concurrently)
                return nullptr;
            return WebCore::subspaceForImpl<JSStats, WebCore::UseCustomHeapCellType::No>(
                vm,
                [](auto& spaces) { return spaces.m_clientSubspaceForStats.get(); },
                [](auto& spaces, auto&& space) { spaces.m_clientSubspaceForStats = std::forward<decltype(space)>(space); },
                [](auto& spaces) { return spaces.m_subspaceForStats.get(); },
                [](auto& spaces, auto&& space) { spaces.m_subspaceForStats = std::forward<decltype(space)>(space); });
        }
    
        static void destroy(JSC::JSCell*);
        static JSC::Structure* createStructure(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::JSValue prototype)
        {
            return JSC::Structure::create(vm, globalObject, prototype, JSC::TypeInfo(static_cast<JSC::JSType>(0b11101110), StructureFlags), info());
        }
    
        static JSObject* createPrototype(VM& vm, JSDOMGlobalObject* globalObject);
        static JSObject* createConstructor(VM& vm, JSGlobalObject* globalObject, JSValue prototype);
    
        ~JSStats();
    
        void* wrapped() const { return m_ctx; }
    
        void detach()
        {
            m_ctx = nullptr;
        }
    
        static void analyzeHeap(JSCell*, JSC::HeapAnalyzer&);
        static ptrdiff_t offsetOfWrapped() { return OBJECT_OFFSETOF(JSStats, m_ctx); }
    
        void* m_ctx { nullptr };

            
        JSStats(JSC::VM& vm, JSC::Structure* structure, void* sinkPtr)
            : Base(vm, structure)
        {
            m_ctx = sinkPtr;
            
        }
    
        void finishCreation(JSC::VM&);

        

        

        DECLARE_VISIT_CHILDREN;
template<typename Visitor> void visitAdditionalChildren(Visitor&);
DECLARE_VISIT_OUTPUT_CONSTRAINTS;


        mutable JSC::WriteBarrier<JSC::Unknown> m_atime;
mutable JSC::WriteBarrier<JSC::Unknown> m_ctime;
mutable JSC::WriteBarrier<JSC::Unknown> m_mtime;
    };

class JSSubprocess final : public JSC::JSDestructibleObject {
    public:
        using Base = JSC::JSDestructibleObject;
        static JSSubprocess* create(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure, void* ctx);
    
        DECLARE_EXPORT_INFO;
        template<typename, JSC::SubspaceAccess mode> static JSC::GCClient::IsoSubspace* subspaceFor(JSC::VM& vm)
        {
            if constexpr (mode == JSC::SubspaceAccess::Concurrently)
                return nullptr;
            return WebCore::subspaceForImpl<JSSubprocess, WebCore::UseCustomHeapCellType::No>(
                vm,
                [](auto& spaces) { return spaces.m_clientSubspaceForSubprocess.get(); },
                [](auto& spaces, auto&& space) { spaces.m_clientSubspaceForSubprocess = std::forward<decltype(space)>(space); },
                [](auto& spaces) { return spaces.m_subspaceForSubprocess.get(); },
                [](auto& spaces, auto&& space) { spaces.m_subspaceForSubprocess = std::forward<decltype(space)>(space); });
        }
    
        static void destroy(JSC::JSCell*);
        static JSC::Structure* createStructure(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::JSValue prototype)
        {
            return JSC::Structure::create(vm, globalObject, prototype, JSC::TypeInfo(static_cast<JSC::JSType>(0b11101110), StructureFlags), info());
        }
    
        static JSObject* createPrototype(VM& vm, JSDOMGlobalObject* globalObject);
        ;
    
        ~JSSubprocess();
    
        void* wrapped() const { return m_ctx; }
    
        void detach()
        {
            m_ctx = nullptr;
        }
    
        static void analyzeHeap(JSCell*, JSC::HeapAnalyzer&);
        static ptrdiff_t offsetOfWrapped() { return OBJECT_OFFSETOF(JSSubprocess, m_ctx); }
    
        void* m_ctx { nullptr };

            
        JSSubprocess(JSC::VM& vm, JSC::Structure* structure, void* sinkPtr)
            : Base(vm, structure)
        {
            m_ctx = sinkPtr;
            m_weakThis = JSC::Weak<JSSubprocess>(this, getOwner());
        }
    
        void finishCreation(JSC::VM&);

        

        
    JSC::Weak<JSSubprocess> m_weakThis;
   

    static bool hasPendingActivity(void* ctx);

    class Owner final : public JSC::WeakHandleOwner {
      public:
          bool isReachableFromOpaqueRoots(JSC::Handle<JSC::Unknown> handle, void* context, JSC::AbstractSlotVisitor& visitor, const char** reason) final
          {
              auto* controller = JSC::jsCast<JSSubprocess*>(handle.slot()->asCell());
              if (JSSubprocess::hasPendingActivity(controller->wrapped())) {
                  if (UNLIKELY(reason))
                    *reason = "has pending activity";
                  return true;
              }

              return visitor.containsOpaqueRoot(context);
          }
          void finalize(JSC::Handle<JSC::Unknown>, void* context) final {}
      };
  
      static JSC::WeakHandleOwner* getOwner()
      {
          static NeverDestroyed<Owner> m_owner;
          return &m_owner.get();
      }
      

        DECLARE_VISIT_CHILDREN;
template<typename Visitor> void visitAdditionalChildren(Visitor&);
DECLARE_VISIT_OUTPUT_CONSTRAINTS;


        mutable JSC::WriteBarrier<JSC::Unknown> m_stderr;
mutable JSC::WriteBarrier<JSC::Unknown> m_stdin;
mutable JSC::WriteBarrier<JSC::Unknown> m_stdout;
    };

class JSTCPSocket final : public JSC::JSDestructibleObject {
    public:
        using Base = JSC::JSDestructibleObject;
        static JSTCPSocket* create(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure, void* ctx);
    
        DECLARE_EXPORT_INFO;
        template<typename, JSC::SubspaceAccess mode> static JSC::GCClient::IsoSubspace* subspaceFor(JSC::VM& vm)
        {
            if constexpr (mode == JSC::SubspaceAccess::Concurrently)
                return nullptr;
            return WebCore::subspaceForImpl<JSTCPSocket, WebCore::UseCustomHeapCellType::No>(
                vm,
                [](auto& spaces) { return spaces.m_clientSubspaceForTCPSocket.get(); },
                [](auto& spaces, auto&& space) { spaces.m_clientSubspaceForTCPSocket = std::forward<decltype(space)>(space); },
                [](auto& spaces) { return spaces.m_subspaceForTCPSocket.get(); },
                [](auto& spaces, auto&& space) { spaces.m_subspaceForTCPSocket = std::forward<decltype(space)>(space); });
        }
    
        static void destroy(JSC::JSCell*);
        static JSC::Structure* createStructure(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::JSValue prototype)
        {
            return JSC::Structure::create(vm, globalObject, prototype, JSC::TypeInfo(static_cast<JSC::JSType>(0b11101110), StructureFlags), info());
        }
    
        static JSObject* createPrototype(VM& vm, JSDOMGlobalObject* globalObject);
        ;
    
        ~JSTCPSocket();
    
        void* wrapped() const { return m_ctx; }
    
        void detach()
        {
            m_ctx = nullptr;
        }
    
        static void analyzeHeap(JSCell*, JSC::HeapAnalyzer&);
        static ptrdiff_t offsetOfWrapped() { return OBJECT_OFFSETOF(JSTCPSocket, m_ctx); }
    
        void* m_ctx { nullptr };

            
        JSTCPSocket(JSC::VM& vm, JSC::Structure* structure, void* sinkPtr)
            : Base(vm, structure)
        {
            m_ctx = sinkPtr;
            m_weakThis = JSC::Weak<JSTCPSocket>(this, getOwner());
        }
    
        void finishCreation(JSC::VM&);

        

        
    JSC::Weak<JSTCPSocket> m_weakThis;
   

    static bool hasPendingActivity(void* ctx);

    class Owner final : public JSC::WeakHandleOwner {
      public:
          bool isReachableFromOpaqueRoots(JSC::Handle<JSC::Unknown> handle, void* context, JSC::AbstractSlotVisitor& visitor, const char** reason) final
          {
              auto* controller = JSC::jsCast<JSTCPSocket*>(handle.slot()->asCell());
              if (JSTCPSocket::hasPendingActivity(controller->wrapped())) {
                  if (UNLIKELY(reason))
                    *reason = "has pending activity";
                  return true;
              }

              return visitor.containsOpaqueRoot(context);
          }
          void finalize(JSC::Handle<JSC::Unknown>, void* context) final {}
      };
  
      static JSC::WeakHandleOwner* getOwner()
      {
          static NeverDestroyed<Owner> m_owner;
          return &m_owner.get();
      }
      

        DECLARE_VISIT_CHILDREN;
template<typename Visitor> void visitAdditionalChildren(Visitor&);
DECLARE_VISIT_OUTPUT_CONSTRAINTS;


        mutable JSC::WriteBarrier<JSC::Unknown> m_data;
mutable JSC::WriteBarrier<JSC::Unknown> m_remoteAddress;
    };

class JSTLSSocket final : public JSC::JSDestructibleObject {
    public:
        using Base = JSC::JSDestructibleObject;
        static JSTLSSocket* create(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure, void* ctx);
    
        DECLARE_EXPORT_INFO;
        template<typename, JSC::SubspaceAccess mode> static JSC::GCClient::IsoSubspace* subspaceFor(JSC::VM& vm)
        {
            if constexpr (mode == JSC::SubspaceAccess::Concurrently)
                return nullptr;
            return WebCore::subspaceForImpl<JSTLSSocket, WebCore::UseCustomHeapCellType::No>(
                vm,
                [](auto& spaces) { return spaces.m_clientSubspaceForTLSSocket.get(); },
                [](auto& spaces, auto&& space) { spaces.m_clientSubspaceForTLSSocket = std::forward<decltype(space)>(space); },
                [](auto& spaces) { return spaces.m_subspaceForTLSSocket.get(); },
                [](auto& spaces, auto&& space) { spaces.m_subspaceForTLSSocket = std::forward<decltype(space)>(space); });
        }
    
        static void destroy(JSC::JSCell*);
        static JSC::Structure* createStructure(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::JSValue prototype)
        {
            return JSC::Structure::create(vm, globalObject, prototype, JSC::TypeInfo(static_cast<JSC::JSType>(0b11101110), StructureFlags), info());
        }
    
        static JSObject* createPrototype(VM& vm, JSDOMGlobalObject* globalObject);
        ;
    
        ~JSTLSSocket();
    
        void* wrapped() const { return m_ctx; }
    
        void detach()
        {
            m_ctx = nullptr;
        }
    
        static void analyzeHeap(JSCell*, JSC::HeapAnalyzer&);
        static ptrdiff_t offsetOfWrapped() { return OBJECT_OFFSETOF(JSTLSSocket, m_ctx); }
    
        void* m_ctx { nullptr };

            
        JSTLSSocket(JSC::VM& vm, JSC::Structure* structure, void* sinkPtr)
            : Base(vm, structure)
        {
            m_ctx = sinkPtr;
            m_weakThis = JSC::Weak<JSTLSSocket>(this, getOwner());
        }
    
        void finishCreation(JSC::VM&);

        

        
    JSC::Weak<JSTLSSocket> m_weakThis;
   

    static bool hasPendingActivity(void* ctx);

    class Owner final : public JSC::WeakHandleOwner {
      public:
          bool isReachableFromOpaqueRoots(JSC::Handle<JSC::Unknown> handle, void* context, JSC::AbstractSlotVisitor& visitor, const char** reason) final
          {
              auto* controller = JSC::jsCast<JSTLSSocket*>(handle.slot()->asCell());
              if (JSTLSSocket::hasPendingActivity(controller->wrapped())) {
                  if (UNLIKELY(reason))
                    *reason = "has pending activity";
                  return true;
              }

              return visitor.containsOpaqueRoot(context);
          }
          void finalize(JSC::Handle<JSC::Unknown>, void* context) final {}
      };
  
      static JSC::WeakHandleOwner* getOwner()
      {
          static NeverDestroyed<Owner> m_owner;
          return &m_owner.get();
      }
      

        DECLARE_VISIT_CHILDREN;
template<typename Visitor> void visitAdditionalChildren(Visitor&);
DECLARE_VISIT_OUTPUT_CONSTRAINTS;


        mutable JSC::WriteBarrier<JSC::Unknown> m_data;
mutable JSC::WriteBarrier<JSC::Unknown> m_remoteAddress;
    };

class JSTextDecoder final : public JSC::JSDestructibleObject {
    public:
        using Base = JSC::JSDestructibleObject;
        static JSTextDecoder* create(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure, void* ctx);
    
        DECLARE_EXPORT_INFO;
        template<typename, JSC::SubspaceAccess mode> static JSC::GCClient::IsoSubspace* subspaceFor(JSC::VM& vm)
        {
            if constexpr (mode == JSC::SubspaceAccess::Concurrently)
                return nullptr;
            return WebCore::subspaceForImpl<JSTextDecoder, WebCore::UseCustomHeapCellType::No>(
                vm,
                [](auto& spaces) { return spaces.m_clientSubspaceForTextDecoder.get(); },
                [](auto& spaces, auto&& space) { spaces.m_clientSubspaceForTextDecoder = std::forward<decltype(space)>(space); },
                [](auto& spaces) { return spaces.m_subspaceForTextDecoder.get(); },
                [](auto& spaces, auto&& space) { spaces.m_subspaceForTextDecoder = std::forward<decltype(space)>(space); });
        }
    
        static void destroy(JSC::JSCell*);
        static JSC::Structure* createStructure(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::JSValue prototype)
        {
            return JSC::Structure::create(vm, globalObject, prototype, JSC::TypeInfo(static_cast<JSC::JSType>(0b11101110), StructureFlags), info());
        }
    
        static JSObject* createPrototype(VM& vm, JSDOMGlobalObject* globalObject);
        static JSObject* createConstructor(VM& vm, JSGlobalObject* globalObject, JSValue prototype);
    
        ~JSTextDecoder();
    
        void* wrapped() const { return m_ctx; }
    
        void detach()
        {
            m_ctx = nullptr;
        }
    
        static void analyzeHeap(JSCell*, JSC::HeapAnalyzer&);
        static ptrdiff_t offsetOfWrapped() { return OBJECT_OFFSETOF(JSTextDecoder, m_ctx); }
    
        void* m_ctx { nullptr };

            
        JSTextDecoder(JSC::VM& vm, JSC::Structure* structure, void* sinkPtr)
            : Base(vm, structure)
        {
            m_ctx = sinkPtr;
            
        }
    
        void finishCreation(JSC::VM&);

        

        

        DECLARE_VISIT_CHILDREN;
template<typename Visitor> void visitAdditionalChildren(Visitor&);
DECLARE_VISIT_OUTPUT_CONSTRAINTS;


        mutable JSC::WriteBarrier<JSC::Unknown> m_encoding;
    };

class JSTimeout final : public JSC::JSDestructibleObject {
    public:
        using Base = JSC::JSDestructibleObject;
        static JSTimeout* create(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure, void* ctx);
    
        DECLARE_EXPORT_INFO;
        template<typename, JSC::SubspaceAccess mode> static JSC::GCClient::IsoSubspace* subspaceFor(JSC::VM& vm)
        {
            if constexpr (mode == JSC::SubspaceAccess::Concurrently)
                return nullptr;
            return WebCore::subspaceForImpl<JSTimeout, WebCore::UseCustomHeapCellType::No>(
                vm,
                [](auto& spaces) { return spaces.m_clientSubspaceForTimeout.get(); },
                [](auto& spaces, auto&& space) { spaces.m_clientSubspaceForTimeout = std::forward<decltype(space)>(space); },
                [](auto& spaces) { return spaces.m_subspaceForTimeout.get(); },
                [](auto& spaces, auto&& space) { spaces.m_subspaceForTimeout = std::forward<decltype(space)>(space); });
        }
    
        static void destroy(JSC::JSCell*);
        static JSC::Structure* createStructure(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::JSValue prototype)
        {
            return JSC::Structure::create(vm, globalObject, prototype, JSC::TypeInfo(static_cast<JSC::JSType>(0b11101110), StructureFlags), info());
        }
    
        static JSObject* createPrototype(VM& vm, JSDOMGlobalObject* globalObject);
        ;
    
        ~JSTimeout();
    
        void* wrapped() const { return m_ctx; }
    
        void detach()
        {
            m_ctx = nullptr;
        }
    
        static void analyzeHeap(JSCell*, JSC::HeapAnalyzer&);
        static ptrdiff_t offsetOfWrapped() { return OBJECT_OFFSETOF(JSTimeout, m_ctx); }
    
        void* m_ctx { nullptr };

            
        JSTimeout(JSC::VM& vm, JSC::Structure* structure, void* sinkPtr)
            : Base(vm, structure)
        {
            m_ctx = sinkPtr;
            
        }
    
        void finishCreation(JSC::VM&);

        

        

        

        
    };

class JSTranspiler final : public JSC::JSDestructibleObject {
    public:
        using Base = JSC::JSDestructibleObject;
        static JSTranspiler* create(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure, void* ctx);
    
        DECLARE_EXPORT_INFO;
        template<typename, JSC::SubspaceAccess mode> static JSC::GCClient::IsoSubspace* subspaceFor(JSC::VM& vm)
        {
            if constexpr (mode == JSC::SubspaceAccess::Concurrently)
                return nullptr;
            return WebCore::subspaceForImpl<JSTranspiler, WebCore::UseCustomHeapCellType::No>(
                vm,
                [](auto& spaces) { return spaces.m_clientSubspaceForTranspiler.get(); },
                [](auto& spaces, auto&& space) { spaces.m_clientSubspaceForTranspiler = std::forward<decltype(space)>(space); },
                [](auto& spaces) { return spaces.m_subspaceForTranspiler.get(); },
                [](auto& spaces, auto&& space) { spaces.m_subspaceForTranspiler = std::forward<decltype(space)>(space); });
        }
    
        static void destroy(JSC::JSCell*);
        static JSC::Structure* createStructure(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::JSValue prototype)
        {
            return JSC::Structure::create(vm, globalObject, prototype, JSC::TypeInfo(static_cast<JSC::JSType>(0b11101110), StructureFlags), info());
        }
    
        static JSObject* createPrototype(VM& vm, JSDOMGlobalObject* globalObject);
        static JSObject* createConstructor(VM& vm, JSGlobalObject* globalObject, JSValue prototype);
    
        ~JSTranspiler();
    
        void* wrapped() const { return m_ctx; }
    
        void detach()
        {
            m_ctx = nullptr;
        }
    
        static void analyzeHeap(JSCell*, JSC::HeapAnalyzer&);
        static ptrdiff_t offsetOfWrapped() { return OBJECT_OFFSETOF(JSTranspiler, m_ctx); }
    
        void* m_ctx { nullptr };

            
        JSTranspiler(JSC::VM& vm, JSC::Structure* structure, void* sinkPtr)
            : Base(vm, structure)
        {
            m_ctx = sinkPtr;
            
        }
    
        void finishCreation(JSC::VM&);

        WTF::Vector<std::unique_ptr<BunPlugin::OnLoad>> onLoadPlugins;
WTF::Vector<std::unique_ptr<BunPlugin::OnResolve>> onResolvePlugins;

        

        

        
    };


}

