
// GENERATED CODE - DO NOT MODIFY BY HAND
// Generated by make codegen
#pragma once

#include "root.h"

namespace Zig {
}

#include "JSDOMWrapper.h"
#include <wtf/NeverDestroyed.h>

namespace WebCore {
using namespace Zig;
using namespace JSC;

class JSTCPSocket final : public JSC::JSDestructibleObject {
public:
    using Base = JSC::JSDestructibleObject;
    static JSTCPSocket* create(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure, void* ctx);

    DECLARE_EXPORT_INFO;
    template<typename, JSC::SubspaceAccess mode> static JSC::GCClient::IsoSubspace* subspaceFor(JSC::VM& vm)
    {
        if constexpr (mode == JSC::SubspaceAccess::Concurrently)
            return nullptr;
        return WebCore::subspaceForImpl<JSTCPSocket, WebCore::UseCustomHeapCellType::No>(
            vm,
            [](auto& spaces) { return spaces.m_clientSubspaceForTCPSocket.get(); },
            [](auto& spaces, auto&& space) { spaces.m_clientSubspaceForTCPSocket = WTFMove(space); },
            [](auto& spaces) { return spaces.m_subspaceForTCPSocket.get(); },
            [](auto& spaces, auto&& space) { spaces.m_subspaceForTCPSocket = WTFMove(space); });
    }

    static void destroy(JSC::JSCell*);
    static JSC::Structure* createStructure(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::JSValue prototype)
    {
        return JSC::Structure::create(vm, globalObject, prototype, JSC::TypeInfo(static_cast<JSC::JSType>(0b11101110), StructureFlags), info());
    }

    static JSObject* createPrototype(VM& vm, JSDOMGlobalObject* globalObject);
    ;

    ~JSTCPSocket();

    void* wrapped() const { return m_ctx; }

    void detach()
    {
        m_ctx = nullptr;
    }

    static void analyzeHeap(JSCell*, JSC::HeapAnalyzer&);
    static ptrdiff_t offsetOfWrapped() { return OBJECT_OFFSETOF(JSTCPSocket, m_ctx); }

    void* m_ctx { nullptr };

    JSTCPSocket(JSC::VM& vm, JSC::Structure* structure, void* sinkPtr)
        : Base(vm, structure)
    {
        m_ctx = sinkPtr;
        m_weakThis = JSC::Weak<JSTCPSocket>(this, getOwner());
    }

    void finishCreation(JSC::VM&);

    JSC::Weak<JSTCPSocket> m_weakThis;

    static bool hasPendingActivity(void* ctx);

    class Owner final : public JSC::WeakHandleOwner {
    public:
        bool isReachableFromOpaqueRoots(JSC::Handle<JSC::Unknown> handle, void* context, JSC::AbstractSlotVisitor& visitor, const char** reason) final
        {
            auto* controller = JSC::jsCast<JSTCPSocket*>(handle.slot()->asCell());
            if (JSTCPSocket::hasPendingActivity(controller->wrapped())) {
                if (UNLIKELY(reason))
                    *reason = "has pending activity";
                return true;
            }

            return visitor.containsOpaqueRoot(context);
        }
        void finalize(JSC::Handle<JSC::Unknown>, void* context) final {}
    };

    static JSC::WeakHandleOwner* getOwner()
    {
        static NeverDestroyed<Owner> m_owner;
        return &m_owner.get();
    }

    DECLARE_VISIT_CHILDREN;
    template<typename Visitor> void visitAdditionalChildren(Visitor&);
    DECLARE_VISIT_OUTPUT_CONSTRAINTS;

    mutable JSC::WriteBarrier<JSC::Unknown> m_data;
    mutable JSC::WriteBarrier<JSC::Unknown> m_remoteAddress;
};

class JSTLSSocket final : public JSC::JSDestructibleObject {
public:
    using Base = JSC::JSDestructibleObject;
    static JSTLSSocket* create(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure, void* ctx);

    DECLARE_EXPORT_INFO;
    template<typename, JSC::SubspaceAccess mode> static JSC::GCClient::IsoSubspace* subspaceFor(JSC::VM& vm)
    {
        if constexpr (mode == JSC::SubspaceAccess::Concurrently)
            return nullptr;
        return WebCore::subspaceForImpl<JSTLSSocket, WebCore::UseCustomHeapCellType::No>(
            vm,
            [](auto& spaces) { return spaces.m_clientSubspaceForTLSSocket.get(); },
            [](auto& spaces, auto&& space) { spaces.m_clientSubspaceForTLSSocket = WTFMove(space); },
            [](auto& spaces) { return spaces.m_subspaceForTLSSocket.get(); },
            [](auto& spaces, auto&& space) { spaces.m_subspaceForTLSSocket = WTFMove(space); });
    }

    static void destroy(JSC::JSCell*);
    static JSC::Structure* createStructure(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::JSValue prototype)
    {
        return JSC::Structure::create(vm, globalObject, prototype, JSC::TypeInfo(static_cast<JSC::JSType>(0b11101110), StructureFlags), info());
    }

    static JSObject* createPrototype(VM& vm, JSDOMGlobalObject* globalObject);
    ;

    ~JSTLSSocket();

    void* wrapped() const { return m_ctx; }

    void detach()
    {
        m_ctx = nullptr;
    }

    static void analyzeHeap(JSCell*, JSC::HeapAnalyzer&);
    static ptrdiff_t offsetOfWrapped() { return OBJECT_OFFSETOF(JSTLSSocket, m_ctx); }

    void* m_ctx { nullptr };

    JSTLSSocket(JSC::VM& vm, JSC::Structure* structure, void* sinkPtr)
        : Base(vm, structure)
    {
        m_ctx = sinkPtr;
        m_weakThis = JSC::Weak<JSTLSSocket>(this, getOwner());
    }

    void finishCreation(JSC::VM&);

    JSC::Weak<JSTLSSocket> m_weakThis;

    static bool hasPendingActivity(void* ctx);

    class Owner final : public JSC::WeakHandleOwner {
    public:
        bool isReachableFromOpaqueRoots(JSC::Handle<JSC::Unknown> handle, void* context, JSC::AbstractSlotVisitor& visitor, const char** reason) final
        {
            auto* controller = JSC::jsCast<JSTLSSocket*>(handle.slot()->asCell());
            if (JSTLSSocket::hasPendingActivity(controller->wrapped())) {
                if (UNLIKELY(reason))
                    *reason = "has pending activity";
                return true;
            }

            return visitor.containsOpaqueRoot(context);
        }
        void finalize(JSC::Handle<JSC::Unknown>, void* context) final {}
    };

    static JSC::WeakHandleOwner* getOwner()
    {
        static NeverDestroyed<Owner> m_owner;
        return &m_owner.get();
    }

    DECLARE_VISIT_CHILDREN;
    template<typename Visitor> void visitAdditionalChildren(Visitor&);
    DECLARE_VISIT_OUTPUT_CONSTRAINTS;

    mutable JSC::WriteBarrier<JSC::Unknown> m_data;
    mutable JSC::WriteBarrier<JSC::Unknown> m_remoteAddress;
};

class JSListener final : public JSC::JSDestructibleObject {
public:
    using Base = JSC::JSDestructibleObject;
    static JSListener* create(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure, void* ctx);

    DECLARE_EXPORT_INFO;
    template<typename, JSC::SubspaceAccess mode> static JSC::GCClient::IsoSubspace* subspaceFor(JSC::VM& vm)
    {
        if constexpr (mode == JSC::SubspaceAccess::Concurrently)
            return nullptr;
        return WebCore::subspaceForImpl<JSListener, WebCore::UseCustomHeapCellType::No>(
            vm,
            [](auto& spaces) { return spaces.m_clientSubspaceForListener.get(); },
            [](auto& spaces, auto&& space) { spaces.m_clientSubspaceForListener = WTFMove(space); },
            [](auto& spaces) { return spaces.m_subspaceForListener.get(); },
            [](auto& spaces, auto&& space) { spaces.m_subspaceForListener = WTFMove(space); });
    }

    static void destroy(JSC::JSCell*);
    static JSC::Structure* createStructure(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::JSValue prototype)
    {
        return JSC::Structure::create(vm, globalObject, prototype, JSC::TypeInfo(static_cast<JSC::JSType>(0b11101110), StructureFlags), info());
    }

    static JSObject* createPrototype(VM& vm, JSDOMGlobalObject* globalObject);
    ;

    ~JSListener();

    void* wrapped() const { return m_ctx; }

    void detach()
    {
        m_ctx = nullptr;
    }

    static void analyzeHeap(JSCell*, JSC::HeapAnalyzer&);
    static ptrdiff_t offsetOfWrapped() { return OBJECT_OFFSETOF(JSListener, m_ctx); }

    void* m_ctx { nullptr };

    JSListener(JSC::VM& vm, JSC::Structure* structure, void* sinkPtr)
        : Base(vm, structure)
    {
        m_ctx = sinkPtr;
    }

    void finishCreation(JSC::VM&);

    DECLARE_VISIT_CHILDREN;
    template<typename Visitor> void visitAdditionalChildren(Visitor&);
    DECLARE_VISIT_OUTPUT_CONSTRAINTS;

    mutable JSC::WriteBarrier<JSC::Unknown> m_hostname;
    mutable JSC::WriteBarrier<JSC::Unknown> m_unix;
};

class JSSubprocess final : public JSC::JSDestructibleObject {
public:
    using Base = JSC::JSDestructibleObject;
    static JSSubprocess* create(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure, void* ctx);

    DECLARE_EXPORT_INFO;
    template<typename, JSC::SubspaceAccess mode> static JSC::GCClient::IsoSubspace* subspaceFor(JSC::VM& vm)
    {
        if constexpr (mode == JSC::SubspaceAccess::Concurrently)
            return nullptr;
        return WebCore::subspaceForImpl<JSSubprocess, WebCore::UseCustomHeapCellType::No>(
            vm,
            [](auto& spaces) { return spaces.m_clientSubspaceForSubprocess.get(); },
            [](auto& spaces, auto&& space) { spaces.m_clientSubspaceForSubprocess = WTFMove(space); },
            [](auto& spaces) { return spaces.m_subspaceForSubprocess.get(); },
            [](auto& spaces, auto&& space) { spaces.m_subspaceForSubprocess = WTFMove(space); });
    }

    static void destroy(JSC::JSCell*);
    static JSC::Structure* createStructure(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::JSValue prototype)
    {
        return JSC::Structure::create(vm, globalObject, prototype, JSC::TypeInfo(static_cast<JSC::JSType>(0b11101110), StructureFlags), info());
    }

    static JSObject* createPrototype(VM& vm, JSDOMGlobalObject* globalObject);
    ;

    ~JSSubprocess();

    void* wrapped() const { return m_ctx; }

    void detach()
    {
        m_ctx = nullptr;
    }

    static void analyzeHeap(JSCell*, JSC::HeapAnalyzer&);
    static ptrdiff_t offsetOfWrapped() { return OBJECT_OFFSETOF(JSSubprocess, m_ctx); }

    void* m_ctx { nullptr };

    JSSubprocess(JSC::VM& vm, JSC::Structure* structure, void* sinkPtr)
        : Base(vm, structure)
    {
        m_ctx = sinkPtr;
        m_weakThis = JSC::Weak<JSSubprocess>(this, getOwner());
    }

    void finishCreation(JSC::VM&);

    JSC::Weak<JSSubprocess> m_weakThis;

    static bool hasPendingActivity(void* ctx);

    class Owner final : public JSC::WeakHandleOwner {
    public:
        bool isReachableFromOpaqueRoots(JSC::Handle<JSC::Unknown> handle, void* context, JSC::AbstractSlotVisitor& visitor, const char** reason) final
        {
            auto* controller = JSC::jsCast<JSSubprocess*>(handle.slot()->asCell());
            if (JSSubprocess::hasPendingActivity(controller->wrapped())) {
                if (UNLIKELY(reason))
                    *reason = "has pending activity";
                return true;
            }

            return visitor.containsOpaqueRoot(context);
        }
        void finalize(JSC::Handle<JSC::Unknown>, void* context) final {}
    };

    static JSC::WeakHandleOwner* getOwner()
    {
        static NeverDestroyed<Owner> m_owner;
        return &m_owner.get();
    }

    DECLARE_VISIT_CHILDREN;
    template<typename Visitor> void visitAdditionalChildren(Visitor&);
    DECLARE_VISIT_OUTPUT_CONSTRAINTS;

    mutable JSC::WriteBarrier<JSC::Unknown> m_stderr;
    mutable JSC::WriteBarrier<JSC::Unknown> m_stdin;
    mutable JSC::WriteBarrier<JSC::Unknown> m_stdout;
};

class JSSHA1 final : public JSC::JSDestructibleObject {
public:
    using Base = JSC::JSDestructibleObject;
    static JSSHA1* create(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure, void* ctx);

    DECLARE_EXPORT_INFO;
    template<typename, JSC::SubspaceAccess mode> static JSC::GCClient::IsoSubspace* subspaceFor(JSC::VM& vm)
    {
        if constexpr (mode == JSC::SubspaceAccess::Concurrently)
            return nullptr;
        return WebCore::subspaceForImpl<JSSHA1, WebCore::UseCustomHeapCellType::No>(
            vm,
            [](auto& spaces) { return spaces.m_clientSubspaceForSHA1.get(); },
            [](auto& spaces, auto&& space) { spaces.m_clientSubspaceForSHA1 = WTFMove(space); },
            [](auto& spaces) { return spaces.m_subspaceForSHA1.get(); },
            [](auto& spaces, auto&& space) { spaces.m_subspaceForSHA1 = WTFMove(space); });
    }

    static void destroy(JSC::JSCell*);
    static JSC::Structure* createStructure(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::JSValue prototype)
    {
        return JSC::Structure::create(vm, globalObject, prototype, JSC::TypeInfo(static_cast<JSC::JSType>(0b11101110), StructureFlags), info());
    }

    static JSObject* createPrototype(VM& vm, JSDOMGlobalObject* globalObject);
    static JSObject* createConstructor(VM& vm, JSGlobalObject* globalObject, JSValue prototype);

    ~JSSHA1();

    void* wrapped() const { return m_ctx; }

    void detach()
    {
        m_ctx = nullptr;
    }

    static void analyzeHeap(JSCell*, JSC::HeapAnalyzer&);
    static ptrdiff_t offsetOfWrapped() { return OBJECT_OFFSETOF(JSSHA1, m_ctx); }

    void* m_ctx { nullptr };

    JSSHA1(JSC::VM& vm, JSC::Structure* structure, void* sinkPtr)
        : Base(vm, structure)
    {
        m_ctx = sinkPtr;
    }

    void finishCreation(JSC::VM&);
};

class JSMD5 final : public JSC::JSDestructibleObject {
public:
    using Base = JSC::JSDestructibleObject;
    static JSMD5* create(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure, void* ctx);

    DECLARE_EXPORT_INFO;
    template<typename, JSC::SubspaceAccess mode> static JSC::GCClient::IsoSubspace* subspaceFor(JSC::VM& vm)
    {
        if constexpr (mode == JSC::SubspaceAccess::Concurrently)
            return nullptr;
        return WebCore::subspaceForImpl<JSMD5, WebCore::UseCustomHeapCellType::No>(
            vm,
            [](auto& spaces) { return spaces.m_clientSubspaceForMD5.get(); },
            [](auto& spaces, auto&& space) { spaces.m_clientSubspaceForMD5 = WTFMove(space); },
            [](auto& spaces) { return spaces.m_subspaceForMD5.get(); },
            [](auto& spaces, auto&& space) { spaces.m_subspaceForMD5 = WTFMove(space); });
    }

    static void destroy(JSC::JSCell*);
    static JSC::Structure* createStructure(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::JSValue prototype)
    {
        return JSC::Structure::create(vm, globalObject, prototype, JSC::TypeInfo(static_cast<JSC::JSType>(0b11101110), StructureFlags), info());
    }

    static JSObject* createPrototype(VM& vm, JSDOMGlobalObject* globalObject);
    static JSObject* createConstructor(VM& vm, JSGlobalObject* globalObject, JSValue prototype);

    ~JSMD5();

    void* wrapped() const { return m_ctx; }

    void detach()
    {
        m_ctx = nullptr;
    }

    static void analyzeHeap(JSCell*, JSC::HeapAnalyzer&);
    static ptrdiff_t offsetOfWrapped() { return OBJECT_OFFSETOF(JSMD5, m_ctx); }

    void* m_ctx { nullptr };

    JSMD5(JSC::VM& vm, JSC::Structure* structure, void* sinkPtr)
        : Base(vm, structure)
    {
        m_ctx = sinkPtr;
    }

    void finishCreation(JSC::VM&);
};

class JSMD4 final : public JSC::JSDestructibleObject {
public:
    using Base = JSC::JSDestructibleObject;
    static JSMD4* create(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure, void* ctx);

    DECLARE_EXPORT_INFO;
    template<typename, JSC::SubspaceAccess mode> static JSC::GCClient::IsoSubspace* subspaceFor(JSC::VM& vm)
    {
        if constexpr (mode == JSC::SubspaceAccess::Concurrently)
            return nullptr;
        return WebCore::subspaceForImpl<JSMD4, WebCore::UseCustomHeapCellType::No>(
            vm,
            [](auto& spaces) { return spaces.m_clientSubspaceForMD4.get(); },
            [](auto& spaces, auto&& space) { spaces.m_clientSubspaceForMD4 = WTFMove(space); },
            [](auto& spaces) { return spaces.m_subspaceForMD4.get(); },
            [](auto& spaces, auto&& space) { spaces.m_subspaceForMD4 = WTFMove(space); });
    }

    static void destroy(JSC::JSCell*);
    static JSC::Structure* createStructure(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::JSValue prototype)
    {
        return JSC::Structure::create(vm, globalObject, prototype, JSC::TypeInfo(static_cast<JSC::JSType>(0b11101110), StructureFlags), info());
    }

    static JSObject* createPrototype(VM& vm, JSDOMGlobalObject* globalObject);
    static JSObject* createConstructor(VM& vm, JSGlobalObject* globalObject, JSValue prototype);

    ~JSMD4();

    void* wrapped() const { return m_ctx; }

    void detach()
    {
        m_ctx = nullptr;
    }

    static void analyzeHeap(JSCell*, JSC::HeapAnalyzer&);
    static ptrdiff_t offsetOfWrapped() { return OBJECT_OFFSETOF(JSMD4, m_ctx); }

    void* m_ctx { nullptr };

    JSMD4(JSC::VM& vm, JSC::Structure* structure, void* sinkPtr)
        : Base(vm, structure)
    {
        m_ctx = sinkPtr;
    }

    void finishCreation(JSC::VM&);
};

class JSSHA224 final : public JSC::JSDestructibleObject {
public:
    using Base = JSC::JSDestructibleObject;
    static JSSHA224* create(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure, void* ctx);

    DECLARE_EXPORT_INFO;
    template<typename, JSC::SubspaceAccess mode> static JSC::GCClient::IsoSubspace* subspaceFor(JSC::VM& vm)
    {
        if constexpr (mode == JSC::SubspaceAccess::Concurrently)
            return nullptr;
        return WebCore::subspaceForImpl<JSSHA224, WebCore::UseCustomHeapCellType::No>(
            vm,
            [](auto& spaces) { return spaces.m_clientSubspaceForSHA224.get(); },
            [](auto& spaces, auto&& space) { spaces.m_clientSubspaceForSHA224 = WTFMove(space); },
            [](auto& spaces) { return spaces.m_subspaceForSHA224.get(); },
            [](auto& spaces, auto&& space) { spaces.m_subspaceForSHA224 = WTFMove(space); });
    }

    static void destroy(JSC::JSCell*);
    static JSC::Structure* createStructure(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::JSValue prototype)
    {
        return JSC::Structure::create(vm, globalObject, prototype, JSC::TypeInfo(static_cast<JSC::JSType>(0b11101110), StructureFlags), info());
    }

    static JSObject* createPrototype(VM& vm, JSDOMGlobalObject* globalObject);
    static JSObject* createConstructor(VM& vm, JSGlobalObject* globalObject, JSValue prototype);

    ~JSSHA224();

    void* wrapped() const { return m_ctx; }

    void detach()
    {
        m_ctx = nullptr;
    }

    static void analyzeHeap(JSCell*, JSC::HeapAnalyzer&);
    static ptrdiff_t offsetOfWrapped() { return OBJECT_OFFSETOF(JSSHA224, m_ctx); }

    void* m_ctx { nullptr };

    JSSHA224(JSC::VM& vm, JSC::Structure* structure, void* sinkPtr)
        : Base(vm, structure)
    {
        m_ctx = sinkPtr;
    }

    void finishCreation(JSC::VM&);
};

class JSSHA512 final : public JSC::JSDestructibleObject {
public:
    using Base = JSC::JSDestructibleObject;
    static JSSHA512* create(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure, void* ctx);

    DECLARE_EXPORT_INFO;
    template<typename, JSC::SubspaceAccess mode> static JSC::GCClient::IsoSubspace* subspaceFor(JSC::VM& vm)
    {
        if constexpr (mode == JSC::SubspaceAccess::Concurrently)
            return nullptr;
        return WebCore::subspaceForImpl<JSSHA512, WebCore::UseCustomHeapCellType::No>(
            vm,
            [](auto& spaces) { return spaces.m_clientSubspaceForSHA512.get(); },
            [](auto& spaces, auto&& space) { spaces.m_clientSubspaceForSHA512 = WTFMove(space); },
            [](auto& spaces) { return spaces.m_subspaceForSHA512.get(); },
            [](auto& spaces, auto&& space) { spaces.m_subspaceForSHA512 = WTFMove(space); });
    }

    static void destroy(JSC::JSCell*);
    static JSC::Structure* createStructure(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::JSValue prototype)
    {
        return JSC::Structure::create(vm, globalObject, prototype, JSC::TypeInfo(static_cast<JSC::JSType>(0b11101110), StructureFlags), info());
    }

    static JSObject* createPrototype(VM& vm, JSDOMGlobalObject* globalObject);
    static JSObject* createConstructor(VM& vm, JSGlobalObject* globalObject, JSValue prototype);

    ~JSSHA512();

    void* wrapped() const { return m_ctx; }

    void detach()
    {
        m_ctx = nullptr;
    }

    static void analyzeHeap(JSCell*, JSC::HeapAnalyzer&);
    static ptrdiff_t offsetOfWrapped() { return OBJECT_OFFSETOF(JSSHA512, m_ctx); }

    void* m_ctx { nullptr };

    JSSHA512(JSC::VM& vm, JSC::Structure* structure, void* sinkPtr)
        : Base(vm, structure)
    {
        m_ctx = sinkPtr;
    }

    void finishCreation(JSC::VM&);
};

class JSSHA384 final : public JSC::JSDestructibleObject {
public:
    using Base = JSC::JSDestructibleObject;
    static JSSHA384* create(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure, void* ctx);

    DECLARE_EXPORT_INFO;
    template<typename, JSC::SubspaceAccess mode> static JSC::GCClient::IsoSubspace* subspaceFor(JSC::VM& vm)
    {
        if constexpr (mode == JSC::SubspaceAccess::Concurrently)
            return nullptr;
        return WebCore::subspaceForImpl<JSSHA384, WebCore::UseCustomHeapCellType::No>(
            vm,
            [](auto& spaces) { return spaces.m_clientSubspaceForSHA384.get(); },
            [](auto& spaces, auto&& space) { spaces.m_clientSubspaceForSHA384 = WTFMove(space); },
            [](auto& spaces) { return spaces.m_subspaceForSHA384.get(); },
            [](auto& spaces, auto&& space) { spaces.m_subspaceForSHA384 = WTFMove(space); });
    }

    static void destroy(JSC::JSCell*);
    static JSC::Structure* createStructure(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::JSValue prototype)
    {
        return JSC::Structure::create(vm, globalObject, prototype, JSC::TypeInfo(static_cast<JSC::JSType>(0b11101110), StructureFlags), info());
    }

    static JSObject* createPrototype(VM& vm, JSDOMGlobalObject* globalObject);
    static JSObject* createConstructor(VM& vm, JSGlobalObject* globalObject, JSValue prototype);

    ~JSSHA384();

    void* wrapped() const { return m_ctx; }

    void detach()
    {
        m_ctx = nullptr;
    }

    static void analyzeHeap(JSCell*, JSC::HeapAnalyzer&);
    static ptrdiff_t offsetOfWrapped() { return OBJECT_OFFSETOF(JSSHA384, m_ctx); }

    void* m_ctx { nullptr };

    JSSHA384(JSC::VM& vm, JSC::Structure* structure, void* sinkPtr)
        : Base(vm, structure)
    {
        m_ctx = sinkPtr;
    }

    void finishCreation(JSC::VM&);
};

class JSSHA256 final : public JSC::JSDestructibleObject {
public:
    using Base = JSC::JSDestructibleObject;
    static JSSHA256* create(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure, void* ctx);

    DECLARE_EXPORT_INFO;
    template<typename, JSC::SubspaceAccess mode> static JSC::GCClient::IsoSubspace* subspaceFor(JSC::VM& vm)
    {
        if constexpr (mode == JSC::SubspaceAccess::Concurrently)
            return nullptr;
        return WebCore::subspaceForImpl<JSSHA256, WebCore::UseCustomHeapCellType::No>(
            vm,
            [](auto& spaces) { return spaces.m_clientSubspaceForSHA256.get(); },
            [](auto& spaces, auto&& space) { spaces.m_clientSubspaceForSHA256 = WTFMove(space); },
            [](auto& spaces) { return spaces.m_subspaceForSHA256.get(); },
            [](auto& spaces, auto&& space) { spaces.m_subspaceForSHA256 = WTFMove(space); });
    }

    static void destroy(JSC::JSCell*);
    static JSC::Structure* createStructure(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::JSValue prototype)
    {
        return JSC::Structure::create(vm, globalObject, prototype, JSC::TypeInfo(static_cast<JSC::JSType>(0b11101110), StructureFlags), info());
    }

    static JSObject* createPrototype(VM& vm, JSDOMGlobalObject* globalObject);
    static JSObject* createConstructor(VM& vm, JSGlobalObject* globalObject, JSValue prototype);

    ~JSSHA256();

    void* wrapped() const { return m_ctx; }

    void detach()
    {
        m_ctx = nullptr;
    }

    static void analyzeHeap(JSCell*, JSC::HeapAnalyzer&);
    static ptrdiff_t offsetOfWrapped() { return OBJECT_OFFSETOF(JSSHA256, m_ctx); }

    void* m_ctx { nullptr };

    JSSHA256(JSC::VM& vm, JSC::Structure* structure, void* sinkPtr)
        : Base(vm, structure)
    {
        m_ctx = sinkPtr;
    }

    void finishCreation(JSC::VM&);
};

class JSSHA512_256 final : public JSC::JSDestructibleObject {
public:
    using Base = JSC::JSDestructibleObject;
    static JSSHA512_256* create(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure, void* ctx);

    DECLARE_EXPORT_INFO;
    template<typename, JSC::SubspaceAccess mode> static JSC::GCClient::IsoSubspace* subspaceFor(JSC::VM& vm)
    {
        if constexpr (mode == JSC::SubspaceAccess::Concurrently)
            return nullptr;
        return WebCore::subspaceForImpl<JSSHA512_256, WebCore::UseCustomHeapCellType::No>(
            vm,
            [](auto& spaces) { return spaces.m_clientSubspaceForSHA512_256.get(); },
            [](auto& spaces, auto&& space) { spaces.m_clientSubspaceForSHA512_256 = WTFMove(space); },
            [](auto& spaces) { return spaces.m_subspaceForSHA512_256.get(); },
            [](auto& spaces, auto&& space) { spaces.m_subspaceForSHA512_256 = WTFMove(space); });
    }

    static void destroy(JSC::JSCell*);
    static JSC::Structure* createStructure(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::JSValue prototype)
    {
        return JSC::Structure::create(vm, globalObject, prototype, JSC::TypeInfo(static_cast<JSC::JSType>(0b11101110), StructureFlags), info());
    }

    static JSObject* createPrototype(VM& vm, JSDOMGlobalObject* globalObject);
    static JSObject* createConstructor(VM& vm, JSGlobalObject* globalObject, JSValue prototype);

    ~JSSHA512_256();

    void* wrapped() const { return m_ctx; }

    void detach()
    {
        m_ctx = nullptr;
    }

    static void analyzeHeap(JSCell*, JSC::HeapAnalyzer&);
    static ptrdiff_t offsetOfWrapped() { return OBJECT_OFFSETOF(JSSHA512_256, m_ctx); }

    void* m_ctx { nullptr };

    JSSHA512_256(JSC::VM& vm, JSC::Structure* structure, void* sinkPtr)
        : Base(vm, structure)
    {
        m_ctx = sinkPtr;
    }

    void finishCreation(JSC::VM&);
};

class JSServerWebSocket final : public JSC::JSDestructibleObject {
public:
    using Base = JSC::JSDestructibleObject;
    static JSServerWebSocket* create(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure, void* ctx);

    DECLARE_EXPORT_INFO;
    template<typename, JSC::SubspaceAccess mode> static JSC::GCClient::IsoSubspace* subspaceFor(JSC::VM& vm)
    {
        if constexpr (mode == JSC::SubspaceAccess::Concurrently)
            return nullptr;
        return WebCore::subspaceForImpl<JSServerWebSocket, WebCore::UseCustomHeapCellType::No>(
            vm,
            [](auto& spaces) { return spaces.m_clientSubspaceForServerWebSocket.get(); },
            [](auto& spaces, auto&& space) { spaces.m_clientSubspaceForServerWebSocket = WTFMove(space); },
            [](auto& spaces) { return spaces.m_subspaceForServerWebSocket.get(); },
            [](auto& spaces, auto&& space) { spaces.m_subspaceForServerWebSocket = WTFMove(space); });
    }

    static void destroy(JSC::JSCell*);
    static JSC::Structure* createStructure(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::JSValue prototype)
    {
        return JSC::Structure::create(vm, globalObject, prototype, JSC::TypeInfo(static_cast<JSC::JSType>(0b11101110), StructureFlags), info());
    }

    static JSObject* createPrototype(VM& vm, JSDOMGlobalObject* globalObject);
    static JSObject* createConstructor(VM& vm, JSGlobalObject* globalObject, JSValue prototype);

    ~JSServerWebSocket();

    void* wrapped() const { return m_ctx; }

    void detach()
    {
        m_ctx = nullptr;
    }

    static void analyzeHeap(JSCell*, JSC::HeapAnalyzer&);
    static ptrdiff_t offsetOfWrapped() { return OBJECT_OFFSETOF(JSServerWebSocket, m_ctx); }

    void* m_ctx { nullptr };

    JSServerWebSocket(JSC::VM& vm, JSC::Structure* structure, void* sinkPtr)
        : Base(vm, structure)
    {
        m_ctx = sinkPtr;
    }

    void finishCreation(JSC::VM&);

    DECLARE_VISIT_CHILDREN;
    template<typename Visitor> void visitAdditionalChildren(Visitor&);
    DECLARE_VISIT_OUTPUT_CONSTRAINTS;

    mutable JSC::WriteBarrier<JSC::Unknown> m_data;
    mutable JSC::WriteBarrier<JSC::Unknown> m_remoteAddress;
};

class JSFileSystemRouter final : public JSC::JSDestructibleObject {
public:
    using Base = JSC::JSDestructibleObject;
    static JSFileSystemRouter* create(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure, void* ctx);

    DECLARE_EXPORT_INFO;
    template<typename, JSC::SubspaceAccess mode> static JSC::GCClient::IsoSubspace* subspaceFor(JSC::VM& vm)
    {
        if constexpr (mode == JSC::SubspaceAccess::Concurrently)
            return nullptr;
        return WebCore::subspaceForImpl<JSFileSystemRouter, WebCore::UseCustomHeapCellType::No>(
            vm,
            [](auto& spaces) { return spaces.m_clientSubspaceForFileSystemRouter.get(); },
            [](auto& spaces, auto&& space) { spaces.m_clientSubspaceForFileSystemRouter = WTFMove(space); },
            [](auto& spaces) { return spaces.m_subspaceForFileSystemRouter.get(); },
            [](auto& spaces, auto&& space) { spaces.m_subspaceForFileSystemRouter = WTFMove(space); });
    }

    static void destroy(JSC::JSCell*);
    static JSC::Structure* createStructure(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::JSValue prototype)
    {
        return JSC::Structure::create(vm, globalObject, prototype, JSC::TypeInfo(static_cast<JSC::JSType>(0b11101110), StructureFlags), info());
    }

    static JSObject* createPrototype(VM& vm, JSDOMGlobalObject* globalObject);
    static JSObject* createConstructor(VM& vm, JSGlobalObject* globalObject, JSValue prototype);

    ~JSFileSystemRouter();

    void* wrapped() const { return m_ctx; }

    void detach()
    {
        m_ctx = nullptr;
    }

    static void analyzeHeap(JSCell*, JSC::HeapAnalyzer&);
    static ptrdiff_t offsetOfWrapped() { return OBJECT_OFFSETOF(JSFileSystemRouter, m_ctx); }

    void* m_ctx { nullptr };

    JSFileSystemRouter(JSC::VM& vm, JSC::Structure* structure, void* sinkPtr)
        : Base(vm, structure)
    {
        m_ctx = sinkPtr;
    }

    void finishCreation(JSC::VM&);

    DECLARE_VISIT_CHILDREN;
    template<typename Visitor> void visitAdditionalChildren(Visitor&);
    DECLARE_VISIT_OUTPUT_CONSTRAINTS;

    mutable JSC::WriteBarrier<JSC::Unknown> m_origin;
    mutable JSC::WriteBarrier<JSC::Unknown> m_routes;
    mutable JSC::WriteBarrier<JSC::Unknown> m_style;
};

class JSMatchedRoute final : public JSC::JSDestructibleObject {
public:
    using Base = JSC::JSDestructibleObject;
    static JSMatchedRoute* create(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure, void* ctx);

    DECLARE_EXPORT_INFO;
    template<typename, JSC::SubspaceAccess mode> static JSC::GCClient::IsoSubspace* subspaceFor(JSC::VM& vm)
    {
        if constexpr (mode == JSC::SubspaceAccess::Concurrently)
            return nullptr;
        return WebCore::subspaceForImpl<JSMatchedRoute, WebCore::UseCustomHeapCellType::No>(
            vm,
            [](auto& spaces) { return spaces.m_clientSubspaceForMatchedRoute.get(); },
            [](auto& spaces, auto&& space) { spaces.m_clientSubspaceForMatchedRoute = WTFMove(space); },
            [](auto& spaces) { return spaces.m_subspaceForMatchedRoute.get(); },
            [](auto& spaces, auto&& space) { spaces.m_subspaceForMatchedRoute = WTFMove(space); });
    }

    static void destroy(JSC::JSCell*);
    static JSC::Structure* createStructure(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::JSValue prototype)
    {
        return JSC::Structure::create(vm, globalObject, prototype, JSC::TypeInfo(static_cast<JSC::JSType>(0b11101110), StructureFlags), info());
    }

    static JSObject* createPrototype(VM& vm, JSDOMGlobalObject* globalObject);
    ;

    ~JSMatchedRoute();

    void* wrapped() const { return m_ctx; }

    void detach()
    {
        m_ctx = nullptr;
    }

    static void analyzeHeap(JSCell*, JSC::HeapAnalyzer&);
    static ptrdiff_t offsetOfWrapped() { return OBJECT_OFFSETOF(JSMatchedRoute, m_ctx); }

    void* m_ctx { nullptr };

    JSMatchedRoute(JSC::VM& vm, JSC::Structure* structure, void* sinkPtr)
        : Base(vm, structure)
    {
        m_ctx = sinkPtr;
    }

    void finishCreation(JSC::VM&);

    DECLARE_VISIT_CHILDREN;
    template<typename Visitor> void visitAdditionalChildren(Visitor&);
    DECLARE_VISIT_OUTPUT_CONSTRAINTS;

    mutable JSC::WriteBarrier<JSC::Unknown> m_filePath;
    mutable JSC::WriteBarrier<JSC::Unknown> m_kind;
    mutable JSC::WriteBarrier<JSC::Unknown> m_name;
    mutable JSC::WriteBarrier<JSC::Unknown> m_params;
    mutable JSC::WriteBarrier<JSC::Unknown> m_pathname;
    mutable JSC::WriteBarrier<JSC::Unknown> m_query;
    mutable JSC::WriteBarrier<JSC::Unknown> m_scriptSrc;
};

class JSExpect final : public JSC::JSDestructibleObject {
public:
    using Base = JSC::JSDestructibleObject;
    static JSExpect* create(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure, void* ctx);

    DECLARE_EXPORT_INFO;
    template<typename, JSC::SubspaceAccess mode> static JSC::GCClient::IsoSubspace* subspaceFor(JSC::VM& vm)
    {
        if constexpr (mode == JSC::SubspaceAccess::Concurrently)
            return nullptr;
        return WebCore::subspaceForImpl<JSExpect, WebCore::UseCustomHeapCellType::No>(
            vm,
            [](auto& spaces) { return spaces.m_clientSubspaceForExpect.get(); },
            [](auto& spaces, auto&& space) { spaces.m_clientSubspaceForExpect = WTFMove(space); },
            [](auto& spaces) { return spaces.m_subspaceForExpect.get(); },
            [](auto& spaces, auto&& space) { spaces.m_subspaceForExpect = WTFMove(space); });
    }

    static void destroy(JSC::JSCell*);
    static JSC::Structure* createStructure(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::JSValue prototype)
    {
        return JSC::Structure::create(vm, globalObject, prototype, JSC::TypeInfo(static_cast<JSC::JSType>(0b11101110), StructureFlags), info());
    }

    static JSObject* createPrototype(VM& vm, JSDOMGlobalObject* globalObject);
    static JSObject* createConstructor(VM& vm, JSGlobalObject* globalObject, JSValue prototype);

    ~JSExpect();

    void* wrapped() const { return m_ctx; }

    void detach()
    {
        m_ctx = nullptr;
    }

    static void analyzeHeap(JSCell*, JSC::HeapAnalyzer&);
    static ptrdiff_t offsetOfWrapped() { return OBJECT_OFFSETOF(JSExpect, m_ctx); }

    void* m_ctx { nullptr };

    JSExpect(JSC::VM& vm, JSC::Structure* structure, void* sinkPtr)
        : Base(vm, structure)
    {
        m_ctx = sinkPtr;
    }

    void finishCreation(JSC::VM&);

    DECLARE_VISIT_CHILDREN;
    template<typename Visitor> void visitAdditionalChildren(Visitor&);
    DECLARE_VISIT_OUTPUT_CONSTRAINTS;

    mutable JSC::WriteBarrier<JSC::Unknown> m_capturedValue;
    mutable JSC::WriteBarrier<JSC::Unknown> m_resultValue;
};

class JSTextDecoder final : public JSC::JSDestructibleObject {
public:
    using Base = JSC::JSDestructibleObject;
    static JSTextDecoder* create(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure, void* ctx);

    DECLARE_EXPORT_INFO;
    template<typename, JSC::SubspaceAccess mode> static JSC::GCClient::IsoSubspace* subspaceFor(JSC::VM& vm)
    {
        if constexpr (mode == JSC::SubspaceAccess::Concurrently)
            return nullptr;
        return WebCore::subspaceForImpl<JSTextDecoder, WebCore::UseCustomHeapCellType::No>(
            vm,
            [](auto& spaces) { return spaces.m_clientSubspaceForTextDecoder.get(); },
            [](auto& spaces, auto&& space) { spaces.m_clientSubspaceForTextDecoder = WTFMove(space); },
            [](auto& spaces) { return spaces.m_subspaceForTextDecoder.get(); },
            [](auto& spaces, auto&& space) { spaces.m_subspaceForTextDecoder = WTFMove(space); });
    }

    static void destroy(JSC::JSCell*);
    static JSC::Structure* createStructure(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::JSValue prototype)
    {
        return JSC::Structure::create(vm, globalObject, prototype, JSC::TypeInfo(static_cast<JSC::JSType>(0b11101110), StructureFlags), info());
    }

    static JSObject* createPrototype(VM& vm, JSDOMGlobalObject* globalObject);
    static JSObject* createConstructor(VM& vm, JSGlobalObject* globalObject, JSValue prototype);

    ~JSTextDecoder();

    void* wrapped() const { return m_ctx; }

    void detach()
    {
        m_ctx = nullptr;
    }

    static void analyzeHeap(JSCell*, JSC::HeapAnalyzer&);
    static ptrdiff_t offsetOfWrapped() { return OBJECT_OFFSETOF(JSTextDecoder, m_ctx); }

    void* m_ctx { nullptr };

    JSTextDecoder(JSC::VM& vm, JSC::Structure* structure, void* sinkPtr)
        : Base(vm, structure)
    {
        m_ctx = sinkPtr;
    }

    void finishCreation(JSC::VM&);

    DECLARE_VISIT_CHILDREN;
    template<typename Visitor> void visitAdditionalChildren(Visitor&);
    DECLARE_VISIT_OUTPUT_CONSTRAINTS;

    mutable JSC::WriteBarrier<JSC::Unknown> m_encoding;
};

class JSRequest final : public JSC::JSDestructibleObject {
public:
    using Base = JSC::JSDestructibleObject;
    static JSRequest* create(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure, void* ctx);

    DECLARE_EXPORT_INFO;
    template<typename, JSC::SubspaceAccess mode> static JSC::GCClient::IsoSubspace* subspaceFor(JSC::VM& vm)
    {
        if constexpr (mode == JSC::SubspaceAccess::Concurrently)
            return nullptr;
        return WebCore::subspaceForImpl<JSRequest, WebCore::UseCustomHeapCellType::No>(
            vm,
            [](auto& spaces) { return spaces.m_clientSubspaceForRequest.get(); },
            [](auto& spaces, auto&& space) { spaces.m_clientSubspaceForRequest = WTFMove(space); },
            [](auto& spaces) { return spaces.m_subspaceForRequest.get(); },
            [](auto& spaces, auto&& space) { spaces.m_subspaceForRequest = WTFMove(space); });
    }

    static void destroy(JSC::JSCell*);
    static JSC::Structure* createStructure(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::JSValue prototype)
    {
        return JSC::Structure::create(vm, globalObject, prototype, JSC::TypeInfo(static_cast<JSC::JSType>(0b11101110), StructureFlags), info());
    }

    static JSObject* createPrototype(VM& vm, JSDOMGlobalObject* globalObject);
    static JSObject* createConstructor(VM& vm, JSGlobalObject* globalObject, JSValue prototype);

    ~JSRequest();

    void* wrapped() const { return m_ctx; }

    void detach()
    {
        m_ctx = nullptr;
    }

    static void analyzeHeap(JSCell*, JSC::HeapAnalyzer&);
    static ptrdiff_t offsetOfWrapped() { return OBJECT_OFFSETOF(JSRequest, m_ctx); }

    void* m_ctx { nullptr };

    JSRequest(JSC::VM& vm, JSC::Structure* structure, void* sinkPtr)
        : Base(vm, structure)
    {
        m_ctx = sinkPtr;
    }

    void finishCreation(JSC::VM&);

    DECLARE_VISIT_CHILDREN;
    template<typename Visitor> void visitAdditionalChildren(Visitor&);
    DECLARE_VISIT_OUTPUT_CONSTRAINTS;

    mutable JSC::WriteBarrier<JSC::Unknown> m_body;
    mutable JSC::WriteBarrier<JSC::Unknown> m_headers;
    mutable JSC::WriteBarrier<JSC::Unknown> m_url;
};

class JSResponse final : public JSC::JSDestructibleObject {
public:
    using Base = JSC::JSDestructibleObject;
    static JSResponse* create(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure, void* ctx);

    DECLARE_EXPORT_INFO;
    template<typename, JSC::SubspaceAccess mode> static JSC::GCClient::IsoSubspace* subspaceFor(JSC::VM& vm)
    {
        if constexpr (mode == JSC::SubspaceAccess::Concurrently)
            return nullptr;
        return WebCore::subspaceForImpl<JSResponse, WebCore::UseCustomHeapCellType::No>(
            vm,
            [](auto& spaces) { return spaces.m_clientSubspaceForResponse.get(); },
            [](auto& spaces, auto&& space) { spaces.m_clientSubspaceForResponse = WTFMove(space); },
            [](auto& spaces) { return spaces.m_subspaceForResponse.get(); },
            [](auto& spaces, auto&& space) { spaces.m_subspaceForResponse = WTFMove(space); });
    }

    static void destroy(JSC::JSCell*);
    static JSC::Structure* createStructure(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::JSValue prototype)
    {
        return JSC::Structure::create(vm, globalObject, prototype, JSC::TypeInfo(static_cast<JSC::JSType>(0b11101110), StructureFlags), info());
    }

    static JSObject* createPrototype(VM& vm, JSDOMGlobalObject* globalObject);
    static JSObject* createConstructor(VM& vm, JSGlobalObject* globalObject, JSValue prototype);

    ~JSResponse();

    void* wrapped() const { return m_ctx; }

    void detach()
    {
        m_ctx = nullptr;
    }

    static void analyzeHeap(JSCell*, JSC::HeapAnalyzer&);
    static ptrdiff_t offsetOfWrapped() { return OBJECT_OFFSETOF(JSResponse, m_ctx); }

    void* m_ctx { nullptr };

    JSResponse(JSC::VM& vm, JSC::Structure* structure, void* sinkPtr)
        : Base(vm, structure)
    {
        m_ctx = sinkPtr;
    }

    void finishCreation(JSC::VM&);

    DECLARE_VISIT_CHILDREN;
    template<typename Visitor> void visitAdditionalChildren(Visitor&);
    DECLARE_VISIT_OUTPUT_CONSTRAINTS;

    mutable JSC::WriteBarrier<JSC::Unknown> m_body;
    mutable JSC::WriteBarrier<JSC::Unknown> m_headers;
    mutable JSC::WriteBarrier<JSC::Unknown> m_statusText;
    mutable JSC::WriteBarrier<JSC::Unknown> m_url;
};

class JSBlob final : public JSC::JSDestructibleObject {
public:
    using Base = JSC::JSDestructibleObject;
    static JSBlob* create(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure, void* ctx);

    DECLARE_EXPORT_INFO;
    template<typename, JSC::SubspaceAccess mode> static JSC::GCClient::IsoSubspace* subspaceFor(JSC::VM& vm)
    {
        if constexpr (mode == JSC::SubspaceAccess::Concurrently)
            return nullptr;
        return WebCore::subspaceForImpl<JSBlob, WebCore::UseCustomHeapCellType::No>(
            vm,
            [](auto& spaces) { return spaces.m_clientSubspaceForBlob.get(); },
            [](auto& spaces, auto&& space) { spaces.m_clientSubspaceForBlob = WTFMove(space); },
            [](auto& spaces) { return spaces.m_subspaceForBlob.get(); },
            [](auto& spaces, auto&& space) { spaces.m_subspaceForBlob = WTFMove(space); });
    }

    static void destroy(JSC::JSCell*);
    static JSC::Structure* createStructure(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::JSValue prototype)
    {
        return JSC::Structure::create(vm, globalObject, prototype, JSC::TypeInfo(static_cast<JSC::JSType>(0b11101110), StructureFlags), info());
    }

    static JSObject* createPrototype(VM& vm, JSDOMGlobalObject* globalObject);
    static JSObject* createConstructor(VM& vm, JSGlobalObject* globalObject, JSValue prototype);

    ~JSBlob();

    void* wrapped() const { return m_ctx; }

    void detach()
    {
        m_ctx = nullptr;
    }

    static void analyzeHeap(JSCell*, JSC::HeapAnalyzer&);
    static ptrdiff_t offsetOfWrapped() { return OBJECT_OFFSETOF(JSBlob, m_ctx); }

    void* m_ctx { nullptr };

    JSBlob(JSC::VM& vm, JSC::Structure* structure, void* sinkPtr)
        : Base(vm, structure)
    {
        m_ctx = sinkPtr;
    }

    void finishCreation(JSC::VM&);
};

}
