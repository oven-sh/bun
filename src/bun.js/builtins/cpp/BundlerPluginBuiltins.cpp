/*
 * Copyright (c) 2015 Igalia
 * Copyright (c) 2015 Igalia S.L.
 * Copyright (c) 2015 Igalia.
 * Copyright (c) 2015, 2016 Canon Inc. All rights reserved.
 * Copyright (c) 2015, 2016, 2017 Canon Inc.
 * Copyright (c) 2016, 2020 Apple Inc. All rights reserved.
 * Copyright (c) 2023 Codeblog Corp. All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 
 * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS''
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 * 
 */

// DO NOT EDIT THIS FILE. It is automatically generated from JavaScript files for
// builtins by the script: Source/JavaScriptCore/Scripts/generate-js-builtins.py

#include "config.h"
#include "BundlerPluginBuiltins.h"

#include "WebCoreJSClientData.h"
#include <JavaScriptCore/IdentifierInlines.h>
#include <JavaScriptCore/ImplementationVisibility.h>
#include <JavaScriptCore/Intrinsic.h>
#include <JavaScriptCore/JSObjectInlines.h>
#include <JavaScriptCore/VM.h>

namespace WebCore {

const JSC::ConstructAbility s_bundlerPluginRunOnResolvePluginsCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const JSC::ConstructorKind s_bundlerPluginRunOnResolvePluginsCodeConstructorKind = JSC::ConstructorKind::None;
const JSC::ImplementationVisibility s_bundlerPluginRunOnResolvePluginsCodeImplementationVisibility = JSC::ImplementationVisibility::Public;
const int s_bundlerPluginRunOnResolvePluginsCodeLength = 3060;
static const JSC::Intrinsic s_bundlerPluginRunOnResolvePluginsCodeIntrinsic = JSC::NoIntrinsic;
const char* const s_bundlerPluginRunOnResolvePluginsCode =
    "(function (specifier, inputNamespace, importer, internalID, kindId) {\n" \
    "    \"use strict\";\n" \
    "  \n" \
    "    //\n" \
    "    const kind = [\n" \
    "      \"entry-point\",\n" \
    "      \"import-statement\",\n" \
    "      \"require-call\",\n" \
    "      \"dynamic-import\",\n" \
    "      \"require-resolve\",\n" \
    "      \"import-rule\",\n" \
    "      \"url-token\",\n" \
    "      \"internal\",\n" \
    "    ][kindId];\n" \
    "  \n" \
    "    var promiseResult = (async (inputPath, inputNamespace, importer, kind) => {\n" \
    "      var { callbacks, filters } = this.onResolvePlugins;\n" \
    "      var length = callbacks.length;\n" \
    "  \n" \
    "      for (var i = 0; i < length; ++i) {\n" \
    "        if (inputPath.test(filters[i])) {\n" \
    "          var result = callbacks[i]({\n" \
    "            path: inputPath,\n" \
    "            importer,\n" \
    "            namespace: inputNamespace,\n" \
    "            kind,\n" \
    "          });\n" \
    "  \n" \
    "          if (result && @isPromise(result)) {\n" \
    "            const flags = @getPromiseInternalField(result, @promiseFieldFlags);\n" \
    "            if (!(flags & @promiseStateFulfilled)) {\n" \
    "              result = await result;\n" \
    "            } else {\n" \
    "              result = @getPromiseInternalField(\n" \
    "                result,\n" \
    "                @promiseFieldReactionsOrResult\n" \
    "              );\n" \
    "            }\n" \
    "          }\n" \
    "  \n" \
    "          if (!result || !@isObject(result)) {\n" \
    "            continue;\n" \
    "          }\n" \
    "  \n" \
    "          var { path, namespace: userNamespace = inputNamespace, external } = result;\n" \
    "          if (!@isString(path) || !@isString(userNamespace)) {\n" \
    "            @throwTypeError(\n" \
    "              \"onResolve plugins must return an object with a string 'path' and string 'loader' field\"\n" \
    "            );\n" \
    "          }\n" \
    "  \n" \
    "          if (path.length === 0) {\n" \
    "            continue;\n" \
    "          }\n" \
    "\n" \
    "          if (userNamespace.length === 0) {\n" \
    "            userNamespace = inputNamespace;\n" \
    "          }\n" \
    "\n" \
    "          if (typeof external !== \"boolean\" && !@isUndefinedOrNull(external)) {\n" \
    "            @throwTypeError(\n" \
    "              \"onResolve plugins \\\"external\\\" field must be boolean or unspecified\"\n" \
    "            );\n" \
    "          }\n" \
    "          \n" \
    "          if (!external) {\n" \
    "            if (userNamespace === \"file\") {\n" \
    "              //\n" \
    "              if (path[0] !== \"/\" || path.includes(\"..\")) {\n" \
    "                @throwTypeError(\n" \
    "                  \"onResolve plugin \\\"path\\\" must be absolute when the namespace is \\\"file\\\"\"\n" \
    "                );\n" \
    "              }\n" \
    "            }\n" \
    "    \n" \
    "            if (userNamespace === \"dataurl\") {\n" \
    "              if (!path.startsWith(\"data:\")) {\n" \
    "                @throwTypeError(\n" \
    "                  \"onResolve plugin \\\"path\\\" must start with \\\"data:\\\" when the namespace is\\\"dataurl\\\"\"\n" \
    "                );\n" \
    "              }\n" \
    "            }\n" \
    "          }\n" \
    "  \n" \
    "          this.onResolveAsync(internalID, path, userNamespace, external);      \n" \
    "          return null;\n" \
    "        }\n" \
    "      }\n" \
    "\n" \
    "      this.onResolveAsync(internalID, null, null, null);\n" \
    "      return null;\n" \
    "    })(specifier, inputNamespace, importer, kind);\n" \
    "  \n" \
    "    const flags = @getPromiseInternalField(promiseResult, @promiseFieldFlags);\n" \
    "    //\n" \
    "    if (!(flags & @promiseStateFulfilled)) {\n" \
    "      promiseResult.@then(@undefined, (error) => {\n" \
    "        this.addError(internalID, error, 1);\n" \
    "      });\n" \
    "    }\n" \
    "  })\n" \
;

const JSC::ConstructAbility s_bundlerPluginRunSetupFunctionCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const JSC::ConstructorKind s_bundlerPluginRunSetupFunctionCodeConstructorKind = JSC::ConstructorKind::None;
const JSC::ImplementationVisibility s_bundlerPluginRunSetupFunctionCodeImplementationVisibility = JSC::ImplementationVisibility::Public;
const int s_bundlerPluginRunSetupFunctionCodeLength = 3471;
static const JSC::Intrinsic s_bundlerPluginRunSetupFunctionCodeIntrinsic = JSC::NoIntrinsic;
const char* const s_bundlerPluginRunSetupFunctionCode =
    "(function (setup) {\n" \
    "    \"use strict\";\n" \
    "    var onLoadPlugins = new @Map(),\n" \
    "      onResolvePlugins = new @Map();\n" \
    "  \n" \
    "    function validate(filterObject, callback, map) {\n" \
    "      if (!filterObject || !@isObject(filterObject)) {\n" \
    "        @throwTypeError('Expected an object with \"filter\" RegExp');\n" \
    "      }\n" \
    "  \n" \
    "      if (!callback || @isCallable(callback)) {\n" \
    "        @throwTypeError(\"callback must be a function\");\n" \
    "      }\n" \
    "  \n" \
    "      var { filter, namespace } = filterObject;\n" \
    "  \n" \
    "      if (!filter) {\n" \
    "        @throwTypeError('Expected an object with \"filter\" RegExp');\n" \
    "      }\n" \
    "  \n" \
    "      if (!@isRegExpObject(filter)) {\n" \
    "        @throwTypeError(\"filter must be a RegExp\");\n" \
    "      }\n" \
    "  \n" \
    "      if (namespace && !@isString(namespace)) {\n" \
    "        @throwTypeError(\"namespace must be a string\");\n" \
    "      }\n" \
    "\n" \
    "      if (!namespace.test(/^([/@a-zA-Z0-9_\\\\-]+)$/)) {\n" \
    "        @throwTypeError(\"namespace can only contain @a-zA-Z0-9_\\\\-\");\n" \
    "      }\n" \
    "  \n" \
    "      if (namespace?.length ?? 0) {\n" \
    "        namespace = \"file\";\n" \
    "      }\n" \
    "  \n" \
    "      var callbacks = map.@get(namespace);\n" \
    "  \n" \
    "      if (!callbacks) {\n" \
    "        callbacks = [];\n" \
    "        map.@set(namespace, callbacks);\n" \
    "      }\n" \
    "  \n" \
    "      @arrayPush(callbacks, [filter, callback]);\n" \
    "    }\n" \
    "  \n" \
    "    function onLoad(filterObject, callback) {\n" \
    "      validate(filterObject, callback, onLoadPlugins);\n" \
    "    }\n" \
    "  \n" \
    "    function onResolve(filterObject, callback) {\n" \
    "      validate(filterObject, callback, onResolvePlugins);\n" \
    "    }\n" \
    "  \n" \
    "    const processSetupResult = () => {\n" \
    "      var anyOnLoad = false,\n" \
    "        anyOnResolve = false;\n" \
    "  \n" \
    "      for (var [namespace, callbacks] of onLoadPlugins.entries()) {\n" \
    "        for (var [filter] of callbacks) {\n" \
    "          this.addFilter(filter, namespace, 0);\n" \
    "          anyOnLoad = true;\n" \
    "        }\n" \
    "      }\n" \
    "  \n" \
    "      for (var [namespace, callbacks] of onResolvePlugins.entries()) {\n" \
    "        for (var [filter] of callbacks) {\n" \
    "          this.addFilter(filter, namespace, 1);\n" \
    "          anyOnResolve = true;\n" \
    "        }\n" \
    "      }\n" \
    "  \n" \
    "      if (anyOnResolve) {\n" \
    "        var onResolveObject = this.onResolve;\n" \
    "        if (!onResolveObject) {\n" \
    "          this.onResolve = onResolvePlugins;\n" \
    "        } else {\n" \
    "          for (var [namespace, callbacks] of onResolvePlugins.entries()) {\n" \
    "            var existing = onResolveObject.@get(namespace);\n" \
    "  \n" \
    "            if (!existing) {\n" \
    "              onResolveObject.@set(namespace, callbacks);\n" \
    "            } else {\n" \
    "              @arrayPush(existing, ...callbacks);\n" \
    "            }\n" \
    "          }\n" \
    "        }\n" \
    "      }\n" \
    "  \n" \
    "      if (anyOnLoad) {\n" \
    "        var onLoadObject = this.onLoad;\n" \
    "        if (!onLoadObject) {\n" \
    "          this.onLoad = onLoadPlugins;\n" \
    "        } else {\n" \
    "          for (var [namespace, callbacks] of onLoadPlugins.entries()) {\n" \
    "            var existing = onLoadObject.@get(namespace);\n" \
    "  \n" \
    "            if (!existing) {\n" \
    "              onLoadObject.@set(namespace, callbacks);\n" \
    "            } else {\n" \
    "              @arrayPush(existing, ...callbacks);\n" \
    "            }\n" \
    "          }\n" \
    "        }\n" \
    "      }\n" \
    "  \n" \
    "      return anyOnLoad || anyOnResolve;\n" \
    "    };\n" \
    "  \n" \
    "    var setupResult = setup({\n" \
    "      onLoad,\n" \
    "      onResolve,\n" \
    "    });\n" \
    "  \n" \
    "    if (setupResult && @isPromise(setupResult)) {\n" \
    "      if (\n" \
    "        @getPromiseInternalField(setupResult, @promiseFieldFlags) &\n" \
    "        @promiseStateFulfilled\n" \
    "      ) {\n" \
    "        setupResult = @getPromiseInternalField(\n" \
    "          setupResult,\n" \
    "          @promiseFieldReactionsOrResult\n" \
    "        );\n" \
    "      } else {\n" \
    "        return setupResult.@then(processSetupResult);\n" \
    "      }\n" \
    "    }\n" \
    "  \n" \
    "    return processSetupResult();\n" \
    "  })\n" \
;

const JSC::ConstructAbility s_bundlerPluginRunOnLoadPluginsCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const JSC::ConstructorKind s_bundlerPluginRunOnLoadPluginsCodeConstructorKind = JSC::ConstructorKind::None;
const JSC::ImplementationVisibility s_bundlerPluginRunOnLoadPluginsCodeImplementationVisibility = JSC::ImplementationVisibility::Public;
const int s_bundlerPluginRunOnLoadPluginsCodeLength = 2603;
static const JSC::Intrinsic s_bundlerPluginRunOnLoadPluginsCodeIntrinsic = JSC::NoIntrinsic;
const char* const s_bundlerPluginRunOnLoadPluginsCode =
    "(function (internalID, path, namespace, defaultLoaderId) {\n" \
    "    \"use strict\";\n" \
    "  \n" \
    "    const LOADERS_MAP = {\n" \
    "      jsx: 0,\n" \
    "      js: 1,\n" \
    "      ts: 2,\n" \
    "      tsx: 3,\n" \
    "      css: 4,\n" \
    "      file: 5,\n" \
    "      json: 6,\n" \
    "      toml: 7,\n" \
    "      wasm: 8,\n" \
    "      napi: 9,\n" \
    "      base64: 10,\n" \
    "      dataurl: 11,\n" \
    "      text: 12,\n" \
    "    };\n" \
    "    const loaderName = [\n" \
    "      \"jsx\",\n" \
    "      \"js\",\n" \
    "      \"ts\",\n" \
    "      \"tsx\",\n" \
    "      \"css\",\n" \
    "      \"file\",\n" \
    "      \"json\",\n" \
    "      \"toml\",\n" \
    "      \"wasm\",\n" \
    "      \"napi\",\n" \
    "      \"base64\",\n" \
    "      \"dataurl\",\n" \
    "      \"text\",\n" \
    "    ][defaultLoaderId];\n" \
    "  \n" \
    "    var promiseResult = (async (internalID, path, namespace, defaultLoader) => {\n" \
    "      var { callbacks, filters } = this.onLoadPlugins.@get(namespace);\n" \
    "      var length = callbacks.length;\n" \
    "  \n" \
    "      for (var i = 0; i < length; ++i) {\n" \
    "        if (specifier.test(filters[i])) {\n" \
    "          var result = callbacks[i]({\n" \
    "            path,\n" \
    "            namespace,\n" \
    "            loader: defaultLoader,\n" \
    "          });\n" \
    "  \n" \
    "          if (result && @isPromise(result)) {\n" \
    "            const flags = @getPromiseInternalField(result, @promiseFieldFlags);\n" \
    "            if (!(flags & @promiseStateFulfilled)) {\n" \
    "              result = await result;\n" \
    "            } else {\n" \
    "              result = @getPromiseInternalField(\n" \
    "                result,\n" \
    "                @promiseFieldReactionsOrResult\n" \
    "              );\n" \
    "            }\n" \
    "          }\n" \
    "  \n" \
    "          if (!result || !@isObject(result)) {\n" \
    "            continue;\n" \
    "          }\n" \
    "  \n" \
    "          var { contents, loader = defaultLoader } = result;\n" \
    "          if (!@isString(contents) && !@isTypedArrayView(contents)) {\n" \
    "            @throwTypeError(\n" \
    "              'onLoad plugins must return an object with \"contents\" as a string or Uint8Array'\n" \
    "            );\n" \
    "          }\n" \
    "  \n" \
    "          if (!@isString(loader)) {\n" \
    "            @throwTypeError(\n" \
    "              'onLoad plugins must return an object with \"loader\" as a string'\n" \
    "            );\n" \
    "          }\n" \
    "  \n" \
    "          const chosenLoader = LOADERS_MAP[loader];\n" \
    "          if (chosenLoader === @undefined) {\n" \
    "            @throwTypeError('Loader \"' + loader + '\" is not supported.');\n" \
    "          }\n" \
    "  \n" \
    "          this.onLoadAsync(internalID, contents, loader);\n" \
    "          return null;\n" \
    "        }\n" \
    "      }\n" \
    "\n" \
    "      this.onLoadAsync(internalID, null, null);\n" \
    "      return null;\n" \
    "    })(internalID, path, namespace, loaderName);\n" \
    "  \n" \
    "    if (promiseResult && @isPromise(promiseResult)) {\n" \
    "      const flags = @getPromiseInternalField(promiseResult, @promiseFieldFlags);\n" \
    "      if (!(flags & @promiseStateFulfilled)) {\n" \
    "        promiseResult.@then(@undefined, (e) => {\n" \
    "          this.addError(internalID, e, 0);\n" \
    "        });\n" \
    "      }\n" \
    "    }\n" \
    "  })\n" \
;


#define DEFINE_BUILTIN_GENERATOR(codeName, functionName, overriddenName, argumentCount) \
JSC::FunctionExecutable* codeName##Generator(JSC::VM& vm) \
{\
    JSVMClientData* clientData = static_cast<JSVMClientData*>(vm.clientData); \
    return clientData->builtinFunctions().bundlerPluginBuiltins().codeName##Executable()->link(vm, nullptr, clientData->builtinFunctions().bundlerPluginBuiltins().codeName##Source(), std::nullopt, s_##codeName##Intrinsic); \
}
WEBCORE_FOREACH_BUNDLERPLUGIN_BUILTIN_CODE(DEFINE_BUILTIN_GENERATOR)
#undef DEFINE_BUILTIN_GENERATOR


} // namespace WebCore
