/*
 * Copyright (c) 2015 Igalia
 * Copyright (c) 2015 Igalia S.L.
 * Copyright (c) 2015 Igalia.
 * Copyright (c) 2015, 2016 Canon Inc. All rights reserved.
 * Copyright (c) 2015, 2016, 2017 Canon Inc.
 * Copyright (c) 2016, 2018 -2018 Apple Inc. All rights reserved.
 * Copyright (c) 2016, 2020 Apple Inc. All rights reserved.
 * Copyright (c) 2022 Codeblog Corp. All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 
 * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS''
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 * 
 */

// DO NOT EDIT THIS FILE. It is automatically generated from JavaScript files for
// builtins by the script: Source/JavaScriptCore/Scripts/generate-js-builtins.py

#include "config.h"
#include "PCRE2RegExpPrototypeBuiltins.h"

#include "WebCoreJSClientData.h"
#include <JavaScriptCore/HeapInlines.h>
#include <JavaScriptCore/IdentifierInlines.h>
#include <JavaScriptCore/ImplementationVisibility.h>
#include <JavaScriptCore/Intrinsic.h>
#include <JavaScriptCore/JSCJSValueInlines.h>
#include <JavaScriptCore/JSCellInlines.h>
#include <JavaScriptCore/StructureInlines.h>
#include <JavaScriptCore/VM.h>

namespace WebCore {

const JSC::ConstructAbility s_pCRE2RegExpPrototypeAdvanceStringIndexCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const JSC::ConstructorKind s_pCRE2RegExpPrototypeAdvanceStringIndexCodeConstructorKind = JSC::ConstructorKind::None;
const JSC::ImplementationVisibility s_pCRE2RegExpPrototypeAdvanceStringIndexCodeImplementationVisibility = JSC::ImplementationVisibility::Private;
const int s_pCRE2RegExpPrototypeAdvanceStringIndexCodeLength = 427;
static const JSC::Intrinsic s_pCRE2RegExpPrototypeAdvanceStringIndexCodeIntrinsic = JSC::NoIntrinsic;
const char* const s_pCRE2RegExpPrototypeAdvanceStringIndexCode =
    "(function (string, index, unicode)\n" \
    "{\n" \
    "    //\n" \
    "    \"use strict\";\n" \
    "\n" \
    "    if (!unicode)\n" \
    "        return index + 1;\n" \
    "\n" \
    "    if (index + 1 >= string.length)\n" \
    "        return index + 1;\n" \
    "\n" \
    "    var first = string.@charCodeAt(index);\n" \
    "    if (first < 0xD800 || first > 0xDBFF)\n" \
    "        return index + 1;\n" \
    "\n" \
    "    var second = string.@charCodeAt(index + 1);\n" \
    "    if (second < 0xDC00 || second > 0xDFFF)\n" \
    "        return index + 1;\n" \
    "\n" \
    "    return index + 2;\n" \
    "})\n" \
;

const JSC::ConstructAbility s_pCRE2RegExpPrototypeMatchSlowCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const JSC::ConstructorKind s_pCRE2RegExpPrototypeMatchSlowCodeConstructorKind = JSC::ConstructorKind::None;
const JSC::ImplementationVisibility s_pCRE2RegExpPrototypeMatchSlowCodeImplementationVisibility = JSC::ImplementationVisibility::Private;
const int s_pCRE2RegExpPrototypeMatchSlowCodeLength = 796;
static const JSC::Intrinsic s_pCRE2RegExpPrototypeMatchSlowCodeIntrinsic = JSC::NoIntrinsic;
const char* const s_pCRE2RegExpPrototypeMatchSlowCode =
    "(function (regexp, str)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "\n" \
    "    if (!regexp.global)\n" \
    "        return regexp.exec(str);\n" \
    "    \n" \
    "    var unicode = regexp.unicode;\n" \
    "    regexp.lastIndex = 0;\n" \
    "    var resultList = [];\n" \
    "\n" \
    "    //\n" \
    "    //\n" \
    "    //\n" \
    "    var maximumReasonableMatchSize = 100000000;\n" \
    "\n" \
    "    while (true) {\n" \
    "        var result = regexp.exec(str);\n" \
    "        \n" \
    "        if (result === null) {\n" \
    "            if (resultList.length === 0)\n" \
    "                return null;\n" \
    "            return resultList;\n" \
    "        }\n" \
    "\n" \
    "        if (resultList.length > maximumReasonableMatchSize)\n" \
    "            @throwOutOfMemoryError();\n" \
    "\n" \
    "        var resultString = @toString(result[0]);\n" \
    "\n" \
    "        if (!resultString.length)\n" \
    "            regexp.lastIndex = @advanceStringIndex(str, regexp.lastIndex, unicode);\n" \
    "\n" \
    "        @arrayPush(resultList, resultString);\n" \
    "    }\n" \
    "})\n" \
;

const JSC::ConstructAbility s_pCRE2RegExpPrototypeMatchCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const JSC::ConstructorKind s_pCRE2RegExpPrototypeMatchCodeConstructorKind = JSC::ConstructorKind::None;
const JSC::ImplementationVisibility s_pCRE2RegExpPrototypeMatchCodeImplementationVisibility = JSC::ImplementationVisibility::Public;
const int s_pCRE2RegExpPrototypeMatchCodeLength = 225;
static const JSC::Intrinsic s_pCRE2RegExpPrototypeMatchCodeIntrinsic = JSC::NoIntrinsic;
const char* const s_pCRE2RegExpPrototypeMatchCode =
    "(function (strArg)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "\n" \
    "    if (!@isObject(this))\n" \
    "        @throwTypeError(\"RegExp.prototype.@@match requires that |this| be an Object\");\n" \
    "\n" \
    "    var str = @toString(strArg);\n" \
    "\n" \
    "    return @matchSlow(this, str);\n" \
    "})\n" \
;

const JSC::ConstructAbility s_pCRE2RegExpPrototypeMatchAllCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const JSC::ConstructorKind s_pCRE2RegExpPrototypeMatchAllCodeConstructorKind = JSC::ConstructorKind::None;
const JSC::ImplementationVisibility s_pCRE2RegExpPrototypeMatchAllCodeImplementationVisibility = JSC::ImplementationVisibility::Public;
const int s_pCRE2RegExpPrototypeMatchAllCodeLength = 2924;
static const JSC::Intrinsic s_pCRE2RegExpPrototypeMatchAllCodeIntrinsic = JSC::NoIntrinsic;
const char* const s_pCRE2RegExpPrototypeMatchAllCode =
    "(function (strArg)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "\n" \
    "    var regExp = this;\n" \
    "    if (!@isObject(regExp)) {\n" \
    "        @throwTypeError(\"RegExp.prototype.@@matchAll requires |this| to be an Object\");\n" \
    "    }\n" \
    "\n" \
    "    var string = @toString(strArg);\n" \
    "\n" \
    "    var Matcher = @speciesConstructor(regExp, @Bun.PCRE2RegExp);\n" \
    "\n" \
    "    var flags = @toString(regExp.flags);\n" \
    "    var matcher = new Matcher(regExp.source, flags);\n" \
    "    matcher.lastIndex = @toLength(regExp.lastIndex);\n" \
    "\n" \
    "    var global = @stringIncludesInternal.@call(flags, \"g\");\n" \
    "    var fullUnicode = @stringIncludesInternal.@call(flags, \"u\");\n" \
    "\n" \
    "    var iterator = globalThis.Symbol.iterator;\n" \
    "\n" \
    "    var RegExpStringIterator = class RegExpStringIterator {\n" \
    "        constructor(regExp, string, global, fullUnicode)\n" \
    "        {\n" \
    "    \n" \
    "            @putByIdDirectPrivate(this, \"regExpStringIteratorRegExp\", regExp);\n" \
    "            @putByIdDirectPrivate(this, \"regExpStringIteratorString\", string);\n" \
    "            @putByIdDirectPrivate(this, \"regExpStringIteratorGlobal\", global);\n" \
    "            @putByIdDirectPrivate(this, \"regExpStringIteratorUnicode\", fullUnicode);\n" \
    "            @putByIdDirectPrivate(this, \"regExpStringIteratorDone\", false);\n" \
    "        }\n" \
    "\n" \
    "        next() {\n" \
    "            \"use strict\";\n" \
    "            if (!@isObject(this)) {\n" \
    "                @throwTypeError(\"%RegExpStringIteratorPrototype%.next requires |this| to be an Object\");\n" \
    "            }\n" \
    "        \n" \
    "            var done = @getByIdDirectPrivate(this, \"regExpStringIteratorDone\");\n" \
    "            if (done === @undefined) {\n" \
    "                @throwTypeError(\"%RegExpStringIteratorPrototype%.next requires |this| to be an RegExp String Iterator instance\");\n" \
    "            }\n" \
    "        \n" \
    "            if (done) {\n" \
    "                return { value: @undefined, done: true };\n" \
    "            }\n" \
    "        \n" \
    "            var regExp = @getByIdDirectPrivate(this, \"regExpStringIteratorRegExp\");\n" \
    "            var string = @getByIdDirectPrivate(this, \"regExpStringIteratorString\");\n" \
    "            var global = @getByIdDirectPrivate(this, \"regExpStringIteratorGlobal\");\n" \
    "            var fullUnicode = @getByIdDirectPrivate(this, \"regExpStringIteratorUnicode\");\n" \
    "            var match = regExp.exec(string);\n" \
    "            if (match === null) {\n" \
    "                @putByIdDirectPrivate(this, \"regExpStringIteratorDone\", true);\n" \
    "                return { value: @undefined, done: true };\n" \
    "            }\n" \
    "        \n" \
    "            if (global) {\n" \
    "                var matchStr = @toString(match[0]);\n" \
    "                if (matchStr === \"\") {\n" \
    "                    var thisIndex = @toLength(regExp.lastIndex);\n" \
    "                    regExp.lastIndex = @advanceStringIndex(string, thisIndex, fullUnicode);\n" \
    "                }\n" \
    "            } else\n" \
    "                @putByIdDirectPrivate(this, \"regExpStringIteratorDone\", true);\n" \
    "        \n" \
    "            return { value: match, done: false };\n" \
    "        }\n" \
    "\n" \
    "        [iterator]() {\n" \
    "            return this;\n" \
    "        }\n" \
    "\n" \
    "    };\n" \
    "\n" \
    "    return new RegExpStringIterator(matcher, string, global, fullUnicode);\n" \
    "})\n" \
;

const JSC::ConstructAbility s_pCRE2RegExpPrototypeGetSubstitutionCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const JSC::ConstructorKind s_pCRE2RegExpPrototypeGetSubstitutionCodeConstructorKind = JSC::ConstructorKind::None;
const JSC::ImplementationVisibility s_pCRE2RegExpPrototypeGetSubstitutionCodeImplementationVisibility = JSC::ImplementationVisibility::Private;
const int s_pCRE2RegExpPrototypeGetSubstitutionCodeLength = 3603;
static const JSC::Intrinsic s_pCRE2RegExpPrototypeGetSubstitutionCodeIntrinsic = JSC::NoIntrinsic;
const char* const s_pCRE2RegExpPrototypeGetSubstitutionCode =
    "(function (matched, str, position, captures, namedCaptures, replacement)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "\n" \
    "    var matchLength = matched.length;\n" \
    "    var stringLength = str.length;\n" \
    "    var tailPos = position + matchLength;\n" \
    "    var m = captures.length;\n" \
    "    var replacementLength = replacement.length;\n" \
    "    var result = \"\";\n" \
    "    var lastStart = 0;\n" \
    "\n" \
    "    for (var start = 0; start = @stringIndexOfInternal.@call(replacement, \"$\", lastStart), start !== -1; lastStart = start) {\n" \
    "        if (start - lastStart > 0)\n" \
    "            result = result + @stringSubstring.@call(replacement, lastStart, start);\n" \
    "        start++;\n" \
    "        if (start >= replacementLength)\n" \
    "            result = result + \"$\";\n" \
    "        else {\n" \
    "            var ch = replacement[start];\n" \
    "            switch (ch)\n" \
    "            {\n" \
    "            case \"$\":\n" \
    "                result = result + \"$\";\n" \
    "                start++;\n" \
    "                break;\n" \
    "            case \"&\":\n" \
    "                result = result + matched;\n" \
    "                start++;\n" \
    "                break;\n" \
    "            case \"`\":\n" \
    "                if (position > 0)\n" \
    "                    result = result + @stringSubstring.@call(str, 0, position);\n" \
    "                start++;\n" \
    "                break;\n" \
    "            case \"'\":\n" \
    "                if (tailPos < stringLength)\n" \
    "                    result = result + @stringSubstring.@call(str, tailPos);\n" \
    "                start++;\n" \
    "                break;\n" \
    "            case \"<\":\n" \
    "                if (namedCaptures !== @undefined) {\n" \
    "                    var groupNameStartIndex = start + 1;\n" \
    "                    var groupNameEndIndex = @stringIndexOfInternal.@call(replacement, \">\", groupNameStartIndex);\n" \
    "                    if (groupNameEndIndex !== -1) {\n" \
    "                        var groupName = @stringSubstring.@call(replacement, groupNameStartIndex, groupNameEndIndex);\n" \
    "                        var capture = namedCaptures[groupName];\n" \
    "                        if (capture !== @undefined)\n" \
    "                            result = result + @toString(capture);\n" \
    "\n" \
    "                        start = groupNameEndIndex + 1;\n" \
    "                        break;\n" \
    "                    }\n" \
    "                }\n" \
    "\n" \
    "                result = result + \"$<\";\n" \
    "                start++;\n" \
    "                break;\n" \
    "            default:\n" \
    "                var chCode = ch.@charCodeAt(0);\n" \
    "                if (chCode >= 0x30 && chCode <= 0x39) {\n" \
    "                    var originalStart = start - 1;\n" \
    "                    start++;\n" \
    "\n" \
    "                    var n = chCode - 0x30;\n" \
    "                    if (n > m) {\n" \
    "                        result = result + @stringSubstring.@call(replacement, originalStart, start);\n" \
    "                        break;\n" \
    "                    }\n" \
    "\n" \
    "                    if (start < replacementLength) {\n" \
    "                        var nextChCode = replacement.@charCodeAt(start);\n" \
    "                        if (nextChCode >= 0x30 && nextChCode <= 0x39) {\n" \
    "                            var nn = 10 * n + nextChCode - 0x30;\n" \
    "                            if (nn <= m) {\n" \
    "                                n = nn;\n" \
    "                                start++;\n" \
    "                            }\n" \
    "                        }\n" \
    "                    }\n" \
    "\n" \
    "                    if (n == 0) {\n" \
    "                        result = result + @stringSubstring.@call(replacement, originalStart, start);\n" \
    "                        break;\n" \
    "                    }\n" \
    "\n" \
    "                    var capture = captures[n - 1];\n" \
    "                    if (capture !== @undefined)\n" \
    "                        result = result + capture;\n" \
    "                } else\n" \
    "                    result = result + \"$\";\n" \
    "                break;\n" \
    "            }\n" \
    "        }\n" \
    "    }\n" \
    "\n" \
    "    return result + @stringSubstring.@call(replacement, lastStart);\n" \
    "})\n" \
;

const JSC::ConstructAbility s_pCRE2RegExpPrototypeReplaceCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const JSC::ConstructorKind s_pCRE2RegExpPrototypeReplaceCodeConstructorKind = JSC::ConstructorKind::None;
const JSC::ImplementationVisibility s_pCRE2RegExpPrototypeReplaceCodeImplementationVisibility = JSC::ImplementationVisibility::Public;
const int s_pCRE2RegExpPrototypeReplaceCodeLength = 3208;
static const JSC::Intrinsic s_pCRE2RegExpPrototypeReplaceCodeIntrinsic = JSC::NoIntrinsic;
const char* const s_pCRE2RegExpPrototypeReplaceCode =
    "(function (strArg, replace)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "\n" \
    "    if (!@isObject(this))\n" \
    "        @throwTypeError(\"RegExp.prototype.@@replace requires that |this| be an Object\");\n" \
    "\n" \
    "    var regexp = this;\n" \
    "\n" \
    "    var str = @toString(strArg);\n" \
    "    var stringLength = str.length;\n" \
    "    var functionalReplace = @isCallable(replace);\n" \
    "\n" \
    "    if (!functionalReplace)\n" \
    "        replace = @toString(replace);\n" \
    "\n" \
    "    var global = regexp.global;\n" \
    "    var unicode = false;\n" \
    "\n" \
    "    if (global) {\n" \
    "        unicode = regexp.unicode;\n" \
    "        regexp.lastIndex = 0;\n" \
    "    }\n" \
    "\n" \
    "    var resultList = [];\n" \
    "    var result;\n" \
    "    var done = false;\n" \
    "    while (!done) {\n" \
    "        result = regexp.exec(str);\n" \
    "\n" \
    "        if (result === null)\n" \
    "            done = true;\n" \
    "        else {\n" \
    "            @arrayPush(resultList, result);\n" \
    "            if (!global)\n" \
    "                done = true;\n" \
    "            else {\n" \
    "                var matchStr = @toString(result[0]);\n" \
    "\n" \
    "                if (!matchStr.length) {\n" \
    "                    var thisIndex = @toLength(regexp.lastIndex);\n" \
    "                    regexp.lastIndex = @advanceStringIndex(str, thisIndex, unicode);\n" \
    "                }\n" \
    "            }\n" \
    "        }\n" \
    "    }\n" \
    "\n" \
    "    var accumulatedResult = \"\";\n" \
    "    var nextSourcePosition = 0;\n" \
    "\n" \
    "    for (var i = 0, resultListLength = resultList.length; i < resultListLength; ++i) {\n" \
    "        var result = resultList[i];\n" \
    "        var nCaptures = result.length - 1;\n" \
    "        if (nCaptures < 0)\n" \
    "            nCaptures = 0;\n" \
    "        var matched = @toString(result[0]);\n" \
    "        var matchLength = matched.length;\n" \
    "        var position = @toIntegerOrInfinity(result.index);\n" \
    "        position = (position > stringLength) ? stringLength : position;\n" \
    "        position = (position < 0) ? 0 : position;\n" \
    "\n" \
    "        var captures = [];\n" \
    "        for (var n = 1; n <= nCaptures; n++) {\n" \
    "            var capN = result[n];\n" \
    "            if (capN !== @undefined)\n" \
    "                capN = @toString(capN);\n" \
    "            @arrayPush(captures, capN);\n" \
    "        }\n" \
    "\n" \
    "        var replacement;\n" \
    "        var namedCaptures = result.groups;\n" \
    "\n" \
    "        if (functionalReplace) {\n" \
    "            var replacerArgs = [ matched ];\n" \
    "            for (var j = 0; j < captures.length; j++)\n" \
    "                @arrayPush(replacerArgs, captures[j]);\n" \
    "\n" \
    "            @arrayPush(replacerArgs, position);\n" \
    "            @arrayPush(replacerArgs, str);\n" \
    "\n" \
    "            if (namedCaptures !== @undefined)\n" \
    "                @arrayPush(replacerArgs, namedCaptures);\n" \
    "\n" \
    "            var replValue = replace.@apply(@undefined, replacerArgs);\n" \
    "            replacement = @toString(replValue);\n" \
    "        } else {\n" \
    "            if (namedCaptures !== @undefined)\n" \
    "                namedCaptures = @toObject(namedCaptures, \"RegExp.prototype[Symbol.replace] requires 'groups' property of a match not be null\");\n" \
    "\n" \
    "            replacement = @getSubstitution(matched, str, position, captures, namedCaptures, replace);\n" \
    "        }\n" \
    "\n" \
    "        if (position >= nextSourcePosition) {\n" \
    "            accumulatedResult = accumulatedResult + @stringSubstring.@call(str, nextSourcePosition, position) + replacement;\n" \
    "            nextSourcePosition = position + matchLength;\n" \
    "        }\n" \
    "    }\n" \
    "\n" \
    "    if (nextSourcePosition >= stringLength)\n" \
    "        return  accumulatedResult;\n" \
    "\n" \
    "    return accumulatedResult + @stringSubstring.@call(str, nextSourcePosition);\n" \
    "})\n" \
;

const JSC::ConstructAbility s_pCRE2RegExpPrototypeSearchCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const JSC::ConstructorKind s_pCRE2RegExpPrototypeSearchCodeConstructorKind = JSC::ConstructorKind::None;
const JSC::ImplementationVisibility s_pCRE2RegExpPrototypeSearchCodeImplementationVisibility = JSC::ImplementationVisibility::Public;
const int s_pCRE2RegExpPrototypeSearchCodeLength = 631;
static const JSC::Intrinsic s_pCRE2RegExpPrototypeSearchCodeIntrinsic = JSC::NoIntrinsic;
const char* const s_pCRE2RegExpPrototypeSearchCode =
    "(function (strArg)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "\n" \
    "    var regexp = this;\n" \
    "\n" \
    "    //\n" \
    "    //\n" \
    "    if (!@isObject(this))\n" \
    "        @throwTypeError(\"RegExp.prototype.@@search requires that |this| be an Object\");\n" \
    "\n" \
    "    //\n" \
    "    var str = @toString(strArg)\n" \
    "\n" \
    "    //\n" \
    "    var previousLastIndex = regexp.lastIndex;\n" \
    "\n" \
    "    //\n" \
    "    //\n" \
    "    if (!@sameValue(previousLastIndex, 0))\n" \
    "        regexp.lastIndex = 0;\n" \
    "\n" \
    "    //\n" \
    "    var result = regexp.exec(str);\n" \
    "\n" \
    "    //\n" \
    "    //\n" \
    "    //\n" \
    "    if (!@sameValue(regexp.lastIndex, previousLastIndex))\n" \
    "        regexp.lastIndex = previousLastIndex;\n" \
    "\n" \
    "    //\n" \
    "    if (result === null)\n" \
    "        return -1;\n" \
    "\n" \
    "    //\n" \
    "    return result.index;\n" \
    "})\n" \
;

const JSC::ConstructAbility s_pCRE2RegExpPrototypeSplitCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const JSC::ConstructorKind s_pCRE2RegExpPrototypeSplitCodeConstructorKind = JSC::ConstructorKind::None;
const JSC::ImplementationVisibility s_pCRE2RegExpPrototypeSplitCodeImplementationVisibility = JSC::ImplementationVisibility::Public;
const int s_pCRE2RegExpPrototypeSplitCodeLength = 2926;
static const JSC::Intrinsic s_pCRE2RegExpPrototypeSplitCodeIntrinsic = JSC::NoIntrinsic;
const char* const s_pCRE2RegExpPrototypeSplitCode =
    "(function (string, limit)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "\n" \
    "    //\n" \
    "    //\n" \
    "    if (!@isObject(this))\n" \
    "        @throwTypeError(\"RegExp.prototype.@@split requires that |this| be an Object\");\n" \
    "    var regexp = this;\n" \
    "\n" \
    "    //\n" \
    "    var str = @toString(string);\n" \
    "\n" \
    "    //\n" \
    "    var speciesConstructor = @speciesConstructor(regexp, @RegExp);\n" \
    "\n" \
    "    //\n" \
    "    var flags = @toString(regexp.flags);\n" \
    "\n" \
    "    //\n" \
    "    //\n" \
    "    var unicodeMatching = @stringIncludesInternal.@call(flags, \"u\");\n" \
    "    //\n" \
    "    //\n" \
    "    var newFlags = @stringIncludesInternal.@call(flags, \"y\") ? flags : flags + \"y\";\n" \
    "\n" \
    "    //\n" \
    "    var splitter = new speciesConstructor(regexp.source, newFlags);\n" \
    "\n" \
    "    //\n" \
    "    //\n" \
    "\n" \
    "    //\n" \
    "    //\n" \
    "    var result = [];\n" \
    "\n" \
    "    //\n" \
    "    limit = (limit === @undefined) ? 0xffffffff : limit >>> 0;\n" \
    "\n" \
    "    //\n" \
    "    if (!limit)\n" \
    "        return result;\n" \
    "\n" \
    "    //\n" \
    "    var size = str.length;\n" \
    "\n" \
    "    //\n" \
    "    if (!size) {\n" \
    "        //\n" \
    "        var z = splitter.exec(str);\n" \
    "        //\n" \
    "        if (z !== null)\n" \
    "            return result;\n" \
    "        //\n" \
    "        @putByValDirect(result, 0, str);\n" \
    "        //\n" \
    "        return result;\n" \
    "    }\n" \
    "\n" \
    "    //\n" \
    "    var position = 0;\n" \
    "    //\n" \
    "    var matchPosition = 0;\n" \
    "\n" \
    "    //\n" \
    "    while (matchPosition < size) {\n" \
    "        //\n" \
    "        splitter.lastIndex = matchPosition;\n" \
    "        //\n" \
    "        var matches = splitter.exec(str);\n" \
    "        //\n" \
    "        if (matches === null)\n" \
    "            matchPosition = @advanceStringIndex(str, matchPosition, unicodeMatching);\n" \
    "        //\n" \
    "        else {\n" \
    "            //\n" \
    "            var endPosition = @toLength(splitter.lastIndex);\n" \
    "            //\n" \
    "            endPosition = (endPosition <= size) ? endPosition : size;\n" \
    "            //\n" \
    "            if (endPosition === position)\n" \
    "                matchPosition = @advanceStringIndex(str, matchPosition, unicodeMatching);\n" \
    "            //\n" \
    "            else {\n" \
    "                //\n" \
    "                var subStr = @stringSubstring.@call(str, position, matchPosition);\n" \
    "                //\n" \
    "                //\n" \
    "                @arrayPush(result, subStr);\n" \
    "                //\n" \
    "                if (result.length == limit)\n" \
    "                    return result;\n" \
    "\n" \
    "                //\n" \
    "                position = endPosition;\n" \
    "                //\n" \
    "                //\n" \
    "                var numberOfCaptures = matches.length > 1 ? matches.length - 1 : 0;\n" \
    "\n" \
    "                //\n" \
    "                var i = 1;\n" \
    "                //\n" \
    "                while (i <= numberOfCaptures) {\n" \
    "                    //\n" \
    "                    var nextCapture = matches[i];\n" \
    "                    //\n" \
    "                    //\n" \
    "                    @arrayPush(result, nextCapture);\n" \
    "                    //\n" \
    "                    if (result.length == limit)\n" \
    "                        return result;\n" \
    "                    //\n" \
    "                    i++;\n" \
    "                }\n" \
    "                //\n" \
    "                matchPosition = position;\n" \
    "            }\n" \
    "        }\n" \
    "    }\n" \
    "    //\n" \
    "    var remainingStr = @stringSubstring.@call(str, position, size);\n" \
    "    //\n" \
    "    @arrayPush(result, remainingStr);\n" \
    "    //\n" \
    "    return result;\n" \
    "})\n" \
;

const JSC::ConstructAbility s_pCRE2RegExpPrototypeTestCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const JSC::ConstructorKind s_pCRE2RegExpPrototypeTestCodeConstructorKind = JSC::ConstructorKind::None;
const JSC::ImplementationVisibility s_pCRE2RegExpPrototypeTestCodeImplementationVisibility = JSC::ImplementationVisibility::Public;
const int s_pCRE2RegExpPrototypeTestCodeLength = 448;
static const JSC::Intrinsic s_pCRE2RegExpPrototypeTestCodeIntrinsic = JSC::NoIntrinsic;
const char* const s_pCRE2RegExpPrototypeTestCode =
    "(function (strArg)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "\n" \
    "    var regexp = this;\n" \
    "\n" \
    "    if (regexp.test == @Bun.PCRE2RegExp.prototype.test) {\n" \
    "        return regexp.test(strArg);\n" \
    "    }\n" \
    "\n" \
    "    //\n" \
    "    //\n" \
    "    if (!@isObject(regexp))\n" \
    "        @throwTypeError(\"RegExp.prototype.test requires that |this| be an Object\");\n" \
    "\n" \
    "    //\n" \
    "    var str = @toString(strArg);\n" \
    "\n" \
    "    //\n" \
    "    var match = regexp.exec(str);\n" \
    "\n" \
    "    //\n" \
    "    if (match !== null)\n" \
    "        return true;\n" \
    "    return false;\n" \
    "})\n" \
;


#define DEFINE_BUILTIN_GENERATOR(codeName, functionName, overriddenName, argumentCount) \
JSC::FunctionExecutable* codeName##Generator(JSC::VM& vm) \
{\
    JSVMClientData* clientData = static_cast<JSVMClientData*>(vm.clientData); \
    return clientData->builtinFunctions().pCRE2RegExpPrototypeBuiltins().codeName##Executable()->link(vm, nullptr, clientData->builtinFunctions().pCRE2RegExpPrototypeBuiltins().codeName##Source(), std::nullopt, s_##codeName##Intrinsic); \
}
WEBCORE_FOREACH_PCRE2REGEXPPROTOTYPE_BUILTIN_CODE(DEFINE_BUILTIN_GENERATOR)
#undef DEFINE_BUILTIN_GENERATOR


} // namespace WebCore
