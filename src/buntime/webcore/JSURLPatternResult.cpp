/*
    This file is part of the WebKit open source project.
    This file has been generated by generate-bindings.pl. DO NOT MODIFY!

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Library General Public
    License as published by the Free Software Foundation; either
    version 2 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Library General Public License for more details.

    You should have received a copy of the GNU Library General Public License
    along with this library; see the file COPYING.LIB.  If not, write to
    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
    Boston, MA 02110-1301, USA.
*/

#include "config.h"
#include "root.h"
#include "JSURLPatternResult.h"

#include "IDLTypes.h"
#include "JSDOMConvertBase.h"
#include "JSDOMConvertStrings.h"
#include "JSDOMGlobalObject.h"
#include "JSURLPatternInit.h"
#include <JavaScriptCore/JSArray.h>
#include <JavaScriptCore/JSCInlines.h>
#include <JavaScriptCore/ObjectConstructor.h>

namespace WebCore {
using namespace JSC;

// URLPatternResult and URLPatternComponentResult are output-only dictionaries that are
// returned from exec() but never accepted as input from JavaScript. These convertDictionary
// template specializations are required to satisfy template instantiation in the binding
// infrastructure. They intentionally throw TypeErrors to catch any invalid JSâ†’native
// conversion attempts, as these types should never be constructed from JavaScript values.
template<> URLPatternResult convertDictionary<URLPatternResult>(JSGlobalObject& lexicalGlobalObject, JSValue value)
{
    auto& vm = JSC::getVM(&lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(value);
    throwTypeError(&lexicalGlobalObject, throwScope, "URLPatternResult cannot be converted from JavaScript"_s);
    return {};
}

template<> URLPatternComponentResult convertDictionary<URLPatternComponentResult>(JSGlobalObject& lexicalGlobalObject, JSValue value)
{
    auto& vm = JSC::getVM(&lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);
    UNUSED_PARAM(value);
    throwTypeError(&lexicalGlobalObject, throwScope, "URLPatternComponentResult cannot be converted from JavaScript"_s);
    return {};
}

// Helper to convert the groups record to JS
static JSC::JSObject* convertGroupsToJS(JSC::JSGlobalObject& lexicalGlobalObject, JSDOMGlobalObject& globalObject, const URLPatternComponentResult::GroupsRecord& groups)
{
    auto& vm = JSC::getVM(&lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);

    auto result = constructEmptyObject(&lexicalGlobalObject, globalObject.objectPrototype());

    for (const auto& pair : groups) {
        JSValue jsValue = WTF::switchOn(pair.value, [&](std::monostate) -> JSValue { return jsUndefined(); }, [&](const String& str) -> JSValue { return toJS<IDLUSVString>(lexicalGlobalObject, throwScope, str); });
        RETURN_IF_EXCEPTION(throwScope, nullptr);

        // Check if the key is an array index
        auto identifier = Identifier::fromString(vm, pair.key);
        if (auto index = parseIndex(identifier)) {
            result->putDirectIndex(&lexicalGlobalObject, index.value(), jsValue);
            RETURN_IF_EXCEPTION(throwScope, nullptr);
        } else {
            result->putDirect(vm, identifier, jsValue);
        }
    }

    return result;
}

// Helper to convert URLPatternInput (variant) to JS
static JSC::JSValue convertURLPatternInputToJS(JSC::JSGlobalObject& lexicalGlobalObject, JSDOMGlobalObject& globalObject, const URLPattern::URLPatternInput& input)
{
    auto& vm = JSC::getVM(&lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);

    return WTF::switchOn(input, [&](const String& str) -> JSValue { return toJS<IDLUSVString>(lexicalGlobalObject, throwScope, str); }, [&](const URLPatternInit& init) -> JSValue { return convertDictionaryToJS(lexicalGlobalObject, globalObject, init); });
}

JSC::JSObject* convertDictionaryToJS(JSC::JSGlobalObject& lexicalGlobalObject, JSDOMGlobalObject& globalObject, const URLPatternComponentResult& dictionary)
{
    auto& vm = JSC::getVM(&lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);

    auto result = constructEmptyObject(&lexicalGlobalObject, globalObject.objectPrototype());

    // Output input
    auto inputValue = toJS<IDLUSVString>(lexicalGlobalObject, throwScope, dictionary.input);
    RETURN_IF_EXCEPTION(throwScope, nullptr);
    result->putDirect(vm, Identifier::fromString(vm, "input"_s), inputValue);

    // Output groups - record<USVString, (undefined or USVString)>
    auto groupsValue = convertGroupsToJS(lexicalGlobalObject, globalObject, dictionary.groups);
    RETURN_IF_EXCEPTION(throwScope, nullptr);
    result->putDirect(vm, Identifier::fromString(vm, "groups"_s), groupsValue);

    return result;
}

JSC::JSObject* convertDictionaryToJS(JSC::JSGlobalObject& lexicalGlobalObject, JSDOMGlobalObject& globalObject, const URLPatternResult& dictionary)
{
    auto& vm = JSC::getVM(&lexicalGlobalObject);
    auto throwScope = DECLARE_THROW_SCOPE(vm);

    auto result = constructEmptyObject(&lexicalGlobalObject, globalObject.objectPrototype());

    // Output inputs - sequence<(USVString or URLPatternInit)>
    auto inputsArray = JSC::constructEmptyArray(&lexicalGlobalObject, nullptr, dictionary.inputs.size());
    RETURN_IF_EXCEPTION(throwScope, nullptr);
    for (size_t i = 0; i < dictionary.inputs.size(); ++i) {
        auto inputValue = convertURLPatternInputToJS(lexicalGlobalObject, globalObject, dictionary.inputs[i]);
        RETURN_IF_EXCEPTION(throwScope, nullptr);
        inputsArray->putDirectIndex(&lexicalGlobalObject, i, inputValue);
        RETURN_IF_EXCEPTION(throwScope, nullptr);
    }
    result->putDirect(vm, Identifier::fromString(vm, "inputs"_s), inputsArray);

    // Output protocol
    auto protocolValue = convertDictionaryToJS(lexicalGlobalObject, globalObject, dictionary.protocol);
    RETURN_IF_EXCEPTION(throwScope, nullptr);
    result->putDirect(vm, Identifier::fromString(vm, "protocol"_s), protocolValue);

    // Output username
    auto usernameValue = convertDictionaryToJS(lexicalGlobalObject, globalObject, dictionary.username);
    RETURN_IF_EXCEPTION(throwScope, nullptr);
    result->putDirect(vm, Identifier::fromString(vm, "username"_s), usernameValue);

    // Output password
    auto passwordValue = convertDictionaryToJS(lexicalGlobalObject, globalObject, dictionary.password);
    RETURN_IF_EXCEPTION(throwScope, nullptr);
    result->putDirect(vm, Identifier::fromString(vm, "password"_s), passwordValue);

    // Output hostname
    auto hostnameValue = convertDictionaryToJS(lexicalGlobalObject, globalObject, dictionary.hostname);
    RETURN_IF_EXCEPTION(throwScope, nullptr);
    result->putDirect(vm, Identifier::fromString(vm, "hostname"_s), hostnameValue);

    // Output port
    auto portValue = convertDictionaryToJS(lexicalGlobalObject, globalObject, dictionary.port);
    RETURN_IF_EXCEPTION(throwScope, nullptr);
    result->putDirect(vm, Identifier::fromString(vm, "port"_s), portValue);

    // Output pathname
    auto pathnameValue = convertDictionaryToJS(lexicalGlobalObject, globalObject, dictionary.pathname);
    RETURN_IF_EXCEPTION(throwScope, nullptr);
    result->putDirect(vm, Identifier::fromString(vm, "pathname"_s), pathnameValue);

    // Output search
    auto searchValue = convertDictionaryToJS(lexicalGlobalObject, globalObject, dictionary.search);
    RETURN_IF_EXCEPTION(throwScope, nullptr);
    result->putDirect(vm, Identifier::fromString(vm, "search"_s), searchValue);

    // Output hash
    auto hashValue = convertDictionaryToJS(lexicalGlobalObject, globalObject, dictionary.hash);
    RETURN_IF_EXCEPTION(throwScope, nullptr);
    result->putDirect(vm, Identifier::fromString(vm, "hash"_s), hashValue);

    return result;
}

} // namespace WebCore
