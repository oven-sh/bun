const std = @import("std");
const bun = @import("root").bun;
const Allocator = std.mem.Allocator;

pub const css = @import("./css_parser.zig");

const Printer = css.Printer;
const PrintErr = css.PrintErr;
const VendorPrefix = css.VendorPrefix;

/// Target browsers and features to compile.
pub const Targets = struct {
    /// Browser targets to compile the CSS for.
    browsers: ?Browsers = null,
    /// Features that should always be compiled, even when supported by targets.
    include: Features = .{},
    /// Features that should never be compiled, even when unsupported by targets.
    exclude: Features = .{},

    pub fn prefixes(this: *const Targets, prefix: css.VendorPrefix, feature: css.prefixes.Feature) css.VendorPrefix {
        if (prefix.contains(css.VendorPrefix{ .none = true }) and !this.exclude.contains(css.targets.Features{ .vendor_prefixes = true })) {
            if (this.include.contains(css.targets.Features{ .vendor_prefixes = true })) {
                return css.VendorPrefix.all();
            } else {
                return if (this.browsers) |b| feature.prefixesFor(b) else prefix;
            }
        } else {
            return prefix;
        }
    }

    pub fn shouldCompileLogical(this: *const Targets, feature: css.compat.Feature) bool {
        return this.shouldCompile(feature, css.Features{ .logical_properties = true });
    }

    pub fn shouldCompile(this: *const Targets, feature: css.compat.Feature, flag: Features) bool {
        return this.include.contains(flag) or (!this.exclude.contains(flag) and !this.isCompatible(feature));
    }

    pub fn shouldCompileSame(this: *const Targets, comptime prop: @Type(.EnumLiteral)) bool {
        const compat_feature: css.compat.Feature = prop;
        const target_feature: css.targets.Features = target_feature: {
            var feature: css.targets.Features = .{};
            @field(feature, @tagName(prop)) = true;
            break :target_feature feature;
        };

        return shouldCompile(this, compat_feature, target_feature);
    }

    pub fn shouldCompileSelectors(this: *const Targets) bool {
        return this.include.intersects(Features.selectors) or
            (!this.exclude.intersects(Features.selectors) and this.browsers != null);
    }

    pub fn isCompatible(this: *const Targets, feature: css.compat.Feature) bool {
        if (this.browsers) |*targets| {
            return feature.isCompatible(targets.*);
        }
        return true;
    }
};

/// Autogenerated by build-prefixes.js
///
/// Browser versions to compile CSS for.
///
/// Versions are represented as a single 24-bit integer, with one byte
/// per `major.minor.patch` component.
///
/// # Example
///
/// This example represents a target of Safari 13.2.0.
///
/// ```
/// const Browsers = struct {
///   safari: ?u32 = (13 << 16) | (2 << 8),
///   ..Browsers{}
/// };
/// ```
pub const Browsers = struct {
    android: ?u32 = null,
    chrome: ?u32 = null,
    edge: ?u32 = null,
    firefox: ?u32 = null,
    ie: ?u32 = null,
    ios_saf: ?u32 = null,
    opera: ?u32 = null,
    safari: ?u32 = null,
    samsung: ?u32 = null,
    pub usingnamespace BrowsersImpl(@This());
};

/// Autogenerated by build-prefixes.js
/// Features to explicitly enable or disable.
pub const Features = packed struct(u32) {
    nesting: bool = false,
    not_selector_list: bool = false,
    dir_selector: bool = false,
    lang_selector_list: bool = false,
    is_selector: bool = false,
    text_decoration_thickness_percent: bool = false,
    media_interval_syntax: bool = false,
    media_range_syntax: bool = false,
    custom_media_queries: bool = false,
    clamp_function: bool = false,
    color_function: bool = false,
    oklab_colors: bool = false,
    lab_colors: bool = false,
    p3_colors: bool = false,
    hex_alpha_colors: bool = false,
    space_separated_color_notation: bool = false,
    font_family_system_ui: bool = false,
    double_position_gradients: bool = false,
    vendor_prefixes: bool = false,
    logical_properties: bool = false,
    __unused: u12 = 0,

    pub const selectors = Features.fromNames(&.{ "nesting", "not_selector_list", "dir_selector", "lang_selector_list", "is_selector" });
    pub const media_queries = Features.fromNames(&.{ "media_interval_syntax", "media_range_syntax", "custom_media_queries" });
    pub const colors = Features.fromNames(&.{ "color_function", "oklab_colors", "lab_colors", "p3_colors", "hex_alpha_colors", "space_separated_color_notation" });

    pub usingnamespace css.Bitflags(@This());
    pub usingnamespace FeaturesImpl(@This());
};

pub fn BrowsersImpl(comptime T: type) type {
    _ = T; // autofix
    return struct {};
}

pub fn FeaturesImpl(comptime T: type) type {
    _ = T; // autofix
    return struct {};
}
