/*
 * Copyright (c) 2015 Igalia
 * Copyright (c) 2015 Igalia S.L.
 * Copyright (c) 2015 Igalia.
 * Copyright (c) 2015, 2016 Canon Inc. All rights reserved.
 * Copyright (c) 2015, 2016, 2017 Canon Inc.
 * Copyright (c) 2016, 2020 Apple Inc. All rights reserved.
 * Copyright (c) 2022 Codeblog Corp. All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 
 * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS''
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 * 
 */

// DO NOT EDIT THIS FILE. It is automatically generated from JavaScript files for
// builtins by the script: Source/JavaScriptCore/Scripts/generate-js-builtins.py

#include "config.h"
#include "ReadableStreamInternalsBuiltins.h"

#include "WebCoreJSClientData.h"
#include <JavaScriptCore/HeapInlines.h>
#include <JavaScriptCore/IdentifierInlines.h>
#include <JavaScriptCore/Intrinsic.h>
#include <JavaScriptCore/JSCJSValueInlines.h>
#include <JavaScriptCore/JSCellInlines.h>
#include <JavaScriptCore/StructureInlines.h>
#include <JavaScriptCore/VM.h>

namespace WebCore {

const JSC::ConstructAbility s_readableStreamInternalsReadableStreamReaderGenericInitializeCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const JSC::ConstructorKind s_readableStreamInternalsReadableStreamReaderGenericInitializeCodeConstructorKind = JSC::ConstructorKind::None;
const int s_readableStreamInternalsReadableStreamReaderGenericInitializeCodeLength = 756;
static const JSC::Intrinsic s_readableStreamInternalsReadableStreamReaderGenericInitializeCodeIntrinsic = JSC::NoIntrinsic;
const char* const s_readableStreamInternalsReadableStreamReaderGenericInitializeCode =
    "(function (reader, stream)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "\n" \
    "    @putByIdDirectPrivate(reader, \"ownerReadableStream\", stream);\n" \
    "    @putByIdDirectPrivate(stream, \"reader\", reader);\n" \
    "    if (@getByIdDirectPrivate(stream, \"state\") === @streamReadable)\n" \
    "        @putByIdDirectPrivate(reader, \"closedPromiseCapability\", @newPromiseCapability(@Promise));\n" \
    "    else if (@getByIdDirectPrivate(stream, \"state\") === @streamClosed)\n" \
    "        @putByIdDirectPrivate(reader, \"closedPromiseCapability\", { @promise: @Promise.@resolve() });\n" \
    "    else {\n" \
    "        @assert(@getByIdDirectPrivate(stream, \"state\") === @streamErrored);\n" \
    "        @putByIdDirectPrivate(reader, \"closedPromiseCapability\", { @promise: @newHandledRejectedPromise(@getByIdDirectPrivate(stream, \"storedError\")) });\n" \
    "    }\n" \
    "})\n" \
;

const JSC::ConstructAbility s_readableStreamInternalsPrivateInitializeReadableStreamDefaultControllerCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const JSC::ConstructorKind s_readableStreamInternalsPrivateInitializeReadableStreamDefaultControllerCodeConstructorKind = JSC::ConstructorKind::None;
const int s_readableStreamInternalsPrivateInitializeReadableStreamDefaultControllerCodeLength = 910;
static const JSC::Intrinsic s_readableStreamInternalsPrivateInitializeReadableStreamDefaultControllerCodeIntrinsic = JSC::NoIntrinsic;
const char* const s_readableStreamInternalsPrivateInitializeReadableStreamDefaultControllerCode =
    "(function (stream, underlyingSource, size, highWaterMark)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "    \n" \
    "        if (!@isReadableStream(stream))\n" \
    "        @throwTypeError(\"ReadableStreamDefaultController needs a ReadableStream\");\n" \
    "\n" \
    "    //\n" \
    "    if (@getByIdDirectPrivate(stream, \"readableStreamController\") !== null)\n" \
    "        @throwTypeError(\"ReadableStream already has a controller\");\n" \
    "\n" \
    "        \n" \
    "\n" \
    "    @putByIdDirectPrivate(this, \"controlledReadableStream\", stream);\n" \
    "    @putByIdDirectPrivate(this, \"underlyingSource\", underlyingSource);\n" \
    "    @putByIdDirectPrivate(this, \"queue\", @newQueue());\n" \
    "    @putByIdDirectPrivate(this, \"started\", -1);\n" \
    "    @putByIdDirectPrivate(this, \"closeRequested\", false);\n" \
    "    @putByIdDirectPrivate(this, \"pullAgain\", false);\n" \
    "    @putByIdDirectPrivate(this, \"pulling\", false);\n" \
    "    @putByIdDirectPrivate(this, \"strategy\", @validateAndNormalizeQueuingStrategy(size, highWaterMark));\n" \
    "    \n" \
    "    \n" \
    "\n" \
    "\n" \
    "    return this;\n" \
    "})\n" \
;

const JSC::ConstructAbility s_readableStreamInternalsSetupReadableStreamDefaultControllerCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const JSC::ConstructorKind s_readableStreamInternalsSetupReadableStreamDefaultControllerCodeConstructorKind = JSC::ConstructorKind::None;
const int s_readableStreamInternalsSetupReadableStreamDefaultControllerCodeLength = 876;
static const JSC::Intrinsic s_readableStreamInternalsSetupReadableStreamDefaultControllerCodeIntrinsic = JSC::NoIntrinsic;
const char* const s_readableStreamInternalsSetupReadableStreamDefaultControllerCode =
    "(function (stream, underlyingSource, size, highWaterMark, startMethod, pullMethod, cancelMethod)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "    \n" \
    "    const controller = new @ReadableStreamDefaultController(stream, underlyingSource, size, highWaterMark, @isReadableStream);\n" \
    "   \n" \
    "    const pullAlgorithm = () => @promiseInvokeOrNoopMethod(underlyingSource, pullMethod, [controller]);\n" \
    "    const cancelAlgorithm = (reason) => @promiseInvokeOrNoopMethod(underlyingSource, cancelMethod, [reason]);\n" \
    "    \n" \
    "    @putByIdDirectPrivate(controller, \"pullAlgorithm\", pullAlgorithm);\n" \
    "    @putByIdDirectPrivate(controller, \"cancelAlgorithm\", cancelAlgorithm);\n" \
    "    @putByIdDirectPrivate(controller, \"pull\", @readableStreamDefaultControllerPull);\n" \
    "    @putByIdDirectPrivate(controller, \"cancel\", @readableStreamDefaultControllerCancel);\n" \
    "    @putByIdDirectPrivate(stream, \"readableStreamController\", controller);\n" \
    "\n" \
    "    \n" \
    "})\n" \
;

const JSC::ConstructAbility s_readableStreamInternalsReadableStreamDefaultControllerStartCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const JSC::ConstructorKind s_readableStreamInternalsReadableStreamDefaultControllerStartCodeConstructorKind = JSC::ConstructorKind::None;
const int s_readableStreamInternalsReadableStreamDefaultControllerStartCodeLength = 782;
static const JSC::Intrinsic s_readableStreamInternalsReadableStreamDefaultControllerStartCodeIntrinsic = JSC::NoIntrinsic;
const char* const s_readableStreamInternalsReadableStreamDefaultControllerStartCode =
    "(function (controller) {\n" \
    "    if (@getByIdDirectPrivate(controller, \"started\") !== -1)\n" \
    "        return;\n" \
    "\n" \
    "    const underlyingSource = @getByIdDirectPrivate(controller, \"underlyingSource\");\n" \
    "    const startMethod = @getByIdDirectPrivate(underlyingSource, \"start\");\n" \
    "    @putByIdDirectPrivate(controller, \"started\", 0);\n" \
    "\n" \
    "    return @promiseInvokeOrNoopMethodNoCatch(underlyingSource, startMethod, [controller]).@then(() => {\n" \
    "        @putByIdDirectPrivate(controller, \"started\", 1);\n" \
    "        @assert(!@getByIdDirectPrivate(controller, \"pulling\"));\n" \
    "        @assert(!@getByIdDirectPrivate(controller, \"pullAgain\"));\n" \
    "        @readableStreamDefaultControllerCallPullIfNeeded(controller);\n" \
    "        \n" \
    "    }, (error) => {\n" \
    "        @readableStreamDefaultControllerError(controller, error);\n" \
    "    });\n" \
    "})\n" \
;

const JSC::ConstructAbility s_readableStreamInternalsReadableStreamDefaultControllerErrorCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const JSC::ConstructorKind s_readableStreamInternalsReadableStreamDefaultControllerErrorCodeConstructorKind = JSC::ConstructorKind::None;
const int s_readableStreamInternalsReadableStreamDefaultControllerErrorCodeLength = 322;
static const JSC::Intrinsic s_readableStreamInternalsReadableStreamDefaultControllerErrorCodeIntrinsic = JSC::NoIntrinsic;
const char* const s_readableStreamInternalsReadableStreamDefaultControllerErrorCode =
    "(function (controller, error)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "\n" \
    "    const stream = @getByIdDirectPrivate(controller, \"controlledReadableStream\");\n" \
    "    if (@getByIdDirectPrivate(stream, \"state\") !== @streamReadable)\n" \
    "        return;\n" \
    "    @putByIdDirectPrivate(controller, \"queue\", @newQueue());\n" \
    "    @readableStreamError(stream, error);\n" \
    "})\n" \
;

const JSC::ConstructAbility s_readableStreamInternalsReadableStreamPipeToCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const JSC::ConstructorKind s_readableStreamInternalsReadableStreamPipeToCodeConstructorKind = JSC::ConstructorKind::None;
const int s_readableStreamInternalsReadableStreamPipeToCodeLength = 778;
static const JSC::Intrinsic s_readableStreamInternalsReadableStreamPipeToCodeIntrinsic = JSC::NoIntrinsic;
const char* const s_readableStreamInternalsReadableStreamPipeToCode =
    "(function (stream, sink)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "    @assert(@isReadableStream(stream));\n" \
    "\n" \
    "    const reader = new @ReadableStreamDefaultReader(stream);\n" \
    "\n" \
    "    @getByIdDirectPrivate(reader, \"closedPromiseCapability\").@promise.@then(() => { }, (e) => { sink.error(e); });\n" \
    "\n" \
    "    function doPipe() {\n" \
    "        @readableStreamDefaultReaderRead(reader).@then(function(result) {\n" \
    "            if (result.done) {\n" \
    "                sink.close();\n" \
    "                return;\n" \
    "            }\n" \
    "            try {\n" \
    "                sink.enqueue(result.value);\n" \
    "            } catch (e) {\n" \
    "                sink.error(\"ReadableStream chunk enqueueing in the sink failed\");\n" \
    "                return;\n" \
    "            }\n" \
    "            doPipe();\n" \
    "        }, function(e) {\n" \
    "            sink.error(e);\n" \
    "        });\n" \
    "    }\n" \
    "    doPipe();\n" \
    "})\n" \
;

const JSC::ConstructAbility s_readableStreamInternalsAcquireReadableStreamDefaultReaderCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const JSC::ConstructorKind s_readableStreamInternalsAcquireReadableStreamDefaultReaderCodeConstructorKind = JSC::ConstructorKind::None;
const int s_readableStreamInternalsAcquireReadableStreamDefaultReaderCodeLength = 356;
static const JSC::Intrinsic s_readableStreamInternalsAcquireReadableStreamDefaultReaderCodeIntrinsic = JSC::NoIntrinsic;
const char* const s_readableStreamInternalsAcquireReadableStreamDefaultReaderCode =
    "(function (stream)\n" \
    "{\n" \
    "    var controller = @getByIdDirectPrivate(stream, \"readableStreamController\");\n" \
    "    if (@isReadableStreamDefaultController(controller)) {\n" \
    "        @readableStreamDefaultControllerStart(controller);\n" \
    "    } else {\n" \
    "        @readableStreamByteStreamControllerStart(controller);\n" \
    "    }\n" \
    "\n" \
    "    return new @ReadableStreamDefaultReader(stream);\n" \
    "})\n" \
;

const JSC::ConstructAbility s_readableStreamInternalsReadableStreamPipeToWritableStreamCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const JSC::ConstructorKind s_readableStreamInternalsReadableStreamPipeToWritableStreamCodeConstructorKind = JSC::ConstructorKind::None;
const int s_readableStreamInternalsReadableStreamPipeToWritableStreamCodeLength = 3213;
static const JSC::Intrinsic s_readableStreamInternalsReadableStreamPipeToWritableStreamCodeIntrinsic = JSC::NoIntrinsic;
const char* const s_readableStreamInternalsReadableStreamPipeToWritableStreamCode =
    "(function (source, destination, preventClose, preventAbort, preventCancel, signal)\n" \
    "{\n" \
    "    @assert(@isReadableStream(source));\n" \
    "    @assert(@isWritableStream(destination));\n" \
    "    @assert(!@isReadableStreamLocked(source));\n" \
    "    @assert(!@isWritableStreamLocked(destination));\n" \
    "    @assert(signal === @undefined || @isAbortSignal(signal));\n" \
    "\n" \
    "    if (@getByIdDirectPrivate(source, \"underlyingByteSource\") !== @undefined)\n" \
    "        return @Promise.@reject(\"Piping to a readable bytestream is not supported\");\n" \
    "\n" \
    "    let pipeState = { source : source, destination : destination, preventAbort : preventAbort, preventCancel : preventCancel, preventClose : preventClose, signal : signal };\n" \
    "\n" \
    "    pipeState.reader = @acquireReadableStreamDefaultReader(source);\n" \
    "    pipeState.writer = @acquireWritableStreamDefaultWriter(destination);\n" \
    "\n" \
    "    @putByIdDirectPrivate(source, \"disturbed\", true);\n" \
    "\n" \
    "    pipeState.finalized = false;\n" \
    "    pipeState.shuttingDown = false;\n" \
    "    pipeState.promiseCapability = @newPromiseCapability(@Promise);\n" \
    "    pipeState.pendingReadPromiseCapability = @newPromiseCapability(@Promise);\n" \
    "    pipeState.pendingReadPromiseCapability.@resolve.@call();\n" \
    "    pipeState.pendingWritePromise = @Promise.@resolve();\n" \
    "\n" \
    "    if (signal !== @undefined) {\n" \
    "        const algorithm = () => {\n" \
    "            if (pipeState.finalized)\n" \
    "                return;\n" \
    "\n" \
    "            const error = @makeDOMException(\"AbortError\", \"abort pipeTo from signal\");\n" \
    "\n" \
    "            @pipeToShutdownWithAction(pipeState, () => {\n" \
    "                const shouldAbortDestination = !pipeState.preventAbort && @getByIdDirectPrivate(pipeState.destination, \"state\") === \"writable\";\n" \
    "                const promiseDestination = shouldAbortDestination ? @writableStreamAbort(pipeState.destination, error) : @Promise.@resolve();\n" \
    "\n" \
    "                const shouldAbortSource = !pipeState.preventCancel && @getByIdDirectPrivate(pipeState.source, \"state\") === @streamReadable;\n" \
    "                const promiseSource = shouldAbortSource ? @readableStreamCancel(pipeState.source, error) : @Promise.@resolve();\n" \
    "\n" \
    "                let promiseCapability = @newPromiseCapability(@Promise);\n" \
    "                let shouldWait = true;\n" \
    "                let handleResolvedPromise = () => {\n" \
    "                    if (shouldWait) {\n" \
    "                        shouldWait = false;\n" \
    "                        return;\n" \
    "                    }\n" \
    "                    promiseCapability.@resolve.@call();\n" \
    "                }\n" \
    "                let handleRejectedPromise = (e) => {\n" \
    "                    promiseCapability.@reject.@call(@undefined, e);\n" \
    "                }\n" \
    "                promiseDestination.@then(handleResolvedPromise, handleRejectedPromise);\n" \
    "                promiseSource.@then(handleResolvedPromise, handleRejectedPromise);\n" \
    "                return promiseCapability.@promise;\n" \
    "            }, error);\n" \
    "        };\n" \
    "        if (@whenSignalAborted(signal, algorithm))\n" \
    "            return pipeState.promiseCapability.@promise;\n" \
    "    }\n" \
    "\n" \
    "    @pipeToErrorsMustBePropagatedForward(pipeState);\n" \
    "    @pipeToErrorsMustBePropagatedBackward(pipeState);\n" \
    "    @pipeToClosingMustBePropagatedForward(pipeState);\n" \
    "    @pipeToClosingMustBePropagatedBackward(pipeState);\n" \
    "\n" \
    "    @pipeToLoop(pipeState);\n" \
    "\n" \
    "    return pipeState.promiseCapability.@promise;\n" \
    "})\n" \
;

const JSC::ConstructAbility s_readableStreamInternalsPipeToLoopCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const JSC::ConstructorKind s_readableStreamInternalsPipeToLoopCodeConstructorKind = JSC::ConstructorKind::None;
const int s_readableStreamInternalsPipeToLoopCodeLength = 194;
static const JSC::Intrinsic s_readableStreamInternalsPipeToLoopCodeIntrinsic = JSC::NoIntrinsic;
const char* const s_readableStreamInternalsPipeToLoopCode =
    "(function (pipeState)\n" \
    "{\n" \
    "    if (pipeState.shuttingDown)\n" \
    "        return;\n" \
    "\n" \
    "    @pipeToDoReadWrite(pipeState).@then((result) => {\n" \
    "        if (result)\n" \
    "            @pipeToLoop(pipeState);\n" \
    "    });\n" \
    "})\n" \
;

const JSC::ConstructAbility s_readableStreamInternalsPipeToDoReadWriteCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const JSC::ConstructorKind s_readableStreamInternalsPipeToDoReadWriteCodeConstructorKind = JSC::ConstructorKind::None;
const int s_readableStreamInternalsPipeToDoReadWriteCodeLength = 1108;
static const JSC::Intrinsic s_readableStreamInternalsPipeToDoReadWriteCodeIntrinsic = JSC::NoIntrinsic;
const char* const s_readableStreamInternalsPipeToDoReadWriteCode =
    "(function (pipeState)\n" \
    "{\n" \
    "    @assert(!pipeState.shuttingDown);\n" \
    "\n" \
    "    pipeState.pendingReadPromiseCapability = @newPromiseCapability(@Promise);\n" \
    "    @getByIdDirectPrivate(pipeState.writer, \"readyPromise\").@promise.@then(() => {\n" \
    "        if (pipeState.shuttingDown) {\n" \
    "            pipeState.pendingReadPromiseCapability.@resolve.@call(@undefined, false);\n" \
    "            return;\n" \
    "        }\n" \
    "\n" \
    "        @readableStreamDefaultReaderRead(pipeState.reader).@then((result) => {\n" \
    "            const canWrite = !result.done && @getByIdDirectPrivate(pipeState.writer, \"stream\") !== @undefined;\n" \
    "            pipeState.pendingReadPromiseCapability.@resolve.@call(@undefined, canWrite);\n" \
    "            if (!canWrite)\n" \
    "                return;\n" \
    "\n" \
    "            pipeState.pendingWritePromise = @writableStreamDefaultWriterWrite(pipeState.writer, result.value);\n" \
    "        }, (e) => {\n" \
    "            pipeState.pendingReadPromiseCapability.@resolve.@call(@undefined, false);\n" \
    "        });\n" \
    "    }, (e) => {\n" \
    "        pipeState.pendingReadPromiseCapability.@resolve.@call(@undefined, false);\n" \
    "    });\n" \
    "    return pipeState.pendingReadPromiseCapability.@promise;\n" \
    "})\n" \
;

const JSC::ConstructAbility s_readableStreamInternalsPipeToErrorsMustBePropagatedForwardCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const JSC::ConstructorKind s_readableStreamInternalsPipeToErrorsMustBePropagatedForwardCodeConstructorKind = JSC::ConstructorKind::None;
const int s_readableStreamInternalsPipeToErrorsMustBePropagatedForwardCodeLength = 676;
static const JSC::Intrinsic s_readableStreamInternalsPipeToErrorsMustBePropagatedForwardCodeIntrinsic = JSC::NoIntrinsic;
const char* const s_readableStreamInternalsPipeToErrorsMustBePropagatedForwardCode =
    "(function (pipeState)\n" \
    "{\n" \
    "    const action = () => {\n" \
    "        pipeState.pendingReadPromiseCapability.@resolve.@call(@undefined, false);\n" \
    "        const error = @getByIdDirectPrivate(pipeState.source, \"storedError\");\n" \
    "        if (!pipeState.preventAbort) {\n" \
    "            @pipeToShutdownWithAction(pipeState, () => @writableStreamAbort(pipeState.destination, error), error);\n" \
    "            return;\n" \
    "        }\n" \
    "        @pipeToShutdown(pipeState, error);\n" \
    "    };\n" \
    "\n" \
    "    if (@getByIdDirectPrivate(pipeState.source, \"state\") === @streamErrored) {\n" \
    "        action();\n" \
    "        return;\n" \
    "    }\n" \
    "\n" \
    "    @getByIdDirectPrivate(pipeState.reader, \"closedPromiseCapability\").@promise.@then(@undefined, action);\n" \
    "})\n" \
;

const JSC::ConstructAbility s_readableStreamInternalsPipeToErrorsMustBePropagatedBackwardCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const JSC::ConstructorKind s_readableStreamInternalsPipeToErrorsMustBePropagatedBackwardCodeConstructorKind = JSC::ConstructorKind::None;
const int s_readableStreamInternalsPipeToErrorsMustBePropagatedBackwardCodeLength = 584;
static const JSC::Intrinsic s_readableStreamInternalsPipeToErrorsMustBePropagatedBackwardCodeIntrinsic = JSC::NoIntrinsic;
const char* const s_readableStreamInternalsPipeToErrorsMustBePropagatedBackwardCode =
    "(function (pipeState)\n" \
    "{\n" \
    "    const action = () => {\n" \
    "        const error = @getByIdDirectPrivate(pipeState.destination, \"storedError\");\n" \
    "        if (!pipeState.preventCancel) {\n" \
    "            @pipeToShutdownWithAction(pipeState, () => @readableStreamCancel(pipeState.source, error), error);\n" \
    "            return;\n" \
    "        }\n" \
    "        @pipeToShutdown(pipeState, error);\n" \
    "    };\n" \
    "    if (@getByIdDirectPrivate(pipeState.destination, \"state\") === \"errored\") {\n" \
    "        action();\n" \
    "        return;\n" \
    "    }\n" \
    "    @getByIdDirectPrivate(pipeState.writer, \"closedPromise\").@promise.@then(@undefined, action);\n" \
    "})\n" \
;

const JSC::ConstructAbility s_readableStreamInternalsPipeToClosingMustBePropagatedForwardCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const JSC::ConstructorKind s_readableStreamInternalsPipeToClosingMustBePropagatedForwardCodeConstructorKind = JSC::ConstructorKind::None;
const int s_readableStreamInternalsPipeToClosingMustBePropagatedForwardCodeLength = 680;
static const JSC::Intrinsic s_readableStreamInternalsPipeToClosingMustBePropagatedForwardCodeIntrinsic = JSC::NoIntrinsic;
const char* const s_readableStreamInternalsPipeToClosingMustBePropagatedForwardCode =
    "(function (pipeState)\n" \
    "{\n" \
    "    const action = () => {\n" \
    "        pipeState.pendingReadPromiseCapability.@resolve.@call(@undefined, false);\n" \
    "        const error = @getByIdDirectPrivate(pipeState.source, \"storedError\");\n" \
    "        if (!pipeState.preventClose) {\n" \
    "            @pipeToShutdownWithAction(pipeState, () => @writableStreamDefaultWriterCloseWithErrorPropagation(pipeState.writer));\n" \
    "            return;\n" \
    "        }\n" \
    "        @pipeToShutdown(pipeState);\n" \
    "    };\n" \
    "    if (@getByIdDirectPrivate(pipeState.source, \"state\") === @streamClosed) {\n" \
    "        action();\n" \
    "        return;\n" \
    "    }\n" \
    "    @getByIdDirectPrivate(pipeState.reader, \"closedPromiseCapability\").@promise.@then(action, @undefined);\n" \
    "})\n" \
;

const JSC::ConstructAbility s_readableStreamInternalsPipeToClosingMustBePropagatedBackwardCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const JSC::ConstructorKind s_readableStreamInternalsPipeToClosingMustBePropagatedBackwardCodeConstructorKind = JSC::ConstructorKind::None;
const int s_readableStreamInternalsPipeToClosingMustBePropagatedBackwardCodeLength = 464;
static const JSC::Intrinsic s_readableStreamInternalsPipeToClosingMustBePropagatedBackwardCodeIntrinsic = JSC::NoIntrinsic;
const char* const s_readableStreamInternalsPipeToClosingMustBePropagatedBackwardCode =
    "(function (pipeState)\n" \
    "{\n" \
    "    if (!@writableStreamCloseQueuedOrInFlight(pipeState.destination) && @getByIdDirectPrivate(pipeState.destination, \"state\") !== \"closed\")\n" \
    "        return;\n" \
    "\n" \
    "    //\n" \
    "\n" \
    "    const error = @makeTypeError(\"closing is propagated backward\");\n" \
    "    if (!pipeState.preventCancel) {\n" \
    "        @pipeToShutdownWithAction(pipeState, () => @readableStreamCancel(pipeState.source, error), error);\n" \
    "        return;\n" \
    "    }\n" \
    "    @pipeToShutdown(pipeState, error);\n" \
    "})\n" \
;

const JSC::ConstructAbility s_readableStreamInternalsPipeToShutdownWithActionCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const JSC::ConstructorKind s_readableStreamInternalsPipeToShutdownWithActionCodeConstructorKind = JSC::ConstructorKind::None;
const int s_readableStreamInternalsPipeToShutdownWithActionCodeLength = 882;
static const JSC::Intrinsic s_readableStreamInternalsPipeToShutdownWithActionCodeIntrinsic = JSC::NoIntrinsic;
const char* const s_readableStreamInternalsPipeToShutdownWithActionCode =
    "(function (pipeState, action)\n" \
    "{\n" \
    "    if (pipeState.shuttingDown)\n" \
    "        return;\n" \
    "\n" \
    "    pipeState.shuttingDown = true;\n" \
    "\n" \
    "    const hasError = arguments.length > 2;\n" \
    "    const error = arguments[2];\n" \
    "    const finalize = () => {\n" \
    "        const promise = action();\n" \
    "        promise.@then(() => {\n" \
    "            if (hasError)\n" \
    "                @pipeToFinalize(pipeState, error);\n" \
    "            else\n" \
    "                @pipeToFinalize(pipeState);\n" \
    "        }, (e)  => {\n" \
    "            @pipeToFinalize(pipeState, e);\n" \
    "        });\n" \
    "    };\n" \
    "\n" \
    "    if (@getByIdDirectPrivate(pipeState.destination, \"state\") === \"writable\" && !@writableStreamCloseQueuedOrInFlight(pipeState.destination)) {\n" \
    "        pipeState.pendingReadPromiseCapability.@promise.@then(() => {\n" \
    "            pipeState.pendingWritePromise.@then(finalize, finalize);\n" \
    "        }, (e) => @pipeToFinalize(pipeState, e));\n" \
    "        return;\n" \
    "    }\n" \
    "\n" \
    "    finalize();\n" \
    "})\n" \
;

const JSC::ConstructAbility s_readableStreamInternalsPipeToShutdownCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const JSC::ConstructorKind s_readableStreamInternalsPipeToShutdownCodeConstructorKind = JSC::ConstructorKind::None;
const int s_readableStreamInternalsPipeToShutdownCodeLength = 717;
static const JSC::Intrinsic s_readableStreamInternalsPipeToShutdownCodeIntrinsic = JSC::NoIntrinsic;
const char* const s_readableStreamInternalsPipeToShutdownCode =
    "(function (pipeState)\n" \
    "{\n" \
    "    if (pipeState.shuttingDown)\n" \
    "        return;\n" \
    "\n" \
    "    pipeState.shuttingDown = true;\n" \
    "\n" \
    "    const hasError = arguments.length > 1;\n" \
    "    const error = arguments[1];\n" \
    "    const finalize = () => {\n" \
    "        if (hasError)\n" \
    "            @pipeToFinalize(pipeState, error);\n" \
    "        else\n" \
    "            @pipeToFinalize(pipeState);\n" \
    "    };\n" \
    "\n" \
    "    if (@getByIdDirectPrivate(pipeState.destination, \"state\") === \"writable\" && !@writableStreamCloseQueuedOrInFlight(pipeState.destination)) {\n" \
    "        pipeState.pendingReadPromiseCapability.@promise.@then(() => {\n" \
    "            pipeState.pendingWritePromise.@then(finalize, finalize);\n" \
    "        }, (e) => @pipeToFinalize(pipeState, e));\n" \
    "        return;\n" \
    "    }\n" \
    "    finalize();\n" \
    "})\n" \
;

const JSC::ConstructAbility s_readableStreamInternalsPipeToFinalizeCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const JSC::ConstructorKind s_readableStreamInternalsPipeToFinalizeCodeConstructorKind = JSC::ConstructorKind::None;
const int s_readableStreamInternalsPipeToFinalizeCodeLength = 356;
static const JSC::Intrinsic s_readableStreamInternalsPipeToFinalizeCodeIntrinsic = JSC::NoIntrinsic;
const char* const s_readableStreamInternalsPipeToFinalizeCode =
    "(function (pipeState)\n" \
    "{\n" \
    "    @writableStreamDefaultWriterRelease(pipeState.writer);\n" \
    "    @readableStreamReaderGenericRelease(pipeState.reader);\n" \
    "\n" \
    "    //\n" \
    "    pipeState.finalized = true;\n" \
    "\n" \
    "    if (arguments.length > 1)\n" \
    "        pipeState.promiseCapability.@reject.@call(@undefined, arguments[1]);\n" \
    "    else\n" \
    "        pipeState.promiseCapability.@resolve.@call();\n" \
    "})\n" \
;

const JSC::ConstructAbility s_readableStreamInternalsReadableStreamTeeCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const JSC::ConstructorKind s_readableStreamInternalsReadableStreamTeeCodeConstructorKind = JSC::ConstructorKind::None;
const int s_readableStreamInternalsReadableStreamTeeCodeLength = 1671;
static const JSC::Intrinsic s_readableStreamInternalsReadableStreamTeeCodeIntrinsic = JSC::NoIntrinsic;
const char* const s_readableStreamInternalsReadableStreamTeeCode =
    "(function (stream, shouldClone)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "\n" \
    "    @assert(@isReadableStream(stream));\n" \
    "    @assert(typeof(shouldClone) === \"boolean\");\n" \
    "\n" \
    "    const reader = new @ReadableStreamDefaultReader(stream);\n" \
    "\n" \
    "    const teeState = {\n" \
    "        closedOrErrored: false,\n" \
    "        canceled1: false,\n" \
    "        canceled2: false,\n" \
    "        reason1: @undefined,\n" \
    "        reason2: @undefined,\n" \
    "    };\n" \
    "\n" \
    "    teeState.cancelPromiseCapability = @newPromiseCapability(@Promise);\n" \
    "\n" \
    "    const pullFunction = @readableStreamTeePullFunction(teeState, reader, shouldClone);\n" \
    "\n" \
    "    const branch1Source = { };\n" \
    "    @putByIdDirectPrivate(branch1Source, \"pull\", pullFunction);\n" \
    "    @putByIdDirectPrivate(branch1Source, \"cancel\", @readableStreamTeeBranch1CancelFunction(teeState, stream));\n" \
    "\n" \
    "    const branch2Source = { };\n" \
    "    @putByIdDirectPrivate(branch2Source, \"pull\", pullFunction);\n" \
    "    @putByIdDirectPrivate(branch2Source, \"cancel\", @readableStreamTeeBranch2CancelFunction(teeState, stream));\n" \
    "\n" \
    "    const branch1 = new @ReadableStream(branch1Source);\n" \
    "    const branch2 = new @ReadableStream(branch2Source);\n" \
    "\n" \
    "    @getByIdDirectPrivate(reader, \"closedPromiseCapability\").@promise.@then(@undefined, function(e) {\n" \
    "        if (teeState.closedOrErrored)\n" \
    "            return;\n" \
    "        @readableStreamDefaultControllerError(branch1.@readableStreamController, e);\n" \
    "        @readableStreamDefaultControllerError(branch2.@readableStreamController, e);\n" \
    "        teeState.closedOrErrored = true;\n" \
    "        if (!teeState.canceled1 || !teeState.canceled2)\n" \
    "            teeState.cancelPromiseCapability.@resolve.@call();\n" \
    "    });\n" \
    "\n" \
    "    //\n" \
    "    teeState.branch1 = branch1;\n" \
    "    teeState.branch2 = branch2;\n" \
    "\n" \
    "    return [branch1, branch2];\n" \
    "})\n" \
;

const JSC::ConstructAbility s_readableStreamInternalsReadableStreamTeePullFunctionCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const JSC::ConstructorKind s_readableStreamInternalsReadableStreamTeePullFunctionCodeConstructorKind = JSC::ConstructorKind::None;
const int s_readableStreamInternalsReadableStreamTeePullFunctionCodeLength = 1275;
static const JSC::Intrinsic s_readableStreamInternalsReadableStreamTeePullFunctionCodeIntrinsic = JSC::NoIntrinsic;
const char* const s_readableStreamInternalsReadableStreamTeePullFunctionCode =
    "(function (teeState, reader, shouldClone)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "\n" \
    "    return function() {\n" \
    "        @Promise.prototype.@then.@call(@readableStreamDefaultReaderRead(reader), function(result) {\n" \
    "            @assert(@isObject(result));\n" \
    "            @assert(typeof result.done === \"boolean\");\n" \
    "            if (result.done && !teeState.closedOrErrored) {\n" \
    "                if (!teeState.canceled1)\n" \
    "                    @readableStreamDefaultControllerClose(teeState.branch1.@readableStreamController);\n" \
    "                if (!teeState.canceled2)\n" \
    "                    @readableStreamDefaultControllerClose(teeState.branch2.@readableStreamController);\n" \
    "                teeState.closedOrErrored = true;\n" \
    "                if (!teeState.canceled1 || !teeState.canceled2)\n" \
    "                    teeState.cancelPromiseCapability.@resolve.@call();\n" \
    "            }\n" \
    "            if (teeState.closedOrErrored)\n" \
    "                return;\n" \
    "            if (!teeState.canceled1)\n" \
    "                @readableStreamDefaultControllerEnqueue(teeState.branch1.@readableStreamController, result.value);\n" \
    "            if (!teeState.canceled2)\n" \
    "                @readableStreamDefaultControllerEnqueue(teeState.branch2.@readableStreamController, shouldClone ? @structuredCloneForStream(result.value) : result.value);\n" \
    "        });\n" \
    "    }\n" \
    "})\n" \
;

const JSC::ConstructAbility s_readableStreamInternalsReadableStreamTeeBranch1CancelFunctionCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const JSC::ConstructorKind s_readableStreamInternalsReadableStreamTeeBranch1CancelFunctionCodeConstructorKind = JSC::ConstructorKind::None;
const int s_readableStreamInternalsReadableStreamTeeBranch1CancelFunctionCodeLength = 456;
static const JSC::Intrinsic s_readableStreamInternalsReadableStreamTeeBranch1CancelFunctionCodeIntrinsic = JSC::NoIntrinsic;
const char* const s_readableStreamInternalsReadableStreamTeeBranch1CancelFunctionCode =
    "(function (teeState, stream)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "\n" \
    "    return function(r) {\n" \
    "        teeState.canceled1 = true;\n" \
    "        teeState.reason1 = r;\n" \
    "        if (teeState.canceled2) {\n" \
    "            @readableStreamCancel(stream, [teeState.reason1, teeState.reason2]).@then(\n" \
    "                teeState.cancelPromiseCapability.@resolve,\n" \
    "                teeState.cancelPromiseCapability.@reject);\n" \
    "        }\n" \
    "        return teeState.cancelPromiseCapability.@promise;\n" \
    "    }\n" \
    "})\n" \
;

const JSC::ConstructAbility s_readableStreamInternalsReadableStreamTeeBranch2CancelFunctionCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const JSC::ConstructorKind s_readableStreamInternalsReadableStreamTeeBranch2CancelFunctionCodeConstructorKind = JSC::ConstructorKind::None;
const int s_readableStreamInternalsReadableStreamTeeBranch2CancelFunctionCodeLength = 456;
static const JSC::Intrinsic s_readableStreamInternalsReadableStreamTeeBranch2CancelFunctionCodeIntrinsic = JSC::NoIntrinsic;
const char* const s_readableStreamInternalsReadableStreamTeeBranch2CancelFunctionCode =
    "(function (teeState, stream)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "\n" \
    "    return function(r) {\n" \
    "        teeState.canceled2 = true;\n" \
    "        teeState.reason2 = r;\n" \
    "        if (teeState.canceled1) {\n" \
    "            @readableStreamCancel(stream, [teeState.reason1, teeState.reason2]).@then(\n" \
    "                teeState.cancelPromiseCapability.@resolve,\n" \
    "                teeState.cancelPromiseCapability.@reject);\n" \
    "        }\n" \
    "        return teeState.cancelPromiseCapability.@promise;\n" \
    "    }\n" \
    "})\n" \
;

const JSC::ConstructAbility s_readableStreamInternalsIsReadableStreamCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const JSC::ConstructorKind s_readableStreamInternalsIsReadableStreamCodeConstructorKind = JSC::ConstructorKind::None;
const int s_readableStreamInternalsIsReadableStreamCodeLength = 170;
static const JSC::Intrinsic s_readableStreamInternalsIsReadableStreamCodeIntrinsic = JSC::NoIntrinsic;
const char* const s_readableStreamInternalsIsReadableStreamCode =
    "(function (stream)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "\n" \
    "    //\n" \
    "    //\n" \
    "    //\n" \
    "    return @isObject(stream) && @getByIdDirectPrivate(stream, \"readableStreamController\") !== @undefined;\n" \
    "})\n" \
;

const JSC::ConstructAbility s_readableStreamInternalsIsReadableStreamDefaultReaderCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const JSC::ConstructorKind s_readableStreamInternalsIsReadableStreamDefaultReaderCodeConstructorKind = JSC::ConstructorKind::None;
const int s_readableStreamInternalsIsReadableStreamDefaultReaderCodeLength = 145;
static const JSC::Intrinsic s_readableStreamInternalsIsReadableStreamDefaultReaderCodeIntrinsic = JSC::NoIntrinsic;
const char* const s_readableStreamInternalsIsReadableStreamDefaultReaderCode =
    "(function (reader)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "\n" \
    "    //\n" \
    "    //\n" \
    "    //\n" \
    "    return @isObject(reader) && !!@getByIdDirectPrivate(reader, \"readRequests\");\n" \
    "})\n" \
;

const JSC::ConstructAbility s_readableStreamInternalsIsReadableStreamDefaultControllerCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const JSC::ConstructorKind s_readableStreamInternalsIsReadableStreamDefaultControllerCodeConstructorKind = JSC::ConstructorKind::None;
const int s_readableStreamInternalsIsReadableStreamDefaultControllerCodeLength = 168;
static const JSC::Intrinsic s_readableStreamInternalsIsReadableStreamDefaultControllerCodeIntrinsic = JSC::NoIntrinsic;
const char* const s_readableStreamInternalsIsReadableStreamDefaultControllerCode =
    "(function (controller)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "\n" \
    "    //\n" \
    "    //\n" \
    "    //\n" \
    "    //\n" \
    "    return @isObject(controller) && !!@getByIdDirectPrivate(controller, \"underlyingSource\");\n" \
    "})\n" \
;

const JSC::ConstructAbility s_readableStreamInternalsReadableStreamErrorCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const JSC::ConstructorKind s_readableStreamInternalsReadableStreamErrorCodeConstructorKind = JSC::ConstructorKind::None;
const int s_readableStreamInternalsReadableStreamErrorCodeLength = 1266;
static const JSC::Intrinsic s_readableStreamInternalsReadableStreamErrorCodeIntrinsic = JSC::NoIntrinsic;
const char* const s_readableStreamInternalsReadableStreamErrorCode =
    "(function (stream, error)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "\n" \
    "    @assert(@isReadableStream(stream));\n" \
    "    @assert(@getByIdDirectPrivate(stream, \"state\") === @streamReadable);\n" \
    "    @putByIdDirectPrivate(stream, \"state\", @streamErrored);\n" \
    "    @putByIdDirectPrivate(stream, \"storedError\", error);\n" \
    "\n" \
    "    const reader = @getByIdDirectPrivate(stream, \"reader\");\n" \
    "\n" \
    "    if (!reader)\n" \
    "        return;\n" \
    "\n" \
    "        if (@isReadableStreamDefaultReader(reader)) {\n" \
    "        const requests = @getByIdDirectPrivate(reader, \"readRequests\");\n" \
    "        @putByIdDirectPrivate(reader, \"readRequests\", @createFIFO());\n" \
    "        for (var request = requests.shift(); request; request = requests.shift())\n" \
    "            @rejectPromise(request, error);\n" \
    "    } else {\n" \
    "        @assert(@isReadableStreamBYOBReader(reader));\n" \
    "        const requests = @getByIdDirectPrivate(reader, \"readIntoRequests\");\n" \
    "        @putByIdDirectPrivate(reader, \"readIntoRequests\", @createFIFO());\n" \
    "        for (var request = requests.shift(); request; request = requests.shift())\n" \
    "            @rejectPromise(request, error);\n" \
    "    }\n" \
    "\n" \
    "    @getByIdDirectPrivate(reader, \"closedPromiseCapability\").@reject.@call(@undefined, error);\n" \
    "    const promise = @getByIdDirectPrivate(reader, \"closedPromiseCapability\").@promise;\n" \
    "    @markPromiseAsHandled(promise);\n" \
    "})\n" \
;

const JSC::ConstructAbility s_readableStreamInternalsReadableStreamDefaultControllerShouldCallPullCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const JSC::ConstructorKind s_readableStreamInternalsReadableStreamDefaultControllerShouldCallPullCodeConstructorKind = JSC::ConstructorKind::None;
const int s_readableStreamInternalsReadableStreamDefaultControllerShouldCallPullCodeLength = 665;
static const JSC::Intrinsic s_readableStreamInternalsReadableStreamDefaultControllerShouldCallPullCodeIntrinsic = JSC::NoIntrinsic;
const char* const s_readableStreamInternalsReadableStreamDefaultControllerShouldCallPullCode =
    "(function (controller)\n" \
    "{\n" \
    "    const stream = @getByIdDirectPrivate(controller, \"controlledReadableStream\");\n" \
    "\n" \
    "    if (!@readableStreamDefaultControllerCanCloseOrEnqueue(controller))\n" \
    "        return false;\n" \
    "    if (!(@getByIdDirectPrivate(controller, \"started\") > 0))\n" \
    "        return false;\n" \
    "    if ((!@isReadableStreamLocked(stream) || !@getByIdDirectPrivate(@getByIdDirectPrivate(stream, \"reader\"), \"readRequests\")?.isNotEmpty()) && @readableStreamDefaultControllerGetDesiredSize(controller) <= 0)\n" \
    "        return false;\n" \
    "    const desiredSize = @readableStreamDefaultControllerGetDesiredSize(controller);\n" \
    "    @assert(desiredSize !== null);\n" \
    "    return desiredSize > 0;\n" \
    "})\n" \
;

const JSC::ConstructAbility s_readableStreamInternalsReadableStreamDefaultControllerCallPullIfNeededCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const JSC::ConstructorKind s_readableStreamInternalsReadableStreamDefaultControllerCallPullIfNeededCodeConstructorKind = JSC::ConstructorKind::None;
const int s_readableStreamInternalsReadableStreamDefaultControllerCallPullIfNeededCodeLength = 1252;
static const JSC::Intrinsic s_readableStreamInternalsReadableStreamDefaultControllerCallPullIfNeededCodeIntrinsic = JSC::NoIntrinsic;
const char* const s_readableStreamInternalsReadableStreamDefaultControllerCallPullIfNeededCode =
    "(function (controller)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "\n" \
    "    //\n" \
    "    const stream = @getByIdDirectPrivate(controller, \"controlledReadableStream\");\n" \
    "\n" \
    "    if (!@readableStreamDefaultControllerCanCloseOrEnqueue(controller))\n" \
    "        return;\n" \
    "    if (!(@getByIdDirectPrivate(controller, \"started\") > 0))\n" \
    "        return;\n" \
    "    if ((!@isReadableStreamLocked(stream) || !@getByIdDirectPrivate(@getByIdDirectPrivate(stream, \"reader\"), \"readRequests\")?.isNotEmpty()) && @readableStreamDefaultControllerGetDesiredSize(controller) <= 0)\n" \
    "        return;\n" \
    "\n" \
    "    if (@getByIdDirectPrivate(controller, \"pulling\")) {\n" \
    "        @putByIdDirectPrivate(controller, \"pullAgain\", true);\n" \
    "        return;\n" \
    "    }\n" \
    "\n" \
    "    @assert(!@getByIdDirectPrivate(controller, \"pullAgain\"));\n" \
    "    @putByIdDirectPrivate(controller, \"pulling\", true);\n" \
    "\n" \
    "    @getByIdDirectPrivate(controller, \"pullAlgorithm\").@call(@undefined).@then(function() {\n" \
    "        @putByIdDirectPrivate(controller, \"pulling\", false);\n" \
    "        if (@getByIdDirectPrivate(controller, \"pullAgain\")) {\n" \
    "            @putByIdDirectPrivate(controller, \"pullAgain\", false);\n" \
    "            @readableStreamDefaultControllerCallPullIfNeeded(controller);\n" \
    "        }\n" \
    "    }, function(error) {\n" \
    "        @readableStreamDefaultControllerError(controller, error);\n" \
    "    });\n" \
    "})\n" \
;

const JSC::ConstructAbility s_readableStreamInternalsIsReadableStreamLockedCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const JSC::ConstructorKind s_readableStreamInternalsIsReadableStreamLockedCodeConstructorKind = JSC::ConstructorKind::None;
const int s_readableStreamInternalsIsReadableStreamLockedCodeLength = 136;
static const JSC::Intrinsic s_readableStreamInternalsIsReadableStreamLockedCodeIntrinsic = JSC::NoIntrinsic;
const char* const s_readableStreamInternalsIsReadableStreamLockedCode =
    "(function (stream)\n" \
    "{\n" \
    "   \"use strict\";\n" \
    "\n" \
    "    @assert(@isReadableStream(stream));\n" \
    "    return !!@getByIdDirectPrivate(stream, \"reader\");\n" \
    "})\n" \
;

const JSC::ConstructAbility s_readableStreamInternalsReadableStreamDefaultControllerGetDesiredSizeCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const JSC::ConstructorKind s_readableStreamInternalsReadableStreamDefaultControllerGetDesiredSizeCodeConstructorKind = JSC::ConstructorKind::None;
const int s_readableStreamInternalsReadableStreamDefaultControllerGetDesiredSizeCodeLength = 416;
static const JSC::Intrinsic s_readableStreamInternalsReadableStreamDefaultControllerGetDesiredSizeCodeIntrinsic = JSC::NoIntrinsic;
const char* const s_readableStreamInternalsReadableStreamDefaultControllerGetDesiredSizeCode =
    "(function (controller)\n" \
    "{\n" \
    "   \"use strict\";\n" \
    "\n" \
    "    const stream = @getByIdDirectPrivate(controller, \"controlledReadableStream\");\n" \
    "    const state = @getByIdDirectPrivate(stream, \"state\");\n" \
    "\n" \
    "    if (state === @streamErrored)\n" \
    "        return null;\n" \
    "    if (state === @streamClosed)\n" \
    "        return 0;\n" \
    "\n" \
    "    return @getByIdDirectPrivate(controller, \"strategy\").highWaterMark - @getByIdDirectPrivate(controller, \"queue\").size;\n" \
    "})\n" \
;

const JSC::ConstructAbility s_readableStreamInternalsReadableStreamReaderGenericCancelCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const JSC::ConstructorKind s_readableStreamInternalsReadableStreamReaderGenericCancelCodeConstructorKind = JSC::ConstructorKind::None;
const int s_readableStreamInternalsReadableStreamReaderGenericCancelCodeLength = 197;
static const JSC::Intrinsic s_readableStreamInternalsReadableStreamReaderGenericCancelCodeIntrinsic = JSC::NoIntrinsic;
const char* const s_readableStreamInternalsReadableStreamReaderGenericCancelCode =
    "(function (reader, reason)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "\n" \
    "    const stream = @getByIdDirectPrivate(reader, \"ownerReadableStream\");\n" \
    "    @assert(!!stream);\n" \
    "    return @readableStreamCancel(stream, reason);\n" \
    "})\n" \
;

const JSC::ConstructAbility s_readableStreamInternalsReadableStreamCancelCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const JSC::ConstructorKind s_readableStreamInternalsReadableStreamCancelCodeConstructorKind = JSC::ConstructorKind::None;
const int s_readableStreamInternalsReadableStreamCancelCodeLength = 547;
static const JSC::Intrinsic s_readableStreamInternalsReadableStreamCancelCodeIntrinsic = JSC::NoIntrinsic;
const char* const s_readableStreamInternalsReadableStreamCancelCode =
    "(function (stream, reason)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "\n" \
    "    @putByIdDirectPrivate(stream, \"disturbed\", true);\n" \
    "    const state = @getByIdDirectPrivate(stream, \"state\");\n" \
    "    if (state === @streamClosed)\n" \
    "        return @Promise.@resolve();\n" \
    "    if (state === @streamErrored)\n" \
    "        return @Promise.@reject(@getByIdDirectPrivate(stream, \"storedError\"));\n" \
    "    @readableStreamClose(stream);\n" \
    "    return @getByIdDirectPrivate(stream, \"readableStreamController\").@cancel(@getByIdDirectPrivate(stream, \"readableStreamController\"), reason).@then(function() {  });\n" \
    "})\n" \
;

const JSC::ConstructAbility s_readableStreamInternalsReadableStreamDefaultControllerCancelCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const JSC::ConstructorKind s_readableStreamInternalsReadableStreamDefaultControllerCancelCodeConstructorKind = JSC::ConstructorKind::None;
const int s_readableStreamInternalsReadableStreamDefaultControllerCancelCodeLength = 207;
static const JSC::Intrinsic s_readableStreamInternalsReadableStreamDefaultControllerCancelCodeIntrinsic = JSC::NoIntrinsic;
const char* const s_readableStreamInternalsReadableStreamDefaultControllerCancelCode =
    "(function (controller, reason)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "\n" \
    "    @putByIdDirectPrivate(controller, \"queue\", @newQueue());\n" \
    "    return @getByIdDirectPrivate(controller, \"cancelAlgorithm\").@call(@undefined, reason);\n" \
    "})\n" \
;

const JSC::ConstructAbility s_readableStreamInternalsReadableStreamDefaultControllerPullCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const JSC::ConstructorKind s_readableStreamInternalsReadableStreamDefaultControllerPullCodeConstructorKind = JSC::ConstructorKind::None;
const int s_readableStreamInternalsReadableStreamDefaultControllerPullCodeLength = 758;
static const JSC::Intrinsic s_readableStreamInternalsReadableStreamDefaultControllerPullCodeIntrinsic = JSC::NoIntrinsic;
const char* const s_readableStreamInternalsReadableStreamDefaultControllerPullCode =
    "(function (controller)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "\n" \
    "    var queue  = @getByIdDirectPrivate(controller, \"queue\");\n" \
    "    if (queue.content.isNotEmpty()) {\n" \
    "        const chunk = @dequeueValue(queue);\n" \
    "        if (@getByIdDirectPrivate(controller, \"closeRequested\") && queue.content.isEmpty())\n" \
    "            @readableStreamClose(@getByIdDirectPrivate(controller, \"controlledReadableStream\"));\n" \
    "        else\n" \
    "            @readableStreamDefaultControllerCallPullIfNeeded(controller);\n" \
    "\n" \
    "        return @createFulfilledPromise({ value: chunk, done: false });\n" \
    "    }\n" \
    "    const pendingPromise = @readableStreamAddReadRequest(@getByIdDirectPrivate(controller, \"controlledReadableStream\"));\n" \
    "    @readableStreamDefaultControllerCallPullIfNeeded(controller);\n" \
    "    return pendingPromise;\n" \
    "})\n" \
;

const JSC::ConstructAbility s_readableStreamInternalsReadableStreamDefaultControllerCloseCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const JSC::ConstructorKind s_readableStreamInternalsReadableStreamDefaultControllerCloseCodeConstructorKind = JSC::ConstructorKind::None;
const int s_readableStreamInternalsReadableStreamDefaultControllerCloseCodeLength = 351;
static const JSC::Intrinsic s_readableStreamInternalsReadableStreamDefaultControllerCloseCodeIntrinsic = JSC::NoIntrinsic;
const char* const s_readableStreamInternalsReadableStreamDefaultControllerCloseCode =
    "(function (controller)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "\n" \
    "    @assert(@readableStreamDefaultControllerCanCloseOrEnqueue(controller));\n" \
    "    @putByIdDirectPrivate(controller, \"closeRequested\", true);\n" \
    "    if (@getByIdDirectPrivate(controller, \"queue\")?.content?.isEmpty())\n" \
    "        @readableStreamClose(@getByIdDirectPrivate(controller, \"controlledReadableStream\"));\n" \
    "})\n" \
;

const JSC::ConstructAbility s_readableStreamInternalsReadableStreamCloseCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const JSC::ConstructorKind s_readableStreamInternalsReadableStreamCloseCodeConstructorKind = JSC::ConstructorKind::None;
const int s_readableStreamInternalsReadableStreamCloseCodeLength = 875;
static const JSC::Intrinsic s_readableStreamInternalsReadableStreamCloseCodeIntrinsic = JSC::NoIntrinsic;
const char* const s_readableStreamInternalsReadableStreamCloseCode =
    "(function (stream)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "\n" \
    "    @assert(@getByIdDirectPrivate(stream, \"state\") === @streamReadable);\n" \
    "    @putByIdDirectPrivate(stream, \"state\", @streamClosed);\n" \
    "    if (!@getByIdDirectPrivate(stream, \"reader\"))\n" \
    "        return;\n" \
    "\n" \
    "    if (@isReadableStreamDefaultReader(@getByIdDirectPrivate(stream, \"reader\"))) {\n" \
    "        const requests = @getByIdDirectPrivate(@getByIdDirectPrivate(stream, \"reader\"), \"readRequests\");\n" \
    "        if (requests.isNotEmpty()) {\n" \
    "            @putByIdDirectPrivate(@getByIdDirectPrivate(stream, \"reader\"), \"readRequests\", @createFIFO());\n" \
    "        \n" \
    "            for (var request = requests.shift(); request; request = requests.shift())\n" \
    "                @fulfillPromise(request, { value: @undefined, done: true });\n" \
    "        }\n" \
    "    }\n" \
    "\n" \
    "    @getByIdDirectPrivate(@getByIdDirectPrivate(stream, \"reader\"), \"closedPromiseCapability\").@resolve.@call();\n" \
    "})\n" \
;

const JSC::ConstructAbility s_readableStreamInternalsReadableStreamFulfillReadRequestCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const JSC::ConstructorKind s_readableStreamInternalsReadableStreamFulfillReadRequestCodeConstructorKind = JSC::ConstructorKind::None;
const int s_readableStreamInternalsReadableStreamFulfillReadRequestCodeLength = 231;
static const JSC::Intrinsic s_readableStreamInternalsReadableStreamFulfillReadRequestCodeIntrinsic = JSC::NoIntrinsic;
const char* const s_readableStreamInternalsReadableStreamFulfillReadRequestCode =
    "(function (stream, chunk, done)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "    const readRequest = @getByIdDirectPrivate(@getByIdDirectPrivate(stream, \"reader\"), \"readRequests\").shift();\n" \
    "    @fulfillPromise(readRequest, { value: chunk, done: done });\n" \
    "})\n" \
;

const JSC::ConstructAbility s_readableStreamInternalsReadableStreamDefaultControllerEnqueueCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const JSC::ConstructorKind s_readableStreamInternalsReadableStreamDefaultControllerEnqueueCodeConstructorKind = JSC::ConstructorKind::None;
const int s_readableStreamInternalsReadableStreamDefaultControllerEnqueueCodeLength = 993;
static const JSC::Intrinsic s_readableStreamInternalsReadableStreamDefaultControllerEnqueueCodeIntrinsic = JSC::NoIntrinsic;
const char* const s_readableStreamInternalsReadableStreamDefaultControllerEnqueueCode =
    "(function (controller, chunk)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "\n" \
    "    const stream = @getByIdDirectPrivate(controller, \"controlledReadableStream\");\n" \
    "    //\n" \
    "    @assert(@readableStreamDefaultControllerCanCloseOrEnqueue(controller));\n" \
    "\n" \
    "    if (@isReadableStreamLocked(stream) && @getByIdDirectPrivate(@getByIdDirectPrivate(stream, \"reader\"), \"readRequests\")?.isNotEmpty()) {\n" \
    "        @readableStreamFulfillReadRequest(stream, chunk, false);\n" \
    "        @readableStreamDefaultControllerCallPullIfNeeded(controller);\n" \
    "        return;\n" \
    "    }\n" \
    "\n" \
    "    try {\n" \
    "        let chunkSize = 1;\n" \
    "        if (@getByIdDirectPrivate(controller, \"strategy\").size !== @undefined)\n" \
    "            chunkSize = @getByIdDirectPrivate(controller, \"strategy\").size(chunk);\n" \
    "        @enqueueValueWithSize(@getByIdDirectPrivate(controller, \"queue\"), chunk, chunkSize);\n" \
    "    }\n" \
    "    catch(error) {\n" \
    "        @readableStreamDefaultControllerError(controller, error);\n" \
    "        throw error;\n" \
    "    }\n" \
    "    @readableStreamDefaultControllerCallPullIfNeeded(controller);\n" \
    "})\n" \
;

const JSC::ConstructAbility s_readableStreamInternalsReadableStreamDefaultReaderReadCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const JSC::ConstructorKind s_readableStreamInternalsReadableStreamDefaultReaderReadCodeConstructorKind = JSC::ConstructorKind::None;
const int s_readableStreamInternalsReadableStreamDefaultReaderReadCodeLength = 649;
static const JSC::Intrinsic s_readableStreamInternalsReadableStreamDefaultReaderReadCodeIntrinsic = JSC::NoIntrinsic;
const char* const s_readableStreamInternalsReadableStreamDefaultReaderReadCode =
    "(function (reader)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "\n" \
    "    const stream = @getByIdDirectPrivate(reader, \"ownerReadableStream\");\n" \
    "    @assert(!!stream);\n" \
    "    const state = @getByIdDirectPrivate(stream, \"state\");\n" \
    "\n" \
    "    @putByIdDirectPrivate(stream, \"disturbed\", true);\n" \
    "    if (state === @streamClosed)\n" \
    "        return @createFulfilledPromise({ value: @undefined, done: true });\n" \
    "    if (state === @streamErrored)\n" \
    "        return @Promise.@reject(@getByIdDirectPrivate(stream, \"storedError\"));\n" \
    "    @assert(state === @streamReadable);\n" \
    "\n" \
    "    return @getByIdDirectPrivate(stream, \"readableStreamController\").@pull(@getByIdDirectPrivate(stream, \"readableStreamController\"));\n" \
    "})\n" \
;

const JSC::ConstructAbility s_readableStreamInternalsReadableStreamAddReadRequestCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const JSC::ConstructorKind s_readableStreamInternalsReadableStreamAddReadRequestCodeConstructorKind = JSC::ConstructorKind::None;
const int s_readableStreamInternalsReadableStreamAddReadRequestCodeLength = 373;
static const JSC::Intrinsic s_readableStreamInternalsReadableStreamAddReadRequestCodeIntrinsic = JSC::NoIntrinsic;
const char* const s_readableStreamInternalsReadableStreamAddReadRequestCode =
    "(function (stream)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "\n" \
    "    @assert(@isReadableStreamDefaultReader(@getByIdDirectPrivate(stream, \"reader\")));\n" \
    "    @assert(@getByIdDirectPrivate(stream, \"state\") == @streamReadable);\n" \
    "\n" \
    "    const readRequest = @newPromise();\n" \
    "    \n" \
    "    @getByIdDirectPrivate(@getByIdDirectPrivate(stream, \"reader\"), \"readRequests\").push(readRequest);\n" \
    "\n" \
    "    return readRequest;\n" \
    "})\n" \
;

const JSC::ConstructAbility s_readableStreamInternalsIsReadableStreamDisturbedCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const JSC::ConstructorKind s_readableStreamInternalsIsReadableStreamDisturbedCodeConstructorKind = JSC::ConstructorKind::None;
const int s_readableStreamInternalsIsReadableStreamDisturbedCodeLength = 138;
static const JSC::Intrinsic s_readableStreamInternalsIsReadableStreamDisturbedCodeIntrinsic = JSC::NoIntrinsic;
const char* const s_readableStreamInternalsIsReadableStreamDisturbedCode =
    "(function (stream)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "\n" \
    "    @assert(@isReadableStream(stream));\n" \
    "    return @getByIdDirectPrivate(stream, \"disturbed\");\n" \
    "})\n" \
;

const JSC::ConstructAbility s_readableStreamInternalsReadableStreamReaderGenericReleaseCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const JSC::ConstructorKind s_readableStreamInternalsReadableStreamReaderGenericReleaseCodeConstructorKind = JSC::ConstructorKind::None;
const int s_readableStreamInternalsReadableStreamReaderGenericReleaseCodeLength = 968;
static const JSC::Intrinsic s_readableStreamInternalsReadableStreamReaderGenericReleaseCodeIntrinsic = JSC::NoIntrinsic;
const char* const s_readableStreamInternalsReadableStreamReaderGenericReleaseCode =
    "(function (reader)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "\n" \
    "    @assert(!!@getByIdDirectPrivate(reader, \"ownerReadableStream\"));\n" \
    "    @assert(@getByIdDirectPrivate(@getByIdDirectPrivate(reader, \"ownerReadableStream\"), \"reader\") === reader);\n" \
    "\n" \
    "    if (@getByIdDirectPrivate(@getByIdDirectPrivate(reader, \"ownerReadableStream\"), \"state\") === @streamReadable)\n" \
    "        @getByIdDirectPrivate(reader, \"closedPromiseCapability\").@reject.@call(@undefined, @makeTypeError(\"releasing lock of reader whose stream is still in readable state\"));\n" \
    "    else\n" \
    "        @putByIdDirectPrivate(reader, \"closedPromiseCapability\", { @promise: @newHandledRejectedPromise(@makeTypeError(\"reader released lock\")) });\n" \
    "\n" \
    "    const promise = @getByIdDirectPrivate(reader, \"closedPromiseCapability\").@promise;\n" \
    "    @markPromiseAsHandled(promise);\n" \
    "    @putByIdDirectPrivate(@getByIdDirectPrivate(reader, \"ownerReadableStream\"), \"reader\", @undefined);\n" \
    "    @putByIdDirectPrivate(reader, \"ownerReadableStream\", @undefined);\n" \
    "})\n" \
;

const JSC::ConstructAbility s_readableStreamInternalsReadableStreamDefaultControllerCanCloseOrEnqueueCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const JSC::ConstructorKind s_readableStreamInternalsReadableStreamDefaultControllerCanCloseOrEnqueueCodeConstructorKind = JSC::ConstructorKind::None;
const int s_readableStreamInternalsReadableStreamDefaultControllerCanCloseOrEnqueueCodeLength = 229;
static const JSC::Intrinsic s_readableStreamInternalsReadableStreamDefaultControllerCanCloseOrEnqueueCodeIntrinsic = JSC::NoIntrinsic;
const char* const s_readableStreamInternalsReadableStreamDefaultControllerCanCloseOrEnqueueCode =
    "(function (controller)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "\n" \
    "    return !@getByIdDirectPrivate(controller, \"closeRequested\") && @getByIdDirectPrivate(@getByIdDirectPrivate(controller, \"controlledReadableStream\"), \"state\") === @streamReadable;\n" \
    "})\n" \
;


#define DEFINE_BUILTIN_GENERATOR(codeName, functionName, overriddenName, argumentCount) \
JSC::FunctionExecutable* codeName##Generator(JSC::VM& vm) \
{\
    JSVMClientData* clientData = static_cast<JSVMClientData*>(vm.clientData); \
    return clientData->builtinFunctions().readableStreamInternalsBuiltins().codeName##Executable()->link(vm, nullptr, clientData->builtinFunctions().readableStreamInternalsBuiltins().codeName##Source(), std::nullopt, s_##codeName##Intrinsic); \
}
WEBCORE_FOREACH_READABLESTREAMINTERNALS_BUILTIN_CODE(DEFINE_BUILTIN_GENERATOR)
#undef DEFINE_BUILTIN_GENERATOR


} // namespace WebCore
