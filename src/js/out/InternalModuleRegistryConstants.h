// clang-format off
#pragma once

namespace Bun {
namespace InternalModuleRegistryConstants {

#if __APPLE__
  //
static constexpr ASCIILiteral BunFFICode = "(function (){\"use strict\";// src/js/out/tmp/bun/ffi.ts\nvar FFIBuilder = function(params, returnType, functionToCall, name) {\n  const hasReturnType = typeof FFIType[returnType] === \"number\" && FFIType[returnType] !== FFIType.void;\n  var paramNames = new Array(params.length), args = new Array(params.length);\n  for (let i = 0;i < params.length; i++) {\n    paramNames[i] = `p${i}`;\n    const wrapper = ffiWrappers[FFIType[params[i]]];\n    if (wrapper)\n      args[i] = `(val=>${wrapper})(p${i})`;\n    else\n      @throwTypeError(`Unsupported type ${params[i]}. Must be one of: ${Object.keys(FFIType).sort().join(\", \")}`);\n  }\n  var code = `functionToCall(${args.join(\", \")})`;\n  if (hasReturnType)\n    if (FFIType[returnType] === FFIType.cstring)\n      code = `return new __GlobalBunCString(${code})`;\n    else\n      code = `return ${code}`;\n  var func = new Function(\"functionToCall\", ...paramNames, code);\n  Object.defineProperty(func, \"name\", {\n    value: name\n  });\n  var wrap;\n  switch (paramNames.length) {\n    case 0:\n      wrap = () => func(functionToCall);\n      break;\n    case 1:\n      wrap = (arg1) => func(functionToCall, arg1);\n      break;\n    case 2:\n      wrap = (arg1, arg2) => func(functionToCall, arg1, arg2);\n      break;\n    case 3:\n      wrap = (arg1, arg2, arg3) => func(functionToCall, arg1, arg2, arg3);\n      break;\n    case 4:\n      wrap = (arg1, arg2, arg3, arg4) => func(functionToCall, arg1, arg2, arg3, arg4);\n      break;\n    case 5:\n      wrap = (arg1, arg2, arg3, arg4, arg5) => func(functionToCall, arg1, arg2, arg3, arg4, arg5);\n      break;\n    case 6:\n      wrap = (arg1, arg2, arg3, arg4, arg5, arg6) => func(functionToCall, arg1, arg2, arg3, arg4, arg5, arg6);\n      break;\n    case 7:\n      wrap = (arg1, arg2, arg3, arg4, arg5, arg6, arg7) => func(functionToCall, arg1, arg2, arg3, arg4, arg5, arg6, arg7);\n      break;\n    case 8:\n      wrap = (arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) => func(functionToCall, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);\n      break;\n    case 9:\n      wrap = (arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9) => func(functionToCall, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9);\n      break;\n    default: {\n      wrap = (...args2) => func(functionToCall, ...args2);\n      break;\n    }\n  }\n  return wrap.native = functionToCall, wrap.ptr = functionToCall.ptr, wrap;\n}, dlopen = function(path, options) {\n  const result = nativeDLOpen(path, options);\n  for (let key in result.symbols) {\n    var symbol = result.symbols[key];\n    if (options[key]\?.args\?.length || FFIType[options[key]\?.returns] === FFIType.cstring)\n      result.symbols[key] = FFIBuilder(options[key].args \?\? [], options[key].returns \?\? FFIType.void, symbol, path.includes(\"/\") \? `${key} (${path.split(\"/\").pop()})` : `${key} (${path})`);\n    else\n      result.symbols[key].native = result.symbols[key];\n  }\n  return result;\n}, linkSymbols = function(options) {\n  const result = nativeLinkSymbols(options);\n  for (let key in result.symbols) {\n    var symbol = result.symbols[key];\n    if (options[key]\?.args\?.length || FFIType[options[key]\?.returns] === FFIType.cstring)\n      result.symbols[key] = FFIBuilder(options[key].args \?\? [], options[key].returns \?\? FFIType.void, symbol, key);\n    else\n      result.symbols[key].native = result.symbols[key];\n  }\n  return result;\n}, onCloseCFunction = function(close) {\n  close();\n}, CFunction = function(options) {\n  const identifier = `CFunction${cFunctionI++}`;\n  var result = linkSymbols({\n    [identifier]: options\n  }), hasClosed = !1, close = result.close;\n  return result.symbols[identifier].close = () => {\n    if (hasClosed || !close)\n      return;\n    hasClosed = !0, close(), close = void 0;\n  }, cFunctionRegistry ||= new FinalizationRegistry(onCloseCFunction), cFunctionRegistry.register(result.symbols[identifier], result.symbols[identifier].close), result.symbols[identifier];\n}, $, FFIType = {\n  \"0\": 0,\n  \"1\": 1,\n  \"2\": 2,\n  \"3\": 3,\n  \"4\": 4,\n  \"5\": 5,\n  \"6\": 6,\n  \"7\": 7,\n  \"8\": 8,\n  \"9\": 9,\n  \"10\": 10,\n  \"11\": 11,\n  \"12\": 12,\n  \"13\": 13,\n  \"14\": 14,\n  \"15\": 15,\n  \"16\": 16,\n  \"17\": 17,\n  bool: 11,\n  c_int: 5,\n  c_uint: 6,\n  char: 0,\n  \"char*\": 12,\n  double: 9,\n  f32: 10,\n  f64: 9,\n  float: 10,\n  i16: 3,\n  i32: 5,\n  i64: 7,\n  i8: 1,\n  int: 5,\n  int16_t: 3,\n  int32_t: 5,\n  int64_t: 7,\n  int8_t: 1,\n  isize: 7,\n  u16: 4,\n  u32: 6,\n  u64: 8,\n  u8: 2,\n  uint16_t: 4,\n  uint32_t: 6,\n  uint64_t: 8,\n  uint8_t: 2,\n  usize: 8,\n  \"void*\": 12,\n  ptr: 12,\n  pointer: 12,\n  void: 13,\n  cstring: 14,\n  i64_fast: 15,\n  u64_fast: 16,\n  function: 17,\n  callback: 17,\n  fn: 17\n};\nvar ffi = globalThis.Bun.FFI, ptr = (arg1, arg2) => typeof arg2 === \"undefined\" \? ffi.ptr(arg1) : ffi.ptr(arg1, arg2), toBuffer = ffi.toBuffer, toArrayBuffer = ffi.toArrayBuffer, viewSource = ffi.viewSource, BunCString = ffi.CString, nativeLinkSymbols = ffi.linkSymbols, nativeDLOpen = ffi.dlopen, nativeCallback = ffi.callback, closeCallback = ffi.closeCallback;\ndelete ffi.callback;\ndelete ffi.closeCallback;\n\nclass JSCallback {\n  constructor(cb, options) {\n    const { ctx, ptr: ptr2 } = nativeCallback(options, cb);\n    this.#ctx = ctx, this.ptr = ptr2, this.#threadsafe = !!options\?.threadsafe;\n  }\n  ptr;\n  #ctx;\n  #threadsafe;\n  get threadsafe() {\n    return this.#threadsafe;\n  }\n  [Symbol.toPrimitive]() {\n    const { ptr: ptr2 } = this;\n    return typeof ptr2 === \"number\" \? ptr2 : 0;\n  }\n  close() {\n    const ctx = this.#ctx;\n    if (this.ptr = null, this.#ctx = null, ctx)\n      closeCallback(ctx);\n  }\n}\n\nclass CString extends String {\n  constructor(ptr2, byteOffset, byteLength) {\n    super(ptr2 \? typeof byteLength === \"number\" && Number.isSafeInteger(byteLength) \? BunCString(ptr2, byteOffset || 0, byteLength) : BunCString(ptr2) : \"\");\n    if (this.ptr = typeof ptr2 === \"number\" \? ptr2 : 0, typeof byteOffset !== \"undefined\")\n      this.byteOffset = byteOffset;\n    if (typeof byteLength !== \"undefined\")\n      this.byteLength = byteLength;\n  }\n  ptr;\n  byteOffset;\n  byteLength;\n  #cachedArrayBuffer;\n  get arrayBuffer() {\n    if (this.#cachedArrayBuffer)\n      return this.#cachedArrayBuffer;\n    if (!this.ptr)\n      return this.#cachedArrayBuffer = new ArrayBuffer(0);\n    return this.#cachedArrayBuffer = toArrayBuffer(this.ptr, this.byteOffset, this.byteLength);\n  }\n}\nObject.defineProperty(globalThis, \"__GlobalBunCString\", {\n  value: CString,\n  enumerable: !1,\n  configurable: !1\n});\nvar ffiWrappers = new Array(18), char = \"val|0\";\nffiWrappers.fill(char);\nffiWrappers[FFIType.uint8_t] = \"val<0\?0:val>=255\?255:val|0\";\nffiWrappers[FFIType.int16_t] = \"val<=-32768\?-32768:val>=32768\?32768:val|0\";\nffiWrappers[FFIType.uint16_t] = \"val<=0\?0:val>=65536\?65536:val|0\";\nffiWrappers[FFIType.int32_t] = \"val|0\";\nffiWrappers[FFIType.uint32_t] = \"val<=0\?0:val>=0xffffffff\?0xffffffff:+val||0\";\nffiWrappers[FFIType.i64_fast] = `{\n  if (typeof val === \"bigint\") {\n    if (val <= BigInt(Number.MAX_SAFE_INTEGER) && val >= BigInt(-Number.MAX_SAFE_INTEGER)) {\n      return Number(val).valueOf() || 0;\n    }\n\n    return val;\n  }\n\n  return !val \? 0 : +val || 0;\n}`;\nffiWrappers[FFIType.i64_fast] = `{\n  if (typeof val === \"bigint\") {\n    if (val <= BigInt(Number.MAX_SAFE_INTEGER) && val >= BigInt(-Number.MAX_SAFE_INTEGER)) {\n      return Number(val).valueOf() || 0;\n    }\n\n    return val;\n  }\n\n  return !val \? 0 : +val || 0;\n}`;\nffiWrappers[FFIType.u64_fast] = `{\n  if (typeof val === \"bigint\") {\n    if (val <= BigInt(Number.MAX_SAFE_INTEGER) && val >= 0) {\n      return Number(val).valueOf() || 0;\n    }\n\n    return val;\n  }\n\n  return !val \? 0 : +val || 0;\n}`;\nffiWrappers[FFIType.int64_t] = `{\n  if (typeof val === \"bigint\") {\n    return val;\n  }\n\n  if (typeof val === \"number\") {\n    return BigInt(val || 0);\n  }\n\n  return BigInt(+val || 0);\n}`;\nffiWrappers[FFIType.uint64_t] = `{\n  if (typeof val === \"bigint\") {\n    return val;\n  }\n\n  if (typeof val === \"number\") {\n    return val <= 0 \? BigInt(0) : BigInt(val || 0);\n  }\n\n  return BigInt(+val || 0);\n}`;\nffiWrappers[FFIType.u64_fast] = `{\n  if (typeof val === \"bigint\") {\n    if (val <= BigInt(Number.MAX_SAFE_INTEGER) && val >= BigInt(0)) return Number(val);\n    return val;\n  }\n\n  return typeof val === \"number\" \? (val <= 0 \? 0 : +val || 0) : +val || 0;\n}`;\nffiWrappers[FFIType.uint16_t] = `{\n  const ret = (typeof val === \"bigint\" \? Number(val) : val) | 0;\n  return ret <= 0 \? 0 : ret > 0xffff \? 0xffff : ret;\n}`;\nffiWrappers[FFIType.double] = `{\n  if (typeof val === \"bigint\") {\n    if (val.valueOf() < BigInt(Number.MAX_VALUE)) {\n      return Math.abs(Number(val).valueOf()) + 0.00000000000001 - 0.00000000000001;\n    }\n  }\n\n  if (!val) {\n    return 0 + 0.00000000000001 - 0.00000000000001;\n  }\n\n  return val + 0.00000000000001 - 0.00000000000001;\n}`;\nffiWrappers[FFIType.float] = ffiWrappers[10] = `{\n  return Math.fround(val);\n}`;\nffiWrappers[FFIType.bool] = `{\n  return !!val;\n}`;\nObject.defineProperty(globalThis, \"__GlobalBunFFIPtrFunctionForWrapper\", {\n  value: ptr,\n  enumerable: !1,\n  configurable: !0\n});\nffiWrappers[FFIType.cstring] = ffiWrappers[FFIType.pointer] = `{\n  if (typeof val === \"number\") return val;\n  if (!val) {\n    return null;\n  }\n\n  if (ArrayBuffer.isView(val) || val instanceof ArrayBuffer) {\n    return __GlobalBunFFIPtrFunctionForWrapper(val);\n  }\n\n  if (typeof val === \"string\") {\n    throw new TypeError(\"To convert a string to a pointer, encode it as a buffer\");\n  }\n\n  throw new TypeError(\\`Unable to convert \\${ val } to a pointer\\`);\n}`;\nffiWrappers[FFIType.function] = `{\n  if (typeof val === \"number\") {\n    return val;\n  }\n\n  if (typeof val === \"bigint\") {\n    return Number(val);\n  }\n\n  var ptr = val && val.ptr;\n\n  if (!ptr) {\n    throw new TypeError(\"Expected function to be a JSCallback or a number\");\n  }\n\n  return ptr;\n}`;\nvar native = {\n  dlopen: nativeDLOpen,\n  callback: () => {\n    throw new Error(\"Deprecated. Use new JSCallback(options, fn) instead\");\n  }\n}, cFunctionI = 0, cFunctionRegistry, read = ffi.read;\n$ = {\n  CFunction,\n  CString,\n  FFIType,\n  JSCallback,\n  dlopen,\n  linkSymbols,\n  native,\n  ptr,\n  read,\n  suffix: \"dylib\",\n  toArrayBuffer,\n  toBuffer,\n  viewSource\n};\nreturn $})\n"_s;
//

//
static constexpr ASCIILiteral BunSqliteCode = "(function (){\"use strict\";// src/js/out/tmp/bun/sqlite.ts\nvar $, defineProperties = Object.defineProperties, toStringTag = Symbol.toStringTag, isArray = Array.isArray, isTypedArray = ArrayBuffer.isView, constants = {\n  SQLITE_OPEN_READONLY: 1,\n  SQLITE_OPEN_READWRITE: 2,\n  SQLITE_OPEN_CREATE: 4,\n  SQLITE_OPEN_DELETEONCLOSE: 8,\n  SQLITE_OPEN_EXCLUSIVE: 16,\n  SQLITE_OPEN_AUTOPROXY: 32,\n  SQLITE_OPEN_URI: 64,\n  SQLITE_OPEN_MEMORY: 128,\n  SQLITE_OPEN_MAIN_DB: 256,\n  SQLITE_OPEN_TEMP_DB: 512,\n  SQLITE_OPEN_TRANSIENT_DB: 1024,\n  SQLITE_OPEN_MAIN_JOURNAL: 2048,\n  SQLITE_OPEN_TEMP_JOURNAL: 4096,\n  SQLITE_OPEN_SUBJOURNAL: 8192,\n  SQLITE_OPEN_SUPER_JOURNAL: 16384,\n  SQLITE_OPEN_NOMUTEX: 32768,\n  SQLITE_OPEN_FULLMUTEX: 65536,\n  SQLITE_OPEN_SHAREDCACHE: 131072,\n  SQLITE_OPEN_PRIVATECACHE: 262144,\n  SQLITE_OPEN_WAL: 524288,\n  SQLITE_OPEN_NOFOLLOW: 16777216,\n  SQLITE_OPEN_EXRESCODE: 33554432,\n  SQLITE_PREPARE_PERSISTENT: 1,\n  SQLITE_PREPARE_NORMALIZE: 2,\n  SQLITE_PREPARE_NO_VTAB: 4\n}, SQL, controllers;\n\nclass Statement {\n  constructor(raw) {\n    switch (this.#raw = raw, raw.paramsCount) {\n      case 0: {\n        this.get = this.#getNoArgs, this.all = this.#allNoArgs, this.values = this.#valuesNoArgs, this.run = this.#runNoArgs;\n        break;\n      }\n      default: {\n        this.get = this.#get, this.all = this.#all, this.values = this.#values, this.run = this.#run;\n        break;\n      }\n    }\n  }\n  #raw;\n  get;\n  all;\n  values;\n  run;\n  isFinalized = !1;\n  toJSON() {\n    return {\n      sql: this.native.toString(),\n      isFinalized: this.isFinalized,\n      paramsCount: this.paramsCount,\n      columnNames: this.columnNames\n    };\n  }\n  get [toStringTag]() {\n    return `\"${this.native.toString()}\"`;\n  }\n  toString() {\n    return this.native.toString();\n  }\n  get native() {\n    return this.#raw;\n  }\n  #getNoArgs() {\n    return this.#raw.get();\n  }\n  #allNoArgs() {\n    return this.#raw.all();\n  }\n  #valuesNoArgs() {\n    return this.#raw.values();\n  }\n  #runNoArgs() {\n    this.#raw.run();\n  }\n  #get(...args) {\n    if (args.length === 0)\n      return this.#getNoArgs();\n    var arg0 = args[0];\n    return !isArray(arg0) && (!arg0 || typeof arg0 !== \"object\" || isTypedArray(arg0)) \? this.#raw.get(args) : this.#raw.get(...args);\n  }\n  #all(...args) {\n    if (args.length === 0)\n      return this.#allNoArgs();\n    var arg0 = args[0];\n    return !isArray(arg0) && (!arg0 || typeof arg0 !== \"object\" || isTypedArray(arg0)) \? this.#raw.all(args) : this.#raw.all(...args);\n  }\n  #values(...args) {\n    if (args.length === 0)\n      return this.#valuesNoArgs();\n    var arg0 = args[0];\n    return !isArray(arg0) && (!arg0 || typeof arg0 !== \"object\" || isTypedArray(arg0)) \? this.#raw.values(args) : this.#raw.values(...args);\n  }\n  #run(...args) {\n    if (args.length === 0)\n      return this.#runNoArgs();\n    var arg0 = args[0];\n    !isArray(arg0) && (!arg0 || typeof arg0 !== \"object\" || isTypedArray(arg0)) \? this.#raw.run(args) : this.#raw.run(...args);\n  }\n  get columnNames() {\n    return this.#raw.columns;\n  }\n  get paramsCount() {\n    return this.#raw.paramsCount;\n  }\n  finalize(...args) {\n    return this.isFinalized = !0, this.#raw.finalize(...args);\n  }\n}\nvar cachedCount = Symbol.for(\"Bun.Database.cache.count\");\n\nclass Database {\n  constructor(filenameGiven, options) {\n    if (typeof filenameGiven === \"undefined\")\n      ;\n    else if (typeof filenameGiven !== \"string\") {\n      if (isTypedArray(filenameGiven)) {\n        this.#handle = Database.deserialize(filenameGiven, typeof options === \"object\" && options \? !!options.readonly : ((options | 0) & constants.SQLITE_OPEN_READONLY) != 0), this.filename = \":memory:\";\n        return;\n      }\n      @throwTypeError(`Expected 'filename' to be a string, got '${typeof filenameGiven}'`);\n    }\n    var filename = typeof filenameGiven === \"string\" \? filenameGiven.trim() : \":memory:\", flags = constants.SQLITE_OPEN_READWRITE | constants.SQLITE_OPEN_CREATE;\n    if (typeof options === \"object\" && options) {\n      if (flags = 0, options.readonly)\n        flags = constants.SQLITE_OPEN_READONLY;\n      if (\"readOnly\" in options)\n        @throwTypeError('Misspelled option \"readOnly\" should be \"readonly\"');\n      if (options.create)\n        flags = constants.SQLITE_OPEN_READWRITE | constants.SQLITE_OPEN_CREATE;\n      if (options.readwrite)\n        flags |= constants.SQLITE_OPEN_READWRITE;\n    } else if (typeof options === \"number\")\n      flags = options;\n    const anonymous = filename === \"\" || filename === \":memory:\";\n    if (anonymous && (flags & constants.SQLITE_OPEN_READONLY) !== 0)\n      throw new Error(\"Cannot open an anonymous database in read-only mode.\");\n    if (!SQL)\n      SQL = globalThis[globalThis.Symbol.for('Bun.lazy')](\"sqlite\");\n    this.#handle = SQL.open(anonymous \? \":memory:\" : filename, flags), this.filename = filename;\n  }\n  #handle;\n  #cachedQueriesKeys = [];\n  #cachedQueriesLengths = [];\n  #cachedQueriesValues = [];\n  filename;\n  get handle() {\n    return this.#handle;\n  }\n  get inTransaction() {\n    return SQL.isInTransaction(this.#handle);\n  }\n  static open(filename, options) {\n    return new Database(filename, options);\n  }\n  loadExtension(name, entryPoint) {\n    return SQL.loadExtension(this.#handle, name, entryPoint);\n  }\n  serialize(optionalName) {\n    return SQL.serialize(this.#handle, optionalName || \"main\");\n  }\n  static deserialize(serialized, isReadOnly = !1) {\n    if (!SQL)\n      SQL = globalThis[globalThis.Symbol.for('Bun.lazy')](\"sqlite\");\n    return SQL.deserialize(serialized, isReadOnly);\n  }\n  static setCustomSQLite(path) {\n    if (!SQL)\n      SQL = globalThis[globalThis.Symbol.for('Bun.lazy')](\"sqlite\");\n    return SQL.setCustomSQLite(path);\n  }\n  close() {\n    return this.clearQueryCache(), SQL.close(this.#handle);\n  }\n  clearQueryCache() {\n    for (let item of this.#cachedQueriesValues)\n      item.finalize();\n    this.#cachedQueriesKeys.length = 0, this.#cachedQueriesValues.length = 0, this.#cachedQueriesLengths.length = 0;\n  }\n  run(query, ...params) {\n    if (params.length === 0) {\n      SQL.run(this.#handle, query);\n      return;\n    }\n    var arg0 = params[0];\n    return !isArray(arg0) && (!arg0 || typeof arg0 !== \"object\" || isTypedArray(arg0)) \? SQL.run(this.#handle, query, params) : SQL.run(this.#handle, query, ...params);\n  }\n  prepare(query, params, flags) {\n    return new Statement(SQL.prepare(this.#handle, query, params, flags || 0));\n  }\n  static MAX_QUERY_CACHE_SIZE = 20;\n  get [cachedCount]() {\n    return this.#cachedQueriesKeys.length;\n  }\n  query(query) {\n    if (typeof query !== \"string\")\n      @throwTypeError(`Expected 'query' to be a string, got '${typeof query}'`);\n    if (query.length === 0)\n      throw new Error(\"SQL query cannot be empty.\");\n    var index = this.#cachedQueriesLengths.indexOf(query.length);\n    while (index !== -1) {\n      if (this.#cachedQueriesKeys[index] !== query) {\n        index = this.#cachedQueriesLengths.indexOf(query.length, index + 1);\n        continue;\n      }\n      var stmt = this.#cachedQueriesValues[index];\n      if (stmt.isFinalized)\n        return this.#cachedQueriesValues[index] = this.prepare(query, void 0, willCache \? constants.SQLITE_PREPARE_PERSISTENT : 0);\n      return stmt;\n    }\n    const willCache = this.#cachedQueriesKeys.length < Database.MAX_QUERY_CACHE_SIZE;\n    var stmt = this.prepare(query, void 0, willCache \? constants.SQLITE_PREPARE_PERSISTENT : 0);\n    if (willCache)\n      this.#cachedQueriesKeys.push(query), this.#cachedQueriesLengths.push(query.length), this.#cachedQueriesValues.push(stmt);\n    return stmt;\n  }\n  transaction(fn, self) {\n    if (typeof fn !== \"function\")\n      @throwTypeError(\"Expected first argument to be a function\");\n    const db = this, controller = getController(db, self), properties = {\n      default: { value: wrapTransaction(fn, db, controller.default) },\n      deferred: { value: wrapTransaction(fn, db, controller.deferred) },\n      immediate: {\n        value: wrapTransaction(fn, db, controller.immediate)\n      },\n      exclusive: {\n        value: wrapTransaction(fn, db, controller.exclusive)\n      },\n      database: { value: this, enumerable: !0 }\n    };\n    return defineProperties(properties.default.value, properties), defineProperties(properties.deferred.value, properties), defineProperties(properties.immediate.value, properties), defineProperties(properties.exclusive.value, properties), properties.default.value;\n  }\n}\nDatabase.prototype.exec = Database.prototype.run;\nvar getController = (db, self) => {\n  let controller = (controllers ||= new WeakMap).get(db);\n  if (!controller) {\n    const shared = {\n      commit: db.prepare(\"COMMIT\", void 0, 0),\n      rollback: db.prepare(\"ROLLBACK\", void 0, 0),\n      savepoint: db.prepare(\"SAVEPOINT `\\t_bs3.\\t`\", void 0, 0),\n      release: db.prepare(\"RELEASE `\\t_bs3.\\t`\", void 0, 0),\n      rollbackTo: db.prepare(\"ROLLBACK TO `\\t_bs3.\\t`\", void 0, 0)\n    };\n    controllers.set(db, controller = {\n      default: Object.assign({ begin: db.prepare(\"BEGIN\", void 0, 0) }, shared),\n      deferred: Object.assign({ begin: db.prepare(\"BEGIN DEFERRED\", void 0, 0) }, shared),\n      immediate: Object.assign({ begin: db.prepare(\"BEGIN IMMEDIATE\", void 0, 0) }, shared),\n      exclusive: Object.assign({ begin: db.prepare(\"BEGIN EXCLUSIVE\", void 0, 0) }, shared)\n    });\n  }\n  return controller;\n}, wrapTransaction = (fn, db, { begin, commit, rollback, savepoint, release, rollbackTo }) => function transaction(...args) {\n  let before, after, undo;\n  if (db.inTransaction)\n    before = savepoint, after = release, undo = rollbackTo;\n  else\n    before = begin, after = commit, undo = rollback;\n  try {\n    before.run();\n    const result = fn.apply(this, args);\n    return after.run(), result;\n  } catch (ex) {\n    if (db.inTransaction) {\n      if (undo.run(), undo !== rollback)\n        after.run();\n    }\n    throw ex;\n  }\n};\n$ = {\n  __esModule: !0,\n  Database,\n  Statement,\n  constants,\n  default: Database\n};\nreturn $})\n"_s;
//

//
static constexpr ASCIILiteral InternalDebuggerCode = "(function (){\"use strict\";// src/js/out/tmp/internal/debugger.ts\nvar generatePath = function() {\n  if (!generatedPath)\n    generatedPath = \"/\" + Math.random().toString(36).slice(2);\n  return generatedPath;\n}, terminalLink = function(url) {\n  if (Bun.enableANSIColors)\n    return \"\\x1B[1m\\x1B]8;;\" + url + \"\\x1B\\\\\" + url + \"\\x1B]8;;\\x1B\\\\\" + \"\\x1B[22m\";\n  return url;\n}, dim = function(text) {\n  if (Bun.enableANSIColors)\n    return \"\\x1B[2m\" + text + \"\\x1B[22m\";\n  return text;\n}, $, sendFn_, disconnectFn_, debuggerCounter = 1;\n\nclass DebuggerWithMessageQueue {\n  debugger = void 0;\n  messageQueue = [];\n  count = debuggerCounter++;\n  send(msg) {\n    sendFn_.call(this.debugger, msg);\n  }\n  disconnect() {\n    disconnectFn_.call(this.debugger), this.messageQueue.length = 0;\n  }\n}\nvar defaultPort = 6499, generatedPath = \"\";\n\nclass WebSocketListener {\n  server;\n  url = \"\";\n  createInspectorConnection;\n  scriptExecutionContextId = 0;\n  activeConnections = new Set;\n  constructor(scriptExecutionContextId = 0, url, createInspectorConnection) {\n    this.scriptExecutionContextId = scriptExecutionContextId, this.createInspectorConnection = createInspectorConnection, this.server = this.start(url);\n  }\n  start(url) {\n    let defaultHostname = \"localhost\", usingDefaultPort = !1;\n    if (/^[0-9]*$/.test(url))\n      url = \"ws://\" + defaultHostname + \":\" + url + generatePath();\n    else if (!url || url.startsWith(\"/\"))\n      url = \"ws://\" + defaultHostname + \":\" + defaultPort + generatePath(), usingDefaultPort = !0;\n    else if (url.includes(\":\") && !url.includes(\"://\"))\n      try {\n        const insertSlash = !url.includes(\"/\");\n        if (url = new URL(\"ws://\" + url).href, insertSlash)\n          url += generatePath().slice(1);\n      } catch (e) {\n        console.error(\"[Inspector]\", \"Failed to parse url\", '\"' + url + '\"'), process.exit(1);\n      }\n    try {\n      var { hostname, port, pathname } = new URL(url);\n      this.url = pathname.toLowerCase();\n    } catch (e) {\n      console.error(\"[Inspector]\", \"Failed to parse url\", '\"' + url + '\"'), process.exit(1);\n    }\n    const serveOptions = {\n      hostname,\n      development: !1,\n      reusePort: !1,\n      websocket: {\n        idleTimeout: 0,\n        open: (socket) => {\n          var connection = new DebuggerWithMessageQueue;\n          const shouldRefEventLoop = !!socket.data\?.shouldRefEventLoop;\n          socket.data = connection, this.activeConnections.add(socket), connection.debugger = this.createInspectorConnection(this.scriptExecutionContextId, shouldRefEventLoop, (...msgs) => {\n            if (socket.readyState > 1) {\n              connection.disconnect();\n              return;\n            }\n            if (connection.messageQueue.length > 0) {\n              connection.messageQueue.push(...msgs);\n              return;\n            }\n            for (let i = 0;i < msgs.length; i++)\n              if (!socket.sendText(msgs[i])) {\n                if (socket.readyState < 2)\n                  connection.messageQueue.push(...msgs.slice(i));\n                return;\n              }\n          }), console.log(\"[Inspector]\", \"Connection #\" + connection.count + \" opened\", \"(\" + new Intl.DateTimeFormat(void 0, {\n            timeStyle: \"long\",\n            dateStyle: \"short\"\n          }).format(new Date) + \")\");\n        },\n        drain: (socket) => {\n          const queue = socket.data.messageQueue;\n          for (let i = 0;i < queue.length; i++)\n            if (!socket.sendText(queue[i])) {\n              socket.data.messageQueue = queue.slice(i);\n              return;\n            }\n          queue.length = 0;\n        },\n        message: (socket, message) => {\n          if (typeof message !== \"string\") {\n            console.warn(\"[Inspector]\", \"Received non-string message\");\n            return;\n          }\n          socket.data.send(message);\n        },\n        close: (socket) => {\n          socket.data.disconnect(), console.log(\"[Inspector]\", \"Connection #\" + socket.data.count + \" closed\", \"(\" + new Intl.DateTimeFormat(void 0, {\n            timeStyle: \"long\",\n            dateStyle: \"short\"\n          }).format(new Date) + \")\"), this.activeConnections.delete(socket);\n        }\n      },\n      fetch: (req, server2) => {\n        let { pathname: pathname2 } = new URL(req.url);\n        if (pathname2 = pathname2.toLowerCase(), pathname2 === \"/json/version\")\n          return Response.json({\n            Browser: navigator.userAgent,\n            \"WebKit-Version\": process.versions.webkit,\n            \"Bun-Version\": Bun.version,\n            \"Bun-Revision\": Bun.revision\n          });\n        if (pathname2 === this.url) {\n          const refHeader = req.headers.get(\"Ref-Event-Loop\");\n          if (server2.upgrade(req, {\n            data: {\n              shouldRefEventLoop: !!refHeader && refHeader !== \"0\"\n            }\n          }))\n            return new Response;\n          return new Response(\"WebSocket expected\", {\n            status: 400\n          });\n        }\n        return new Response(\"Not found\", {\n          status: 404\n        });\n      }\n    };\n    if (port === \"\")\n      port = defaultPort + \"\";\n    let portNumber = Number(port);\n    var server, lastError;\n    if (usingDefaultPort)\n      for (let tries = 0;tries < 10 && !server; tries++)\n        try {\n          lastError = void 0, server = Bun.serve({\n            ...serveOptions,\n            port: portNumber++\n          });\n        } catch (e) {\n          lastError = e;\n        }\n    else\n      try {\n        server = Bun.serve({\n          ...serveOptions,\n          port: portNumber\n        });\n      } catch (e) {\n        lastError = e;\n      }\n    if (!server) {\n      if (console.error(\"[Inspector]\", \"Failed to start server\"), lastError)\n        console.error(lastError);\n      process.exit(1);\n    }\n    let textToWrite = \"\";\n    function writeToConsole(text) {\n      textToWrite += text;\n    }\n    function flushToConsole() {\n      console.write(textToWrite);\n    }\n    return writeToConsole(dim(\"------------------ Bun Inspector ------------------\\n\")), writeToConsole(\"\\x1B[49m\"), writeToConsole(\"Listening at:\\n  \" + `ws://${hostname}:${server.port}${this.url}` + \"\\n\\nInspect in browser:\\n  \" + terminalLink(new URL(`https://debug.bun.sh#${server.hostname}:${server.port}${this.url}`).href) + \"\\n\"), writeToConsole(dim(\"------------------ Bun Inspector ------------------\\n\")), flushToConsole(), server;\n  }\n}\nvar listener;\n$ = function start(debuggerId, hostOrPort, createInspectorConnection, sendFn, disconnectFn) {\n  try {\n    sendFn_ = sendFn, disconnectFn_ = disconnectFn, globalThis.listener = listener ||= new WebSocketListener(debuggerId, hostOrPort, createInspectorConnection);\n  } catch (e) {\n    console.error(\"Bun Inspector threw an exception\\n\", e), process.exit(1);\n  }\n  return `http://${listener.server.hostname}:${listener.server.port}${listener.url}`;\n};\nreturn $})\n"_s;
//

//
static constexpr ASCIILiteral InternalSharedCode = "(function (){\"use strict\";// src/js/out/tmp/internal/shared.ts\nvar throwNotImplemented = function(feature, issue) {\n  throw hideFromStack(throwNotImplemented), new NotImplementedError(feature, issue);\n}, hideFromStack = function(...fns) {\n  for (let fn of fns)\n    Object.defineProperty(fn, \"name\", {\n      value: \"::bunternal::\"\n    });\n}, $;\n\nclass NotImplementedError extends Error {\n  code;\n  constructor(feature, issue) {\n    super(feature + \" is not yet implemented in Bun.\" + (issue \? \" Track the status & thumbs up the issue: https://github.com/oven-sh/bun/issues/\" + issue : \"\"));\n    this.name = \"NotImplementedError\", this.code = \"ERR_NOT_IMPLEMENTED\", hideFromStack(NotImplementedError);\n  }\n}\n$ = {\n  NotImplementedError,\n  throwNotImplemented,\n  hideFromStack\n};\nreturn $})\n"_s;
//

//
static constexpr ASCIILiteral NodeAssertCode = "(function (){\"use strict\";// src/js/out/tmp/node/assert.ts\nvar CallTracker = function() {\n  throw new Error(\"CallTracker is not supported yet\");\n}, util = @getInternalField(@internalModuleRegistry, 43) || @createInternalModuleById(43), isDeepEqual = Bun.deepEquals, __commonJS = (cb, mod) => function() {\n  return mod || (0, cb[Object.keys(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;\n}, require_errors = __commonJS({\n  \"assert/build/internal/errors.js\"(exports, module2) {\n    function _typeof(obj) {\n      return typeof Symbol == \"function\" && typeof Symbol.iterator == \"symbol\" \? _typeof = function(obj2) {\n        return typeof obj2;\n      } : _typeof = function(obj2) {\n        return obj2 && typeof Symbol == \"function\" && obj2.constructor === Symbol && obj2 !== Symbol.prototype \? \"symbol\" : typeof obj2;\n      }, _typeof(obj);\n    }\n    function _classCallCheck(instance, Constructor) {\n      if (!(instance instanceof Constructor))\n        @throwTypeError(\"Cannot call a class as a function\");\n    }\n    function _possibleConstructorReturn(self, call) {\n      return call && (_typeof(call) === \"object\" || typeof call == \"function\") \? call : _assertThisInitialized(self);\n    }\n    function _assertThisInitialized(self) {\n      if (self === void 0)\n        throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n      return self;\n    }\n    function _getPrototypeOf(o) {\n      return _getPrototypeOf = Object.setPrototypeOf \? Object.getPrototypeOf : function(o2) {\n        return o2.__proto__ || Object.getPrototypeOf(o2);\n      }, _getPrototypeOf(o);\n    }\n    function _inherits(subClass, superClass) {\n      if (typeof superClass != \"function\" && superClass !== null)\n        @throwTypeError(\"Super expression must either be null or a function\");\n      subClass.prototype = Object.create(superClass && superClass.prototype, {\n        constructor: { value: subClass, writable: !0, configurable: !0 }\n      }), superClass && _setPrototypeOf(subClass, superClass);\n    }\n    function _setPrototypeOf(o, p) {\n      return _setPrototypeOf = Object.setPrototypeOf || function(o2, p2) {\n        return o2.__proto__ = p2, o2;\n      }, _setPrototypeOf(o, p);\n    }\n    var codes = {}, assert, util2;\n    function createErrorType(code, message, Base) {\n      Base || (Base = Error);\n      function getMessage(arg1, arg2, arg3) {\n        return typeof message == \"string\" \? message : message(arg1, arg2, arg3);\n      }\n      var NodeError = function(_Base) {\n        _inherits(NodeError2, _Base);\n        function NodeError2(arg1, arg2, arg3) {\n          var _this;\n          return _classCallCheck(this, NodeError2), _this = _possibleConstructorReturn(this, _getPrototypeOf(NodeError2).call(this, getMessage(arg1, arg2, arg3))), _this.code = code, _this;\n        }\n        return NodeError2;\n      }(Base);\n      codes[code] = NodeError;\n    }\n    function oneOf(expected, thing) {\n      if (Array.isArray(expected)) {\n        var len = expected.length;\n        return expected = expected.map(function(i) {\n          return String(i);\n        }), len > 2 \? \"one of \".concat(thing, \" \").concat(expected.slice(0, len - 1).join(\", \"), \", or \") + expected[len - 1] : len === 2 \? \"one of \".concat(thing, \" \").concat(expected[0], \" or \").concat(expected[1]) : \"of \".concat(thing, \" \").concat(expected[0]);\n      } else\n        return \"of \".concat(thing, \" \").concat(String(expected));\n    }\n    function startsWith(str, search, pos) {\n      return str.substr(!pos || pos < 0 \? 0 : +pos, search.length) === search;\n    }\n    function endsWith(str, search, this_len) {\n      return (this_len === void 0 || this_len > str.length) && (this_len = str.length), str.substring(this_len - search.length, this_len) === search;\n    }\n    function includes(str, search, start) {\n      return typeof start != \"number\" && (start = 0), start + search.length > str.length \? !1 : str.indexOf(search, start) !== -1;\n    }\n    createErrorType(\"ERR_AMBIGUOUS_ARGUMENT\", 'The \"%s\" argument is ambiguous. %s', TypeError), createErrorType(\"ERR_INVALID_ARG_TYPE\", function(name, expected, actual) {\n      assert === void 0 && (assert = require_assert()), assert(typeof name == \"string\", \"'name' must be a string\");\n      var determiner;\n      typeof expected == \"string\" && startsWith(expected, \"not \") \? (determiner = \"must not be\", expected = expected.replace(/^not /, \"\")) : determiner = \"must be\";\n      var msg;\n      if (endsWith(name, \" argument\"))\n        msg = \"The \".concat(name, \" \").concat(determiner, \" \").concat(oneOf(expected, \"type\"));\n      else {\n        var type = includes(name, \".\") \? \"property\" : \"argument\";\n        msg = 'The \"'.concat(name, '\" ').concat(type, \" \").concat(determiner, \" \").concat(oneOf(expected, \"type\"));\n      }\n      return msg += \". Received type \".concat(_typeof(actual)), msg;\n    }, TypeError), createErrorType(\"ERR_INVALID_ARG_VALUE\", function(name, value) {\n      var reason = arguments.length > 2 && arguments[2] !== void 0 \? arguments[2] : \"is invalid\", inspected = util2.inspect(value);\n      return inspected.length > 128 && (inspected = \"\".concat(inspected.slice(0, 128), \"...\")), \"The argument '\".concat(name, \"' \").concat(reason, \". Received \").concat(inspected);\n    }, TypeError, RangeError), createErrorType(\"ERR_INVALID_RETURN_VALUE\", function(input, name, value) {\n      var type;\n      return value && value.constructor && value.constructor.name \? type = \"instance of \".concat(value.constructor.name) : type = \"type \".concat(_typeof(value)), \"Expected \".concat(input, ' to be returned from the \"').concat(name, '\"') + \" function but got \".concat(type, \".\");\n    }, TypeError), createErrorType(\"ERR_MISSING_ARGS\", function() {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0;_key < _len; _key++)\n        args[_key] = arguments[_key];\n      assert === void 0 && (assert = require_assert()), assert(args.length > 0, \"At least one arg needs to be specified\");\n      var msg = \"The \", len = args.length;\n      switch (args = args.map(function(a) {\n        return '\"'.concat(a, '\"');\n      }), len) {\n        case 1:\n          msg += \"\".concat(args[0], \" argument\");\n          break;\n        case 2:\n          msg += \"\".concat(args[0], \" and \").concat(args[1], \" arguments\");\n          break;\n        default:\n          msg += args.slice(0, len - 1).join(\", \"), msg += \", and \".concat(args[len - 1], \" arguments\");\n          break;\n      }\n      return \"\".concat(msg, \" must be specified\");\n    }, TypeError), module2.exports.codes = codes;\n  }\n}), require_assertion_error = __commonJS({\n  \"assert/build/internal/assert/assertion_error.js\"(exports, module2) {\n    function _objectSpread(target) {\n      for (var i = 1;i < arguments.length; i++) {\n        var source = arguments[i] != null \? arguments[i] : {}, ownKeys = Object.keys(source);\n        typeof Object.getOwnPropertySymbols == \"function\" && (ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {\n          return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n        }))), ownKeys.forEach(function(key) {\n          _defineProperty(target, key, source[key]);\n        });\n      }\n      return target;\n    }\n    function _defineProperty(obj, key, value) {\n      return (key in obj) \? Object.defineProperty(obj, key, {\n        value,\n        enumerable: !0,\n        configurable: !0,\n        writable: !0\n      }) : obj[key] = value, obj;\n    }\n    function _classCallCheck(instance, Constructor) {\n      if (!(instance instanceof Constructor))\n        @throwTypeError(\"Cannot call a class as a function\");\n    }\n    function _defineProperties(target, props) {\n      for (var i = 0;i < props.length; i++) {\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, (\"value\" in descriptor) && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);\n      }\n    }\n    function _createClass(Constructor, protoProps, staticProps) {\n      return protoProps && _defineProperties(Constructor.prototype, protoProps), staticProps && _defineProperties(Constructor, staticProps), Constructor;\n    }\n    function _possibleConstructorReturn(self, call) {\n      return call && (_typeof(call) === \"object\" || typeof call == \"function\") \? call : _assertThisInitialized(self);\n    }\n    function _assertThisInitialized(self) {\n      if (self === void 0)\n        throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n      return self;\n    }\n    function _inherits(subClass, superClass) {\n      if (typeof superClass != \"function\" && superClass !== null)\n        @throwTypeError(\"Super expression must either be null or a function\");\n      subClass.prototype = Object.create(superClass && superClass.prototype, {\n        constructor: { value: subClass, writable: !0, configurable: !0 }\n      }), superClass && _setPrototypeOf(subClass, superClass);\n    }\n    function _wrapNativeSuper(Class) {\n      var _cache = typeof Map == \"function\" \? new Map : void 0;\n      return _wrapNativeSuper = function(Class2) {\n        if (Class2 === null || !_isNativeFunction(Class2))\n          return Class2;\n        if (typeof Class2 != \"function\")\n          @throwTypeError(\"Super expression must either be null or a function\");\n        if (typeof _cache != \"undefined\") {\n          if (_cache.has(Class2))\n            return _cache.get(Class2);\n          _cache.set(Class2, Wrapper);\n        }\n        function Wrapper() {\n          return _construct(Class2, arguments, _getPrototypeOf(this).constructor);\n        }\n        return Wrapper.prototype = Object.create(Class2.prototype, {\n          constructor: {\n            value: Wrapper,\n            enumerable: !1,\n            writable: !0,\n            configurable: !0\n          }\n        }), _setPrototypeOf(Wrapper, Class2);\n      }, _wrapNativeSuper(Class);\n    }\n    function isNativeReflectConstruct() {\n      if (typeof Reflect == \"undefined\" || !Reflect.construct || Reflect.construct.sham)\n        return !1;\n      if (typeof Proxy == \"function\")\n        return !0;\n      try {\n        return Date.prototype.toString.call(Reflect.construct(Date, [], function() {\n        })), !0;\n      } catch {\n        return !1;\n      }\n    }\n    function _construct(Parent, args, Class) {\n      return isNativeReflectConstruct() \? _construct = Reflect.construct : _construct = function(Parent2, args2, Class2) {\n        var a = [null];\n        a.push.apply(a, args2);\n        var Constructor = Function.bind.apply(Parent2, a), instance = new Constructor;\n        return Class2 && _setPrototypeOf(instance, Class2.prototype), instance;\n      }, _construct.apply(null, arguments);\n    }\n    function _isNativeFunction(fn) {\n      return Function.toString.call(fn).indexOf(\"[native code]\") !== -1;\n    }\n    function _setPrototypeOf(o, p) {\n      return _setPrototypeOf = Object.setPrototypeOf || function(o2, p2) {\n        return o2.__proto__ = p2, o2;\n      }, _setPrototypeOf(o, p);\n    }\n    function _getPrototypeOf(o) {\n      return _getPrototypeOf = Object.setPrototypeOf \? Object.getPrototypeOf : function(o2) {\n        return o2.__proto__ || Object.getPrototypeOf(o2);\n      }, _getPrototypeOf(o);\n    }\n    function _typeof(obj) {\n      return typeof Symbol == \"function\" && typeof Symbol.iterator == \"symbol\" \? _typeof = function(obj2) {\n        return typeof obj2;\n      } : _typeof = function(obj2) {\n        return obj2 && typeof Symbol == \"function\" && obj2.constructor === Symbol && obj2 !== Symbol.prototype \? \"symbol\" : typeof obj2;\n      }, _typeof(obj);\n    }\n    var inspect = util.inspect, _require2 = require_errors(), ERR_INVALID_ARG_TYPE = _require2.codes.ERR_INVALID_ARG_TYPE;\n    function endsWith(str, search, this_len) {\n      return (this_len === void 0 || this_len > str.length) && (this_len = str.length), str.substring(this_len - search.length, this_len) === search;\n    }\n    function repeat(str, count) {\n      if (count = Math.floor(count), str.length == 0 || count == 0)\n        return \"\";\n      var maxCount = str.length * count;\n      for (count = Math.floor(Math.log(count) / Math.log(2));count; )\n        str += str, count--;\n      return str += str.substring(0, maxCount - str.length), str;\n    }\n    var blue = \"\", green = \"\", red = \"\", white = \"\", kReadableOperator = {\n      deepStrictEqual: \"Expected values to be strictly deep-equal:\",\n      strictEqual: \"Expected values to be strictly equal:\",\n      strictEqualObject: 'Expected \"actual\" to be reference-equal to \"expected\":',\n      deepEqual: \"Expected values to be loosely deep-equal:\",\n      equal: \"Expected values to be loosely equal:\",\n      notDeepStrictEqual: 'Expected \"actual\" not to be strictly deep-equal to:',\n      notStrictEqual: 'Expected \"actual\" to be strictly unequal to:',\n      notStrictEqualObject: 'Expected \"actual\" not to be reference-equal to \"expected\":',\n      notDeepEqual: 'Expected \"actual\" not to be loosely deep-equal to:',\n      notEqual: 'Expected \"actual\" to be loosely unequal to:',\n      notIdentical: \"Values identical but not reference-equal:\"\n    }, kMaxShortLength = 10;\n    function copyError(source) {\n      var keys = Object.keys(source), target = Object.create(Object.getPrototypeOf(source));\n      return keys.forEach(function(key) {\n        target[key] = source[key];\n      }), Object.defineProperty(target, \"message\", {\n        value: source.message\n      }), target;\n    }\n    function inspectValue(val) {\n      return inspect(val, {\n        compact: !1,\n        customInspect: !1,\n        depth: 1000,\n        maxArrayLength: Infinity,\n        showHidden: !1,\n        breakLength: Infinity,\n        showProxy: !1,\n        sorted: !0,\n        getters: !0\n      });\n    }\n    function createErrDiff(actual, expected, operator) {\n      var other = \"\", res = \"\", lastPos = 0, end = \"\", skipped = !1, actualInspected = inspectValue(actual), actualLines = actualInspected.split(`\n`), expectedLines = inspectValue(expected).split(`\n`), i = 0, indicator = \"\";\n      if (operator === \"strictEqual\" && _typeof(actual) === \"object\" && _typeof(expected) === \"object\" && actual !== null && expected !== null && (operator = \"strictEqualObject\"), actualLines.length === 1 && expectedLines.length === 1 && actualLines[0] !== expectedLines[0]) {\n        var inputLength = actualLines[0].length + expectedLines[0].length;\n        if (inputLength <= kMaxShortLength) {\n          if ((_typeof(actual) !== \"object\" || actual === null) && (_typeof(expected) !== \"object\" || expected === null) && (actual !== 0 || expected !== 0))\n            return \"\".concat(kReadableOperator[operator], `\n\n`) + \"\".concat(actualLines[0], \" !== \").concat(expectedLines[0], `\n`);\n        } else if (operator !== \"strictEqualObject\") {\n          var maxLength = process.stderr && process.stderr.isTTY \? process.stderr.columns : 80;\n          if (inputLength < maxLength) {\n            for (;actualLines[0][i] === expectedLines[0][i]; )\n              i++;\n            i > 2 && (indicator = `\n  `.concat(repeat(\" \", i), \"^\"), i = 0);\n          }\n        }\n      }\n      for (var a = actualLines[actualLines.length - 1], b = expectedLines[expectedLines.length - 1];a === b && (i++ < 2 \? end = `\n  `.concat(a).concat(end) : other = a, actualLines.pop(), expectedLines.pop(), !(actualLines.length === 0 || expectedLines.length === 0)); )\n        a = actualLines[actualLines.length - 1], b = expectedLines[expectedLines.length - 1];\n      var maxLines = Math.max(actualLines.length, expectedLines.length);\n      if (maxLines === 0) {\n        var _actualLines = actualInspected.split(`\n`);\n        if (_actualLines.length > 30)\n          for (_actualLines[26] = \"\".concat(blue, \"...\").concat(white);_actualLines.length > 27; )\n            _actualLines.pop();\n        return \"\".concat(kReadableOperator.notIdentical, `\n\n`).concat(_actualLines.join(`\n`), `\n`);\n      }\n      i > 3 && (end = `\n`.concat(blue, \"...\").concat(white).concat(end), skipped = !0), other !== \"\" && (end = `\n  `.concat(other).concat(end), other = \"\");\n      var printedLines = 0, msg = kReadableOperator[operator] + `\n`.concat(green, \"+ actual\").concat(white, \" \").concat(red, \"- expected\").concat(white), skippedMsg = \" \".concat(blue, \"...\").concat(white, \" Lines skipped\");\n      for (i = 0;i < maxLines; i++) {\n        var cur = i - lastPos;\n        if (actualLines.length < i + 1)\n          cur > 1 && i > 2 && (cur > 4 \? (res += `\n`.concat(blue, \"...\").concat(white), skipped = !0) : cur > 3 && (res += `\n  `.concat(expectedLines[i - 2]), printedLines++), res += `\n  `.concat(expectedLines[i - 1]), printedLines++), lastPos = i, other += `\n`.concat(red, \"-\").concat(white, \" \").concat(expectedLines[i]), printedLines++;\n        else if (expectedLines.length < i + 1)\n          cur > 1 && i > 2 && (cur > 4 \? (res += `\n`.concat(blue, \"...\").concat(white), skipped = !0) : cur > 3 && (res += `\n  `.concat(actualLines[i - 2]), printedLines++), res += `\n  `.concat(actualLines[i - 1]), printedLines++), lastPos = i, res += `\n`.concat(green, \"+\").concat(white, \" \").concat(actualLines[i]), printedLines++;\n        else {\n          var expectedLine = expectedLines[i], actualLine = actualLines[i], divergingLines = actualLine !== expectedLine && (!endsWith(actualLine, \",\") || actualLine.slice(0, -1) !== expectedLine);\n          divergingLines && endsWith(expectedLine, \",\") && expectedLine.slice(0, -1) === actualLine && (divergingLines = !1, actualLine += \",\"), divergingLines \? (cur > 1 && i > 2 && (cur > 4 \? (res += `\n`.concat(blue, \"...\").concat(white), skipped = !0) : cur > 3 && (res += `\n  `.concat(actualLines[i - 2]), printedLines++), res += `\n  `.concat(actualLines[i - 1]), printedLines++), lastPos = i, res += `\n`.concat(green, \"+\").concat(white, \" \").concat(actualLine), other += `\n`.concat(red, \"-\").concat(white, \" \").concat(expectedLine), printedLines += 2) : (res += other, other = \"\", (cur === 1 || i === 0) && (res += `\n  `.concat(actualLine), printedLines++));\n        }\n        if (printedLines > 20 && i < maxLines - 2)\n          return \"\".concat(msg).concat(skippedMsg, `\n`).concat(res, `\n`).concat(blue, \"...\").concat(white).concat(other, `\n`) + \"\".concat(blue, \"...\").concat(white);\n      }\n      return \"\".concat(msg).concat(skipped \? skippedMsg : \"\", `\n`).concat(res).concat(other).concat(end).concat(indicator);\n    }\n    var AssertionError = function(_Error) {\n      function AssertionError2(options) {\n        var _this;\n        if (_classCallCheck(this, AssertionError2), _typeof(options) !== \"object\" || options === null)\n          throw new ERR_INVALID_ARG_TYPE(\"options\", \"Object\", options);\n        var { message, operator, stackStartFn, actual, expected } = options, limit = Error.stackTraceLimit;\n        if (Error.stackTraceLimit = 0, message != null)\n          _this = _possibleConstructorReturn(this, _getPrototypeOf(AssertionError2).call(this, String(message)));\n        else if (process.stderr && process.stderr.isTTY && (process.stderr && process.stderr.getColorDepth && process.stderr.getColorDepth() !== 1 \? (blue = \"[34m\", green = \"[32m\", white = \"[39m\", red = \"[31m\") : (blue = \"\", green = \"\", white = \"\", red = \"\")), _typeof(actual) === \"object\" && actual !== null && _typeof(expected) === \"object\" && expected !== null && (\"stack\" in actual) && actual instanceof Error && (\"stack\" in expected) && expected instanceof Error && (actual = copyError(actual), expected = copyError(expected)), operator === \"deepStrictEqual\" || operator === \"strictEqual\")\n          _this = _possibleConstructorReturn(this, _getPrototypeOf(AssertionError2).call(this, createErrDiff(actual, expected, operator)));\n        else if (operator === \"notDeepStrictEqual\" || operator === \"notStrictEqual\") {\n          var base = kReadableOperator[operator], res = inspectValue(actual).split(`\n`);\n          if (operator === \"notStrictEqual\" && _typeof(actual) === \"object\" && actual !== null && (base = kReadableOperator.notStrictEqualObject), res.length > 30)\n            for (res[26] = \"\".concat(blue, \"...\").concat(white);res.length > 27; )\n              res.pop();\n          res.length === 1 \? _this = _possibleConstructorReturn(this, _getPrototypeOf(AssertionError2).call(this, \"\".concat(base, \" \").concat(res[0]))) : _this = _possibleConstructorReturn(this, _getPrototypeOf(AssertionError2).call(this, \"\".concat(base, `\n\n`).concat(res.join(`\n`), `\n`)));\n        } else {\n          var _res = inspectValue(actual), other = \"\", knownOperators = kReadableOperator[operator];\n          operator === \"notDeepEqual\" || operator === \"notEqual\" \? (_res = \"\".concat(kReadableOperator[operator], `\n\n`).concat(_res), _res.length > 1024 && (_res = \"\".concat(_res.slice(0, 1021), \"...\"))) : (other = \"\".concat(inspectValue(expected)), _res.length > 512 && (_res = \"\".concat(_res.slice(0, 509), \"...\")), other.length > 512 && (other = \"\".concat(other.slice(0, 509), \"...\")), operator === \"deepEqual\" || operator === \"equal\" \? _res = \"\".concat(knownOperators, `\n\n`).concat(_res, `\n\nshould equal\n\n`) : other = \" \".concat(operator, \" \").concat(other)), _this = _possibleConstructorReturn(this, _getPrototypeOf(AssertionError2).call(this, \"\".concat(_res).concat(other)));\n        }\n        return Error.stackTraceLimit = limit, _this.generatedMessage = !message, Object.defineProperty(_assertThisInitialized(_this), \"name\", {\n          value: \"AssertionError [ERR_ASSERTION]\",\n          enumerable: !1,\n          writable: !0,\n          configurable: !0\n        }), _this.code = \"ERR_ASSERTION\", _this.actual = actual, _this.expected = expected, _this.operator = operator, Error.captureStackTrace && Error.captureStackTrace(_assertThisInitialized(_this), stackStartFn), _this.stack, _this.name = \"AssertionError\", _possibleConstructorReturn(_this);\n      }\n      return AssertionError2.prototype = {}, _inherits(AssertionError2, _Error), _createClass(AssertionError2, [\n        {\n          key: \"toString\",\n          value: function() {\n            return \"\".concat(this.name, \" [\").concat(this.code, \"]: \").concat(this.message);\n          }\n        },\n        {\n          key: inspect.custom,\n          value: function(recurseTimes, ctx) {\n            return inspect(this, _objectSpread({}, ctx, {\n              customInspect: !1,\n              depth: 0\n            }));\n          }\n        }\n      ]), AssertionError2;\n    }(_wrapNativeSuper(Error));\n    module2.exports = AssertionError;\n  }\n}), require_assert = __commonJS({\n  \"assert/build/assert.js\"(exports, module2) {\n    function _typeof(obj) {\n      return typeof Symbol == \"function\" && typeof Symbol.iterator == \"symbol\" \? _typeof = function(obj2) {\n        return typeof obj2;\n      } : _typeof = function(obj2) {\n        return obj2 && typeof Symbol == \"function\" && obj2.constructor === Symbol && obj2 !== Symbol.prototype \? \"symbol\" : typeof obj2;\n      }, _typeof(obj);\n    }\n    function _classCallCheck(instance, Constructor) {\n      if (!(instance instanceof Constructor))\n        @throwTypeError(\"Cannot call a class as a function\");\n    }\n    var _require = require_errors(), _require$codes = _require.codes, ERR_AMBIGUOUS_ARGUMENT = _require$codes.ERR_AMBIGUOUS_ARGUMENT, ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE, ERR_INVALID_ARG_VALUE = _require$codes.ERR_INVALID_ARG_VALUE, ERR_INVALID_RETURN_VALUE = _require$codes.ERR_INVALID_RETURN_VALUE, ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS, AssertionError = require_assertion_error(), _require2 = util, inspect = _require2.inspect, _require$types = util.types, isPromise = _require$types.isPromise, isRegExp = _require$types.isRegExp, objectAssign = Object.assign, objectIs = Object.is, errorCache = new Map, warned = !1, assert = module2.exports = ok, NO_EXCEPTION_SENTINEL = {};\n    function innerFail(obj) {\n      throw obj.message instanceof Error \? obj.message : new AssertionError(obj);\n    }\n    function fail(actual, expected, message, operator, stackStartFn) {\n      var argsLen = arguments.length, internalMessage;\n      if (argsLen === 0)\n        internalMessage = \"Failed\";\n      else if (argsLen === 1)\n        message = actual, actual = void 0;\n      else {\n        if (warned === !1) {\n          warned = !0;\n          var warn = process.emitWarning \? process.emitWarning : console.warn.bind(console);\n          warn(\"assert.fail() with more than one argument is deprecated. Please use assert.strictEqual() instead or only pass a message.\", \"DeprecationWarning\", \"DEP0094\");\n        }\n        argsLen === 2 && (operator = \"!=\");\n      }\n      if (message instanceof Error)\n        throw message;\n      var errArgs = {\n        actual,\n        expected,\n        operator: operator === void 0 \? \"fail\" : operator,\n        stackStartFn: stackStartFn || fail\n      };\n      message !== void 0 && (errArgs.message = message);\n      var err = new AssertionError(errArgs);\n      throw internalMessage && (err.message = internalMessage, err.generatedMessage = !0), err;\n    }\n    assert.fail = fail, assert.AssertionError = AssertionError;\n    function innerOk(fn, argLen, value, message) {\n      if (!value) {\n        var generatedMessage = !1;\n        if (argLen === 0)\n          generatedMessage = !0, message = \"No value argument passed to `assert.ok()`\";\n        else if (message instanceof Error)\n          throw message;\n        var err = new AssertionError({\n          actual: value,\n          expected: !0,\n          message,\n          operator: \"==\",\n          stackStartFn: fn\n        });\n        throw err.generatedMessage = generatedMessage, err;\n      }\n    }\n    function ok() {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0;_key < _len; _key++)\n        args[_key] = arguments[_key];\n      innerOk.apply(void 0, [ok, args.length].concat(args));\n    }\n    assert.ok = ok, assert.equal = function equal(actual, expected, message) {\n      if (arguments.length < 2)\n        throw new ERR_MISSING_ARGS(\"actual\", \"expected\");\n      actual != expected && innerFail({\n        actual,\n        expected,\n        message,\n        operator: \"==\",\n        stackStartFn: equal\n      });\n    }, assert.notEqual = function notEqual(actual, expected, message) {\n      if (arguments.length < 2)\n        throw new ERR_MISSING_ARGS(\"actual\", \"expected\");\n      actual == expected && innerFail({\n        actual,\n        expected,\n        message,\n        operator: \"!=\",\n        stackStartFn: notEqual\n      });\n    }, assert.deepEqual = function deepEqual(actual, expected, message) {\n      if (arguments.length < 2)\n        throw new ERR_MISSING_ARGS(\"actual\", \"expected\");\n      isDeepEqual(actual, expected, !1) || innerFail({\n        actual,\n        expected,\n        message,\n        operator: \"deepEqual\",\n        stackStartFn: deepEqual\n      });\n    }, assert.notDeepEqual = function notDeepEqual(actual, expected, message) {\n      if (arguments.length < 2)\n        throw new ERR_MISSING_ARGS(\"actual\", \"expected\");\n      isDeepEqual(actual, expected, !1) && innerFail({\n        actual,\n        expected,\n        message,\n        operator: \"notDeepEqual\",\n        stackStartFn: notDeepEqual\n      });\n    }, assert.deepStrictEqual = function deepStrictEqual(actual, expected, message) {\n      if (arguments.length < 2)\n        throw new ERR_MISSING_ARGS(\"actual\", \"expected\");\n      isDeepEqual(actual, expected, !0) || innerFail({\n        actual,\n        expected,\n        message,\n        operator: \"deepStrictEqual\",\n        stackStartFn: deepStrictEqual\n      });\n    }, assert.notDeepStrictEqual = notDeepStrictEqual;\n    function notDeepStrictEqual(actual, expected, message) {\n      if (arguments.length < 2)\n        throw new ERR_MISSING_ARGS(\"actual\", \"expected\");\n      isDeepEqual(actual, expected, !0) && innerFail({\n        actual,\n        expected,\n        message,\n        operator: \"notDeepStrictEqual\",\n        stackStartFn: notDeepStrictEqual\n      });\n    }\n    assert.strictEqual = function strictEqual(actual, expected, message) {\n      if (arguments.length < 2)\n        throw new ERR_MISSING_ARGS(\"actual\", \"expected\");\n      objectIs(actual, expected) || innerFail({\n        actual,\n        expected,\n        message,\n        operator: \"strictEqual\",\n        stackStartFn: strictEqual\n      });\n    }, assert.notStrictEqual = function notStrictEqual(actual, expected, message) {\n      if (arguments.length < 2)\n        throw new ERR_MISSING_ARGS(\"actual\", \"expected\");\n      objectIs(actual, expected) && innerFail({\n        actual,\n        expected,\n        message,\n        operator: \"notStrictEqual\",\n        stackStartFn: notStrictEqual\n      });\n    }, assert.match = function match(actual, expected, message) {\n      if (arguments.length < 2)\n        throw new ERR_MISSING_ARGS(\"actual\", \"expected\");\n      if (!isRegExp(expected))\n        throw new ERR_INVALID_ARG_TYPE(\"expected\", \"RegExp\", expected);\n      expected.test(actual) || innerFail({\n        actual,\n        expected,\n        message,\n        operator: \"match\",\n        stackStartFn: match\n      });\n    };\n    var Comparison = function Comparison2(obj, keys, actual) {\n      var _this = this;\n      _classCallCheck(this, Comparison2), keys.forEach(function(key) {\n        (key in obj) && (actual !== void 0 && typeof actual[key] == \"string\" && isRegExp(obj[key]) && obj[key].test(actual[key]) \? _this[key] = actual[key] : _this[key] = obj[key]);\n      });\n    };\n    function compareExceptionKey(actual, expected, key, message, keys, fn) {\n      if (!(key in actual) || !isDeepEqual(actual[key], expected[key], !0)) {\n        if (!message) {\n          var a = new Comparison(actual, keys), b = new Comparison(expected, keys, actual), err = new AssertionError({\n            actual: a,\n            expected: b,\n            operator: \"deepStrictEqual\",\n            stackStartFn: fn\n          });\n          throw err.actual = actual, err.expected = expected, err.operator = fn.name, err;\n        }\n        innerFail({\n          actual,\n          expected,\n          message,\n          operator: fn.name,\n          stackStartFn: fn\n        });\n      }\n    }\n    function expectedException(actual, expected, msg, fn) {\n      if (typeof expected != \"function\") {\n        if (isRegExp(expected))\n          return expected.test(actual);\n        if (arguments.length === 2)\n          throw new ERR_INVALID_ARG_TYPE(\"expected\", [\"Function\", \"RegExp\"], expected);\n        if (_typeof(actual) !== \"object\" || actual === null) {\n          var err = new AssertionError({\n            actual,\n            expected,\n            message: msg,\n            operator: \"deepStrictEqual\",\n            stackStartFn: fn\n          });\n          throw err.operator = fn.name, err;\n        }\n        var keys = Object.keys(expected);\n        if (expected instanceof Error)\n          keys.push(\"name\", \"message\");\n        else if (keys.length === 0)\n          throw new ERR_INVALID_ARG_VALUE(\"error\", expected, \"may not be an empty object\");\n        return keys.forEach(function(key) {\n          return typeof actual[key] == \"string\" && isRegExp(expected[key]) && expected[key].test(actual[key]) || compareExceptionKey(actual, expected, key, msg, keys, fn);\n        }), !0;\n      }\n      return expected.prototype !== void 0 && actual instanceof expected \? !0 : Error.isPrototypeOf(expected) \? !1 : expected.call({}, actual) === !0;\n    }\n    function getActual(fn) {\n      if (typeof fn != \"function\")\n        throw new ERR_INVALID_ARG_TYPE(\"fn\", \"Function\", fn);\n      try {\n        fn();\n      } catch (e) {\n        return e;\n      }\n      return NO_EXCEPTION_SENTINEL;\n    }\n    function checkIsPromise(obj) {\n      return isPromise(obj) || obj !== null && _typeof(obj) === \"object\" && typeof obj.then == \"function\" && typeof obj.catch == \"function\";\n    }\n    function waitForActual(promiseFn) {\n      return Promise.resolve().then(function() {\n        var resultPromise;\n        if (typeof promiseFn == \"function\") {\n          if (resultPromise = promiseFn(), !checkIsPromise(resultPromise))\n            throw new ERR_INVALID_RETURN_VALUE(\"instance of Promise\", \"promiseFn\", resultPromise);\n        } else if (checkIsPromise(promiseFn))\n          resultPromise = promiseFn;\n        else\n          throw new ERR_INVALID_ARG_TYPE(\"promiseFn\", [\"Function\", \"Promise\"], promiseFn);\n        return Promise.resolve().then(function() {\n          return resultPromise;\n        }).then(function() {\n          return NO_EXCEPTION_SENTINEL;\n        }).catch(function(e) {\n          return e;\n        });\n      });\n    }\n    function expectsError(stackStartFn, actual, error, message) {\n      if (typeof error == \"string\") {\n        if (arguments.length === 4)\n          throw new ERR_INVALID_ARG_TYPE(\"error\", [\"Object\", \"Error\", \"Function\", \"RegExp\"], error);\n        if (_typeof(actual) === \"object\" && actual !== null) {\n          if (actual.message === error)\n            throw new ERR_AMBIGUOUS_ARGUMENT(\"error/message\", 'The error message \"'.concat(actual.message, '\" is identical to the message.'));\n        } else if (actual === error)\n          throw new ERR_AMBIGUOUS_ARGUMENT(\"error/message\", 'The error \"'.concat(actual, '\" is identical to the message.'));\n        message = error, error = void 0;\n      } else if (error != null && _typeof(error) !== \"object\" && typeof error != \"function\")\n        throw new ERR_INVALID_ARG_TYPE(\"error\", [\"Object\", \"Error\", \"Function\", \"RegExp\"], error);\n      if (actual === NO_EXCEPTION_SENTINEL) {\n        var details = \"\";\n        error && error.name && (details += \" (\".concat(error.name, \")\")), details += message \? \": \".concat(message) : \".\";\n        var fnType = stackStartFn.name === \"rejects\" \? \"rejection\" : \"exception\";\n        innerFail({\n          actual: void 0,\n          expected: error,\n          operator: stackStartFn.name,\n          message: \"Missing expected \".concat(fnType).concat(details),\n          stackStartFn\n        });\n      }\n      if (error && !expectedException(actual, error, message, stackStartFn))\n        throw actual;\n    }\n    function expectsNoError(stackStartFn, actual, error, message) {\n      if (actual !== NO_EXCEPTION_SENTINEL) {\n        if (typeof error == \"string\" && (message = error, error = void 0), !error || expectedException(actual, error)) {\n          var details = message \? \": \".concat(message) : \".\", fnType = stackStartFn.name === \"doesNotReject\" \? \"rejection\" : \"exception\";\n          innerFail({\n            actual,\n            expected: error,\n            operator: stackStartFn.name,\n            message: \"Got unwanted \".concat(fnType).concat(details, `\n`) + 'Actual message: \"'.concat(actual && actual.message, '\"'),\n            stackStartFn\n          });\n        }\n        throw actual;\n      }\n    }\n    assert.throws = function throws(promiseFn) {\n      for (var _len2 = arguments.length, args = new Array(_len2 > 1 \? _len2 - 1 : 0), _key2 = 1;_key2 < _len2; _key2++)\n        args[_key2 - 1] = arguments[_key2];\n      expectsError.apply(void 0, [throws, getActual(promiseFn)].concat(args));\n    }, assert.rejects = function rejects(promiseFn) {\n      for (var _len3 = arguments.length, args = new Array(_len3 > 1 \? _len3 - 1 : 0), _key3 = 1;_key3 < _len3; _key3++)\n        args[_key3 - 1] = arguments[_key3];\n      return waitForActual(promiseFn).then(function(result) {\n        return expectsError.apply(void 0, [rejects, result].concat(args));\n      });\n    }, assert.doesNotThrow = function doesNotThrow(fn) {\n      for (var _len4 = arguments.length, args = new Array(_len4 > 1 \? _len4 - 1 : 0), _key4 = 1;_key4 < _len4; _key4++)\n        args[_key4 - 1] = arguments[_key4];\n      expectsNoError.apply(void 0, [doesNotThrow, getActual(fn)].concat(args));\n    }, assert.doesNotReject = function doesNotReject(fn) {\n      for (var _len5 = arguments.length, args = new Array(_len5 > 1 \? _len5 - 1 : 0), _key5 = 1;_key5 < _len5; _key5++)\n        args[_key5 - 1] = arguments[_key5];\n      return waitForActual(fn).then(function(result) {\n        return expectsNoError.apply(void 0, [doesNotReject, result].concat(args));\n      });\n    }, assert.ifError = function ifError(err) {\n      if (err != null) {\n        var message = \"ifError got unwanted exception: \";\n        _typeof(err) === \"object\" && typeof err.message == \"string\" \? err.message.length === 0 && err.constructor \? message += err.constructor.name : message += err.message : message += inspect(err);\n        var newErr = new AssertionError({\n          actual: err,\n          expected: null,\n          operator: \"ifError\",\n          message,\n          stackStartFn: ifError\n        }), origStack = err.stack;\n        if (typeof origStack == \"string\") {\n          var tmp2 = origStack.split(`\n`);\n          tmp2.shift();\n          for (var tmp1 = newErr.stack.split(`\n`), i = 0;i < tmp2.length; i++) {\n            var pos = tmp1.indexOf(tmp2[i]);\n            if (pos !== -1) {\n              tmp1 = tmp1.slice(0, pos);\n              break;\n            }\n          }\n          newErr.stack = \"\".concat(tmp1.join(`\n`), `\n`).concat(tmp2.join(`\n`));\n        }\n        throw newErr;\n      }\n    };\n    function strict() {\n      for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0;_key6 < _len6; _key6++)\n        args[_key6] = arguments[_key6];\n      innerOk.apply(void 0, [strict, args.length].concat(args));\n    }\n    assert.strict = objectAssign(strict, assert, {\n      equal: assert.strictEqual,\n      deepEqual: assert.deepStrictEqual,\n      notEqual: assert.notStrictEqual,\n      notDeepEqual: assert.notDeepStrictEqual\n    }), assert.strict.strict = assert.strict;\n  }\n}), assert_module = require_assert();\nassert_module.CallTracker = CallTracker;\nreturn assert_module})\n"_s;
//

//
static constexpr ASCIILiteral NodeAssertStrictCode = "(function (){\"use strict\";// src/js/out/tmp/node/assert.strict.ts\nreturn (@getInternalField(@internalModuleRegistry, 4) || @createInternalModuleById(4)).strict})\n"_s;
//

//
static constexpr ASCIILiteral NodeAsyncHooksCode = "(function (){\"use strict\";// src/js/out/tmp/node/async_hooks.ts\nvar get = function() {\n  return @getInternalField(@asyncContext, 0);\n}, set = function(contextValue) {\n  return @putInternalField(@asyncContext, 0, contextValue);\n}, createWarning = function(message) {\n  let warned = !1;\n  var wrapped = function() {\n    if (warned)\n      return;\n    if (new Error().stack.includes(\"zx/build/core.js\"))\n      return;\n    warned = !0, console.warn(\"[bun] Warning:\", message);\n  };\n  return wrapped;\n}, createHook = function(callbacks) {\n  return {\n    enable: createHookNotImpl,\n    disable: createHookNotImpl\n  };\n}, executionAsyncId = function() {\n  return executionAsyncIdNotImpl(), 0;\n}, triggerAsyncId = function() {\n  return 0;\n}, executionAsyncResource = function() {\n  return executionAsyncResourceWarning(), process.stdin;\n}, $, { cleanupLater } = globalThis[globalThis.Symbol.for('Bun.lazy')](\"async_hooks\");\n\nclass AsyncLocalStorage {\n  #disableCalled = !1;\n  constructor() {\n  }\n  static bind(fn, ...args) {\n    return this.snapshot().bind(null, fn, ...args);\n  }\n  static snapshot() {\n    var context = get();\n    return (fn, ...args) => {\n      var prev = get();\n      set(context);\n      try {\n        return fn(...args);\n      } catch (error) {\n        throw error;\n      } finally {\n        set(prev);\n      }\n    };\n  }\n  enterWith(store) {\n    cleanupLater();\n    var context = get();\n    if (!context) {\n      set([this, store]);\n      return;\n    }\n    var { length } = context;\n    for (var i = 0;i < length; i += 2)\n      if (context[i] === this) {\n        const clone = context.slice();\n        clone[i + 1] = store, set(clone);\n        return;\n      }\n    set(context.concat(this, store));\n  }\n  exit(cb, ...args) {\n    return this.run(void 0, cb, ...args);\n  }\n  run(store, callback, ...args) {\n    var context = get(), hasPrevious = !1, previous, i = 0, contextWasInit = !context;\n    if (contextWasInit)\n      set(context = [this, store]);\n    else {\n      if (context = context.slice(), i = context.indexOf(this), i > -1)\n        hasPrevious = !0, previous = context[i + 1], context[i + 1] = store;\n      else\n        context.push(this, store);\n      set(context);\n    }\n    try {\n      return callback(...args);\n    } catch (e) {\n      throw e;\n    } finally {\n      if (!this.#disableCalled) {\n        var context2 = get();\n        if (context2 === context && contextWasInit)\n          set(void 0);\n        else if (context2 = context2.slice(), hasPrevious)\n          context2[i + 1] = previous, set(context2);\n        else\n          context2.splice(i, 2), set(context2.length \? context2 : void 0);\n      }\n    }\n  }\n  disable() {\n    if (!this.#disableCalled) {\n      var context = get();\n      if (context) {\n        var { length } = context;\n        for (var i = 0;i < length; i += 2)\n          if (context[i] === this) {\n            context.splice(i, 2), set(context.length \? context : void 0);\n            break;\n          }\n      }\n      this.#disableCalled = !0;\n    }\n  }\n  getStore() {\n    var context = get();\n    if (!context)\n      return;\n    var { length } = context;\n    for (var i = 0;i < length; i += 2)\n      if (context[i] === this)\n        return context[i + 1];\n  }\n}\n\nclass AsyncResource {\n  type;\n  #snapshot;\n  constructor(type, options) {\n    if (typeof type !== \"string\")\n      @throwTypeError('The \"type\" argument must be of type string. Received type ' + typeof type);\n    this.type = type, this.#snapshot = get();\n  }\n  emitBefore() {\n    return !0;\n  }\n  emitAfter() {\n    return !0;\n  }\n  asyncId() {\n    return 0;\n  }\n  triggerAsyncId() {\n    return 0;\n  }\n  emitDestroy() {\n  }\n  runInAsyncScope(fn, thisArg, ...args) {\n    var prev = get();\n    set(this.#snapshot);\n    try {\n      return fn.apply(thisArg, args);\n    } catch (error) {\n      throw error;\n    } finally {\n      set(prev);\n    }\n  }\n}\nvar createHookNotImpl = createWarning(\"async_hooks.createHook is not implemented in Bun. Hooks can still be created but will never be called.\"), executionAsyncIdNotImpl = createWarning(\"async_hooks.executionAsyncId/triggerAsyncId are not implemented in Bun. It will return 0 every time.\"), executionAsyncResourceWarning = createWarning(\"async_hooks.executionAsyncResource is not implemented in Bun. It returns a reference to process.stdin every time.\"), asyncWrapProviders = {\n  NONE: 0,\n  DIRHANDLE: 1,\n  DNSCHANNEL: 2,\n  ELDHISTOGRAM: 3,\n  FILEHANDLE: 4,\n  FILEHANDLECLOSEREQ: 5,\n  FIXEDSIZEBLOBCOPY: 6,\n  FSEVENTWRAP: 7,\n  FSREQCALLBACK: 8,\n  FSREQPROMISE: 9,\n  GETADDRINFOREQWRAP: 10,\n  GETNAMEINFOREQWRAP: 11,\n  HEAPSNAPSHOT: 12,\n  HTTP2SESSION: 13,\n  HTTP2STREAM: 14,\n  HTTP2PING: 15,\n  HTTP2SETTINGS: 16,\n  HTTPINCOMINGMESSAGE: 17,\n  HTTPCLIENTREQUEST: 18,\n  JSSTREAM: 19,\n  JSUDPWRAP: 20,\n  MESSAGEPORT: 21,\n  PIPECONNECTWRAP: 22,\n  PIPESERVERWRAP: 23,\n  PIPEWRAP: 24,\n  PROCESSWRAP: 25,\n  PROMISE: 26,\n  QUERYWRAP: 27,\n  SHUTDOWNWRAP: 28,\n  SIGNALWRAP: 29,\n  STATWATCHER: 30,\n  STREAMPIPE: 31,\n  TCPCONNECTWRAP: 32,\n  TCPSERVERWRAP: 33,\n  TCPWRAP: 34,\n  TTYWRAP: 35,\n  UDPSENDWRAP: 36,\n  UDPWRAP: 37,\n  SIGINTWATCHDOG: 38,\n  WORKER: 39,\n  WORKERHEAPSNAPSHOT: 40,\n  WRITEWRAP: 41,\n  ZLIB: 42,\n  CHECKPRIMEREQUEST: 43,\n  PBKDF2REQUEST: 44,\n  KEYPAIRGENREQUEST: 45,\n  KEYGENREQUEST: 46,\n  KEYEXPORTREQUEST: 47,\n  CIPHERREQUEST: 48,\n  DERIVEBITSREQUEST: 49,\n  HASHREQUEST: 50,\n  RANDOMBYTESREQUEST: 51,\n  RANDOMPRIMEREQUEST: 52,\n  SCRYPTREQUEST: 53,\n  SIGNREQUEST: 54,\n  TLSWRAP: 55,\n  VERIFYREQUEST: 56,\n  INSPECTORJSBINDING: 57\n};\n$ = {\n  AsyncLocalStorage,\n  createHook,\n  executionAsyncId,\n  triggerAsyncId,\n  executionAsyncResource,\n  asyncWrapProviders,\n  AsyncResource\n};\nreturn $})\n"_s;
//

//
static constexpr ASCIILiteral NodeChildProcessCode = "(function (){\"use strict\";// src/js/out/tmp/node/child_process.ts\nvar spawn = function(file, args, options) {\n  options = normalizeSpawnArguments(file, args, options), validateTimeout(options.timeout), validateAbortSignal(options.signal, \"options.signal\");\n  const killSignal2 = sanitizeKillSignal(options.killSignal), child = new ChildProcess;\n  if (child.spawn(options), options.timeout > 0) {\n    let timeoutId = setTimeout(() => {\n      if (timeoutId) {\n        try {\n          child.kill(killSignal2);\n        } catch (err) {\n          child.emit(\"error\", err);\n        }\n        timeoutId = null;\n      }\n    });\n    child.once(\"exit\", () => {\n      if (timeoutId)\n        clearTimeout(timeoutId), timeoutId = null;\n    });\n  }\n  if (options.signal) {\n    let onAbortListener2 = function() {\n      abortChildProcess(child, killSignal2, options.signal.reason);\n    };\n    var onAbortListener = onAbortListener2;\n    const signal = options.signal;\n    if (signal.aborted)\n      process.nextTick(onAbortListener2);\n    else\n      signal.addEventListener(\"abort\", onAbortListener2, { once: !0 }), child.once(\"exit\", () => signal.removeEventListener(\"abort\", onAbortListener2));\n  }\n  return child;\n}, execFile = function(file, args, options, callback) {\n  ({ file, args, options, callback } = normalizeExecFileArgs(file, args, options, callback)), options = {\n    encoding: \"utf8\",\n    timeout: 0,\n    maxBuffer: MAX_BUFFER,\n    killSignal: \"SIGTERM\",\n    cwd: null,\n    env: null,\n    shell: !1,\n    ...options\n  };\n  const maxBuffer = options.maxBuffer;\n  validateTimeout(options.timeout), validateMaxBuffer(maxBuffer), options.killSignal = sanitizeKillSignal(options.killSignal);\n  const child = spawn(file, args, {\n    cwd: options.cwd,\n    env: options.env,\n    shell: options.shell,\n    signal: options.signal\n  });\n  let encoding;\n  const _stdout = [], _stderr = [];\n  if (options.encoding !== \"buffer\" && BufferIsEncoding(options.encoding))\n    encoding = options.encoding;\n  else\n    encoding = null;\n  let stdoutLen = 0, stderrLen = 0, killed = !1, exited = !1, timeoutId, encodedStdoutLen, encodedStderrLen, ex = null, cmd = file;\n  function exitHandler(code, signal) {\n    if (exited)\n      return;\n    if (exited = !0, timeoutId)\n      clearTimeout(timeoutId), timeoutId = null;\n    if (!callback)\n      return;\n    const readableEncoding = child\?.stdout\?.readableEncoding;\n    let stdout, stderr;\n    if (encoding || child.stdout && readableEncoding)\n      stdout = ArrayPrototypeJoin.call(_stdout, \"\");\n    else\n      stdout = BufferConcat(_stdout);\n    if (encoding || child.stderr && readableEncoding)\n      stderr = ArrayPrototypeJoin.call(_stderr, \"\");\n    else\n      stderr = BufferConcat(_stderr);\n    if (!ex && code === 0 && signal === null) {\n      callback(null, stdout, stderr);\n      return;\n    }\n    if (args\?.length)\n      cmd += ` ${ArrayPrototypeJoin.call(args, \" \")}`;\n    if (!ex) {\n      let message = `Command failed: ${cmd}`;\n      if (stderr)\n        message += `\\n${stderr}`;\n      ex = genericNodeError(message, {\n        code,\n        killed: child.killed || killed,\n        signal\n      });\n    }\n    ex.cmd = cmd, callback(ex, stdout, stderr);\n  }\n  function errorHandler(e) {\n    if (ex = e, child.stdout)\n      child.stdout.destroy();\n    if (child.stderr)\n      child.stderr.destroy();\n    exitHandler();\n  }\n  function kill() {\n    if (child.stdout)\n      child.stdout.destroy();\n    if (child.stderr)\n      child.stderr.destroy();\n    killed = !0;\n    try {\n      child.kill(options.killSignal);\n    } catch (e) {\n      ex = e, exitHandler();\n    }\n  }\n  if (options.timeout > 0)\n    timeoutId = setTimeout(function delayedKill() {\n      kill(), timeoutId = null;\n    }, options.timeout);\n  if (child.stdout) {\n    if (encoding)\n      child.stdout.setEncoding(encoding);\n    child.stdout.on(\"data\", maxBuffer === Infinity \? function onUnlimitedSizeBufferedData(chunk) {\n      ArrayPrototypePush.call(_stdout, chunk);\n    } : encoding \? function onChildStdoutEncoded(chunk) {\n      if (stdoutLen += chunk.length, stdoutLen * 4 > maxBuffer) {\n        const encoding2 = child.stdout.readableEncoding, actualLen = Buffer.byteLength(chunk, encoding2);\n        if (encodedStdoutLen === void 0)\n          for (let i = 0;i < _stdout.length; i++)\n            encodedStdoutLen += Buffer.byteLength(_stdout[i], encoding2);\n        else\n          encodedStdoutLen += actualLen;\n        const truncatedLen = maxBuffer - (encodedStdoutLen - actualLen);\n        ArrayPrototypePush.call(_stdout, StringPrototypeSlice.apply(chunk, 0, truncatedLen)), ex = new ERR_CHILD_PROCESS_STDIO_MAXBUFFER(\"stdout\"), kill();\n      } else\n        ArrayPrototypePush.call(_stdout, chunk);\n    } : function onChildStdoutRaw(chunk) {\n      if (stdoutLen += chunk.length, stdoutLen > maxBuffer) {\n        const truncatedLen = maxBuffer - (stdoutLen - chunk.length);\n        ArrayPrototypePush.call(_stdout, chunk.slice(0, truncatedLen)), ex = new ERR_CHILD_PROCESS_STDIO_MAXBUFFER(\"stdout\"), kill();\n      } else\n        ArrayPrototypePush.call(_stdout, chunk);\n    });\n  }\n  if (child.stderr) {\n    if (encoding)\n      child.stderr.setEncoding(encoding);\n    child.stderr.on(\"data\", maxBuffer === Infinity \? function onUnlimitedSizeBufferedData(chunk) {\n      ArrayPrototypePush.call(_stderr, chunk);\n    } : encoding \? function onChildStderrEncoded(chunk) {\n      if (stderrLen += chunk.length, stderrLen * 4 > maxBuffer) {\n        const encoding2 = child.stderr.readableEncoding, actualLen = Buffer.byteLength(chunk, encoding2);\n        if (encodedStderrLen === void 0)\n          for (let i = 0;i < _stderr.length; i++)\n            encodedStderrLen += Buffer.byteLength(_stderr[i], encoding2);\n        else\n          encodedStderrLen += actualLen;\n        const truncatedLen = maxBuffer - (encodedStderrLen - actualLen);\n        ArrayPrototypePush.call(_stderr, StringPrototypeSlice.call(chunk, 0, truncatedLen)), ex = new ERR_CHILD_PROCESS_STDIO_MAXBUFFER(\"stderr\"), kill();\n      } else\n        ArrayPrototypePush.call(_stderr, chunk);\n    } : function onChildStderrRaw(chunk) {\n      if (stderrLen += chunk.length, stderrLen > maxBuffer) {\n        const truncatedLen = maxBuffer - (stderrLen - chunk.length);\n        ArrayPrototypePush.call(_stderr, StringPrototypeSlice.call(chunk, 0, truncatedLen)), ex = new ERR_CHILD_PROCESS_STDIO_MAXBUFFER(\"stderr\"), kill();\n      } else\n        ArrayPrototypePush.call(_stderr, chunk);\n    });\n  }\n  return child.addListener(\"close\", exitHandler), child.addListener(\"error\", errorHandler), child;\n}, exec = function(command, options, callback) {\n  const opts = normalizeExecArgs(command, options, callback);\n  return execFile(opts.file, opts.options, opts.callback);\n}, spawnSync = function(file, args, options) {\n  options = {\n    maxBuffer: MAX_BUFFER,\n    ...normalizeSpawnArguments(file, args, options)\n  };\n  const { maxBuffer, encoding } = options;\n  validateTimeout(options.timeout), validateMaxBuffer(maxBuffer), options.killSignal = sanitizeKillSignal(options.killSignal);\n  const stdio = options.stdio || \"pipe\", bunStdio = getBunStdioFromOptions(stdio);\n  var { input } = options;\n  if (input)\n    if (ArrayBufferIsView(input))\n      bunStdio[0] = input;\n    else if (typeof input === \"string\")\n      bunStdio[0] = Buffer.from(input, encoding || \"utf8\");\n    else\n      throw new ERR_INVALID_ARG_TYPE(\"options.stdio[0]\", [\"Buffer\", \"TypedArray\", \"DataView\", \"string\"], input);\n  const { stdout, stderr, success, exitCode } = Bun.spawnSync({\n    cmd: options.args,\n    env: options.env || void 0,\n    cwd: options.cwd || void 0,\n    stdin: bunStdio[0],\n    stdout: bunStdio[1],\n    stderr: bunStdio[2]\n  }), result = {\n    signal: null,\n    status: exitCode,\n    output: [null, stdout, stderr]\n  };\n  if (stdout && encoding && encoding !== \"buffer\")\n    result.output[1] = result.output[1]\?.toString(encoding);\n  if (stderr && encoding && encoding !== \"buffer\")\n    result.output[2] = result.output[2]\?.toString(encoding);\n  if (result.stdout = result.output[1], result.stderr = result.output[2], !success)\n    result.error = new SystemError(result.output[2], options.file, \"spawnSync\", -1, result.status), result.error.spawnargs = ArrayPrototypeSlice.call(options.args, 1);\n  return result;\n}, execFileSync = function(file, args, options) {\n  ({ file, args, options } = normalizeExecFileArgs(file, args, options));\n  const ret = spawnSync(file, args, options), errArgs = [options.argv0 || file];\n  ArrayPrototypePush.apply(errArgs, args);\n  const err = checkExecSyncError(ret, errArgs);\n  if (err)\n    throw err;\n  return ret.stdout;\n}, execSync = function(command, options) {\n  const opts = normalizeExecArgs(command, options, null), ret = spawnSync(opts.file, opts.options), err = checkExecSyncError(ret, void 0, command);\n  if (err)\n    throw err;\n  return ret.stdout;\n}, stdioStringToArray = function(stdio, channel) {\n  const options = [];\n  switch (stdio) {\n    case \"ignore\":\n    case \"overlapped\":\n    case \"pipe\":\n      ArrayPrototypePush.call(options, stdio, stdio, stdio);\n      break;\n    case \"inherit\":\n      ArrayPrototypePush.call(options, 0, 1, 2);\n      break;\n    default:\n      throw new ERR_INVALID_ARG_VALUE(\"stdio\", stdio);\n  }\n  if (channel)\n    ArrayPrototypePush.call(options, channel);\n  return options;\n}, fork = function(modulePath, args = [], options) {\n  modulePath = getValidatedPath(modulePath, \"modulePath\");\n  let execArgv;\n  if (args == null)\n    args = [];\n  else if (typeof args === \"object\" && !ArrayIsArray(args))\n    options = args, args = [];\n  else\n    validateArray(args, \"args\");\n  if (options != null)\n    validateObject(options, \"options\");\n  if (options = { __proto__: null, ...options, shell: !1 }, options.execPath = options.execPath || process.execPath, validateArgumentNullCheck(options.execPath, \"options.execPath\"), execArgv = options.execArgv || process.execArgv, validateArgumentsNullCheck(execArgv, \"options.execArgv\"), execArgv === process.execArgv && process._eval != null) {\n    const index = ArrayPrototypeLastIndexOf.call(execArgv, process._eval);\n    if (index > 0)\n      execArgv = ArrayPrototypeSlice.call(execArgv), ArrayPrototypeSplice.call(execArgv, index - 1, 2);\n  }\n  if (args = [...execArgv, modulePath, ...args], typeof options.stdio === \"string\")\n    options.stdio = stdioStringToArray(options.stdio, \"ipc\");\n  else if (!ArrayIsArray(options.stdio))\n    options.stdio = stdioStringToArray(options.silent \? \"pipe\" : \"inherit\", \"ipc\");\n  else if (!ArrayPrototypeIncludes.call(options.stdio, \"ipc\"))\n    throw new ERR_CHILD_PROCESS_IPC_REQUIRED(\"options.stdio\");\n  return spawn(options.execPath, args, options);\n}, convertToValidSignal = function(signal) {\n  if (typeof signal === \"number\" && getSignalsToNamesMapping()[signal])\n    return signal;\n  if (typeof signal === \"string\") {\n    const signalName = signals[StringPrototypeToUpperCase.call(signal)];\n    if (signalName)\n      return signalName;\n  }\n  throw new ERR_UNKNOWN_SIGNAL(signal);\n}, sanitizeKillSignal = function(killSignal2) {\n  if (typeof killSignal2 === \"string\" || typeof killSignal2 === \"number\")\n    return convertToValidSignal(killSignal2);\n  else if (killSignal2 != null)\n    throw new ERR_INVALID_ARG_TYPE(\"options.killSignal\", [\"string\", \"number\"], killSignal2);\n}, getSignalsToNamesMapping = function() {\n  if (signalsToNamesMapping !== void 0)\n    return signalsToNamesMapping;\n  signalsToNamesMapping = ObjectCreate(null);\n  for (let key in signals)\n    signalsToNamesMapping[signals[key]] = key;\n  return signalsToNamesMapping;\n}, normalizeExecFileArgs = function(file, args, options, callback) {\n  if (ArrayIsArray(args))\n    args = ArrayPrototypeSlice.call(args);\n  else if (args != null && typeof args === \"object\")\n    callback = options, options = args, args = null;\n  else if (typeof args === \"function\")\n    callback = args, options = null, args = null;\n  if (args == null)\n    args = [];\n  if (typeof options === \"function\")\n    callback = options;\n  else if (options != null)\n    validateObject(options, \"options\");\n  if (options == null)\n    options = kEmptyObject;\n  if (callback != null)\n    validateFunction(callback, \"callback\");\n  if (options.argv0 != null)\n    validateString(options.argv0, \"options.argv0\"), validateArgumentNullCheck(options.argv0, \"options.argv0\");\n  return { file, args, options, callback };\n}, normalizeExecArgs = function(command, options, callback) {\n  if (validateString(command, \"command\"), validateArgumentNullCheck(command, \"command\"), typeof options === \"function\")\n    callback = options, options = void 0;\n  return options = { ...options }, options.shell = typeof options.shell === \"string\" \? options.shell : !0, {\n    file: command,\n    options,\n    callback\n  };\n}, normalizeSpawnArguments = function(file, args, options) {\n  if (validateString(file, \"file\"), validateArgumentNullCheck(file, \"file\"), file.length === 0)\n    throw new ERR_INVALID_ARG_VALUE(\"file\", file, \"cannot be empty\");\n  if (ArrayIsArray(args))\n    args = ArrayPrototypeSlice.call(args);\n  else if (args == null)\n    args = [];\n  else if (typeof args !== \"object\")\n    throw new ERR_INVALID_ARG_TYPE(\"args\", \"object\", args);\n  else\n    options = args, args = [];\n  if (validateArgumentsNullCheck(args, \"args\"), options === void 0)\n    options = {};\n  else\n    validateObject(options, \"options\");\n  let cwd = options.cwd;\n  if (cwd != null)\n    cwd = getValidatedPath(cwd, \"options.cwd\");\n  if (options.shell != null && typeof options.shell !== \"boolean\" && typeof options.shell !== \"string\")\n    throw new ERR_INVALID_ARG_TYPE(\"options.shell\", [\"boolean\", \"string\"], options.shell);\n  if (options.argv0 != null)\n    validateString(options.argv0, \"options.argv0\"), validateArgumentNullCheck(options.argv0, \"options.argv0\");\n  if (options.shell) {\n    validateArgumentNullCheck(options.shell, \"options.shell\");\n    const command = ArrayPrototypeJoin.call([file, ...args], \" \");\n    if (typeof options.shell === \"string\")\n      file = options.shell;\n    else\n      file = \"sh\";\n    args = [\"-c\", command];\n  }\n  if (typeof options.argv0 === \"string\")\n    ArrayPrototypeUnshift.call(args, options.argv0);\n  else\n    ArrayPrototypeUnshift.call(args, file);\n  const envPairs = options.env || process.env;\n  return { ...options, file, args, cwd, envPairs };\n}, checkExecSyncError = function(ret, args, cmd) {\n  let err;\n  if (ret.error)\n    err = ret.error, ObjectAssign(err, ret);\n  else if (ret.status !== 0) {\n    let msg = \"Command failed: \";\n    if (msg += cmd || ArrayPrototypeJoin.call(args, \" \"), ret.stderr && ret.stderr.length > 0)\n      msg += `\\n${ret.stderr.toString()}`;\n    err = genericNodeError(msg, ret);\n  }\n  return err;\n}, nodeToBun = function(item) {\n  if (typeof item === \"number\")\n    return item;\n  else {\n    const result = nodeToBunLookup[item];\n    if (result === void 0)\n      throw new Error(\"Invalid stdio option\");\n    return result;\n  }\n}, fdToStdioName = function(fd) {\n  switch (fd) {\n    case 0:\n      return \"stdin\";\n    case 1:\n      return \"stdout\";\n    case 2:\n      return \"stderr\";\n    default:\n      return null;\n  }\n}, getBunStdioFromOptions = function(stdio) {\n  return normalizeStdio(stdio).map((item) => nodeToBun(item));\n}, normalizeStdio = function(stdio) {\n  if (typeof stdio === \"string\")\n    switch (stdio) {\n      case \"ignore\":\n        return [\"ignore\", \"ignore\", \"ignore\"];\n      case \"pipe\":\n        return [\"pipe\", \"pipe\", \"pipe\"];\n      case \"inherit\":\n        return [\"inherit\", \"inherit\", \"inherit\"];\n      default:\n        throw new ERR_INVALID_OPT_VALUE(\"stdio\", stdio);\n    }\n  else if (ArrayIsArray(stdio)) {\n    let processedStdio;\n    if (stdio.length === 0)\n      processedStdio = [\"pipe\", \"pipe\", \"pipe\"];\n    else if (stdio.length === 1)\n      processedStdio = [stdio[0], \"pipe\", \"pipe\"];\n    else if (stdio.length === 2)\n      processedStdio = [stdio[0], stdio[1], \"pipe\"];\n    else if (stdio.length >= 3)\n      processedStdio = [stdio[0], stdio[1], stdio[2]];\n    return processedStdio.map((item) => !item \? \"pipe\" : item);\n  } else\n    throw new ERR_INVALID_OPT_VALUE(\"stdio\", stdio);\n}, flushStdio = function(subprocess) {\n  const stdio = subprocess.stdio;\n  if (stdio == null)\n    return;\n  for (let i = 0;i < stdio.length; i++) {\n    const stream = stdio[i];\n    if (!stream || !stream.readable)\n      continue;\n    stream.resume();\n  }\n}, onSpawnNT = function(self) {\n  self.emit(\"spawn\");\n}, abortChildProcess = function(child, killSignal2, reason) {\n  if (!child)\n    return;\n  try {\n    if (child.kill(killSignal2))\n      child.emit(\"error\", new AbortError(void 0, { cause: reason }));\n  } catch (err) {\n    child.emit(\"error\", err);\n  }\n}, validateMaxBuffer = function(maxBuffer) {\n  if (maxBuffer != null && !(typeof maxBuffer === \"number\" && maxBuffer >= 0))\n    throw new ERR_OUT_OF_RANGE(\"options.maxBuffer\", \"a positive number\", maxBuffer);\n}, validateArgumentNullCheck = function(arg, propName) {\n  if (typeof arg === \"string\" && StringPrototypeIncludes.call(arg, \"\\0\"))\n    throw new ERR_INVALID_ARG_VALUE(propName, arg, \"must be a string without null bytes\");\n}, validateArgumentsNullCheck = function(args, propName) {\n  for (let i = 0;i < args.length; ++i)\n    validateArgumentNullCheck(args[i], `${propName}[${i}]`);\n}, validateTimeout = function(timeout) {\n  if (timeout != null && !(NumberIsInteger(timeout) && timeout >= 0))\n    throw new ERR_OUT_OF_RANGE(\"timeout\", \"an unsigned integer\", timeout);\n};\nvar validateFunction = function(value, name) {\n  if (typeof value !== \"function\")\n    throw new ERR_INVALID_ARG_TYPE(name, \"Function\", value);\n}, validateString = function(value, name) {\n  if (typeof value !== \"string\")\n    throw new ERR_INVALID_ARG_TYPE(name, \"string\", value);\n}, nullCheck = function(path, propName, throwError = !0) {\n  const pathIsString = typeof path === \"string\", pathIsUint8Array = isUint8Array(path);\n  if (!pathIsString && !pathIsUint8Array || pathIsString && !StringPrototypeIncludes.call(path, \"\\0\") || pathIsUint8Array && !Uint8ArrayPrototypeIncludes.call(path, 0))\n    return;\n  const err = new ERR_INVALID_ARG_VALUE(propName, path, \"must be a string or Uint8Array without null bytes\");\n  if (throwError)\n    throw err;\n  return err;\n}, validatePath = function(path, propName = \"path\") {\n  if (typeof path !== \"string\" && !isUint8Array(path))\n    throw new ERR_INVALID_ARG_TYPE(propName, [\"string\", \"Buffer\", \"URL\"], path);\n  const err = nullCheck(path, propName, !1);\n  if (err !== void 0)\n    throw err;\n}, getValidatedPath = function(fileURLOrPath, propName = \"path\") {\n  const path = toPathIfFileURL(fileURLOrPath);\n  return validatePath(path, propName), path;\n}, isUint8Array = function(value) {\n  return typeof value === \"object\" && value !== null && value instanceof Uint8Array;\n}, isURLInstance = function(fileURLOrPath) {\n  return fileURLOrPath != null && fileURLOrPath.href && fileURLOrPath.origin;\n}, toPathIfFileURL = function(fileURLOrPath) {\n  if (!isURLInstance(fileURLOrPath))\n    return fileURLOrPath;\n  return Bun.fileURLToPath(fileURLOrPath);\n}, genericNodeError = function(message, options) {\n  const err = new Error(message);\n  return err.code = options.code, err.killed = options.killed, err.signal = options.signal, err;\n}, ERR_OUT_OF_RANGE = function(str, range, input, replaceDefaultBoolean = !1) {\n  return new RangeError(`The value of ${str} is out of range. It must be ${range}. Received ${input}`);\n}, ERR_CHILD_PROCESS_STDIO_MAXBUFFER = function(stdio) {\n  return Error(`${stdio} maxBuffer length exceeded`);\n}, ERR_UNKNOWN_SIGNAL = function(name) {\n  const err = @makeTypeError(`Unknown signal: ${name}`);\n  return err.code = \"ERR_UNKNOWN_SIGNAL\", err;\n}, ERR_INVALID_ARG_TYPE = function(name, type, value) {\n  const err = @makeTypeError(`The \"${name}\" argument must be of type ${type}. Received ${value\?.toString()}`);\n  return err.code = \"ERR_INVALID_ARG_TYPE\", err;\n}, ERR_INVALID_OPT_VALUE = function(name, value) {\n  return @makeTypeError(`The value \"${value}\" is invalid for option \"${name}\"`);\n}, ERR_INVALID_ARG_VALUE = function(name, value, reason) {\n  return new Error(`The value \"${value}\" is invalid for argument '${name}'. Reason: ${reason}`);\n}, ERR_CHILD_PROCESS_IPC_REQUIRED = function(name) {\n  const err = @makeTypeError(`Forked processes must have an IPC channel, missing value 'ipc' in ${name}`);\n  return err.code = \"ERR_CHILD_PROCESS_IPC_REQUIRED\", err;\n}, $, EventEmitter = @getInternalField(@internalModuleRegistry, 16) || @createInternalModuleById(16), StreamModule = @getInternalField(@internalModuleRegistry, 35) || @createInternalModuleById(35), {\n  constants: { signals }\n} = @getInternalField(@internalModuleRegistry, 24) || @createInternalModuleById(24), { promisify } = @getInternalField(@internalModuleRegistry, 43) || @createInternalModuleById(43), ObjectCreate = Object.create, ObjectAssign = Object.assign, ObjectDefineProperty = Object.defineProperty, BufferConcat = Buffer.concat, BufferIsEncoding = Buffer.isEncoding, kEmptyObject = ObjectCreate(null), ArrayPrototypePush = Array.prototype.push, ArrayPrototypeJoin = Array.prototype.join, ArrayPrototypeMap = Array.prototype.map, ArrayPrototypeIncludes = Array.prototype.includes, ArrayPrototypeSlice = Array.prototype.slice, ArrayPrototypeUnshift = Array.prototype.unshift, ArrayPrototypeLastIndexOf = Array.prototype.lastIndexOf, ArrayPrototypeSplice = Array.prototype.splice, ArrayIsArray = Array.isArray, ArrayBufferIsView = ArrayBuffer.isView, NumberIsInteger = Number.isInteger;\nvar StringPrototypeToUpperCase = String.prototype.toUpperCase, StringPrototypeIncludes = String.prototype.includes, StringPrototypeSlice = String.prototype.slice, Uint8ArrayPrototypeIncludes = Uint8Array.prototype.includes, MAX_BUFFER = 1048576, NativeWritable, ReadableFromWeb, customPromiseExecFunction = (orig) => {\n  return (...args) => {\n    let resolve, reject;\n    const promise = new Promise((res, rej) => {\n      resolve = res, reject = rej;\n    });\n    return promise.child = orig(...args, (err, stdout, stderr) => {\n      if (err !== null)\n        err.stdout = stdout, err.stderr = stderr, reject(err);\n      else\n        resolve({ stdout, stderr });\n    }), promise;\n  };\n};\nObjectDefineProperty(exec, promisify.custom, {\n  __proto__: null,\n  enumerable: !1,\n  value: customPromiseExecFunction(exec)\n});\nvar signalsToNamesMapping;\n\nclass ChildProcess extends EventEmitter {\n  constructor() {\n    super(...arguments);\n  }\n  #handle;\n  #exited = !1;\n  #closesNeeded = 1;\n  #closesGot = 0;\n  connected = !1;\n  signalCode = null;\n  exitCode = null;\n  spawnfile;\n  spawnargs;\n  pid;\n  channel;\n  get killed() {\n    if (this.#handle == null)\n      return !1;\n  }\n  #handleOnExit(exitCode, signalCode, err) {\n    if (this.#exited)\n      return;\n    if (signalCode)\n      this.signalCode = signalCode;\n    else\n      this.exitCode = exitCode;\n    if (this.#stdin)\n      this.#stdin.destroy();\n    if (this.#handle)\n      this.#handle = null;\n    if (exitCode < 0) {\n      const err2 = new SystemError(`Spawned process exited with error code: ${exitCode}`, void 0, \"spawn\", \"EUNKNOWN\", \"ERR_CHILD_PROCESS_UNKNOWN_ERROR\");\n      if (this.spawnfile)\n        err2.path = this.spawnfile;\n      err2.spawnargs = ArrayPrototypeSlice.call(this.spawnargs, 1), this.emit(\"error\", err2);\n    } else\n      this.emit(\"exit\", this.exitCode, this.signalCode);\n    process.nextTick(flushStdio, this), this.#maybeClose(), this.#exited = !0, this.#stdioOptions = [\"destroyed\", \"destroyed\", \"destroyed\"];\n  }\n  #getBunSpawnIo(i, encoding) {\n    NativeWritable ||= StreamModule.NativeWritable, ReadableFromWeb ||= StreamModule.Readable.fromWeb;\n    const io = this.#stdioOptions[i];\n    switch (i) {\n      case 0:\n        switch (io) {\n          case \"pipe\":\n            return new NativeWritable(this.#handle.stdin);\n          case \"inherit\":\n            return process.stdin || null;\n          case \"destroyed\":\n            return new ShimmedStdin;\n          default:\n            return null;\n        }\n      case 2:\n      case 1:\n        switch (io) {\n          case \"pipe\":\n            return ReadableFromWeb(this.#handle[fdToStdioName(i)], { encoding });\n          case \"inherit\":\n            return process[fdToStdioName(i)] || null;\n          case \"destroyed\":\n            return new ShimmedStdioOutStream;\n          default:\n            return null;\n        }\n    }\n  }\n  #stdin;\n  #stdout;\n  #stderr;\n  #stdioObject;\n  #encoding;\n  #stdioOptions;\n  #createStdioObject() {\n    return Object.create(null, {\n      0: {\n        get: () => this.stdin\n      },\n      1: {\n        get: () => this.stdout\n      },\n      2: {\n        get: () => this.stderr\n      }\n    });\n  }\n  get stdin() {\n    return this.#stdin \?\?= this.#getBunSpawnIo(0, this.#encoding);\n  }\n  get stdout() {\n    return this.#stdout \?\?= this.#getBunSpawnIo(1, this.#encoding);\n  }\n  get stderr() {\n    return this.#stderr \?\?= this.#getBunSpawnIo(2, this.#encoding);\n  }\n  get stdio() {\n    return this.#stdioObject \?\?= this.#createStdioObject();\n  }\n  spawn(options) {\n    validateObject(options, \"options\"), validateString(options.file, \"options.file\");\n    var file = this.spawnfile = options.file, spawnargs;\n    if (options.args == null)\n      spawnargs = this.spawnargs = [];\n    else\n      validateArray(options.args, \"options.args\"), spawnargs = this.spawnargs = options.args;\n    const stdio = options.stdio || [\"pipe\", \"pipe\", \"pipe\"], bunStdio = getBunStdioFromOptions(stdio);\n    var env = options.envPairs || void 0;\n    this.#encoding = options.encoding || void 0, this.#stdioOptions = bunStdio, this.#handle = Bun.spawn({\n      cmd: spawnargs,\n      stdin: bunStdio[0],\n      stdout: bunStdio[1],\n      stderr: bunStdio[2],\n      cwd: options.cwd || void 0,\n      env: env || process.env,\n      onExit: (handle, exitCode, signalCode, err) => {\n        this.#handle = handle, this.pid = this.#handle.pid, process.nextTick((exitCode2, signalCode2, err2) => this.#handleOnExit(exitCode2, signalCode2, err2), exitCode, signalCode, err);\n      },\n      lazy: !0\n    }), this.pid = this.#handle.pid, onSpawnNT(this);\n  }\n  send() {\n    console.log(\"ChildProcess.prototype.send() - Sorry! Not implemented yet\");\n  }\n  disconnect() {\n    console.log(\"ChildProcess.prototype.disconnect() - Sorry! Not implemented yet\");\n  }\n  kill(sig) {\n    const signal = sig === 0 \? sig : convertToValidSignal(sig === void 0 \? \"SIGTERM\" : sig);\n    if (this.#handle)\n      this.#handle.kill(signal);\n    return this.#maybeClose(), !0;\n  }\n  #maybeClose() {\n    if (this.#closesGot++, this.#closesGot === this.#closesNeeded)\n      this.emit(\"close\", this.exitCode, this.signalCode);\n  }\n  ref() {\n    if (this.#handle)\n      this.#handle.ref();\n  }\n  unref() {\n    if (this.#handle)\n      this.#handle.unref();\n  }\n}\nvar nodeToBunLookup = {\n  ignore: null,\n  pipe: \"pipe\",\n  overlapped: \"pipe\",\n  inherit: \"inherit\"\n};\n\nclass ShimmedStdin extends EventEmitter {\n  constructor() {\n    super();\n  }\n  write() {\n    return !1;\n  }\n  destroy() {\n  }\n  end() {\n  }\n  pipe() {\n  }\n}\n\nclass ShimmedStdioOutStream extends EventEmitter {\n  constructor() {\n    super(...arguments);\n  }\n  pipe() {\n  }\n}\nvar validateAbortSignal = (signal, name) => {\n  if (signal !== void 0 && (signal === null || typeof signal !== \"object\" || !(\"aborted\" in signal)))\n    throw new ERR_INVALID_ARG_TYPE(name, \"AbortSignal\", signal);\n};\nvar validateObject = (value, name, options = null) => {\n  const allowArray = options\?.allowArray \?\? !1, allowFunction = options\?.allowFunction \?\? !1;\n  if (!(options\?.nullable \?\? !1) && value === null || !allowArray && ArrayIsArray.call(value) || typeof value !== \"object\" && (!allowFunction || typeof value !== \"function\"))\n    throw new ERR_INVALID_ARG_TYPE(name, \"object\", value);\n}, validateArray = (value, name, minLength = 0) => {\n  if (!ArrayIsArray(value))\n    throw new ERR_INVALID_ARG_TYPE(name, \"Array\", value);\n  if (value.length < minLength) {\n    const reason = `must be longer than ${minLength}`;\n    throw new ERR_INVALID_ARG_VALUE(name, value, reason);\n  }\n}, Error = globalThis.Error, TypeError = globalThis.TypeError, RangeError = globalThis.RangeError;\n\nclass AbortError extends Error {\n  code = \"ABORT_ERR\";\n  name = \"AbortError\";\n  constructor(message = \"The operation was aborted\", options = void 0) {\n    if (options !== void 0 && typeof options !== \"object\")\n      throw new ERR_INVALID_ARG_TYPE(\"options\", \"Object\", options);\n    super(message, options);\n  }\n}\n\nclass SystemError extends Error {\n  path;\n  syscall;\n  errno;\n  code;\n  constructor(message, path, syscall, errno, code) {\n    super(message);\n    this.path = path, this.syscall = syscall, this.errno = errno, this.code = code;\n  }\n  get name() {\n    return \"SystemError\";\n  }\n}\n$ = {\n  ChildProcess,\n  spawn,\n  execFile,\n  exec,\n  fork,\n  spawnSync,\n  execFileSync,\n  execSync\n};\nreturn $})\n"_s;
//

//
static constexpr ASCIILiteral NodeClusterCode = "(function (){\"use strict\";// src/js/out/tmp/node/cluster.ts\nvar EventEmitter = @getInternalField(@internalModuleRegistry, 16) || @createInternalModuleById(16), { throwNotImplemented } = @getInternalField(@internalModuleRegistry, 3) || @createInternalModuleById(3);\n\nclass Cluster extends EventEmitter {\n  constructor() {\n    super(...arguments);\n  }\n  isWorker = !1;\n  isPrimary = !0;\n  isMaster = !0;\n  workers = {};\n  settings = {};\n  SCHED_NONE = 1;\n  SCHED_RR = 2;\n  schedulingPolicy = 2;\n  Worker = function Worker() {\n    throwNotImplemented(\"node:cluster Worker\", 2428);\n  };\n  setupPrimary() {\n    throwNotImplemented(\"node:cluster\", 2428);\n  }\n  setupMaster() {\n    throwNotImplemented(\"node:cluster\", 2428);\n  }\n  fork() {\n    throwNotImplemented(\"node:cluster\", 2428);\n  }\n  disconnect() {\n    throwNotImplemented(\"node:cluster\", 2428);\n  }\n}\nreturn new Cluster})\n"_s;
//

//
static constexpr ASCIILiteral NodeConsoleCode = "(function (){\"use strict\";// src/js/out/tmp/node/console.ts\nreturn console})\n"_s;
//

//
static constexpr ASCIILiteral NodeCryptoCode = "(function (){\"use strict\";// src/js/out/tmp/node/crypto.ts\nvar getArrayBufferOrView = function(buffer, name, encoding) {\n  if (isAnyArrayBuffer(buffer))\n    return buffer;\n  if (typeof buffer === \"string\") {\n    if (encoding === \"buffer\")\n      encoding = \"utf8\";\n    return Buffer.from(buffer, encoding);\n  }\n  if (!isArrayBufferView(buffer)) {\n    var error = @makeTypeError(`ERR_INVALID_ARG_TYPE: The \"${name}\" argument must be of type string or an instance of ArrayBuffer, Buffer, TypedArray, or DataView. Received ` + buffer);\n    throw error.code = \"ERR_INVALID_ARG_TYPE\", error;\n  }\n  return buffer;\n}, getCurves = function() {\n  return harcoded_curves;\n}, $, __defProp = Object.defineProperty, __getOwnPropNames = Object.getOwnPropertyNames, StreamModule = @getInternalField(@internalModuleRegistry, 35) || @createInternalModuleById(35), BufferModule = @requireNativeModule(\"node:buffer\"), StringDecoder = @requireNativeModule(\"node:string_decoder\").StringDecoder, MAX_STRING_LENGTH = 536870888, Buffer = globalThis.Buffer, EMPTY_BUFFER = Buffer.alloc(0), { isAnyArrayBuffer, isArrayBufferView } = @requireNativeModule(\"node:util/types\"), crypto = globalThis.crypto, globalCrypto = crypto, __commonJS = (cb, mod) => function() {\n  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;\n}, __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: !0 });\n}, require_safe_buffer = __commonJS({\n  \"node_modules/safe-buffer/index.js\"(exports, module) {\n    var buffer = BufferModule, Buffer2 = buffer.Buffer;\n    function copyProps(src, dst) {\n      for (var key in src)\n        dst[key] = src[key];\n    }\n    Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow \? module.exports = buffer : (copyProps(buffer, exports), exports.Buffer = SafeBuffer);\n    function SafeBuffer(arg, encodingOrOffset, length) {\n      return Buffer2(arg, encodingOrOffset, length);\n    }\n    SafeBuffer.prototype = Object.create(Buffer2.prototype), copyProps(Buffer2, SafeBuffer), SafeBuffer.from = function(arg, encodingOrOffset, length) {\n      if (typeof arg == \"number\")\n        @throwTypeError(\"Argument must not be a number\");\n      return Buffer2(arg, encodingOrOffset, length);\n    }, SafeBuffer.alloc = function(size, fill, encoding) {\n      if (typeof size != \"number\")\n        @throwTypeError(\"Argument must be a number\");\n      var buf = Buffer2(size);\n      return fill !== void 0 \? typeof encoding == \"string\" \? buf.fill(fill, encoding) : buf.fill(fill) : buf.fill(0), buf;\n    }, SafeBuffer.allocUnsafe = function(size) {\n      if (typeof size != \"number\")\n        @throwTypeError(\"Argument must be a number\");\n      return Buffer2(size);\n    }, SafeBuffer.allocUnsafeSlow = function(size) {\n      if (typeof size != \"number\")\n        @throwTypeError(\"Argument must be a number\");\n      return buffer.SlowBuffer(size);\n    };\n  }\n}), require_browser = __commonJS({\n  \"node_modules/randombytes/browser.js\"(exports, module) {\n    var MAX_BYTES = 65536, MAX_UINT32 = 4294967295;\n    function oldBrowser() {\n      throw new Error(`Secure random number generation is not supported by this browser.\nUse Chrome, Firefox or Internet Explorer 11`);\n    }\n    var Buffer2 = require_safe_buffer().Buffer, crypto2 = globalCrypto;\n    crypto2 && crypto2.getRandomValues \? module.exports = randomBytes : module.exports = oldBrowser;\n    function randomBytes(size, cb) {\n      if (size > MAX_UINT32)\n        @throwRangeError(\"requested too many random bytes\");\n      var bytes = Buffer2.allocUnsafe(size);\n      if (size > 0)\n        if (size > MAX_BYTES)\n          for (var generated = 0;generated < size; generated += MAX_BYTES)\n            crypto2.getRandomValues(bytes.slice(generated, generated + MAX_BYTES));\n        else\n          crypto2.getRandomValues(bytes);\n      return typeof cb == \"function\" \? process.nextTick(function() {\n        cb(null, bytes);\n      }) : bytes;\n    }\n  }\n}), require_inherits_browser = __commonJS({\n  \"node_modules/inherits/inherits_browser.js\"(exports, module) {\n    module.exports = function(ctor, superCtor) {\n      superCtor && (ctor.super_ = superCtor, ctor.prototype = Object.create(superCtor.prototype, {\n        constructor: {\n          value: ctor,\n          enumerable: !1,\n          writable: !0,\n          configurable: !0\n        }\n      }));\n    };\n  }\n}), require_hash_base = __commonJS({\n  \"node_modules/hash-base/index.js\"(exports, module) {\n    var Buffer2 = require_safe_buffer().Buffer, inherits = require_inherits_browser();\n    function throwIfNotStringOrBuffer(val, prefix) {\n      if (!Buffer2.isBuffer(val) && typeof val != \"string\")\n        @throwTypeError(prefix + \" must be a string or a buffer\");\n    }\n    function HashBase(blockSize) {\n      StreamModule.Transform.call(this), this._block = Buffer2.allocUnsafe(blockSize), this._blockSize = blockSize, this._blockOffset = 0, this._length = [0, 0, 0, 0], this._finalized = !1;\n    }\n    inherits(HashBase, StreamModule.Transform), HashBase.prototype._transform = function(chunk, encoding, callback) {\n      var error = null;\n      try {\n        this.update(chunk, encoding);\n      } catch (err) {\n        error = err;\n      }\n      callback(error);\n    }, HashBase.prototype._flush = function(callback) {\n      var error = null;\n      try {\n        this.push(this.digest());\n      } catch (err) {\n        error = err;\n      }\n      callback(error);\n    }, HashBase.prototype.update = function(data, encoding) {\n      if (throwIfNotStringOrBuffer(data, \"Data\"), this._finalized)\n        throw new Error(\"Digest already called\");\n      Buffer2.isBuffer(data) || (data = Buffer2.from(data, encoding));\n      for (var block = this._block, offset = 0;this._blockOffset + data.length - offset >= this._blockSize; ) {\n        for (var i = this._blockOffset;i < this._blockSize; )\n          block[i++] = data[offset++];\n        this._update(), this._blockOffset = 0;\n      }\n      for (;offset < data.length; )\n        block[this._blockOffset++] = data[offset++];\n      for (var j = 0, carry = data.length * 8;carry > 0; ++j)\n        this._length[j] += carry, carry = this._length[j] / 4294967296 | 0, carry > 0 && (this._length[j] -= 4294967296 * carry);\n      return this;\n    }, HashBase.prototype._update = function() {\n      throw new Error(\"_update is not implemented\");\n    }, HashBase.prototype.digest = function(encoding) {\n      if (this._finalized)\n        throw new Error(\"Digest already called\");\n      this._finalized = !0;\n      var digest = this._digest();\n      encoding !== void 0 && (digest = digest.toString(encoding)), this._block.fill(0), this._blockOffset = 0;\n      for (var i = 0;i < 4; ++i)\n        this._length[i] = 0;\n      return digest;\n    }, HashBase.prototype._digest = function() {\n      throw new Error(\"_digest is not implemented\");\n    }, module.exports = HashBase;\n  }\n}), require_md5 = __commonJS({\n  \"node_modules/md5.js/index.js\"(exports, module) {\n    var inherits = require_inherits_browser(), HashBase = require_hash_base(), Buffer2 = require_safe_buffer().Buffer, ARRAY16 = new Array(16);\n    function MD5() {\n      HashBase.call(this, 64), this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878;\n    }\n    inherits(MD5, HashBase), MD5.prototype._update = function() {\n      for (var M = ARRAY16, i = 0;i < 16; ++i)\n        M[i] = this._block.readInt32LE(i * 4);\n      var a = this._a, b = this._b, c = this._c, d = this._d;\n      a = fnF(a, b, c, d, M[0], 3614090360, 7), d = fnF(d, a, b, c, M[1], 3905402710, 12), c = fnF(c, d, a, b, M[2], 606105819, 17), b = fnF(b, c, d, a, M[3], 3250441966, 22), a = fnF(a, b, c, d, M[4], 4118548399, 7), d = fnF(d, a, b, c, M[5], 1200080426, 12), c = fnF(c, d, a, b, M[6], 2821735955, 17), b = fnF(b, c, d, a, M[7], 4249261313, 22), a = fnF(a, b, c, d, M[8], 1770035416, 7), d = fnF(d, a, b, c, M[9], 2336552879, 12), c = fnF(c, d, a, b, M[10], 4294925233, 17), b = fnF(b, c, d, a, M[11], 2304563134, 22), a = fnF(a, b, c, d, M[12], 1804603682, 7), d = fnF(d, a, b, c, M[13], 4254626195, 12), c = fnF(c, d, a, b, M[14], 2792965006, 17), b = fnF(b, c, d, a, M[15], 1236535329, 22), a = fnG(a, b, c, d, M[1], 4129170786, 5), d = fnG(d, a, b, c, M[6], 3225465664, 9), c = fnG(c, d, a, b, M[11], 643717713, 14), b = fnG(b, c, d, a, M[0], 3921069994, 20), a = fnG(a, b, c, d, M[5], 3593408605, 5), d = fnG(d, a, b, c, M[10], 38016083, 9), c = fnG(c, d, a, b, M[15], 3634488961, 14), b = fnG(b, c, d, a, M[4], 3889429448, 20), a = fnG(a, b, c, d, M[9], 568446438, 5), d = fnG(d, a, b, c, M[14], 3275163606, 9), c = fnG(c, d, a, b, M[3], 4107603335, 14), b = fnG(b, c, d, a, M[8], 1163531501, 20), a = fnG(a, b, c, d, M[13], 2850285829, 5), d = fnG(d, a, b, c, M[2], 4243563512, 9), c = fnG(c, d, a, b, M[7], 1735328473, 14), b = fnG(b, c, d, a, M[12], 2368359562, 20), a = fnH(a, b, c, d, M[5], 4294588738, 4), d = fnH(d, a, b, c, M[8], 2272392833, 11), c = fnH(c, d, a, b, M[11], 1839030562, 16), b = fnH(b, c, d, a, M[14], 4259657740, 23), a = fnH(a, b, c, d, M[1], 2763975236, 4), d = fnH(d, a, b, c, M[4], 1272893353, 11), c = fnH(c, d, a, b, M[7], 4139469664, 16), b = fnH(b, c, d, a, M[10], 3200236656, 23), a = fnH(a, b, c, d, M[13], 681279174, 4), d = fnH(d, a, b, c, M[0], 3936430074, 11), c = fnH(c, d, a, b, M[3], 3572445317, 16), b = fnH(b, c, d, a, M[6], 76029189, 23), a = fnH(a, b, c, d, M[9], 3654602809, 4), d = fnH(d, a, b, c, M[12], 3873151461, 11), c = fnH(c, d, a, b, M[15], 530742520, 16), b = fnH(b, c, d, a, M[2], 3299628645, 23), a = fnI(a, b, c, d, M[0], 4096336452, 6), d = fnI(d, a, b, c, M[7], 1126891415, 10), c = fnI(c, d, a, b, M[14], 2878612391, 15), b = fnI(b, c, d, a, M[5], 4237533241, 21), a = fnI(a, b, c, d, M[12], 1700485571, 6), d = fnI(d, a, b, c, M[3], 2399980690, 10), c = fnI(c, d, a, b, M[10], 4293915773, 15), b = fnI(b, c, d, a, M[1], 2240044497, 21), a = fnI(a, b, c, d, M[8], 1873313359, 6), d = fnI(d, a, b, c, M[15], 4264355552, 10), c = fnI(c, d, a, b, M[6], 2734768916, 15), b = fnI(b, c, d, a, M[13], 1309151649, 21), a = fnI(a, b, c, d, M[4], 4149444226, 6), d = fnI(d, a, b, c, M[11], 3174756917, 10), c = fnI(c, d, a, b, M[2], 718787259, 15), b = fnI(b, c, d, a, M[9], 3951481745, 21), this._a = this._a + a | 0, this._b = this._b + b | 0, this._c = this._c + c | 0, this._d = this._d + d | 0;\n    }, MD5.prototype._digest = function() {\n      this._block[this._blockOffset++] = 128, this._blockOffset > 56 && (this._block.fill(0, this._blockOffset, 64), this._update(), this._blockOffset = 0), this._block.fill(0, this._blockOffset, 56), this._block.writeUInt32LE(this._length[0], 56), this._block.writeUInt32LE(this._length[1], 60), this._update();\n      var buffer = Buffer2.allocUnsafe(16);\n      return buffer.writeInt32LE(this._a, 0), buffer.writeInt32LE(this._b, 4), buffer.writeInt32LE(this._c, 8), buffer.writeInt32LE(this._d, 12), buffer;\n    };\n    function rotl(x, n) {\n      return x << n | x >>> 32 - n;\n    }\n    function fnF(a, b, c, d, m, k, s) {\n      return rotl(a + (b & c | ~b & d) + m + k | 0, s) + b | 0;\n    }\n    function fnG(a, b, c, d, m, k, s) {\n      return rotl(a + (b & d | c & ~d) + m + k | 0, s) + b | 0;\n    }\n    function fnH(a, b, c, d, m, k, s) {\n      return rotl(a + (b ^ c ^ d) + m + k | 0, s) + b | 0;\n    }\n    function fnI(a, b, c, d, m, k, s) {\n      return rotl(a + (c ^ (b | ~d)) + m + k | 0, s) + b | 0;\n    }\n    module.exports = MD5;\n  }\n}), require_ripemd160 = __commonJS({\n  \"node_modules/ripemd160/index.js\"(exports, module) {\n    var Buffer2 = Buffer, inherits = require_inherits_browser(), HashBase = require_hash_base(), ARRAY16 = new Array(16), zl = [\n      0,\n      1,\n      2,\n      3,\n      4,\n      5,\n      6,\n      7,\n      8,\n      9,\n      10,\n      11,\n      12,\n      13,\n      14,\n      15,\n      7,\n      4,\n      13,\n      1,\n      10,\n      6,\n      15,\n      3,\n      12,\n      0,\n      9,\n      5,\n      2,\n      14,\n      11,\n      8,\n      3,\n      10,\n      14,\n      4,\n      9,\n      15,\n      8,\n      1,\n      2,\n      7,\n      0,\n      6,\n      13,\n      11,\n      5,\n      12,\n      1,\n      9,\n      11,\n      10,\n      0,\n      8,\n      12,\n      4,\n      13,\n      3,\n      7,\n      15,\n      14,\n      5,\n      6,\n      2,\n      4,\n      0,\n      5,\n      9,\n      7,\n      12,\n      2,\n      10,\n      14,\n      1,\n      3,\n      8,\n      11,\n      6,\n      15,\n      13\n    ], zr = [\n      5,\n      14,\n      7,\n      0,\n      9,\n      2,\n      11,\n      4,\n      13,\n      6,\n      15,\n      8,\n      1,\n      10,\n      3,\n      12,\n      6,\n      11,\n      3,\n      7,\n      0,\n      13,\n      5,\n      10,\n      14,\n      15,\n      8,\n      12,\n      4,\n      9,\n      1,\n      2,\n      15,\n      5,\n      1,\n      3,\n      7,\n      14,\n      6,\n      9,\n      11,\n      8,\n      12,\n      2,\n      10,\n      0,\n      4,\n      13,\n      8,\n      6,\n      4,\n      1,\n      3,\n      11,\n      15,\n      0,\n      5,\n      12,\n      2,\n      13,\n      9,\n      7,\n      10,\n      14,\n      12,\n      15,\n      10,\n      4,\n      1,\n      5,\n      8,\n      7,\n      6,\n      2,\n      13,\n      14,\n      0,\n      3,\n      9,\n      11\n    ], sl = [\n      11,\n      14,\n      15,\n      12,\n      5,\n      8,\n      7,\n      9,\n      11,\n      13,\n      14,\n      15,\n      6,\n      7,\n      9,\n      8,\n      7,\n      6,\n      8,\n      13,\n      11,\n      9,\n      7,\n      15,\n      7,\n      12,\n      15,\n      9,\n      11,\n      7,\n      13,\n      12,\n      11,\n      13,\n      6,\n      7,\n      14,\n      9,\n      13,\n      15,\n      14,\n      8,\n      13,\n      6,\n      5,\n      12,\n      7,\n      5,\n      11,\n      12,\n      14,\n      15,\n      14,\n      15,\n      9,\n      8,\n      9,\n      14,\n      5,\n      6,\n      8,\n      6,\n      5,\n      12,\n      9,\n      15,\n      5,\n      11,\n      6,\n      8,\n      13,\n      12,\n      5,\n      12,\n      13,\n      14,\n      11,\n      8,\n      5,\n      6\n    ], sr = [\n      8,\n      9,\n      9,\n      11,\n      13,\n      15,\n      15,\n      5,\n      7,\n      7,\n      8,\n      11,\n      14,\n      14,\n      12,\n      6,\n      9,\n      13,\n      15,\n      7,\n      12,\n      8,\n      9,\n      11,\n      7,\n      7,\n      12,\n      7,\n      6,\n      15,\n      13,\n      11,\n      9,\n      7,\n      15,\n      11,\n      8,\n      6,\n      6,\n      14,\n      12,\n      13,\n      5,\n      14,\n      13,\n      13,\n      7,\n      5,\n      15,\n      5,\n      8,\n      11,\n      14,\n      14,\n      6,\n      14,\n      6,\n      9,\n      12,\n      9,\n      12,\n      5,\n      15,\n      8,\n      8,\n      5,\n      12,\n      9,\n      12,\n      5,\n      14,\n      6,\n      8,\n      13,\n      6,\n      5,\n      15,\n      13,\n      11,\n      11\n    ], hl = [0, 1518500249, 1859775393, 2400959708, 2840853838], hr = [1352829926, 1548603684, 1836072691, 2053994217, 0];\n    function RIPEMD160() {\n      HashBase.call(this, 64), this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520;\n    }\n    inherits(RIPEMD160, HashBase), RIPEMD160.prototype._update = function() {\n      for (var words = ARRAY16, j = 0;j < 16; ++j)\n        words[j] = this._block.readInt32LE(j * 4);\n      for (var al = this._a | 0, bl = this._b | 0, cl = this._c | 0, dl = this._d | 0, el = this._e | 0, ar = this._a | 0, br = this._b | 0, cr = this._c | 0, dr = this._d | 0, er = this._e | 0, i = 0;i < 80; i += 1) {\n        var tl, tr;\n        i < 16 \? (tl = fn1(al, bl, cl, dl, el, words[zl[i]], hl[0], sl[i]), tr = fn5(ar, br, cr, dr, er, words[zr[i]], hr[0], sr[i])) : i < 32 \? (tl = fn2(al, bl, cl, dl, el, words[zl[i]], hl[1], sl[i]), tr = fn4(ar, br, cr, dr, er, words[zr[i]], hr[1], sr[i])) : i < 48 \? (tl = fn3(al, bl, cl, dl, el, words[zl[i]], hl[2], sl[i]), tr = fn3(ar, br, cr, dr, er, words[zr[i]], hr[2], sr[i])) : i < 64 \? (tl = fn4(al, bl, cl, dl, el, words[zl[i]], hl[3], sl[i]), tr = fn2(ar, br, cr, dr, er, words[zr[i]], hr[3], sr[i])) : (tl = fn5(al, bl, cl, dl, el, words[zl[i]], hl[4], sl[i]), tr = fn1(ar, br, cr, dr, er, words[zr[i]], hr[4], sr[i])), al = el, el = dl, dl = rotl(cl, 10), cl = bl, bl = tl, ar = er, er = dr, dr = rotl(cr, 10), cr = br, br = tr;\n      }\n      var t = this._b + cl + dr | 0;\n      this._b = this._c + dl + er | 0, this._c = this._d + el + ar | 0, this._d = this._e + al + br | 0, this._e = this._a + bl + cr | 0, this._a = t;\n    }, RIPEMD160.prototype._digest = function() {\n      this._block[this._blockOffset++] = 128, this._blockOffset > 56 && (this._block.fill(0, this._blockOffset, 64), this._update(), this._blockOffset = 0), this._block.fill(0, this._blockOffset, 56), this._block.writeUInt32LE(this._length[0], 56), this._block.writeUInt32LE(this._length[1], 60), this._update();\n      var buffer = Buffer2.alloc \? Buffer2.alloc(20) : new Buffer2(20);\n      return buffer.writeInt32LE(this._a, 0), buffer.writeInt32LE(this._b, 4), buffer.writeInt32LE(this._c, 8), buffer.writeInt32LE(this._d, 12), buffer.writeInt32LE(this._e, 16), buffer;\n    };\n    function rotl(x, n) {\n      return x << n | x >>> 32 - n;\n    }\n    function fn1(a, b, c, d, e, m, k, s) {\n      return rotl(a + (b ^ c ^ d) + m + k | 0, s) + e | 0;\n    }\n    function fn2(a, b, c, d, e, m, k, s) {\n      return rotl(a + (b & c | ~b & d) + m + k | 0, s) + e | 0;\n    }\n    function fn3(a, b, c, d, e, m, k, s) {\n      return rotl(a + ((b | ~c) ^ d) + m + k | 0, s) + e | 0;\n    }\n    function fn4(a, b, c, d, e, m, k, s) {\n      return rotl(a + (b & d | c & ~d) + m + k | 0, s) + e | 0;\n    }\n    function fn5(a, b, c, d, e, m, k, s) {\n      return rotl(a + (b ^ (c | ~d)) + m + k | 0, s) + e | 0;\n    }\n    module.exports = RIPEMD160;\n  }\n}), require_hash = __commonJS({\n  \"node_modules/sha.js/hash.js\"(exports, module) {\n    var Buffer2 = require_safe_buffer().Buffer;\n    function Hash(blockSize, finalSize) {\n      this._block = Buffer2.alloc(blockSize), this._finalSize = finalSize, this._blockSize = blockSize, this._len = 0;\n    }\n    Hash.prototype = {}, Hash.prototype.update = function(data, enc) {\n      typeof data == \"string\" && (enc = enc || \"utf8\", data = Buffer2.from(data, enc));\n      for (var block = this._block, blockSize = this._blockSize, length = data.length, accum = this._len, offset = 0;offset < length; ) {\n        for (var assigned = accum % blockSize, remainder = Math.min(length - offset, blockSize - assigned), i = 0;i < remainder; i++)\n          block[assigned + i] = data[offset + i];\n        accum += remainder, offset += remainder, accum % blockSize === 0 && this._update(block);\n      }\n      return this._len += length, this;\n    }, Hash.prototype.digest = function(enc) {\n      var rem = this._len % this._blockSize;\n      this._block[rem] = 128, this._block.fill(0, rem + 1), rem >= this._finalSize && (this._update(this._block), this._block.fill(0));\n      var bits = this._len * 8;\n      if (bits <= 4294967295)\n        this._block.writeUInt32BE(bits, this._blockSize - 4);\n      else {\n        var lowBits = (bits & 4294967295) >>> 0, highBits = (bits - lowBits) / 4294967296;\n        this._block.writeUInt32BE(highBits, this._blockSize - 8), this._block.writeUInt32BE(lowBits, this._blockSize - 4);\n      }\n      this._update(this._block);\n      var hash = this._hash();\n      return enc \? hash.toString(enc) : hash;\n    }, Hash.prototype._update = function() {\n      throw new Error(\"_update must be implemented by subclass\");\n    }, module.exports = Hash;\n  }\n}), require_sha = __commonJS({\n  \"node_modules/sha.js/sha.js\"(exports, module) {\n    var inherits = require_inherits_browser(), Hash = require_hash(), Buffer2 = require_safe_buffer().Buffer, K = [1518500249, 1859775393, -1894007588, -899497514], W = new Array(80);\n    function Sha() {\n      this.init(), this._w = W, Hash.call(this, 64, 56);\n    }\n    inherits(Sha, Hash), Sha.prototype.init = function() {\n      return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this;\n    };\n    function rotl5(num) {\n      return num << 5 | num >>> 27;\n    }\n    function rotl30(num) {\n      return num << 30 | num >>> 2;\n    }\n    function ft(s, b, c, d) {\n      return s === 0 \? b & c | ~b & d : s === 2 \? b & c | b & d | c & d : b ^ c ^ d;\n    }\n    Sha.prototype._update = function(M) {\n      for (var W2 = this._w, a = this._a | 0, b = this._b | 0, c = this._c | 0, d = this._d | 0, e = this._e | 0, i = 0;i < 16; ++i)\n        W2[i] = M.readInt32BE(i * 4);\n      for (;i < 80; ++i)\n        W2[i] = W2[i - 3] ^ W2[i - 8] ^ W2[i - 14] ^ W2[i - 16];\n      for (var j = 0;j < 80; ++j) {\n        var s = ~~(j / 20), t = rotl5(a) + ft(s, b, c, d) + e + W2[j] + K[s] | 0;\n        e = d, d = c, c = rotl30(b), b = a, a = t;\n      }\n      this._a = a + this._a | 0, this._b = b + this._b | 0, this._c = c + this._c | 0, this._d = d + this._d | 0, this._e = e + this._e | 0;\n    }, Sha.prototype._hash = function() {\n      var H = Buffer2.allocUnsafe(20);\n      return H.writeInt32BE(this._a | 0, 0), H.writeInt32BE(this._b | 0, 4), H.writeInt32BE(this._c | 0, 8), H.writeInt32BE(this._d | 0, 12), H.writeInt32BE(this._e | 0, 16), H;\n    }, module.exports = Sha;\n  }\n}), require_sha1 = __commonJS({\n  \"node_modules/sha.js/sha1.js\"(exports, module) {\n    var inherits = require_inherits_browser(), Hash = require_hash(), Buffer2 = require_safe_buffer().Buffer, K = [1518500249, 1859775393, -1894007588, -899497514], W = new Array(80);\n    function Sha1() {\n      this.init(), this._w = W, Hash.call(this, 64, 56);\n    }\n    inherits(Sha1, Hash), Sha1.prototype.init = function() {\n      return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this;\n    };\n    function rotl1(num) {\n      return num << 1 | num >>> 31;\n    }\n    function rotl5(num) {\n      return num << 5 | num >>> 27;\n    }\n    function rotl30(num) {\n      return num << 30 | num >>> 2;\n    }\n    function ft(s, b, c, d) {\n      return s === 0 \? b & c | ~b & d : s === 2 \? b & c | b & d | c & d : b ^ c ^ d;\n    }\n    Sha1.prototype._update = function(M) {\n      for (var W2 = this._w, a = this._a | 0, b = this._b | 0, c = this._c | 0, d = this._d | 0, e = this._e | 0, i = 0;i < 16; ++i)\n        W2[i] = M.readInt32BE(i * 4);\n      for (;i < 80; ++i)\n        W2[i] = rotl1(W2[i - 3] ^ W2[i - 8] ^ W2[i - 14] ^ W2[i - 16]);\n      for (var j = 0;j < 80; ++j) {\n        var s = ~~(j / 20), t = rotl5(a) + ft(s, b, c, d) + e + W2[j] + K[s] | 0;\n        e = d, d = c, c = rotl30(b), b = a, a = t;\n      }\n      this._a = a + this._a | 0, this._b = b + this._b | 0, this._c = c + this._c | 0, this._d = d + this._d | 0, this._e = e + this._e | 0;\n    }, Sha1.prototype._hash = function() {\n      var H = Buffer2.allocUnsafe(20);\n      return H.writeInt32BE(this._a | 0, 0), H.writeInt32BE(this._b | 0, 4), H.writeInt32BE(this._c | 0, 8), H.writeInt32BE(this._d | 0, 12), H.writeInt32BE(this._e | 0, 16), H;\n    }, module.exports = Sha1;\n  }\n}), require_sha256 = __commonJS({\n  \"node_modules/sha.js/sha256.js\"(exports, module) {\n    var inherits = require_inherits_browser(), Hash = require_hash(), Buffer2 = require_safe_buffer().Buffer, K = [\n      1116352408,\n      1899447441,\n      3049323471,\n      3921009573,\n      961987163,\n      1508970993,\n      2453635748,\n      2870763221,\n      3624381080,\n      310598401,\n      607225278,\n      1426881987,\n      1925078388,\n      2162078206,\n      2614888103,\n      3248222580,\n      3835390401,\n      4022224774,\n      264347078,\n      604807628,\n      770255983,\n      1249150122,\n      1555081692,\n      1996064986,\n      2554220882,\n      2821834349,\n      2952996808,\n      3210313671,\n      3336571891,\n      3584528711,\n      113926993,\n      338241895,\n      666307205,\n      773529912,\n      1294757372,\n      1396182291,\n      1695183700,\n      1986661051,\n      2177026350,\n      2456956037,\n      2730485921,\n      2820302411,\n      3259730800,\n      3345764771,\n      3516065817,\n      3600352804,\n      4094571909,\n      275423344,\n      430227734,\n      506948616,\n      659060556,\n      883997877,\n      958139571,\n      1322822218,\n      1537002063,\n      1747873779,\n      1955562222,\n      2024104815,\n      2227730452,\n      2361852424,\n      2428436474,\n      2756734187,\n      3204031479,\n      3329325298\n    ], W = new Array(64);\n    function Sha256() {\n      this.init(), this._w = W, Hash.call(this, 64, 56);\n    }\n    inherits(Sha256, Hash), Sha256.prototype.init = function() {\n      return this._a = 1779033703, this._b = 3144134277, this._c = 1013904242, this._d = 2773480762, this._e = 1359893119, this._f = 2600822924, this._g = 528734635, this._h = 1541459225, this;\n    };\n    function ch(x, y, z) {\n      return z ^ x & (y ^ z);\n    }\n    function maj(x, y, z) {\n      return x & y | z & (x | y);\n    }\n    function sigma0(x) {\n      return (x >>> 2 | x << 30) ^ (x >>> 13 | x << 19) ^ (x >>> 22 | x << 10);\n    }\n    function sigma1(x) {\n      return (x >>> 6 | x << 26) ^ (x >>> 11 | x << 21) ^ (x >>> 25 | x << 7);\n    }\n    function gamma0(x) {\n      return (x >>> 7 | x << 25) ^ (x >>> 18 | x << 14) ^ x >>> 3;\n    }\n    function gamma1(x) {\n      return (x >>> 17 | x << 15) ^ (x >>> 19 | x << 13) ^ x >>> 10;\n    }\n    Sha256.prototype._update = function(M) {\n      for (var W2 = this._w, a = this._a | 0, b = this._b | 0, c = this._c | 0, d = this._d | 0, e = this._e | 0, f = this._f | 0, g = this._g | 0, h = this._h | 0, i = 0;i < 16; ++i)\n        W2[i] = M.readInt32BE(i * 4);\n      for (;i < 64; ++i)\n        W2[i] = gamma1(W2[i - 2]) + W2[i - 7] + gamma0(W2[i - 15]) + W2[i - 16] | 0;\n      for (var j = 0;j < 64; ++j) {\n        var T1 = h + sigma1(e) + ch(e, f, g) + K[j] + W2[j] | 0, T2 = sigma0(a) + maj(a, b, c) | 0;\n        h = g, g = f, f = e, e = d + T1 | 0, d = c, c = b, b = a, a = T1 + T2 | 0;\n      }\n      this._a = a + this._a | 0, this._b = b + this._b | 0, this._c = c + this._c | 0, this._d = d + this._d | 0, this._e = e + this._e | 0, this._f = f + this._f | 0, this._g = g + this._g | 0, this._h = h + this._h | 0;\n    }, Sha256.prototype._hash = function() {\n      var H = Buffer2.allocUnsafe(32);\n      return H.writeInt32BE(this._a, 0), H.writeInt32BE(this._b, 4), H.writeInt32BE(this._c, 8), H.writeInt32BE(this._d, 12), H.writeInt32BE(this._e, 16), H.writeInt32BE(this._f, 20), H.writeInt32BE(this._g, 24), H.writeInt32BE(this._h, 28), H;\n    }, module.exports = Sha256;\n  }\n}), require_sha224 = __commonJS({\n  \"node_modules/sha.js/sha224.js\"(exports, module) {\n    var inherits = require_inherits_browser(), Sha256 = require_sha256(), Hash = require_hash(), Buffer2 = require_safe_buffer().Buffer, W = new Array(64);\n    function Sha224() {\n      this.init(), this._w = W, Hash.call(this, 64, 56);\n    }\n    inherits(Sha224, Sha256), Sha224.prototype.init = function() {\n      return this._a = 3238371032, this._b = 914150663, this._c = 812702999, this._d = 4144912697, this._e = 4290775857, this._f = 1750603025, this._g = 1694076839, this._h = 3204075428, this;\n    }, Sha224.prototype._hash = function() {\n      var H = Buffer2.allocUnsafe(28);\n      return H.writeInt32BE(this._a, 0), H.writeInt32BE(this._b, 4), H.writeInt32BE(this._c, 8), H.writeInt32BE(this._d, 12), H.writeInt32BE(this._e, 16), H.writeInt32BE(this._f, 20), H.writeInt32BE(this._g, 24), H;\n    }, module.exports = Sha224;\n  }\n}), require_sha512 = __commonJS({\n  \"node_modules/sha.js/sha512.js\"(exports, module) {\n    var inherits = require_inherits_browser(), Hash = require_hash(), Buffer2 = require_safe_buffer().Buffer, K = [\n      1116352408,\n      3609767458,\n      1899447441,\n      602891725,\n      3049323471,\n      3964484399,\n      3921009573,\n      2173295548,\n      961987163,\n      4081628472,\n      1508970993,\n      3053834265,\n      2453635748,\n      2937671579,\n      2870763221,\n      3664609560,\n      3624381080,\n      2734883394,\n      310598401,\n      1164996542,\n      607225278,\n      1323610764,\n      1426881987,\n      3590304994,\n      1925078388,\n      4068182383,\n      2162078206,\n      991336113,\n      2614888103,\n      633803317,\n      3248222580,\n      3479774868,\n      3835390401,\n      2666613458,\n      4022224774,\n      944711139,\n      264347078,\n      2341262773,\n      604807628,\n      2007800933,\n      770255983,\n      1495990901,\n      1249150122,\n      1856431235,\n      1555081692,\n      3175218132,\n      1996064986,\n      2198950837,\n      2554220882,\n      3999719339,\n      2821834349,\n      766784016,\n      2952996808,\n      2566594879,\n      3210313671,\n      3203337956,\n      3336571891,\n      1034457026,\n      3584528711,\n      2466948901,\n      113926993,\n      3758326383,\n      338241895,\n      168717936,\n      666307205,\n      1188179964,\n      773529912,\n      1546045734,\n      1294757372,\n      1522805485,\n      1396182291,\n      2643833823,\n      1695183700,\n      2343527390,\n      1986661051,\n      1014477480,\n      2177026350,\n      1206759142,\n      2456956037,\n      344077627,\n      2730485921,\n      1290863460,\n      2820302411,\n      3158454273,\n      3259730800,\n      3505952657,\n      3345764771,\n      106217008,\n      3516065817,\n      3606008344,\n      3600352804,\n      1432725776,\n      4094571909,\n      1467031594,\n      275423344,\n      851169720,\n      430227734,\n      3100823752,\n      506948616,\n      1363258195,\n      659060556,\n      3750685593,\n      883997877,\n      3785050280,\n      958139571,\n      3318307427,\n      1322822218,\n      3812723403,\n      1537002063,\n      2003034995,\n      1747873779,\n      3602036899,\n      1955562222,\n      1575990012,\n      2024104815,\n      1125592928,\n      2227730452,\n      2716904306,\n      2361852424,\n      442776044,\n      2428436474,\n      593698344,\n      2756734187,\n      3733110249,\n      3204031479,\n      2999351573,\n      3329325298,\n      3815920427,\n      3391569614,\n      3928383900,\n      3515267271,\n      566280711,\n      3940187606,\n      3454069534,\n      4118630271,\n      4000239992,\n      116418474,\n      1914138554,\n      174292421,\n      2731055270,\n      289380356,\n      3203993006,\n      460393269,\n      320620315,\n      685471733,\n      587496836,\n      852142971,\n      1086792851,\n      1017036298,\n      365543100,\n      1126000580,\n      2618297676,\n      1288033470,\n      3409855158,\n      1501505948,\n      4234509866,\n      1607167915,\n      987167468,\n      1816402316,\n      1246189591\n    ], W = new Array(160);\n    function Sha512() {\n      this.init(), this._w = W, Hash.call(this, 128, 112);\n    }\n    inherits(Sha512, Hash), Sha512.prototype.init = function() {\n      return this._ah = 1779033703, this._bh = 3144134277, this._ch = 1013904242, this._dh = 2773480762, this._eh = 1359893119, this._fh = 2600822924, this._gh = 528734635, this._hh = 1541459225, this._al = 4089235720, this._bl = 2227873595, this._cl = 4271175723, this._dl = 1595750129, this._el = 2917565137, this._fl = 725511199, this._gl = 4215389547, this._hl = 327033209, this;\n    };\n    function Ch(x, y, z) {\n      return z ^ x & (y ^ z);\n    }\n    function maj(x, y, z) {\n      return x & y | z & (x | y);\n    }\n    function sigma0(x, xl) {\n      return (x >>> 28 | xl << 4) ^ (xl >>> 2 | x << 30) ^ (xl >>> 7 | x << 25);\n    }\n    function sigma1(x, xl) {\n      return (x >>> 14 | xl << 18) ^ (x >>> 18 | xl << 14) ^ (xl >>> 9 | x << 23);\n    }\n    function Gamma0(x, xl) {\n      return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ x >>> 7;\n    }\n    function Gamma0l(x, xl) {\n      return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ (x >>> 7 | xl << 25);\n    }\n    function Gamma1(x, xl) {\n      return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ x >>> 6;\n    }\n    function Gamma1l(x, xl) {\n      return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ (x >>> 6 | xl << 26);\n    }\n    function getCarry(a, b) {\n      return a >>> 0 < b >>> 0 \? 1 : 0;\n    }\n    Sha512.prototype._update = function(M) {\n      for (var W2 = this._w, ah = this._ah | 0, bh = this._bh | 0, ch = this._ch | 0, dh = this._dh | 0, eh = this._eh | 0, fh = this._fh | 0, gh = this._gh | 0, hh = this._hh | 0, al = this._al | 0, bl = this._bl | 0, cl = this._cl | 0, dl = this._dl | 0, el = this._el | 0, fl = this._fl | 0, gl = this._gl | 0, hl = this._hl | 0, i = 0;i < 32; i += 2)\n        W2[i] = M.readInt32BE(i * 4), W2[i + 1] = M.readInt32BE(i * 4 + 4);\n      for (;i < 160; i += 2) {\n        var xh = W2[i - 30], xl = W2[i - 30 + 1], gamma0 = Gamma0(xh, xl), gamma0l = Gamma0l(xl, xh);\n        xh = W2[i - 4], xl = W2[i - 4 + 1];\n        var gamma1 = Gamma1(xh, xl), gamma1l = Gamma1l(xl, xh), Wi7h = W2[i - 14], Wi7l = W2[i - 14 + 1], Wi16h = W2[i - 32], Wi16l = W2[i - 32 + 1], Wil = gamma0l + Wi7l | 0, Wih = gamma0 + Wi7h + getCarry(Wil, gamma0l) | 0;\n        Wil = Wil + gamma1l | 0, Wih = Wih + gamma1 + getCarry(Wil, gamma1l) | 0, Wil = Wil + Wi16l | 0, Wih = Wih + Wi16h + getCarry(Wil, Wi16l) | 0, W2[i] = Wih, W2[i + 1] = Wil;\n      }\n      for (var j = 0;j < 160; j += 2) {\n        Wih = W2[j], Wil = W2[j + 1];\n        var majh = maj(ah, bh, ch), majl = maj(al, bl, cl), sigma0h = sigma0(ah, al), sigma0l = sigma0(al, ah), sigma1h = sigma1(eh, el), sigma1l = sigma1(el, eh), Kih = K[j], Kil = K[j + 1], chh = Ch(eh, fh, gh), chl = Ch(el, fl, gl), t1l = hl + sigma1l | 0, t1h = hh + sigma1h + getCarry(t1l, hl) | 0;\n        t1l = t1l + chl | 0, t1h = t1h + chh + getCarry(t1l, chl) | 0, t1l = t1l + Kil | 0, t1h = t1h + Kih + getCarry(t1l, Kil) | 0, t1l = t1l + Wil | 0, t1h = t1h + Wih + getCarry(t1l, Wil) | 0;\n        var t2l = sigma0l + majl | 0, t2h = sigma0h + majh + getCarry(t2l, sigma0l) | 0;\n        hh = gh, hl = gl, gh = fh, gl = fl, fh = eh, fl = el, el = dl + t1l | 0, eh = dh + t1h + getCarry(el, dl) | 0, dh = ch, dl = cl, ch = bh, cl = bl, bh = ah, bl = al, al = t1l + t2l | 0, ah = t1h + t2h + getCarry(al, t1l) | 0;\n      }\n      this._al = this._al + al | 0, this._bl = this._bl + bl | 0, this._cl = this._cl + cl | 0, this._dl = this._dl + dl | 0, this._el = this._el + el | 0, this._fl = this._fl + fl | 0, this._gl = this._gl + gl | 0, this._hl = this._hl + hl | 0, this._ah = this._ah + ah + getCarry(this._al, al) | 0, this._bh = this._bh + bh + getCarry(this._bl, bl) | 0, this._ch = this._ch + ch + getCarry(this._cl, cl) | 0, this._dh = this._dh + dh + getCarry(this._dl, dl) | 0, this._eh = this._eh + eh + getCarry(this._el, el) | 0, this._fh = this._fh + fh + getCarry(this._fl, fl) | 0, this._gh = this._gh + gh + getCarry(this._gl, gl) | 0, this._hh = this._hh + hh + getCarry(this._hl, hl) | 0;\n    }, Sha512.prototype._hash = function() {\n      var H = Buffer2.allocUnsafe(64);\n      function writeInt64BE(h, l, offset) {\n        H.writeInt32BE(h, offset), H.writeInt32BE(l, offset + 4);\n      }\n      return writeInt64BE(this._ah, this._al, 0), writeInt64BE(this._bh, this._bl, 8), writeInt64BE(this._ch, this._cl, 16), writeInt64BE(this._dh, this._dl, 24), writeInt64BE(this._eh, this._el, 32), writeInt64BE(this._fh, this._fl, 40), writeInt64BE(this._gh, this._gl, 48), writeInt64BE(this._hh, this._hl, 56), H;\n    }, module.exports = Sha512;\n  }\n}), require_sha384 = __commonJS({\n  \"node_modules/sha.js/sha384.js\"(exports, module) {\n    var inherits = require_inherits_browser(), SHA512 = require_sha512(), Hash = require_hash(), Buffer2 = require_safe_buffer().Buffer, W = new Array(160);\n    function Sha384() {\n      this.init(), this._w = W, Hash.call(this, 128, 112);\n    }\n    inherits(Sha384, SHA512), Sha384.prototype.init = function() {\n      return this._ah = 3418070365, this._bh = 1654270250, this._ch = 2438529370, this._dh = 355462360, this._eh = 1731405415, this._fh = 2394180231, this._gh = 3675008525, this._hh = 1203062813, this._al = 3238371032, this._bl = 914150663, this._cl = 812702999, this._dl = 4144912697, this._el = 4290775857, this._fl = 1750603025, this._gl = 1694076839, this._hl = 3204075428, this;\n    }, Sha384.prototype._hash = function() {\n      var H = Buffer2.allocUnsafe(48);\n      function writeInt64BE(h, l, offset) {\n        H.writeInt32BE(h, offset), H.writeInt32BE(l, offset + 4);\n      }\n      return writeInt64BE(this._ah, this._al, 0), writeInt64BE(this._bh, this._bl, 8), writeInt64BE(this._ch, this._cl, 16), writeInt64BE(this._dh, this._dl, 24), writeInt64BE(this._eh, this._el, 32), writeInt64BE(this._fh, this._fl, 40), H;\n    }, module.exports = Sha384;\n  }\n}), require_sha2 = __commonJS({\n  \"node_modules/sha.js/index.js\"(exports, module) {\n    var exports = module.exports = function(algorithm) {\n      algorithm = algorithm.toLowerCase();\n      var Algorithm = exports[algorithm];\n      if (!Algorithm)\n        throw new Error(algorithm + \" is not supported (we accept pull requests)\");\n      return new Algorithm;\n    };\n    exports.sha = require_sha(), exports.sha1 = require_sha1(), exports.sha224 = require_sha224(), exports.sha256 = require_sha256(), exports.sha384 = require_sha384(), exports.sha512 = require_sha512();\n  }\n}), require_cipher_base = __commonJS({\n  \"node_modules/cipher-base/index.js\"(exports, module) {\n    var Buffer2 = require_safe_buffer().Buffer, inherits = require_inherits_browser();\n    function CipherBase(hashMode) {\n      StreamModule.Transform.call(this), this.hashMode = typeof hashMode == \"string\", this.hashMode \? this[hashMode] = this._finalOrDigest : this.final = this._finalOrDigest, this._final && (this.__final = this._final, this._final = null), this._decoder = null, this._encoding = null;\n    }\n    inherits(CipherBase, StreamModule.Transform), CipherBase.prototype.update = function(data, inputEnc, outputEnc) {\n      typeof data == \"string\" && (data = Buffer2.from(data, inputEnc));\n      var outData = this._update(data);\n      return this.hashMode \? this : (outputEnc && (outData = this._toString(outData, outputEnc)), outData);\n    }, CipherBase.prototype.setAutoPadding = function() {\n    }, CipherBase.prototype.getAuthTag = function() {\n      throw new Error(\"trying to get auth tag in unsupported state\");\n    }, CipherBase.prototype.setAuthTag = function() {\n      throw new Error(\"trying to set auth tag in unsupported state\");\n    }, CipherBase.prototype.setAAD = function() {\n      throw new Error(\"trying to set aad in unsupported state\");\n    }, CipherBase.prototype._transform = function(data, _, next) {\n      var err;\n      try {\n        this.hashMode \? this._update(data) : this.push(this._update(data));\n      } catch (e) {\n        err = e;\n      } finally {\n        next(err);\n      }\n    }, CipherBase.prototype._flush = function(done) {\n      var err;\n      try {\n        this.push(this.__final());\n      } catch (e) {\n        err = e;\n      }\n      done(err);\n    }, CipherBase.prototype._finalOrDigest = function(outputEnc) {\n      var outData = this.__final() || Buffer2.alloc(0);\n      return outputEnc && (outData = this._toString(outData, outputEnc, !0)), outData;\n    }, CipherBase.prototype._toString = function(value, enc, fin) {\n      if (this._decoder || (this._decoder = new StringDecoder(enc), this._encoding = enc), this._encoding !== enc)\n        throw new Error(\"can't switch encodings\");\n      var out = this._decoder.write(value);\n      return fin && (out += this._decoder.end()), out;\n    }, module.exports = CipherBase;\n  }\n}), require_browser2 = __commonJS({\n  \"node_modules/create-hash/browser.js\"(exports, module) {\n    const LazyHash = function Hash(algorithm, options) {\n      this._options = options, this._hasher = new CryptoHasher(algorithm, options), this._finalized = !1;\n    };\n    LazyHash.prototype = Object.create(StreamModule.Transform.prototype), LazyHash.prototype.update = function update(data, encoding) {\n      return this._checkFinalized(), this._hasher.update(data, encoding), this;\n    }, LazyHash.prototype.digest = function update(data, encoding) {\n      return this._checkFinalized(), this._finalized = !0, this._hasher.digest(data, encoding);\n    }, LazyHash.prototype._checkFinalized = function _checkFinalized() {\n      if (this._finalized) {\n        var err = new Error(\"Digest already called\");\n        throw err.code = \"ERR_CRYPTO_HASH_FINALIZED\", err;\n      }\n    }, LazyHash.prototype.copy = function copy() {\n      const copy = Object.create(LazyHash.prototype);\n      return copy._options = this._options, copy._hasher = this._hasher.copy(), copy._finalized = this._finalized, copy;\n    };\n    const lazyHashFullInitProto = {\n      __proto__: StreamModule.Transform.prototype,\n      ...LazyHash.prototype,\n      _transform(data, encoding, callback) {\n        this.update(data, encoding), callback && callback();\n      },\n      _flush(callback) {\n        this.push(this.digest()), callback();\n      }\n    }, triggerMethods = [\n      \"_events\",\n      \"_eventsCount\",\n      \"_final\",\n      \"_maxListeners\",\n      \"_maxListeners\",\n      \"_read\",\n      \"_undestroy\",\n      \"_writableState\",\n      \"_write\",\n      \"_writev\",\n      \"addListener\",\n      \"asIndexedPairs\",\n      \"closed\",\n      \"compose\",\n      \"constructor\",\n      \"cork\",\n      \"destroy\",\n      \"destroyed\",\n      \"drop\",\n      \"emit\",\n      \"end\",\n      \"errored\",\n      \"eventNames\",\n      \"every\",\n      \"filter\",\n      \"find\",\n      \"flatMap\",\n      \"forEach\",\n      \"getMaxListeners\",\n      \"hasOwnProperty\",\n      \"isPaused\",\n      \"isPrototypeOf\",\n      \"iterator\",\n      \"listenerCount\",\n      \"listeners\",\n      \"map\",\n      \"off\",\n      \"on\",\n      \"once\",\n      \"pause\",\n      \"pipe\",\n      \"prependListener\",\n      \"prependOnceListener\",\n      \"propertyIsEnumerable\",\n      \"push\",\n      \"rawListeners\",\n      \"read\",\n      \"readable\",\n      \"readableAborted\",\n      \"readableBuffer\",\n      \"readableDidRead\",\n      \"readableEncoding\",\n      \"readableEnded\",\n      \"readableFlowing\",\n      \"readableHighWaterMark\",\n      \"readableLength\",\n      \"readableObjectMode\",\n      \"reduce\",\n      \"removeAllListeners\",\n      \"removeListener\",\n      \"resume\",\n      \"setDefaultEncoding\",\n      \"setEncoding\",\n      \"setMaxListeners\",\n      \"some\",\n      \"take\",\n      \"toArray\",\n      \"toLocaleString\",\n      \"toString\",\n      \"uncork\",\n      \"unpipe\",\n      \"unshift\",\n      \"valueOf\",\n      \"wrap\",\n      \"writable\",\n      \"writableBuffer\",\n      \"writableCorked\",\n      \"writableEnded\",\n      \"writableFinished\",\n      \"writableHighWaterMark\",\n      \"writableLength\",\n      \"writableNeedDrain\",\n      \"writableObjectMode\",\n      \"write\"\n    ];\n    for (let method of triggerMethods)\n      Object.defineProperty(LazyHash.prototype, method, {\n        get() {\n          return Object.setPrototypeOf(this, lazyHashFullInitProto), StreamModule.Transform.call(this, this._options), this[method];\n        },\n        enumerable: !1,\n        configurable: !0\n      });\n    module.exports = function createHash(algorithm) {\n      return new LazyHash(algorithm);\n    }, module.exports.createHash = module.exports, module.exports.Hash = LazyHash;\n  }\n}), require_legacy = __commonJS({\n  \"node_modules/create-hmac/legacy.js\"(exports, module) {\n    var inherits = require_inherits_browser(), Buffer2 = require_safe_buffer().Buffer, Base = require_cipher_base(), ZEROS = Buffer2.alloc(128), blocksize = 64;\n    function Hmac(alg, key) {\n      Base.call(this, \"digest\"), typeof key == \"string\" && (key = Buffer2.from(key)), this._alg = alg, this._key = key, key.length > blocksize \? key = alg(key) : key.length < blocksize && (key = Buffer2.concat([key, ZEROS], blocksize));\n      for (var ipad = this._ipad = Buffer2.allocUnsafe(blocksize), opad = this._opad = Buffer2.allocUnsafe(blocksize), i = 0;i < blocksize; i++)\n        ipad[i] = key[i] ^ 54, opad[i] = key[i] ^ 92;\n      this._hash = [ipad];\n    }\n    Hmac.prototype = {}, inherits(Hmac, Base), Hmac.prototype._update = function(data) {\n      this._hash.push(data);\n    }, Hmac.prototype._final = function() {\n      var h = this._alg(Buffer2.concat(this._hash));\n      return this._alg(Buffer2.concat([this._opad, h]));\n    }, module.exports = Hmac;\n  }\n}), require_md52 = __commonJS({\n  \"node_modules/create-hash/md5.js\"(exports, module) {\n    var MD5 = require_md5();\n    module.exports = function(buffer) {\n      return new MD5().update(buffer).digest();\n    };\n  }\n}), require_browser3 = __commonJS({\n  \"node_modules/create-hmac/browser.js\"(exports, module) {\n    var inherits = require_inherits_browser(), Legacy = require_legacy(), Base = require_cipher_base(), Buffer2 = require_safe_buffer().Buffer, md5 = require_md52(), RIPEMD160 = require_ripemd160(), sha = require_sha2(), ZEROS = Buffer2.alloc(128);\n    function Hmac(alg, key) {\n      Base.call(this, \"digest\"), typeof key == \"string\" && (key = Buffer2.from(key));\n      var blocksize = alg === \"sha512\" || alg === \"sha384\" \? 128 : 64;\n      if (this._alg = alg, this._key = key, key.length > blocksize) {\n        var hash = alg === \"rmd160\" \? new RIPEMD160 : sha(alg);\n        key = hash.update(key).digest();\n      } else\n        key.length < blocksize && (key = Buffer2.concat([key, ZEROS], blocksize));\n      for (var ipad = this._ipad = Buffer2.allocUnsafe(blocksize), opad = this._opad = Buffer2.allocUnsafe(blocksize), i = 0;i < blocksize; i++)\n        ipad[i] = key[i] ^ 54, opad[i] = key[i] ^ 92;\n      this._hash = alg === \"rmd160\" \? new RIPEMD160 : sha(alg), this._hash.update(ipad);\n    }\n    inherits(Hmac, Base), Hmac.prototype._update = function(data) {\n      this._hash.update(data);\n    }, Hmac.prototype._final = function() {\n      var h = this._hash.digest(), hash = this._alg === \"rmd160\" \? new RIPEMD160 : sha(this._alg);\n      return hash.update(this._opad).update(h).digest();\n    }, module.exports = function(alg, key) {\n      return alg = alg.toLowerCase(), alg === \"rmd160\" || alg === \"ripemd160\" \? new Hmac(\"rmd160\", key) : alg === \"md5\" \? new Legacy(md5, key) : new Hmac(alg, key);\n    };\n  }\n}), require_algorithms = __commonJS({\n  \"node_modules/browserify-sign/browser/algorithms.json\"(exports, module) {\n    module.exports = {\n      sha224WithRSAEncryption: {\n        sign: \"rsa\",\n        hash: \"sha224\",\n        id: \"302d300d06096086480165030402040500041c\"\n      },\n      \"RSA-SHA224\": {\n        sign: \"ecdsa/rsa\",\n        hash: \"sha224\",\n        id: \"302d300d06096086480165030402040500041c\"\n      },\n      sha256WithRSAEncryption: {\n        sign: \"rsa\",\n        hash: \"sha256\",\n        id: \"3031300d060960864801650304020105000420\"\n      },\n      \"RSA-SHA256\": {\n        sign: \"ecdsa/rsa\",\n        hash: \"sha256\",\n        id: \"3031300d060960864801650304020105000420\"\n      },\n      sha384WithRSAEncryption: {\n        sign: \"rsa\",\n        hash: \"sha384\",\n        id: \"3041300d060960864801650304020205000430\"\n      },\n      \"RSA-SHA384\": {\n        sign: \"ecdsa/rsa\",\n        hash: \"sha384\",\n        id: \"3041300d060960864801650304020205000430\"\n      },\n      sha512WithRSAEncryption: {\n        sign: \"rsa\",\n        hash: \"sha512\",\n        id: \"3051300d060960864801650304020305000440\"\n      },\n      \"RSA-SHA512\": {\n        sign: \"ecdsa/rsa\",\n        hash: \"sha512\",\n        id: \"3051300d060960864801650304020305000440\"\n      },\n      \"RSA-SHA1\": {\n        sign: \"rsa\",\n        hash: \"sha1\",\n        id: \"3021300906052b0e03021a05000414\"\n      },\n      \"ecdsa-with-SHA1\": {\n        sign: \"ecdsa\",\n        hash: \"sha1\",\n        id: \"\"\n      },\n      sha256: {\n        sign: \"ecdsa\",\n        hash: \"sha256\",\n        id: \"\"\n      },\n      sha224: {\n        sign: \"ecdsa\",\n        hash: \"sha224\",\n        id: \"\"\n      },\n      sha384: {\n        sign: \"ecdsa\",\n        hash: \"sha384\",\n        id: \"\"\n      },\n      sha512: {\n        sign: \"ecdsa\",\n        hash: \"sha512\",\n        id: \"\"\n      },\n      \"DSA-SHA\": {\n        sign: \"dsa\",\n        hash: \"sha1\",\n        id: \"\"\n      },\n      \"DSA-SHA1\": {\n        sign: \"dsa\",\n        hash: \"sha1\",\n        id: \"\"\n      },\n      DSA: {\n        sign: \"dsa\",\n        hash: \"sha1\",\n        id: \"\"\n      },\n      \"DSA-WITH-SHA224\": {\n        sign: \"dsa\",\n        hash: \"sha224\",\n        id: \"\"\n      },\n      \"DSA-SHA224\": {\n        sign: \"dsa\",\n        hash: \"sha224\",\n        id: \"\"\n      },\n      \"DSA-WITH-SHA256\": {\n        sign: \"dsa\",\n        hash: \"sha256\",\n        id: \"\"\n      },\n      \"DSA-SHA256\": {\n        sign: \"dsa\",\n        hash: \"sha256\",\n        id: \"\"\n      },\n      \"DSA-WITH-SHA384\": {\n        sign: \"dsa\",\n        hash: \"sha384\",\n        id: \"\"\n      },\n      \"DSA-SHA384\": {\n        sign: \"dsa\",\n        hash: \"sha384\",\n        id: \"\"\n      },\n      \"DSA-WITH-SHA512\": {\n        sign: \"dsa\",\n        hash: \"sha512\",\n        id: \"\"\n      },\n      \"DSA-SHA512\": {\n        sign: \"dsa\",\n        hash: \"sha512\",\n        id: \"\"\n      },\n      \"DSA-RIPEMD160\": {\n        sign: \"dsa\",\n        hash: \"rmd160\",\n        id: \"\"\n      },\n      ripemd160WithRSA: {\n        sign: \"rsa\",\n        hash: \"rmd160\",\n        id: \"3021300906052b2403020105000414\"\n      },\n      \"RSA-RIPEMD160\": {\n        sign: \"rsa\",\n        hash: \"rmd160\",\n        id: \"3021300906052b2403020105000414\"\n      },\n      md5WithRSAEncryption: {\n        sign: \"rsa\",\n        hash: \"md5\",\n        id: \"3020300c06082a864886f70d020505000410\"\n      },\n      \"RSA-MD5\": {\n        sign: \"rsa\",\n        hash: \"md5\",\n        id: \"3020300c06082a864886f70d020505000410\"\n      }\n    };\n  }\n}), require_algos = __commonJS({\n  \"node_modules/browserify-sign/algos.js\"(exports, module) {\n    module.exports = require_algorithms();\n  }\n}), require_precondition = __commonJS({\n  \"node_modules/pbkdf2/lib/precondition.js\"(exports, module) {\n    var MAX_ALLOC = Math.pow(2, 30) - 1;\n    module.exports = function(iterations, keylen) {\n      if (typeof iterations != \"number\")\n        @throwTypeError(\"Iterations not a number\");\n      if (iterations < 0)\n        @throwTypeError(\"Bad iterations\");\n      if (typeof keylen != \"number\")\n        @throwTypeError(\"Key length not a number\");\n      if (keylen < 0 || keylen > MAX_ALLOC || keylen !== keylen)\n        @throwTypeError(\"Bad key length\");\n    };\n  }\n}), require_default_encoding = __commonJS({\n  \"node_modules/pbkdf2/lib/default-encoding.js\"(exports, module) {\n    var defaultEncoding;\n    global.process && global.process.browser \? defaultEncoding = \"utf-8\" : global.process && global.process.version \? (pVersionMajor = parseInt(process.version.split(\".\")[0].slice(1), 10), defaultEncoding = pVersionMajor >= 6 \? \"utf-8\" : \"binary\") : defaultEncoding = \"utf-8\";\n    var pVersionMajor;\n    module.exports = defaultEncoding;\n  }\n}), require_to_buffer = __commonJS({\n  \"node_modules/pbkdf2/lib/to-buffer.js\"(exports, module) {\n    var Buffer2 = require_safe_buffer().Buffer;\n    module.exports = function(thing, encoding, name) {\n      if (Buffer2.isBuffer(thing))\n        return thing;\n      if (typeof thing == \"string\")\n        return Buffer2.from(thing, encoding);\n      if (ArrayBuffer.isView(thing))\n        return Buffer2.from(thing.buffer);\n      @throwTypeError(name + \" must be a string, a Buffer, a typed array or a DataView\");\n    };\n  }\n}), require_sync_browser = __commonJS({\n  \"node_modules/pbkdf2/lib/sync-browser.js\"(exports, module) {\n    var md5 = require_md52(), RIPEMD160 = require_ripemd160(), sha = require_sha2(), Buffer2 = require_safe_buffer().Buffer, checkParameters = require_precondition(), defaultEncoding = require_default_encoding(), toBuffer = require_to_buffer(), ZEROS = Buffer2.alloc(128), sizes = {\n      md5: 16,\n      sha1: 20,\n      sha224: 28,\n      sha256: 32,\n      sha384: 48,\n      sha512: 64,\n      rmd160: 20,\n      ripemd160: 20\n    };\n    function Hmac(alg, key, saltLen) {\n      var hash = getDigest(alg), blocksize = alg === \"sha512\" || alg === \"sha384\" \? 128 : 64;\n      key.length > blocksize \? key = hash(key) : key.length < blocksize && (key = Buffer2.concat([key, ZEROS], blocksize));\n      for (var ipad = Buffer2.allocUnsafe(blocksize + sizes[alg]), opad = Buffer2.allocUnsafe(blocksize + sizes[alg]), i = 0;i < blocksize; i++)\n        ipad[i] = key[i] ^ 54, opad[i] = key[i] ^ 92;\n      var ipad1 = Buffer2.allocUnsafe(blocksize + saltLen + 4);\n      ipad.copy(ipad1, 0, 0, blocksize), this.ipad1 = ipad1, this.ipad2 = ipad, this.opad = opad, this.alg = alg, this.blocksize = blocksize, this.hash = hash, this.size = sizes[alg];\n    }\n    Hmac.prototype = {}, Hmac.prototype.run = function(data, ipad) {\n      data.copy(ipad, this.blocksize);\n      var h = this.hash(ipad);\n      return h.copy(this.opad, this.blocksize), this.hash(this.opad);\n    };\n    function getDigest(alg) {\n      function shaFunc(data) {\n        return sha(alg).update(data).digest();\n      }\n      function rmd160Func(data) {\n        return new RIPEMD160().update(data).digest();\n      }\n      return alg === \"rmd160\" || alg === \"ripemd160\" \? rmd160Func : alg === \"md5\" \? md5 : shaFunc;\n    }\n    function pbkdf2(password, salt, iterations, keylen, digest) {\n      checkParameters(iterations, keylen), password = toBuffer(password, defaultEncoding, \"Password\"), salt = toBuffer(salt, defaultEncoding, \"Salt\"), digest = digest || \"sha1\";\n      var hmac = new Hmac(digest, password, salt.length), DK = Buffer2.allocUnsafe(keylen), block1 = Buffer2.allocUnsafe(salt.length + 4);\n      salt.copy(block1, 0, 0, salt.length);\n      for (var destPos = 0, hLen = sizes[digest], l = Math.ceil(keylen / hLen), i = 1;i <= l; i++) {\n        block1.writeUInt32BE(i, salt.length);\n        for (var T = hmac.run(block1, hmac.ipad1), U = T, j = 1;j < iterations; j++) {\n          U = hmac.run(U, hmac.ipad2);\n          for (var k = 0;k < hLen; k++)\n            T[k] ^= U[k];\n        }\n        T.copy(DK, destPos), destPos += hLen;\n      }\n      return DK;\n    }\n    module.exports = pbkdf2;\n  }\n}), require_async = __commonJS({\n  \"node_modules/pbkdf2/lib/async.js\"(exports, module) {\n    var Buffer2 = require_safe_buffer().Buffer, checkParameters = require_precondition(), defaultEncoding = require_default_encoding(), sync = require_sync_browser(), toBuffer = require_to_buffer(), ZERO_BUF, subtle = globalCrypto.subtle, toBrowser = {\n      sha: \"SHA-1\",\n      \"sha-1\": \"SHA-1\",\n      sha1: \"SHA-1\",\n      sha256: \"SHA-256\",\n      \"sha-256\": \"SHA-256\",\n      sha384: \"SHA-384\",\n      \"sha-384\": \"SHA-384\",\n      \"sha-512\": \"SHA-512\",\n      sha512: \"SHA-512\"\n    }, checks = [];\n    function checkNative(algo) {\n      if (global.process && !global.process.browser || !subtle || !subtle.importKey || !subtle.deriveBits)\n        return Promise.resolve(!1);\n      if (checks[algo] !== void 0)\n        return checks[algo];\n      ZERO_BUF = ZERO_BUF || Buffer2.alloc(8);\n      var prom = browserPbkdf2(ZERO_BUF, ZERO_BUF, 10, 128, algo).then(function() {\n        return !0;\n      }).catch(function() {\n        return !1;\n      });\n      return checks[algo] = prom, prom;\n    }\n    var nextTick;\n    function getNextTick() {\n      return nextTick || (global.process && global.process.nextTick \? nextTick = global.process.nextTick : global.queueMicrotask \? nextTick = global.queueMicrotask : global.setImmediate \? nextTick = global.setImmediate : nextTick = global.setTimeout, nextTick);\n    }\n    function browserPbkdf2(password, salt, iterations, length, algo) {\n      return subtle.importKey(\"raw\", password, { name: \"PBKDF2\" }, !1, [\"deriveBits\"]).then(function(key) {\n        return subtle.deriveBits({\n          name: \"PBKDF2\",\n          salt,\n          iterations,\n          hash: {\n            name: algo\n          }\n        }, key, length << 3);\n      }).then(function(res) {\n        return Buffer2.from(res);\n      });\n    }\n    function resolvePromise(promise, callback) {\n      promise.then(function(out) {\n        getNextTick()(function() {\n          callback(null, out);\n        });\n      }, function(e) {\n        getNextTick()(function() {\n          callback(e);\n        });\n      });\n    }\n    module.exports = function(password, salt, iterations, keylen, digest, callback) {\n      typeof digest == \"function\" && (callback = digest, digest = void 0), digest = digest || \"sha1\";\n      var algo = toBrowser[digest.toLowerCase()];\n      if (!algo || typeof global.Promise != \"function\") {\n        getNextTick()(function() {\n          var out;\n          try {\n            out = sync(password, salt, iterations, keylen, digest);\n          } catch (e) {\n            return callback(e);\n          }\n          callback(null, out);\n        });\n        return;\n      }\n      if (checkParameters(iterations, keylen), password = toBuffer(password, defaultEncoding, \"Password\"), salt = toBuffer(salt, defaultEncoding, \"Salt\"), typeof callback != \"function\")\n        throw new Error(\"No callback provided to pbkdf2\");\n      resolvePromise(checkNative(algo).then(function(resp) {\n        return resp \? browserPbkdf2(password, salt, iterations, keylen, algo) : sync(password, salt, iterations, keylen, digest);\n      }), callback);\n    };\n  }\n}), require_browser4 = __commonJS({\n  \"node_modules/pbkdf2/browser.js\"(exports) {\n    exports.pbkdf2 = require_async(), exports.pbkdf2Sync = require_sync_browser();\n  }\n}), require_utils = __commonJS({\n  \"node_modules/des.js/lib/des/utils.js\"(exports) {\n    exports.readUInt32BE = function(bytes, off) {\n      var res = bytes[0 + off] << 24 | bytes[1 + off] << 16 | bytes[2 + off] << 8 | bytes[3 + off];\n      return res >>> 0;\n    }, exports.writeUInt32BE = function(bytes, value, off) {\n      bytes[0 + off] = value >>> 24, bytes[1 + off] = value >>> 16 & 255, bytes[2 + off] = value >>> 8 & 255, bytes[3 + off] = value & 255;\n    }, exports.ip = function(inL, inR, out, off) {\n      for (var outL = 0, outR = 0, i = 6;i >= 0; i -= 2) {\n        for (var j = 0;j <= 24; j += 8)\n          outL <<= 1, outL |= inR >>> j + i & 1;\n        for (var j = 0;j <= 24; j += 8)\n          outL <<= 1, outL |= inL >>> j + i & 1;\n      }\n      for (var i = 6;i >= 0; i -= 2) {\n        for (var j = 1;j <= 25; j += 8)\n          outR <<= 1, outR |= inR >>> j + i & 1;\n        for (var j = 1;j <= 25; j += 8)\n          outR <<= 1, outR |= inL >>> j + i & 1;\n      }\n      out[off + 0] = outL >>> 0, out[off + 1] = outR >>> 0;\n    }, exports.rip = function(inL, inR, out, off) {\n      for (var outL = 0, outR = 0, i = 0;i < 4; i++)\n        for (var j = 24;j >= 0; j -= 8)\n          outL <<= 1, outL |= inR >>> j + i & 1, outL <<= 1, outL |= inL >>> j + i & 1;\n      for (var i = 4;i < 8; i++)\n        for (var j = 24;j >= 0; j -= 8)\n          outR <<= 1, outR |= inR >>> j + i & 1, outR <<= 1, outR |= inL >>> j + i & 1;\n      out[off + 0] = outL >>> 0, out[off + 1] = outR >>> 0;\n    }, exports.pc1 = function(inL, inR, out, off) {\n      for (var outL = 0, outR = 0, i = 7;i >= 5; i--) {\n        for (var j = 0;j <= 24; j += 8)\n          outL <<= 1, outL |= inR >> j + i & 1;\n        for (var j = 0;j <= 24; j += 8)\n          outL <<= 1, outL |= inL >> j + i & 1;\n      }\n      for (var j = 0;j <= 24; j += 8)\n        outL <<= 1, outL |= inR >> j + i & 1;\n      for (var i = 1;i <= 3; i++) {\n        for (var j = 0;j <= 24; j += 8)\n          outR <<= 1, outR |= inR >> j + i & 1;\n        for (var j = 0;j <= 24; j += 8)\n          outR <<= 1, outR |= inL >> j + i & 1;\n      }\n      for (var j = 0;j <= 24; j += 8)\n        outR <<= 1, outR |= inL >> j + i & 1;\n      out[off + 0] = outL >>> 0, out[off + 1] = outR >>> 0;\n    }, exports.r28shl = function(num, shift) {\n      return num << shift & 268435455 | num >>> 28 - shift;\n    };\n    var pc2table = [\n      14,\n      11,\n      17,\n      4,\n      27,\n      23,\n      25,\n      0,\n      13,\n      22,\n      7,\n      18,\n      5,\n      9,\n      16,\n      24,\n      2,\n      20,\n      12,\n      21,\n      1,\n      8,\n      15,\n      26,\n      15,\n      4,\n      25,\n      19,\n      9,\n      1,\n      26,\n      16,\n      5,\n      11,\n      23,\n      8,\n      12,\n      7,\n      17,\n      0,\n      22,\n      3,\n      10,\n      14,\n      6,\n      20,\n      27,\n      24\n    ];\n    exports.pc2 = function(inL, inR, out, off) {\n      for (var outL = 0, outR = 0, len = pc2table.length >>> 1, i = 0;i < len; i++)\n        outL <<= 1, outL |= inL >>> pc2table[i] & 1;\n      for (var i = len;i < pc2table.length; i++)\n        outR <<= 1, outR |= inR >>> pc2table[i] & 1;\n      out[off + 0] = outL >>> 0, out[off + 1] = outR >>> 0;\n    }, exports.expand = function(r, out, off) {\n      var outL = 0, outR = 0;\n      outL = (r & 1) << 5 | r >>> 27;\n      for (var i = 23;i >= 15; i -= 4)\n        outL <<= 6, outL |= r >>> i & 63;\n      for (var i = 11;i >= 3; i -= 4)\n        outR |= r >>> i & 63, outR <<= 6;\n      outR |= (r & 31) << 1 | r >>> 31, out[off + 0] = outL >>> 0, out[off + 1] = outR >>> 0;\n    };\n    var sTable = [\n      14,\n      0,\n      4,\n      15,\n      13,\n      7,\n      1,\n      4,\n      2,\n      14,\n      15,\n      2,\n      11,\n      13,\n      8,\n      1,\n      3,\n      10,\n      10,\n      6,\n      6,\n      12,\n      12,\n      11,\n      5,\n      9,\n      9,\n      5,\n      0,\n      3,\n      7,\n      8,\n      4,\n      15,\n      1,\n      12,\n      14,\n      8,\n      8,\n      2,\n      13,\n      4,\n      6,\n      9,\n      2,\n      1,\n      11,\n      7,\n      15,\n      5,\n      12,\n      11,\n      9,\n      3,\n      7,\n      14,\n      3,\n      10,\n      10,\n      0,\n      5,\n      6,\n      0,\n      13,\n      15,\n      3,\n      1,\n      13,\n      8,\n      4,\n      14,\n      7,\n      6,\n      15,\n      11,\n      2,\n      3,\n      8,\n      4,\n      14,\n      9,\n      12,\n      7,\n      0,\n      2,\n      1,\n      13,\n      10,\n      12,\n      6,\n      0,\n      9,\n      5,\n      11,\n      10,\n      5,\n      0,\n      13,\n      14,\n      8,\n      7,\n      10,\n      11,\n      1,\n      10,\n      3,\n      4,\n      15,\n      13,\n      4,\n      1,\n      2,\n      5,\n      11,\n      8,\n      6,\n      12,\n      7,\n      6,\n      12,\n      9,\n      0,\n      3,\n      5,\n      2,\n      14,\n      15,\n      9,\n      10,\n      13,\n      0,\n      7,\n      9,\n      0,\n      14,\n      9,\n      6,\n      3,\n      3,\n      4,\n      15,\n      6,\n      5,\n      10,\n      1,\n      2,\n      13,\n      8,\n      12,\n      5,\n      7,\n      14,\n      11,\n      12,\n      4,\n      11,\n      2,\n      15,\n      8,\n      1,\n      13,\n      1,\n      6,\n      10,\n      4,\n      13,\n      9,\n      0,\n      8,\n      6,\n      15,\n      9,\n      3,\n      8,\n      0,\n      7,\n      11,\n      4,\n      1,\n      15,\n      2,\n      14,\n      12,\n      3,\n      5,\n      11,\n      10,\n      5,\n      14,\n      2,\n      7,\n      12,\n      7,\n      13,\n      13,\n      8,\n      14,\n      11,\n      3,\n      5,\n      0,\n      6,\n      6,\n      15,\n      9,\n      0,\n      10,\n      3,\n      1,\n      4,\n      2,\n      7,\n      8,\n      2,\n      5,\n      12,\n      11,\n      1,\n      12,\n      10,\n      4,\n      14,\n      15,\n      9,\n      10,\n      3,\n      6,\n      15,\n      9,\n      0,\n      0,\n      6,\n      12,\n      10,\n      11,\n      1,\n      7,\n      13,\n      13,\n      8,\n      15,\n      9,\n      1,\n      4,\n      3,\n      5,\n      14,\n      11,\n      5,\n      12,\n      2,\n      7,\n      8,\n      2,\n      4,\n      14,\n      2,\n      14,\n      12,\n      11,\n      4,\n      2,\n      1,\n      12,\n      7,\n      4,\n      10,\n      7,\n      11,\n      13,\n      6,\n      1,\n      8,\n      5,\n      5,\n      0,\n      3,\n      15,\n      15,\n      10,\n      13,\n      3,\n      0,\n      9,\n      14,\n      8,\n      9,\n      6,\n      4,\n      11,\n      2,\n      8,\n      1,\n      12,\n      11,\n      7,\n      10,\n      1,\n      13,\n      14,\n      7,\n      2,\n      8,\n      13,\n      15,\n      6,\n      9,\n      15,\n      12,\n      0,\n      5,\n      9,\n      6,\n      10,\n      3,\n      4,\n      0,\n      5,\n      14,\n      3,\n      12,\n      10,\n      1,\n      15,\n      10,\n      4,\n      15,\n      2,\n      9,\n      7,\n      2,\n      12,\n      6,\n      9,\n      8,\n      5,\n      0,\n      6,\n      13,\n      1,\n      3,\n      13,\n      4,\n      14,\n      14,\n      0,\n      7,\n      11,\n      5,\n      3,\n      11,\n      8,\n      9,\n      4,\n      14,\n      3,\n      15,\n      2,\n      5,\n      12,\n      2,\n      9,\n      8,\n      5,\n      12,\n      15,\n      3,\n      10,\n      7,\n      11,\n      0,\n      14,\n      4,\n      1,\n      10,\n      7,\n      1,\n      6,\n      13,\n      0,\n      11,\n      8,\n      6,\n      13,\n      4,\n      13,\n      11,\n      0,\n      2,\n      11,\n      14,\n      7,\n      15,\n      4,\n      0,\n      9,\n      8,\n      1,\n      13,\n      10,\n      3,\n      14,\n      12,\n      3,\n      9,\n      5,\n      7,\n      12,\n      5,\n      2,\n      10,\n      15,\n      6,\n      8,\n      1,\n      6,\n      1,\n      6,\n      4,\n      11,\n      11,\n      13,\n      13,\n      8,\n      12,\n      1,\n      3,\n      4,\n      7,\n      10,\n      14,\n      7,\n      10,\n      9,\n      15,\n      5,\n      6,\n      0,\n      8,\n      15,\n      0,\n      14,\n      5,\n      2,\n      9,\n      3,\n      2,\n      12,\n      13,\n      1,\n      2,\n      15,\n      8,\n      13,\n      4,\n      8,\n      6,\n      10,\n      15,\n      3,\n      11,\n      7,\n      1,\n      4,\n      10,\n      12,\n      9,\n      5,\n      3,\n      6,\n      14,\n      11,\n      5,\n      0,\n      0,\n      14,\n      12,\n      9,\n      7,\n      2,\n      7,\n      2,\n      11,\n      1,\n      4,\n      14,\n      1,\n      7,\n      9,\n      4,\n      12,\n      10,\n      14,\n      8,\n      2,\n      13,\n      0,\n      15,\n      6,\n      12,\n      10,\n      9,\n      13,\n      0,\n      15,\n      3,\n      3,\n      5,\n      5,\n      6,\n      8,\n      11\n    ];\n    exports.substitute = function(inL, inR) {\n      for (var out = 0, i = 0;i < 4; i++) {\n        var b = inL >>> 18 - i * 6 & 63, sb = sTable[i * 64 + b];\n        out <<= 4, out |= sb;\n      }\n      for (var i = 0;i < 4; i++) {\n        var b = inR >>> 18 - i * 6 & 63, sb = sTable[256 + i * 64 + b];\n        out <<= 4, out |= sb;\n      }\n      return out >>> 0;\n    };\n    var permuteTable = [\n      16,\n      25,\n      12,\n      11,\n      3,\n      20,\n      4,\n      15,\n      31,\n      17,\n      9,\n      6,\n      27,\n      14,\n      1,\n      22,\n      30,\n      24,\n      8,\n      18,\n      0,\n      5,\n      29,\n      23,\n      13,\n      19,\n      2,\n      26,\n      10,\n      21,\n      28,\n      7\n    ];\n    exports.permute = function(num) {\n      for (var out = 0, i = 0;i < permuteTable.length; i++)\n        out <<= 1, out |= num >>> permuteTable[i] & 1;\n      return out >>> 0;\n    }, exports.padSplit = function(num, size, group) {\n      for (var str = num.toString(2);str.length < size; )\n        str = \"0\" + str;\n      for (var out = [], i = 0;i < size; i += group)\n        out.push(str.slice(i, i + group));\n      return out.join(\" \");\n    };\n  }\n}), require_minimalistic_assert = __commonJS({\n  \"node_modules/minimalistic-assert/index.js\"(exports, module) {\n    module.exports = assert;\n    function assert(val, msg) {\n      if (!val)\n        throw new Error(msg || \"Assertion failed\");\n    }\n    assert.equal = function(l, r, msg) {\n      if (l != r)\n        throw new Error(msg || \"Assertion failed: \" + l + \" != \" + r);\n    };\n  }\n}), require_cipher = __commonJS({\n  \"node_modules/des.js/lib/des/cipher.js\"(exports, module) {\n    var assert = require_minimalistic_assert();\n    function Cipher(options) {\n      this.options = options, this.type = this.options.type, this.blockSize = 8, this._init(), this.buffer = new Array(this.blockSize), this.bufferOff = 0;\n    }\n    Cipher.prototype = {}, module.exports = Cipher, Cipher.prototype._init = function() {\n    }, Cipher.prototype.update = function(data) {\n      return data.length === 0 \? [] : this.type === \"decrypt\" \? this._updateDecrypt(data) : this._updateEncrypt(data);\n    }, Cipher.prototype._buffer = function(data, off) {\n      for (var min = Math.min(this.buffer.length - this.bufferOff, data.length - off), i = 0;i < min; i++)\n        this.buffer[this.bufferOff + i] = data[off + i];\n      return this.bufferOff += min, min;\n    }, Cipher.prototype._flushBuffer = function(out, off) {\n      return this._update(this.buffer, 0, out, off), this.bufferOff = 0, this.blockSize;\n    }, Cipher.prototype._updateEncrypt = function(data) {\n      var inputOff = 0, outputOff = 0, count = (this.bufferOff + data.length) / this.blockSize | 0, out = new Array(count * this.blockSize);\n      this.bufferOff !== 0 && (inputOff += this._buffer(data, inputOff), this.bufferOff === this.buffer.length && (outputOff += this._flushBuffer(out, outputOff)));\n      for (var max = data.length - (data.length - inputOff) % this.blockSize;inputOff < max; inputOff += this.blockSize)\n        this._update(data, inputOff, out, outputOff), outputOff += this.blockSize;\n      for (;inputOff < data.length; inputOff++, this.bufferOff++)\n        this.buffer[this.bufferOff] = data[inputOff];\n      return out;\n    }, Cipher.prototype._updateDecrypt = function(data) {\n      for (var inputOff = 0, outputOff = 0, count = Math.ceil((this.bufferOff + data.length) / this.blockSize) - 1, out = new Array(count * this.blockSize);count > 0; count--)\n        inputOff += this._buffer(data, inputOff), outputOff += this._flushBuffer(out, outputOff);\n      return inputOff += this._buffer(data, inputOff), out;\n    }, Cipher.prototype.final = function(buffer) {\n      var first;\n      buffer && (first = this.update(buffer));\n      var last;\n      return this.type === \"encrypt\" \? last = this._finalEncrypt() : last = this._finalDecrypt(), first \? first.concat(last) : last;\n    }, Cipher.prototype._pad = function(buffer, off) {\n      if (off === 0)\n        return !1;\n      for (;off < buffer.length; )\n        buffer[off++] = 0;\n      return !0;\n    }, Cipher.prototype._finalEncrypt = function() {\n      if (!this._pad(this.buffer, this.bufferOff))\n        return [];\n      var out = new Array(this.blockSize);\n      return this._update(this.buffer, 0, out, 0), out;\n    }, Cipher.prototype._unpad = function(buffer) {\n      return buffer;\n    }, Cipher.prototype._finalDecrypt = function() {\n      assert.equal(this.bufferOff, this.blockSize, \"Not enough data to decrypt\");\n      var out = new Array(this.blockSize);\n      return this._flushBuffer(out, 0), this._unpad(out);\n    };\n  }\n}), require_des = __commonJS({\n  \"node_modules/des.js/lib/des/des.js\"(exports, module) {\n    var assert = require_minimalistic_assert(), inherits = require_inherits_browser(), utils = require_utils(), Cipher = require_cipher();\n    function DESState() {\n      this.tmp = new Array(2), this.keys = null;\n    }\n    function DES(options) {\n      Cipher.call(this, options);\n      var state = new DESState;\n      this._desState = state, this.deriveKeys(state, options.key);\n    }\n    inherits(DES, Cipher), module.exports = DES, DES.create = function(options) {\n      return new DES(options);\n    };\n    var shiftTable = [1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1];\n    DES.prototype.deriveKeys = function(state, key) {\n      state.keys = new Array(32), assert.equal(key.length, this.blockSize, \"Invalid key length\");\n      var kL = utils.readUInt32BE(key, 0), kR = utils.readUInt32BE(key, 4);\n      utils.pc1(kL, kR, state.tmp, 0), kL = state.tmp[0], kR = state.tmp[1];\n      for (var i = 0;i < state.keys.length; i += 2) {\n        var shift = shiftTable[i >>> 1];\n        kL = utils.r28shl(kL, shift), kR = utils.r28shl(kR, shift), utils.pc2(kL, kR, state.keys, i);\n      }\n    }, DES.prototype._update = function(inp, inOff, out, outOff) {\n      var state = this._desState, l = utils.readUInt32BE(inp, inOff), r = utils.readUInt32BE(inp, inOff + 4);\n      utils.ip(l, r, state.tmp, 0), l = state.tmp[0], r = state.tmp[1], this.type === \"encrypt\" \? this._encrypt(state, l, r, state.tmp, 0) : this._decrypt(state, l, r, state.tmp, 0), l = state.tmp[0], r = state.tmp[1], utils.writeUInt32BE(out, l, outOff), utils.writeUInt32BE(out, r, outOff + 4);\n    }, DES.prototype._pad = function(buffer, off) {\n      for (var value = buffer.length - off, i = off;i < buffer.length; i++)\n        buffer[i] = value;\n      return !0;\n    }, DES.prototype._unpad = function(buffer) {\n      for (var pad = buffer[buffer.length - 1], i = buffer.length - pad;i < buffer.length; i++)\n        assert.equal(buffer[i], pad);\n      return buffer.slice(0, buffer.length - pad);\n    }, DES.prototype._encrypt = function(state, lStart, rStart, out, off) {\n      for (var l = lStart, r = rStart, i = 0;i < state.keys.length; i += 2) {\n        var keyL = state.keys[i], keyR = state.keys[i + 1];\n        utils.expand(r, state.tmp, 0), keyL ^= state.tmp[0], keyR ^= state.tmp[1];\n        var s = utils.substitute(keyL, keyR), f = utils.permute(s), t = r;\n        r = (l ^ f) >>> 0, l = t;\n      }\n      utils.rip(r, l, out, off);\n    }, DES.prototype._decrypt = function(state, lStart, rStart, out, off) {\n      for (var l = rStart, r = lStart, i = state.keys.length - 2;i >= 0; i -= 2) {\n        var keyL = state.keys[i], keyR = state.keys[i + 1];\n        utils.expand(l, state.tmp, 0), keyL ^= state.tmp[0], keyR ^= state.tmp[1];\n        var s = utils.substitute(keyL, keyR), f = utils.permute(s), t = l;\n        l = (r ^ f) >>> 0, r = t;\n      }\n      utils.rip(l, r, out, off);\n    };\n  }\n}), require_cbc = __commonJS({\n  \"node_modules/des.js/lib/des/cbc.js\"(exports) {\n    var assert = require_minimalistic_assert(), inherits = require_inherits_browser(), proto = {};\n    function CBCState(iv) {\n      assert.equal(iv.length, 8, \"Invalid IV length\"), this.iv = new Array(8);\n      for (var i = 0;i < this.iv.length; i++)\n        this.iv[i] = iv[i];\n    }\n    function instantiate(Base) {\n      function CBC(options) {\n        Base.call(this, options), this._cbcInit();\n      }\n      inherits(CBC, Base);\n      for (var keys = Object.keys(proto), i = 0;i < keys.length; i++) {\n        var key = keys[i];\n        CBC.prototype[key] = proto[key];\n      }\n      return CBC.create = function(options) {\n        return new CBC(options);\n      }, CBC;\n    }\n    exports.instantiate = instantiate, proto._cbcInit = function() {\n      var state = new CBCState(this.options.iv);\n      this._cbcState = state;\n    }, proto._update = function(inp, inOff, out, outOff) {\n      var state = this._cbcState, superProto = this.constructor.super_.prototype, iv = state.iv;\n      if (this.type === \"encrypt\") {\n        for (var i = 0;i < this.blockSize; i++)\n          iv[i] ^= inp[inOff + i];\n        superProto._update.call(this, iv, 0, out, outOff);\n        for (var i = 0;i < this.blockSize; i++)\n          iv[i] = out[outOff + i];\n      } else {\n        superProto._update.call(this, inp, inOff, out, outOff);\n        for (var i = 0;i < this.blockSize; i++)\n          out[outOff + i] ^= iv[i];\n        for (var i = 0;i < this.blockSize; i++)\n          iv[i] = inp[inOff + i];\n      }\n    };\n  }\n}), require_ede = __commonJS({\n  \"node_modules/des.js/lib/des/ede.js\"(exports, module) {\n    var assert = require_minimalistic_assert(), inherits = require_inherits_browser(), Cipher = require_cipher(), DES = require_des();\n    function EDEState(type, key) {\n      assert.equal(key.length, 24, \"Invalid key length\");\n      var k1 = key.slice(0, 8), k2 = key.slice(8, 16), k3 = key.slice(16, 24);\n      type === \"encrypt\" \? this.ciphers = [\n        DES.create({ type: \"encrypt\", key: k1 }),\n        DES.create({ type: \"decrypt\", key: k2 }),\n        DES.create({ type: \"encrypt\", key: k3 })\n      ] : this.ciphers = [\n        DES.create({ type: \"decrypt\", key: k3 }),\n        DES.create({ type: \"encrypt\", key: k2 }),\n        DES.create({ type: \"decrypt\", key: k1 })\n      ];\n    }\n    function EDE(options) {\n      Cipher.call(this, options);\n      var state = new EDEState(this.type, this.options.key);\n      this._edeState = state;\n    }\n    inherits(EDE, Cipher), module.exports = EDE, EDE.create = function(options) {\n      return new EDE(options);\n    }, EDE.prototype._update = function(inp, inOff, out, outOff) {\n      var state = this._edeState;\n      state.ciphers[0]._update(inp, inOff, out, outOff), state.ciphers[1]._update(out, outOff, out, outOff), state.ciphers[2]._update(out, outOff, out, outOff);\n    }, EDE.prototype._pad = DES.prototype._pad, EDE.prototype._unpad = DES.prototype._unpad;\n  }\n}), require_des2 = __commonJS({\n  \"node_modules/des.js/lib/des.js\"(exports) {\n    exports.utils = require_utils(), exports.Cipher = require_cipher(), exports.DES = require_des(), exports.CBC = require_cbc(), exports.EDE = require_ede();\n  }\n}), require_browserify_des = __commonJS({\n  \"node_modules/browserify-des/index.js\"(exports, module) {\n    var CipherBase = require_cipher_base(), des = require_des2(), inherits = require_inherits_browser(), Buffer2 = require_safe_buffer().Buffer, modes = {\n      \"des-ede3-cbc\": des.CBC.instantiate(des.EDE),\n      \"des-ede3\": des.EDE,\n      \"des-ede-cbc\": des.CBC.instantiate(des.EDE),\n      \"des-ede\": des.EDE,\n      \"des-cbc\": des.CBC.instantiate(des.DES),\n      \"des-ecb\": des.DES\n    };\n    modes.des = modes[\"des-cbc\"], modes.des3 = modes[\"des-ede3-cbc\"], module.exports = DES, inherits(DES, CipherBase);\n    function DES(opts) {\n      CipherBase.call(this);\n      var modeName = opts.mode.toLowerCase(), mode = modes[modeName], type;\n      opts.decrypt \? type = \"decrypt\" : type = \"encrypt\";\n      var key = opts.key;\n      Buffer2.isBuffer(key) || (key = Buffer2.from(key)), (modeName === \"des-ede\" || modeName === \"des-ede-cbc\") && (key = Buffer2.concat([key, key.slice(0, 8)]));\n      var iv = opts.iv;\n      Buffer2.isBuffer(iv) || (iv = Buffer2.from(iv)), this._des = mode.create({\n        key,\n        iv,\n        type\n      });\n    }\n    DES.prototype._update = function(data) {\n      return Buffer2.from(this._des.update(data));\n    }, DES.prototype._final = function() {\n      return Buffer2.from(this._des.final());\n    };\n  }\n}), require_ecb = __commonJS({\n  \"node_modules/browserify-aes/modes/ecb.js\"(exports) {\n    exports.encrypt = function(self2, block) {\n      return self2._cipher.encryptBlock(block);\n    }, exports.decrypt = function(self2, block) {\n      return self2._cipher.decryptBlock(block);\n    };\n  }\n}), require_buffer_xor = __commonJS({\n  \"node_modules/buffer-xor/index.js\"(exports, module) {\n    module.exports = function(a, b) {\n      for (var length = Math.min(a.length, b.length), buffer = new Buffer(length), i = 0;i < length; ++i)\n        buffer[i] = a[i] ^ b[i];\n      return buffer;\n    };\n  }\n}), require_cbc2 = __commonJS({\n  \"node_modules/browserify-aes/modes/cbc.js\"(exports) {\n    var xor = require_buffer_xor();\n    exports.encrypt = function(self2, block) {\n      var data = xor(block, self2._prev);\n      return self2._prev = self2._cipher.encryptBlock(data), self2._prev;\n    }, exports.decrypt = function(self2, block) {\n      var pad = self2._prev;\n      self2._prev = block;\n      var out = self2._cipher.decryptBlock(block);\n      return xor(out, pad);\n    };\n  }\n}), require_cfb = __commonJS({\n  \"node_modules/browserify-aes/modes/cfb.js\"(exports) {\n    var Buffer2 = require_safe_buffer().Buffer, xor = require_buffer_xor();\n    function encryptStart(self2, data, decrypt) {\n      var len = data.length, out = xor(data, self2._cache);\n      return self2._cache = self2._cache.slice(len), self2._prev = Buffer2.concat([self2._prev, decrypt \? data : out]), out;\n    }\n    exports.encrypt = function(self2, data, decrypt) {\n      for (var out = Buffer2.allocUnsafe(0), len;data.length; )\n        if (self2._cache.length === 0 && (self2._cache = self2._cipher.encryptBlock(self2._prev), self2._prev = Buffer2.allocUnsafe(0)), self2._cache.length <= data.length)\n          len = self2._cache.length, out = Buffer2.concat([out, encryptStart(self2, data.slice(0, len), decrypt)]), data = data.slice(len);\n        else {\n          out = Buffer2.concat([out, encryptStart(self2, data, decrypt)]);\n          break;\n        }\n      return out;\n    };\n  }\n}), require_cfb8 = __commonJS({\n  \"node_modules/browserify-aes/modes/cfb8.js\"(exports) {\n    var Buffer2 = require_safe_buffer().Buffer;\n    function encryptByte(self2, byteParam, decrypt) {\n      var pad = self2._cipher.encryptBlock(self2._prev), out = pad[0] ^ byteParam;\n      return self2._prev = Buffer2.concat([self2._prev.slice(1), Buffer2.from([decrypt \? byteParam : out])]), out;\n    }\n    exports.encrypt = function(self2, chunk, decrypt) {\n      for (var len = chunk.length, out = Buffer2.allocUnsafe(len), i = -1;++i < len; )\n        out[i] = encryptByte(self2, chunk[i], decrypt);\n      return out;\n    };\n  }\n}), require_cfb1 = __commonJS({\n  \"node_modules/browserify-aes/modes/cfb1.js\"(exports) {\n    var Buffer2 = require_safe_buffer().Buffer;\n    function encryptByte(self2, byteParam, decrypt) {\n      for (var pad, i = -1, len = 8, out = 0, bit, value;++i < len; )\n        pad = self2._cipher.encryptBlock(self2._prev), bit = byteParam & 1 << 7 - i \? 128 : 0, value = pad[0] ^ bit, out += (value & 128) >> i % 8, self2._prev = shiftIn(self2._prev, decrypt \? bit : value);\n      return out;\n    }\n    function shiftIn(buffer, value) {\n      var len = buffer.length, i = -1, out = Buffer2.allocUnsafe(buffer.length);\n      for (buffer = Buffer2.concat([buffer, Buffer2.from([value])]);++i < len; )\n        out[i] = buffer[i] << 1 | buffer[i + 1] >> 7;\n      return out;\n    }\n    exports.encrypt = function(self2, chunk, decrypt) {\n      for (var len = chunk.length, out = Buffer2.allocUnsafe(len), i = -1;++i < len; )\n        out[i] = encryptByte(self2, chunk[i], decrypt);\n      return out;\n    };\n  }\n}), require_ofb = __commonJS({\n  \"node_modules/browserify-aes/modes/ofb.js\"(exports) {\n    var xor = require_buffer_xor();\n    function getBlock(self2) {\n      return self2._prev = self2._cipher.encryptBlock(self2._prev), self2._prev;\n    }\n    exports.encrypt = function(self2, chunk) {\n      for (;self2._cache.length < chunk.length; )\n        self2._cache = Buffer.concat([self2._cache, getBlock(self2)]);\n      var pad = self2._cache.slice(0, chunk.length);\n      return self2._cache = self2._cache.slice(chunk.length), xor(chunk, pad);\n    };\n  }\n}), require_incr32 = __commonJS({\n  \"node_modules/browserify-aes/incr32.js\"(exports, module) {\n    function incr32(iv) {\n      for (var len = iv.length, item;len--; )\n        if (item = iv.readUInt8(len), item === 255)\n          iv.writeUInt8(0, len);\n        else {\n          item++, iv.writeUInt8(item, len);\n          break;\n        }\n    }\n    module.exports = incr32;\n  }\n}), require_ctr = __commonJS({\n  \"node_modules/browserify-aes/modes/ctr.js\"(exports) {\n    var xor = require_buffer_xor(), Buffer2 = require_safe_buffer().Buffer, incr32 = require_incr32();\n    function getBlock(self2) {\n      var out = self2._cipher.encryptBlockRaw(self2._prev);\n      return incr32(self2._prev), out;\n    }\n    var blockSize = 16;\n    exports.encrypt = function(self2, chunk) {\n      var chunkNum = Math.ceil(chunk.length / blockSize), start = self2._cache.length;\n      self2._cache = Buffer2.concat([self2._cache, Buffer2.allocUnsafe(chunkNum * blockSize)]);\n      for (var i = 0;i < chunkNum; i++) {\n        var out = getBlock(self2), offset = start + i * blockSize;\n        self2._cache.writeUInt32BE(out[0], offset + 0), self2._cache.writeUInt32BE(out[1], offset + 4), self2._cache.writeUInt32BE(out[2], offset + 8), self2._cache.writeUInt32BE(out[3], offset + 12);\n      }\n      var pad = self2._cache.slice(0, chunk.length);\n      return self2._cache = self2._cache.slice(chunk.length), xor(chunk, pad);\n    };\n  }\n}), require_list = __commonJS({\n  \"node_modules/browserify-aes/modes/list.json\"(exports, module) {\n    module.exports = {\n      \"aes-128-ecb\": {\n        cipher: \"AES\",\n        key: 128,\n        iv: 0,\n        mode: \"ECB\",\n        type: \"block\"\n      },\n      \"aes-192-ecb\": {\n        cipher: \"AES\",\n        key: 192,\n        iv: 0,\n        mode: \"ECB\",\n        type: \"block\"\n      },\n      \"aes-256-ecb\": {\n        cipher: \"AES\",\n        key: 256,\n        iv: 0,\n        mode: \"ECB\",\n        type: \"block\"\n      },\n      \"aes-128-cbc\": {\n        cipher: \"AES\",\n        key: 128,\n        iv: 16,\n        mode: \"CBC\",\n        type: \"block\"\n      },\n      \"aes-192-cbc\": {\n        cipher: \"AES\",\n        key: 192,\n        iv: 16,\n        mode: \"CBC\",\n        type: \"block\"\n      },\n      \"aes-256-cbc\": {\n        cipher: \"AES\",\n        key: 256,\n        iv: 16,\n        mode: \"CBC\",\n        type: \"block\"\n      },\n      aes128: {\n        cipher: \"AES\",\n        key: 128,\n        iv: 16,\n        mode: \"CBC\",\n        type: \"block\"\n      },\n      aes192: {\n        cipher: \"AES\",\n        key: 192,\n        iv: 16,\n        mode: \"CBC\",\n        type: \"block\"\n      },\n      aes256: {\n        cipher: \"AES\",\n        key: 256,\n        iv: 16,\n        mode: \"CBC\",\n        type: \"block\"\n      },\n      \"aes-128-cfb\": {\n        cipher: \"AES\",\n        key: 128,\n        iv: 16,\n        mode: \"CFB\",\n        type: \"stream\"\n      },\n      \"aes-192-cfb\": {\n        cipher: \"AES\",\n        key: 192,\n        iv: 16,\n        mode: \"CFB\",\n        type: \"stream\"\n      },\n      \"aes-256-cfb\": {\n        cipher: \"AES\",\n        key: 256,\n        iv: 16,\n        mode: \"CFB\",\n        type: \"stream\"\n      },\n      \"aes-128-cfb8\": {\n        cipher: \"AES\",\n        key: 128,\n        iv: 16,\n        mode: \"CFB8\",\n        type: \"stream\"\n      },\n      \"aes-192-cfb8\": {\n        cipher: \"AES\",\n        key: 192,\n        iv: 16,\n        mode: \"CFB8\",\n        type: \"stream\"\n      },\n      \"aes-256-cfb8\": {\n        cipher: \"AES\",\n        key: 256,\n        iv: 16,\n        mode: \"CFB8\",\n        type: \"stream\"\n      },\n      \"aes-128-cfb1\": {\n        cipher: \"AES\",\n        key: 128,\n        iv: 16,\n        mode: \"CFB1\",\n        type: \"stream\"\n      },\n      \"aes-192-cfb1\": {\n        cipher: \"AES\",\n        key: 192,\n        iv: 16,\n        mode: \"CFB1\",\n        type: \"stream\"\n      },\n      \"aes-256-cfb1\": {\n        cipher: \"AES\",\n        key: 256,\n        iv: 16,\n        mode: \"CFB1\",\n        type: \"stream\"\n      },\n      \"aes-128-ofb\": {\n        cipher: \"AES\",\n        key: 128,\n        iv: 16,\n        mode: \"OFB\",\n        type: \"stream\"\n      },\n      \"aes-192-ofb\": {\n        cipher: \"AES\",\n        key: 192,\n        iv: 16,\n        mode: \"OFB\",\n        type: \"stream\"\n      },\n      \"aes-256-ofb\": {\n        cipher: \"AES\",\n        key: 256,\n        iv: 16,\n        mode: \"OFB\",\n        type: \"stream\"\n      },\n      \"aes-128-ctr\": {\n        cipher: \"AES\",\n        key: 128,\n        iv: 16,\n        mode: \"CTR\",\n        type: \"stream\"\n      },\n      \"aes-192-ctr\": {\n        cipher: \"AES\",\n        key: 192,\n        iv: 16,\n        mode: \"CTR\",\n        type: \"stream\"\n      },\n      \"aes-256-ctr\": {\n        cipher: \"AES\",\n        key: 256,\n        iv: 16,\n        mode: \"CTR\",\n        type: \"stream\"\n      },\n      \"aes-128-gcm\": {\n        cipher: \"AES\",\n        key: 128,\n        iv: 12,\n        mode: \"GCM\",\n        type: \"auth\"\n      },\n      \"aes-192-gcm\": {\n        cipher: \"AES\",\n        key: 192,\n        iv: 12,\n        mode: \"GCM\",\n        type: \"auth\"\n      },\n      \"aes-256-gcm\": {\n        cipher: \"AES\",\n        key: 256,\n        iv: 12,\n        mode: \"GCM\",\n        type: \"auth\"\n      }\n    };\n  }\n}), require_modes = __commonJS({\n  \"node_modules/browserify-aes/modes/index.js\"(exports, module) {\n    var modeModules = {\n      ECB: require_ecb(),\n      CBC: require_cbc2(),\n      CFB: require_cfb(),\n      CFB8: require_cfb8(),\n      CFB1: require_cfb1(),\n      OFB: require_ofb(),\n      CTR: require_ctr(),\n      GCM: require_ctr()\n    }, modes = require_list();\n    for (key in modes)\n      modes[key].module = modeModules[modes[key].mode];\n    var key;\n    module.exports = modes;\n  }\n}), require_aes = __commonJS({\n  \"node_modules/browserify-aes/aes.js\"(exports, module) {\n    var Buffer2 = require_safe_buffer().Buffer;\n    function asUInt32Array(buf) {\n      Buffer2.isBuffer(buf) || (buf = Buffer2.from(buf));\n      for (var len = buf.length / 4 | 0, out = new Array(len), i = 0;i < len; i++)\n        out[i] = buf.readUInt32BE(i * 4);\n      return out;\n    }\n    function scrubVec(v) {\n      for (var i = 0;i < v.length; v++)\n        v[i] = 0;\n    }\n    function cryptBlock(M, keySchedule, SUB_MIX, SBOX, nRounds) {\n      for (var SUB_MIX0 = SUB_MIX[0], SUB_MIX1 = SUB_MIX[1], SUB_MIX2 = SUB_MIX[2], SUB_MIX3 = SUB_MIX[3], s0 = M[0] ^ keySchedule[0], s1 = M[1] ^ keySchedule[1], s2 = M[2] ^ keySchedule[2], s3 = M[3] ^ keySchedule[3], t0, t1, t2, t3, ksRow = 4, round = 1;round < nRounds; round++)\n        t0 = SUB_MIX0[s0 >>> 24] ^ SUB_MIX1[s1 >>> 16 & 255] ^ SUB_MIX2[s2 >>> 8 & 255] ^ SUB_MIX3[s3 & 255] ^ keySchedule[ksRow++], t1 = SUB_MIX0[s1 >>> 24] ^ SUB_MIX1[s2 >>> 16 & 255] ^ SUB_MIX2[s3 >>> 8 & 255] ^ SUB_MIX3[s0 & 255] ^ keySchedule[ksRow++], t2 = SUB_MIX0[s2 >>> 24] ^ SUB_MIX1[s3 >>> 16 & 255] ^ SUB_MIX2[s0 >>> 8 & 255] ^ SUB_MIX3[s1 & 255] ^ keySchedule[ksRow++], t3 = SUB_MIX0[s3 >>> 24] ^ SUB_MIX1[s0 >>> 16 & 255] ^ SUB_MIX2[s1 >>> 8 & 255] ^ SUB_MIX3[s2 & 255] ^ keySchedule[ksRow++], s0 = t0, s1 = t1, s2 = t2, s3 = t3;\n      return t0 = (SBOX[s0 >>> 24] << 24 | SBOX[s1 >>> 16 & 255] << 16 | SBOX[s2 >>> 8 & 255] << 8 | SBOX[s3 & 255]) ^ keySchedule[ksRow++], t1 = (SBOX[s1 >>> 24] << 24 | SBOX[s2 >>> 16 & 255] << 16 | SBOX[s3 >>> 8 & 255] << 8 | SBOX[s0 & 255]) ^ keySchedule[ksRow++], t2 = (SBOX[s2 >>> 24] << 24 | SBOX[s3 >>> 16 & 255] << 16 | SBOX[s0 >>> 8 & 255] << 8 | SBOX[s1 & 255]) ^ keySchedule[ksRow++], t3 = (SBOX[s3 >>> 24] << 24 | SBOX[s0 >>> 16 & 255] << 16 | SBOX[s1 >>> 8 & 255] << 8 | SBOX[s2 & 255]) ^ keySchedule[ksRow++], t0 = t0 >>> 0, t1 = t1 >>> 0, t2 = t2 >>> 0, t3 = t3 >>> 0, [t0, t1, t2, t3];\n    }\n    var RCON = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54], G = function() {\n      for (var d = new Array(256), j = 0;j < 256; j++)\n        j < 128 \? d[j] = j << 1 : d[j] = j << 1 ^ 283;\n      for (var SBOX = [], INV_SBOX = [], SUB_MIX = [[], [], [], []], INV_SUB_MIX = [[], [], [], []], x = 0, xi = 0, i = 0;i < 256; ++i) {\n        var sx = xi ^ xi << 1 ^ xi << 2 ^ xi << 3 ^ xi << 4;\n        sx = sx >>> 8 ^ sx & 255 ^ 99, SBOX[x] = sx, INV_SBOX[sx] = x;\n        var x2 = d[x], x4 = d[x2], x8 = d[x4], t = d[sx] * 257 ^ sx * 16843008;\n        SUB_MIX[0][x] = t << 24 | t >>> 8, SUB_MIX[1][x] = t << 16 | t >>> 16, SUB_MIX[2][x] = t << 8 | t >>> 24, SUB_MIX[3][x] = t, t = x8 * 16843009 ^ x4 * 65537 ^ x2 * 257 ^ x * 16843008, INV_SUB_MIX[0][sx] = t << 24 | t >>> 8, INV_SUB_MIX[1][sx] = t << 16 | t >>> 16, INV_SUB_MIX[2][sx] = t << 8 | t >>> 24, INV_SUB_MIX[3][sx] = t, x === 0 \? x = xi = 1 : (x = x2 ^ d[d[d[x8 ^ x2]]], xi ^= d[d[xi]]);\n      }\n      return {\n        SBOX,\n        INV_SBOX,\n        SUB_MIX,\n        INV_SUB_MIX\n      };\n    }();\n    function AES(key) {\n      this._key = asUInt32Array(key), this._reset();\n    }\n    AES.prototype = {}, AES.blockSize = 16, AES.keySize = 32, AES.prototype.blockSize = AES.blockSize, AES.prototype.keySize = AES.keySize, AES.prototype._reset = function() {\n      for (var keyWords = this._key, keySize = keyWords.length, nRounds = keySize + 6, ksRows = (nRounds + 1) * 4, keySchedule = [], k = 0;k < keySize; k++)\n        keySchedule[k] = keyWords[k];\n      for (k = keySize;k < ksRows; k++) {\n        var t = keySchedule[k - 1];\n        k % keySize === 0 \? (t = t << 8 | t >>> 24, t = G.SBOX[t >>> 24] << 24 | G.SBOX[t >>> 16 & 255] << 16 | G.SBOX[t >>> 8 & 255] << 8 | G.SBOX[t & 255], t ^= RCON[k / keySize | 0] << 24) : keySize > 6 && k % keySize === 4 && (t = G.SBOX[t >>> 24] << 24 | G.SBOX[t >>> 16 & 255] << 16 | G.SBOX[t >>> 8 & 255] << 8 | G.SBOX[t & 255]), keySchedule[k] = keySchedule[k - keySize] ^ t;\n      }\n      for (var invKeySchedule = [], ik = 0;ik < ksRows; ik++) {\n        var ksR = ksRows - ik, tt = keySchedule[ksR - (ik % 4 \? 0 : 4)];\n        ik < 4 || ksR <= 4 \? invKeySchedule[ik] = tt : invKeySchedule[ik] = G.INV_SUB_MIX[0][G.SBOX[tt >>> 24]] ^ G.INV_SUB_MIX[1][G.SBOX[tt >>> 16 & 255]] ^ G.INV_SUB_MIX[2][G.SBOX[tt >>> 8 & 255]] ^ G.INV_SUB_MIX[3][G.SBOX[tt & 255]];\n      }\n      this._nRounds = nRounds, this._keySchedule = keySchedule, this._invKeySchedule = invKeySchedule;\n    }, AES.prototype.encryptBlockRaw = function(M) {\n      return M = asUInt32Array(M), cryptBlock(M, this._keySchedule, G.SUB_MIX, G.SBOX, this._nRounds);\n    }, AES.prototype.encryptBlock = function(M) {\n      var out = this.encryptBlockRaw(M), buf = Buffer2.allocUnsafe(16);\n      return buf.writeUInt32BE(out[0], 0), buf.writeUInt32BE(out[1], 4), buf.writeUInt32BE(out[2], 8), buf.writeUInt32BE(out[3], 12), buf;\n    }, AES.prototype.decryptBlock = function(M) {\n      M = asUInt32Array(M);\n      var m1 = M[1];\n      M[1] = M[3], M[3] = m1;\n      var out = cryptBlock(M, this._invKeySchedule, G.INV_SUB_MIX, G.INV_SBOX, this._nRounds), buf = Buffer2.allocUnsafe(16);\n      return buf.writeUInt32BE(out[0], 0), buf.writeUInt32BE(out[3], 4), buf.writeUInt32BE(out[2], 8), buf.writeUInt32BE(out[1], 12), buf;\n    }, AES.prototype.scrub = function() {\n      scrubVec(this._keySchedule), scrubVec(this._invKeySchedule), scrubVec(this._key);\n    }, module.exports.AES = AES;\n  }\n}), require_ghash = __commonJS({\n  \"node_modules/browserify-aes/ghash.js\"(exports, module) {\n    var Buffer2 = require_safe_buffer().Buffer, ZEROES = Buffer2.alloc(16, 0);\n    function toArray(buf) {\n      return [buf.readUInt32BE(0), buf.readUInt32BE(4), buf.readUInt32BE(8), buf.readUInt32BE(12)];\n    }\n    function fromArray(out) {\n      var buf = Buffer2.allocUnsafe(16);\n      return buf.writeUInt32BE(out[0] >>> 0, 0), buf.writeUInt32BE(out[1] >>> 0, 4), buf.writeUInt32BE(out[2] >>> 0, 8), buf.writeUInt32BE(out[3] >>> 0, 12), buf;\n    }\n    function GHASH(key) {\n      this.h = key, this.state = Buffer2.alloc(16, 0), this.cache = Buffer2.allocUnsafe(0);\n    }\n    GHASH.prototype = {}, GHASH.prototype.ghash = function(block) {\n      for (var i = -1;++i < block.length; )\n        this.state[i] ^= block[i];\n      this._multiply();\n    }, GHASH.prototype._multiply = function() {\n      for (var Vi = toArray(this.h), Zi = [0, 0, 0, 0], j, xi, lsbVi, i = -1;++i < 128; ) {\n        for (xi = (this.state[~~(i / 8)] & 1 << 7 - i % 8) !== 0, xi && (Zi[0] ^= Vi[0], Zi[1] ^= Vi[1], Zi[2] ^= Vi[2], Zi[3] ^= Vi[3]), lsbVi = (Vi[3] & 1) !== 0, j = 3;j > 0; j--)\n          Vi[j] = Vi[j] >>> 1 | (Vi[j - 1] & 1) << 31;\n        Vi[0] = Vi[0] >>> 1, lsbVi && (Vi[0] = Vi[0] ^ 225 << 24);\n      }\n      this.state = fromArray(Zi);\n    }, GHASH.prototype.update = function(buf) {\n      this.cache = Buffer2.concat([this.cache, buf]);\n      for (var chunk;this.cache.length >= 16; )\n        chunk = this.cache.slice(0, 16), this.cache = this.cache.slice(16), this.ghash(chunk);\n    }, GHASH.prototype.final = function(abl, bl) {\n      return this.cache.length && this.ghash(Buffer2.concat([this.cache, ZEROES], 16)), this.ghash(fromArray([0, abl, 0, bl])), this.state;\n    }, module.exports = GHASH;\n  }\n}), require_authCipher = __commonJS({\n  \"node_modules/browserify-aes/authCipher.js\"(exports, module) {\n    var aes = require_aes(), Buffer2 = require_safe_buffer().Buffer, Transform = require_cipher_base(), inherits = require_inherits_browser(), GHASH = require_ghash(), xor = require_buffer_xor(), incr32 = require_incr32();\n    function xorTest(a, b) {\n      var out = 0;\n      a.length !== b.length && out++;\n      for (var len = Math.min(a.length, b.length), i = 0;i < len; ++i)\n        out += a[i] ^ b[i];\n      return out;\n    }\n    function calcIv(self2, iv, ck) {\n      if (iv.length === 12)\n        return self2._finID = Buffer2.concat([iv, Buffer2.from([0, 0, 0, 1])]), Buffer2.concat([iv, Buffer2.from([0, 0, 0, 2])]);\n      var ghash = new GHASH(ck), len = iv.length, toPad = len % 16;\n      ghash.update(iv), toPad && (toPad = 16 - toPad, ghash.update(Buffer2.alloc(toPad, 0))), ghash.update(Buffer2.alloc(8, 0));\n      var ivBits = len * 8, tail = Buffer2.alloc(8);\n      tail.writeUIntBE(ivBits, 0, 8), ghash.update(tail), self2._finID = ghash.state;\n      var out = Buffer2.from(self2._finID);\n      return incr32(out), out;\n    }\n    function StreamCipher(mode, key, iv, decrypt) {\n      Transform.call(this);\n      var h = Buffer2.alloc(4, 0);\n      this._cipher = new aes.AES(key);\n      var ck = this._cipher.encryptBlock(h);\n      this._ghash = new GHASH(ck), iv = calcIv(this, iv, ck), this._prev = Buffer2.from(iv), this._cache = Buffer2.allocUnsafe(0), this._secCache = Buffer2.allocUnsafe(0), this._decrypt = decrypt, this._alen = 0, this._len = 0, this._mode = mode, this._authTag = null, this._called = !1;\n    }\n    inherits(StreamCipher, Transform), StreamCipher.prototype._update = function(chunk) {\n      if (!this._called && this._alen) {\n        var rump = 16 - this._alen % 16;\n        rump < 16 && (rump = Buffer2.alloc(rump, 0), this._ghash.update(rump));\n      }\n      this._called = !0;\n      var out = this._mode.encrypt(this, chunk);\n      return this._decrypt \? this._ghash.update(chunk) : this._ghash.update(out), this._len += chunk.length, out;\n    }, StreamCipher.prototype._final = function() {\n      if (this._decrypt && !this._authTag)\n        throw new Error(\"Unsupported state or unable to authenticate data\");\n      var tag = xor(this._ghash.final(this._alen * 8, this._len * 8), this._cipher.encryptBlock(this._finID));\n      if (this._decrypt && xorTest(tag, this._authTag))\n        throw new Error(\"Unsupported state or unable to authenticate data\");\n      this._authTag = tag, this._cipher.scrub();\n    }, StreamCipher.prototype.getAuthTag = function() {\n      if (this._decrypt || !Buffer2.isBuffer(this._authTag))\n        throw new Error(\"Attempting to get auth tag in unsupported state\");\n      return this._authTag;\n    }, StreamCipher.prototype.setAuthTag = function(tag) {\n      if (!this._decrypt)\n        throw new Error(\"Attempting to set auth tag in unsupported state\");\n      this._authTag = tag;\n    }, StreamCipher.prototype.setAAD = function(buf) {\n      if (this._called)\n        throw new Error(\"Attempting to set AAD in unsupported state\");\n      this._ghash.update(buf), this._alen += buf.length;\n    }, module.exports = StreamCipher;\n  }\n}), require_streamCipher = __commonJS({\n  \"node_modules/browserify-aes/streamCipher.js\"(exports, module) {\n    var aes = require_aes(), Buffer2 = require_safe_buffer().Buffer, Transform = require_cipher_base(), inherits = require_inherits_browser();\n    function StreamCipher(mode, key, iv, decrypt) {\n      Transform.call(this), this._cipher = new aes.AES(key), this._prev = Buffer2.from(iv), this._cache = Buffer2.allocUnsafe(0), this._secCache = Buffer2.allocUnsafe(0), this._decrypt = decrypt, this._mode = mode;\n    }\n    inherits(StreamCipher, Transform), StreamCipher.prototype._update = function(chunk) {\n      return this._mode.encrypt(this, chunk, this._decrypt);\n    }, StreamCipher.prototype._final = function() {\n      this._cipher.scrub();\n    }, module.exports = StreamCipher;\n  }\n}), require_evp_bytestokey = __commonJS({\n  \"node_modules/evp_bytestokey/index.js\"(exports, module) {\n    var Buffer2 = require_safe_buffer().Buffer, MD5 = require_md5();\n    function EVP_BytesToKey(password, salt, keyBits, ivLen) {\n      if (Buffer2.isBuffer(password) || (password = Buffer2.from(password, \"binary\")), salt && (Buffer2.isBuffer(salt) || (salt = Buffer2.from(salt, \"binary\")), salt.length !== 8))\n        @throwRangeError(\"salt should be Buffer with 8 byte length\");\n      for (var keyLen = keyBits / 8, key = Buffer2.alloc(keyLen), iv = Buffer2.alloc(ivLen || 0), tmp = Buffer2.alloc(0);keyLen > 0 || ivLen > 0; ) {\n        var hash = new MD5;\n        hash.update(tmp), hash.update(password), salt && hash.update(salt), tmp = hash.digest();\n        var used = 0;\n        if (keyLen > 0) {\n          var keyStart = key.length - keyLen;\n          used = Math.min(keyLen, tmp.length), tmp.copy(key, keyStart, 0, used), keyLen -= used;\n        }\n        if (used < tmp.length && ivLen > 0) {\n          var ivStart = iv.length - ivLen, length = Math.min(ivLen, tmp.length - used);\n          tmp.copy(iv, ivStart, used, used + length), ivLen -= length;\n        }\n      }\n      return tmp.fill(0), { key, iv };\n    }\n    module.exports = EVP_BytesToKey;\n  }\n}), require_encrypter = __commonJS({\n  \"node_modules/browserify-aes/encrypter.js\"(exports) {\n    var MODES = require_modes(), AuthCipher = require_authCipher(), Buffer2 = require_safe_buffer().Buffer, StreamCipher = require_streamCipher(), Transform = require_cipher_base(), aes = require_aes(), ebtk = require_evp_bytestokey(), inherits = require_inherits_browser();\n    function Cipher(mode, key, iv) {\n      Transform.call(this), this._cache = new Splitter, this._cipher = new aes.AES(key), this._prev = Buffer2.from(iv), this._mode = mode, this._autopadding = !0;\n    }\n    inherits(Cipher, Transform), Cipher.prototype._update = function(data) {\n      this._cache.add(data);\n      for (var chunk, thing, out = [];chunk = this._cache.get(); )\n        thing = this._mode.encrypt(this, chunk), out.push(thing);\n      return Buffer2.concat(out);\n    };\n    var PADDING = Buffer2.alloc(16, 16);\n    Cipher.prototype._final = function() {\n      var chunk = this._cache.flush();\n      if (this._autopadding)\n        return chunk = this._mode.encrypt(this, chunk), this._cipher.scrub(), chunk;\n      if (!chunk.equals(PADDING))\n        throw this._cipher.scrub(), new Error(\"data not multiple of block length\");\n    }, Cipher.prototype.setAutoPadding = function(setTo) {\n      return this._autopadding = !!setTo, this;\n    };\n    function Splitter() {\n      this.cache = Buffer2.allocUnsafe(0);\n    }\n    Splitter.prototype = {}, Splitter.prototype.add = function(data) {\n      this.cache = Buffer2.concat([this.cache, data]);\n    }, Splitter.prototype.get = function() {\n      if (this.cache.length > 15) {\n        var out = this.cache.slice(0, 16);\n        return this.cache = this.cache.slice(16), out;\n      }\n      return null;\n    }, Splitter.prototype.flush = function() {\n      for (var len = 16 - this.cache.length, padBuff = Buffer2.allocUnsafe(len), i = -1;++i < len; )\n        padBuff.writeUInt8(len, i);\n      return Buffer2.concat([this.cache, padBuff]);\n    };\n    function createCipheriv(suite, password, iv) {\n      var config = MODES[suite.toLowerCase()];\n      if (!config)\n        @throwTypeError(\"invalid suite type\");\n      password = getArrayBufferOrView(password, \"password\");\n      const iv_length = iv\?.length || 0, required_iv_length = config.iv || 0;\n      if (iv = iv === null \? EMPTY_BUFFER : getArrayBufferOrView(iv, \"iv\"), password\?.length !== config.key / 8) {\n        var error = new RangeError(\"Invalid key length\");\n        throw error.code = \"ERR_CRYPTO_INVALID_KEYLEN\", error;\n      }\n      if (config.mode !== \"GCM\" && iv_length !== required_iv_length) {\n        var error = new RangeError(\"Invalid key length\");\n        throw error.code = \"ERR_CRYPTO_INVALID_KEYLEN\", error;\n      }\n      return config.type === \"stream\" \? new StreamCipher(config.module, password, iv) : config.type === \"auth\" \? new AuthCipher(config.module, password, iv) : new Cipher(config.module, password, iv);\n    }\n    function createCipher(suite, password) {\n      var config = MODES[suite.toLowerCase()];\n      if (!config)\n        @throwTypeError(\"invalid suite type\");\n      var keys = ebtk(password, !1, config.key, config.iv);\n      return createCipheriv(suite, keys.key, keys.iv);\n    }\n    exports.createCipheriv = createCipheriv, exports.createCipher = createCipher;\n  }\n}), require_decrypter = __commonJS({\n  \"node_modules/browserify-aes/decrypter.js\"(exports) {\n    var AuthCipher = require_authCipher(), Buffer2 = require_safe_buffer().Buffer, MODES = require_modes(), StreamCipher = require_streamCipher(), Transform = require_cipher_base(), aes = require_aes(), ebtk = require_evp_bytestokey(), inherits = require_inherits_browser();\n    function Decipher(mode, key, iv) {\n      Transform.call(this), this._cache = new Splitter, this._last = void 0, this._cipher = new aes.AES(key), this._prev = Buffer2.from(iv), this._mode = mode, this._autopadding = !0;\n    }\n    inherits(Decipher, Transform), Decipher.prototype._update = function(data) {\n      this._cache.add(data);\n      for (var chunk, thing, out = [];chunk = this._cache.get(this._autopadding); )\n        thing = this._mode.decrypt(this, chunk), out.push(thing);\n      return Buffer2.concat(out);\n    }, Decipher.prototype._final = function() {\n      var chunk = this._cache.flush();\n      if (this._autopadding)\n        return unpad(this._mode.decrypt(this, chunk));\n      if (chunk)\n        throw new Error(\"data not multiple of block length\");\n    }, Decipher.prototype.setAutoPadding = function(setTo) {\n      return this._autopadding = !!setTo, this;\n    };\n    function Splitter() {\n      this.cache = Buffer2.allocUnsafe(0);\n    }\n    Splitter.prototype = {}, Splitter.prototype.add = function(data) {\n      this.cache = Buffer2.concat([this.cache, data]);\n    }, Splitter.prototype.get = function(autoPadding) {\n      var out;\n      if (autoPadding) {\n        if (this.cache.length > 16)\n          return out = this.cache.slice(0, 16), this.cache = this.cache.slice(16), out;\n      } else if (this.cache.length >= 16)\n        return out = this.cache.slice(0, 16), this.cache = this.cache.slice(16), out;\n      return null;\n    }, Splitter.prototype.flush = function() {\n      if (this.cache.length)\n        return this.cache;\n    };\n    function unpad(last) {\n      var padded = last[15];\n      if (padded < 1 || padded > 16)\n        throw new Error(\"unable to decrypt data\");\n      for (var i = -1;++i < padded; )\n        if (last[i + (16 - padded)] !== padded)\n          throw new Error(\"unable to decrypt data\");\n      if (padded !== 16)\n        return last.slice(0, 16 - padded);\n    }\n    function createDecipheriv(suite, password, iv) {\n      var config = MODES[suite.toLowerCase()];\n      if (!config)\n        @throwTypeError(\"invalid suite type\");\n      password = getArrayBufferOrView(password, \"password\");\n      const iv_length = iv\?.length || 0, required_iv_length = config.iv || 0;\n      if (iv = iv === null \? EMPTY_BUFFER : getArrayBufferOrView(iv, \"iv\"), config.mode !== \"GCM\" && iv_length !== required_iv_length) {\n        var error = new RangeError(\"Invalid key length\");\n        throw error.code = \"ERR_CRYPTO_INVALID_KEYLEN\", error;\n      }\n      if (password.length !== config.key / 8) {\n        var error = new RangeError(\"Invalid key length\");\n        throw error.code = \"ERR_CRYPTO_INVALID_KEYLEN\", error;\n      }\n      return config.type === \"stream\" \? new StreamCipher(config.module, password, iv, !0) : config.type === \"auth\" \? new AuthCipher(config.module, password, iv, !0) : new Decipher(config.module, password, iv);\n    }\n    function createDecipher(suite, password) {\n      var config = MODES[suite.toLowerCase()];\n      if (!config)\n        @throwTypeError(\"invalid suite type\");\n      var keys = ebtk(password, !1, config.key, config.iv);\n      return createDecipheriv(suite, keys.key, keys.iv);\n    }\n    exports.createDecipher = createDecipher, exports.createDecipheriv = createDecipheriv;\n  }\n}), require_browser5 = __commonJS({\n  \"node_modules/browserify-aes/browser.js\"(exports) {\n    var ciphers = require_encrypter(), deciphers = require_decrypter(), modes = require_list();\n    function getCiphers() {\n      return Object.keys(modes);\n    }\n    exports.createCipher = exports.Cipher = ciphers.createCipher, exports.createCipheriv = exports.Cipheriv = ciphers.createCipheriv, exports.createDecipher = exports.Decipher = deciphers.createDecipher, exports.createDecipheriv = exports.Decipheriv = deciphers.createDecipheriv, exports.listCiphers = exports.getCiphers = getCiphers;\n  }\n}), require_modes2 = __commonJS({\n  \"node_modules/browserify-des/modes.js\"(exports) {\n    exports[\"des-ecb\"] = {\n      key: 8,\n      iv: 0\n    }, exports[\"des-cbc\"] = exports.des = {\n      key: 8,\n      iv: 8\n    }, exports[\"des-ede3-cbc\"] = exports.des3 = {\n      key: 24,\n      iv: 8\n    }, exports[\"des-ede3\"] = {\n      key: 24,\n      iv: 0\n    }, exports[\"des-ede-cbc\"] = {\n      key: 16,\n      iv: 8\n    }, exports[\"des-ede\"] = {\n      key: 16,\n      iv: 0\n    };\n  }\n}), require_browser6 = __commonJS({\n  \"node_modules/browserify-cipher/browser.js\"(exports) {\n    var DES = require_browserify_des(), aes = require_browser5(), aesModes = require_modes(), desModes = require_modes2(), ebtk = require_evp_bytestokey();\n    function createCipher(suite, password) {\n      suite = suite.toLowerCase();\n      var keyLen, ivLen;\n      if (aesModes[suite])\n        keyLen = aesModes[suite].key, ivLen = aesModes[suite].iv;\n      else if (desModes[suite])\n        keyLen = desModes[suite].key * 8, ivLen = desModes[suite].iv;\n      else\n        @throwTypeError(\"invalid suite type\");\n      var keys = ebtk(password, !1, keyLen, ivLen);\n      return createCipheriv(suite, keys.key, keys.iv);\n    }\n    function createDecipher(suite, password) {\n      suite = suite.toLowerCase();\n      var keyLen, ivLen;\n      if (aesModes[suite])\n        keyLen = aesModes[suite].key, ivLen = aesModes[suite].iv;\n      else if (desModes[suite])\n        keyLen = desModes[suite].key * 8, ivLen = desModes[suite].iv;\n      else\n        @throwTypeError(\"invalid suite type\");\n      var keys = ebtk(password, !1, keyLen, ivLen);\n      return createDecipheriv(suite, keys.key, keys.iv);\n    }\n    function createCipheriv(suite, key, iv) {\n      if (suite = suite.toLowerCase(), aesModes[suite])\n        return aes.createCipheriv(suite, key, iv);\n      if (desModes[suite])\n        return new DES({ key, iv, mode: suite });\n      @throwTypeError(\"invalid suite type\");\n    }\n    function createDecipheriv(suite, key, iv) {\n      if (suite = suite.toLowerCase(), aesModes[suite])\n        return aes.createDecipheriv(suite, key, iv);\n      if (desModes[suite])\n        return new DES({ key, iv, mode: suite, decrypt: !0 });\n      @throwTypeError(\"invalid suite type\");\n    }\n    function getCiphers() {\n      return Object.keys(desModes).concat(aes.getCiphers());\n    }\n    exports.createCipher = exports.Cipher = createCipher, exports.createCipheriv = exports.Cipheriv = createCipheriv, exports.createDecipher = exports.Decipher = createDecipher, exports.createDecipheriv = exports.Decipheriv = createDecipheriv, exports.listCiphers = exports.getCiphers = getCiphers;\n  }\n}), require_bn = __commonJS({\n  \"node_modules/diffie-hellman/node_modules/bn.js/lib/bn.js\"(exports, module) {\n    (function(module2, exports2) {\n      function assert(val, msg) {\n        if (!val)\n          throw new Error(msg || \"Assertion failed\");\n      }\n      function inherits(ctor, superCtor) {\n        ctor.super_ = superCtor;\n        var TempCtor = function() {\n        };\n        TempCtor.prototype = superCtor.prototype, ctor.prototype = new TempCtor, ctor.prototype.constructor = ctor;\n      }\n      function BN(number, base, endian) {\n        if (BN.isBN(number))\n          return number;\n        this.negative = 0, this.words = null, this.length = 0, this.red = null, number !== null && ((base === \"le\" || base === \"be\") && (endian = base, base = 10), this._init(number || 0, base || 10, endian || \"be\"));\n      }\n      BN.prototype = {}, typeof module2 == \"object\" \? module2.exports = BN : exports2.BN = BN, BN.BN = BN, BN.wordSize = 26;\n      var Buffer2 = Buffer;\n      BN.isBN = function(num) {\n        return num instanceof BN \? !0 : num !== null && typeof num == \"object\" && num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);\n      }, BN.max = function(left, right) {\n        return left.cmp(right) > 0 \? left : right;\n      }, BN.min = function(left, right) {\n        return left.cmp(right) < 0 \? left : right;\n      }, BN.prototype._init = function(number, base, endian) {\n        if (typeof number == \"number\")\n          return this._initNumber(number, base, endian);\n        if (typeof number == \"object\")\n          return this._initArray(number, base, endian);\n        base === \"hex\" && (base = 16), assert(base === (base | 0) && base >= 2 && base <= 36), number = number.toString().replace(/\\s+/g, \"\");\n        var start = 0;\n        number[0] === \"-\" && (start++, this.negative = 1), start < number.length && (base === 16 \? this._parseHex(number, start, endian) : (this._parseBase(number, base, start), endian === \"le\" && this._initArray(this.toArray(), base, endian)));\n      }, BN.prototype._initNumber = function(number, base, endian) {\n        number < 0 && (this.negative = 1, number = -number), number < 67108864 \? (this.words = [number & 67108863], this.length = 1) : number < 4503599627370496 \? (this.words = [number & 67108863, number / 67108864 & 67108863], this.length = 2) : (assert(number < 9007199254740992), this.words = [number & 67108863, number / 67108864 & 67108863, 1], this.length = 3), endian === \"le\" && this._initArray(this.toArray(), base, endian);\n      }, BN.prototype._initArray = function(number, base, endian) {\n        if (assert(typeof number.length == \"number\"), number.length <= 0)\n          return this.words = [0], this.length = 1, this;\n        this.length = Math.ceil(number.length / 3), this.words = new Array(this.length);\n        for (var i = 0;i < this.length; i++)\n          this.words[i] = 0;\n        var j, w, off = 0;\n        if (endian === \"be\")\n          for (i = number.length - 1, j = 0;i >= 0; i -= 3)\n            w = number[i] | number[i - 1] << 8 | number[i - 2] << 16, this.words[j] |= w << off & 67108863, this.words[j + 1] = w >>> 26 - off & 67108863, off += 24, off >= 26 && (off -= 26, j++);\n        else if (endian === \"le\")\n          for (i = 0, j = 0;i < number.length; i += 3)\n            w = number[i] | number[i + 1] << 8 | number[i + 2] << 16, this.words[j] |= w << off & 67108863, this.words[j + 1] = w >>> 26 - off & 67108863, off += 24, off >= 26 && (off -= 26, j++);\n        return this.strip();\n      };\n      function parseHex4Bits(string, index) {\n        var c = string.charCodeAt(index);\n        return c >= 65 && c <= 70 \? c - 55 : c >= 97 && c <= 102 \? c - 87 : c - 48 & 15;\n      }\n      function parseHexByte(string, lowerBound, index) {\n        var r = parseHex4Bits(string, index);\n        return index - 1 >= lowerBound && (r |= parseHex4Bits(string, index - 1) << 4), r;\n      }\n      BN.prototype._parseHex = function(number, start, endian) {\n        this.length = Math.ceil((number.length - start) / 6), this.words = new Array(this.length);\n        for (var i = 0;i < this.length; i++)\n          this.words[i] = 0;\n        var off = 0, j = 0, w;\n        if (endian === \"be\")\n          for (i = number.length - 1;i >= start; i -= 2)\n            w = parseHexByte(number, start, i) << off, this.words[j] |= w & 67108863, off >= 18 \? (off -= 18, j += 1, this.words[j] |= w >>> 26) : off += 8;\n        else {\n          var parseLength = number.length - start;\n          for (i = parseLength % 2 === 0 \? start + 1 : start;i < number.length; i += 2)\n            w = parseHexByte(number, start, i) << off, this.words[j] |= w & 67108863, off >= 18 \? (off -= 18, j += 1, this.words[j] |= w >>> 26) : off += 8;\n        }\n        this.strip();\n      };\n      function parseBase(str, start, end, mul) {\n        for (var r = 0, len = Math.min(str.length, end), i = start;i < len; i++) {\n          var c = str.charCodeAt(i) - 48;\n          r *= mul, c >= 49 \? r += c - 49 + 10 : c >= 17 \? r += c - 17 + 10 : r += c;\n        }\n        return r;\n      }\n      BN.prototype._parseBase = function(number, base, start) {\n        this.words = [0], this.length = 1;\n        for (var limbLen = 0, limbPow = 1;limbPow <= 67108863; limbPow *= base)\n          limbLen++;\n        limbLen--, limbPow = limbPow / base | 0;\n        for (var total = number.length - start, mod = total % limbLen, end = Math.min(total, total - mod) + start, word = 0, i = start;i < end; i += limbLen)\n          word = parseBase(number, i, i + limbLen, base), this.imuln(limbPow), this.words[0] + word < 67108864 \? this.words[0] += word : this._iaddn(word);\n        if (mod !== 0) {\n          var pow = 1;\n          for (word = parseBase(number, i, number.length, base), i = 0;i < mod; i++)\n            pow *= base;\n          this.imuln(pow), this.words[0] + word < 67108864 \? this.words[0] += word : this._iaddn(word);\n        }\n        this.strip();\n      }, BN.prototype.copy = function(dest) {\n        dest.words = new Array(this.length);\n        for (var i = 0;i < this.length; i++)\n          dest.words[i] = this.words[i];\n        dest.length = this.length, dest.negative = this.negative, dest.red = this.red;\n      }, BN.prototype.clone = function() {\n        var r = new BN(null);\n        return this.copy(r), r;\n      }, BN.prototype._expand = function(size) {\n        for (;this.length < size; )\n          this.words[this.length++] = 0;\n        return this;\n      }, BN.prototype.strip = function() {\n        for (;this.length > 1 && this.words[this.length - 1] === 0; )\n          this.length--;\n        return this._normSign();\n      }, BN.prototype._normSign = function() {\n        return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;\n      }, BN.prototype.inspect = function() {\n        return (this.red \? \"<BN-R: \" : \"<BN: \") + this.toString(16) + \">\";\n      };\n      var zeros = [\n        \"\",\n        \"0\",\n        \"00\",\n        \"000\",\n        \"0000\",\n        \"00000\",\n        \"000000\",\n        \"0000000\",\n        \"00000000\",\n        \"000000000\",\n        \"0000000000\",\n        \"00000000000\",\n        \"000000000000\",\n        \"0000000000000\",\n        \"00000000000000\",\n        \"000000000000000\",\n        \"0000000000000000\",\n        \"00000000000000000\",\n        \"000000000000000000\",\n        \"0000000000000000000\",\n        \"00000000000000000000\",\n        \"000000000000000000000\",\n        \"0000000000000000000000\",\n        \"00000000000000000000000\",\n        \"000000000000000000000000\",\n        \"0000000000000000000000000\"\n      ], groupSizes = [\n        0,\n        0,\n        25,\n        16,\n        12,\n        11,\n        10,\n        9,\n        8,\n        8,\n        7,\n        7,\n        7,\n        7,\n        6,\n        6,\n        6,\n        6,\n        6,\n        6,\n        6,\n        5,\n        5,\n        5,\n        5,\n        5,\n        5,\n        5,\n        5,\n        5,\n        5,\n        5,\n        5,\n        5,\n        5,\n        5,\n        5\n      ], groupBases = [\n        0,\n        0,\n        33554432,\n        43046721,\n        16777216,\n        48828125,\n        60466176,\n        40353607,\n        16777216,\n        43046721,\n        1e7,\n        19487171,\n        35831808,\n        62748517,\n        7529536,\n        11390625,\n        16777216,\n        24137569,\n        34012224,\n        47045881,\n        64000000,\n        4084101,\n        5153632,\n        6436343,\n        7962624,\n        9765625,\n        11881376,\n        14348907,\n        17210368,\n        20511149,\n        24300000,\n        28629151,\n        33554432,\n        39135393,\n        45435424,\n        52521875,\n        60466176\n      ];\n      BN.prototype.toString = function(base, padding) {\n        base = base || 10, padding = padding | 0 || 1;\n        var out;\n        if (base === 16 || base === \"hex\") {\n          out = \"\";\n          for (var off = 0, carry = 0, i = 0;i < this.length; i++) {\n            var w = this.words[i], word = ((w << off | carry) & 16777215).toString(16);\n            carry = w >>> 24 - off & 16777215, carry !== 0 || i !== this.length - 1 \? out = zeros[6 - word.length] + word + out : out = word + out, off += 2, off >= 26 && (off -= 26, i--);\n          }\n          for (carry !== 0 && (out = carry.toString(16) + out);out.length % padding !== 0; )\n            out = \"0\" + out;\n          return this.negative !== 0 && (out = \"-\" + out), out;\n        }\n        if (base === (base | 0) && base >= 2 && base <= 36) {\n          var groupSize = groupSizes[base], groupBase = groupBases[base];\n          out = \"\";\n          var c = this.clone();\n          for (c.negative = 0;!c.isZero(); ) {\n            var r = c.modn(groupBase).toString(base);\n            c = c.idivn(groupBase), c.isZero() \? out = r + out : out = zeros[groupSize - r.length] + r + out;\n          }\n          for (this.isZero() && (out = \"0\" + out);out.length % padding !== 0; )\n            out = \"0\" + out;\n          return this.negative !== 0 && (out = \"-\" + out), out;\n        }\n        assert(!1, \"Base should be between 2 and 36\");\n      }, BN.prototype.toNumber = function() {\n        var ret = this.words[0];\n        return this.length === 2 \? ret += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 \? ret += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && assert(!1, \"Number can only safely store up to 53 bits\"), this.negative !== 0 \? -ret : ret;\n      }, BN.prototype.toJSON = function() {\n        return this.toString(16);\n      }, BN.prototype.toBuffer = function(endian, length) {\n        return assert(typeof Buffer2 < \"u\"), this.toArrayLike(Buffer2, endian, length);\n      }, BN.prototype.toArray = function(endian, length) {\n        return this.toArrayLike(Array, endian, length);\n      }, BN.prototype.toArrayLike = function(ArrayType, endian, length) {\n        var byteLength = this.byteLength(), reqLength = length || Math.max(1, byteLength);\n        assert(byteLength <= reqLength, \"byte array longer than desired length\"), assert(reqLength > 0, \"Requested array length <= 0\"), this.strip();\n        var littleEndian = endian === \"le\", res = new ArrayType(reqLength), b, i, q = this.clone();\n        if (littleEndian) {\n          for (i = 0;!q.isZero(); i++)\n            b = q.andln(255), q.iushrn(8), res[i] = b;\n          for (;i < reqLength; i++)\n            res[i] = 0;\n        } else {\n          for (i = 0;i < reqLength - byteLength; i++)\n            res[i] = 0;\n          for (i = 0;!q.isZero(); i++)\n            b = q.andln(255), q.iushrn(8), res[reqLength - i - 1] = b;\n        }\n        return res;\n      }, Math.clz32 \? BN.prototype._countBits = function(w) {\n        return 32 - Math.clz32(w);\n      } : BN.prototype._countBits = function(w) {\n        var t = w, r = 0;\n        return t >= 4096 && (r += 13, t >>>= 13), t >= 64 && (r += 7, t >>>= 7), t >= 8 && (r += 4, t >>>= 4), t >= 2 && (r += 2, t >>>= 2), r + t;\n      }, BN.prototype._zeroBits = function(w) {\n        if (w === 0)\n          return 26;\n        var t = w, r = 0;\n        return (t & 8191) === 0 && (r += 13, t >>>= 13), (t & 127) === 0 && (r += 7, t >>>= 7), (t & 15) === 0 && (r += 4, t >>>= 4), (t & 3) === 0 && (r += 2, t >>>= 2), (t & 1) === 0 && r++, r;\n      }, BN.prototype.bitLength = function() {\n        var w = this.words[this.length - 1], hi = this._countBits(w);\n        return (this.length - 1) * 26 + hi;\n      };\n      function toBitArray(num) {\n        for (var w = new Array(num.bitLength()), bit = 0;bit < w.length; bit++) {\n          var off = bit / 26 | 0, wbit = bit % 26;\n          w[bit] = (num.words[off] & 1 << wbit) >>> wbit;\n        }\n        return w;\n      }\n      BN.prototype.zeroBits = function() {\n        if (this.isZero())\n          return 0;\n        for (var r = 0, i = 0;i < this.length; i++) {\n          var b = this._zeroBits(this.words[i]);\n          if (r += b, b !== 26)\n            break;\n        }\n        return r;\n      }, BN.prototype.byteLength = function() {\n        return Math.ceil(this.bitLength() / 8);\n      }, BN.prototype.toTwos = function(width) {\n        return this.negative !== 0 \? this.abs().inotn(width).iaddn(1) : this.clone();\n      }, BN.prototype.fromTwos = function(width) {\n        return this.testn(width - 1) \? this.notn(width).iaddn(1).ineg() : this.clone();\n      }, BN.prototype.isNeg = function() {\n        return this.negative !== 0;\n      }, BN.prototype.neg = function() {\n        return this.clone().ineg();\n      }, BN.prototype.ineg = function() {\n        return this.isZero() || (this.negative ^= 1), this;\n      }, BN.prototype.iuor = function(num) {\n        for (;this.length < num.length; )\n          this.words[this.length++] = 0;\n        for (var i = 0;i < num.length; i++)\n          this.words[i] = this.words[i] | num.words[i];\n        return this.strip();\n      }, BN.prototype.ior = function(num) {\n        return assert((this.negative | num.negative) === 0), this.iuor(num);\n      }, BN.prototype.or = function(num) {\n        return this.length > num.length \? this.clone().ior(num) : num.clone().ior(this);\n      }, BN.prototype.uor = function(num) {\n        return this.length > num.length \? this.clone().iuor(num) : num.clone().iuor(this);\n      }, BN.prototype.iuand = function(num) {\n        var b;\n        this.length > num.length \? b = num : b = this;\n        for (var i = 0;i < b.length; i++)\n          this.words[i] = this.words[i] & num.words[i];\n        return this.length = b.length, this.strip();\n      }, BN.prototype.iand = function(num) {\n        return assert((this.negative | num.negative) === 0), this.iuand(num);\n      }, BN.prototype.and = function(num) {\n        return this.length > num.length \? this.clone().iand(num) : num.clone().iand(this);\n      }, BN.prototype.uand = function(num) {\n        return this.length > num.length \? this.clone().iuand(num) : num.clone().iuand(this);\n      }, BN.prototype.iuxor = function(num) {\n        var a, b;\n        this.length > num.length \? (a = this, b = num) : (a = num, b = this);\n        for (var i = 0;i < b.length; i++)\n          this.words[i] = a.words[i] ^ b.words[i];\n        if (this !== a)\n          for (;i < a.length; i++)\n            this.words[i] = a.words[i];\n        return this.length = a.length, this.strip();\n      }, BN.prototype.ixor = function(num) {\n        return assert((this.negative | num.negative) === 0), this.iuxor(num);\n      }, BN.prototype.xor = function(num) {\n        return this.length > num.length \? this.clone().ixor(num) : num.clone().ixor(this);\n      }, BN.prototype.uxor = function(num) {\n        return this.length > num.length \? this.clone().iuxor(num) : num.clone().iuxor(this);\n      }, BN.prototype.inotn = function(width) {\n        assert(typeof width == \"number\" && width >= 0);\n        var bytesNeeded = Math.ceil(width / 26) | 0, bitsLeft = width % 26;\n        this._expand(bytesNeeded), bitsLeft > 0 && bytesNeeded--;\n        for (var i = 0;i < bytesNeeded; i++)\n          this.words[i] = ~this.words[i] & 67108863;\n        return bitsLeft > 0 && (this.words[i] = ~this.words[i] & 67108863 >> 26 - bitsLeft), this.strip();\n      }, BN.prototype.notn = function(width) {\n        return this.clone().inotn(width);\n      }, BN.prototype.setn = function(bit, val) {\n        assert(typeof bit == \"number\" && bit >= 0);\n        var off = bit / 26 | 0, wbit = bit % 26;\n        return this._expand(off + 1), val \? this.words[off] = this.words[off] | 1 << wbit : this.words[off] = this.words[off] & ~(1 << wbit), this.strip();\n      }, BN.prototype.iadd = function(num) {\n        var r;\n        if (this.negative !== 0 && num.negative === 0)\n          return this.negative = 0, r = this.isub(num), this.negative ^= 1, this._normSign();\n        if (this.negative === 0 && num.negative !== 0)\n          return num.negative = 0, r = this.isub(num), num.negative = 1, r._normSign();\n        var a, b;\n        this.length > num.length \? (a = this, b = num) : (a = num, b = this);\n        for (var carry = 0, i = 0;i < b.length; i++)\n          r = (a.words[i] | 0) + (b.words[i] | 0) + carry, this.words[i] = r & 67108863, carry = r >>> 26;\n        for (;carry !== 0 && i < a.length; i++)\n          r = (a.words[i] | 0) + carry, this.words[i] = r & 67108863, carry = r >>> 26;\n        if (this.length = a.length, carry !== 0)\n          this.words[this.length] = carry, this.length++;\n        else if (a !== this)\n          for (;i < a.length; i++)\n            this.words[i] = a.words[i];\n        return this;\n      }, BN.prototype.add = function(num) {\n        var res;\n        return num.negative !== 0 && this.negative === 0 \? (num.negative = 0, res = this.sub(num), num.negative ^= 1, res) : num.negative === 0 && this.negative !== 0 \? (this.negative = 0, res = num.sub(this), this.negative = 1, res) : this.length > num.length \? this.clone().iadd(num) : num.clone().iadd(this);\n      }, BN.prototype.isub = function(num) {\n        if (num.negative !== 0) {\n          num.negative = 0;\n          var r = this.iadd(num);\n          return num.negative = 1, r._normSign();\n        } else if (this.negative !== 0)\n          return this.negative = 0, this.iadd(num), this.negative = 1, this._normSign();\n        var cmp = this.cmp(num);\n        if (cmp === 0)\n          return this.negative = 0, this.length = 1, this.words[0] = 0, this;\n        var a, b;\n        cmp > 0 \? (a = this, b = num) : (a = num, b = this);\n        for (var carry = 0, i = 0;i < b.length; i++)\n          r = (a.words[i] | 0) - (b.words[i] | 0) + carry, carry = r >> 26, this.words[i] = r & 67108863;\n        for (;carry !== 0 && i < a.length; i++)\n          r = (a.words[i] | 0) + carry, carry = r >> 26, this.words[i] = r & 67108863;\n        if (carry === 0 && i < a.length && a !== this)\n          for (;i < a.length; i++)\n            this.words[i] = a.words[i];\n        return this.length = Math.max(this.length, i), a !== this && (this.negative = 1), this.strip();\n      }, BN.prototype.sub = function(num) {\n        return this.clone().isub(num);\n      };\n      function smallMulTo(self2, num, out) {\n        out.negative = num.negative ^ self2.negative;\n        var len = self2.length + num.length | 0;\n        out.length = len, len = len - 1 | 0;\n        var a = self2.words[0] | 0, b = num.words[0] | 0, r = a * b, lo = r & 67108863, carry = r / 67108864 | 0;\n        out.words[0] = lo;\n        for (var k = 1;k < len; k++) {\n          for (var ncarry = carry >>> 26, rword = carry & 67108863, maxJ = Math.min(k, num.length - 1), j = Math.max(0, k - self2.length + 1);j <= maxJ; j++) {\n            var i = k - j | 0;\n            a = self2.words[i] | 0, b = num.words[j] | 0, r = a * b + rword, ncarry += r / 67108864 | 0, rword = r & 67108863;\n          }\n          out.words[k] = rword | 0, carry = ncarry | 0;\n        }\n        return carry !== 0 \? out.words[k] = carry | 0 : out.length--, out.strip();\n      }\n      var comb10MulTo = function(self2, num, out) {\n        var a = self2.words, b = num.words, o = out.words, c = 0, lo, mid, hi, a0 = a[0] | 0, al0 = a0 & 8191, ah0 = a0 >>> 13, a1 = a[1] | 0, al1 = a1 & 8191, ah1 = a1 >>> 13, a2 = a[2] | 0, al2 = a2 & 8191, ah2 = a2 >>> 13, a3 = a[3] | 0, al3 = a3 & 8191, ah3 = a3 >>> 13, a4 = a[4] | 0, al4 = a4 & 8191, ah4 = a4 >>> 13, a5 = a[5] | 0, al5 = a5 & 8191, ah5 = a5 >>> 13, a6 = a[6] | 0, al6 = a6 & 8191, ah6 = a6 >>> 13, a7 = a[7] | 0, al7 = a7 & 8191, ah7 = a7 >>> 13, a8 = a[8] | 0, al8 = a8 & 8191, ah8 = a8 >>> 13, a9 = a[9] | 0, al9 = a9 & 8191, ah9 = a9 >>> 13, b0 = b[0] | 0, bl0 = b0 & 8191, bh0 = b0 >>> 13, b1 = b[1] | 0, bl1 = b1 & 8191, bh1 = b1 >>> 13, b2 = b[2] | 0, bl2 = b2 & 8191, bh2 = b2 >>> 13, b3 = b[3] | 0, bl3 = b3 & 8191, bh3 = b3 >>> 13, b4 = b[4] | 0, bl4 = b4 & 8191, bh4 = b4 >>> 13, b5 = b[5] | 0, bl5 = b5 & 8191, bh5 = b5 >>> 13, b6 = b[6] | 0, bl6 = b6 & 8191, bh6 = b6 >>> 13, b7 = b[7] | 0, bl7 = b7 & 8191, bh7 = b7 >>> 13, b8 = b[8] | 0, bl8 = b8 & 8191, bh8 = b8 >>> 13, b9 = b[9] | 0, bl9 = b9 & 8191, bh9 = b9 >>> 13;\n        out.negative = self2.negative ^ num.negative, out.length = 19, lo = Math.imul(al0, bl0), mid = Math.imul(al0, bh0), mid = mid + Math.imul(ah0, bl0) | 0, hi = Math.imul(ah0, bh0);\n        var w0 = (c + lo | 0) + ((mid & 8191) << 13) | 0;\n        c = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0, w0 &= 67108863, lo = Math.imul(al1, bl0), mid = Math.imul(al1, bh0), mid = mid + Math.imul(ah1, bl0) | 0, hi = Math.imul(ah1, bh0), lo = lo + Math.imul(al0, bl1) | 0, mid = mid + Math.imul(al0, bh1) | 0, mid = mid + Math.imul(ah0, bl1) | 0, hi = hi + Math.imul(ah0, bh1) | 0;\n        var w1 = (c + lo | 0) + ((mid & 8191) << 13) | 0;\n        c = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0, w1 &= 67108863, lo = Math.imul(al2, bl0), mid = Math.imul(al2, bh0), mid = mid + Math.imul(ah2, bl0) | 0, hi = Math.imul(ah2, bh0), lo = lo + Math.imul(al1, bl1) | 0, mid = mid + Math.imul(al1, bh1) | 0, mid = mid + Math.imul(ah1, bl1) | 0, hi = hi + Math.imul(ah1, bh1) | 0, lo = lo + Math.imul(al0, bl2) | 0, mid = mid + Math.imul(al0, bh2) | 0, mid = mid + Math.imul(ah0, bl2) | 0, hi = hi + Math.imul(ah0, bh2) | 0;\n        var w2 = (c + lo | 0) + ((mid & 8191) << 13) | 0;\n        c = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0, w2 &= 67108863, lo = Math.imul(al3, bl0), mid = Math.imul(al3, bh0), mid = mid + Math.imul(ah3, bl0) | 0, hi = Math.imul(ah3, bh0), lo = lo + Math.imul(al2, bl1) | 0, mid = mid + Math.imul(al2, bh1) | 0, mid = mid + Math.imul(ah2, bl1) | 0, hi = hi + Math.imul(ah2, bh1) | 0, lo = lo + Math.imul(al1, bl2) | 0, mid = mid + Math.imul(al1, bh2) | 0, mid = mid + Math.imul(ah1, bl2) | 0, hi = hi + Math.imul(ah1, bh2) | 0, lo = lo + Math.imul(al0, bl3) | 0, mid = mid + Math.imul(al0, bh3) | 0, mid = mid + Math.imul(ah0, bl3) | 0, hi = hi + Math.imul(ah0, bh3) | 0;\n        var w3 = (c + lo | 0) + ((mid & 8191) << 13) | 0;\n        c = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0, w3 &= 67108863, lo = Math.imul(al4, bl0), mid = Math.imul(al4, bh0), mid = mid + Math.imul(ah4, bl0) | 0, hi = Math.imul(ah4, bh0), lo = lo + Math.imul(al3, bl1) | 0, mid = mid + Math.imul(al3, bh1) | 0, mid = mid + Math.imul(ah3, bl1) | 0, hi = hi + Math.imul(ah3, bh1) | 0, lo = lo + Math.imul(al2, bl2) | 0, mid = mid + Math.imul(al2, bh2) | 0, mid = mid + Math.imul(ah2, bl2) | 0, hi = hi + Math.imul(ah2, bh2) | 0, lo = lo + Math.imul(al1, bl3) | 0, mid = mid + Math.imul(al1, bh3) | 0, mid = mid + Math.imul(ah1, bl3) | 0, hi = hi + Math.imul(ah1, bh3) | 0, lo = lo + Math.imul(al0, bl4) | 0, mid = mid + Math.imul(al0, bh4) | 0, mid = mid + Math.imul(ah0, bl4) | 0, hi = hi + Math.imul(ah0, bh4) | 0;\n        var w4 = (c + lo | 0) + ((mid & 8191) << 13) | 0;\n        c = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0, w4 &= 67108863, lo = Math.imul(al5, bl0), mid = Math.imul(al5, bh0), mid = mid + Math.imul(ah5, bl0) | 0, hi = Math.imul(ah5, bh0), lo = lo + Math.imul(al4, bl1) | 0, mid = mid + Math.imul(al4, bh1) | 0, mid = mid + Math.imul(ah4, bl1) | 0, hi = hi + Math.imul(ah4, bh1) | 0, lo = lo + Math.imul(al3, bl2) | 0, mid = mid + Math.imul(al3, bh2) | 0, mid = mid + Math.imul(ah3, bl2) | 0, hi = hi + Math.imul(ah3, bh2) | 0, lo = lo + Math.imul(al2, bl3) | 0, mid = mid + Math.imul(al2, bh3) | 0, mid = mid + Math.imul(ah2, bl3) | 0, hi = hi + Math.imul(ah2, bh3) | 0, lo = lo + Math.imul(al1, bl4) | 0, mid = mid + Math.imul(al1, bh4) | 0, mid = mid + Math.imul(ah1, bl4) | 0, hi = hi + Math.imul(ah1, bh4) | 0, lo = lo + Math.imul(al0, bl5) | 0, mid = mid + Math.imul(al0, bh5) | 0, mid = mid + Math.imul(ah0, bl5) | 0, hi = hi + Math.imul(ah0, bh5) | 0;\n        var w5 = (c + lo | 0) + ((mid & 8191) << 13) | 0;\n        c = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0, w5 &= 67108863, lo = Math.imul(al6, bl0), mid = Math.imul(al6, bh0), mid = mid + Math.imul(ah6, bl0) | 0, hi = Math.imul(ah6, bh0), lo = lo + Math.imul(al5, bl1) | 0, mid = mid + Math.imul(al5, bh1) | 0, mid = mid + Math.imul(ah5, bl1) | 0, hi = hi + Math.imul(ah5, bh1) | 0, lo = lo + Math.imul(al4, bl2) | 0, mid = mid + Math.imul(al4, bh2) | 0, mid = mid + Math.imul(ah4, bl2) | 0, hi = hi + Math.imul(ah4, bh2) | 0, lo = lo + Math.imul(al3, bl3) | 0, mid = mid + Math.imul(al3, bh3) | 0, mid = mid + Math.imul(ah3, bl3) | 0, hi = hi + Math.imul(ah3, bh3) | 0, lo = lo + Math.imul(al2, bl4) | 0, mid = mid + Math.imul(al2, bh4) | 0, mid = mid + Math.imul(ah2, bl4) | 0, hi = hi + Math.imul(ah2, bh4) | 0, lo = lo + Math.imul(al1, bl5) | 0, mid = mid + Math.imul(al1, bh5) | 0, mid = mid + Math.imul(ah1, bl5) | 0, hi = hi + Math.imul(ah1, bh5) | 0, lo = lo + Math.imul(al0, bl6) | 0, mid = mid + Math.imul(al0, bh6) | 0, mid = mid + Math.imul(ah0, bl6) | 0, hi = hi + Math.imul(ah0, bh6) | 0;\n        var w6 = (c + lo | 0) + ((mid & 8191) << 13) | 0;\n        c = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0, w6 &= 67108863, lo = Math.imul(al7, bl0), mid = Math.imul(al7, bh0), mid = mid + Math.imul(ah7, bl0) | 0, hi = Math.imul(ah7, bh0), lo = lo + Math.imul(al6, bl1) | 0, mid = mid + Math.imul(al6, bh1) | 0, mid = mid + Math.imul(ah6, bl1) | 0, hi = hi + Math.imul(ah6, bh1) | 0, lo = lo + Math.imul(al5, bl2) | 0, mid = mid + Math.imul(al5, bh2) | 0, mid = mid + Math.imul(ah5, bl2) | 0, hi = hi + Math.imul(ah5, bh2) | 0, lo = lo + Math.imul(al4, bl3) | 0, mid = mid + Math.imul(al4, bh3) | 0, mid = mid + Math.imul(ah4, bl3) | 0, hi = hi + Math.imul(ah4, bh3) | 0, lo = lo + Math.imul(al3, bl4) | 0, mid = mid + Math.imul(al3, bh4) | 0, mid = mid + Math.imul(ah3, bl4) | 0, hi = hi + Math.imul(ah3, bh4) | 0, lo = lo + Math.imul(al2, bl5) | 0, mid = mid + Math.imul(al2, bh5) | 0, mid = mid + Math.imul(ah2, bl5) | 0, hi = hi + Math.imul(ah2, bh5) | 0, lo = lo + Math.imul(al1, bl6) | 0, mid = mid + Math.imul(al1, bh6) | 0, mid = mid + Math.imul(ah1, bl6) | 0, hi = hi + Math.imul(ah1, bh6) | 0, lo = lo + Math.imul(al0, bl7) | 0, mid = mid + Math.imul(al0, bh7) | 0, mid = mid + Math.imul(ah0, bl7) | 0, hi = hi + Math.imul(ah0, bh7) | 0;\n        var w7 = (c + lo | 0) + ((mid & 8191) << 13) | 0;\n        c = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0, w7 &= 67108863, lo = Math.imul(al8, bl0), mid = Math.imul(al8, bh0), mid = mid + Math.imul(ah8, bl0) | 0, hi = Math.imul(ah8, bh0), lo = lo + Math.imul(al7, bl1) | 0, mid = mid + Math.imul(al7, bh1) | 0, mid = mid + Math.imul(ah7, bl1) | 0, hi = hi + Math.imul(ah7, bh1) | 0, lo = lo + Math.imul(al6, bl2) | 0, mid = mid + Math.imul(al6, bh2) | 0, mid = mid + Math.imul(ah6, bl2) | 0, hi = hi + Math.imul(ah6, bh2) | 0, lo = lo + Math.imul(al5, bl3) | 0, mid = mid + Math.imul(al5, bh3) | 0, mid = mid + Math.imul(ah5, bl3) | 0, hi = hi + Math.imul(ah5, bh3) | 0, lo = lo + Math.imul(al4, bl4) | 0, mid = mid + Math.imul(al4, bh4) | 0, mid = mid + Math.imul(ah4, bl4) | 0, hi = hi + Math.imul(ah4, bh4) | 0, lo = lo + Math.imul(al3, bl5) | 0, mid = mid + Math.imul(al3, bh5) | 0, mid = mid + Math.imul(ah3, bl5) | 0, hi = hi + Math.imul(ah3, bh5) | 0, lo = lo + Math.imul(al2, bl6) | 0, mid = mid + Math.imul(al2, bh6) | 0, mid = mid + Math.imul(ah2, bl6) | 0, hi = hi + Math.imul(ah2, bh6) | 0, lo = lo + Math.imul(al1, bl7) | 0, mid = mid + Math.imul(al1, bh7) | 0, mid = mid + Math.imul(ah1, bl7) | 0, hi = hi + Math.imul(ah1, bh7) | 0, lo = lo + Math.imul(al0, bl8) | 0, mid = mid + Math.imul(al0, bh8) | 0, mid = mid + Math.imul(ah0, bl8) | 0, hi = hi + Math.imul(ah0, bh8) | 0;\n        var w8 = (c + lo | 0) + ((mid & 8191) << 13) | 0;\n        c = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0, w8 &= 67108863, lo = Math.imul(al9, bl0), mid = Math.imul(al9, bh0), mid = mid + Math.imul(ah9, bl0) | 0, hi = Math.imul(ah9, bh0), lo = lo + Math.imul(al8, bl1) | 0, mid = mid + Math.imul(al8, bh1) | 0, mid = mid + Math.imul(ah8, bl1) | 0, hi = hi + Math.imul(ah8, bh1) | 0, lo = lo + Math.imul(al7, bl2) | 0, mid = mid + Math.imul(al7, bh2) | 0, mid = mid + Math.imul(ah7, bl2) | 0, hi = hi + Math.imul(ah7, bh2) | 0, lo = lo + Math.imul(al6, bl3) | 0, mid = mid + Math.imul(al6, bh3) | 0, mid = mid + Math.imul(ah6, bl3) | 0, hi = hi + Math.imul(ah6, bh3) | 0, lo = lo + Math.imul(al5, bl4) | 0, mid = mid + Math.imul(al5, bh4) | 0, mid = mid + Math.imul(ah5, bl4) | 0, hi = hi + Math.imul(ah5, bh4) | 0, lo = lo + Math.imul(al4, bl5) | 0, mid = mid + Math.imul(al4, bh5) | 0, mid = mid + Math.imul(ah4, bl5) | 0, hi = hi + Math.imul(ah4, bh5) | 0, lo = lo + Math.imul(al3, bl6) | 0, mid = mid + Math.imul(al3, bh6) | 0, mid = mid + Math.imul(ah3, bl6) | 0, hi = hi + Math.imul(ah3, bh6) | 0, lo = lo + Math.imul(al2, bl7) | 0, mid = mid + Math.imul(al2, bh7) | 0, mid = mid + Math.imul(ah2, bl7) | 0, hi = hi + Math.imul(ah2, bh7) | 0, lo = lo + Math.imul(al1, bl8) | 0, mid = mid + Math.imul(al1, bh8) | 0, mid = mid + Math.imul(ah1, bl8) | 0, hi = hi + Math.imul(ah1, bh8) | 0, lo = lo + Math.imul(al0, bl9) | 0, mid = mid + Math.imul(al0, bh9) | 0, mid = mid + Math.imul(ah0, bl9) | 0, hi = hi + Math.imul(ah0, bh9) | 0;\n        var w9 = (c + lo | 0) + ((mid & 8191) << 13) | 0;\n        c = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0, w9 &= 67108863, lo = Math.imul(al9, bl1), mid = Math.imul(al9, bh1), mid = mid + Math.imul(ah9, bl1) | 0, hi = Math.imul(ah9, bh1), lo = lo + Math.imul(al8, bl2) | 0, mid = mid + Math.imul(al8, bh2) | 0, mid = mid + Math.imul(ah8, bl2) | 0, hi = hi + Math.imul(ah8, bh2) | 0, lo = lo + Math.imul(al7, bl3) | 0, mid = mid + Math.imul(al7, bh3) | 0, mid = mid + Math.imul(ah7, bl3) | 0, hi = hi + Math.imul(ah7, bh3) | 0, lo = lo + Math.imul(al6, bl4) | 0, mid = mid + Math.imul(al6, bh4) | 0, mid = mid + Math.imul(ah6, bl4) | 0, hi = hi + Math.imul(ah6, bh4) | 0, lo = lo + Math.imul(al5, bl5) | 0, mid = mid + Math.imul(al5, bh5) | 0, mid = mid + Math.imul(ah5, bl5) | 0, hi = hi + Math.imul(ah5, bh5) | 0, lo = lo + Math.imul(al4, bl6) | 0, mid = mid + Math.imul(al4, bh6) | 0, mid = mid + Math.imul(ah4, bl6) | 0, hi = hi + Math.imul(ah4, bh6) | 0, lo = lo + Math.imul(al3, bl7) | 0, mid = mid + Math.imul(al3, bh7) | 0, mid = mid + Math.imul(ah3, bl7) | 0, hi = hi + Math.imul(ah3, bh7) | 0, lo = lo + Math.imul(al2, bl8) | 0, mid = mid + Math.imul(al2, bh8) | 0, mid = mid + Math.imul(ah2, bl8) | 0, hi = hi + Math.imul(ah2, bh8) | 0, lo = lo + Math.imul(al1, bl9) | 0, mid = mid + Math.imul(al1, bh9) | 0, mid = mid + Math.imul(ah1, bl9) | 0, hi = hi + Math.imul(ah1, bh9) | 0;\n        var w10 = (c + lo | 0) + ((mid & 8191) << 13) | 0;\n        c = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0, w10 &= 67108863, lo = Math.imul(al9, bl2), mid = Math.imul(al9, bh2), mid = mid + Math.imul(ah9, bl2) | 0, hi = Math.imul(ah9, bh2), lo = lo + Math.imul(al8, bl3) | 0, mid = mid + Math.imul(al8, bh3) | 0, mid = mid + Math.imul(ah8, bl3) | 0, hi = hi + Math.imul(ah8, bh3) | 0, lo = lo + Math.imul(al7, bl4) | 0, mid = mid + Math.imul(al7, bh4) | 0, mid = mid + Math.imul(ah7, bl4) | 0, hi = hi + Math.imul(ah7, bh4) | 0, lo = lo + Math.imul(al6, bl5) | 0, mid = mid + Math.imul(al6, bh5) | 0, mid = mid + Math.imul(ah6, bl5) | 0, hi = hi + Math.imul(ah6, bh5) | 0, lo = lo + Math.imul(al5, bl6) | 0, mid = mid + Math.imul(al5, bh6) | 0, mid = mid + Math.imul(ah5, bl6) | 0, hi = hi + Math.imul(ah5, bh6) | 0, lo = lo + Math.imul(al4, bl7) | 0, mid = mid + Math.imul(al4, bh7) | 0, mid = mid + Math.imul(ah4, bl7) | 0, hi = hi + Math.imul(ah4, bh7) | 0, lo = lo + Math.imul(al3, bl8) | 0, mid = mid + Math.imul(al3, bh8) | 0, mid = mid + Math.imul(ah3, bl8) | 0, hi = hi + Math.imul(ah3, bh8) | 0, lo = lo + Math.imul(al2, bl9) | 0, mid = mid + Math.imul(al2, bh9) | 0, mid = mid + Math.imul(ah2, bl9) | 0, hi = hi + Math.imul(ah2, bh9) | 0;\n        var w11 = (c + lo | 0) + ((mid & 8191) << 13) | 0;\n        c = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0, w11 &= 67108863, lo = Math.imul(al9, bl3), mid = Math.imul(al9, bh3), mid = mid + Math.imul(ah9, bl3) | 0, hi = Math.imul(ah9, bh3), lo = lo + Math.imul(al8, bl4) | 0, mid = mid + Math.imul(al8, bh4) | 0, mid = mid + Math.imul(ah8, bl4) | 0, hi = hi + Math.imul(ah8, bh4) | 0, lo = lo + Math.imul(al7, bl5) | 0, mid = mid + Math.imul(al7, bh5) | 0, mid = mid + Math.imul(ah7, bl5) | 0, hi = hi + Math.imul(ah7, bh5) | 0, lo = lo + Math.imul(al6, bl6) | 0, mid = mid + Math.imul(al6, bh6) | 0, mid = mid + Math.imul(ah6, bl6) | 0, hi = hi + Math.imul(ah6, bh6) | 0, lo = lo + Math.imul(al5, bl7) | 0, mid = mid + Math.imul(al5, bh7) | 0, mid = mid + Math.imul(ah5, bl7) | 0, hi = hi + Math.imul(ah5, bh7) | 0, lo = lo + Math.imul(al4, bl8) | 0, mid = mid + Math.imul(al4, bh8) | 0, mid = mid + Math.imul(ah4, bl8) | 0, hi = hi + Math.imul(ah4, bh8) | 0, lo = lo + Math.imul(al3, bl9) | 0, mid = mid + Math.imul(al3, bh9) | 0, mid = mid + Math.imul(ah3, bl9) | 0, hi = hi + Math.imul(ah3, bh9) | 0;\n        var w12 = (c + lo | 0) + ((mid & 8191) << 13) | 0;\n        c = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0, w12 &= 67108863, lo = Math.imul(al9, bl4), mid = Math.imul(al9, bh4), mid = mid + Math.imul(ah9, bl4) | 0, hi = Math.imul(ah9, bh4), lo = lo + Math.imul(al8, bl5) | 0, mid = mid + Math.imul(al8, bh5) | 0, mid = mid + Math.imul(ah8, bl5) | 0, hi = hi + Math.imul(ah8, bh5) | 0, lo = lo + Math.imul(al7, bl6) | 0, mid = mid + Math.imul(al7, bh6) | 0, mid = mid + Math.imul(ah7, bl6) | 0, hi = hi + Math.imul(ah7, bh6) | 0, lo = lo + Math.imul(al6, bl7) | 0, mid = mid + Math.imul(al6, bh7) | 0, mid = mid + Math.imul(ah6, bl7) | 0, hi = hi + Math.imul(ah6, bh7) | 0, lo = lo + Math.imul(al5, bl8) | 0, mid = mid + Math.imul(al5, bh8) | 0, mid = mid + Math.imul(ah5, bl8) | 0, hi = hi + Math.imul(ah5, bh8) | 0, lo = lo + Math.imul(al4, bl9) | 0, mid = mid + Math.imul(al4, bh9) | 0, mid = mid + Math.imul(ah4, bl9) | 0, hi = hi + Math.imul(ah4, bh9) | 0;\n        var w13 = (c + lo | 0) + ((mid & 8191) << 13) | 0;\n        c = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0, w13 &= 67108863, lo = Math.imul(al9, bl5), mid = Math.imul(al9, bh5), mid = mid + Math.imul(ah9, bl5) | 0, hi = Math.imul(ah9, bh5), lo = lo + Math.imul(al8, bl6) | 0, mid = mid + Math.imul(al8, bh6) | 0, mid = mid + Math.imul(ah8, bl6) | 0, hi = hi + Math.imul(ah8, bh6) | 0, lo = lo + Math.imul(al7, bl7) | 0, mid = mid + Math.imul(al7, bh7) | 0, mid = mid + Math.imul(ah7, bl7) | 0, hi = hi + Math.imul(ah7, bh7) | 0, lo = lo + Math.imul(al6, bl8) | 0, mid = mid + Math.imul(al6, bh8) | 0, mid = mid + Math.imul(ah6, bl8) | 0, hi = hi + Math.imul(ah6, bh8) | 0, lo = lo + Math.imul(al5, bl9) | 0, mid = mid + Math.imul(al5, bh9) | 0, mid = mid + Math.imul(ah5, bl9) | 0, hi = hi + Math.imul(ah5, bh9) | 0;\n        var w14 = (c + lo | 0) + ((mid & 8191) << 13) | 0;\n        c = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0, w14 &= 67108863, lo = Math.imul(al9, bl6), mid = Math.imul(al9, bh6), mid = mid + Math.imul(ah9, bl6) | 0, hi = Math.imul(ah9, bh6), lo = lo + Math.imul(al8, bl7) | 0, mid = mid + Math.imul(al8, bh7) | 0, mid = mid + Math.imul(ah8, bl7) | 0, hi = hi + Math.imul(ah8, bh7) | 0, lo = lo + Math.imul(al7, bl8) | 0, mid = mid + Math.imul(al7, bh8) | 0, mid = mid + Math.imul(ah7, bl8) | 0, hi = hi + Math.imul(ah7, bh8) | 0, lo = lo + Math.imul(al6, bl9) | 0, mid = mid + Math.imul(al6, bh9) | 0, mid = mid + Math.imul(ah6, bl9) | 0, hi = hi + Math.imul(ah6, bh9) | 0;\n        var w15 = (c + lo | 0) + ((mid & 8191) << 13) | 0;\n        c = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0, w15 &= 67108863, lo = Math.imul(al9, bl7), mid = Math.imul(al9, bh7), mid = mid + Math.imul(ah9, bl7) | 0, hi = Math.imul(ah9, bh7), lo = lo + Math.imul(al8, bl8) | 0, mid = mid + Math.imul(al8, bh8) | 0, mid = mid + Math.imul(ah8, bl8) | 0, hi = hi + Math.imul(ah8, bh8) | 0, lo = lo + Math.imul(al7, bl9) | 0, mid = mid + Math.imul(al7, bh9) | 0, mid = mid + Math.imul(ah7, bl9) | 0, hi = hi + Math.imul(ah7, bh9) | 0;\n        var w16 = (c + lo | 0) + ((mid & 8191) << 13) | 0;\n        c = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0, w16 &= 67108863, lo = Math.imul(al9, bl8), mid = Math.imul(al9, bh8), mid = mid + Math.imul(ah9, bl8) | 0, hi = Math.imul(ah9, bh8), lo = lo + Math.imul(al8, bl9) | 0, mid = mid + Math.imul(al8, bh9) | 0, mid = mid + Math.imul(ah8, bl9) | 0, hi = hi + Math.imul(ah8, bh9) | 0;\n        var w17 = (c + lo | 0) + ((mid & 8191) << 13) | 0;\n        c = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0, w17 &= 67108863, lo = Math.imul(al9, bl9), mid = Math.imul(al9, bh9), mid = mid + Math.imul(ah9, bl9) | 0, hi = Math.imul(ah9, bh9);\n        var w18 = (c + lo | 0) + ((mid & 8191) << 13) | 0;\n        return c = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0, w18 &= 67108863, o[0] = w0, o[1] = w1, o[2] = w2, o[3] = w3, o[4] = w4, o[5] = w5, o[6] = w6, o[7] = w7, o[8] = w8, o[9] = w9, o[10] = w10, o[11] = w11, o[12] = w12, o[13] = w13, o[14] = w14, o[15] = w15, o[16] = w16, o[17] = w17, o[18] = w18, c !== 0 && (o[19] = c, out.length++), out;\n      };\n      Math.imul || (comb10MulTo = smallMulTo);\n      function bigMulTo(self2, num, out) {\n        out.negative = num.negative ^ self2.negative, out.length = self2.length + num.length;\n        for (var carry = 0, hncarry = 0, k = 0;k < out.length - 1; k++) {\n          var ncarry = hncarry;\n          hncarry = 0;\n          for (var rword = carry & 67108863, maxJ = Math.min(k, num.length - 1), j = Math.max(0, k - self2.length + 1);j <= maxJ; j++) {\n            var i = k - j, a = self2.words[i] | 0, b = num.words[j] | 0, r = a * b, lo = r & 67108863;\n            ncarry = ncarry + (r / 67108864 | 0) | 0, lo = lo + rword | 0, rword = lo & 67108863, ncarry = ncarry + (lo >>> 26) | 0, hncarry += ncarry >>> 26, ncarry &= 67108863;\n          }\n          out.words[k] = rword, carry = ncarry, ncarry = hncarry;\n        }\n        return carry !== 0 \? out.words[k] = carry : out.length--, out.strip();\n      }\n      function jumboMulTo(self2, num, out) {\n        var fftm = new FFTM;\n        return fftm.mulp(self2, num, out);\n      }\n      BN.prototype.mulTo = function(num, out) {\n        var res, len = this.length + num.length;\n        return this.length === 10 && num.length === 10 \? res = comb10MulTo(this, num, out) : len < 63 \? res = smallMulTo(this, num, out) : len < 1024 \? res = bigMulTo(this, num, out) : res = jumboMulTo(this, num, out), res;\n      };\n      function FFTM(x, y) {\n        this.x = x, this.y = y;\n      }\n      FFTM.prototype = {}, FFTM.prototype.makeRBT = function(N) {\n        for (var t = new Array(N), l = BN.prototype._countBits(N) - 1, i = 0;i < N; i++)\n          t[i] = this.revBin(i, l, N);\n        return t;\n      }, FFTM.prototype.revBin = function(x, l, N) {\n        if (x === 0 || x === N - 1)\n          return x;\n        for (var rb = 0, i = 0;i < l; i++)\n          rb |= (x & 1) << l - i - 1, x >>= 1;\n        return rb;\n      }, FFTM.prototype.permute = function(rbt, rws, iws, rtws, itws, N) {\n        for (var i = 0;i < N; i++)\n          rtws[i] = rws[rbt[i]], itws[i] = iws[rbt[i]];\n      }, FFTM.prototype.transform = function(rws, iws, rtws, itws, N, rbt) {\n        this.permute(rbt, rws, iws, rtws, itws, N);\n        for (var s = 1;s < N; s <<= 1)\n          for (var l = s << 1, rtwdf = Math.cos(2 * Math.PI / l), itwdf = Math.sin(2 * Math.PI / l), p = 0;p < N; p += l)\n            for (var rtwdf_ = rtwdf, itwdf_ = itwdf, j = 0;j < s; j++) {\n              var re = rtws[p + j], ie = itws[p + j], ro = rtws[p + j + s], io = itws[p + j + s], rx = rtwdf_ * ro - itwdf_ * io;\n              io = rtwdf_ * io + itwdf_ * ro, ro = rx, rtws[p + j] = re + ro, itws[p + j] = ie + io, rtws[p + j + s] = re - ro, itws[p + j + s] = ie - io, j !== l && (rx = rtwdf * rtwdf_ - itwdf * itwdf_, itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_, rtwdf_ = rx);\n            }\n      }, FFTM.prototype.guessLen13b = function(n, m) {\n        var N = Math.max(m, n) | 1, odd = N & 1, i = 0;\n        for (N = N / 2 | 0;N; N = N >>> 1)\n          i++;\n        return 1 << i + 1 + odd;\n      }, FFTM.prototype.conjugate = function(rws, iws, N) {\n        if (!(N <= 1))\n          for (var i = 0;i < N / 2; i++) {\n            var t = rws[i];\n            rws[i] = rws[N - i - 1], rws[N - i - 1] = t, t = iws[i], iws[i] = -iws[N - i - 1], iws[N - i - 1] = -t;\n          }\n      }, FFTM.prototype.normalize13b = function(ws, N) {\n        for (var carry = 0, i = 0;i < N / 2; i++) {\n          var w = Math.round(ws[2 * i + 1] / N) * 8192 + Math.round(ws[2 * i] / N) + carry;\n          ws[i] = w & 67108863, w < 67108864 \? carry = 0 : carry = w / 67108864 | 0;\n        }\n        return ws;\n      }, FFTM.prototype.convert13b = function(ws, len, rws, N) {\n        for (var carry = 0, i = 0;i < len; i++)\n          carry = carry + (ws[i] | 0), rws[2 * i] = carry & 8191, carry = carry >>> 13, rws[2 * i + 1] = carry & 8191, carry = carry >>> 13;\n        for (i = 2 * len;i < N; ++i)\n          rws[i] = 0;\n        assert(carry === 0), assert((carry & -8192) === 0);\n      }, FFTM.prototype.stub = function(N) {\n        for (var ph = new Array(N), i = 0;i < N; i++)\n          ph[i] = 0;\n        return ph;\n      }, FFTM.prototype.mulp = function(x, y, out) {\n        var N = 2 * this.guessLen13b(x.length, y.length), rbt = this.makeRBT(N), _ = this.stub(N), rws = new Array(N), rwst = new Array(N), iwst = new Array(N), nrws = new Array(N), nrwst = new Array(N), niwst = new Array(N), rmws = out.words;\n        rmws.length = N, this.convert13b(x.words, x.length, rws, N), this.convert13b(y.words, y.length, nrws, N), this.transform(rws, _, rwst, iwst, N, rbt), this.transform(nrws, _, nrwst, niwst, N, rbt);\n        for (var i = 0;i < N; i++) {\n          var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];\n          iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i], rwst[i] = rx;\n        }\n        return this.conjugate(rwst, iwst, N), this.transform(rwst, iwst, rmws, _, N, rbt), this.conjugate(rmws, _, N), this.normalize13b(rmws, N), out.negative = x.negative ^ y.negative, out.length = x.length + y.length, out.strip();\n      }, BN.prototype.mul = function(num) {\n        var out = new BN(null);\n        return out.words = new Array(this.length + num.length), this.mulTo(num, out);\n      }, BN.prototype.mulf = function(num) {\n        var out = new BN(null);\n        return out.words = new Array(this.length + num.length), jumboMulTo(this, num, out);\n      }, BN.prototype.imul = function(num) {\n        return this.clone().mulTo(num, this);\n      }, BN.prototype.imuln = function(num) {\n        assert(typeof num == \"number\"), assert(num < 67108864);\n        for (var carry = 0, i = 0;i < this.length; i++) {\n          var w = (this.words[i] | 0) * num, lo = (w & 67108863) + (carry & 67108863);\n          carry >>= 26, carry += w / 67108864 | 0, carry += lo >>> 26, this.words[i] = lo & 67108863;\n        }\n        return carry !== 0 && (this.words[i] = carry, this.length++), this;\n      }, BN.prototype.muln = function(num) {\n        return this.clone().imuln(num);\n      }, BN.prototype.sqr = function() {\n        return this.mul(this);\n      }, BN.prototype.isqr = function() {\n        return this.imul(this.clone());\n      }, BN.prototype.pow = function(num) {\n        var w = toBitArray(num);\n        if (w.length === 0)\n          return new BN(1);\n        for (var res = this, i = 0;i < w.length && w[i] === 0; i++, res = res.sqr())\n          ;\n        if (++i < w.length)\n          for (var q = res.sqr();i < w.length; i++, q = q.sqr())\n            w[i] !== 0 && (res = res.mul(q));\n        return res;\n      }, BN.prototype.iushln = function(bits) {\n        assert(typeof bits == \"number\" && bits >= 0);\n        var r = bits % 26, s = (bits - r) / 26, carryMask = 67108863 >>> 26 - r << 26 - r, i;\n        if (r !== 0) {\n          var carry = 0;\n          for (i = 0;i < this.length; i++) {\n            var newCarry = this.words[i] & carryMask, c = (this.words[i] | 0) - newCarry << r;\n            this.words[i] = c | carry, carry = newCarry >>> 26 - r;\n          }\n          carry && (this.words[i] = carry, this.length++);\n        }\n        if (s !== 0) {\n          for (i = this.length - 1;i >= 0; i--)\n            this.words[i + s] = this.words[i];\n          for (i = 0;i < s; i++)\n            this.words[i] = 0;\n          this.length += s;\n        }\n        return this.strip();\n      }, BN.prototype.ishln = function(bits) {\n        return assert(this.negative === 0), this.iushln(bits);\n      }, BN.prototype.iushrn = function(bits, hint, extended) {\n        assert(typeof bits == \"number\" && bits >= 0);\n        var h;\n        hint \? h = (hint - hint % 26) / 26 : h = 0;\n        var r = bits % 26, s = Math.min((bits - r) / 26, this.length), mask = 67108863 ^ 67108863 >>> r << r, maskedWords = extended;\n        if (h -= s, h = Math.max(0, h), maskedWords) {\n          for (var i = 0;i < s; i++)\n            maskedWords.words[i] = this.words[i];\n          maskedWords.length = s;\n        }\n        if (s !== 0)\n          if (this.length > s)\n            for (this.length -= s, i = 0;i < this.length; i++)\n              this.words[i] = this.words[i + s];\n          else\n            this.words[0] = 0, this.length = 1;\n        var carry = 0;\n        for (i = this.length - 1;i >= 0 && (carry !== 0 || i >= h); i--) {\n          var word = this.words[i] | 0;\n          this.words[i] = carry << 26 - r | word >>> r, carry = word & mask;\n        }\n        return maskedWords && carry !== 0 && (maskedWords.words[maskedWords.length++] = carry), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip();\n      }, BN.prototype.ishrn = function(bits, hint, extended) {\n        return assert(this.negative === 0), this.iushrn(bits, hint, extended);\n      }, BN.prototype.shln = function(bits) {\n        return this.clone().ishln(bits);\n      }, BN.prototype.ushln = function(bits) {\n        return this.clone().iushln(bits);\n      }, BN.prototype.shrn = function(bits) {\n        return this.clone().ishrn(bits);\n      }, BN.prototype.ushrn = function(bits) {\n        return this.clone().iushrn(bits);\n      }, BN.prototype.testn = function(bit) {\n        assert(typeof bit == \"number\" && bit >= 0);\n        var r = bit % 26, s = (bit - r) / 26, q = 1 << r;\n        if (this.length <= s)\n          return !1;\n        var w = this.words[s];\n        return !!(w & q);\n      }, BN.prototype.imaskn = function(bits) {\n        assert(typeof bits == \"number\" && bits >= 0);\n        var r = bits % 26, s = (bits - r) / 26;\n        if (assert(this.negative === 0, \"imaskn works only with positive numbers\"), this.length <= s)\n          return this;\n        if (r !== 0 && s++, this.length = Math.min(s, this.length), r !== 0) {\n          var mask = 67108863 ^ 67108863 >>> r << r;\n          this.words[this.length - 1] &= mask;\n        }\n        return this.strip();\n      }, BN.prototype.maskn = function(bits) {\n        return this.clone().imaskn(bits);\n      }, BN.prototype.iaddn = function(num) {\n        return assert(typeof num == \"number\"), assert(num < 67108864), num < 0 \? this.isubn(-num) : this.negative !== 0 \? this.length === 1 && (this.words[0] | 0) < num \? (this.words[0] = num - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(num), this.negative = 1, this) : this._iaddn(num);\n      }, BN.prototype._iaddn = function(num) {\n        this.words[0] += num;\n        for (var i = 0;i < this.length && this.words[i] >= 67108864; i++)\n          this.words[i] -= 67108864, i === this.length - 1 \? this.words[i + 1] = 1 : this.words[i + 1]++;\n        return this.length = Math.max(this.length, i + 1), this;\n      }, BN.prototype.isubn = function(num) {\n        if (assert(typeof num == \"number\"), assert(num < 67108864), num < 0)\n          return this.iaddn(-num);\n        if (this.negative !== 0)\n          return this.negative = 0, this.iaddn(num), this.negative = 1, this;\n        if (this.words[0] -= num, this.length === 1 && this.words[0] < 0)\n          this.words[0] = -this.words[0], this.negative = 1;\n        else\n          for (var i = 0;i < this.length && this.words[i] < 0; i++)\n            this.words[i] += 67108864, this.words[i + 1] -= 1;\n        return this.strip();\n      }, BN.prototype.addn = function(num) {\n        return this.clone().iaddn(num);\n      }, BN.prototype.subn = function(num) {\n        return this.clone().isubn(num);\n      }, BN.prototype.iabs = function() {\n        return this.negative = 0, this;\n      }, BN.prototype.abs = function() {\n        return this.clone().iabs();\n      }, BN.prototype._ishlnsubmul = function(num, mul, shift) {\n        var len = num.length + shift, i;\n        this._expand(len);\n        var w, carry = 0;\n        for (i = 0;i < num.length; i++) {\n          w = (this.words[i + shift] | 0) + carry;\n          var right = (num.words[i] | 0) * mul;\n          w -= right & 67108863, carry = (w >> 26) - (right / 67108864 | 0), this.words[i + shift] = w & 67108863;\n        }\n        for (;i < this.length - shift; i++)\n          w = (this.words[i + shift] | 0) + carry, carry = w >> 26, this.words[i + shift] = w & 67108863;\n        if (carry === 0)\n          return this.strip();\n        for (assert(carry === -1), carry = 0, i = 0;i < this.length; i++)\n          w = -(this.words[i] | 0) + carry, carry = w >> 26, this.words[i] = w & 67108863;\n        return this.negative = 1, this.strip();\n      }, BN.prototype._wordDiv = function(num, mode) {\n        var shift = this.length - num.length, a = this.clone(), b = num, bhi = b.words[b.length - 1] | 0, bhiBits = this._countBits(bhi);\n        shift = 26 - bhiBits, shift !== 0 && (b = b.ushln(shift), a.iushln(shift), bhi = b.words[b.length - 1] | 0);\n        var m = a.length - b.length, q;\n        if (mode !== \"mod\") {\n          q = new BN(null), q.length = m + 1, q.words = new Array(q.length);\n          for (var i = 0;i < q.length; i++)\n            q.words[i] = 0;\n        }\n        var diff = a.clone()._ishlnsubmul(b, 1, m);\n        diff.negative === 0 && (a = diff, q && (q.words[m] = 1));\n        for (var j = m - 1;j >= 0; j--) {\n          var qj = (a.words[b.length + j] | 0) * 67108864 + (a.words[b.length + j - 1] | 0);\n          for (qj = Math.min(qj / bhi | 0, 67108863), a._ishlnsubmul(b, qj, j);a.negative !== 0; )\n            qj--, a.negative = 0, a._ishlnsubmul(b, 1, j), a.isZero() || (a.negative ^= 1);\n          q && (q.words[j] = qj);\n        }\n        return q && q.strip(), a.strip(), mode !== \"div\" && shift !== 0 && a.iushrn(shift), {\n          div: q || null,\n          mod: a\n        };\n      }, BN.prototype.divmod = function(num, mode, positive) {\n        if (assert(!num.isZero()), this.isZero())\n          return {\n            div: new BN(0),\n            mod: new BN(0)\n          };\n        var div, mod, res;\n        return this.negative !== 0 && num.negative === 0 \? (res = this.neg().divmod(num, mode), mode !== \"mod\" && (div = res.div.neg()), mode !== \"div\" && (mod = res.mod.neg(), positive && mod.negative !== 0 && mod.iadd(num)), {\n          div,\n          mod\n        }) : this.negative === 0 && num.negative !== 0 \? (res = this.divmod(num.neg(), mode), mode !== \"mod\" && (div = res.div.neg()), {\n          div,\n          mod: res.mod\n        }) : (this.negative & num.negative) !== 0 \? (res = this.neg().divmod(num.neg(), mode), mode !== \"div\" && (mod = res.mod.neg(), positive && mod.negative !== 0 && mod.isub(num)), {\n          div: res.div,\n          mod\n        }) : num.length > this.length || this.cmp(num) < 0 \? {\n          div: new BN(0),\n          mod: this\n        } : num.length === 1 \? mode === \"div\" \? {\n          div: this.divn(num.words[0]),\n          mod: null\n        } : mode === \"mod\" \? {\n          div: null,\n          mod: new BN(this.modn(num.words[0]))\n        } : {\n          div: this.divn(num.words[0]),\n          mod: new BN(this.modn(num.words[0]))\n        } : this._wordDiv(num, mode);\n      }, BN.prototype.div = function(num) {\n        return this.divmod(num, \"div\", !1).div;\n      }, BN.prototype.mod = function(num) {\n        return this.divmod(num, \"mod\", !1).mod;\n      }, BN.prototype.umod = function(num) {\n        return this.divmod(num, \"mod\", !0).mod;\n      }, BN.prototype.divRound = function(num) {\n        var dm = this.divmod(num);\n        if (dm.mod.isZero())\n          return dm.div;\n        var mod = dm.div.negative !== 0 \? dm.mod.isub(num) : dm.mod, half = num.ushrn(1), r2 = num.andln(1), cmp = mod.cmp(half);\n        return cmp < 0 || r2 === 1 && cmp === 0 \? dm.div : dm.div.negative !== 0 \? dm.div.isubn(1) : dm.div.iaddn(1);\n      }, BN.prototype.modn = function(num) {\n        assert(num <= 67108863);\n        for (var p = (1 << 26) % num, acc = 0, i = this.length - 1;i >= 0; i--)\n          acc = (p * acc + (this.words[i] | 0)) % num;\n        return acc;\n      }, BN.prototype.idivn = function(num) {\n        assert(num <= 67108863);\n        for (var carry = 0, i = this.length - 1;i >= 0; i--) {\n          var w = (this.words[i] | 0) + carry * 67108864;\n          this.words[i] = w / num | 0, carry = w % num;\n        }\n        return this.strip();\n      }, BN.prototype.divn = function(num) {\n        return this.clone().idivn(num);\n      }, BN.prototype.egcd = function(p) {\n        assert(p.negative === 0), assert(!p.isZero());\n        var x = this, y = p.clone();\n        x.negative !== 0 \? x = x.umod(p) : x = x.clone();\n        for (var A = new BN(1), B = new BN(0), C = new BN(0), D = new BN(1), g = 0;x.isEven() && y.isEven(); )\n          x.iushrn(1), y.iushrn(1), ++g;\n        for (var yp = y.clone(), xp = x.clone();!x.isZero(); ) {\n          for (var i = 0, im = 1;(x.words[0] & im) === 0 && i < 26; ++i, im <<= 1)\n            ;\n          if (i > 0)\n            for (x.iushrn(i);i-- > 0; )\n              (A.isOdd() || B.isOdd()) && (A.iadd(yp), B.isub(xp)), A.iushrn(1), B.iushrn(1);\n          for (var j = 0, jm = 1;(y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)\n            ;\n          if (j > 0)\n            for (y.iushrn(j);j-- > 0; )\n              (C.isOdd() || D.isOdd()) && (C.iadd(yp), D.isub(xp)), C.iushrn(1), D.iushrn(1);\n          x.cmp(y) >= 0 \? (x.isub(y), A.isub(C), B.isub(D)) : (y.isub(x), C.isub(A), D.isub(B));\n        }\n        return {\n          a: C,\n          b: D,\n          gcd: y.iushln(g)\n        };\n      }, BN.prototype._invmp = function(p) {\n        assert(p.negative === 0), assert(!p.isZero());\n        var a = this, b = p.clone();\n        a.negative !== 0 \? a = a.umod(p) : a = a.clone();\n        for (var x1 = new BN(1), x2 = new BN(0), delta = b.clone();a.cmpn(1) > 0 && b.cmpn(1) > 0; ) {\n          for (var i = 0, im = 1;(a.words[0] & im) === 0 && i < 26; ++i, im <<= 1)\n            ;\n          if (i > 0)\n            for (a.iushrn(i);i-- > 0; )\n              x1.isOdd() && x1.iadd(delta), x1.iushrn(1);\n          for (var j = 0, jm = 1;(b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)\n            ;\n          if (j > 0)\n            for (b.iushrn(j);j-- > 0; )\n              x2.isOdd() && x2.iadd(delta), x2.iushrn(1);\n          a.cmp(b) >= 0 \? (a.isub(b), x1.isub(x2)) : (b.isub(a), x2.isub(x1));\n        }\n        var res;\n        return a.cmpn(1) === 0 \? res = x1 : res = x2, res.cmpn(0) < 0 && res.iadd(p), res;\n      }, BN.prototype.gcd = function(num) {\n        if (this.isZero())\n          return num.abs();\n        if (num.isZero())\n          return this.abs();\n        var a = this.clone(), b = num.clone();\n        a.negative = 0, b.negative = 0;\n        for (var shift = 0;a.isEven() && b.isEven(); shift++)\n          a.iushrn(1), b.iushrn(1);\n        do {\n          for (;a.isEven(); )\n            a.iushrn(1);\n          for (;b.isEven(); )\n            b.iushrn(1);\n          var r = a.cmp(b);\n          if (r < 0) {\n            var t = a;\n            a = b, b = t;\n          } else if (r === 0 || b.cmpn(1) === 0)\n            break;\n          a.isub(b);\n        } while (!0);\n        return b.iushln(shift);\n      }, BN.prototype.invm = function(num) {\n        return this.egcd(num).a.umod(num);\n      }, BN.prototype.isEven = function() {\n        return (this.words[0] & 1) === 0;\n      }, BN.prototype.isOdd = function() {\n        return (this.words[0] & 1) === 1;\n      }, BN.prototype.andln = function(num) {\n        return this.words[0] & num;\n      }, BN.prototype.bincn = function(bit) {\n        assert(typeof bit == \"number\");\n        var r = bit % 26, s = (bit - r) / 26, q = 1 << r;\n        if (this.length <= s)\n          return this._expand(s + 1), this.words[s] |= q, this;\n        for (var carry = q, i = s;carry !== 0 && i < this.length; i++) {\n          var w = this.words[i] | 0;\n          w += carry, carry = w >>> 26, w &= 67108863, this.words[i] = w;\n        }\n        return carry !== 0 && (this.words[i] = carry, this.length++), this;\n      }, BN.prototype.isZero = function() {\n        return this.length === 1 && this.words[0] === 0;\n      }, BN.prototype.cmpn = function(num) {\n        var negative = num < 0;\n        if (this.negative !== 0 && !negative)\n          return -1;\n        if (this.negative === 0 && negative)\n          return 1;\n        this.strip();\n        var res;\n        if (this.length > 1)\n          res = 1;\n        else {\n          negative && (num = -num), assert(num <= 67108863, \"Number is too big\");\n          var w = this.words[0] | 0;\n          res = w === num \? 0 : w < num \? -1 : 1;\n        }\n        return this.negative !== 0 \? -res | 0 : res;\n      }, BN.prototype.cmp = function(num) {\n        if (this.negative !== 0 && num.negative === 0)\n          return -1;\n        if (this.negative === 0 && num.negative !== 0)\n          return 1;\n        var res = this.ucmp(num);\n        return this.negative !== 0 \? -res | 0 : res;\n      }, BN.prototype.ucmp = function(num) {\n        if (this.length > num.length)\n          return 1;\n        if (this.length < num.length)\n          return -1;\n        for (var res = 0, i = this.length - 1;i >= 0; i--) {\n          var a = this.words[i] | 0, b = num.words[i] | 0;\n          if (a !== b) {\n            a < b \? res = -1 : a > b && (res = 1);\n            break;\n          }\n        }\n        return res;\n      }, BN.prototype.gtn = function(num) {\n        return this.cmpn(num) === 1;\n      }, BN.prototype.gt = function(num) {\n        return this.cmp(num) === 1;\n      }, BN.prototype.gten = function(num) {\n        return this.cmpn(num) >= 0;\n      }, BN.prototype.gte = function(num) {\n        return this.cmp(num) >= 0;\n      }, BN.prototype.ltn = function(num) {\n        return this.cmpn(num) === -1;\n      }, BN.prototype.lt = function(num) {\n        return this.cmp(num) === -1;\n      }, BN.prototype.lten = function(num) {\n        return this.cmpn(num) <= 0;\n      }, BN.prototype.lte = function(num) {\n        return this.cmp(num) <= 0;\n      }, BN.prototype.eqn = function(num) {\n        return this.cmpn(num) === 0;\n      }, BN.prototype.eq = function(num) {\n        return this.cmp(num) === 0;\n      }, BN.red = function(num) {\n        return new Red(num);\n      }, BN.prototype.toRed = function(ctx) {\n        return assert(!this.red, \"Already a number in reduction context\"), assert(this.negative === 0, \"red works only with positives\"), ctx.convertTo(this)._forceRed(ctx);\n      }, BN.prototype.fromRed = function() {\n        return assert(this.red, \"fromRed works only with numbers in reduction context\"), this.red.convertFrom(this);\n      }, BN.prototype._forceRed = function(ctx) {\n        return this.red = ctx, this;\n      }, BN.prototype.forceRed = function(ctx) {\n        return assert(!this.red, \"Already a number in reduction context\"), this._forceRed(ctx);\n      }, BN.prototype.redAdd = function(num) {\n        return assert(this.red, \"redAdd works only with red numbers\"), this.red.add(this, num);\n      }, BN.prototype.redIAdd = function(num) {\n        return assert(this.red, \"redIAdd works only with red numbers\"), this.red.iadd(this, num);\n      }, BN.prototype.redSub = function(num) {\n        return assert(this.red, \"redSub works only with red numbers\"), this.red.sub(this, num);\n      }, BN.prototype.redISub = function(num) {\n        return assert(this.red, \"redISub works only with red numbers\"), this.red.isub(this, num);\n      }, BN.prototype.redShl = function(num) {\n        return assert(this.red, \"redShl works only with red numbers\"), this.red.shl(this, num);\n      }, BN.prototype.redMul = function(num) {\n        return assert(this.red, \"redMul works only with red numbers\"), this.red._verify2(this, num), this.red.mul(this, num);\n      }, BN.prototype.redIMul = function(num) {\n        return assert(this.red, \"redMul works only with red numbers\"), this.red._verify2(this, num), this.red.imul(this, num);\n      }, BN.prototype.redSqr = function() {\n        return assert(this.red, \"redSqr works only with red numbers\"), this.red._verify1(this), this.red.sqr(this);\n      }, BN.prototype.redISqr = function() {\n        return assert(this.red, \"redISqr works only with red numbers\"), this.red._verify1(this), this.red.isqr(this);\n      }, BN.prototype.redSqrt = function() {\n        return assert(this.red, \"redSqrt works only with red numbers\"), this.red._verify1(this), this.red.sqrt(this);\n      }, BN.prototype.redInvm = function() {\n        return assert(this.red, \"redInvm works only with red numbers\"), this.red._verify1(this), this.red.invm(this);\n      }, BN.prototype.redNeg = function() {\n        return assert(this.red, \"redNeg works only with red numbers\"), this.red._verify1(this), this.red.neg(this);\n      }, BN.prototype.redPow = function(num) {\n        return assert(this.red && !num.red, \"redPow(normalNum)\"), this.red._verify1(this), this.red.pow(this, num);\n      };\n      var primes = {\n        k256: null,\n        p224: null,\n        p192: null,\n        p25519: null\n      };\n      function MPrime(name, p) {\n        this.name = name, this.p = new BN(p, 16), this.n = this.p.bitLength(), this.k = new BN(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();\n      }\n      MPrime.prototype = {}, MPrime.prototype._tmp = function() {\n        var tmp = new BN(null);\n        return tmp.words = new Array(Math.ceil(this.n / 13)), tmp;\n      }, MPrime.prototype.ireduce = function(num) {\n        var r = num, rlen;\n        do\n          this.split(r, this.tmp), r = this.imulK(r), r = r.iadd(this.tmp), rlen = r.bitLength();\n        while (rlen > this.n);\n        var cmp = rlen < this.n \? -1 : r.ucmp(this.p);\n        return cmp === 0 \? (r.words[0] = 0, r.length = 1) : cmp > 0 \? r.isub(this.p) : r.strip !== void 0 \? r.strip() : r._strip(), r;\n      }, MPrime.prototype.split = function(input, out) {\n        input.iushrn(this.n, 0, out);\n      }, MPrime.prototype.imulK = function(num) {\n        return num.imul(this.k);\n      };\n      function K256() {\n        MPrime.call(this, \"k256\", \"ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f\");\n      }\n      inherits(K256, MPrime), K256.prototype.split = function(input, output) {\n        for (var mask = 4194303, outLen = Math.min(input.length, 9), i = 0;i < outLen; i++)\n          output.words[i] = input.words[i];\n        if (output.length = outLen, input.length <= 9) {\n          input.words[0] = 0, input.length = 1;\n          return;\n        }\n        var prev = input.words[9];\n        for (output.words[output.length++] = prev & mask, i = 10;i < input.length; i++) {\n          var next = input.words[i] | 0;\n          input.words[i - 10] = (next & mask) << 4 | prev >>> 22, prev = next;\n        }\n        prev >>>= 22, input.words[i - 10] = prev, prev === 0 && input.length > 10 \? input.length -= 10 : input.length -= 9;\n      }, K256.prototype.imulK = function(num) {\n        num.words[num.length] = 0, num.words[num.length + 1] = 0, num.length += 2;\n        for (var lo = 0, i = 0;i < num.length; i++) {\n          var w = num.words[i] | 0;\n          lo += w * 977, num.words[i] = lo & 67108863, lo = w * 64 + (lo / 67108864 | 0);\n        }\n        return num.words[num.length - 1] === 0 && (num.length--, num.words[num.length - 1] === 0 && num.length--), num;\n      };\n      function P224() {\n        MPrime.call(this, \"p224\", \"ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001\");\n      }\n      inherits(P224, MPrime);\n      function P192() {\n        MPrime.call(this, \"p192\", \"ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff\");\n      }\n      inherits(P192, MPrime);\n      function P25519() {\n        MPrime.call(this, \"25519\", \"7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed\");\n      }\n      inherits(P25519, MPrime), P25519.prototype.imulK = function(num) {\n        for (var carry = 0, i = 0;i < num.length; i++) {\n          var hi = (num.words[i] | 0) * 19 + carry, lo = hi & 67108863;\n          hi >>>= 26, num.words[i] = lo, carry = hi;\n        }\n        return carry !== 0 && (num.words[num.length++] = carry), num;\n      }, BN._prime = function(name) {\n        if (primes[name])\n          return primes[name];\n        var prime2;\n        if (name === \"k256\")\n          prime2 = new K256;\n        else if (name === \"p224\")\n          prime2 = new P224;\n        else if (name === \"p192\")\n          prime2 = new P192;\n        else if (name === \"p25519\")\n          prime2 = new P25519;\n        else\n          throw new Error(\"Unknown prime \" + name);\n        return primes[name] = prime2, prime2;\n      };\n      function Red(m) {\n        if (typeof m == \"string\") {\n          var prime = BN._prime(m);\n          this.m = prime.p, this.prime = prime;\n        } else\n          assert(m.gtn(1), \"modulus must be greater than 1\"), this.m = m, this.prime = null;\n      }\n      Red.prototype = {}, Red.prototype._verify1 = function(a) {\n        assert(a.negative === 0, \"red works only with positives\"), assert(a.red, \"red works only with red numbers\");\n      }, Red.prototype._verify2 = function(a, b) {\n        assert((a.negative | b.negative) === 0, \"red works only with positives\"), assert(a.red && a.red === b.red, \"red works only with red numbers\");\n      }, Red.prototype.imod = function(a) {\n        return this.prime \? this.prime.ireduce(a)._forceRed(this) : a.umod(this.m)._forceRed(this);\n      }, Red.prototype.neg = function(a) {\n        return a.isZero() \? a.clone() : this.m.sub(a)._forceRed(this);\n      }, Red.prototype.add = function(a, b) {\n        this._verify2(a, b);\n        var res = a.add(b);\n        return res.cmp(this.m) >= 0 && res.isub(this.m), res._forceRed(this);\n      }, Red.prototype.iadd = function(a, b) {\n        this._verify2(a, b);\n        var res = a.iadd(b);\n        return res.cmp(this.m) >= 0 && res.isub(this.m), res;\n      }, Red.prototype.sub = function(a, b) {\n        this._verify2(a, b);\n        var res = a.sub(b);\n        return res.cmpn(0) < 0 && res.iadd(this.m), res._forceRed(this);\n      }, Red.prototype.isub = function(a, b) {\n        this._verify2(a, b);\n        var res = a.isub(b);\n        return res.cmpn(0) < 0 && res.iadd(this.m), res;\n      }, Red.prototype.shl = function(a, num) {\n        return this._verify1(a), this.imod(a.ushln(num));\n      }, Red.prototype.imul = function(a, b) {\n        return this._verify2(a, b), this.imod(a.imul(b));\n      }, Red.prototype.mul = function(a, b) {\n        return this._verify2(a, b), this.imod(a.mul(b));\n      }, Red.prototype.isqr = function(a) {\n        return this.imul(a, a.clone());\n      }, Red.prototype.sqr = function(a) {\n        return this.mul(a, a);\n      }, Red.prototype.sqrt = function(a) {\n        if (a.isZero())\n          return a.clone();\n        var mod3 = this.m.andln(3);\n        if (assert(mod3 % 2 === 1), mod3 === 3) {\n          var pow = this.m.add(new BN(1)).iushrn(2);\n          return this.pow(a, pow);\n        }\n        for (var q = this.m.subn(1), s = 0;!q.isZero() && q.andln(1) === 0; )\n          s++, q.iushrn(1);\n        assert(!q.isZero());\n        var one = new BN(1).toRed(this), nOne = one.redNeg(), lpow = this.m.subn(1).iushrn(1), z = this.m.bitLength();\n        for (z = new BN(2 * z * z).toRed(this);this.pow(z, lpow).cmp(nOne) !== 0; )\n          z.redIAdd(nOne);\n        for (var c = this.pow(z, q), r = this.pow(a, q.addn(1).iushrn(1)), t = this.pow(a, q), m = s;t.cmp(one) !== 0; ) {\n          for (var tmp = t, i = 0;tmp.cmp(one) !== 0; i++)\n            tmp = tmp.redSqr();\n          assert(i < m);\n          var b = this.pow(c, new BN(1).iushln(m - i - 1));\n          r = r.redMul(b), c = b.redSqr(), t = t.redMul(c), m = i;\n        }\n        return r;\n      }, Red.prototype.invm = function(a) {\n        var inv = a._invmp(this.m);\n        return inv.negative !== 0 \? (inv.negative = 0, this.imod(inv).redNeg()) : this.imod(inv);\n      }, Red.prototype.pow = function(a, num) {\n        if (num.isZero())\n          return new BN(1).toRed(this);\n        if (num.cmpn(1) === 0)\n          return a.clone();\n        var windowSize = 4, wnd = new Array(1 << windowSize);\n        wnd[0] = new BN(1).toRed(this), wnd[1] = a;\n        for (var i = 2;i < wnd.length; i++)\n          wnd[i] = this.mul(wnd[i - 1], a);\n        var res = wnd[0], current = 0, currentLen = 0, start = num.bitLength() % 26;\n        for (start === 0 && (start = 26), i = num.length - 1;i >= 0; i--) {\n          for (var word = num.words[i], j = start - 1;j >= 0; j--) {\n            var bit = word >> j & 1;\n            if (res !== wnd[0] && (res = this.sqr(res)), bit === 0 && current === 0) {\n              currentLen = 0;\n              continue;\n            }\n            current <<= 1, current |= bit, currentLen++, !(currentLen !== windowSize && (i !== 0 || j !== 0)) && (res = this.mul(res, wnd[current]), currentLen = 0, current = 0);\n          }\n          start = 26;\n        }\n        return res;\n      }, Red.prototype.convertTo = function(num) {\n        var r = num.umod(this.m);\n        return r === num \? r.clone() : r;\n      }, Red.prototype.convertFrom = function(num) {\n        var res = num.clone();\n        return res.red = null, res;\n      }, BN.mont = function(num) {\n        return new Mont(num);\n      };\n      function Mont(m) {\n        Red.call(this, m), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new BN(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);\n      }\n      inherits(Mont, Red), Mont.prototype.convertTo = function(num) {\n        return this.imod(num.ushln(this.shift));\n      }, Mont.prototype.convertFrom = function(num) {\n        var r = this.imod(num.mul(this.rinv));\n        return r.red = null, r;\n      }, Mont.prototype.imul = function(a, b) {\n        if (a.isZero() || b.isZero())\n          return a.words[0] = 0, a.length = 1, a;\n        var t = a.imul(b), c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), u = t.isub(c).iushrn(this.shift), res = u;\n        return u.cmp(this.m) >= 0 \? res = u.isub(this.m) : u.cmpn(0) < 0 && (res = u.iadd(this.m)), res._forceRed(this);\n      }, Mont.prototype.mul = function(a, b) {\n        if (a.isZero() || b.isZero())\n          return new BN(0)._forceRed(this);\n        var t = a.mul(b), c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), u = t.isub(c).iushrn(this.shift), res = u;\n        return u.cmp(this.m) >= 0 \? res = u.isub(this.m) : u.cmpn(0) < 0 && (res = u.iadd(this.m)), res._forceRed(this);\n      }, Mont.prototype.invm = function(a) {\n        var res = this.imod(a._invmp(this.m).mul(this.r2));\n        return res._forceRed(this);\n      };\n    })(typeof module > \"u\" || module, exports);\n  }\n}), require_bn2 = require_bn, require_brorand = __commonJS({\n  \"node_modules/brorand/index.js\"(exports, module) {\n    var r;\n    module.exports = function(len) {\n      return r || (r = new Rand(null)), r.generate(len);\n    };\n    function Rand(rand) {\n      this.rand = rand;\n    }\n    Rand.prototype = {}, module.exports.Rand = Rand, Rand.prototype.generate = function(len) {\n      return this._rand(len);\n    }, Rand.prototype._rand = function(n) {\n      var out = new Buffer(n);\n      return crypto.getRandomValues(out), out;\n    };\n  }\n}), require_mr = __commonJS({\n  \"node_modules/miller-rabin/lib/mr.js\"(exports, module) {\n    var bn = require_bn2(), brorand = require_brorand();\n    function MillerRabin(rand) {\n      this.rand = rand || new brorand.Rand;\n    }\n    module.exports = MillerRabin, MillerRabin.create = function(rand) {\n      return new MillerRabin(rand);\n    }, MillerRabin.prototype = {}, MillerRabin.prototype._randbelow = function(n) {\n      var len = n.bitLength(), min_bytes = Math.ceil(len / 8);\n      do\n        var a = new bn(this.rand.generate(min_bytes));\n      while (a.cmp(n) >= 0);\n      return a;\n    }, MillerRabin.prototype._randrange = function(start, stop) {\n      var size = stop.sub(start);\n      return start.add(this._randbelow(size));\n    }, MillerRabin.prototype.test = function(n, k, cb) {\n      var len = n.bitLength(), red = bn.mont(n), rone = new bn(1).toRed(red);\n      k || (k = Math.max(1, len / 48 | 0));\n      for (var n1 = n.subn(1), s = 0;!n1.testn(s); s++)\n        ;\n      for (var d = n.shrn(s), rn1 = n1.toRed(red), prime = !0;k > 0; k--) {\n        var a = this._randrange(new bn(2), n1);\n        cb && cb(a);\n        var x = a.toRed(red).redPow(d);\n        if (!(x.cmp(rone) === 0 || x.cmp(rn1) === 0)) {\n          for (var i = 1;i < s; i++) {\n            if (x = x.redSqr(), x.cmp(rone) === 0)\n              return !1;\n            if (x.cmp(rn1) === 0)\n              break;\n          }\n          if (i === s)\n            return !1;\n        }\n      }\n      return prime;\n    }, MillerRabin.prototype.getDivisor = function(n, k) {\n      var len = n.bitLength(), red = bn.mont(n), rone = new bn(1).toRed(red);\n      k || (k = Math.max(1, len / 48 | 0));\n      for (var n1 = n.subn(1), s = 0;!n1.testn(s); s++)\n        ;\n      for (var d = n.shrn(s), rn1 = n1.toRed(red);k > 0; k--) {\n        var a = this._randrange(new bn(2), n1), g = n.gcd(a);\n        if (g.cmpn(1) !== 0)\n          return g;\n        var x = a.toRed(red).redPow(d);\n        if (!(x.cmp(rone) === 0 || x.cmp(rn1) === 0)) {\n          for (var i = 1;i < s; i++) {\n            if (x = x.redSqr(), x.cmp(rone) === 0)\n              return x.fromRed().subn(1).gcd(n);\n            if (x.cmp(rn1) === 0)\n              break;\n          }\n          if (i === s)\n            return x = x.redSqr(), x.fromRed().subn(1).gcd(n);\n        }\n      }\n      return !1;\n    };\n  }\n}), require_generatePrime = __commonJS({\n  \"node_modules/diffie-hellman/lib/generatePrime.js\"(exports, module) {\n    var randomBytes = require_browser();\n    module.exports = findPrime, findPrime.simpleSieve = simpleSieve, findPrime.fermatTest = fermatTest;\n    var BN = require_bn(), TWENTYFOUR = new BN(24), MillerRabin = require_mr(), millerRabin = new MillerRabin, ONE = new BN(1), TWO = new BN(2), FIVE = new BN(5), SIXTEEN = new BN(16), EIGHT = new BN(8), TEN = new BN(10), THREE = new BN(3), SEVEN = new BN(7), ELEVEN = new BN(11), FOUR = new BN(4), TWELVE = new BN(12), primes = null;\n    function _getPrimes() {\n      if (primes !== null)\n        return primes;\n      var limit = 1048576, res = [];\n      res[0] = 2;\n      for (var i = 1, k = 3;k < limit; k += 2) {\n        for (var sqrt = Math.ceil(Math.sqrt(k)), j = 0;j < i && res[j] <= sqrt && k % res[j] !== 0; j++)\n          ;\n        i !== j && res[j] <= sqrt || (res[i++] = k);\n      }\n      return primes = res, res;\n    }\n    function simpleSieve(p) {\n      for (var primes2 = _getPrimes(), i = 0;i < primes2.length; i++)\n        if (p.modn(primes2[i]) === 0)\n          return p.cmpn(primes2[i]) === 0;\n      return !0;\n    }\n    function fermatTest(p) {\n      var red = BN.mont(p);\n      return TWO.toRed(red).redPow(p.subn(1)).fromRed().cmpn(1) === 0;\n    }\n    function findPrime(bits, gen) {\n      if (bits < 16)\n        return gen === 2 || gen === 5 \? new BN([140, 123]) : new BN([140, 39]);\n      gen = new BN(gen);\n      for (var num, n2;; ) {\n        for (num = new BN(randomBytes(Math.ceil(bits / 8)));num.bitLength() > bits; )\n          num.ishrn(1);\n        if (num.isEven() && num.iadd(ONE), num.testn(1) || num.iadd(TWO), gen.cmp(TWO)) {\n          if (!gen.cmp(FIVE))\n            for (;num.mod(TEN).cmp(THREE); )\n              num.iadd(FOUR);\n        } else\n          for (;num.mod(TWENTYFOUR).cmp(ELEVEN); )\n            num.iadd(FOUR);\n        if (n2 = num.shrn(1), simpleSieve(n2) && simpleSieve(num) && fermatTest(n2) && fermatTest(num) && millerRabin.test(n2) && millerRabin.test(num))\n          return num;\n      }\n    }\n  }\n}), require_primes = __commonJS({\n  \"node_modules/diffie-hellman/lib/primes.json\"(exports, module) {\n    module.exports = {\n      modp1: {\n        gen: \"02\",\n        prime: \"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a63a3620ffffffffffffffff\"\n      },\n      modp2: {\n        gen: \"02\",\n        prime: \"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece65381ffffffffffffffff\"\n      },\n      modp5: {\n        gen: \"02\",\n        prime: \"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca237327ffffffffffffffff\"\n      },\n      modp14: {\n        gen: \"02\",\n        prime: \"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aacaa68ffffffffffffffff\"\n      },\n      modp15: {\n        gen: \"02\",\n        prime: \"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a93ad2caffffffffffffffff\"\n      },\n      modp16: {\n        gen: \"02\",\n        prime: \"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c934063199ffffffffffffffff\"\n      },\n      modp17: {\n        gen: \"02\",\n        prime: \"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dcc4024ffffffffffffffff\"\n      },\n      modp18: {\n        gen: \"02\",\n        prime: \"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dbe115974a3926f12fee5e438777cb6a932df8cd8bec4d073b931ba3bc832b68d9dd300741fa7bf8afc47ed2576f6936ba424663aab639c5ae4f5683423b4742bf1c978238f16cbe39d652de3fdb8befc848ad922222e04a4037c0713eb57a81a23f0c73473fc646cea306b4bcbc8862f8385ddfa9d4b7fa2c087e879683303ed5bdd3a062b3cf5b3a278a66d2a13f83f44f82ddf310ee074ab6a364597e899a0255dc164f31cc50846851df9ab48195ded7ea1b1d510bd7ee74d73faf36bc31ecfa268359046f4eb879f924009438b481c6cd7889a002ed5ee382bc9190da6fc026e479558e4475677e9aa9e3050e2765694dfc81f56e880b96e7160c980dd98edd3dfffffffffffffffff\"\n      }\n    };\n  }\n}), require_dh = __commonJS({\n  \"node_modules/diffie-hellman/lib/dh.js\"(exports, module) {\n    var BN = require_bn(), MillerRabin = require_mr(), millerRabin = new MillerRabin, TWENTYFOUR = new BN(24), ELEVEN = new BN(11), TEN = new BN(10), THREE = new BN(3), SEVEN = new BN(7), primes = require_generatePrime(), randomBytes = require_browser();\n    module.exports = DH;\n    function setPublicKey(pub, enc) {\n      return enc = enc || \"utf8\", Buffer.isBuffer(pub) || (pub = new Buffer(pub, enc)), this._pub = new BN(pub), this;\n    }\n    function setPrivateKey(priv, enc) {\n      return enc = enc || \"utf8\", Buffer.isBuffer(priv) || (priv = new Buffer(priv, enc)), this._priv = new BN(priv), this;\n    }\n    var primeCache = {};\n    function checkPrime(prime, generator) {\n      var gen = generator.toString(\"hex\"), hex = [gen, prime.toString(16)].join(\"_\");\n      if (hex in primeCache)\n        return primeCache[hex];\n      var error = 0;\n      if (prime.isEven() || !primes.simpleSieve || !primes.fermatTest(prime) || !millerRabin.test(prime))\n        return error += 1, gen === \"02\" || gen === \"05\" \? error += 8 : error += 4, primeCache[hex] = error, error;\n      millerRabin.test(prime.shrn(1)) || (error += 2);\n      var rem;\n      switch (gen) {\n        case \"02\":\n          prime.mod(TWENTYFOUR).cmp(ELEVEN) && (error += 8);\n          break;\n        case \"05\":\n          rem = prime.mod(TEN), rem.cmp(THREE) && rem.cmp(SEVEN) && (error += 8);\n          break;\n        default:\n          error += 4;\n      }\n      return primeCache[hex] = error, error;\n    }\n    function DH(prime, generator, malleable) {\n      this.setGenerator(generator), this.__prime = new BN(prime), this._prime = BN.mont(this.__prime), this._primeLen = prime.length, this._pub = void 0, this._priv = void 0, this._primeCode = void 0, malleable \? (this.setPublicKey = setPublicKey, this.setPrivateKey = setPrivateKey) : this._primeCode = 8;\n    }\n    DH.prototype = {}, Object.defineProperty(DH.prototype, \"verifyError\", {\n      enumerable: !0,\n      get: function() {\n        return typeof this._primeCode != \"number\" && (this._primeCode = checkPrime(this.__prime, this.__gen)), this._primeCode;\n      }\n    }), DH.prototype.generateKeys = function() {\n      return this._priv || (this._priv = new BN(randomBytes(this._primeLen))), this._pub = this._gen.toRed(this._prime).redPow(this._priv).fromRed(), this.getPublicKey();\n    }, DH.prototype.computeSecret = function(other) {\n      other = new BN(other), other = other.toRed(this._prime);\n      var secret = other.redPow(this._priv).fromRed(), out = new Buffer(secret.toArray()), prime = this.getPrime();\n      if (out.length < prime.length) {\n        var front = new Buffer(prime.length - out.length);\n        front.fill(0), out = Buffer.concat([front, out]);\n      }\n      return out;\n    }, DH.prototype.getPublicKey = function(enc) {\n      return formatReturnValue(this._pub, enc);\n    }, DH.prototype.getPrivateKey = function(enc) {\n      return formatReturnValue(this._priv, enc);\n    }, DH.prototype.getPrime = function(enc) {\n      return formatReturnValue(this.__prime, enc);\n    }, DH.prototype.getGenerator = function(enc) {\n      return formatReturnValue(this._gen, enc);\n    }, DH.prototype.setGenerator = function(gen, enc) {\n      return enc = enc || \"utf8\", Buffer.isBuffer(gen) || (gen = new Buffer(gen, enc)), this.__gen = gen, this._gen = new BN(gen), this;\n    };\n    function formatReturnValue(bn, enc) {\n      var buf = new Buffer(bn.toArray());\n      return enc \? buf.toString(enc) : buf;\n    }\n  }\n}), require_browser7 = __commonJS({\n  \"node_modules/diffie-hellman/browser.js\"(exports) {\n    var generatePrime = require_generatePrime(), primes = require_primes(), DH = require_dh();\n    function getDiffieHellman(mod) {\n      var prime = new Buffer(primes[mod].prime, \"hex\"), gen = new Buffer(primes[mod].gen, \"hex\");\n      return new DH(prime, gen);\n    }\n    var ENCODINGS = {\n      binary: !0,\n      hex: !0,\n      base64: !0\n    };\n    function createDiffieHellman(prime, enc, generator, genc) {\n      return Buffer.isBuffer(enc) || ENCODINGS[enc] === void 0 \? createDiffieHellman(prime, \"binary\", enc, generator) : (enc = enc || \"binary\", genc = genc || \"binary\", generator = generator || new Buffer([2]), Buffer.isBuffer(generator) || (generator = new Buffer(generator, genc)), typeof prime == \"number\" \? new DH(generatePrime(prime, generator), generator, !0) : (Buffer.isBuffer(prime) || (prime = new Buffer(prime, enc)), new DH(prime, generator, !0)));\n    }\n    exports.DiffieHellmanGroup = exports.createDiffieHellmanGroup = exports.getDiffieHellman = getDiffieHellman, exports.createDiffieHellman = exports.DiffieHellman = createDiffieHellman;\n  }\n}), require_bn3 = require_bn, require_browserify_rsa = __commonJS({\n  \"node_modules/browserify-rsa/index.js\"(exports, module) {\n    var BN = require_bn3(), randomBytes = require_browser();\n    function blind(priv) {\n      var r = getr(priv), blinder = r.toRed(BN.mont(priv.modulus)).redPow(new BN(priv.publicExponent)).fromRed();\n      return { blinder, unblinder: r.invm(priv.modulus) };\n    }\n    function getr(priv) {\n      var len = priv.modulus.byteLength(), r;\n      do\n        r = new BN(randomBytes(len));\n      while (r.cmp(priv.modulus) >= 0 || !r.umod(priv.prime1) || !r.umod(priv.prime2));\n      return r;\n    }\n    function crt(msg, priv) {\n      var blinds = blind(priv), len = priv.modulus.byteLength(), blinded = new BN(msg).mul(blinds.blinder).umod(priv.modulus), c1 = blinded.toRed(BN.mont(priv.prime1)), c2 = blinded.toRed(BN.mont(priv.prime2)), qinv = priv.coefficient, p = priv.prime1, q = priv.prime2, m1 = c1.redPow(priv.exponent1).fromRed(), m2 = c2.redPow(priv.exponent2).fromRed(), h = m1.isub(m2).imul(qinv).umod(p).imul(q);\n      return m2.iadd(h).imul(blinds.unblinder).umod(priv.modulus).toArrayLike(Buffer, \"be\", len);\n    }\n    crt.getr = getr, module.exports = crt;\n  }\n}), require_package = __commonJS({\n  \"node_modules/elliptic/package.json\"(exports, module) {\n    module.exports = {\n      name: \"elliptic\",\n      version: \"6.5.4\",\n      description: \"EC cryptography\",\n      main: \"lib/elliptic.js\",\n      files: [\"lib\"],\n      scripts: {\n        lint: \"eslint lib test\",\n        \"lint:fix\": \"npm run lint -- --fix\",\n        unit: \"istanbul test _mocha --reporter=spec test/index.js\",\n        test: \"npm run lint && npm run unit\",\n        version: \"grunt dist && git add dist/\"\n      },\n      repository: {\n        type: \"git\",\n        url: \"git@github.com:indutny/elliptic\"\n      },\n      keywords: [\"EC\", \"Elliptic\", \"curve\", \"Cryptography\"],\n      author: \"Fedor Indutny <fedor@indutny.com>\",\n      license: \"MIT\",\n      bugs: {\n        url: \"https://github.com/indutny/elliptic/issues\"\n      },\n      homepage: \"https://github.com/indutny/elliptic\",\n      devDependencies: {\n        brfs: \"^2.0.2\",\n        coveralls: \"^3.1.0\",\n        eslint: \"^7.6.0\",\n        grunt: \"^1.2.1\",\n        \"grunt-browserify\": \"^5.3.0\",\n        \"grunt-cli\": \"^1.3.2\",\n        \"grunt-contrib-connect\": \"^3.0.0\",\n        \"grunt-contrib-copy\": \"^1.0.0\",\n        \"grunt-contrib-uglify\": \"^5.0.0\",\n        \"grunt-mocha-istanbul\": \"^5.0.2\",\n        \"grunt-saucelabs\": \"^9.0.1\",\n        istanbul: \"^0.4.5\",\n        mocha: \"^8.0.1\"\n      },\n      dependencies: {\n        \"bn.js\": \"^4.11.9\",\n        brorand: \"^1.1.0\",\n        \"hash.js\": \"^1.0.0\",\n        \"hmac-drbg\": \"^1.0.1\",\n        inherits: \"^2.0.4\",\n        \"minimalistic-assert\": \"^1.0.1\",\n        \"minimalistic-crypto-utils\": \"^1.0.1\"\n      }\n    };\n  }\n}), require_bn4 = require_bn, require_utils2 = __commonJS({\n  \"node_modules/minimalistic-crypto-utils/lib/utils.js\"(exports) {\n    var utils = exports;\n    function toArray(msg, enc) {\n      if (Array.isArray(msg))\n        return msg.slice();\n      if (!msg)\n        return [];\n      var res = [];\n      if (typeof msg != \"string\") {\n        for (var i = 0;i < msg.length; i++)\n          res[i] = msg[i] | 0;\n        return res;\n      }\n      if (enc === \"hex\") {\n        msg = msg.replace(/[^a-z0-9]+/gi, \"\"), msg.length % 2 !== 0 && (msg = \"0\" + msg);\n        for (var i = 0;i < msg.length; i += 2)\n          res.push(parseInt(msg[i] + msg[i + 1], 16));\n      } else\n        for (var i = 0;i < msg.length; i++) {\n          var c = msg.charCodeAt(i), hi = c >> 8, lo = c & 255;\n          hi \? res.push(hi, lo) : res.push(lo);\n        }\n      return res;\n    }\n    utils.toArray = toArray;\n    function zero2(word) {\n      return word.length === 1 \? \"0\" + word : word;\n    }\n    utils.zero2 = zero2;\n    function toHex(msg) {\n      for (var res = \"\", i = 0;i < msg.length; i++)\n        res += zero2(msg[i].toString(16));\n      return res;\n    }\n    utils.toHex = toHex, utils.encode = function(arr, enc) {\n      return enc === \"hex\" \? toHex(arr) : arr;\n    };\n  }\n}), require_utils3 = __commonJS({\n  \"node_modules/elliptic/lib/elliptic/utils.js\"(exports) {\n    var utils = exports, BN = require_bn4(), minAssert = require_minimalistic_assert(), minUtils = require_utils2();\n    utils.assert = minAssert, utils.toArray = minUtils.toArray, utils.zero2 = minUtils.zero2, utils.toHex = minUtils.toHex, utils.encode = minUtils.encode;\n    function getNAF(num, w, bits) {\n      var naf = new Array(Math.max(num.bitLength(), bits) + 1);\n      naf.fill(0);\n      for (var ws = 1 << w + 1, k = num.clone(), i = 0;i < naf.length; i++) {\n        var z, mod = k.andln(ws - 1);\n        k.isOdd() \? (mod > (ws >> 1) - 1 \? z = (ws >> 1) - mod : z = mod, k.isubn(z)) : z = 0, naf[i] = z, k.iushrn(1);\n      }\n      return naf;\n    }\n    utils.getNAF = getNAF;\n    function getJSF(k1, k2) {\n      var jsf = [[], []];\n      k1 = k1.clone(), k2 = k2.clone();\n      for (var d1 = 0, d2 = 0, m8;k1.cmpn(-d1) > 0 || k2.cmpn(-d2) > 0; ) {\n        var m14 = k1.andln(3) + d1 & 3, m24 = k2.andln(3) + d2 & 3;\n        m14 === 3 && (m14 = -1), m24 === 3 && (m24 = -1);\n        var u1;\n        (m14 & 1) === 0 \? u1 = 0 : (m8 = k1.andln(7) + d1 & 7, (m8 === 3 || m8 === 5) && m24 === 2 \? u1 = -m14 : u1 = m14), jsf[0].push(u1);\n        var u2;\n        (m24 & 1) === 0 \? u2 = 0 : (m8 = k2.andln(7) + d2 & 7, (m8 === 3 || m8 === 5) && m14 === 2 \? u2 = -m24 : u2 = m24), jsf[1].push(u2), 2 * d1 === u1 + 1 && (d1 = 1 - d1), 2 * d2 === u2 + 1 && (d2 = 1 - d2), k1.iushrn(1), k2.iushrn(1);\n      }\n      return jsf;\n    }\n    utils.getJSF = getJSF;\n    function cachedProperty(obj, name, computer) {\n      var key = \"_\" + name;\n      obj.prototype[name] = function() {\n        return this[key] !== void 0 \? this[key] : this[key] = computer.call(this);\n      };\n    }\n    utils.cachedProperty = cachedProperty;\n    function parseBytes(bytes) {\n      return typeof bytes == \"string\" \? utils.toArray(bytes, \"hex\") : bytes;\n    }\n    utils.parseBytes = parseBytes;\n    function intFromLE(bytes) {\n      return new BN(bytes, \"hex\", \"le\");\n    }\n    utils.intFromLE = intFromLE;\n  }\n}), require_base = __commonJS({\n  \"node_modules/elliptic/lib/elliptic/curve/base.js\"(exports, module) {\n    var BN = require_bn4(), utils = require_utils3(), getNAF = utils.getNAF, getJSF = utils.getJSF, assert = utils.assert;\n    function BaseCurve(type, conf) {\n      this.type = type, this.p = new BN(conf.p, 16), this.red = conf.prime \? BN.red(conf.prime) : BN.mont(this.p), this.zero = new BN(0).toRed(this.red), this.one = new BN(1).toRed(this.red), this.two = new BN(2).toRed(this.red), this.n = conf.n && new BN(conf.n, 16), this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed), this._wnafT1 = new Array(4), this._wnafT2 = new Array(4), this._wnafT3 = new Array(4), this._wnafT4 = new Array(4), this._bitLength = this.n \? this.n.bitLength() : 0;\n      var adjustCount = this.n && this.p.div(this.n);\n      !adjustCount || adjustCount.cmpn(100) > 0 \? this.redN = null : (this._maxwellTrick = !0, this.redN = this.n.toRed(this.red));\n    }\n    module.exports = BaseCurve, BaseCurve.prototype = {}, BaseCurve.prototype.point = function() {\n      throw new Error(\"Not implemented\");\n    }, BaseCurve.prototype.validate = function() {\n      throw new Error(\"Not implemented\");\n    }, BaseCurve.prototype._fixedNafMul = function(p, k) {\n      assert(p.precomputed);\n      var doubles = p._getDoubles(), naf = getNAF(k, 1, this._bitLength), I = (1 << doubles.step + 1) - (doubles.step % 2 === 0 \? 2 : 1);\n      I /= 3;\n      var repr = [], j, nafW;\n      for (j = 0;j < naf.length; j += doubles.step) {\n        nafW = 0;\n        for (var l = j + doubles.step - 1;l >= j; l--)\n          nafW = (nafW << 1) + naf[l];\n        repr.push(nafW);\n      }\n      for (var a = this.jpoint(null, null, null), b = this.jpoint(null, null, null), i = I;i > 0; i--) {\n        for (j = 0;j < repr.length; j++)\n          nafW = repr[j], nafW === i \? b = b.mixedAdd(doubles.points[j]) : nafW === -i && (b = b.mixedAdd(doubles.points[j].neg()));\n        a = a.add(b);\n      }\n      return a.toP();\n    }, BaseCurve.prototype._wnafMul = function(p, k) {\n      var w = 4, nafPoints = p._getNAFPoints(w);\n      w = nafPoints.wnd;\n      for (var wnd = nafPoints.points, naf = getNAF(k, w, this._bitLength), acc = this.jpoint(null, null, null), i = naf.length - 1;i >= 0; i--) {\n        for (var l = 0;i >= 0 && naf[i] === 0; i--)\n          l++;\n        if (i >= 0 && l++, acc = acc.dblp(l), i < 0)\n          break;\n        var z = naf[i];\n        assert(z !== 0), p.type === \"affine\" \? z > 0 \? acc = acc.mixedAdd(wnd[z - 1 >> 1]) : acc = acc.mixedAdd(wnd[-z - 1 >> 1].neg()) : z > 0 \? acc = acc.add(wnd[z - 1 >> 1]) : acc = acc.add(wnd[-z - 1 >> 1].neg());\n      }\n      return p.type === \"affine\" \? acc.toP() : acc;\n    }, BaseCurve.prototype._wnafMulAdd = function(defW, points, coeffs, len, jacobianResult) {\n      var wndWidth = this._wnafT1, wnd = this._wnafT2, naf = this._wnafT3, max = 0, i, j, p;\n      for (i = 0;i < len; i++) {\n        p = points[i];\n        var nafPoints = p._getNAFPoints(defW);\n        wndWidth[i] = nafPoints.wnd, wnd[i] = nafPoints.points;\n      }\n      for (i = len - 1;i >= 1; i -= 2) {\n        var a = i - 1, b = i;\n        if (wndWidth[a] !== 1 || wndWidth[b] !== 1) {\n          naf[a] = getNAF(coeffs[a], wndWidth[a], this._bitLength), naf[b] = getNAF(coeffs[b], wndWidth[b], this._bitLength), max = Math.max(naf[a].length, max), max = Math.max(naf[b].length, max);\n          continue;\n        }\n        var comb = [points[a], null, null, points[b]];\n        points[a].y.cmp(points[b].y) === 0 \? (comb[1] = points[a].add(points[b]), comb[2] = points[a].toJ().mixedAdd(points[b].neg())) : points[a].y.cmp(points[b].y.redNeg()) === 0 \? (comb[1] = points[a].toJ().mixedAdd(points[b]), comb[2] = points[a].add(points[b].neg())) : (comb[1] = points[a].toJ().mixedAdd(points[b]), comb[2] = points[a].toJ().mixedAdd(points[b].neg()));\n        var index = [-3, -1, -5, -7, 0, 7, 5, 1, 3], jsf = getJSF(coeffs[a], coeffs[b]);\n        for (max = Math.max(jsf[0].length, max), naf[a] = new Array(max), naf[b] = new Array(max), j = 0;j < max; j++) {\n          var ja = jsf[0][j] | 0, jb = jsf[1][j] | 0;\n          naf[a][j] = index[(ja + 1) * 3 + (jb + 1)], naf[b][j] = 0, wnd[a] = comb;\n        }\n      }\n      var acc = this.jpoint(null, null, null), tmp = this._wnafT4;\n      for (i = max;i >= 0; i--) {\n        for (var k = 0;i >= 0; ) {\n          var zero = !0;\n          for (j = 0;j < len; j++)\n            tmp[j] = naf[j][i] | 0, tmp[j] !== 0 && (zero = !1);\n          if (!zero)\n            break;\n          k++, i--;\n        }\n        if (i >= 0 && k++, acc = acc.dblp(k), i < 0)\n          break;\n        for (j = 0;j < len; j++) {\n          var z = tmp[j];\n          z !== 0 && (z > 0 \? p = wnd[j][z - 1 >> 1] : z < 0 && (p = wnd[j][-z - 1 >> 1].neg()), p.type === \"affine\" \? acc = acc.mixedAdd(p) : acc = acc.add(p));\n        }\n      }\n      for (i = 0;i < len; i++)\n        wnd[i] = null;\n      return jacobianResult \? acc : acc.toP();\n    };\n    function BasePoint(curve, type) {\n      this.curve = curve, this.type = type, this.precomputed = null;\n    }\n    BasePoint.prototype = {}, BaseCurve.BasePoint = BasePoint, BasePoint.prototype.eq = function() {\n      throw new Error(\"Not implemented\");\n    }, BasePoint.prototype.validate = function() {\n      return this.curve.validate(this);\n    }, BaseCurve.prototype.decodePoint = function(bytes, enc) {\n      bytes = utils.toArray(bytes, enc);\n      var len = this.p.byteLength();\n      if ((bytes[0] === 4 || bytes[0] === 6 || bytes[0] === 7) && bytes.length - 1 === 2 * len) {\n        bytes[0] === 6 \? assert(bytes[bytes.length - 1] % 2 === 0) : bytes[0] === 7 && assert(bytes[bytes.length - 1] % 2 === 1);\n        var res = this.point(bytes.slice(1, 1 + len), bytes.slice(1 + len, 1 + 2 * len));\n        return res;\n      } else if ((bytes[0] === 2 || bytes[0] === 3) && bytes.length - 1 === len)\n        return this.pointFromX(bytes.slice(1, 1 + len), bytes[0] === 3);\n      throw new Error(\"Unknown point format\");\n    }, BasePoint.prototype.encodeCompressed = function(enc) {\n      return this.encode(enc, !0);\n    }, BasePoint.prototype._encode = function(compact) {\n      var len = this.curve.p.byteLength(), x = this.getX().toArray(\"be\", len);\n      return compact \? [this.getY().isEven() \? 2 : 3].concat(x) : [4].concat(x, this.getY().toArray(\"be\", len));\n    }, BasePoint.prototype.encode = function(enc, compact) {\n      return utils.encode(this._encode(compact), enc);\n    }, BasePoint.prototype.precompute = function(power) {\n      if (this.precomputed)\n        return this;\n      var precomputed = {\n        doubles: null,\n        naf: null,\n        beta: null\n      };\n      return precomputed.naf = this._getNAFPoints(8), precomputed.doubles = this._getDoubles(4, power), precomputed.beta = this._getBeta(), this.precomputed = precomputed, this;\n    }, BasePoint.prototype._hasDoubles = function(k) {\n      if (!this.precomputed)\n        return !1;\n      var doubles = this.precomputed.doubles;\n      return doubles \? doubles.points.length >= Math.ceil((k.bitLength() + 1) / doubles.step) : !1;\n    }, BasePoint.prototype._getDoubles = function(step, power) {\n      if (this.precomputed && this.precomputed.doubles)\n        return this.precomputed.doubles;\n      for (var doubles = [this], acc = this, i = 0;i < power; i += step) {\n        for (var j = 0;j < step; j++)\n          acc = acc.dbl();\n        doubles.push(acc);\n      }\n      return {\n        step,\n        points: doubles\n      };\n    }, BasePoint.prototype._getNAFPoints = function(wnd) {\n      if (this.precomputed && this.precomputed.naf)\n        return this.precomputed.naf;\n      for (var res = [this], max = (1 << wnd) - 1, dbl = max === 1 \? null : this.dbl(), i = 1;i < max; i++)\n        res[i] = res[i - 1].add(dbl);\n      return {\n        wnd,\n        points: res\n      };\n    }, BasePoint.prototype._getBeta = function() {\n      return null;\n    }, BasePoint.prototype.dblp = function(k) {\n      for (var r = this, i = 0;i < k; i++)\n        r = r.dbl();\n      return r;\n    };\n  }\n}), require_short = __commonJS({\n  \"node_modules/elliptic/lib/elliptic/curve/short.js\"(exports, module) {\n    var utils = require_utils3(), BN = require_bn4(), inherits = require_inherits_browser(), Base = require_base(), assert = utils.assert;\n    function ShortCurve(conf) {\n      Base.call(this, \"short\", conf), this.a = new BN(conf.a, 16).toRed(this.red), this.b = new BN(conf.b, 16).toRed(this.red), this.tinv = this.two.redInvm(), this.zeroA = this.a.fromRed().cmpn(0) === 0, this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0, this.endo = this._getEndomorphism(conf), this._endoWnafT1 = new Array(4), this._endoWnafT2 = new Array(4);\n    }\n    inherits(ShortCurve, Base), module.exports = ShortCurve, ShortCurve.prototype._getEndomorphism = function(conf) {\n      if (!(!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)) {\n        var beta, lambda;\n        if (conf.beta)\n          beta = new BN(conf.beta, 16).toRed(this.red);\n        else {\n          var betas = this._getEndoRoots(this.p);\n          beta = betas[0].cmp(betas[1]) < 0 \? betas[0] : betas[1], beta = beta.toRed(this.red);\n        }\n        if (conf.lambda)\n          lambda = new BN(conf.lambda, 16);\n        else {\n          var lambdas = this._getEndoRoots(this.n);\n          this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0 \? lambda = lambdas[0] : (lambda = lambdas[1], assert(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0));\n        }\n        var basis;\n        return conf.basis \? basis = conf.basis.map(function(vec) {\n          return {\n            a: new BN(vec.a, 16),\n            b: new BN(vec.b, 16)\n          };\n        }) : basis = this._getEndoBasis(lambda), {\n          beta,\n          lambda,\n          basis\n        };\n      }\n    }, ShortCurve.prototype._getEndoRoots = function(num) {\n      var red = num === this.p \? this.red : BN.mont(num), tinv = new BN(2).toRed(red).redInvm(), ntinv = tinv.redNeg(), s = new BN(3).toRed(red).redNeg().redSqrt().redMul(tinv), l1 = ntinv.redAdd(s).fromRed(), l2 = ntinv.redSub(s).fromRed();\n      return [l1, l2];\n    }, ShortCurve.prototype._getEndoBasis = function(lambda) {\n      for (var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2)), u = lambda, v = this.n.clone(), x1 = new BN(1), y1 = new BN(0), x2 = new BN(0), y2 = new BN(1), a0, b0, a1, b1, a2, b2, prevR, i = 0, r, x;u.cmpn(0) !== 0; ) {\n        var q = v.div(u);\n        r = v.sub(q.mul(u)), x = x2.sub(q.mul(x1));\n        var y = y2.sub(q.mul(y1));\n        if (!a1 && r.cmp(aprxSqrt) < 0)\n          a0 = prevR.neg(), b0 = x1, a1 = r.neg(), b1 = x;\n        else if (a1 && ++i === 2)\n          break;\n        prevR = r, v = u, u = r, x2 = x1, x1 = x, y2 = y1, y1 = y;\n      }\n      a2 = r.neg(), b2 = x;\n      var len1 = a1.sqr().add(b1.sqr()), len2 = a2.sqr().add(b2.sqr());\n      return len2.cmp(len1) >= 0 && (a2 = a0, b2 = b0), a1.negative && (a1 = a1.neg(), b1 = b1.neg()), a2.negative && (a2 = a2.neg(), b2 = b2.neg()), [\n        { a: a1, b: b1 },\n        { a: a2, b: b2 }\n      ];\n    }, ShortCurve.prototype._endoSplit = function(k) {\n      var basis = this.endo.basis, v1 = basis[0], v2 = basis[1], c1 = v2.b.mul(k).divRound(this.n), c2 = v1.b.neg().mul(k).divRound(this.n), p1 = c1.mul(v1.a), p2 = c2.mul(v2.a), q1 = c1.mul(v1.b), q2 = c2.mul(v2.b), k1 = k.sub(p1).sub(p2), k2 = q1.add(q2).neg();\n      return { k1, k2 };\n    }, ShortCurve.prototype.pointFromX = function(x, odd) {\n      x = new BN(x, 16), x.red || (x = x.toRed(this.red));\n      var y2 = x.redSqr().redMul(x).redIAdd(x.redMul(this.a)).redIAdd(this.b), y = y2.redSqrt();\n      if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)\n        throw new Error(\"invalid point\");\n      var isOdd = y.fromRed().isOdd();\n      return (odd && !isOdd || !odd && isOdd) && (y = y.redNeg()), this.point(x, y);\n    }, ShortCurve.prototype.validate = function(point) {\n      if (point.inf)\n        return !0;\n      var { x, y } = point, ax = this.a.redMul(x), rhs = x.redSqr().redMul(x).redIAdd(ax).redIAdd(this.b);\n      return y.redSqr().redISub(rhs).cmpn(0) === 0;\n    }, ShortCurve.prototype._endoWnafMulAdd = function(points, coeffs, jacobianResult) {\n      for (var npoints = this._endoWnafT1, ncoeffs = this._endoWnafT2, i = 0;i < points.length; i++) {\n        var split = this._endoSplit(coeffs[i]), p = points[i], beta = p._getBeta();\n        split.k1.negative && (split.k1.ineg(), p = p.neg(!0)), split.k2.negative && (split.k2.ineg(), beta = beta.neg(!0)), npoints[i * 2] = p, npoints[i * 2 + 1] = beta, ncoeffs[i * 2] = split.k1, ncoeffs[i * 2 + 1] = split.k2;\n      }\n      for (var res = this._wnafMulAdd(1, npoints, ncoeffs, i * 2, jacobianResult), j = 0;j < i * 2; j++)\n        npoints[j] = null, ncoeffs[j] = null;\n      return res;\n    };\n    function Point(curve, x, y, isRed) {\n      Base.BasePoint.call(this, curve, \"affine\"), x === null && y === null \? (this.x = null, this.y = null, this.inf = !0) : (this.x = new BN(x, 16), this.y = new BN(y, 16), isRed && (this.x.forceRed(this.curve.red), this.y.forceRed(this.curve.red)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.inf = !1);\n    }\n    inherits(Point, Base.BasePoint), ShortCurve.prototype.point = function(x, y, isRed) {\n      return new Point(this, x, y, isRed);\n    }, ShortCurve.prototype.pointFromJSON = function(obj, red) {\n      return Point.fromJSON(this, obj, red);\n    }, Point.prototype._getBeta = function() {\n      if (this.curve.endo) {\n        var pre = this.precomputed;\n        if (pre && pre.beta)\n          return pre.beta;\n        var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);\n        if (pre) {\n          var curve = this.curve, endoMul = function(p) {\n            return curve.point(p.x.redMul(curve.endo.beta), p.y);\n          };\n          pre.beta = beta, beta.precomputed = {\n            beta: null,\n            naf: pre.naf && {\n              wnd: pre.naf.wnd,\n              points: pre.naf.points.map(endoMul)\n            },\n            doubles: pre.doubles && {\n              step: pre.doubles.step,\n              points: pre.doubles.points.map(endoMul)\n            }\n          };\n        }\n        return beta;\n      }\n    }, Point.prototype.toJSON = function() {\n      return this.precomputed \? [\n        this.x,\n        this.y,\n        this.precomputed && {\n          doubles: this.precomputed.doubles && {\n            step: this.precomputed.doubles.step,\n            points: this.precomputed.doubles.points.slice(1)\n          },\n          naf: this.precomputed.naf && {\n            wnd: this.precomputed.naf.wnd,\n            points: this.precomputed.naf.points.slice(1)\n          }\n        }\n      ] : [this.x, this.y];\n    }, Point.fromJSON = function(curve, obj, red) {\n      typeof obj == \"string\" && (obj = JSON.parse(obj));\n      var res = curve.point(obj[0], obj[1], red);\n      if (!obj[2])\n        return res;\n      function obj2point(obj2) {\n        return curve.point(obj2[0], obj2[1], red);\n      }\n      var pre = obj[2];\n      return res.precomputed = {\n        beta: null,\n        doubles: pre.doubles && {\n          step: pre.doubles.step,\n          points: [res].concat(pre.doubles.points.map(obj2point))\n        },\n        naf: pre.naf && {\n          wnd: pre.naf.wnd,\n          points: [res].concat(pre.naf.points.map(obj2point))\n        }\n      }, res;\n    }, Point.prototype.inspect = function() {\n      return this.isInfinity() \? \"<EC Point Infinity>\" : \"<EC Point x: \" + this.x.fromRed().toString(16, 2) + \" y: \" + this.y.fromRed().toString(16, 2) + \">\";\n    }, Point.prototype.isInfinity = function() {\n      return this.inf;\n    }, Point.prototype.add = function(p) {\n      if (this.inf)\n        return p;\n      if (p.inf)\n        return this;\n      if (this.eq(p))\n        return this.dbl();\n      if (this.neg().eq(p))\n        return this.curve.point(null, null);\n      if (this.x.cmp(p.x) === 0)\n        return this.curve.point(null, null);\n      var c = this.y.redSub(p.y);\n      c.cmpn(0) !== 0 && (c = c.redMul(this.x.redSub(p.x).redInvm()));\n      var nx = c.redSqr().redISub(this.x).redISub(p.x), ny = c.redMul(this.x.redSub(nx)).redISub(this.y);\n      return this.curve.point(nx, ny);\n    }, Point.prototype.dbl = function() {\n      if (this.inf)\n        return this;\n      var ys1 = this.y.redAdd(this.y);\n      if (ys1.cmpn(0) === 0)\n        return this.curve.point(null, null);\n      var a = this.curve.a, x2 = this.x.redSqr(), dyinv = ys1.redInvm(), c = x2.redAdd(x2).redIAdd(x2).redIAdd(a).redMul(dyinv), nx = c.redSqr().redISub(this.x.redAdd(this.x)), ny = c.redMul(this.x.redSub(nx)).redISub(this.y);\n      return this.curve.point(nx, ny);\n    }, Point.prototype.getX = function() {\n      return this.x.fromRed();\n    }, Point.prototype.getY = function() {\n      return this.y.fromRed();\n    }, Point.prototype.mul = function(k) {\n      return k = new BN(k, 16), this.isInfinity() \? this : this._hasDoubles(k) \? this.curve._fixedNafMul(this, k) : this.curve.endo \? this.curve._endoWnafMulAdd([this], [k]) : this.curve._wnafMul(this, k);\n    }, Point.prototype.mulAdd = function(k1, p2, k2) {\n      var points = [this, p2], coeffs = [k1, k2];\n      return this.curve.endo \? this.curve._endoWnafMulAdd(points, coeffs) : this.curve._wnafMulAdd(1, points, coeffs, 2);\n    }, Point.prototype.jmulAdd = function(k1, p2, k2) {\n      var points = [this, p2], coeffs = [k1, k2];\n      return this.curve.endo \? this.curve._endoWnafMulAdd(points, coeffs, !0) : this.curve._wnafMulAdd(1, points, coeffs, 2, !0);\n    }, Point.prototype.eq = function(p) {\n      return this === p || this.inf === p.inf && (this.inf || this.x.cmp(p.x) === 0 && this.y.cmp(p.y) === 0);\n    }, Point.prototype.neg = function(_precompute) {\n      if (this.inf)\n        return this;\n      var res = this.curve.point(this.x, this.y.redNeg());\n      if (_precompute && this.precomputed) {\n        var pre = this.precomputed, negate = function(p) {\n          return p.neg();\n        };\n        res.precomputed = {\n          naf: pre.naf && {\n            wnd: pre.naf.wnd,\n            points: pre.naf.points.map(negate)\n          },\n          doubles: pre.doubles && {\n            step: pre.doubles.step,\n            points: pre.doubles.points.map(negate)\n          }\n        };\n      }\n      return res;\n    }, Point.prototype.toJ = function() {\n      if (this.inf)\n        return this.curve.jpoint(null, null, null);\n      var res = this.curve.jpoint(this.x, this.y, this.curve.one);\n      return res;\n    };\n    function JPoint(curve, x, y, z) {\n      Base.BasePoint.call(this, curve, \"jacobian\"), x === null && y === null && z === null \? (this.x = this.curve.one, this.y = this.curve.one, this.z = new BN(0)) : (this.x = new BN(x, 16), this.y = new BN(y, 16), this.z = new BN(z, 16)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.zOne = this.z === this.curve.one;\n    }\n    inherits(JPoint, Base.BasePoint), ShortCurve.prototype.jpoint = function(x, y, z) {\n      return new JPoint(this, x, y, z);\n    }, JPoint.prototype.toP = function() {\n      if (this.isInfinity())\n        return this.curve.point(null, null);\n      var zinv = this.z.redInvm(), zinv2 = zinv.redSqr(), ax = this.x.redMul(zinv2), ay = this.y.redMul(zinv2).redMul(zinv);\n      return this.curve.point(ax, ay);\n    }, JPoint.prototype.neg = function() {\n      return this.curve.jpoint(this.x, this.y.redNeg(), this.z);\n    }, JPoint.prototype.add = function(p) {\n      if (this.isInfinity())\n        return p;\n      if (p.isInfinity())\n        return this;\n      var pz2 = p.z.redSqr(), z2 = this.z.redSqr(), u1 = this.x.redMul(pz2), u2 = p.x.redMul(z2), s1 = this.y.redMul(pz2.redMul(p.z)), s2 = p.y.redMul(z2.redMul(this.z)), h = u1.redSub(u2), r = s1.redSub(s2);\n      if (h.cmpn(0) === 0)\n        return r.cmpn(0) !== 0 \? this.curve.jpoint(null, null, null) : this.dbl();\n      var h2 = h.redSqr(), h3 = h2.redMul(h), v = u1.redMul(h2), nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v), ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3)), nz = this.z.redMul(p.z).redMul(h);\n      return this.curve.jpoint(nx, ny, nz);\n    }, JPoint.prototype.mixedAdd = function(p) {\n      if (this.isInfinity())\n        return p.toJ();\n      if (p.isInfinity())\n        return this;\n      var z2 = this.z.redSqr(), u1 = this.x, u2 = p.x.redMul(z2), s1 = this.y, s2 = p.y.redMul(z2).redMul(this.z), h = u1.redSub(u2), r = s1.redSub(s2);\n      if (h.cmpn(0) === 0)\n        return r.cmpn(0) !== 0 \? this.curve.jpoint(null, null, null) : this.dbl();\n      var h2 = h.redSqr(), h3 = h2.redMul(h), v = u1.redMul(h2), nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v), ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3)), nz = this.z.redMul(h);\n      return this.curve.jpoint(nx, ny, nz);\n    }, JPoint.prototype.dblp = function(pow) {\n      if (pow === 0)\n        return this;\n      if (this.isInfinity())\n        return this;\n      if (!pow)\n        return this.dbl();\n      var i;\n      if (this.curve.zeroA || this.curve.threeA) {\n        var r = this;\n        for (i = 0;i < pow; i++)\n          r = r.dbl();\n        return r;\n      }\n      var a = this.curve.a, tinv = this.curve.tinv, jx = this.x, jy = this.y, jz = this.z, jz4 = jz.redSqr().redSqr(), jyd = jy.redAdd(jy);\n      for (i = 0;i < pow; i++) {\n        var jx2 = jx.redSqr(), jyd2 = jyd.redSqr(), jyd4 = jyd2.redSqr(), c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4)), t1 = jx.redMul(jyd2), nx = c.redSqr().redISub(t1.redAdd(t1)), t2 = t1.redISub(nx), dny = c.redMul(t2);\n        dny = dny.redIAdd(dny).redISub(jyd4);\n        var nz = jyd.redMul(jz);\n        i + 1 < pow && (jz4 = jz4.redMul(jyd4)), jx = nx, jz = nz, jyd = dny;\n      }\n      return this.curve.jpoint(jx, jyd.redMul(tinv), jz);\n    }, JPoint.prototype.dbl = function() {\n      return this.isInfinity() \? this : this.curve.zeroA \? this._zeroDbl() : this.curve.threeA \? this._threeDbl() : this._dbl();\n    }, JPoint.prototype._zeroDbl = function() {\n      var nx, ny, nz;\n      if (this.zOne) {\n        var xx = this.x.redSqr(), yy = this.y.redSqr(), yyyy = yy.redSqr(), s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);\n        s = s.redIAdd(s);\n        var m = xx.redAdd(xx).redIAdd(xx), t = m.redSqr().redISub(s).redISub(s), yyyy8 = yyyy.redIAdd(yyyy);\n        yyyy8 = yyyy8.redIAdd(yyyy8), yyyy8 = yyyy8.redIAdd(yyyy8), nx = t, ny = m.redMul(s.redISub(t)).redISub(yyyy8), nz = this.y.redAdd(this.y);\n      } else {\n        var a = this.x.redSqr(), b = this.y.redSqr(), c = b.redSqr(), d = this.x.redAdd(b).redSqr().redISub(a).redISub(c);\n        d = d.redIAdd(d);\n        var e = a.redAdd(a).redIAdd(a), f = e.redSqr(), c8 = c.redIAdd(c);\n        c8 = c8.redIAdd(c8), c8 = c8.redIAdd(c8), nx = f.redISub(d).redISub(d), ny = e.redMul(d.redISub(nx)).redISub(c8), nz = this.y.redMul(this.z), nz = nz.redIAdd(nz);\n      }\n      return this.curve.jpoint(nx, ny, nz);\n    }, JPoint.prototype._threeDbl = function() {\n      var nx, ny, nz;\n      if (this.zOne) {\n        var xx = this.x.redSqr(), yy = this.y.redSqr(), yyyy = yy.redSqr(), s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);\n        s = s.redIAdd(s);\n        var m = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a), t = m.redSqr().redISub(s).redISub(s);\n        nx = t;\n        var yyyy8 = yyyy.redIAdd(yyyy);\n        yyyy8 = yyyy8.redIAdd(yyyy8), yyyy8 = yyyy8.redIAdd(yyyy8), ny = m.redMul(s.redISub(t)).redISub(yyyy8), nz = this.y.redAdd(this.y);\n      } else {\n        var delta = this.z.redSqr(), gamma = this.y.redSqr(), beta = this.x.redMul(gamma), alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));\n        alpha = alpha.redAdd(alpha).redIAdd(alpha);\n        var beta4 = beta.redIAdd(beta);\n        beta4 = beta4.redIAdd(beta4);\n        var beta8 = beta4.redAdd(beta4);\n        nx = alpha.redSqr().redISub(beta8), nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);\n        var ggamma8 = gamma.redSqr();\n        ggamma8 = ggamma8.redIAdd(ggamma8), ggamma8 = ggamma8.redIAdd(ggamma8), ggamma8 = ggamma8.redIAdd(ggamma8), ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);\n      }\n      return this.curve.jpoint(nx, ny, nz);\n    }, JPoint.prototype._dbl = function() {\n      var a = this.curve.a, jx = this.x, jy = this.y, jz = this.z, jz4 = jz.redSqr().redSqr(), jx2 = jx.redSqr(), jy2 = jy.redSqr(), c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4)), jxd4 = jx.redAdd(jx);\n      jxd4 = jxd4.redIAdd(jxd4);\n      var t1 = jxd4.redMul(jy2), nx = c.redSqr().redISub(t1.redAdd(t1)), t2 = t1.redISub(nx), jyd8 = jy2.redSqr();\n      jyd8 = jyd8.redIAdd(jyd8), jyd8 = jyd8.redIAdd(jyd8), jyd8 = jyd8.redIAdd(jyd8);\n      var ny = c.redMul(t2).redISub(jyd8), nz = jy.redAdd(jy).redMul(jz);\n      return this.curve.jpoint(nx, ny, nz);\n    }, JPoint.prototype.trpl = function() {\n      if (!this.curve.zeroA)\n        return this.dbl().add(this);\n      var xx = this.x.redSqr(), yy = this.y.redSqr(), zz = this.z.redSqr(), yyyy = yy.redSqr(), m = xx.redAdd(xx).redIAdd(xx), mm = m.redSqr(), e = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);\n      e = e.redIAdd(e), e = e.redAdd(e).redIAdd(e), e = e.redISub(mm);\n      var ee = e.redSqr(), t = yyyy.redIAdd(yyyy);\n      t = t.redIAdd(t), t = t.redIAdd(t), t = t.redIAdd(t);\n      var u = m.redIAdd(e).redSqr().redISub(mm).redISub(ee).redISub(t), yyu4 = yy.redMul(u);\n      yyu4 = yyu4.redIAdd(yyu4), yyu4 = yyu4.redIAdd(yyu4);\n      var nx = this.x.redMul(ee).redISub(yyu4);\n      nx = nx.redIAdd(nx), nx = nx.redIAdd(nx);\n      var ny = this.y.redMul(u.redMul(t.redISub(u)).redISub(e.redMul(ee)));\n      ny = ny.redIAdd(ny), ny = ny.redIAdd(ny), ny = ny.redIAdd(ny);\n      var nz = this.z.redAdd(e).redSqr().redISub(zz).redISub(ee);\n      return this.curve.jpoint(nx, ny, nz);\n    }, JPoint.prototype.mul = function(k, kbase) {\n      return k = new BN(k, kbase), this.curve._wnafMul(this, k);\n    }, JPoint.prototype.eq = function(p) {\n      if (p.type === \"affine\")\n        return this.eq(p.toJ());\n      if (this === p)\n        return !0;\n      var z2 = this.z.redSqr(), pz2 = p.z.redSqr();\n      if (this.x.redMul(pz2).redISub(p.x.redMul(z2)).cmpn(0) !== 0)\n        return !1;\n      var z3 = z2.redMul(this.z), pz3 = pz2.redMul(p.z);\n      return this.y.redMul(pz3).redISub(p.y.redMul(z3)).cmpn(0) === 0;\n    }, JPoint.prototype.eqXToP = function(x) {\n      var zs = this.z.redSqr(), rx = x.toRed(this.curve.red).redMul(zs);\n      if (this.x.cmp(rx) === 0)\n        return !0;\n      for (var xc = x.clone(), t = this.curve.redN.redMul(zs);; ) {\n        if (xc.iadd(this.curve.n), xc.cmp(this.curve.p) >= 0)\n          return !1;\n        if (rx.redIAdd(t), this.x.cmp(rx) === 0)\n          return !0;\n      }\n    }, JPoint.prototype.inspect = function() {\n      return this.isInfinity() \? \"<EC JPoint Infinity>\" : \"<EC JPoint x: \" + this.x.toString(16, 2) + \" y: \" + this.y.toString(16, 2) + \" z: \" + this.z.toString(16, 2) + \">\";\n    }, JPoint.prototype.isInfinity = function() {\n      return this.z.cmpn(0) === 0;\n    };\n  }\n}), require_mont = __commonJS({\n  \"node_modules/elliptic/lib/elliptic/curve/mont.js\"(exports, module) {\n    var BN = require_bn4(), inherits = require_inherits_browser(), Base = require_base(), utils = require_utils3();\n    function MontCurve(conf) {\n      Base.call(this, \"mont\", conf), this.a = new BN(conf.a, 16).toRed(this.red), this.b = new BN(conf.b, 16).toRed(this.red), this.i4 = new BN(4).toRed(this.red).redInvm(), this.two = new BN(2).toRed(this.red), this.a24 = this.i4.redMul(this.a.redAdd(this.two));\n    }\n    inherits(MontCurve, Base), module.exports = MontCurve, MontCurve.prototype.validate = function(point) {\n      var x = point.normalize().x, x2 = x.redSqr(), rhs = x2.redMul(x).redAdd(x2.redMul(this.a)).redAdd(x), y = rhs.redSqrt();\n      return y.redSqr().cmp(rhs) === 0;\n    };\n    function Point(curve, x, z) {\n      Base.BasePoint.call(this, curve, \"projective\"), x === null && z === null \? (this.x = this.curve.one, this.z = this.curve.zero) : (this.x = new BN(x, 16), this.z = new BN(z, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)));\n    }\n    inherits(Point, Base.BasePoint), MontCurve.prototype.decodePoint = function(bytes, enc) {\n      return this.point(utils.toArray(bytes, enc), 1);\n    }, MontCurve.prototype.point = function(x, z) {\n      return new Point(this, x, z);\n    }, MontCurve.prototype.pointFromJSON = function(obj) {\n      return Point.fromJSON(this, obj);\n    }, Point.prototype.precompute = function() {\n    }, Point.prototype._encode = function() {\n      return this.getX().toArray(\"be\", this.curve.p.byteLength());\n    }, Point.fromJSON = function(curve, obj) {\n      return new Point(curve, obj[0], obj[1] || curve.one);\n    }, Point.prototype.inspect = function() {\n      return this.isInfinity() \? \"<EC Point Infinity>\" : \"<EC Point x: \" + this.x.fromRed().toString(16, 2) + \" z: \" + this.z.fromRed().toString(16, 2) + \">\";\n    }, Point.prototype.isInfinity = function() {\n      return this.z.cmpn(0) === 0;\n    }, Point.prototype.dbl = function() {\n      var a = this.x.redAdd(this.z), aa = a.redSqr(), b = this.x.redSub(this.z), bb = b.redSqr(), c = aa.redSub(bb), nx = aa.redMul(bb), nz = c.redMul(bb.redAdd(this.curve.a24.redMul(c)));\n      return this.curve.point(nx, nz);\n    }, Point.prototype.add = function() {\n      throw new Error(\"Not supported on Montgomery curve\");\n    }, Point.prototype.diffAdd = function(p, diff) {\n      var a = this.x.redAdd(this.z), b = this.x.redSub(this.z), c = p.x.redAdd(p.z), d = p.x.redSub(p.z), da = d.redMul(a), cb = c.redMul(b), nx = diff.z.redMul(da.redAdd(cb).redSqr()), nz = diff.x.redMul(da.redISub(cb).redSqr());\n      return this.curve.point(nx, nz);\n    }, Point.prototype.mul = function(k) {\n      for (var t = k.clone(), a = this, b = this.curve.point(null, null), c = this, bits = [];t.cmpn(0) !== 0; t.iushrn(1))\n        bits.push(t.andln(1));\n      for (var i = bits.length - 1;i >= 0; i--)\n        bits[i] === 0 \? (a = a.diffAdd(b, c), b = b.dbl()) : (b = a.diffAdd(b, c), a = a.dbl());\n      return b;\n    }, Point.prototype.mulAdd = function() {\n      throw new Error(\"Not supported on Montgomery curve\");\n    }, Point.prototype.jumlAdd = function() {\n      throw new Error(\"Not supported on Montgomery curve\");\n    }, Point.prototype.eq = function(other) {\n      return this.getX().cmp(other.getX()) === 0;\n    }, Point.prototype.normalize = function() {\n      return this.x = this.x.redMul(this.z.redInvm()), this.z = this.curve.one, this;\n    }, Point.prototype.getX = function() {\n      return this.normalize(), this.x.fromRed();\n    };\n  }\n}), require_edwards = __commonJS({\n  \"node_modules/elliptic/lib/elliptic/curve/edwards.js\"(exports, module) {\n    var utils = require_utils3(), BN = require_bn4(), inherits = require_inherits_browser(), Base = require_base(), assert = utils.assert;\n    function EdwardsCurve(conf) {\n      this.twisted = (conf.a | 0) !== 1, this.mOneA = this.twisted && (conf.a | 0) === -1, this.extended = this.mOneA, Base.call(this, \"edwards\", conf), this.a = new BN(conf.a, 16).umod(this.red.m), this.a = this.a.toRed(this.red), this.c = new BN(conf.c, 16).toRed(this.red), this.c2 = this.c.redSqr(), this.d = new BN(conf.d, 16).toRed(this.red), this.dd = this.d.redAdd(this.d), assert(!this.twisted || this.c.fromRed().cmpn(1) === 0), this.oneC = (conf.c | 0) === 1;\n    }\n    inherits(EdwardsCurve, Base), module.exports = EdwardsCurve, EdwardsCurve.prototype._mulA = function(num) {\n      return this.mOneA \? num.redNeg() : this.a.redMul(num);\n    }, EdwardsCurve.prototype._mulC = function(num) {\n      return this.oneC \? num : this.c.redMul(num);\n    }, EdwardsCurve.prototype.jpoint = function(x, y, z, t) {\n      return this.point(x, y, z, t);\n    }, EdwardsCurve.prototype.pointFromX = function(x, odd) {\n      x = new BN(x, 16), x.red || (x = x.toRed(this.red));\n      var x2 = x.redSqr(), rhs = this.c2.redSub(this.a.redMul(x2)), lhs = this.one.redSub(this.c2.redMul(this.d).redMul(x2)), y2 = rhs.redMul(lhs.redInvm()), y = y2.redSqrt();\n      if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)\n        throw new Error(\"invalid point\");\n      var isOdd = y.fromRed().isOdd();\n      return (odd && !isOdd || !odd && isOdd) && (y = y.redNeg()), this.point(x, y);\n    }, EdwardsCurve.prototype.pointFromY = function(y, odd) {\n      y = new BN(y, 16), y.red || (y = y.toRed(this.red));\n      var y2 = y.redSqr(), lhs = y2.redSub(this.c2), rhs = y2.redMul(this.d).redMul(this.c2).redSub(this.a), x2 = lhs.redMul(rhs.redInvm());\n      if (x2.cmp(this.zero) === 0) {\n        if (odd)\n          throw new Error(\"invalid point\");\n        return this.point(this.zero, y);\n      }\n      var x = x2.redSqrt();\n      if (x.redSqr().redSub(x2).cmp(this.zero) !== 0)\n        throw new Error(\"invalid point\");\n      return x.fromRed().isOdd() !== odd && (x = x.redNeg()), this.point(x, y);\n    }, EdwardsCurve.prototype.validate = function(point) {\n      if (point.isInfinity())\n        return !0;\n      point.normalize();\n      var x2 = point.x.redSqr(), y2 = point.y.redSqr(), lhs = x2.redMul(this.a).redAdd(y2), rhs = this.c2.redMul(this.one.redAdd(this.d.redMul(x2).redMul(y2)));\n      return lhs.cmp(rhs) === 0;\n    };\n    function Point(curve, x, y, z, t) {\n      Base.BasePoint.call(this, curve, \"projective\"), x === null && y === null && z === null \? (this.x = this.curve.zero, this.y = this.curve.one, this.z = this.curve.one, this.t = this.curve.zero, this.zOne = !0) : (this.x = new BN(x, 16), this.y = new BN(y, 16), this.z = z \? new BN(z, 16) : this.curve.one, this.t = t && new BN(t, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.t && !this.t.red && (this.t = this.t.toRed(this.curve.red)), this.zOne = this.z === this.curve.one, this.curve.extended && !this.t && (this.t = this.x.redMul(this.y), this.zOne || (this.t = this.t.redMul(this.z.redInvm()))));\n    }\n    inherits(Point, Base.BasePoint), EdwardsCurve.prototype.pointFromJSON = function(obj) {\n      return Point.fromJSON(this, obj);\n    }, EdwardsCurve.prototype.point = function(x, y, z, t) {\n      return new Point(this, x, y, z, t);\n    }, Point.fromJSON = function(curve, obj) {\n      return new Point(curve, obj[0], obj[1], obj[2]);\n    }, Point.prototype.inspect = function() {\n      return this.isInfinity() \? \"<EC Point Infinity>\" : \"<EC Point x: \" + this.x.fromRed().toString(16, 2) + \" y: \" + this.y.fromRed().toString(16, 2) + \" z: \" + this.z.fromRed().toString(16, 2) + \">\";\n    }, Point.prototype.isInfinity = function() {\n      return this.x.cmpn(0) === 0 && (this.y.cmp(this.z) === 0 || this.zOne && this.y.cmp(this.curve.c) === 0);\n    }, Point.prototype._extDbl = function() {\n      var a = this.x.redSqr(), b = this.y.redSqr(), c = this.z.redSqr();\n      c = c.redIAdd(c);\n      var d = this.curve._mulA(a), e = this.x.redAdd(this.y).redSqr().redISub(a).redISub(b), g = d.redAdd(b), f = g.redSub(c), h = d.redSub(b), nx = e.redMul(f), ny = g.redMul(h), nt = e.redMul(h), nz = f.redMul(g);\n      return this.curve.point(nx, ny, nz, nt);\n    }, Point.prototype._projDbl = function() {\n      var b = this.x.redAdd(this.y).redSqr(), c = this.x.redSqr(), d = this.y.redSqr(), nx, ny, nz, e, h, j;\n      if (this.curve.twisted) {\n        e = this.curve._mulA(c);\n        var f = e.redAdd(d);\n        this.zOne \? (nx = b.redSub(c).redSub(d).redMul(f.redSub(this.curve.two)), ny = f.redMul(e.redSub(d)), nz = f.redSqr().redSub(f).redSub(f)) : (h = this.z.redSqr(), j = f.redSub(h).redISub(h), nx = b.redSub(c).redISub(d).redMul(j), ny = f.redMul(e.redSub(d)), nz = f.redMul(j));\n      } else\n        e = c.redAdd(d), h = this.curve._mulC(this.z).redSqr(), j = e.redSub(h).redSub(h), nx = this.curve._mulC(b.redISub(e)).redMul(j), ny = this.curve._mulC(e).redMul(c.redISub(d)), nz = e.redMul(j);\n      return this.curve.point(nx, ny, nz);\n    }, Point.prototype.dbl = function() {\n      return this.isInfinity() \? this : this.curve.extended \? this._extDbl() : this._projDbl();\n    }, Point.prototype._extAdd = function(p) {\n      var a = this.y.redSub(this.x).redMul(p.y.redSub(p.x)), b = this.y.redAdd(this.x).redMul(p.y.redAdd(p.x)), c = this.t.redMul(this.curve.dd).redMul(p.t), d = this.z.redMul(p.z.redAdd(p.z)), e = b.redSub(a), f = d.redSub(c), g = d.redAdd(c), h = b.redAdd(a), nx = e.redMul(f), ny = g.redMul(h), nt = e.redMul(h), nz = f.redMul(g);\n      return this.curve.point(nx, ny, nz, nt);\n    }, Point.prototype._projAdd = function(p) {\n      var a = this.z.redMul(p.z), b = a.redSqr(), c = this.x.redMul(p.x), d = this.y.redMul(p.y), e = this.curve.d.redMul(c).redMul(d), f = b.redSub(e), g = b.redAdd(e), tmp = this.x.redAdd(this.y).redMul(p.x.redAdd(p.y)).redISub(c).redISub(d), nx = a.redMul(f).redMul(tmp), ny, nz;\n      return this.curve.twisted \? (ny = a.redMul(g).redMul(d.redSub(this.curve._mulA(c))), nz = f.redMul(g)) : (ny = a.redMul(g).redMul(d.redSub(c)), nz = this.curve._mulC(f).redMul(g)), this.curve.point(nx, ny, nz);\n    }, Point.prototype.add = function(p) {\n      return this.isInfinity() \? p : p.isInfinity() \? this : this.curve.extended \? this._extAdd(p) : this._projAdd(p);\n    }, Point.prototype.mul = function(k) {\n      return this._hasDoubles(k) \? this.curve._fixedNafMul(this, k) : this.curve._wnafMul(this, k);\n    }, Point.prototype.mulAdd = function(k1, p, k2) {\n      return this.curve._wnafMulAdd(1, [this, p], [k1, k2], 2, !1);\n    }, Point.prototype.jmulAdd = function(k1, p, k2) {\n      return this.curve._wnafMulAdd(1, [this, p], [k1, k2], 2, !0);\n    }, Point.prototype.normalize = function() {\n      if (this.zOne)\n        return this;\n      var zi = this.z.redInvm();\n      return this.x = this.x.redMul(zi), this.y = this.y.redMul(zi), this.t && (this.t = this.t.redMul(zi)), this.z = this.curve.one, this.zOne = !0, this;\n    }, Point.prototype.neg = function() {\n      return this.curve.point(this.x.redNeg(), this.y, this.z, this.t && this.t.redNeg());\n    }, Point.prototype.getX = function() {\n      return this.normalize(), this.x.fromRed();\n    }, Point.prototype.getY = function() {\n      return this.normalize(), this.y.fromRed();\n    }, Point.prototype.eq = function(other) {\n      return this === other || this.getX().cmp(other.getX()) === 0 && this.getY().cmp(other.getY()) === 0;\n    }, Point.prototype.eqXToP = function(x) {\n      var rx = x.toRed(this.curve.red).redMul(this.z);\n      if (this.x.cmp(rx) === 0)\n        return !0;\n      for (var xc = x.clone(), t = this.curve.redN.redMul(this.z);; ) {\n        if (xc.iadd(this.curve.n), xc.cmp(this.curve.p) >= 0)\n          return !1;\n        if (rx.redIAdd(t), this.x.cmp(rx) === 0)\n          return !0;\n      }\n    }, Point.prototype.toP = Point.prototype.normalize, Point.prototype.mixedAdd = Point.prototype.add;\n  }\n}), require_curve = __commonJS({\n  \"node_modules/elliptic/lib/elliptic/curve/index.js\"(exports) {\n    var curve = exports;\n    curve.base = require_base(), curve.short = require_short(), curve.mont = require_mont(), curve.edwards = require_edwards();\n  }\n}), require_utils4 = __commonJS({\n  \"node_modules/hash.js/lib/hash/utils.js\"(exports) {\n    var assert = require_minimalistic_assert(), inherits = require_inherits_browser();\n    exports.inherits = inherits;\n    function isSurrogatePair(msg, i) {\n      return (msg.charCodeAt(i) & 64512) !== 55296 || i < 0 || i + 1 >= msg.length \? !1 : (msg.charCodeAt(i + 1) & 64512) === 56320;\n    }\n    function toArray(msg, enc) {\n      if (Array.isArray(msg))\n        return msg.slice();\n      if (!msg)\n        return [];\n      var res = [];\n      if (typeof msg == \"string\")\n        if (enc) {\n          if (enc === \"hex\")\n            for (msg = msg.replace(/[^a-z0-9]+/gi, \"\"), msg.length % 2 !== 0 && (msg = \"0\" + msg), i = 0;i < msg.length; i += 2)\n              res.push(parseInt(msg[i] + msg[i + 1], 16));\n        } else\n          for (var p = 0, i = 0;i < msg.length; i++) {\n            var c = msg.charCodeAt(i);\n            c < 128 \? res[p++] = c : c < 2048 \? (res[p++] = c >> 6 | 192, res[p++] = c & 63 | 128) : isSurrogatePair(msg, i) \? (c = 65536 + ((c & 1023) << 10) + (msg.charCodeAt(++i) & 1023), res[p++] = c >> 18 | 240, res[p++] = c >> 12 & 63 | 128, res[p++] = c >> 6 & 63 | 128, res[p++] = c & 63 | 128) : (res[p++] = c >> 12 | 224, res[p++] = c >> 6 & 63 | 128, res[p++] = c & 63 | 128);\n          }\n      else\n        for (i = 0;i < msg.length; i++)\n          res[i] = msg[i] | 0;\n      return res;\n    }\n    exports.toArray = toArray;\n    function toHex(msg) {\n      for (var res = \"\", i = 0;i < msg.length; i++)\n        res += zero2(msg[i].toString(16));\n      return res;\n    }\n    exports.toHex = toHex;\n    function htonl(w) {\n      var res = w >>> 24 | w >>> 8 & 65280 | w << 8 & 16711680 | (w & 255) << 24;\n      return res >>> 0;\n    }\n    exports.htonl = htonl;\n    function toHex32(msg, endian) {\n      for (var res = \"\", i = 0;i < msg.length; i++) {\n        var w = msg[i];\n        endian === \"little\" && (w = htonl(w)), res += zero8(w.toString(16));\n      }\n      return res;\n    }\n    exports.toHex32 = toHex32;\n    function zero2(word) {\n      return word.length === 1 \? \"0\" + word : word;\n    }\n    exports.zero2 = zero2;\n    function zero8(word) {\n      return word.length === 7 \? \"0\" + word : word.length === 6 \? \"00\" + word : word.length === 5 \? \"000\" + word : word.length === 4 \? \"0000\" + word : word.length === 3 \? \"00000\" + word : word.length === 2 \? \"000000\" + word : word.length === 1 \? \"0000000\" + word : word;\n    }\n    exports.zero8 = zero8;\n    function join32(msg, start, end, endian) {\n      var len = end - start;\n      assert(len % 4 === 0);\n      for (var res = new Array(len / 4), i = 0, k = start;i < res.length; i++, k += 4) {\n        var w;\n        endian === \"big\" \? w = msg[k] << 24 | msg[k + 1] << 16 | msg[k + 2] << 8 | msg[k + 3] : w = msg[k + 3] << 24 | msg[k + 2] << 16 | msg[k + 1] << 8 | msg[k], res[i] = w >>> 0;\n      }\n      return res;\n    }\n    exports.join32 = join32;\n    function split32(msg, endian) {\n      for (var res = new Array(msg.length * 4), i = 0, k = 0;i < msg.length; i++, k += 4) {\n        var m = msg[i];\n        endian === \"big\" \? (res[k] = m >>> 24, res[k + 1] = m >>> 16 & 255, res[k + 2] = m >>> 8 & 255, res[k + 3] = m & 255) : (res[k + 3] = m >>> 24, res[k + 2] = m >>> 16 & 255, res[k + 1] = m >>> 8 & 255, res[k] = m & 255);\n      }\n      return res;\n    }\n    exports.split32 = split32;\n    function rotr32(w, b) {\n      return w >>> b | w << 32 - b;\n    }\n    exports.rotr32 = rotr32;\n    function rotl32(w, b) {\n      return w << b | w >>> 32 - b;\n    }\n    exports.rotl32 = rotl32;\n    function sum32(a, b) {\n      return a + b >>> 0;\n    }\n    exports.sum32 = sum32;\n    function sum32_3(a, b, c) {\n      return a + b + c >>> 0;\n    }\n    exports.sum32_3 = sum32_3;\n    function sum32_4(a, b, c, d) {\n      return a + b + c + d >>> 0;\n    }\n    exports.sum32_4 = sum32_4;\n    function sum32_5(a, b, c, d, e) {\n      return a + b + c + d + e >>> 0;\n    }\n    exports.sum32_5 = sum32_5;\n    function sum64(buf, pos, ah, al) {\n      var bh = buf[pos], bl = buf[pos + 1], lo = al + bl >>> 0, hi = (lo < al \? 1 : 0) + ah + bh;\n      buf[pos] = hi >>> 0, buf[pos + 1] = lo;\n    }\n    exports.sum64 = sum64;\n    function sum64_hi(ah, al, bh, bl) {\n      var lo = al + bl >>> 0, hi = (lo < al \? 1 : 0) + ah + bh;\n      return hi >>> 0;\n    }\n    exports.sum64_hi = sum64_hi;\n    function sum64_lo(ah, al, bh, bl) {\n      var lo = al + bl;\n      return lo >>> 0;\n    }\n    exports.sum64_lo = sum64_lo;\n    function sum64_4_hi(ah, al, bh, bl, ch, cl, dh, dl) {\n      var carry = 0, lo = al;\n      lo = lo + bl >>> 0, carry += lo < al \? 1 : 0, lo = lo + cl >>> 0, carry += lo < cl \? 1 : 0, lo = lo + dl >>> 0, carry += lo < dl \? 1 : 0;\n      var hi = ah + bh + ch + dh + carry;\n      return hi >>> 0;\n    }\n    exports.sum64_4_hi = sum64_4_hi;\n    function sum64_4_lo(ah, al, bh, bl, ch, cl, dh, dl) {\n      var lo = al + bl + cl + dl;\n      return lo >>> 0;\n    }\n    exports.sum64_4_lo = sum64_4_lo;\n    function sum64_5_hi(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {\n      var carry = 0, lo = al;\n      lo = lo + bl >>> 0, carry += lo < al \? 1 : 0, lo = lo + cl >>> 0, carry += lo < cl \? 1 : 0, lo = lo + dl >>> 0, carry += lo < dl \? 1 : 0, lo = lo + el >>> 0, carry += lo < el \? 1 : 0;\n      var hi = ah + bh + ch + dh + eh + carry;\n      return hi >>> 0;\n    }\n    exports.sum64_5_hi = sum64_5_hi;\n    function sum64_5_lo(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {\n      var lo = al + bl + cl + dl + el;\n      return lo >>> 0;\n    }\n    exports.sum64_5_lo = sum64_5_lo;\n    function rotr64_hi(ah, al, num) {\n      var r = al << 32 - num | ah >>> num;\n      return r >>> 0;\n    }\n    exports.rotr64_hi = rotr64_hi;\n    function rotr64_lo(ah, al, num) {\n      var r = ah << 32 - num | al >>> num;\n      return r >>> 0;\n    }\n    exports.rotr64_lo = rotr64_lo;\n    function shr64_hi(ah, al, num) {\n      return ah >>> num;\n    }\n    exports.shr64_hi = shr64_hi;\n    function shr64_lo(ah, al, num) {\n      var r = ah << 32 - num | al >>> num;\n      return r >>> 0;\n    }\n    exports.shr64_lo = shr64_lo;\n  }\n}), require_common = __commonJS({\n  \"node_modules/hash.js/lib/hash/common.js\"(exports) {\n    var utils = require_utils4(), assert = require_minimalistic_assert();\n    function BlockHash() {\n      this.pending = null, this.pendingTotal = 0, this.blockSize = this.constructor.blockSize, this.outSize = this.constructor.outSize, this.hmacStrength = this.constructor.hmacStrength, this.padLength = this.constructor.padLength / 8, this.endian = \"big\", this._delta8 = this.blockSize / 8, this._delta32 = this.blockSize / 32;\n    }\n    BlockHash.prototype = {}, exports.BlockHash = BlockHash, BlockHash.prototype.update = function(msg, enc) {\n      if (msg = utils.toArray(msg, enc), this.pending \? this.pending = this.pending.concat(msg) : this.pending = msg, this.pendingTotal += msg.length, this.pending.length >= this._delta8) {\n        msg = this.pending;\n        var r = msg.length % this._delta8;\n        this.pending = msg.slice(msg.length - r, msg.length), this.pending.length === 0 && (this.pending = null), msg = utils.join32(msg, 0, msg.length - r, this.endian);\n        for (var i = 0;i < msg.length; i += this._delta32)\n          this._update(msg, i, i + this._delta32);\n      }\n      return this;\n    }, BlockHash.prototype.digest = function(enc) {\n      return this.update(this._pad()), assert(this.pending === null), this._digest(enc);\n    }, BlockHash.prototype._pad = function() {\n      var len = this.pendingTotal, bytes = this._delta8, k = bytes - (len + this.padLength) % bytes, res = new Array(k + this.padLength);\n      res[0] = 128;\n      for (var i = 1;i < k; i++)\n        res[i] = 0;\n      if (len <<= 3, this.endian === \"big\") {\n        for (var t = 8;t < this.padLength; t++)\n          res[i++] = 0;\n        res[i++] = 0, res[i++] = 0, res[i++] = 0, res[i++] = 0, res[i++] = len >>> 24 & 255, res[i++] = len >>> 16 & 255, res[i++] = len >>> 8 & 255, res[i++] = len & 255;\n      } else\n        for (res[i++] = len & 255, res[i++] = len >>> 8 & 255, res[i++] = len >>> 16 & 255, res[i++] = len >>> 24 & 255, res[i++] = 0, res[i++] = 0, res[i++] = 0, res[i++] = 0, t = 8;t < this.padLength; t++)\n          res[i++] = 0;\n      return res;\n    };\n  }\n}), require_common2 = __commonJS({\n  \"node_modules/hash.js/lib/hash/sha/common.js\"(exports) {\n    var utils = require_utils4(), rotr32 = utils.rotr32;\n    function ft_1(s, x, y, z) {\n      if (s === 0)\n        return ch32(x, y, z);\n      if (s === 1 || s === 3)\n        return p32(x, y, z);\n      if (s === 2)\n        return maj32(x, y, z);\n    }\n    exports.ft_1 = ft_1;\n    function ch32(x, y, z) {\n      return x & y ^ ~x & z;\n    }\n    exports.ch32 = ch32;\n    function maj32(x, y, z) {\n      return x & y ^ x & z ^ y & z;\n    }\n    exports.maj32 = maj32;\n    function p32(x, y, z) {\n      return x ^ y ^ z;\n    }\n    exports.p32 = p32;\n    function s0_256(x) {\n      return rotr32(x, 2) ^ rotr32(x, 13) ^ rotr32(x, 22);\n    }\n    exports.s0_256 = s0_256;\n    function s1_256(x) {\n      return rotr32(x, 6) ^ rotr32(x, 11) ^ rotr32(x, 25);\n    }\n    exports.s1_256 = s1_256;\n    function g0_256(x) {\n      return rotr32(x, 7) ^ rotr32(x, 18) ^ x >>> 3;\n    }\n    exports.g0_256 = g0_256;\n    function g1_256(x) {\n      return rotr32(x, 17) ^ rotr32(x, 19) ^ x >>> 10;\n    }\n    exports.g1_256 = g1_256;\n  }\n}), require__ = __commonJS({\n  \"node_modules/hash.js/lib/hash/sha/1.js\"(exports, module) {\n    var utils = require_utils4(), common = require_common(), shaCommon = require_common2(), rotl32 = utils.rotl32, sum32 = utils.sum32, sum32_5 = utils.sum32_5, ft_1 = shaCommon.ft_1, BlockHash = common.BlockHash, sha1_K = [1518500249, 1859775393, 2400959708, 3395469782];\n    function SHA1() {\n      if (!(this instanceof SHA1))\n        return new SHA1;\n      BlockHash.call(this), this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.W = new Array(80);\n    }\n    utils.inherits(SHA1, BlockHash), module.exports = SHA1, SHA1.blockSize = 512, SHA1.outSize = 160, SHA1.hmacStrength = 80, SHA1.padLength = 64, SHA1.prototype._update = function(msg, start) {\n      for (var W = this.W, i = 0;i < 16; i++)\n        W[i] = msg[start + i];\n      for (;i < W.length; i++)\n        W[i] = rotl32(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16], 1);\n      var a = this.h[0], b = this.h[1], c = this.h[2], d = this.h[3], e = this.h[4];\n      for (i = 0;i < W.length; i++) {\n        var s = ~~(i / 20), t = sum32_5(rotl32(a, 5), ft_1(s, b, c, d), e, W[i], sha1_K[s]);\n        e = d, d = c, c = rotl32(b, 30), b = a, a = t;\n      }\n      this.h[0] = sum32(this.h[0], a), this.h[1] = sum32(this.h[1], b), this.h[2] = sum32(this.h[2], c), this.h[3] = sum32(this.h[3], d), this.h[4] = sum32(this.h[4], e);\n    }, SHA1.prototype._digest = function(enc) {\n      return enc === \"hex\" \? utils.toHex32(this.h, \"big\") : utils.split32(this.h, \"big\");\n    };\n  }\n}), require__2 = __commonJS({\n  \"node_modules/hash.js/lib/hash/sha/256.js\"(exports, module) {\n    var utils = require_utils4(), common = require_common(), shaCommon = require_common2(), assert = require_minimalistic_assert(), sum32 = utils.sum32, sum32_4 = utils.sum32_4, sum32_5 = utils.sum32_5, ch32 = shaCommon.ch32, maj32 = shaCommon.maj32, s0_256 = shaCommon.s0_256, s1_256 = shaCommon.s1_256, g0_256 = shaCommon.g0_256, g1_256 = shaCommon.g1_256, BlockHash = common.BlockHash, sha256_K = [\n      1116352408,\n      1899447441,\n      3049323471,\n      3921009573,\n      961987163,\n      1508970993,\n      2453635748,\n      2870763221,\n      3624381080,\n      310598401,\n      607225278,\n      1426881987,\n      1925078388,\n      2162078206,\n      2614888103,\n      3248222580,\n      3835390401,\n      4022224774,\n      264347078,\n      604807628,\n      770255983,\n      1249150122,\n      1555081692,\n      1996064986,\n      2554220882,\n      2821834349,\n      2952996808,\n      3210313671,\n      3336571891,\n      3584528711,\n      113926993,\n      338241895,\n      666307205,\n      773529912,\n      1294757372,\n      1396182291,\n      1695183700,\n      1986661051,\n      2177026350,\n      2456956037,\n      2730485921,\n      2820302411,\n      3259730800,\n      3345764771,\n      3516065817,\n      3600352804,\n      4094571909,\n      275423344,\n      430227734,\n      506948616,\n      659060556,\n      883997877,\n      958139571,\n      1322822218,\n      1537002063,\n      1747873779,\n      1955562222,\n      2024104815,\n      2227730452,\n      2361852424,\n      2428436474,\n      2756734187,\n      3204031479,\n      3329325298\n    ];\n    function SHA256() {\n      if (!(this instanceof SHA256))\n        return new SHA256;\n      BlockHash.call(this), this.h = [1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225], this.k = sha256_K, this.W = new Array(64);\n    }\n    utils.inherits(SHA256, BlockHash), module.exports = SHA256, SHA256.blockSize = 512, SHA256.outSize = 256, SHA256.hmacStrength = 192, SHA256.padLength = 64, SHA256.prototype._update = function(msg, start) {\n      for (var W = this.W, i = 0;i < 16; i++)\n        W[i] = msg[start + i];\n      for (;i < W.length; i++)\n        W[i] = sum32_4(g1_256(W[i - 2]), W[i - 7], g0_256(W[i - 15]), W[i - 16]);\n      var a = this.h[0], b = this.h[1], c = this.h[2], d = this.h[3], e = this.h[4], f = this.h[5], g = this.h[6], h = this.h[7];\n      for (assert(this.k.length === W.length), i = 0;i < W.length; i++) {\n        var T1 = sum32_5(h, s1_256(e), ch32(e, f, g), this.k[i], W[i]), T2 = sum32(s0_256(a), maj32(a, b, c));\n        h = g, g = f, f = e, e = sum32(d, T1), d = c, c = b, b = a, a = sum32(T1, T2);\n      }\n      this.h[0] = sum32(this.h[0], a), this.h[1] = sum32(this.h[1], b), this.h[2] = sum32(this.h[2], c), this.h[3] = sum32(this.h[3], d), this.h[4] = sum32(this.h[4], e), this.h[5] = sum32(this.h[5], f), this.h[6] = sum32(this.h[6], g), this.h[7] = sum32(this.h[7], h);\n    }, SHA256.prototype._digest = function(enc) {\n      return enc === \"hex\" \? utils.toHex32(this.h, \"big\") : utils.split32(this.h, \"big\");\n    };\n  }\n}), require__3 = __commonJS({\n  \"node_modules/hash.js/lib/hash/sha/224.js\"(exports, module) {\n    var utils = require_utils4(), SHA256 = require__2();\n    function SHA224() {\n      if (!(this instanceof SHA224))\n        return new SHA224;\n      SHA256.call(this), this.h = [3238371032, 914150663, 812702999, 4144912697, 4290775857, 1750603025, 1694076839, 3204075428];\n    }\n    utils.inherits(SHA224, SHA256), module.exports = SHA224, SHA224.blockSize = 512, SHA224.outSize = 224, SHA224.hmacStrength = 192, SHA224.padLength = 64, SHA224.prototype._digest = function(enc) {\n      return enc === \"hex\" \? utils.toHex32(this.h.slice(0, 7), \"big\") : utils.split32(this.h.slice(0, 7), \"big\");\n    };\n  }\n}), require__4 = __commonJS({\n  \"node_modules/hash.js/lib/hash/sha/512.js\"(exports, module) {\n    var utils = require_utils4(), common = require_common(), assert = require_minimalistic_assert(), rotr64_hi = utils.rotr64_hi, rotr64_lo = utils.rotr64_lo, shr64_hi = utils.shr64_hi, shr64_lo = utils.shr64_lo, sum64 = utils.sum64, sum64_hi = utils.sum64_hi, sum64_lo = utils.sum64_lo, sum64_4_hi = utils.sum64_4_hi, sum64_4_lo = utils.sum64_4_lo, sum64_5_hi = utils.sum64_5_hi, sum64_5_lo = utils.sum64_5_lo, BlockHash = common.BlockHash, sha512_K = [\n      1116352408,\n      3609767458,\n      1899447441,\n      602891725,\n      3049323471,\n      3964484399,\n      3921009573,\n      2173295548,\n      961987163,\n      4081628472,\n      1508970993,\n      3053834265,\n      2453635748,\n      2937671579,\n      2870763221,\n      3664609560,\n      3624381080,\n      2734883394,\n      310598401,\n      1164996542,\n      607225278,\n      1323610764,\n      1426881987,\n      3590304994,\n      1925078388,\n      4068182383,\n      2162078206,\n      991336113,\n      2614888103,\n      633803317,\n      3248222580,\n      3479774868,\n      3835390401,\n      2666613458,\n      4022224774,\n      944711139,\n      264347078,\n      2341262773,\n      604807628,\n      2007800933,\n      770255983,\n      1495990901,\n      1249150122,\n      1856431235,\n      1555081692,\n      3175218132,\n      1996064986,\n      2198950837,\n      2554220882,\n      3999719339,\n      2821834349,\n      766784016,\n      2952996808,\n      2566594879,\n      3210313671,\n      3203337956,\n      3336571891,\n      1034457026,\n      3584528711,\n      2466948901,\n      113926993,\n      3758326383,\n      338241895,\n      168717936,\n      666307205,\n      1188179964,\n      773529912,\n      1546045734,\n      1294757372,\n      1522805485,\n      1396182291,\n      2643833823,\n      1695183700,\n      2343527390,\n      1986661051,\n      1014477480,\n      2177026350,\n      1206759142,\n      2456956037,\n      344077627,\n      2730485921,\n      1290863460,\n      2820302411,\n      3158454273,\n      3259730800,\n      3505952657,\n      3345764771,\n      106217008,\n      3516065817,\n      3606008344,\n      3600352804,\n      1432725776,\n      4094571909,\n      1467031594,\n      275423344,\n      851169720,\n      430227734,\n      3100823752,\n      506948616,\n      1363258195,\n      659060556,\n      3750685593,\n      883997877,\n      3785050280,\n      958139571,\n      3318307427,\n      1322822218,\n      3812723403,\n      1537002063,\n      2003034995,\n      1747873779,\n      3602036899,\n      1955562222,\n      1575990012,\n      2024104815,\n      1125592928,\n      2227730452,\n      2716904306,\n      2361852424,\n      442776044,\n      2428436474,\n      593698344,\n      2756734187,\n      3733110249,\n      3204031479,\n      2999351573,\n      3329325298,\n      3815920427,\n      3391569614,\n      3928383900,\n      3515267271,\n      566280711,\n      3940187606,\n      3454069534,\n      4118630271,\n      4000239992,\n      116418474,\n      1914138554,\n      174292421,\n      2731055270,\n      289380356,\n      3203993006,\n      460393269,\n      320620315,\n      685471733,\n      587496836,\n      852142971,\n      1086792851,\n      1017036298,\n      365543100,\n      1126000580,\n      2618297676,\n      1288033470,\n      3409855158,\n      1501505948,\n      4234509866,\n      1607167915,\n      987167468,\n      1816402316,\n      1246189591\n    ];\n    function SHA512() {\n      if (!(this instanceof SHA512))\n        return new SHA512;\n      BlockHash.call(this), this.h = [\n        1779033703,\n        4089235720,\n        3144134277,\n        2227873595,\n        1013904242,\n        4271175723,\n        2773480762,\n        1595750129,\n        1359893119,\n        2917565137,\n        2600822924,\n        725511199,\n        528734635,\n        4215389547,\n        1541459225,\n        327033209\n      ], this.k = sha512_K, this.W = new Array(160);\n    }\n    utils.inherits(SHA512, BlockHash), module.exports = SHA512, SHA512.blockSize = 1024, SHA512.outSize = 512, SHA512.hmacStrength = 192, SHA512.padLength = 128, SHA512.prototype._prepareBlock = function(msg, start) {\n      for (var W = this.W, i = 0;i < 32; i++)\n        W[i] = msg[start + i];\n      for (;i < W.length; i += 2) {\n        var c0_hi = g1_512_hi(W[i - 4], W[i - 3]), c0_lo = g1_512_lo(W[i - 4], W[i - 3]), c1_hi = W[i - 14], c1_lo = W[i - 13], c2_hi = g0_512_hi(W[i - 30], W[i - 29]), c2_lo = g0_512_lo(W[i - 30], W[i - 29]), c3_hi = W[i - 32], c3_lo = W[i - 31];\n        W[i] = sum64_4_hi(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo), W[i + 1] = sum64_4_lo(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo);\n      }\n    }, SHA512.prototype._update = function(msg, start) {\n      this._prepareBlock(msg, start);\n      var W = this.W, ah = this.h[0], al = this.h[1], bh = this.h[2], bl = this.h[3], ch = this.h[4], cl = this.h[5], dh = this.h[6], dl = this.h[7], eh = this.h[8], el = this.h[9], fh = this.h[10], fl = this.h[11], gh = this.h[12], gl = this.h[13], hh = this.h[14], hl = this.h[15];\n      assert(this.k.length === W.length);\n      for (var i = 0;i < W.length; i += 2) {\n        var c0_hi = hh, c0_lo = hl, c1_hi = s1_512_hi(eh, el), c1_lo = s1_512_lo(eh, el), c2_hi = ch64_hi(eh, el, fh, fl, gh, gl), c2_lo = ch64_lo(eh, el, fh, fl, gh, gl), c3_hi = this.k[i], c3_lo = this.k[i + 1], c4_hi = W[i], c4_lo = W[i + 1], T1_hi = sum64_5_hi(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo, c4_hi, c4_lo), T1_lo = sum64_5_lo(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo, c4_hi, c4_lo);\n        c0_hi = s0_512_hi(ah, al), c0_lo = s0_512_lo(ah, al), c1_hi = maj64_hi(ah, al, bh, bl, ch, cl), c1_lo = maj64_lo(ah, al, bh, bl, ch, cl);\n        var T2_hi = sum64_hi(c0_hi, c0_lo, c1_hi, c1_lo), T2_lo = sum64_lo(c0_hi, c0_lo, c1_hi, c1_lo);\n        hh = gh, hl = gl, gh = fh, gl = fl, fh = eh, fl = el, eh = sum64_hi(dh, dl, T1_hi, T1_lo), el = sum64_lo(dl, dl, T1_hi, T1_lo), dh = ch, dl = cl, ch = bh, cl = bl, bh = ah, bl = al, ah = sum64_hi(T1_hi, T1_lo, T2_hi, T2_lo), al = sum64_lo(T1_hi, T1_lo, T2_hi, T2_lo);\n      }\n      sum64(this.h, 0, ah, al), sum64(this.h, 2, bh, bl), sum64(this.h, 4, ch, cl), sum64(this.h, 6, dh, dl), sum64(this.h, 8, eh, el), sum64(this.h, 10, fh, fl), sum64(this.h, 12, gh, gl), sum64(this.h, 14, hh, hl);\n    }, SHA512.prototype._digest = function(enc) {\n      return enc === \"hex\" \? utils.toHex32(this.h, \"big\") : utils.split32(this.h, \"big\");\n    };\n    function ch64_hi(xh, xl, yh, yl, zh) {\n      var r = xh & yh ^ ~xh & zh;\n      return r < 0 && (r += 4294967296), r;\n    }\n    function ch64_lo(xh, xl, yh, yl, zh, zl) {\n      var r = xl & yl ^ ~xl & zl;\n      return r < 0 && (r += 4294967296), r;\n    }\n    function maj64_hi(xh, xl, yh, yl, zh) {\n      var r = xh & yh ^ xh & zh ^ yh & zh;\n      return r < 0 && (r += 4294967296), r;\n    }\n    function maj64_lo(xh, xl, yh, yl, zh, zl) {\n      var r = xl & yl ^ xl & zl ^ yl & zl;\n      return r < 0 && (r += 4294967296), r;\n    }\n    function s0_512_hi(xh, xl) {\n      var c0_hi = rotr64_hi(xh, xl, 28), c1_hi = rotr64_hi(xl, xh, 2), c2_hi = rotr64_hi(xl, xh, 7), r = c0_hi ^ c1_hi ^ c2_hi;\n      return r < 0 && (r += 4294967296), r;\n    }\n    function s0_512_lo(xh, xl) {\n      var c0_lo = rotr64_lo(xh, xl, 28), c1_lo = rotr64_lo(xl, xh, 2), c2_lo = rotr64_lo(xl, xh, 7), r = c0_lo ^ c1_lo ^ c2_lo;\n      return r < 0 && (r += 4294967296), r;\n    }\n    function s1_512_hi(xh, xl) {\n      var c0_hi = rotr64_hi(xh, xl, 14), c1_hi = rotr64_hi(xh, xl, 18), c2_hi = rotr64_hi(xl, xh, 9), r = c0_hi ^ c1_hi ^ c2_hi;\n      return r < 0 && (r += 4294967296), r;\n    }\n    function s1_512_lo(xh, xl) {\n      var c0_lo = rotr64_lo(xh, xl, 14), c1_lo = rotr64_lo(xh, xl, 18), c2_lo = rotr64_lo(xl, xh, 9), r = c0_lo ^ c1_lo ^ c2_lo;\n      return r < 0 && (r += 4294967296), r;\n    }\n    function g0_512_hi(xh, xl) {\n      var c0_hi = rotr64_hi(xh, xl, 1), c1_hi = rotr64_hi(xh, xl, 8), c2_hi = shr64_hi(xh, xl, 7), r = c0_hi ^ c1_hi ^ c2_hi;\n      return r < 0 && (r += 4294967296), r;\n    }\n    function g0_512_lo(xh, xl) {\n      var c0_lo = rotr64_lo(xh, xl, 1), c1_lo = rotr64_lo(xh, xl, 8), c2_lo = shr64_lo(xh, xl, 7), r = c0_lo ^ c1_lo ^ c2_lo;\n      return r < 0 && (r += 4294967296), r;\n    }\n    function g1_512_hi(xh, xl) {\n      var c0_hi = rotr64_hi(xh, xl, 19), c1_hi = rotr64_hi(xl, xh, 29), c2_hi = shr64_hi(xh, xl, 6), r = c0_hi ^ c1_hi ^ c2_hi;\n      return r < 0 && (r += 4294967296), r;\n    }\n    function g1_512_lo(xh, xl) {\n      var c0_lo = rotr64_lo(xh, xl, 19), c1_lo = rotr64_lo(xl, xh, 29), c2_lo = shr64_lo(xh, xl, 6), r = c0_lo ^ c1_lo ^ c2_lo;\n      return r < 0 && (r += 4294967296), r;\n    }\n  }\n}), require__5 = __commonJS({\n  \"node_modules/hash.js/lib/hash/sha/384.js\"(exports, module) {\n    var utils = require_utils4(), SHA512 = require__4();\n    function SHA384() {\n      if (!(this instanceof SHA384))\n        return new SHA384;\n      SHA512.call(this), this.h = [\n        3418070365,\n        3238371032,\n        1654270250,\n        914150663,\n        2438529370,\n        812702999,\n        355462360,\n        4144912697,\n        1731405415,\n        4290775857,\n        2394180231,\n        1750603025,\n        3675008525,\n        1694076839,\n        1203062813,\n        3204075428\n      ];\n    }\n    utils.inherits(SHA384, SHA512), module.exports = SHA384, SHA384.blockSize = 1024, SHA384.outSize = 384, SHA384.hmacStrength = 192, SHA384.padLength = 128, SHA384.prototype._digest = function(enc) {\n      return enc === \"hex\" \? utils.toHex32(this.h.slice(0, 12), \"big\") : utils.split32(this.h.slice(0, 12), \"big\");\n    };\n  }\n}), require_sha3 = __commonJS({\n  \"node_modules/hash.js/lib/hash/sha.js\"(exports) {\n    exports.sha1 = require__(), exports.sha224 = require__3(), exports.sha256 = require__2(), exports.sha384 = require__5(), exports.sha512 = require__4();\n  }\n}), require_ripemd = __commonJS({\n  \"node_modules/hash.js/lib/hash/ripemd.js\"(exports) {\n    var utils = require_utils4(), common = require_common(), rotl32 = utils.rotl32, sum32 = utils.sum32, sum32_3 = utils.sum32_3, sum32_4 = utils.sum32_4, BlockHash = common.BlockHash;\n    function RIPEMD160() {\n      if (!(this instanceof RIPEMD160))\n        return new RIPEMD160;\n      BlockHash.call(this), this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.endian = \"little\";\n    }\n    utils.inherits(RIPEMD160, BlockHash), exports.ripemd160 = RIPEMD160, RIPEMD160.blockSize = 512, RIPEMD160.outSize = 160, RIPEMD160.hmacStrength = 192, RIPEMD160.padLength = 64, RIPEMD160.prototype._update = function(msg, start) {\n      for (var A = this.h[0], B = this.h[1], C = this.h[2], D = this.h[3], E = this.h[4], Ah = A, Bh = B, Ch = C, Dh = D, Eh = E, j = 0;j < 80; j++) {\n        var T = sum32(rotl32(sum32_4(A, f(j, B, C, D), msg[r[j] + start], K(j)), s[j]), E);\n        A = E, E = D, D = rotl32(C, 10), C = B, B = T, T = sum32(rotl32(sum32_4(Ah, f(79 - j, Bh, Ch, Dh), msg[rh[j] + start], Kh(j)), sh[j]), Eh), Ah = Eh, Eh = Dh, Dh = rotl32(Ch, 10), Ch = Bh, Bh = T;\n      }\n      T = sum32_3(this.h[1], C, Dh), this.h[1] = sum32_3(this.h[2], D, Eh), this.h[2] = sum32_3(this.h[3], E, Ah), this.h[3] = sum32_3(this.h[4], A, Bh), this.h[4] = sum32_3(this.h[0], B, Ch), this.h[0] = T;\n    }, RIPEMD160.prototype._digest = function(enc) {\n      return enc === \"hex\" \? utils.toHex32(this.h, \"little\") : utils.split32(this.h, \"little\");\n    };\n    function f(j, x, y, z) {\n      return j <= 15 \? x ^ y ^ z : j <= 31 \? x & y | ~x & z : j <= 47 \? (x | ~y) ^ z : j <= 63 \? x & z | y & ~z : x ^ (y | ~z);\n    }\n    function K(j) {\n      return j <= 15 \? 0 : j <= 31 \? 1518500249 : j <= 47 \? 1859775393 : j <= 63 \? 2400959708 : 2840853838;\n    }\n    function Kh(j) {\n      return j <= 15 \? 1352829926 : j <= 31 \? 1548603684 : j <= 47 \? 1836072691 : j <= 63 \? 2053994217 : 0;\n    }\n    var r = [\n      0,\n      1,\n      2,\n      3,\n      4,\n      5,\n      6,\n      7,\n      8,\n      9,\n      10,\n      11,\n      12,\n      13,\n      14,\n      15,\n      7,\n      4,\n      13,\n      1,\n      10,\n      6,\n      15,\n      3,\n      12,\n      0,\n      9,\n      5,\n      2,\n      14,\n      11,\n      8,\n      3,\n      10,\n      14,\n      4,\n      9,\n      15,\n      8,\n      1,\n      2,\n      7,\n      0,\n      6,\n      13,\n      11,\n      5,\n      12,\n      1,\n      9,\n      11,\n      10,\n      0,\n      8,\n      12,\n      4,\n      13,\n      3,\n      7,\n      15,\n      14,\n      5,\n      6,\n      2,\n      4,\n      0,\n      5,\n      9,\n      7,\n      12,\n      2,\n      10,\n      14,\n      1,\n      3,\n      8,\n      11,\n      6,\n      15,\n      13\n    ], rh = [\n      5,\n      14,\n      7,\n      0,\n      9,\n      2,\n      11,\n      4,\n      13,\n      6,\n      15,\n      8,\n      1,\n      10,\n      3,\n      12,\n      6,\n      11,\n      3,\n      7,\n      0,\n      13,\n      5,\n      10,\n      14,\n      15,\n      8,\n      12,\n      4,\n      9,\n      1,\n      2,\n      15,\n      5,\n      1,\n      3,\n      7,\n      14,\n      6,\n      9,\n      11,\n      8,\n      12,\n      2,\n      10,\n      0,\n      4,\n      13,\n      8,\n      6,\n      4,\n      1,\n      3,\n      11,\n      15,\n      0,\n      5,\n      12,\n      2,\n      13,\n      9,\n      7,\n      10,\n      14,\n      12,\n      15,\n      10,\n      4,\n      1,\n      5,\n      8,\n      7,\n      6,\n      2,\n      13,\n      14,\n      0,\n      3,\n      9,\n      11\n    ], s = [\n      11,\n      14,\n      15,\n      12,\n      5,\n      8,\n      7,\n      9,\n      11,\n      13,\n      14,\n      15,\n      6,\n      7,\n      9,\n      8,\n      7,\n      6,\n      8,\n      13,\n      11,\n      9,\n      7,\n      15,\n      7,\n      12,\n      15,\n      9,\n      11,\n      7,\n      13,\n      12,\n      11,\n      13,\n      6,\n      7,\n      14,\n      9,\n      13,\n      15,\n      14,\n      8,\n      13,\n      6,\n      5,\n      12,\n      7,\n      5,\n      11,\n      12,\n      14,\n      15,\n      14,\n      15,\n      9,\n      8,\n      9,\n      14,\n      5,\n      6,\n      8,\n      6,\n      5,\n      12,\n      9,\n      15,\n      5,\n      11,\n      6,\n      8,\n      13,\n      12,\n      5,\n      12,\n      13,\n      14,\n      11,\n      8,\n      5,\n      6\n    ], sh = [\n      8,\n      9,\n      9,\n      11,\n      13,\n      15,\n      15,\n      5,\n      7,\n      7,\n      8,\n      11,\n      14,\n      14,\n      12,\n      6,\n      9,\n      13,\n      15,\n      7,\n      12,\n      8,\n      9,\n      11,\n      7,\n      7,\n      12,\n      7,\n      6,\n      15,\n      13,\n      11,\n      9,\n      7,\n      15,\n      11,\n      8,\n      6,\n      6,\n      14,\n      12,\n      13,\n      5,\n      14,\n      13,\n      13,\n      7,\n      5,\n      15,\n      5,\n      8,\n      11,\n      14,\n      14,\n      6,\n      14,\n      6,\n      9,\n      12,\n      9,\n      12,\n      5,\n      15,\n      8,\n      8,\n      5,\n      12,\n      9,\n      12,\n      5,\n      14,\n      6,\n      8,\n      13,\n      6,\n      5,\n      15,\n      13,\n      11,\n      11\n    ];\n  }\n}), require_hmac = __commonJS({\n  \"node_modules/hash.js/lib/hash/hmac.js\"(exports, module) {\n    var utils = require_utils4(), assert = require_minimalistic_assert();\n    function Hmac(hash, key, enc) {\n      if (!(this instanceof Hmac))\n        return new Hmac(hash, key, enc);\n      this.Hash = hash, this.blockSize = hash.blockSize / 8, this.outSize = hash.outSize / 8, this.inner = null, this.outer = null, this._init(utils.toArray(key, enc));\n    }\n    Hmac.prototype = {}, module.exports = Hmac, Hmac.prototype._init = function(key) {\n      key.length > this.blockSize && (key = new this.Hash().update(key).digest()), assert(key.length <= this.blockSize);\n      for (var i = key.length;i < this.blockSize; i++)\n        key.push(0);\n      for (i = 0;i < key.length; i++)\n        key[i] ^= 54;\n      for (this.inner = new this.Hash().update(key), i = 0;i < key.length; i++)\n        key[i] ^= 106;\n      this.outer = new this.Hash().update(key);\n    }, Hmac.prototype.update = function(msg, enc) {\n      return this.inner.update(msg, enc), this;\n    }, Hmac.prototype.digest = function(enc) {\n      return this.outer.update(this.inner.digest()), this.outer.digest(enc);\n    };\n  }\n}), require_hash2 = __commonJS({\n  \"node_modules/hash.js/lib/hash.js\"(exports) {\n    var hash = exports;\n    hash.utils = require_utils4(), hash.common = require_common(), hash.sha = require_sha3(), hash.ripemd = require_ripemd(), hash.hmac = require_hmac(), hash.sha1 = hash.sha.sha1, hash.sha256 = hash.sha.sha256, hash.sha224 = hash.sha.sha224, hash.sha384 = hash.sha.sha384, hash.sha512 = hash.sha.sha512, hash.ripemd160 = hash.ripemd.ripemd160;\n  }\n}), require_secp256k1 = __commonJS({\n  \"node_modules/elliptic/lib/elliptic/precomputed/secp256k1.js\"(exports, module) {\n    module.exports = {\n      doubles: {\n        step: 4,\n        points: [\n          [\n            \"e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a\",\n            \"f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821\"\n          ],\n          [\n            \"8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508\",\n            \"11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf\"\n          ],\n          [\n            \"175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739\",\n            \"d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695\"\n          ],\n          [\n            \"363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640\",\n            \"4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9\"\n          ],\n          [\n            \"8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c\",\n            \"4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36\"\n          ],\n          [\n            \"723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda\",\n            \"96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f\"\n          ],\n          [\n            \"eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa\",\n            \"5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999\"\n          ],\n          [\n            \"100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0\",\n            \"cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09\"\n          ],\n          [\n            \"e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d\",\n            \"9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d\"\n          ],\n          [\n            \"feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d\",\n            \"e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088\"\n          ],\n          [\n            \"da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1\",\n            \"9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d\"\n          ],\n          [\n            \"53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0\",\n            \"5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8\"\n          ],\n          [\n            \"8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047\",\n            \"10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a\"\n          ],\n          [\n            \"385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862\",\n            \"283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453\"\n          ],\n          [\n            \"6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7\",\n            \"7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160\"\n          ],\n          [\n            \"3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd\",\n            \"56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0\"\n          ],\n          [\n            \"85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83\",\n            \"7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6\"\n          ],\n          [\n            \"948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a\",\n            \"53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589\"\n          ],\n          [\n            \"6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8\",\n            \"bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17\"\n          ],\n          [\n            \"e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d\",\n            \"4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda\"\n          ],\n          [\n            \"e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725\",\n            \"7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd\"\n          ],\n          [\n            \"213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754\",\n            \"4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2\"\n          ],\n          [\n            \"4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c\",\n            \"17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6\"\n          ],\n          [\n            \"fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6\",\n            \"6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f\"\n          ],\n          [\n            \"76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39\",\n            \"c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01\"\n          ],\n          [\n            \"c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891\",\n            \"893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3\"\n          ],\n          [\n            \"d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b\",\n            \"febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f\"\n          ],\n          [\n            \"b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03\",\n            \"2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7\"\n          ],\n          [\n            \"e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d\",\n            \"eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78\"\n          ],\n          [\n            \"a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070\",\n            \"7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1\"\n          ],\n          [\n            \"90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4\",\n            \"e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150\"\n          ],\n          [\n            \"8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da\",\n            \"662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82\"\n          ],\n          [\n            \"e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11\",\n            \"1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc\"\n          ],\n          [\n            \"8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e\",\n            \"efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b\"\n          ],\n          [\n            \"e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41\",\n            \"2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51\"\n          ],\n          [\n            \"b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef\",\n            \"67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45\"\n          ],\n          [\n            \"d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8\",\n            \"db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120\"\n          ],\n          [\n            \"324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d\",\n            \"648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84\"\n          ],\n          [\n            \"4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96\",\n            \"35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d\"\n          ],\n          [\n            \"9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd\",\n            \"ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d\"\n          ],\n          [\n            \"6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5\",\n            \"9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8\"\n          ],\n          [\n            \"a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266\",\n            \"40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8\"\n          ],\n          [\n            \"7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71\",\n            \"34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac\"\n          ],\n          [\n            \"928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac\",\n            \"c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f\"\n          ],\n          [\n            \"85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751\",\n            \"1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962\"\n          ],\n          [\n            \"ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e\",\n            \"493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907\"\n          ],\n          [\n            \"827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241\",\n            \"c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec\"\n          ],\n          [\n            \"eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3\",\n            \"be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d\"\n          ],\n          [\n            \"e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f\",\n            \"4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414\"\n          ],\n          [\n            \"1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19\",\n            \"aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd\"\n          ],\n          [\n            \"146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be\",\n            \"b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0\"\n          ],\n          [\n            \"fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9\",\n            \"6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811\"\n          ],\n          [\n            \"da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2\",\n            \"8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1\"\n          ],\n          [\n            \"a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13\",\n            \"7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c\"\n          ],\n          [\n            \"174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c\",\n            \"ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73\"\n          ],\n          [\n            \"959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba\",\n            \"2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd\"\n          ],\n          [\n            \"d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151\",\n            \"e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405\"\n          ],\n          [\n            \"64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073\",\n            \"d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589\"\n          ],\n          [\n            \"8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458\",\n            \"38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e\"\n          ],\n          [\n            \"13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b\",\n            \"69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27\"\n          ],\n          [\n            \"bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366\",\n            \"d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1\"\n          ],\n          [\n            \"8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa\",\n            \"40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482\"\n          ],\n          [\n            \"8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0\",\n            \"620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945\"\n          ],\n          [\n            \"dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787\",\n            \"7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573\"\n          ],\n          [\n            \"f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e\",\n            \"ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82\"\n          ]\n        ]\n      },\n      naf: {\n        wnd: 7,\n        points: [\n          [\n            \"f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9\",\n            \"388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672\"\n          ],\n          [\n            \"2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4\",\n            \"d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6\"\n          ],\n          [\n            \"5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc\",\n            \"6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da\"\n          ],\n          [\n            \"acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe\",\n            \"cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37\"\n          ],\n          [\n            \"774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb\",\n            \"d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b\"\n          ],\n          [\n            \"f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8\",\n            \"ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81\"\n          ],\n          [\n            \"d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e\",\n            \"581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58\"\n          ],\n          [\n            \"defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34\",\n            \"4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77\"\n          ],\n          [\n            \"2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c\",\n            \"85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a\"\n          ],\n          [\n            \"352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5\",\n            \"321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c\"\n          ],\n          [\n            \"2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f\",\n            \"2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67\"\n          ],\n          [\n            \"9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714\",\n            \"73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402\"\n          ],\n          [\n            \"daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729\",\n            \"a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55\"\n          ],\n          [\n            \"c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db\",\n            \"2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482\"\n          ],\n          [\n            \"6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4\",\n            \"e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82\"\n          ],\n          [\n            \"1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5\",\n            \"b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396\"\n          ],\n          [\n            \"605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479\",\n            \"2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49\"\n          ],\n          [\n            \"62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d\",\n            \"80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf\"\n          ],\n          [\n            \"80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f\",\n            \"1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a\"\n          ],\n          [\n            \"7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb\",\n            \"d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7\"\n          ],\n          [\n            \"d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9\",\n            \"eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933\"\n          ],\n          [\n            \"49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963\",\n            \"758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a\"\n          ],\n          [\n            \"77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74\",\n            \"958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6\"\n          ],\n          [\n            \"f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530\",\n            \"e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37\"\n          ],\n          [\n            \"463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b\",\n            \"5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e\"\n          ],\n          [\n            \"f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247\",\n            \"cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6\"\n          ],\n          [\n            \"caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1\",\n            \"cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476\"\n          ],\n          [\n            \"2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120\",\n            \"4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40\"\n          ],\n          [\n            \"7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435\",\n            \"91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61\"\n          ],\n          [\n            \"754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18\",\n            \"673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683\"\n          ],\n          [\n            \"e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8\",\n            \"59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5\"\n          ],\n          [\n            \"186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb\",\n            \"3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b\"\n          ],\n          [\n            \"df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f\",\n            \"55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417\"\n          ],\n          [\n            \"5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143\",\n            \"efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868\"\n          ],\n          [\n            \"290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba\",\n            \"e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a\"\n          ],\n          [\n            \"af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45\",\n            \"f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6\"\n          ],\n          [\n            \"766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a\",\n            \"744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996\"\n          ],\n          [\n            \"59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e\",\n            \"c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e\"\n          ],\n          [\n            \"f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8\",\n            \"e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d\"\n          ],\n          [\n            \"7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c\",\n            \"30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2\"\n          ],\n          [\n            \"948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519\",\n            \"e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e\"\n          ],\n          [\n            \"7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab\",\n            \"100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437\"\n          ],\n          [\n            \"3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca\",\n            \"ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311\"\n          ],\n          [\n            \"d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf\",\n            \"8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4\"\n          ],\n          [\n            \"1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610\",\n            \"68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575\"\n          ],\n          [\n            \"733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4\",\n            \"f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d\"\n          ],\n          [\n            \"15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c\",\n            \"d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d\"\n          ],\n          [\n            \"a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940\",\n            \"edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629\"\n          ],\n          [\n            \"e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980\",\n            \"a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06\"\n          ],\n          [\n            \"311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3\",\n            \"66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374\"\n          ],\n          [\n            \"34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf\",\n            \"9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee\"\n          ],\n          [\n            \"f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63\",\n            \"4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1\"\n          ],\n          [\n            \"d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448\",\n            \"fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b\"\n          ],\n          [\n            \"32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf\",\n            \"5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661\"\n          ],\n          [\n            \"7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5\",\n            \"8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6\"\n          ],\n          [\n            \"ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6\",\n            \"8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e\"\n          ],\n          [\n            \"16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5\",\n            \"5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d\"\n          ],\n          [\n            \"eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99\",\n            \"f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc\"\n          ],\n          [\n            \"78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51\",\n            \"f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4\"\n          ],\n          [\n            \"494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5\",\n            \"42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c\"\n          ],\n          [\n            \"a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5\",\n            \"204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b\"\n          ],\n          [\n            \"c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997\",\n            \"4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913\"\n          ],\n          [\n            \"841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881\",\n            \"73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154\"\n          ],\n          [\n            \"5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5\",\n            \"39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865\"\n          ],\n          [\n            \"36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66\",\n            \"d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc\"\n          ],\n          [\n            \"336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726\",\n            \"ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224\"\n          ],\n          [\n            \"8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede\",\n            \"6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e\"\n          ],\n          [\n            \"1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94\",\n            \"60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6\"\n          ],\n          [\n            \"85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31\",\n            \"3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511\"\n          ],\n          [\n            \"29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51\",\n            \"b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b\"\n          ],\n          [\n            \"a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252\",\n            \"ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2\"\n          ],\n          [\n            \"4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5\",\n            \"cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c\"\n          ],\n          [\n            \"d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b\",\n            \"6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3\"\n          ],\n          [\n            \"ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4\",\n            \"322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d\"\n          ],\n          [\n            \"af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f\",\n            \"6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700\"\n          ],\n          [\n            \"e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889\",\n            \"2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4\"\n          ],\n          [\n            \"591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246\",\n            \"b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196\"\n          ],\n          [\n            \"11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984\",\n            \"998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4\"\n          ],\n          [\n            \"3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a\",\n            \"b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257\"\n          ],\n          [\n            \"cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030\",\n            \"bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13\"\n          ],\n          [\n            \"c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197\",\n            \"6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096\"\n          ],\n          [\n            \"c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593\",\n            \"c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38\"\n          ],\n          [\n            \"a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef\",\n            \"21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f\"\n          ],\n          [\n            \"347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38\",\n            \"60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448\"\n          ],\n          [\n            \"da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a\",\n            \"49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a\"\n          ],\n          [\n            \"c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111\",\n            \"5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4\"\n          ],\n          [\n            \"4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502\",\n            \"7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437\"\n          ],\n          [\n            \"3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea\",\n            \"be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7\"\n          ],\n          [\n            \"cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26\",\n            \"8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d\"\n          ],\n          [\n            \"b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986\",\n            \"39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a\"\n          ],\n          [\n            \"d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e\",\n            \"62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54\"\n          ],\n          [\n            \"48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4\",\n            \"25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77\"\n          ],\n          [\n            \"dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda\",\n            \"ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517\"\n          ],\n          [\n            \"6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859\",\n            \"cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10\"\n          ],\n          [\n            \"e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f\",\n            \"f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125\"\n          ],\n          [\n            \"eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c\",\n            \"6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e\"\n          ],\n          [\n            \"13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942\",\n            \"fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1\"\n          ],\n          [\n            \"ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a\",\n            \"1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2\"\n          ],\n          [\n            \"b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80\",\n            \"5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423\"\n          ],\n          [\n            \"ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d\",\n            \"438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8\"\n          ],\n          [\n            \"8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1\",\n            \"cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758\"\n          ],\n          [\n            \"52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63\",\n            \"c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375\"\n          ],\n          [\n            \"e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352\",\n            \"6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d\"\n          ],\n          [\n            \"7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193\",\n            \"ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec\"\n          ],\n          [\n            \"5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00\",\n            \"9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0\"\n          ],\n          [\n            \"32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58\",\n            \"ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c\"\n          ],\n          [\n            \"e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7\",\n            \"d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4\"\n          ],\n          [\n            \"8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8\",\n            \"c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f\"\n          ],\n          [\n            \"4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e\",\n            \"67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649\"\n          ],\n          [\n            \"3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d\",\n            \"cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826\"\n          ],\n          [\n            \"674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b\",\n            \"299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5\"\n          ],\n          [\n            \"d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f\",\n            \"f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87\"\n          ],\n          [\n            \"30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6\",\n            \"462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b\"\n          ],\n          [\n            \"be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297\",\n            \"62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc\"\n          ],\n          [\n            \"93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a\",\n            \"7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c\"\n          ],\n          [\n            \"b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c\",\n            \"ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f\"\n          ],\n          [\n            \"d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52\",\n            \"4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a\"\n          ],\n          [\n            \"d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb\",\n            \"bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46\"\n          ],\n          [\n            \"463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065\",\n            \"bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f\"\n          ],\n          [\n            \"7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917\",\n            \"603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03\"\n          ],\n          [\n            \"74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9\",\n            \"cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08\"\n          ],\n          [\n            \"30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3\",\n            \"553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8\"\n          ],\n          [\n            \"9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57\",\n            \"712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373\"\n          ],\n          [\n            \"176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66\",\n            \"ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3\"\n          ],\n          [\n            \"75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8\",\n            \"9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8\"\n          ],\n          [\n            \"809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721\",\n            \"9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1\"\n          ],\n          [\n            \"1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180\",\n            \"4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9\"\n          ]\n        ]\n      }\n    };\n  }\n}), require_curves = __commonJS({\n  \"node_modules/elliptic/lib/elliptic/curves.js\"(exports) {\n    var curves = exports, hash = require_hash2(), curve = require_curve(), utils = require_utils3(), assert = utils.assert;\n    function PresetCurve(options) {\n      options.type === \"short\" \? this.curve = new curve.short(options) : options.type === \"edwards\" \? this.curve = new curve.edwards(options) : this.curve = new curve.mont(options), this.g = this.curve.g, this.n = this.curve.n, this.hash = options.hash, assert(this.g.validate(), \"Invalid curve\"), assert(this.g.mul(this.n).isInfinity(), \"Invalid curve, G*N != O\");\n    }\n    curves.PresetCurve = PresetCurve;\n    function defineCurve(name, options) {\n      Object.defineProperty(curves, name, {\n        configurable: !0,\n        enumerable: !0,\n        get: function() {\n          var curve2 = new PresetCurve(options);\n          return Object.defineProperty(curves, name, {\n            configurable: !0,\n            enumerable: !0,\n            value: curve2\n          }), curve2;\n        }\n      });\n    }\n    defineCurve(\"p192\", {\n      type: \"short\",\n      prime: \"p192\",\n      p: \"ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff\",\n      a: \"ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc\",\n      b: \"64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1\",\n      n: \"ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831\",\n      hash: hash.sha256,\n      gRed: !1,\n      g: [\n        \"188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012\",\n        \"07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811\"\n      ]\n    }), defineCurve(\"p224\", {\n      type: \"short\",\n      prime: \"p224\",\n      p: \"ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001\",\n      a: \"ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe\",\n      b: \"b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4\",\n      n: \"ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d\",\n      hash: hash.sha256,\n      gRed: !1,\n      g: [\n        \"b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21\",\n        \"bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34\"\n      ]\n    }), defineCurve(\"p256\", {\n      type: \"short\",\n      prime: null,\n      p: \"ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff\",\n      a: \"ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc\",\n      b: \"5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b\",\n      n: \"ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551\",\n      hash: hash.sha256,\n      gRed: !1,\n      g: [\n        \"6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296\",\n        \"4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5\"\n      ]\n    }), defineCurve(\"p384\", {\n      type: \"short\",\n      prime: null,\n      p: \"ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff\",\n      a: \"ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc\",\n      b: \"b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef\",\n      n: \"ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973\",\n      hash: hash.sha384,\n      gRed: !1,\n      g: [\n        \"aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7\",\n        \"3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f\"\n      ]\n    }), defineCurve(\"p521\", {\n      type: \"short\",\n      prime: null,\n      p: \"000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff\",\n      a: \"000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc\",\n      b: \"00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00\",\n      n: \"000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409\",\n      hash: hash.sha512,\n      gRed: !1,\n      g: [\n        \"000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66\",\n        \"00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650\"\n      ]\n    }), defineCurve(\"curve25519\", {\n      type: \"mont\",\n      prime: \"p25519\",\n      p: \"7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed\",\n      a: \"76d06\",\n      b: \"1\",\n      n: \"1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed\",\n      hash: hash.sha256,\n      gRed: !1,\n      g: [\"9\"]\n    }), defineCurve(\"ed25519\", {\n      type: \"edwards\",\n      prime: \"p25519\",\n      p: \"7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed\",\n      a: \"-1\",\n      c: \"1\",\n      d: \"52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3\",\n      n: \"1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed\",\n      hash: hash.sha256,\n      gRed: !1,\n      g: [\n        \"216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a\",\n        \"6666666666666666666666666666666666666666666666666666666666666658\"\n      ]\n    });\n    var pre;\n    try {\n      pre = require_secp256k1();\n    } catch {\n      pre = void 0;\n    }\n    defineCurve(\"secp256k1\", {\n      type: \"short\",\n      prime: \"k256\",\n      p: \"ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f\",\n      a: \"0\",\n      b: \"7\",\n      n: \"ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141\",\n      h: \"1\",\n      hash: hash.sha256,\n      beta: \"7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\",\n      lambda: \"5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72\",\n      basis: [\n        {\n          a: \"3086d221a7d46bcde86c90e49284eb15\",\n          b: \"-e4437ed6010e88286f547fa90abfe4c3\"\n        },\n        {\n          a: \"114ca50f7a8e2f3f657c1108d9d44cfd8\",\n          b: \"3086d221a7d46bcde86c90e49284eb15\"\n        }\n      ],\n      gRed: !1,\n      g: [\n        \"79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798\",\n        \"483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8\",\n        pre\n      ]\n    });\n  }\n}), require_hmac_drbg = __commonJS({\n  \"node_modules/hmac-drbg/lib/hmac-drbg.js\"(exports, module) {\n    var hash = require_hash2(), utils = require_utils2(), assert = require_minimalistic_assert();\n    function HmacDRBG(options) {\n      if (!(this instanceof HmacDRBG))\n        return new HmacDRBG(options);\n      this.hash = options.hash, this.predResist = !!options.predResist, this.outLen = this.hash.outSize, this.minEntropy = options.minEntropy || this.hash.hmacStrength, this._reseed = null, this.reseedInterval = null, this.K = null, this.V = null;\n      var entropy = utils.toArray(options.entropy, options.entropyEnc || \"hex\"), nonce = utils.toArray(options.nonce, options.nonceEnc || \"hex\"), pers = utils.toArray(options.pers, options.persEnc || \"hex\");\n      assert(entropy.length >= this.minEntropy / 8, \"Not enough entropy. Minimum is: \" + this.minEntropy + \" bits\"), this._init(entropy, nonce, pers);\n    }\n    HmacDRBG.prototype = {}, module.exports = HmacDRBG, HmacDRBG.prototype._init = function(entropy, nonce, pers) {\n      var seed = entropy.concat(nonce).concat(pers);\n      this.K = new Array(this.outLen / 8), this.V = new Array(this.outLen / 8);\n      for (var i = 0;i < this.V.length; i++)\n        this.K[i] = 0, this.V[i] = 1;\n      this._update(seed), this._reseed = 1, this.reseedInterval = 281474976710656;\n    }, HmacDRBG.prototype._hmac = function() {\n      return new hash.hmac(this.hash, this.K);\n    }, HmacDRBG.prototype._update = function(seed) {\n      var kmac = this._hmac().update(this.V).update([0]);\n      seed && (kmac = kmac.update(seed)), this.K = kmac.digest(), this.V = this._hmac().update(this.V).digest(), seed && (this.K = this._hmac().update(this.V).update([1]).update(seed).digest(), this.V = this._hmac().update(this.V).digest());\n    }, HmacDRBG.prototype.reseed = function(entropy, entropyEnc, add, addEnc) {\n      typeof entropyEnc != \"string\" && (addEnc = add, add = entropyEnc, entropyEnc = null), entropy = utils.toArray(entropy, entropyEnc), add = utils.toArray(add, addEnc), assert(entropy.length >= this.minEntropy / 8, \"Not enough entropy. Minimum is: \" + this.minEntropy + \" bits\"), this._update(entropy.concat(add || [])), this._reseed = 1;\n    }, HmacDRBG.prototype.generate = function(len, enc, add, addEnc) {\n      if (this._reseed > this.reseedInterval)\n        throw new Error(\"Reseed is required\");\n      typeof enc != \"string\" && (addEnc = add, add = enc, enc = null), add && (add = utils.toArray(add, addEnc || \"hex\"), this._update(add));\n      for (var temp = [];temp.length < len; )\n        this.V = this._hmac().update(this.V).digest(), temp = temp.concat(this.V);\n      var res = temp.slice(0, len);\n      return this._update(add), this._reseed++, utils.encode(res, enc);\n    };\n  }\n}), require_key = __commonJS({\n  \"node_modules/elliptic/lib/elliptic/ec/key.js\"(exports, module) {\n    var BN = require_bn4(), utils = require_utils3(), assert = utils.assert;\n    function KeyPair(ec, options) {\n      this.ec = ec, this.priv = null, this.pub = null, options.priv && this._importPrivate(options.priv, options.privEnc), options.pub && this._importPublic(options.pub, options.pubEnc);\n    }\n    KeyPair.prototype = {}, module.exports = KeyPair, KeyPair.fromPublic = function(ec, pub, enc) {\n      return pub instanceof KeyPair \? pub : new KeyPair(ec, {\n        pub,\n        pubEnc: enc\n      });\n    }, KeyPair.fromPrivate = function(ec, priv, enc) {\n      return priv instanceof KeyPair \? priv : new KeyPair(ec, {\n        priv,\n        privEnc: enc\n      });\n    }, KeyPair.prototype.validate = function() {\n      var pub = this.getPublic();\n      return pub.isInfinity() \? { result: !1, reason: \"Invalid public key\" } : pub.validate() \? pub.mul(this.ec.curve.n).isInfinity() \? { result: !0, reason: null } : { result: !1, reason: \"Public key * N != O\" } : { result: !1, reason: \"Public key is not a point\" };\n    }, KeyPair.prototype.getPublic = function(compact, enc) {\n      return typeof compact == \"string\" && (enc = compact, compact = null), this.pub || (this.pub = this.ec.g.mul(this.priv)), enc \? this.pub.encode(enc, compact) : this.pub;\n    }, KeyPair.prototype.getPrivate = function(enc) {\n      return enc === \"hex\" \? this.priv.toString(16, 2) : this.priv;\n    }, KeyPair.prototype._importPrivate = function(key, enc) {\n      this.priv = new BN(key, enc || 16), this.priv = this.priv.umod(this.ec.curve.n);\n    }, KeyPair.prototype._importPublic = function(key, enc) {\n      if (key.x || key.y) {\n        this.ec.curve.type === \"mont\" \? assert(key.x, \"Need x coordinate\") : (this.ec.curve.type === \"short\" || this.ec.curve.type === \"edwards\") && assert(key.x && key.y, \"Need both x and y coordinate\"), this.pub = this.ec.curve.point(key.x, key.y);\n        return;\n      }\n      this.pub = this.ec.curve.decodePoint(key, enc);\n    }, KeyPair.prototype.derive = function(pub) {\n      return pub.validate() || assert(pub.validate(), \"public point not validated\"), pub.mul(this.priv).getX();\n    }, KeyPair.prototype.sign = function(msg, enc, options) {\n      return this.ec.sign(msg, this, enc, options);\n    }, KeyPair.prototype.verify = function(msg, signature) {\n      return this.ec.verify(msg, signature, this);\n    }, KeyPair.prototype.inspect = function() {\n      return \"<Key priv: \" + (this.priv && this.priv.toString(16, 2)) + \" pub: \" + (this.pub && this.pub.inspect()) + \" >\";\n    };\n  }\n}), require_signature = __commonJS({\n  \"node_modules/elliptic/lib/elliptic/ec/signature.js\"(exports, module) {\n    var BN = require_bn4(), utils = require_utils3(), assert = utils.assert;\n    function Signature(options, enc) {\n      if (options instanceof Signature)\n        return options;\n      this._importDER(options, enc) || (assert(options.r && options.s, \"Signature without r or s\"), this.r = new BN(options.r, 16), this.s = new BN(options.s, 16), options.recoveryParam === void 0 \? this.recoveryParam = null : this.recoveryParam = options.recoveryParam);\n    }\n    Signature.prototype = {}, module.exports = Signature;\n    function Position() {\n      this.place = 0;\n    }\n    function getLength(buf, p) {\n      var initial = buf[p.place++];\n      if (!(initial & 128))\n        return initial;\n      var octetLen = initial & 15;\n      if (octetLen === 0 || octetLen > 4)\n        return !1;\n      for (var val = 0, i = 0, off = p.place;i < octetLen; i++, off++)\n        val <<= 8, val |= buf[off], val >>>= 0;\n      return val <= 127 \? !1 : (p.place = off, val);\n    }\n    function rmPadding(buf) {\n      for (var i = 0, len = buf.length - 1;!buf[i] && !(buf[i + 1] & 128) && i < len; )\n        i++;\n      return i === 0 \? buf : buf.slice(i);\n    }\n    Signature.prototype._importDER = function(data, enc) {\n      data = utils.toArray(data, enc);\n      var p = new Position;\n      if (data[p.place++] !== 48)\n        return !1;\n      var len = getLength(data, p);\n      if (len === !1 || len + p.place !== data.length || data[p.place++] !== 2)\n        return !1;\n      var rlen = getLength(data, p);\n      if (rlen === !1)\n        return !1;\n      var r = data.slice(p.place, rlen + p.place);\n      if (p.place += rlen, data[p.place++] !== 2)\n        return !1;\n      var slen = getLength(data, p);\n      if (slen === !1 || data.length !== slen + p.place)\n        return !1;\n      var s = data.slice(p.place, slen + p.place);\n      if (r[0] === 0)\n        if (r[1] & 128)\n          r = r.slice(1);\n        else\n          return !1;\n      if (s[0] === 0)\n        if (s[1] & 128)\n          s = s.slice(1);\n        else\n          return !1;\n      return this.r = new BN(r), this.s = new BN(s), this.recoveryParam = null, !0;\n    };\n    function constructLength(arr, len) {\n      if (len < 128) {\n        arr.push(len);\n        return;\n      }\n      var octets = 1 + (Math.log(len) / Math.LN2 >>> 3);\n      for (arr.push(octets | 128);--octets; )\n        arr.push(len >>> (octets << 3) & 255);\n      arr.push(len);\n    }\n    Signature.prototype.toDER = function(enc) {\n      var r = this.r.toArray(), s = this.s.toArray();\n      for (r[0] & 128 && (r = [0].concat(r)), s[0] & 128 && (s = [0].concat(s)), r = rmPadding(r), s = rmPadding(s);!s[0] && !(s[1] & 128); )\n        s = s.slice(1);\n      var arr = [2];\n      constructLength(arr, r.length), arr = arr.concat(r), arr.push(2), constructLength(arr, s.length);\n      var backHalf = arr.concat(s), res = [48];\n      return constructLength(res, backHalf.length), res = res.concat(backHalf), utils.encode(res, enc);\n    };\n  }\n}), require_ec = __commonJS({\n  \"node_modules/elliptic/lib/elliptic/ec/index.js\"(exports, module) {\n    var BN = require_bn4(), HmacDRBG = require_hmac_drbg(), utils = require_utils3(), curves = require_curves(), rand = require_brorand(), assert = utils.assert, KeyPair = require_key(), Signature = require_signature();\n    function EC(options) {\n      if (!(this instanceof EC))\n        return new EC(options);\n      typeof options == \"string\" && (assert(Object.prototype.hasOwnProperty.call(curves, options), \"Unknown curve \" + options), options = curves[options]), options instanceof curves.PresetCurve && (options = { curve: options }), this.curve = options.curve.curve, this.n = this.curve.n, this.nh = this.n.ushrn(1), this.g = this.curve.g, this.g = options.curve.g, this.g.precompute(options.curve.n.bitLength() + 1), this.hash = options.hash || options.curve.hash;\n    }\n    EC.prototype = {}, module.exports = EC, EC.prototype.keyPair = function(options) {\n      return new KeyPair(this, options);\n    }, EC.prototype.keyFromPrivate = function(priv, enc) {\n      return KeyPair.fromPrivate(this, priv, enc);\n    }, EC.prototype.keyFromPublic = function(pub, enc) {\n      return KeyPair.fromPublic(this, pub, enc);\n    }, EC.prototype.genKeyPair = function(options) {\n      options || (options = {});\n      for (var drbg = new HmacDRBG({\n        hash: this.hash,\n        pers: options.pers,\n        persEnc: options.persEnc || \"utf8\",\n        entropy: options.entropy || rand(this.hash.hmacStrength),\n        entropyEnc: options.entropy && options.entropyEnc || \"utf8\",\n        nonce: this.n.toArray()\n      }), bytes = this.n.byteLength(), ns2 = this.n.sub(new BN(2));; ) {\n        var priv = new BN(drbg.generate(bytes));\n        if (!(priv.cmp(ns2) > 0))\n          return priv.iaddn(1), this.keyFromPrivate(priv);\n      }\n    }, EC.prototype._truncateToN = function(msg, truncOnly) {\n      var delta = msg.byteLength() * 8 - this.n.bitLength();\n      return delta > 0 && (msg = msg.ushrn(delta)), !truncOnly && msg.cmp(this.n) >= 0 \? msg.sub(this.n) : msg;\n    }, EC.prototype.sign = function(msg, key, enc, options) {\n      typeof enc == \"object\" && (options = enc, enc = null), options || (options = {}), key = this.keyFromPrivate(key, enc), msg = this._truncateToN(new BN(msg, 16));\n      for (var bytes = this.n.byteLength(), bkey = key.getPrivate().toArray(\"be\", bytes), nonce = msg.toArray(\"be\", bytes), drbg = new HmacDRBG({\n        hash: this.hash,\n        entropy: bkey,\n        nonce,\n        pers: options.pers,\n        persEnc: options.persEnc || \"utf8\"\n      }), ns1 = this.n.sub(new BN(1)), iter = 0;; iter++) {\n        var k = options.k \? options.k(iter) : new BN(drbg.generate(this.n.byteLength()));\n        if (k = this._truncateToN(k, !0), !(k.cmpn(1) <= 0 || k.cmp(ns1) >= 0)) {\n          var kp = this.g.mul(k);\n          if (!kp.isInfinity()) {\n            var kpX = kp.getX(), r = kpX.umod(this.n);\n            if (r.cmpn(0) !== 0) {\n              var s = k.invm(this.n).mul(r.mul(key.getPrivate()).iadd(msg));\n              if (s = s.umod(this.n), s.cmpn(0) !== 0) {\n                var recoveryParam = (kp.getY().isOdd() \? 1 : 0) | (kpX.cmp(r) !== 0 \? 2 : 0);\n                return options.canonical && s.cmp(this.nh) > 0 && (s = this.n.sub(s), recoveryParam ^= 1), new Signature({ r, s, recoveryParam });\n              }\n            }\n          }\n        }\n      }\n    }, EC.prototype.verify = function(msg, signature, key, enc) {\n      msg = this._truncateToN(new BN(msg, 16)), key = this.keyFromPublic(key, enc), signature = new Signature(signature, \"hex\");\n      var { r, s } = signature;\n      if (r.cmpn(1) < 0 || r.cmp(this.n) >= 0 || s.cmpn(1) < 0 || s.cmp(this.n) >= 0)\n        return !1;\n      var sinv = s.invm(this.n), u1 = sinv.mul(msg).umod(this.n), u2 = sinv.mul(r).umod(this.n), p;\n      return this.curve._maxwellTrick \? (p = this.g.jmulAdd(u1, key.getPublic(), u2), p.isInfinity() \? !1 : p.eqXToP(r)) : (p = this.g.mulAdd(u1, key.getPublic(), u2), p.isInfinity() \? !1 : p.getX().umod(this.n).cmp(r) === 0);\n    }, EC.prototype.recoverPubKey = function(msg, signature, j, enc) {\n      assert((3 & j) === j, \"The recovery param is more than two bits\"), signature = new Signature(signature, enc);\n      var n = this.n, e = new BN(msg), r = signature.r, s = signature.s, isYOdd = j & 1, isSecondKey = j >> 1;\n      if (r.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey)\n        throw new Error(\"Unable to find sencond key candinate\");\n      isSecondKey \? r = this.curve.pointFromX(r.add(this.curve.n), isYOdd) : r = this.curve.pointFromX(r, isYOdd);\n      var rInv = signature.r.invm(n), s1 = n.sub(e).mul(rInv).umod(n), s2 = s.mul(rInv).umod(n);\n      return this.g.mulAdd(s1, r, s2);\n    }, EC.prototype.getKeyRecoveryParam = function(e, signature, Q, enc) {\n      if (signature = new Signature(signature, enc), signature.recoveryParam !== null)\n        return signature.recoveryParam;\n      for (var i = 0;i < 4; i++) {\n        var Qprime;\n        try {\n          Qprime = this.recoverPubKey(e, signature, i);\n        } catch {\n          continue;\n        }\n        if (Qprime.eq(Q))\n          return i;\n      }\n      throw new Error(\"Unable to find valid recovery factor\");\n    };\n  }\n}), require_key2 = __commonJS({\n  \"node_modules/elliptic/lib/elliptic/eddsa/key.js\"(exports, module) {\n    var utils = require_utils3(), assert = utils.assert, parseBytes = utils.parseBytes, cachedProperty = utils.cachedProperty;\n    function KeyPair(eddsa, params) {\n      this.eddsa = eddsa, this._secret = parseBytes(params.secret), eddsa.isPoint(params.pub) \? this._pub = params.pub : this._pubBytes = parseBytes(params.pub);\n    }\n    KeyPair.prototype = {}, KeyPair.fromPublic = function(eddsa, pub) {\n      return pub instanceof KeyPair \? pub : new KeyPair(eddsa, { pub });\n    }, KeyPair.fromSecret = function(eddsa, secret) {\n      return secret instanceof KeyPair \? secret : new KeyPair(eddsa, { secret });\n    }, KeyPair.prototype.secret = function() {\n      return this._secret;\n    }, cachedProperty(KeyPair, \"pubBytes\", function() {\n      return this.eddsa.encodePoint(this.pub());\n    }), cachedProperty(KeyPair, \"pub\", function() {\n      return this._pubBytes \? this.eddsa.decodePoint(this._pubBytes) : this.eddsa.g.mul(this.priv());\n    }), cachedProperty(KeyPair, \"privBytes\", function() {\n      var eddsa = this.eddsa, hash = this.hash(), lastIx = eddsa.encodingLength - 1, a = hash.slice(0, eddsa.encodingLength);\n      return a[0] &= 248, a[lastIx] &= 127, a[lastIx] |= 64, a;\n    }), cachedProperty(KeyPair, \"priv\", function() {\n      return this.eddsa.decodeInt(this.privBytes());\n    }), cachedProperty(KeyPair, \"hash\", function() {\n      return this.eddsa.hash().update(this.secret()).digest();\n    }), cachedProperty(KeyPair, \"messagePrefix\", function() {\n      return this.hash().slice(this.eddsa.encodingLength);\n    }), KeyPair.prototype.sign = function(message) {\n      return assert(this._secret, \"KeyPair can only verify\"), this.eddsa.sign(message, this);\n    }, KeyPair.prototype.verify = function(message, sig) {\n      return this.eddsa.verify(message, sig, this);\n    }, KeyPair.prototype.getSecret = function(enc) {\n      return assert(this._secret, \"KeyPair is public only\"), utils.encode(this.secret(), enc);\n    }, KeyPair.prototype.getPublic = function(enc) {\n      return utils.encode(this.pubBytes(), enc);\n    }, module.exports = KeyPair;\n  }\n}), require_signature2 = __commonJS({\n  \"node_modules/elliptic/lib/elliptic/eddsa/signature.js\"(exports, module) {\n    var BN = require_bn4(), utils = require_utils3(), assert = utils.assert, cachedProperty = utils.cachedProperty, parseBytes = utils.parseBytes;\n    function Signature(eddsa, sig) {\n      this.eddsa = eddsa, typeof sig != \"object\" && (sig = parseBytes(sig)), Array.isArray(sig) && (sig = {\n        R: sig.slice(0, eddsa.encodingLength),\n        S: sig.slice(eddsa.encodingLength)\n      }), assert(sig.R && sig.S, \"Signature without R or S\"), eddsa.isPoint(sig.R) && (this._R = sig.R), sig.S instanceof BN && (this._S = sig.S), this._Rencoded = Array.isArray(sig.R) \? sig.R : sig.Rencoded, this._Sencoded = Array.isArray(sig.S) \? sig.S : sig.Sencoded;\n    }\n    Signature.prototype = {}, cachedProperty(Signature, \"S\", function() {\n      return this.eddsa.decodeInt(this.Sencoded());\n    }), cachedProperty(Signature, \"R\", function() {\n      return this.eddsa.decodePoint(this.Rencoded());\n    }), cachedProperty(Signature, \"Rencoded\", function() {\n      return this.eddsa.encodePoint(this.R());\n    }), cachedProperty(Signature, \"Sencoded\", function() {\n      return this.eddsa.encodeInt(this.S());\n    }), Signature.prototype.toBytes = function() {\n      return this.Rencoded().concat(this.Sencoded());\n    }, Signature.prototype.toHex = function() {\n      return utils.encode(this.toBytes(), \"hex\").toUpperCase();\n    }, module.exports = Signature;\n  }\n}), require_eddsa = __commonJS({\n  \"node_modules/elliptic/lib/elliptic/eddsa/index.js\"(exports, module) {\n    var hash = require_hash2(), curves = require_curves(), utils = require_utils3(), assert = utils.assert, parseBytes = utils.parseBytes, KeyPair = require_key2(), Signature = require_signature2();\n    function EDDSA(curve) {\n      if (assert(curve === \"ed25519\", \"only tested with ed25519 so far\"), !(this instanceof EDDSA))\n        return new EDDSA(curve);\n      curve = curves[curve].curve, this.curve = curve, this.g = curve.g, this.g.precompute(curve.n.bitLength() + 1), this.pointClass = curve.point().constructor, this.encodingLength = Math.ceil(curve.n.bitLength() / 8), this.hash = hash.sha512;\n    }\n    EDDSA.prototype = {}, module.exports = EDDSA, EDDSA.prototype.sign = function(message, secret) {\n      message = parseBytes(message);\n      var key = this.keyFromSecret(secret), r = this.hashInt(key.messagePrefix(), message), R = this.g.mul(r), Rencoded = this.encodePoint(R), s_ = this.hashInt(Rencoded, key.pubBytes(), message).mul(key.priv()), S = r.add(s_).umod(this.curve.n);\n      return this.makeSignature({ R, S, Rencoded });\n    }, EDDSA.prototype.verify = function(message, sig, pub) {\n      message = parseBytes(message), sig = this.makeSignature(sig);\n      var key = this.keyFromPublic(pub), h = this.hashInt(sig.Rencoded(), key.pubBytes(), message), SG = this.g.mul(sig.S()), RplusAh = sig.R().add(key.pub().mul(h));\n      return RplusAh.eq(SG);\n    }, EDDSA.prototype.hashInt = function() {\n      for (var hash2 = this.hash(), i = 0;i < arguments.length; i++)\n        hash2.update(arguments[i]);\n      return utils.intFromLE(hash2.digest()).umod(this.curve.n);\n    }, EDDSA.prototype.keyFromPublic = function(pub) {\n      return KeyPair.fromPublic(this, pub);\n    }, EDDSA.prototype.keyFromSecret = function(secret) {\n      return KeyPair.fromSecret(this, secret);\n    }, EDDSA.prototype.makeSignature = function(sig) {\n      return sig instanceof Signature \? sig : new Signature(this, sig);\n    }, EDDSA.prototype.encodePoint = function(point) {\n      var enc = point.getY().toArray(\"le\", this.encodingLength);\n      return enc[this.encodingLength - 1] |= point.getX().isOdd() \? 128 : 0, enc;\n    }, EDDSA.prototype.decodePoint = function(bytes) {\n      bytes = utils.parseBytes(bytes);\n      var lastIx = bytes.length - 1, normed = bytes.slice(0, lastIx).concat(bytes[lastIx] & -129), xIsOdd = (bytes[lastIx] & 128) !== 0, y = utils.intFromLE(normed);\n      return this.curve.pointFromY(y, xIsOdd);\n    }, EDDSA.prototype.encodeInt = function(num) {\n      return num.toArray(\"le\", this.encodingLength);\n    }, EDDSA.prototype.decodeInt = function(bytes) {\n      return utils.intFromLE(bytes);\n    }, EDDSA.prototype.isPoint = function(val) {\n      return val instanceof this.pointClass;\n    };\n  }\n}), require_elliptic = __commonJS({\n  \"node_modules/elliptic/lib/elliptic.js\"(exports) {\n    var elliptic = exports;\n    elliptic.version = require_package().version, elliptic.utils = require_utils3(), elliptic.rand = require_brorand(), elliptic.curve = require_curve(), elliptic.curves = require_curves(), elliptic.ec = require_ec(), elliptic.eddsa = require_eddsa();\n  }\n}), require_bn5 = require_bn, require_safer = __commonJS({\n  \"node_modules/safer-buffer/safer.js\"(exports, module) {\n    var buffer = BufferModule, Buffer2 = Buffer, safer = {}, key;\n    for (key in buffer)\n      !buffer.hasOwnProperty(key) || key === \"SlowBuffer\" || key === \"Buffer\" || (safer[key] = buffer[key]);\n    var Safer = safer.Buffer = {};\n    for (key in Buffer2)\n      !Buffer2.hasOwnProperty(key) || key === \"allocUnsafe\" || key === \"allocUnsafeSlow\" || (Safer[key] = Buffer2[key]);\n    if (safer.Buffer.prototype = Buffer2.prototype, (!Safer.from || Safer.from === Uint8Array.from) && (Safer.from = function(value, encodingOrOffset, length) {\n      if (typeof value == \"number\")\n        @throwTypeError('The \"value\" argument must not be of type number. Received type ' + typeof value);\n      if (value && typeof value.length > \"u\")\n        @throwTypeError(\"The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type \" + typeof value);\n      return Buffer2(value, encodingOrOffset, length);\n    }), Safer.alloc || (Safer.alloc = function(size, fill, encoding) {\n      if (typeof size != \"number\")\n        @throwTypeError('The \"size\" argument must be of type number. Received type ' + typeof size);\n      if (size < 0 || size >= 2 * (1 << 30))\n        @throwRangeError('The value \"' + size + '\" is invalid for option \"size\"');\n      var buf = Buffer2(size);\n      return !fill || fill.length === 0 \? buf.fill(0) : typeof encoding == \"string\" \? buf.fill(fill, encoding) : buf.fill(fill), buf;\n    }), !safer.kStringMaxLength)\n      try {\n        safer.kStringMaxLength = MAX_STRING_LENGTH;\n      } catch {\n      }\n    safer.constants || (safer.constants = {\n      MAX_LENGTH: safer.kMaxLength\n    }, safer.kStringMaxLength && (safer.constants.MAX_STRING_LENGTH = safer.kStringMaxLength)), module.exports = safer;\n  }\n}), require_reporter = __commonJS({\n  \"node_modules/asn1.js/lib/asn1/base/reporter.js\"(exports) {\n    var inherits = require_inherits_browser();\n    function Reporter(options) {\n      this._reporterState = {\n        obj: null,\n        path: [],\n        options: options || {},\n        errors: []\n      };\n    }\n    Reporter.prototype = {}, exports.Reporter = Reporter, Reporter.prototype.isError = function(obj) {\n      return obj instanceof ReporterError;\n    }, Reporter.prototype.save = function() {\n      let state = this._reporterState;\n      return { obj: state.obj, pathLen: state.path.length };\n    }, Reporter.prototype.restore = function(data) {\n      let state = this._reporterState;\n      state.obj = data.obj, state.path = state.path.slice(0, data.pathLen);\n    }, Reporter.prototype.enterKey = function(key) {\n      return this._reporterState.path.push(key);\n    }, Reporter.prototype.exitKey = function(index) {\n      let state = this._reporterState;\n      state.path = state.path.slice(0, index - 1);\n    }, Reporter.prototype.leaveKey = function(index, key, value) {\n      let state = this._reporterState;\n      this.exitKey(index), state.obj !== null && (state.obj[key] = value);\n    }, Reporter.prototype.path = function() {\n      return this._reporterState.path.join(\"/\");\n    }, Reporter.prototype.enterObject = function() {\n      let state = this._reporterState, prev = state.obj;\n      return state.obj = {}, prev;\n    }, Reporter.prototype.leaveObject = function(prev) {\n      let state = this._reporterState, now = state.obj;\n      return state.obj = prev, now;\n    }, Reporter.prototype.error = function(msg) {\n      let err, state = this._reporterState, inherited = msg instanceof ReporterError;\n      if (inherited \? err = msg : err = new ReporterError(state.path.map(function(elem) {\n        return \"[\" + JSON.stringify(elem) + \"]\";\n      }).join(\"\"), msg.message || msg, msg.stack), !state.options.partial)\n        throw err;\n      return inherited || state.errors.push(err), err;\n    }, Reporter.prototype.wrapResult = function(result) {\n      let state = this._reporterState;\n      return state.options.partial \? {\n        result: this.isError(result) \? null : result,\n        errors: state.errors\n      } : result;\n    };\n    function ReporterError(path, msg) {\n      this.path = path, this.rethrow(msg);\n    }\n    inherits(ReporterError, Error), ReporterError.prototype.rethrow = function(msg) {\n      if (this.message = msg + \" at: \" + (this.path || \"(shallow)\"), Error.captureStackTrace && Error.captureStackTrace(this, ReporterError), !this.stack)\n        try {\n          throw new Error(this.message);\n        } catch (e) {\n          this.stack = e.stack;\n        }\n      return this;\n    };\n  }\n}), require_buffer = __commonJS({\n  \"node_modules/asn1.js/lib/asn1/base/buffer.js\"(exports) {\n    var inherits = require_inherits_browser(), Reporter = require_reporter().Reporter, Buffer2 = require_safer().Buffer;\n    function DecoderBuffer(base, options) {\n      if (Reporter.call(this, options), !Buffer2.isBuffer(base)) {\n        this.error(\"Input not Buffer\");\n        return;\n      }\n      this.base = base, this.offset = 0, this.length = base.length;\n    }\n    inherits(DecoderBuffer, Reporter), exports.DecoderBuffer = DecoderBuffer, DecoderBuffer.isDecoderBuffer = function(data) {\n      return data instanceof DecoderBuffer \? !0 : typeof data == \"object\" && Buffer2.isBuffer(data.base) && data.constructor.name === \"DecoderBuffer\" && typeof data.offset == \"number\" && typeof data.length == \"number\" && typeof data.save == \"function\" && typeof data.restore == \"function\" && typeof data.isEmpty == \"function\" && typeof data.readUInt8 == \"function\" && typeof data.skip == \"function\" && typeof data.raw == \"function\";\n    }, DecoderBuffer.prototype.save = function() {\n      return {\n        offset: this.offset,\n        reporter: Reporter.prototype.save.call(this)\n      };\n    }, DecoderBuffer.prototype.restore = function(save) {\n      let res = new DecoderBuffer(this.base);\n      return res.offset = save.offset, res.length = this.offset, this.offset = save.offset, Reporter.prototype.restore.call(this, save.reporter), res;\n    }, DecoderBuffer.prototype.isEmpty = function() {\n      return this.offset === this.length;\n    }, DecoderBuffer.prototype.readUInt8 = function(fail) {\n      return this.offset + 1 <= this.length \? this.base.readUInt8(this.offset++, !0) : this.error(fail || \"DecoderBuffer overrun\");\n    }, DecoderBuffer.prototype.skip = function(bytes, fail) {\n      if (!(this.offset + bytes <= this.length))\n        return this.error(fail || \"DecoderBuffer overrun\");\n      let res = new DecoderBuffer(this.base);\n      return res._reporterState = this._reporterState, res.offset = this.offset, res.length = this.offset + bytes, this.offset += bytes, res;\n    }, DecoderBuffer.prototype.raw = function(save) {\n      return this.base.slice(save \? save.offset : this.offset, this.length);\n    };\n    function EncoderBuffer(value, reporter) {\n      if (Array.isArray(value))\n        this.length = 0, this.value = value.map(function(item) {\n          return EncoderBuffer.isEncoderBuffer(item) || (item = new EncoderBuffer(item, reporter)), this.length += item.length, item;\n        }, this);\n      else if (typeof value == \"number\") {\n        if (!(0 <= value && value <= 255))\n          return reporter.error(\"non-byte EncoderBuffer value\");\n        this.value = value, this.length = 1;\n      } else if (typeof value == \"string\")\n        this.value = value, this.length = Buffer2.byteLength(value);\n      else if (Buffer2.isBuffer(value))\n        this.value = value, this.length = value.length;\n      else\n        return reporter.error(\"Unsupported type: \" + typeof value);\n    }\n    EncoderBuffer.prototype = {}, exports.EncoderBuffer = EncoderBuffer, EncoderBuffer.isEncoderBuffer = function(data) {\n      return data instanceof EncoderBuffer \? !0 : typeof data == \"object\" && data.constructor.name === \"EncoderBuffer\" && typeof data.length == \"number\" && typeof data.join == \"function\";\n    }, EncoderBuffer.prototype.join = function(out, offset) {\n      return out || (out = Buffer2.alloc(this.length)), offset || (offset = 0), this.length === 0 || (Array.isArray(this.value) \? this.value.forEach(function(item) {\n        item.join(out, offset), offset += item.length;\n      }) : (typeof this.value == \"number\" \? out[offset] = this.value : typeof this.value == \"string\" \? out.write(this.value, offset) : Buffer2.isBuffer(this.value) && this.value.copy(out, offset), offset += this.length)), out;\n    };\n  }\n}), require_node = __commonJS({\n  \"node_modules/asn1.js/lib/asn1/base/node.js\"(exports, module) {\n    var Reporter = require_reporter().Reporter, EncoderBuffer = require_buffer().EncoderBuffer, DecoderBuffer = require_buffer().DecoderBuffer, assert = require_minimalistic_assert(), tags = [\n      \"seq\",\n      \"seqof\",\n      \"set\",\n      \"setof\",\n      \"objid\",\n      \"bool\",\n      \"gentime\",\n      \"utctime\",\n      \"null_\",\n      \"enum\",\n      \"int\",\n      \"objDesc\",\n      \"bitstr\",\n      \"bmpstr\",\n      \"charstr\",\n      \"genstr\",\n      \"graphstr\",\n      \"ia5str\",\n      \"iso646str\",\n      \"numstr\",\n      \"octstr\",\n      \"printstr\",\n      \"t61str\",\n      \"unistr\",\n      \"utf8str\",\n      \"videostr\"\n    ], methods = [\"key\", \"obj\", \"use\", \"optional\", \"explicit\", \"implicit\", \"def\", \"choice\", \"any\", \"contains\"].concat(tags), overrided = [\n      \"_peekTag\",\n      \"_decodeTag\",\n      \"_use\",\n      \"_decodeStr\",\n      \"_decodeObjid\",\n      \"_decodeTime\",\n      \"_decodeNull\",\n      \"_decodeInt\",\n      \"_decodeBool\",\n      \"_decodeList\",\n      \"_encodeComposite\",\n      \"_encodeStr\",\n      \"_encodeObjid\",\n      \"_encodeTime\",\n      \"_encodeNull\",\n      \"_encodeInt\",\n      \"_encodeBool\"\n    ];\n    function Node(enc, parent, name) {\n      let state = {};\n      this._baseState = state, state.name = name, state.enc = enc, state.parent = parent || null, state.children = null, state.tag = null, state.args = null, state.reverseArgs = null, state.choice = null, state.optional = !1, state.any = !1, state.obj = !1, state.use = null, state.useDecoder = null, state.key = null, state.default = null, state.explicit = null, state.implicit = null, state.contains = null, state.parent || (state.children = [], this._wrap());\n    }\n    Node.prototype = {}, module.exports = Node;\n    var stateProps = [\n      \"enc\",\n      \"parent\",\n      \"children\",\n      \"tag\",\n      \"args\",\n      \"reverseArgs\",\n      \"choice\",\n      \"optional\",\n      \"any\",\n      \"obj\",\n      \"use\",\n      \"alteredUse\",\n      \"key\",\n      \"default\",\n      \"explicit\",\n      \"implicit\",\n      \"contains\"\n    ];\n    Node.prototype.clone = function() {\n      let state = this._baseState, cstate = {};\n      stateProps.forEach(function(prop) {\n        cstate[prop] = state[prop];\n      });\n      let res = new this.constructor(cstate.parent);\n      return res._baseState = cstate, res;\n    }, Node.prototype._wrap = function() {\n      let state = this._baseState;\n      methods.forEach(function(method) {\n        this[method] = function() {\n          let clone = new this.constructor(this);\n          return state.children.push(clone), clone[method].apply(clone, arguments);\n        };\n      }, this);\n    }, Node.prototype._init = function(body) {\n      let state = this._baseState;\n      assert(state.parent === null), body.call(this), state.children = state.children.filter(function(child) {\n        return child._baseState.parent === this;\n      }, this), assert.equal(state.children.length, 1, \"Root node can have only one child\");\n    }, Node.prototype._useArgs = function(args) {\n      let state = this._baseState, children = args.filter(function(arg) {\n        return arg instanceof this.constructor;\n      }, this);\n      args = args.filter(function(arg) {\n        return !(arg instanceof this.constructor);\n      }, this), children.length !== 0 && (assert(state.children === null), state.children = children, children.forEach(function(child) {\n        child._baseState.parent = this;\n      }, this)), args.length !== 0 && (assert(state.args === null), state.args = args, state.reverseArgs = args.map(function(arg) {\n        if (typeof arg != \"object\" || arg.constructor !== Object)\n          return arg;\n        let res = {};\n        return Object.keys(arg).forEach(function(key) {\n          key == (key | 0) && (key |= 0);\n          let value = arg[key];\n          res[value] = key;\n        }), res;\n      }));\n    }, overrided.forEach(function(method) {\n      Node.prototype[method] = function() {\n        let state = this._baseState;\n        throw new Error(method + \" not implemented for encoding: \" + state.enc);\n      };\n    }), tags.forEach(function(tag) {\n      Node.prototype[tag] = function() {\n        let state = this._baseState, args = Array.prototype.slice.call(arguments);\n        return assert(state.tag === null), state.tag = tag, this._useArgs(args), this;\n      };\n    }), Node.prototype.use = function(item) {\n      assert(item);\n      let state = this._baseState;\n      return assert(state.use === null), state.use = item, this;\n    }, Node.prototype.optional = function() {\n      let state = this._baseState;\n      return state.optional = !0, this;\n    }, Node.prototype.def = function(val) {\n      let state = this._baseState;\n      return assert(state.default === null), state.default = val, state.optional = !0, this;\n    }, Node.prototype.explicit = function(num) {\n      let state = this._baseState;\n      return assert(state.explicit === null && state.implicit === null), state.explicit = num, this;\n    }, Node.prototype.implicit = function(num) {\n      let state = this._baseState;\n      return assert(state.explicit === null && state.implicit === null), state.implicit = num, this;\n    }, Node.prototype.obj = function() {\n      let state = this._baseState, args = Array.prototype.slice.call(arguments);\n      return state.obj = !0, args.length !== 0 && this._useArgs(args), this;\n    }, Node.prototype.key = function(newKey) {\n      let state = this._baseState;\n      return assert(state.key === null), state.key = newKey, this;\n    }, Node.prototype.any = function() {\n      let state = this._baseState;\n      return state.any = !0, this;\n    }, Node.prototype.choice = function(obj) {\n      let state = this._baseState;\n      return assert(state.choice === null), state.choice = obj, this._useArgs(Object.keys(obj).map(function(key) {\n        return obj[key];\n      })), this;\n    }, Node.prototype.contains = function(item) {\n      let state = this._baseState;\n      return assert(state.use === null), state.contains = item, this;\n    }, Node.prototype._decode = function(input, options) {\n      let state = this._baseState;\n      if (state.parent === null)\n        return input.wrapResult(state.children[0]._decode(input, options));\n      let result = state.default, present = !0, prevKey = null;\n      if (state.key !== null && (prevKey = input.enterKey(state.key)), state.optional) {\n        let tag = null;\n        if (state.explicit !== null \? tag = state.explicit : state.implicit !== null \? tag = state.implicit : state.tag !== null && (tag = state.tag), tag === null && !state.any) {\n          let save = input.save();\n          try {\n            state.choice === null \? this._decodeGeneric(state.tag, input, options) : this._decodeChoice(input, options), present = !0;\n          } catch {\n            present = !1;\n          }\n          input.restore(save);\n        } else if (present = this._peekTag(input, tag, state.any), input.isError(present))\n          return present;\n      }\n      let prevObj;\n      if (state.obj && present && (prevObj = input.enterObject()), present) {\n        if (state.explicit !== null) {\n          let explicit = this._decodeTag(input, state.explicit);\n          if (input.isError(explicit))\n            return explicit;\n          input = explicit;\n        }\n        let start = input.offset;\n        if (state.use === null && state.choice === null) {\n          let save;\n          state.any && (save = input.save());\n          let body = this._decodeTag(input, state.implicit !== null \? state.implicit : state.tag, state.any);\n          if (input.isError(body))\n            return body;\n          state.any \? result = input.raw(save) : input = body;\n        }\n        if (options && options.track && state.tag !== null && options.track(input.path(), start, input.length, \"tagged\"), options && options.track && state.tag !== null && options.track(input.path(), input.offset, input.length, \"content\"), state.any || (state.choice === null \? result = this._decodeGeneric(state.tag, input, options) : result = this._decodeChoice(input, options)), input.isError(result))\n          return result;\n        if (!state.any && state.choice === null && state.children !== null && state.children.forEach(function(child) {\n          child._decode(input, options);\n        }), state.contains && (state.tag === \"octstr\" || state.tag === \"bitstr\")) {\n          let data = new DecoderBuffer(result);\n          result = this._getUse(state.contains, input._reporterState.obj)._decode(data, options);\n        }\n      }\n      return state.obj && present && (result = input.leaveObject(prevObj)), state.key !== null && (result !== null || present === !0) \? input.leaveKey(prevKey, state.key, result) : prevKey !== null && input.exitKey(prevKey), result;\n    }, Node.prototype._decodeGeneric = function(tag, input, options) {\n      let state = this._baseState;\n      return tag === \"seq\" || tag === \"set\" \? null : tag === \"seqof\" || tag === \"setof\" \? this._decodeList(input, tag, state.args[0], options) : /str$/.test(tag) \? this._decodeStr(input, tag, options) : tag === \"objid\" && state.args \? this._decodeObjid(input, state.args[0], state.args[1], options) : tag === \"objid\" \? this._decodeObjid(input, null, null, options) : tag === \"gentime\" || tag === \"utctime\" \? this._decodeTime(input, tag, options) : tag === \"null_\" \? this._decodeNull(input, options) : tag === \"bool\" \? this._decodeBool(input, options) : tag === \"objDesc\" \? this._decodeStr(input, tag, options) : tag === \"int\" || tag === \"enum\" \? this._decodeInt(input, state.args && state.args[0], options) : state.use !== null \? this._getUse(state.use, input._reporterState.obj)._decode(input, options) : input.error(\"unknown tag: \" + tag);\n    }, Node.prototype._getUse = function(entity, obj) {\n      let state = this._baseState;\n      return state.useDecoder = this._use(entity, obj), assert(state.useDecoder._baseState.parent === null), state.useDecoder = state.useDecoder._baseState.children[0], state.implicit !== state.useDecoder._baseState.implicit && (state.useDecoder = state.useDecoder.clone(), state.useDecoder._baseState.implicit = state.implicit), state.useDecoder;\n    }, Node.prototype._decodeChoice = function(input, options) {\n      let state = this._baseState, result = null, match = !1;\n      return Object.keys(state.choice).some(function(key) {\n        let save = input.save(), node = state.choice[key];\n        try {\n          let value = node._decode(input, options);\n          if (input.isError(value))\n            return !1;\n          result = { type: key, value }, match = !0;\n        } catch {\n          return input.restore(save), !1;\n        }\n        return !0;\n      }, this), match \? result : input.error(\"Choice not matched\");\n    }, Node.prototype._createEncoderBuffer = function(data) {\n      return new EncoderBuffer(data, this.reporter);\n    }, Node.prototype._encode = function(data, reporter, parent) {\n      let state = this._baseState;\n      if (state.default !== null && state.default === data)\n        return;\n      let result = this._encodeValue(data, reporter, parent);\n      if (result !== void 0 && !this._skipDefault(result, reporter, parent))\n        return result;\n    }, Node.prototype._encodeValue = function(data, reporter, parent) {\n      let state = this._baseState;\n      if (state.parent === null)\n        return state.children[0]._encode(data, reporter || new Reporter);\n      let result = null;\n      if (this.reporter = reporter, state.optional && data === void 0)\n        if (state.default !== null)\n          data = state.default;\n        else\n          return;\n      let content = null, primitive = !1;\n      if (state.any)\n        result = this._createEncoderBuffer(data);\n      else if (state.choice)\n        result = this._encodeChoice(data, reporter);\n      else if (state.contains)\n        content = this._getUse(state.contains, parent)._encode(data, reporter), primitive = !0;\n      else if (state.children)\n        content = state.children.map(function(child) {\n          if (child._baseState.tag === \"null_\")\n            return child._encode(null, reporter, data);\n          if (child._baseState.key === null)\n            return reporter.error(\"Child should have a key\");\n          let prevKey = reporter.enterKey(child._baseState.key);\n          if (typeof data != \"object\")\n            return reporter.error(\"Child expected, but input is not object\");\n          let res = child._encode(data[child._baseState.key], reporter, data);\n          return reporter.leaveKey(prevKey), res;\n        }, this).filter(function(child) {\n          return child;\n        }), content = this._createEncoderBuffer(content);\n      else if (state.tag === \"seqof\" || state.tag === \"setof\") {\n        if (!(state.args && state.args.length === 1))\n          return reporter.error(\"Too many args for : \" + state.tag);\n        if (!Array.isArray(data))\n          return reporter.error(\"seqof/setof, but data is not Array\");\n        let child = this.clone();\n        child._baseState.implicit = null, content = this._createEncoderBuffer(data.map(function(item) {\n          let state2 = this._baseState;\n          return this._getUse(state2.args[0], data)._encode(item, reporter);\n        }, child));\n      } else\n        state.use !== null \? result = this._getUse(state.use, parent)._encode(data, reporter) : (content = this._encodePrimitive(state.tag, data), primitive = !0);\n      if (!state.any && state.choice === null) {\n        let tag = state.implicit !== null \? state.implicit : state.tag, cls = state.implicit === null \? \"universal\" : \"context\";\n        tag === null \? state.use === null && reporter.error(\"Tag could be omitted only for .use()\") : state.use === null && (result = this._encodeComposite(tag, primitive, cls, content));\n      }\n      return state.explicit !== null && (result = this._encodeComposite(state.explicit, !1, \"context\", result)), result;\n    }, Node.prototype._encodeChoice = function(data, reporter) {\n      let state = this._baseState, node = state.choice[data.type];\n      return node || assert(!1, data.type + \" not found in \" + JSON.stringify(Object.keys(state.choice))), node._encode(data.value, reporter);\n    }, Node.prototype._encodePrimitive = function(tag, data) {\n      let state = this._baseState;\n      if (/str$/.test(tag))\n        return this._encodeStr(data, tag);\n      if (tag === \"objid\" && state.args)\n        return this._encodeObjid(data, state.reverseArgs[0], state.args[1]);\n      if (tag === \"objid\")\n        return this._encodeObjid(data, null, null);\n      if (tag === \"gentime\" || tag === \"utctime\")\n        return this._encodeTime(data, tag);\n      if (tag === \"null_\")\n        return this._encodeNull();\n      if (tag === \"int\" || tag === \"enum\")\n        return this._encodeInt(data, state.args && state.reverseArgs[0]);\n      if (tag === \"bool\")\n        return this._encodeBool(data);\n      if (tag === \"objDesc\")\n        return this._encodeStr(data, tag);\n      throw new Error(\"Unsupported tag: \" + tag);\n    }, Node.prototype._isNumstr = function(str) {\n      return /^[0-9 ]*$/.test(str);\n    }, Node.prototype._isPrintstr = function(str) {\n      return /^[A-Za-z0-9 '()+,-./:=\?]*$/.test(str);\n    };\n  }\n}), require_der = __commonJS({\n  \"node_modules/asn1.js/lib/asn1/constants/der.js\"(exports) {\n    function reverse(map) {\n      let res = {};\n      return Object.keys(map).forEach(function(key) {\n        (key | 0) == key && (key = key | 0);\n        let value = map[key];\n        res[value] = key;\n      }), res;\n    }\n    exports.tagClass = {\n      0: \"universal\",\n      1: \"application\",\n      2: \"context\",\n      3: \"private\"\n    }, exports.tagClassByName = reverse(exports.tagClass), exports.tag = {\n      0: \"end\",\n      1: \"bool\",\n      2: \"int\",\n      3: \"bitstr\",\n      4: \"octstr\",\n      5: \"null_\",\n      6: \"objid\",\n      7: \"objDesc\",\n      8: \"external\",\n      9: \"real\",\n      10: \"enum\",\n      11: \"embed\",\n      12: \"utf8str\",\n      13: \"relativeOid\",\n      16: \"seq\",\n      17: \"set\",\n      18: \"numstr\",\n      19: \"printstr\",\n      20: \"t61str\",\n      21: \"videostr\",\n      22: \"ia5str\",\n      23: \"utctime\",\n      24: \"gentime\",\n      25: \"graphstr\",\n      26: \"iso646str\",\n      27: \"genstr\",\n      28: \"unistr\",\n      29: \"charstr\",\n      30: \"bmpstr\"\n    }, exports.tagByName = reverse(exports.tag);\n  }\n}), require_der2 = __commonJS({\n  \"node_modules/asn1.js/lib/asn1/encoders/der.js\"(exports, module) {\n    var inherits = require_inherits_browser(), Buffer2 = require_safer().Buffer, Node = require_node(), der = require_der();\n    function DEREncoder(entity) {\n      this.enc = \"der\", this.name = entity.name, this.entity = entity, this.tree = new DERNode, this.tree._init(entity.body);\n    }\n    DEREncoder.prototype = {}, module.exports = DEREncoder, DEREncoder.prototype.encode = function(data, reporter) {\n      return this.tree._encode(data, reporter).join();\n    };\n    function DERNode(parent) {\n      Node.call(this, \"der\", parent);\n    }\n    inherits(DERNode, Node), DERNode.prototype._encodeComposite = function(tag, primitive, cls, content) {\n      let encodedTag = encodeTag(tag, primitive, cls, this.reporter);\n      if (content.length < 128) {\n        let header2 = Buffer2.alloc(2);\n        return header2[0] = encodedTag, header2[1] = content.length, this._createEncoderBuffer([header2, content]);\n      }\n      let lenOctets = 1;\n      for (let i = content.length;i >= 256; i >>= 8)\n        lenOctets++;\n      let header = Buffer2.alloc(2 + lenOctets);\n      header[0] = encodedTag, header[1] = 128 | lenOctets;\n      for (let i = 1 + lenOctets, j = content.length;j > 0; i--, j >>= 8)\n        header[i] = j & 255;\n      return this._createEncoderBuffer([header, content]);\n    }, DERNode.prototype._encodeStr = function(str, tag) {\n      if (tag === \"bitstr\")\n        return this._createEncoderBuffer([str.unused | 0, str.data]);\n      if (tag === \"bmpstr\") {\n        let buf = Buffer2.alloc(str.length * 2);\n        for (let i = 0;i < str.length; i++)\n          buf.writeUInt16BE(str.charCodeAt(i), i * 2);\n        return this._createEncoderBuffer(buf);\n      } else\n        return tag === \"numstr\" \? this._isNumstr(str) \? this._createEncoderBuffer(str) : this.reporter.error(\"Encoding of string type: numstr supports only digits and space\") : tag === \"printstr\" \? this._isPrintstr(str) \? this._createEncoderBuffer(str) : this.reporter.error(\"Encoding of string type: printstr supports only latin upper and lower case letters, digits, space, apostrophe, left and rigth parenthesis, plus sign, comma, hyphen, dot, slash, colon, equal sign, question mark\") : /str$/.test(tag) \? this._createEncoderBuffer(str) : tag === \"objDesc\" \? this._createEncoderBuffer(str) : this.reporter.error(\"Encoding of string type: \" + tag + \" unsupported\");\n    }, DERNode.prototype._encodeObjid = function(id, values, relative) {\n      if (typeof id == \"string\") {\n        if (!values)\n          return this.reporter.error(\"string objid given, but no values map found\");\n        if (!values.hasOwnProperty(id))\n          return this.reporter.error(\"objid not found in values map\");\n        id = values[id].split(/[\\s.]+/g);\n        for (let i = 0;i < id.length; i++)\n          id[i] |= 0;\n      } else if (Array.isArray(id)) {\n        id = id.slice();\n        for (let i = 0;i < id.length; i++)\n          id[i] |= 0;\n      }\n      if (!Array.isArray(id))\n        return this.reporter.error(\"objid() should be either array or string, got: \" + JSON.stringify(id));\n      if (!relative) {\n        if (id[1] >= 40)\n          return this.reporter.error(\"Second objid identifier OOB\");\n        id.splice(0, 2, id[0] * 40 + id[1]);\n      }\n      let size = 0;\n      for (let i = 0;i < id.length; i++) {\n        let ident = id[i];\n        for (size++;ident >= 128; ident >>= 7)\n          size++;\n      }\n      let objid = Buffer2.alloc(size), offset = objid.length - 1;\n      for (let i = id.length - 1;i >= 0; i--) {\n        let ident = id[i];\n        for (objid[offset--] = ident & 127;(ident >>= 7) > 0; )\n          objid[offset--] = 128 | ident & 127;\n      }\n      return this._createEncoderBuffer(objid);\n    };\n    function two(num) {\n      return num < 10 \? \"0\" + num : num;\n    }\n    DERNode.prototype._encodeTime = function(time, tag) {\n      let str, date = new Date(time);\n      return tag === \"gentime\" \? str = [\n        two(date.getUTCFullYear()),\n        two(date.getUTCMonth() + 1),\n        two(date.getUTCDate()),\n        two(date.getUTCHours()),\n        two(date.getUTCMinutes()),\n        two(date.getUTCSeconds()),\n        \"Z\"\n      ].join(\"\") : tag === \"utctime\" \? str = [\n        two(date.getUTCFullYear() % 100),\n        two(date.getUTCMonth() + 1),\n        two(date.getUTCDate()),\n        two(date.getUTCHours()),\n        two(date.getUTCMinutes()),\n        two(date.getUTCSeconds()),\n        \"Z\"\n      ].join(\"\") : this.reporter.error(\"Encoding \" + tag + \" time is not supported yet\"), this._encodeStr(str, \"octstr\");\n    }, DERNode.prototype._encodeNull = function() {\n      return this._createEncoderBuffer(\"\");\n    }, DERNode.prototype._encodeInt = function(num, values) {\n      if (typeof num == \"string\") {\n        if (!values)\n          return this.reporter.error(\"String int or enum given, but no values map\");\n        if (!values.hasOwnProperty(num))\n          return this.reporter.error(\"Values map doesn't contain: \" + JSON.stringify(num));\n        num = values[num];\n      }\n      if (typeof num != \"number\" && !Buffer2.isBuffer(num)) {\n        let numArray = num.toArray();\n        !num.sign && numArray[0] & 128 && numArray.unshift(0), num = Buffer2.from(numArray);\n      }\n      if (Buffer2.isBuffer(num)) {\n        let size2 = num.length;\n        num.length === 0 && size2++;\n        let out2 = Buffer2.alloc(size2);\n        return num.copy(out2), num.length === 0 && (out2[0] = 0), this._createEncoderBuffer(out2);\n      }\n      if (num < 128)\n        return this._createEncoderBuffer(num);\n      if (num < 256)\n        return this._createEncoderBuffer([0, num]);\n      let size = 1;\n      for (let i = num;i >= 256; i >>= 8)\n        size++;\n      let out = new Array(size);\n      for (let i = out.length - 1;i >= 0; i--)\n        out[i] = num & 255, num >>= 8;\n      return out[0] & 128 && out.unshift(0), this._createEncoderBuffer(Buffer2.from(out));\n    }, DERNode.prototype._encodeBool = function(value) {\n      return this._createEncoderBuffer(value \? 255 : 0);\n    }, DERNode.prototype._use = function(entity, obj) {\n      return typeof entity == \"function\" && (entity = entity(obj)), entity._getEncoder(\"der\").tree;\n    }, DERNode.prototype._skipDefault = function(dataBuffer, reporter, parent) {\n      let state = this._baseState, i;\n      if (state.default === null)\n        return !1;\n      let data = dataBuffer.join();\n      if (state.defaultBuffer === void 0 && (state.defaultBuffer = this._encodeValue(state.default, reporter, parent).join()), data.length !== state.defaultBuffer.length)\n        return !1;\n      for (i = 0;i < data.length; i++)\n        if (data[i] !== state.defaultBuffer[i])\n          return !1;\n      return !0;\n    };\n    function encodeTag(tag, primitive, cls, reporter) {\n      let res;\n      if (tag === \"seqof\" \? tag = \"seq\" : tag === \"setof\" && (tag = \"set\"), der.tagByName.hasOwnProperty(tag))\n        res = der.tagByName[tag];\n      else if (typeof tag == \"number\" && (tag | 0) === tag)\n        res = tag;\n      else\n        return reporter.error(\"Unknown tag: \" + tag);\n      return res >= 31 \? reporter.error(\"Multi-octet tag encoding unsupported\") : (primitive || (res |= 32), res |= der.tagClassByName[cls || \"universal\"] << 6, res);\n    }\n  }\n}), require_pem = __commonJS({\n  \"node_modules/asn1.js/lib/asn1/encoders/pem.js\"(exports, module) {\n    var inherits = require_inherits_browser(), DEREncoder = require_der2();\n    function PEMEncoder(entity) {\n      DEREncoder.call(this, entity), this.enc = \"pem\";\n    }\n    inherits(PEMEncoder, DEREncoder), module.exports = PEMEncoder, PEMEncoder.prototype.encode = function(data, options) {\n      let p = DEREncoder.prototype.encode.call(this, data).toString(\"base64\"), out = [\"-----BEGIN \" + options.label + \"-----\"];\n      for (let i = 0;i < p.length; i += 64)\n        out.push(p.slice(i, i + 64));\n      return out.push(\"-----END \" + options.label + \"-----\"), out.join(`\n`);\n    };\n  }\n}), require_encoders = __commonJS({\n  \"node_modules/asn1.js/lib/asn1/encoders/index.js\"(exports) {\n    var encoders = exports;\n    encoders.der = require_der2(), encoders.pem = require_pem();\n  }\n}), require_der3 = __commonJS({\n  \"node_modules/asn1.js/lib/asn1/decoders/der.js\"(exports, module) {\n    var inherits = require_inherits_browser(), bignum = require_bn5(), DecoderBuffer = require_buffer().DecoderBuffer, Node = require_node(), der = require_der();\n    function DERDecoder(entity) {\n      this.enc = \"der\", this.name = entity.name, this.entity = entity, this.tree = new DERNode, this.tree._init(entity.body);\n    }\n    DERDecoder.prototype = {}, module.exports = DERDecoder, DERDecoder.prototype.decode = function(data, options) {\n      return DecoderBuffer.isDecoderBuffer(data) || (data = new DecoderBuffer(data, options)), this.tree._decode(data, options);\n    };\n    function DERNode(parent) {\n      Node.call(this, \"der\", parent);\n    }\n    inherits(DERNode, Node), DERNode.prototype._peekTag = function(buffer, tag, any) {\n      if (buffer.isEmpty())\n        return !1;\n      let state = buffer.save(), decodedTag = derDecodeTag(buffer, 'Failed to peek tag: \"' + tag + '\"');\n      return buffer.isError(decodedTag) \? decodedTag : (buffer.restore(state), decodedTag.tag === tag || decodedTag.tagStr === tag || decodedTag.tagStr + \"of\" === tag || any);\n    }, DERNode.prototype._decodeTag = function(buffer, tag, any) {\n      let decodedTag = derDecodeTag(buffer, 'Failed to decode tag of \"' + tag + '\"');\n      if (buffer.isError(decodedTag))\n        return decodedTag;\n      let len = derDecodeLen(buffer, decodedTag.primitive, 'Failed to get length of \"' + tag + '\"');\n      if (buffer.isError(len))\n        return len;\n      if (!any && decodedTag.tag !== tag && decodedTag.tagStr !== tag && decodedTag.tagStr + \"of\" !== tag)\n        return buffer.error('Failed to match tag: \"' + tag + '\"');\n      if (decodedTag.primitive || len !== null)\n        return buffer.skip(len, 'Failed to match body of: \"' + tag + '\"');\n      let state = buffer.save(), res = this._skipUntilEnd(buffer, 'Failed to skip indefinite length body: \"' + this.tag + '\"');\n      return buffer.isError(res) \? res : (len = buffer.offset - state.offset, buffer.restore(state), buffer.skip(len, 'Failed to match body of: \"' + tag + '\"'));\n    }, DERNode.prototype._skipUntilEnd = function(buffer, fail) {\n      for (;; ) {\n        let tag = derDecodeTag(buffer, fail);\n        if (buffer.isError(tag))\n          return tag;\n        let len = derDecodeLen(buffer, tag.primitive, fail);\n        if (buffer.isError(len))\n          return len;\n        let res;\n        if (tag.primitive || len !== null \? res = buffer.skip(len) : res = this._skipUntilEnd(buffer, fail), buffer.isError(res))\n          return res;\n        if (tag.tagStr === \"end\")\n          break;\n      }\n    }, DERNode.prototype._decodeList = function(buffer, tag, decoder, options) {\n      let result = [];\n      for (;!buffer.isEmpty(); ) {\n        let possibleEnd = this._peekTag(buffer, \"end\");\n        if (buffer.isError(possibleEnd))\n          return possibleEnd;\n        let res = decoder.decode(buffer, \"der\", options);\n        if (buffer.isError(res) && possibleEnd)\n          break;\n        result.push(res);\n      }\n      return result;\n    }, DERNode.prototype._decodeStr = function(buffer, tag) {\n      if (tag === \"bitstr\") {\n        let unused = buffer.readUInt8();\n        return buffer.isError(unused) \? unused : { unused, data: buffer.raw() };\n      } else if (tag === \"bmpstr\") {\n        let raw = buffer.raw();\n        if (raw.length % 2 === 1)\n          return buffer.error(\"Decoding of string type: bmpstr length mismatch\");\n        let str = \"\";\n        for (let i = 0;i < raw.length / 2; i++)\n          str += String.fromCharCode(raw.readUInt16BE(i * 2));\n        return str;\n      } else if (tag === \"numstr\") {\n        let numstr = buffer.raw().toString(\"ascii\");\n        return this._isNumstr(numstr) \? numstr : buffer.error(\"Decoding of string type: numstr unsupported characters\");\n      } else {\n        if (tag === \"octstr\")\n          return buffer.raw();\n        if (tag === \"objDesc\")\n          return buffer.raw();\n        if (tag === \"printstr\") {\n          let printstr = buffer.raw().toString(\"ascii\");\n          return this._isPrintstr(printstr) \? printstr : buffer.error(\"Decoding of string type: printstr unsupported characters\");\n        } else\n          return /str$/.test(tag) \? buffer.raw().toString() : buffer.error(\"Decoding of string type: \" + tag + \" unsupported\");\n      }\n    }, DERNode.prototype._decodeObjid = function(buffer, values, relative) {\n      let result, identifiers = [], ident = 0, subident = 0;\n      for (;!buffer.isEmpty(); )\n        subident = buffer.readUInt8(), ident <<= 7, ident |= subident & 127, (subident & 128) === 0 && (identifiers.push(ident), ident = 0);\n      subident & 128 && identifiers.push(ident);\n      let first = identifiers[0] / 40 | 0, second = identifiers[0] % 40;\n      if (relative \? result = identifiers : result = [first, second].concat(identifiers.slice(1)), values) {\n        let tmp = values[result.join(\" \")];\n        tmp === void 0 && (tmp = values[result.join(\".\")]), tmp !== void 0 && (result = tmp);\n      }\n      return result;\n    }, DERNode.prototype._decodeTime = function(buffer, tag) {\n      let str = buffer.raw().toString(), year, mon, day, hour, min, sec;\n      if (tag === \"gentime\")\n        year = str.slice(0, 4) | 0, mon = str.slice(4, 6) | 0, day = str.slice(6, 8) | 0, hour = str.slice(8, 10) | 0, min = str.slice(10, 12) | 0, sec = str.slice(12, 14) | 0;\n      else if (tag === \"utctime\")\n        year = str.slice(0, 2) | 0, mon = str.slice(2, 4) | 0, day = str.slice(4, 6) | 0, hour = str.slice(6, 8) | 0, min = str.slice(8, 10) | 0, sec = str.slice(10, 12) | 0, year < 70 \? year = 2000 + year : year = 1900 + year;\n      else\n        return buffer.error(\"Decoding \" + tag + \" time is not supported yet\");\n      return Date.UTC(year, mon - 1, day, hour, min, sec, 0);\n    }, DERNode.prototype._decodeNull = function() {\n      return null;\n    }, DERNode.prototype._decodeBool = function(buffer) {\n      let res = buffer.readUInt8();\n      return buffer.isError(res) \? res : res !== 0;\n    }, DERNode.prototype._decodeInt = function(buffer, values) {\n      let raw = buffer.raw(), res = new bignum(raw);\n      return values && (res = values[res.toString(10)] || res), res;\n    }, DERNode.prototype._use = function(entity, obj) {\n      return typeof entity == \"function\" && (entity = entity(obj)), entity._getDecoder(\"der\").tree;\n    };\n    function derDecodeTag(buf, fail) {\n      let tag = buf.readUInt8(fail);\n      if (buf.isError(tag))\n        return tag;\n      let cls = der.tagClass[tag >> 6], primitive = (tag & 32) === 0;\n      if ((tag & 31) === 31) {\n        let oct = tag;\n        for (tag = 0;(oct & 128) === 128; ) {\n          if (oct = buf.readUInt8(fail), buf.isError(oct))\n            return oct;\n          tag <<= 7, tag |= oct & 127;\n        }\n      } else\n        tag &= 31;\n      let tagStr = der.tag[tag];\n      return {\n        cls,\n        primitive,\n        tag,\n        tagStr\n      };\n    }\n    function derDecodeLen(buf, primitive, fail) {\n      let len = buf.readUInt8(fail);\n      if (buf.isError(len))\n        return len;\n      if (!primitive && len === 128)\n        return null;\n      if ((len & 128) === 0)\n        return len;\n      let num = len & 127;\n      if (num > 4)\n        return buf.error(\"length octect is too long\");\n      len = 0;\n      for (let i = 0;i < num; i++) {\n        len <<= 8;\n        let j = buf.readUInt8(fail);\n        if (buf.isError(j))\n          return j;\n        len |= j;\n      }\n      return len;\n    }\n  }\n}), require_pem2 = __commonJS({\n  \"node_modules/asn1.js/lib/asn1/decoders/pem.js\"(exports, module) {\n    var inherits = require_inherits_browser(), Buffer2 = require_safer().Buffer, DERDecoder = require_der3();\n    function PEMDecoder(entity) {\n      DERDecoder.call(this, entity), this.enc = \"pem\";\n    }\n    inherits(PEMDecoder, DERDecoder), module.exports = PEMDecoder, PEMDecoder.prototype.decode = function(data, options) {\n      let lines = data.toString().split(/[\\r\\n]+/g), label = options.label.toUpperCase(), re = /^-----(BEGIN|END) ([^-]+)-----$/, start = -1, end = -1;\n      for (let i = 0;i < lines.length; i++) {\n        let match = lines[i].match(re);\n        if (match !== null && match[2] === label)\n          if (start === -1) {\n            if (match[1] !== \"BEGIN\")\n              break;\n            start = i;\n          } else {\n            if (match[1] !== \"END\")\n              break;\n            end = i;\n            break;\n          }\n      }\n      if (start === -1 || end === -1)\n        throw new Error(\"PEM section not found for: \" + label);\n      let base64 = lines.slice(start + 1, end).join(\"\");\n      base64.replace(/[^a-z0-9+/=]+/gi, \"\");\n      let input = Buffer2.from(base64, \"base64\");\n      return DERDecoder.prototype.decode.call(this, input, options);\n    };\n  }\n}), require_decoders = __commonJS({\n  \"node_modules/asn1.js/lib/asn1/decoders/index.js\"(exports) {\n    var decoders = exports;\n    decoders.der = require_der3(), decoders.pem = require_pem2();\n  }\n}), require_api = __commonJS({\n  \"node_modules/asn1.js/lib/asn1/api.js\"(exports) {\n    var encoders = require_encoders(), decoders = require_decoders(), inherits = require_inherits_browser(), api = exports;\n    api.define = function(name, body) {\n      return new Entity(name, body);\n    };\n    function Entity(name, body) {\n      this.name = name, this.body = body, this.decoders = {}, this.encoders = {};\n    }\n    Entity.prototype = {}, Entity.prototype._createNamed = function(Base) {\n      let name = this.name;\n      function Generated(entity) {\n        this._initNamed(entity, name);\n      }\n      return inherits(Generated, Base), Generated.prototype._initNamed = function(entity, name2) {\n        Base.call(this, entity, name2);\n      }, new Generated(this);\n    }, Entity.prototype._getDecoder = function(enc) {\n      return enc = enc || \"der\", this.decoders.hasOwnProperty(enc) || (this.decoders[enc] = this._createNamed(decoders[enc])), this.decoders[enc];\n    }, Entity.prototype.decode = function(data, enc, options) {\n      return this._getDecoder(enc).decode(data, options);\n    }, Entity.prototype._getEncoder = function(enc) {\n      return enc = enc || \"der\", this.encoders.hasOwnProperty(enc) || (this.encoders[enc] = this._createNamed(encoders[enc])), this.encoders[enc];\n    }, Entity.prototype.encode = function(data, enc, reporter) {\n      return this._getEncoder(enc).encode(data, reporter);\n    };\n  }\n}), require_base2 = __commonJS({\n  \"node_modules/asn1.js/lib/asn1/base/index.js\"(exports) {\n    var base = exports;\n    base.Reporter = require_reporter().Reporter, base.DecoderBuffer = require_buffer().DecoderBuffer, base.EncoderBuffer = require_buffer().EncoderBuffer, base.Node = require_node();\n  }\n}), require_constants = __commonJS({\n  \"node_modules/asn1.js/lib/asn1/constants/index.js\"(exports) {\n    var constants = exports;\n    constants._reverse = function(map) {\n      let res = {};\n      return Object.keys(map).forEach(function(key) {\n        (key | 0) == key && (key = key | 0);\n        let value = map[key];\n        res[value] = key;\n      }), res;\n    }, constants.der = require_der();\n  }\n}), require_asn1 = __commonJS({\n  \"node_modules/asn1.js/lib/asn1.js\"(exports) {\n    var asn1 = exports;\n    asn1.bignum = require_bn5(), asn1.define = require_api().define, asn1.base = require_base2(), asn1.constants = require_constants(), asn1.decoders = require_decoders(), asn1.encoders = require_encoders();\n  }\n}), require_certificate = __commonJS({\n  \"node_modules/parse-asn1/certificate.js\"(exports, module) {\n    var asn = require_asn1(), Time = asn.define(\"Time\", function() {\n      this.choice({\n        utcTime: this.utctime(),\n        generalTime: this.gentime()\n      });\n    }), AttributeTypeValue = asn.define(\"AttributeTypeValue\", function() {\n      this.seq().obj(this.key(\"type\").objid(), this.key(\"value\").any());\n    }), AlgorithmIdentifier = asn.define(\"AlgorithmIdentifier\", function() {\n      this.seq().obj(this.key(\"algorithm\").objid(), this.key(\"parameters\").optional(), this.key(\"curve\").objid().optional());\n    }), SubjectPublicKeyInfo = asn.define(\"SubjectPublicKeyInfo\", function() {\n      this.seq().obj(this.key(\"algorithm\").use(AlgorithmIdentifier), this.key(\"subjectPublicKey\").bitstr());\n    }), RelativeDistinguishedName = asn.define(\"RelativeDistinguishedName\", function() {\n      this.setof(AttributeTypeValue);\n    }), RDNSequence = asn.define(\"RDNSequence\", function() {\n      this.seqof(RelativeDistinguishedName);\n    }), Name = asn.define(\"Name\", function() {\n      this.choice({\n        rdnSequence: this.use(RDNSequence)\n      });\n    }), Validity = asn.define(\"Validity\", function() {\n      this.seq().obj(this.key(\"notBefore\").use(Time), this.key(\"notAfter\").use(Time));\n    }), Extension = asn.define(\"Extension\", function() {\n      this.seq().obj(this.key(\"extnID\").objid(), this.key(\"critical\").bool().def(!1), this.key(\"extnValue\").octstr());\n    }), TBSCertificate = asn.define(\"TBSCertificate\", function() {\n      this.seq().obj(this.key(\"version\").explicit(0).int().optional(), this.key(\"serialNumber\").int(), this.key(\"signature\").use(AlgorithmIdentifier), this.key(\"issuer\").use(Name), this.key(\"validity\").use(Validity), this.key(\"subject\").use(Name), this.key(\"subjectPublicKeyInfo\").use(SubjectPublicKeyInfo), this.key(\"issuerUniqueID\").implicit(1).bitstr().optional(), this.key(\"subjectUniqueID\").implicit(2).bitstr().optional(), this.key(\"extensions\").explicit(3).seqof(Extension).optional());\n    }), X509Certificate = asn.define(\"X509Certificate\", function() {\n      this.seq().obj(this.key(\"tbsCertificate\").use(TBSCertificate), this.key(\"signatureAlgorithm\").use(AlgorithmIdentifier), this.key(\"signatureValue\").bitstr());\n    });\n    module.exports = X509Certificate;\n  }\n}), require_asn12 = __commonJS({\n  \"node_modules/parse-asn1/asn1.js\"(exports) {\n    var asn1 = require_asn1();\n    exports.certificate = require_certificate();\n    var RSAPrivateKey = asn1.define(\"RSAPrivateKey\", function() {\n      this.seq().obj(this.key(\"version\").int(), this.key(\"modulus\").int(), this.key(\"publicExponent\").int(), this.key(\"privateExponent\").int(), this.key(\"prime1\").int(), this.key(\"prime2\").int(), this.key(\"exponent1\").int(), this.key(\"exponent2\").int(), this.key(\"coefficient\").int());\n    });\n    exports.RSAPrivateKey = RSAPrivateKey;\n    var RSAPublicKey = asn1.define(\"RSAPublicKey\", function() {\n      this.seq().obj(this.key(\"modulus\").int(), this.key(\"publicExponent\").int());\n    });\n    exports.RSAPublicKey = RSAPublicKey;\n    var PublicKey = asn1.define(\"SubjectPublicKeyInfo\", function() {\n      this.seq().obj(this.key(\"algorithm\").use(AlgorithmIdentifier), this.key(\"subjectPublicKey\").bitstr());\n    });\n    exports.PublicKey = PublicKey;\n    var AlgorithmIdentifier = asn1.define(\"AlgorithmIdentifier\", function() {\n      this.seq().obj(this.key(\"algorithm\").objid(), this.key(\"none\").null_().optional(), this.key(\"curve\").objid().optional(), this.key(\"params\").seq().obj(this.key(\"p\").int(), this.key(\"q\").int(), this.key(\"g\").int()).optional());\n    }), PrivateKeyInfo = asn1.define(\"PrivateKeyInfo\", function() {\n      this.seq().obj(this.key(\"version\").int(), this.key(\"algorithm\").use(AlgorithmIdentifier), this.key(\"subjectPrivateKey\").octstr());\n    });\n    exports.PrivateKey = PrivateKeyInfo;\n    var EncryptedPrivateKeyInfo = asn1.define(\"EncryptedPrivateKeyInfo\", function() {\n      this.seq().obj(this.key(\"algorithm\").seq().obj(this.key(\"id\").objid(), this.key(\"decrypt\").seq().obj(this.key(\"kde\").seq().obj(this.key(\"id\").objid(), this.key(\"kdeparams\").seq().obj(this.key(\"salt\").octstr(), this.key(\"iters\").int())), this.key(\"cipher\").seq().obj(this.key(\"algo\").objid(), this.key(\"iv\").octstr()))), this.key(\"subjectPrivateKey\").octstr());\n    });\n    exports.EncryptedPrivateKey = EncryptedPrivateKeyInfo;\n    var DSAPrivateKey = asn1.define(\"DSAPrivateKey\", function() {\n      this.seq().obj(this.key(\"version\").int(), this.key(\"p\").int(), this.key(\"q\").int(), this.key(\"g\").int(), this.key(\"pub_key\").int(), this.key(\"priv_key\").int());\n    });\n    exports.DSAPrivateKey = DSAPrivateKey, exports.DSAparam = asn1.define(\"DSAparam\", function() {\n      this.int();\n    });\n    var ECPrivateKey = asn1.define(\"ECPrivateKey\", function() {\n      this.seq().obj(this.key(\"version\").int(), this.key(\"privateKey\").octstr(), this.key(\"parameters\").optional().explicit(0).use(ECParameters), this.key(\"publicKey\").optional().explicit(1).bitstr());\n    });\n    exports.ECPrivateKey = ECPrivateKey;\n    var ECParameters = asn1.define(\"ECParameters\", function() {\n      this.choice({\n        namedCurve: this.objid()\n      });\n    });\n    exports.signature = asn1.define(\"signature\", function() {\n      this.seq().obj(this.key(\"r\").int(), this.key(\"s\").int());\n    });\n  }\n}), require_aesid = __commonJS({\n  \"node_modules/parse-asn1/aesid.json\"(exports, module) {\n    module.exports = {\n      \"2.16.840.1.101.3.4.1.1\": \"aes-128-ecb\",\n      \"2.16.840.1.101.3.4.1.2\": \"aes-128-cbc\",\n      \"2.16.840.1.101.3.4.1.3\": \"aes-128-ofb\",\n      \"2.16.840.1.101.3.4.1.4\": \"aes-128-cfb\",\n      \"2.16.840.1.101.3.4.1.21\": \"aes-192-ecb\",\n      \"2.16.840.1.101.3.4.1.22\": \"aes-192-cbc\",\n      \"2.16.840.1.101.3.4.1.23\": \"aes-192-ofb\",\n      \"2.16.840.1.101.3.4.1.24\": \"aes-192-cfb\",\n      \"2.16.840.1.101.3.4.1.41\": \"aes-256-ecb\",\n      \"2.16.840.1.101.3.4.1.42\": \"aes-256-cbc\",\n      \"2.16.840.1.101.3.4.1.43\": \"aes-256-ofb\",\n      \"2.16.840.1.101.3.4.1.44\": \"aes-256-cfb\"\n    };\n  }\n}), require_fixProc = __commonJS({\n  \"node_modules/parse-asn1/fixProc.js\"(exports, module) {\n    var findProc = /Proc-Type: 4,ENCRYPTED[\\n\\r]+DEK-Info: AES-((\?:128)|(\?:192)|(\?:256))-CBC,([0-9A-H]+)[\\n\\r]+([0-9A-z\\n\\r+/=]+)[\\n\\r]+/m, startRegex = /^-----BEGIN ((\?:.*\? KEY)|CERTIFICATE)-----/m, fullRegex = /^-----BEGIN ((\?:.*\? KEY)|CERTIFICATE)-----([0-9A-z\\n\\r+/=]+)-----END \\1-----$/m, evp = require_evp_bytestokey(), ciphers = require_browser5(), Buffer2 = require_safe_buffer().Buffer;\n    module.exports = function(okey, password) {\n      var key = okey.toString(), match = key.match(findProc), decrypted;\n      if (match) {\n        var suite = \"aes\" + match[1], iv = Buffer2.from(match[2], \"hex\"), cipherText = Buffer2.from(match[3].replace(/[\\r\\n]/g, \"\"), \"base64\"), cipherKey = evp(password, iv.slice(0, 8), parseInt(match[1], 10)).key, out = [], cipher = ciphers.createDecipheriv(suite, cipherKey, iv);\n        out.push(cipher.update(cipherText)), out.push(cipher.final()), decrypted = Buffer2.concat(out);\n      } else {\n        var match2 = key.match(fullRegex);\n        decrypted = Buffer2.from(match2[2].replace(/[\\r\\n]/g, \"\"), \"base64\");\n      }\n      var tag = key.match(startRegex)[1];\n      return {\n        tag,\n        data: decrypted\n      };\n    };\n  }\n}), require_parse_asn1 = __commonJS({\n  \"node_modules/parse-asn1/index.js\"(exports, module) {\n    var asn1 = require_asn12(), aesid = require_aesid(), fixProc = require_fixProc(), ciphers = require_browser5(), compat = require_browser4(), Buffer2 = require_safe_buffer().Buffer;\n    module.exports = parseKeys;\n    function parseKeys(buffer) {\n      var password;\n      typeof buffer == \"object\" && !Buffer2.isBuffer(buffer) && (password = buffer.passphrase, buffer = buffer.key), typeof buffer == \"string\" && (buffer = Buffer2.from(buffer));\n      var stripped = fixProc(buffer, password), type = stripped.tag, data = stripped.data, subtype, ndata;\n      switch (type) {\n        case \"CERTIFICATE\":\n          ndata = asn1.certificate.decode(data, \"der\").tbsCertificate.subjectPublicKeyInfo;\n        case \"PUBLIC KEY\":\n          switch (ndata || (ndata = asn1.PublicKey.decode(data, \"der\")), subtype = ndata.algorithm.algorithm.join(\".\"), subtype) {\n            case \"1.2.840.113549.1.1.1\":\n              return asn1.RSAPublicKey.decode(ndata.subjectPublicKey.data, \"der\");\n            case \"1.2.840.10045.2.1\":\n              return ndata.subjectPrivateKey = ndata.subjectPublicKey, {\n                type: \"ec\",\n                data: ndata\n              };\n            case \"1.2.840.10040.4.1\":\n              return ndata.algorithm.params.pub_key = asn1.DSAparam.decode(ndata.subjectPublicKey.data, \"der\"), {\n                type: \"dsa\",\n                data: ndata.algorithm.params\n              };\n            default:\n              throw new Error(\"unknown key id \" + subtype);\n          }\n        case \"ENCRYPTED PRIVATE KEY\":\n          data = asn1.EncryptedPrivateKey.decode(data, \"der\"), data = decrypt(data, password);\n        case \"PRIVATE KEY\":\n          switch (ndata = asn1.PrivateKey.decode(data, \"der\"), subtype = ndata.algorithm.algorithm.join(\".\"), subtype) {\n            case \"1.2.840.113549.1.1.1\":\n              return asn1.RSAPrivateKey.decode(ndata.subjectPrivateKey, \"der\");\n            case \"1.2.840.10045.2.1\":\n              return {\n                curve: ndata.algorithm.curve,\n                privateKey: asn1.ECPrivateKey.decode(ndata.subjectPrivateKey, \"der\").privateKey\n              };\n            case \"1.2.840.10040.4.1\":\n              return ndata.algorithm.params.priv_key = asn1.DSAparam.decode(ndata.subjectPrivateKey, \"der\"), {\n                type: \"dsa\",\n                params: ndata.algorithm.params\n              };\n            default:\n              throw new Error(\"unknown key id \" + subtype);\n          }\n        case \"RSA PUBLIC KEY\":\n          return asn1.RSAPublicKey.decode(data, \"der\");\n        case \"RSA PRIVATE KEY\":\n          return asn1.RSAPrivateKey.decode(data, \"der\");\n        case \"DSA PRIVATE KEY\":\n          return {\n            type: \"dsa\",\n            params: asn1.DSAPrivateKey.decode(data, \"der\")\n          };\n        case \"EC PRIVATE KEY\":\n          return data = asn1.ECPrivateKey.decode(data, \"der\"), {\n            curve: data.parameters.value,\n            privateKey: data.privateKey\n          };\n        default:\n          throw new Error(\"unknown key type \" + type);\n      }\n    }\n    parseKeys.signature = asn1.signature;\n    function decrypt(data, password) {\n      var salt = data.algorithm.decrypt.kde.kdeparams.salt, iters = parseInt(data.algorithm.decrypt.kde.kdeparams.iters.toString(), 10), algo = aesid[data.algorithm.decrypt.cipher.algo.join(\".\")], iv = data.algorithm.decrypt.cipher.iv, cipherText = data.subjectPrivateKey, keylen = parseInt(algo.split(\"-\")[1], 10) / 8, key = compat.pbkdf2Sync(password, salt, iters, keylen, \"sha1\"), cipher = ciphers.createDecipheriv(algo, key, iv), out = [];\n      return out.push(cipher.update(cipherText)), out.push(cipher.final()), Buffer2.concat(out);\n    }\n  }\n}), require_curves2 = __commonJS({\n  \"node_modules/browserify-sign/browser/curves.json\"(exports, module) {\n    module.exports = {\n      \"1.3.132.0.10\": \"secp256k1\",\n      \"1.3.132.0.33\": \"p224\",\n      \"1.2.840.10045.3.1.1\": \"p192\",\n      \"1.2.840.10045.3.1.7\": \"p256\",\n      \"1.3.132.0.34\": \"p384\",\n      \"1.3.132.0.35\": \"p521\"\n    };\n  }\n}), require_sign = __commonJS({\n  \"node_modules/browserify-sign/browser/sign.js\"(exports, module) {\n    var Buffer2 = require_safe_buffer().Buffer, createHmac = require_browser3(), crt = require_browserify_rsa(), EC = require_elliptic().ec, BN = require_bn3(), parseKeys = require_parse_asn1(), curves = require_curves2();\n    function sign(hash, key, hashType, signType, tag) {\n      var priv = parseKeys(key);\n      if (priv.curve) {\n        if (signType !== \"ecdsa\" && signType !== \"ecdsa/rsa\")\n          throw new Error(\"wrong private key type\");\n        return ecSign(hash, priv);\n      } else if (priv.type === \"dsa\") {\n        if (signType !== \"dsa\")\n          throw new Error(\"wrong private key type\");\n        return dsaSign(hash, priv, hashType);\n      } else if (signType !== \"rsa\" && signType !== \"ecdsa/rsa\")\n        throw new Error(\"wrong private key type\");\n      hash = Buffer2.concat([tag, hash]);\n      for (var len = priv.modulus.byteLength(), pad = [0, 1];hash.length + pad.length + 1 < len; )\n        pad.push(255);\n      pad.push(0);\n      for (var i = -1;++i < hash.length; )\n        pad.push(hash[i]);\n      var out = crt(pad, priv);\n      return out;\n    }\n    function ecSign(hash, priv) {\n      var curveId = curves[priv.curve.join(\".\")];\n      if (!curveId)\n        throw new Error(\"unknown curve \" + priv.curve.join(\".\"));\n      var curve = new EC(curveId), key = curve.keyFromPrivate(priv.privateKey), out = key.sign(hash);\n      return Buffer2.from(out.toDER());\n    }\n    function dsaSign(hash, priv, algo) {\n      for (var x = priv.params.priv_key, p = priv.params.p, q = priv.params.q, g = priv.params.g, r = new BN(0), k, H = bits2int(hash, q).mod(q), s = !1, kv = getKey(x, q, hash, algo);s === !1; )\n        k = makeKey(q, kv, algo), r = makeR(g, k, p, q), s = k.invm(q).imul(H.add(x.mul(r))).mod(q), s.cmpn(0) === 0 && (s = !1, r = new BN(0));\n      return toDER(r, s);\n    }\n    function toDER(r, s) {\n      r = r.toArray(), s = s.toArray(), r[0] & 128 && (r = [0].concat(r)), s[0] & 128 && (s = [0].concat(s));\n      var total = r.length + s.length + 4, res = [48, total, 2, r.length];\n      return res = res.concat(r, [2, s.length], s), Buffer2.from(res);\n    }\n    function getKey(x, q, hash, algo) {\n      if (x = Buffer2.from(x.toArray()), x.length < q.byteLength()) {\n        var zeros = Buffer2.alloc(q.byteLength() - x.length);\n        x = Buffer2.concat([zeros, x]);\n      }\n      var hlen = hash.length, hbits = bits2octets(hash, q), v = Buffer2.alloc(hlen);\n      v.fill(1);\n      var k = Buffer2.alloc(hlen);\n      return k = createHmac(algo, k).update(v).update(Buffer2.from([0])).update(x).update(hbits).digest(), v = createHmac(algo, k).update(v).digest(), k = createHmac(algo, k).update(v).update(Buffer2.from([1])).update(x).update(hbits).digest(), v = createHmac(algo, k).update(v).digest(), { k, v };\n    }\n    function bits2int(obits, q) {\n      var bits = new BN(obits), shift = (obits.length << 3) - q.bitLength();\n      return shift > 0 && bits.ishrn(shift), bits;\n    }\n    function bits2octets(bits, q) {\n      bits = bits2int(bits, q), bits = bits.mod(q);\n      var out = Buffer2.from(bits.toArray());\n      if (out.length < q.byteLength()) {\n        var zeros = Buffer2.alloc(q.byteLength() - out.length);\n        out = Buffer2.concat([zeros, out]);\n      }\n      return out;\n    }\n    function makeKey(q, kv, algo) {\n      var t, k;\n      do {\n        for (t = Buffer2.alloc(0);t.length * 8 < q.bitLength(); )\n          kv.v = createHmac(algo, kv.k).update(kv.v).digest(), t = Buffer2.concat([t, kv.v]);\n        k = bits2int(t, q), kv.k = createHmac(algo, kv.k).update(kv.v).update(Buffer2.from([0])).digest(), kv.v = createHmac(algo, kv.k).update(kv.v).digest();\n      } while (k.cmp(q) !== -1);\n      return k;\n    }\n    function makeR(g, k, p, q) {\n      return g.toRed(BN.mont(p)).redPow(k).fromRed().mod(q);\n    }\n    module.exports = sign, module.exports.getKey = getKey, module.exports.makeKey = makeKey;\n  }\n}), require_verify = __commonJS({\n  \"node_modules/browserify-sign/browser/verify.js\"(exports, module) {\n    var Buffer2 = require_safe_buffer().Buffer, BN = require_bn3(), EC = require_elliptic().ec, parseKeys = require_parse_asn1(), curves = require_curves2();\n    function verify(sig, hash, key, signType, tag) {\n      var pub = parseKeys(key);\n      if (pub.type === \"ec\") {\n        if (signType !== \"ecdsa\" && signType !== \"ecdsa/rsa\")\n          throw new Error(\"wrong public key type\");\n        return ecVerify(sig, hash, pub);\n      } else if (pub.type === \"dsa\") {\n        if (signType !== \"dsa\")\n          throw new Error(\"wrong public key type\");\n        return dsaVerify(sig, hash, pub);\n      } else if (signType !== \"rsa\" && signType !== \"ecdsa/rsa\")\n        throw new Error(\"wrong public key type\");\n      hash = Buffer2.concat([tag, hash]);\n      for (var len = pub.modulus.byteLength(), pad = [1], padNum = 0;hash.length + pad.length + 2 < len; )\n        pad.push(255), padNum++;\n      pad.push(0);\n      for (var i = -1;++i < hash.length; )\n        pad.push(hash[i]);\n      pad = Buffer2.from(pad);\n      var red = BN.mont(pub.modulus);\n      sig = new BN(sig).toRed(red), sig = sig.redPow(new BN(pub.publicExponent)), sig = Buffer2.from(sig.fromRed().toArray());\n      var out = padNum < 8 \? 1 : 0;\n      for (len = Math.min(sig.length, pad.length), sig.length !== pad.length && (out = 1), i = -1;++i < len; )\n        out |= sig[i] ^ pad[i];\n      return out === 0;\n    }\n    function ecVerify(sig, hash, pub) {\n      var curveId = curves[pub.data.algorithm.curve.join(\".\")];\n      if (!curveId)\n        throw new Error(\"unknown curve \" + pub.data.algorithm.curve.join(\".\"));\n      var curve = new EC(curveId), pubkey = pub.data.subjectPrivateKey.data;\n      return curve.verify(hash, sig, pubkey);\n    }\n    function dsaVerify(sig, hash, pub) {\n      var p = pub.data.p, q = pub.data.q, g = pub.data.g, y = pub.data.pub_key, unpacked = parseKeys.signature.decode(sig, \"der\"), s = unpacked.s, r = unpacked.r;\n      checkValue(s, q), checkValue(r, q);\n      var montp = BN.mont(p), w = s.invm(q), v = g.toRed(montp).redPow(new BN(hash).mul(w).mod(q)).fromRed().mul(y.toRed(montp).redPow(r.mul(w).mod(q)).fromRed()).mod(p).mod(q);\n      return v.cmp(r) === 0;\n    }\n    function checkValue(b, q) {\n      if (b.cmpn(0) <= 0)\n        throw new Error(\"invalid sig\");\n      if (b.cmp(q) >= q)\n        throw new Error(\"invalid sig\");\n    }\n    module.exports = verify;\n  }\n}), require_browser8 = __commonJS({\n  \"node_modules/browserify-sign/browser/index.js\"(exports, module) {\n    var Buffer2 = require_safe_buffer().Buffer, createHash = require_browser2(), inherits = require_inherits_browser(), sign = require_sign(), verify = require_verify(), algorithms = require_algorithms();\n    Object.keys(algorithms).forEach(function(key) {\n      algorithms[key].id = Buffer2.from(algorithms[key].id, \"hex\"), algorithms[key.toLowerCase()] = algorithms[key];\n    });\n    function Sign(algorithm) {\n      StreamModule.Writable.call(this);\n      var data = algorithms[algorithm];\n      if (!data)\n        throw new Error(\"Unknown message digest\");\n      this._hashType = data.hash, this._hash = createHash(data.hash), this._tag = data.id, this._signType = data.sign;\n    }\n    inherits(Sign, StreamModule.Writable), Sign.prototype._write = function(data, _, done) {\n      this._hash.update(data), done();\n    }, Sign.prototype.update = function(data, enc) {\n      return typeof data == \"string\" && (data = Buffer2.from(data, enc)), this._hash.update(data), this;\n    }, Sign.prototype.sign = function(key, enc) {\n      this.end();\n      var hash = this._hash.digest(), sig = sign(hash, key, this._hashType, this._signType, this._tag);\n      return enc \? sig.toString(enc) : sig;\n    };\n    function Verify(algorithm) {\n      StreamModule.Writable.call(this);\n      var data = algorithms[algorithm];\n      if (!data)\n        throw new Error(\"Unknown message digest\");\n      this._hash = createHash(data.hash), this._tag = data.id, this._signType = data.sign;\n    }\n    inherits(Verify, StreamModule.Writable), Verify.prototype._write = function(data, _, done) {\n      this._hash.update(data), done();\n    }, Verify.prototype.update = function(data, enc) {\n      return typeof data == \"string\" && (data = Buffer2.from(data, enc)), this._hash.update(data), this;\n    }, Verify.prototype.verify = function(key, sig, enc) {\n      typeof sig == \"string\" && (sig = Buffer2.from(sig, enc)), this.end();\n      var hash = this._hash.digest();\n      return verify(sig, hash, key, this._signType, this._tag);\n    };\n    function createSign(algorithm) {\n      return new Sign(algorithm);\n    }\n    function createVerify(algorithm) {\n      return new Verify(algorithm);\n    }\n    module.exports = {\n      Sign: createSign,\n      Verify: createVerify,\n      createSign,\n      createVerify\n    };\n  }\n}), require_bn6 = require_bn, require_browser9 = __commonJS({\n  \"node_modules/create-ecdh/browser.js\"(exports, module) {\n    var elliptic = require_elliptic(), BN = require_bn6();\n    module.exports = function(curve) {\n      return new ECDH(curve);\n    };\n    var aliases = {\n      secp256k1: {\n        name: \"secp256k1\",\n        byteLength: 32\n      },\n      secp224r1: {\n        name: \"p224\",\n        byteLength: 28\n      },\n      prime256v1: {\n        name: \"p256\",\n        byteLength: 32\n      },\n      prime192v1: {\n        name: \"p192\",\n        byteLength: 24\n      },\n      ed25519: {\n        name: \"ed25519\",\n        byteLength: 32\n      },\n      secp384r1: {\n        name: \"p384\",\n        byteLength: 48\n      },\n      secp521r1: {\n        name: \"p521\",\n        byteLength: 66\n      }\n    };\n    aliases.p224 = aliases.secp224r1, aliases.p256 = aliases.secp256r1 = aliases.prime256v1, aliases.p192 = aliases.secp192r1 = aliases.prime192v1, aliases.p384 = aliases.secp384r1, aliases.p521 = aliases.secp521r1;\n    function ECDH(curve) {\n      this.curveType = aliases[curve], this.curveType || (this.curveType = {\n        name: curve\n      }), this.curve = new elliptic.ec(this.curveType.name), this.keys = void 0;\n    }\n    ECDH.prototype = {}, ECDH.prototype.generateKeys = function(enc, format) {\n      return this.keys = this.curve.genKeyPair(), this.getPublicKey(enc, format);\n    }, ECDH.prototype.computeSecret = function(other, inenc, enc) {\n      inenc = inenc || \"utf8\", Buffer.isBuffer(other) || (other = new Buffer(other, inenc));\n      var otherPub = this.curve.keyFromPublic(other).getPublic(), out = otherPub.mul(this.keys.getPrivate()).getX();\n      return formatReturnValue(out, enc, this.curveType.byteLength);\n    }, ECDH.prototype.getPublicKey = function(enc, format) {\n      var key = this.keys.getPublic(format === \"compressed\", !0);\n      return format === \"hybrid\" && (key[key.length - 1] % 2 \? key[0] = 7 : key[0] = 6), formatReturnValue(key, enc);\n    }, ECDH.prototype.getPrivateKey = function(enc) {\n      return formatReturnValue(this.keys.getPrivate(), enc);\n    }, ECDH.prototype.setPublicKey = function(pub, enc) {\n      return enc = enc || \"utf8\", Buffer.isBuffer(pub) || (pub = new Buffer(pub, enc)), this.keys._importPublic(pub), this;\n    }, ECDH.prototype.setPrivateKey = function(priv, enc) {\n      enc = enc || \"utf8\", Buffer.isBuffer(priv) || (priv = new Buffer(priv, enc));\n      var _priv = new BN(priv);\n      return _priv = _priv.toString(16), this.keys = this.curve.genKeyPair(), this.keys._importPrivate(_priv), this;\n    };\n    function formatReturnValue(bn, enc, len) {\n      Array.isArray(bn) || (bn = bn.toArray());\n      var buf = new Buffer(bn);\n      if (len && buf.length < len) {\n        var zeros = new Buffer(len - buf.length);\n        zeros.fill(0), buf = Buffer.concat([zeros, buf]);\n      }\n      return enc \? buf.toString(enc) : buf;\n    }\n  }\n}), require_mgf = __commonJS({\n  \"node_modules/public-encrypt/mgf.js\"(exports, module) {\n    var createHash = require_browser2(), Buffer2 = require_safe_buffer().Buffer;\n    module.exports = function(seed, len) {\n      for (var t = Buffer2.alloc(0), i = 0, c;t.length < len; )\n        c = i2ops(i++), t = Buffer2.concat([t, createHash(\"sha1\").update(seed).update(c).digest()]);\n      return t.slice(0, len);\n    };\n    function i2ops(c) {\n      var out = Buffer2.allocUnsafe(4);\n      return out.writeUInt32BE(c, 0), out;\n    }\n  }\n}), require_xor = __commonJS({\n  \"node_modules/public-encrypt/xor.js\"(exports, module) {\n    module.exports = function(a, b) {\n      for (var len = a.length, i = -1;++i < len; )\n        a[i] ^= b[i];\n      return a;\n    };\n  }\n}), require_bn7 = require_bn, { CryptoHasher } = globalThis.Bun, require_withPublic = __commonJS({\n  \"node_modules/public-encrypt/withPublic.js\"(exports, module) {\n    var BN = require_bn7(), Buffer2 = require_safe_buffer().Buffer;\n    function withPublic(paddedMsg, key) {\n      return Buffer2.from(paddedMsg.toRed(BN.mont(key.modulus)).redPow(new BN(key.publicExponent)).fromRed().toArray());\n    }\n    module.exports = withPublic;\n  }\n}), require_publicEncrypt = __commonJS({\n  \"node_modules/public-encrypt/publicEncrypt.js\"(exports, module) {\n    var parseKeys = require_parse_asn1(), randomBytes = require_browser(), createHash = require_browser2(), mgf = require_mgf(), xor = require_xor(), BN = require_bn7(), withPublic = require_withPublic(), crt = require_browserify_rsa(), Buffer2 = require_safe_buffer().Buffer;\n    module.exports = function(publicKey, msg, reverse) {\n      var padding;\n      publicKey.padding \? padding = publicKey.padding : reverse \? padding = 1 : padding = 4;\n      var key = parseKeys(publicKey), paddedMsg;\n      if (padding === 4)\n        paddedMsg = oaep(key, msg);\n      else if (padding === 1)\n        paddedMsg = pkcs1(key, msg, reverse);\n      else if (padding === 3) {\n        if (paddedMsg = new BN(msg), paddedMsg.cmp(key.modulus) >= 0)\n          throw new Error(\"data too long for modulus\");\n      } else\n        throw new Error(\"unknown padding\");\n      return reverse \? crt(paddedMsg, key) : withPublic(paddedMsg, key);\n    };\n    function oaep(key, msg) {\n      var k = key.modulus.byteLength(), mLen = msg.length, iHash = createHash(\"sha1\").update(Buffer2.alloc(0)).digest(), hLen = iHash.length, hLen2 = 2 * hLen;\n      if (mLen > k - hLen2 - 2)\n        throw new Error(\"message too long\");\n      var ps = Buffer2.alloc(k - mLen - hLen2 - 2), dblen = k - hLen - 1, seed = randomBytes(hLen), maskedDb = xor(Buffer2.concat([iHash, ps, Buffer2.alloc(1, 1), msg], dblen), mgf(seed, dblen)), maskedSeed = xor(seed, mgf(maskedDb, hLen));\n      return new BN(Buffer2.concat([Buffer2.alloc(1), maskedSeed, maskedDb], k));\n    }\n    function pkcs1(key, msg, reverse) {\n      var mLen = msg.length, k = key.modulus.byteLength();\n      if (mLen > k - 11)\n        throw new Error(\"message too long\");\n      var ps;\n      return reverse \? ps = Buffer2.alloc(k - mLen - 3, 255) : ps = nonZero(k - mLen - 3), new BN(Buffer2.concat([Buffer2.from([0, reverse \? 1 : 2]), ps, Buffer2.alloc(1), msg], k));\n    }\n    function nonZero(len) {\n      for (var out = Buffer2.allocUnsafe(len), i = 0, cache = randomBytes(len * 2), cur = 0, num;i < len; )\n        cur === cache.length && (cache = randomBytes(len * 2), cur = 0), num = cache[cur++], num && (out[i++] = num);\n      return out;\n    }\n  }\n}), require_privateDecrypt = __commonJS({\n  \"node_modules/public-encrypt/privateDecrypt.js\"(exports, module) {\n    var parseKeys = require_parse_asn1(), mgf = require_mgf(), xor = require_xor(), BN = require_bn7(), crt = require_browserify_rsa(), createHash = require_browser2(), withPublic = require_withPublic(), Buffer2 = require_safe_buffer().Buffer;\n    module.exports = function(privateKey, enc, reverse) {\n      var padding;\n      privateKey.padding \? padding = privateKey.padding : reverse \? padding = 1 : padding = 4;\n      var key = parseKeys(privateKey), k = key.modulus.byteLength();\n      if (enc.length > k || new BN(enc).cmp(key.modulus) >= 0)\n        throw new Error(\"decryption error\");\n      var msg;\n      reverse \? msg = withPublic(new BN(enc), key) : msg = crt(enc, key);\n      var zBuffer = Buffer2.alloc(k - msg.length);\n      if (msg = Buffer2.concat([zBuffer, msg], k), padding === 4)\n        return oaep(key, msg);\n      if (padding === 1)\n        return pkcs1(key, msg, reverse);\n      if (padding === 3)\n        return msg;\n      throw new Error(\"unknown padding\");\n    };\n    function oaep(key, msg) {\n      var k = key.modulus.byteLength(), iHash = createHash(\"sha1\").update(Buffer2.alloc(0)).digest(), hLen = iHash.length;\n      if (msg[0] !== 0)\n        throw new Error(\"decryption error\");\n      var maskedSeed = msg.slice(1, hLen + 1), maskedDb = msg.slice(hLen + 1), seed = xor(maskedSeed, mgf(maskedDb, hLen)), db = xor(maskedDb, mgf(seed, k - hLen - 1));\n      if (compare(iHash, db.slice(0, hLen)))\n        throw new Error(\"decryption error\");\n      for (var i = hLen;db[i] === 0; )\n        i++;\n      if (db[i++] !== 1)\n        throw new Error(\"decryption error\");\n      return db.slice(i);\n    }\n    function pkcs1(key, msg, reverse) {\n      for (var p1 = msg.slice(0, 2), i = 2, status = 0;msg[i++] !== 0; )\n        if (i >= msg.length) {\n          status++;\n          break;\n        }\n      var ps = msg.slice(2, i - 1);\n      if ((p1.toString(\"hex\") !== \"0002\" && !reverse || p1.toString(\"hex\") !== \"0001\" && reverse) && status++, ps.length < 8 && status++, status)\n        throw new Error(\"decryption error\");\n      return msg.slice(i);\n    }\n    function compare(a, b) {\n      a = Buffer2.from(a), b = Buffer2.from(b);\n      var dif = 0, len = a.length;\n      a.length !== b.length && (dif++, len = Math.min(a.length, b.length));\n      for (var i = -1;++i < len; )\n        dif += a[i] ^ b[i];\n      return dif;\n    }\n  }\n}), require_browser10 = __commonJS({\n  \"node_modules/public-encrypt/browser.js\"(exports) {\n    exports.publicEncrypt = require_publicEncrypt(), exports.privateDecrypt = require_privateDecrypt(), exports.privateEncrypt = function(key, buf) {\n      return exports.publicEncrypt(key, buf, !0);\n    }, exports.publicDecrypt = function(key, buf) {\n      return exports.privateDecrypt(key, buf, !0);\n    };\n  }\n}), require_browser11 = __commonJS({\n  \"node_modules/randomfill/browser.js\"(exports) {\n    var safeBuffer = require_safe_buffer(), randombytes = require_browser(), Buffer2 = safeBuffer.Buffer, kBufferMaxLength = safeBuffer.kMaxLength, kMaxUint32 = Math.pow(2, 32) - 1;\n    function assertOffset(offset, length) {\n      if (typeof offset != \"number\" || offset !== offset)\n        @throwTypeError(\"offset must be a number\");\n      if (offset > kMaxUint32 || offset < 0)\n        @throwTypeError(\"offset must be a uint32\");\n      if (offset > kBufferMaxLength || offset > length)\n        @throwRangeError(\"offset out of range\");\n    }\n    function assertSize(size, offset, length) {\n      if (typeof size != \"number\" || size !== size)\n        @throwTypeError(\"size must be a number\");\n      if (size > kMaxUint32 || size < 0)\n        @throwTypeError(\"size must be a uint32\");\n      if (size + offset > length || size > kBufferMaxLength)\n        @throwRangeError(\"buffer too small\");\n    }\n    exports.randomFill = randomFill, exports.randomFillSync = randomFillSync;\n    function randomFill(buf, offset, size, cb) {\n      if (!Buffer2.isBuffer(buf) && !(buf instanceof global.Uint8Array))\n        @throwTypeError('\"buf\" argument must be a Buffer or Uint8Array');\n      if (typeof offset == \"function\")\n        cb = offset, offset = 0, size = buf.length;\n      else if (typeof size == \"function\")\n        cb = size, size = buf.length - offset;\n      else if (typeof cb != \"function\")\n        @throwTypeError('\"cb\" argument must be a function');\n      return assertOffset(offset, buf.length), assertSize(size, offset, buf.length), actualFill(buf, offset, size, cb);\n    }\n    function actualFill(buf, offset, size, cb) {\n      if (cb) {\n        randombytes(size, function(err, bytes2) {\n          if (err)\n            return cb(err);\n          bytes2.copy(buf, offset), cb(null, buf);\n        });\n        return;\n      }\n      var bytes = randombytes(size);\n      return bytes.copy(buf, offset), buf;\n    }\n    function randomFillSync(buf, offset, size) {\n      if (typeof offset > \"u\" && (offset = 0), !Buffer2.isBuffer(buf) && !(buf instanceof global.Uint8Array))\n        @throwTypeError('\"buf\" argument must be a Buffer or Uint8Array');\n      return assertOffset(offset, buf.length), size === void 0 && (size = buf.length - offset), assertSize(size, offset, buf.length), actualFill(buf, offset, size);\n    }\n  }\n}), require_crypto_browserify2 = __commonJS({\n  \"node_modules/crypto-browserify/index.js\"(exports) {\n    exports.randomBytes = exports.rng = exports.pseudoRandomBytes = exports.prng = require_browser(), exports.createHash = require_browser2(), exports.Hash = exports.createHash.Hash, exports.createHmac = exports.Hmac = require_browser3();\n    var algos = require_algos(), algoKeys = Object.keys(algos), hashes = [\"sha1\", \"sha224\", \"sha256\", \"sha384\", \"sha512\", \"md5\", \"rmd160\"].concat(algoKeys);\n    exports.getHashes = function() {\n      return hashes;\n    };\n    var p = require_browser4();\n    exports.pbkdf2 = p.pbkdf2, exports.pbkdf2Sync = p.pbkdf2Sync;\n    var aes = require_browser6();\n    exports.Cipher = aes.Cipher, exports.createCipher = aes.createCipher, exports.Cipheriv = aes.Cipheriv, exports.createCipheriv = aes.createCipheriv, exports.Decipher = aes.Decipher, exports.createDecipher = aes.createDecipher, exports.Decipheriv = aes.Decipheriv, exports.createDecipheriv = aes.createDecipheriv, exports.getCiphers = aes.getCiphers, exports.listCiphers = aes.listCiphers;\n    var dh = require_browser7();\n    exports.DiffieHellmanGroup = dh.DiffieHellmanGroup, exports.createDiffieHellmanGroup = dh.createDiffieHellmanGroup, exports.getDiffieHellman = dh.getDiffieHellman, exports.createDiffieHellman = dh.createDiffieHellman, exports.DiffieHellman = dh.DiffieHellman;\n    var sign = require_browser8();\n    exports.createSign = sign.createSign, exports.Sign = sign.Sign, exports.createVerify = sign.createVerify, exports.Verify = sign.Verify, exports.createECDH = require_browser9();\n    var publicEncrypt = require_browser10();\n    exports.publicEncrypt = publicEncrypt.publicEncrypt, exports.privateEncrypt = publicEncrypt.privateEncrypt, exports.publicDecrypt = publicEncrypt.publicDecrypt, exports.privateDecrypt = publicEncrypt.privateDecrypt, exports.getRandomValues = (values) => crypto.getRandomValues(values);\n    var rf = require_browser11();\n    exports.randomFill = rf.randomFill, exports.randomFillSync = rf.randomFillSync, exports.createCredentials = function() {\n      throw new Error([\n        \"sorry, createCredentials is not implemented yet\",\n        \"we accept pull requests\",\n        \"https://github.com/crypto-browserify/crypto-browserify\"\n      ].join(`\n`));\n    }, exports.constants = @processBindingConstants.crypto;\n  }\n}), crypto_exports = require_crypto_browserify2(), DEFAULT_ENCODING = \"buffer\", getRandomValues = (array) => crypto.getRandomValues(array), randomUUID = () => crypto.randomUUID(), randomInt = (...args) => crypto.randomInt(...args), timingSafeEqual = \"timingSafeEqual\" in crypto \? (a, b) => {\n  let { byteLength: byteLengthA } = a, { byteLength: byteLengthB } = b;\n  if (typeof byteLengthA != \"number\" || typeof byteLengthB != \"number\")\n    @throwTypeError(\"Input must be an array buffer view\");\n  if (byteLengthA !== byteLengthB)\n    @throwRangeError(\"Input buffers must have the same length\");\n  return crypto.timingSafeEqual(a, b);\n} : void 0, scryptSync = \"scryptSync\" in crypto \? (password, salt, keylen, options) => {\n  let res = crypto.scryptSync(password, salt, keylen, options);\n  return DEFAULT_ENCODING !== \"buffer\" \? new Buffer(res).toString(DEFAULT_ENCODING) : new Buffer(res);\n} : void 0, scrypt = \"scryptSync\" in crypto \? function(password, salt, keylen, options, callback) {\n  if (typeof options == \"function\" && (callback = options, options = void 0), typeof callback != \"function\") {\n    var err = @makeTypeError(\"callback must be a function\");\n    throw err.code = \"ERR_INVALID_CALLBACK\", err;\n  }\n  try {\n    let result = crypto.scryptSync(password, salt, keylen, options);\n    process.nextTick(callback, null, DEFAULT_ENCODING !== \"buffer\" \? new Buffer(result).toString(DEFAULT_ENCODING) : new Buffer(result));\n  } catch (err2) {\n    throw err2;\n  }\n} : void 0;\ntimingSafeEqual && (Object.defineProperty(timingSafeEqual, \"name\", {\n  value: \"::bunternal::\"\n}), Object.defineProperty(scrypt, \"name\", {\n  value: \"::bunternal::\"\n}), Object.defineProperty(scryptSync, \"name\", {\n  value: \"::bunternal::\"\n}));\nvar harcoded_curves = [\n  \"p192\",\n  \"p224\",\n  \"p256\",\n  \"p384\",\n  \"p521\",\n  \"curve25519\",\n  \"ed25519\",\n  \"secp256k1\",\n  \"secp224r1\",\n  \"prime256v1\",\n  \"prime192v1\",\n  \"ed25519\",\n  \"secp384r1\",\n  \"secp521r1\"\n], webcrypto = crypto;\n__export(crypto_exports, {\n  DEFAULT_ENCODING: () => DEFAULT_ENCODING,\n  getRandomValues: () => getRandomValues,\n  randomUUID: () => randomUUID,\n  randomInt: () => randomInt,\n  getCurves: () => getCurves,\n  scrypt: () => scrypt,\n  scryptSync: () => scryptSync,\n  timingSafeEqual: () => timingSafeEqual,\n  webcrypto: () => webcrypto,\n  subtle: () => webcrypto.subtle\n});\n$ = crypto_exports;\n/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */\nreturn $})\n"_s;
//

//
static constexpr ASCIILiteral NodeDgramCode = "(function (){\"use strict\";// src/js/out/tmp/node/dgram.ts\nvar createSocket = function() {\n  throwNotImplemented(\"node:dgram createSocket\", 1630);\n}, Socket = function() {\n  throwNotImplemented(\"node:dgram Socket\", 1630);\n}, _createSocketHandle = function() {\n  throwNotImplemented(\"node:dgram _createSocketHandle\", 1630);\n}, $, { hideFromStack, throwNotImplemented } = @getInternalField(@internalModuleRegistry, 3) || @createInternalModuleById(3);\n$ = {\n  createSocket,\n  Socket,\n  _createSocketHandle\n};\nhideFromStack(createSocket, Socket, _createSocketHandle);\nreturn $})\n"_s;
//

//
static constexpr ASCIILiteral NodeDiagnosticsChannelCode = "(function (){\"use strict\";// src/js/out/tmp/node/diagnostics_channel.ts\nvar markActive = function(channel) {\n  ObjectSetPrototypeOf(channel, ActiveChannel.prototype), channel._subscribers = [], channel._stores = new SafeMap;\n}, maybeMarkInactive = function(channel) {\n  if (!channel._subscribers.length && !channel._stores.size)\n    ObjectSetPrototypeOf(channel, Channel.prototype), channel._subscribers = void 0, channel._stores = void 0;\n}, defaultTransform = function(data) {\n  return data;\n}, wrapStoreRun = function(store, data, next, transform = defaultTransform) {\n  return () => {\n    let context;\n    try {\n      context = transform(data);\n    } catch (err) {\n      return process.nextTick(() => reportError(err)), next();\n    }\n    return store.run(context, next);\n  };\n}, channel = function(name) {\n  const channel2 = channels.get(name);\n  if (channel2)\n    return channel2;\n  if (typeof name !== \"string\" && typeof name !== \"symbol\")\n    throw new ERR_INVALID_ARG_TYPE(\"channel\", [\"string\", \"symbol\"], name);\n  return new Channel(name);\n}, subscribe = function(name, subscription) {\n  return channel(name).subscribe(subscription);\n}, unsubscribe = function(name, subscription) {\n  return channel(name).unsubscribe(subscription);\n}, hasSubscribers = function(name) {\n  const channel2 = channels.get(name);\n  if (!channel2)\n    return !1;\n  return channel2.hasSubscribers;\n}, assertChannel = function(value, name) {\n  if (!(value instanceof Channel))\n    throw new ERR_INVALID_ARG_TYPE(name, [\"Channel\"], value);\n}, tracingChannel = function(nameOrChannels) {\n  return new TracingChannel(nameOrChannels);\n}, validateFunction = function(callable, field) {\n  if (typeof callable !== \"function\")\n    throw new ERR_INVALID_ARG_TYPE(field, \"Function\", callable);\n  return callable;\n}, $, SafeMap = Map, SafeFinalizationRegistry = FinalizationRegistry, ArrayPrototypeAt = (array, index) => array[index], ArrayPrototypeIndexOf = (array, value) => array.indexOf(value), ArrayPrototypePush = (array, value) => array.push(value), ArrayPrototypeSplice = (array, start, deleteCount) => array.splice(start, deleteCount), ObjectGetPrototypeOf = Object.getPrototypeOf, ObjectSetPrototypeOf = Object.setPrototypeOf, SymbolHasInstance = Symbol.hasInstance, ReflectApply = Reflect.apply, PromiseResolve = Promise.resolve, PromiseReject = Promise.reject, PromisePrototypeThen = (promise, onFulfilled, onRejected) => promise.then(onFulfilled, onRejected);\n\nclass WeakReference extends WeakRef {\n  constructor() {\n    super(...arguments);\n  }\n  #refs = 0;\n  get() {\n    return this.deref();\n  }\n  incRef() {\n    return ++this.#refs;\n  }\n  decRef() {\n    return --this.#refs;\n  }\n}\n\nclass WeakRefMap extends SafeMap {\n  constructor() {\n    super(...arguments);\n  }\n  #finalizers = new SafeFinalizationRegistry((key) => {\n    this.delete(key);\n  });\n  set(key, value) {\n    return this.#finalizers.register(value, key), super.set(key, new WeakReference(value));\n  }\n  get(key) {\n    return super.get(key)\?.get();\n  }\n  incRef(key) {\n    return super.get(key)\?.incRef();\n  }\n  decRef(key) {\n    return super.get(key)\?.decRef();\n  }\n}\n\nclass ActiveChannel {\n  subscribe(subscription) {\n    validateFunction(subscription, \"subscription\"), ArrayPrototypePush(this._subscribers, subscription), channels.incRef(this.name);\n  }\n  unsubscribe(subscription) {\n    const index = ArrayPrototypeIndexOf(this._subscribers, subscription);\n    if (index === -1)\n      return !1;\n    return ArrayPrototypeSplice(this._subscribers, index, 1), channels.decRef(this.name), maybeMarkInactive(this), !0;\n  }\n  bindStore(store, transform) {\n    if (!this._stores.has(store))\n      channels.incRef(this.name);\n    this._stores.set(store, transform);\n  }\n  unbindStore(store) {\n    if (!this._stores.has(store))\n      return !1;\n    return this._stores.delete(store), channels.decRef(this.name), maybeMarkInactive(this), !0;\n  }\n  get hasSubscribers() {\n    return !0;\n  }\n  publish(data) {\n    for (let i = 0;i < (this._subscribers\?.length || 0); i++)\n      try {\n        const onMessage = this._subscribers[i];\n        onMessage(data, this.name);\n      } catch (err) {\n        process.nextTick(() => reportError(err));\n      }\n  }\n  runStores(data, fn, thisArg, ...args) {\n    let run = () => {\n      return this.publish(data), ReflectApply(fn, thisArg, args);\n    };\n    for (let entry of this._stores.entries()) {\n      const store = entry[0], transform = entry[1];\n      run = wrapStoreRun(store, data, run, transform);\n    }\n    return run();\n  }\n}\n\nclass Channel {\n  constructor(name) {\n    this._subscribers = void 0, this._stores = void 0, this.name = name, channels.set(name, this);\n  }\n  static [SymbolHasInstance](instance) {\n    const prototype = ObjectGetPrototypeOf(instance);\n    return prototype === Channel.prototype || prototype === ActiveChannel.prototype;\n  }\n  subscribe(subscription) {\n    markActive(this), this.subscribe(subscription);\n  }\n  unsubscribe() {\n    return !1;\n  }\n  bindStore(store, transform) {\n    markActive(this), this.bindStore(store, transform);\n  }\n  unbindStore() {\n    return !1;\n  }\n  get hasSubscribers() {\n    return !1;\n  }\n  publish() {\n  }\n  runStores(data, fn, thisArg, ...args) {\n    return ReflectApply(fn, thisArg, args);\n  }\n}\nvar channels = new WeakRefMap, traceEvents = [\"start\", \"end\", \"asyncStart\", \"asyncEnd\", \"error\"];\n\nclass TracingChannel {\n  constructor(nameOrChannels) {\n    if (typeof nameOrChannels === \"string\")\n      this.start = channel(`tracing:${nameOrChannels}:start`), this.end = channel(`tracing:${nameOrChannels}:end`), this.asyncStart = channel(`tracing:${nameOrChannels}:asyncStart`), this.asyncEnd = channel(`tracing:${nameOrChannels}:asyncEnd`), this.error = channel(`tracing:${nameOrChannels}:error`);\n    else if (typeof nameOrChannels === \"object\") {\n      const { start, end, asyncStart, asyncEnd, error } = nameOrChannels;\n      assertChannel(start, \"nameOrChannels.start\"), assertChannel(end, \"nameOrChannels.end\"), assertChannel(asyncStart, \"nameOrChannels.asyncStart\"), assertChannel(asyncEnd, \"nameOrChannels.asyncEnd\"), assertChannel(error, \"nameOrChannels.error\"), this.start = start, this.end = end, this.asyncStart = asyncStart, this.asyncEnd = asyncEnd, this.error = error;\n    } else\n      throw new ERR_INVALID_ARG_TYPE(\"nameOrChannels\", [\"string\", \"object\", \"Channel\"], nameOrChannels);\n  }\n  subscribe(handlers) {\n    for (let name of traceEvents) {\n      if (!handlers[name])\n        continue;\n      this[name]\?.subscribe(handlers[name]);\n    }\n  }\n  unsubscribe(handlers) {\n    let done = !0;\n    for (let name of traceEvents) {\n      if (!handlers[name])\n        continue;\n      if (!this[name]\?.unsubscribe(handlers[name]))\n        done = !1;\n    }\n    return done;\n  }\n  traceSync(fn, context = {}, thisArg, ...args) {\n    const { start, end, error } = this;\n    return start.runStores(context, () => {\n      try {\n        const result = ReflectApply(fn, thisArg, args);\n        return context.result = result, result;\n      } catch (err) {\n        throw context.error = err, error.publish(context), err;\n      } finally {\n        end.publish(context);\n      }\n    });\n  }\n  tracePromise(fn, context = {}, thisArg, ...args) {\n    const { start, end, asyncStart, asyncEnd, error } = this;\n    function reject(err) {\n      return context.error = err, error.publish(context), asyncStart.publish(context), asyncEnd.publish(context), PromiseReject(err);\n    }\n    function resolve(result) {\n      return context.result = result, asyncStart.publish(context), asyncEnd.publish(context), result;\n    }\n    return start.runStores(context, () => {\n      try {\n        let promise = ReflectApply(fn, thisArg, args);\n        if (!(promise instanceof Promise))\n          promise = PromiseResolve(promise);\n        return PromisePrototypeThen(promise, resolve, reject);\n      } catch (err) {\n        throw context.error = err, error.publish(context), err;\n      } finally {\n        end.publish(context);\n      }\n    });\n  }\n  traceCallback(fn, position = -1, context = {}, thisArg, ...args) {\n    const { start, end, asyncStart, asyncEnd, error } = this;\n    function wrappedCallback(err, res) {\n      if (err)\n        context.error = err, error.publish(context);\n      else\n        context.result = res;\n      asyncStart.runStores(context, () => {\n        try {\n          if (callback)\n            return ReflectApply(callback, this, arguments);\n        } finally {\n          asyncEnd.publish(context);\n        }\n      });\n    }\n    const callback = ArrayPrototypeAt(args, position);\n    if (typeof callback !== \"function\")\n      throw new ERR_INVALID_ARG_TYPE(\"callback\", [\"function\"], callback);\n    return ArrayPrototypeSplice(args, position, 1, wrappedCallback), start.runStores(context, () => {\n      try {\n        return ReflectApply(fn, thisArg, args);\n      } catch (err) {\n        throw context.error = err, error.publish(context), err;\n      } finally {\n        end.publish(context);\n      }\n    });\n  }\n}\n\nclass ERR_INVALID_ARG_TYPE extends TypeError {\n  constructor(name, expected, actual) {\n    super(`The ${name} argument must be of type ${expected}. Received type ${typeof actual}`);\n    this.code = \"ERR_INVALID_ARG_TYPE\";\n  }\n}\n$ = {\n  channel,\n  hasSubscribers,\n  subscribe,\n  tracingChannel,\n  unsubscribe,\n  Channel\n};\nreturn $})\n"_s;
//

//
static constexpr ASCIILiteral NodeDNSCode = "(function (){\"use strict\";// src/js/out/tmp/node/dns.ts\nvar getServers = function() {\n  return dns.getServers();\n}, lookup = function(domain, options, callback) {\n  if (typeof options == \"function\")\n    callback = options;\n  if (typeof callback != \"function\")\n    @throwTypeError(\"callback must be a function\");\n  if (typeof options == \"number\")\n    options = { family: options };\n  dns.lookup(domain, options).then((res) => {\n    if (res.sort((a, b) => a.family - b.family), options\?.all)\n      callback(null, res.map(mapLookupAll));\n    else {\n      const [{ address, family }] = res;\n      callback(null, address, family);\n    }\n  }, (error) => {\n    callback(error);\n  });\n}, resolveSrv = function(hostname, callback) {\n  if (typeof callback != \"function\")\n    @throwTypeError(\"callback must be a function\");\n  dns.resolveSrv(hostname, callback).then((results) => {\n    callback(null, results);\n  }, (error) => {\n    callback(error);\n  });\n}, resolveTxt = function(hostname, callback) {\n  if (typeof callback != \"function\")\n    @throwTypeError(\"callback must be a function\");\n  dns.resolveTxt(hostname, callback).then((results) => {\n    callback(null, results);\n  }, (error) => {\n    callback(error);\n  });\n}, resolveSoa = function(hostname, callback) {\n  if (typeof callback != \"function\")\n    @throwTypeError(\"callback must be a function\");\n  dns.resolveSoa(hostname, callback).then((results) => {\n    callback(null, results);\n  }, (error) => {\n    callback(error);\n  });\n}, resolveNaptr = function(hostname, callback) {\n  if (typeof callback != \"function\")\n    @throwTypeError(\"callback must be a function\");\n  dns.resolveNaptr(hostname, callback).then((results) => {\n    callback(null, results);\n  }, (error) => {\n    callback(error);\n  });\n}, resolveMx = function(hostname, callback) {\n  if (typeof callback != \"function\")\n    @throwTypeError(\"callback must be a function\");\n  dns.resolveMx(hostname, callback).then((results) => {\n    callback(null, results);\n  }, (error) => {\n    callback(error);\n  });\n}, resolveCaa = function(hostname, callback) {\n  if (typeof callback != \"function\")\n    @throwTypeError(\"callback must be a function\");\n  dns.resolveCaa(hostname, callback).then((results) => {\n    callback(null, results);\n  }, (error) => {\n    callback(error);\n  });\n}, resolveNs = function(hostname, callback) {\n  if (typeof callback != \"function\")\n    @throwTypeError(\"callback must be a function\");\n  dns.resolveNs(hostname, callback).then((results) => {\n    callback(null, results);\n  }, (error) => {\n    callback(error);\n  });\n}, resolvePtr = function(hostname, callback) {\n  if (typeof callback != \"function\")\n    @throwTypeError(\"callback must be a function\");\n  dns.resolvePtr(hostname, callback).then((results) => {\n    callback(null, results);\n  }, (error) => {\n    callback(error);\n  });\n}, resolveCname = function(hostname, callback) {\n  if (typeof callback != \"function\")\n    @throwTypeError(\"callback must be a function\");\n  dns.resolveCname(hostname, callback).then((results) => {\n    callback(null, results);\n  }, (error) => {\n    callback(error);\n  });\n}, lookupService = function(address, port, callback) {\n  if (typeof callback != \"function\")\n    @throwTypeError(\"callback must be a function\");\n  callback(null, address, port);\n}, resolve = function(hostname, rrtype, callback) {\n  if (typeof rrtype == \"function\")\n    callback = rrtype;\n  if (typeof callback != \"function\")\n    @throwTypeError(\"callback must be a function\");\n  dns.resolve(hostname).then((results) => {\n    switch (rrtype\?.toLowerCase()) {\n      case \"a\":\n      case \"aaaa\":\n        callback(null, hostname, results.map(({ address }) => address));\n        break;\n      default:\n        callback(null, results);\n        break;\n    }\n  }, (error) => {\n    callback(error);\n  });\n}, Resolver = function(options) {\n  return new InternalResolver(options);\n}, setDefaultResultOrder = function() {\n}, setServers = function() {\n}, $, dns = Bun.dns, InternalResolver = class Resolver2 {\n  constructor(options) {\n  }\n  cancel() {\n  }\n  getServers() {\n    return [];\n  }\n  resolve(hostname, rrtype, callback) {\n    if (typeof rrtype == \"function\")\n      callback = rrtype, rrtype = null;\n    if (typeof callback != \"function\")\n      @throwTypeError(\"callback must be a function\");\n    dns.resolve(hostname).then((results) => {\n      switch (rrtype\?.toLowerCase()) {\n        case \"a\":\n        case \"aaaa\":\n          callback(null, hostname, results.map(mapResolveX));\n          break;\n        default:\n          callback(null, results);\n          break;\n      }\n    }, (error) => {\n      callback(error);\n    });\n  }\n  resolve4(hostname, options, callback) {\n    if (typeof options == \"function\")\n      callback = options, options = null;\n    if (typeof callback != \"function\")\n      @throwTypeError(\"callback must be a function\");\n    dns.lookup(hostname, { family: 4 }).then((addresses) => {\n      callback(null, options\?.ttl \? addresses : addresses.map(mapResolveX));\n    }, (error) => {\n      callback(error);\n    });\n  }\n  resolve6(hostname, options, callback) {\n    if (typeof options == \"function\")\n      callback = options, options = null;\n    if (typeof callback != \"function\")\n      @throwTypeError(\"callback must be a function\");\n    dns.lookup(hostname, { family: 6 }).then((addresses) => {\n      callback(null, options\?.ttl \? addresses : addresses.map(({ address }) => address));\n    }, (error) => {\n      callback(error);\n    });\n  }\n  resolveAny(hostname, callback) {\n    callback(null, []);\n  }\n  resolveCname(hostname, callback) {\n    if (typeof callback != \"function\")\n      @throwTypeError(\"callback must be a function\");\n    dns.resolveCname(hostname, callback).then((results) => {\n      callback(null, results);\n    }, (error) => {\n      callback(error);\n    });\n  }\n  resolveMx(hostname, callback) {\n    if (typeof callback != \"function\")\n      @throwTypeError(\"callback must be a function\");\n    dns.resolveMx(hostname, callback).then((results) => {\n      callback(null, results);\n    }, (error) => {\n      callback(error);\n    });\n  }\n  resolveNaptr(hostname, callback) {\n    if (typeof callback != \"function\")\n      @throwTypeError(\"callback must be a function\");\n    dns.resolveNaptr(hostname, callback).then((results) => {\n      callback(null, results);\n    }, (error) => {\n      callback(error);\n    });\n  }\n  resolveNs(hostname, callback) {\n    if (typeof callback != \"function\")\n      @throwTypeError(\"callback must be a function\");\n    dns.resolveNs(hostname, callback).then((results) => {\n      callback(null, results);\n    }, (error) => {\n      callback(error);\n    });\n  }\n  resolvePtr(hostname, callback) {\n    if (typeof callback != \"function\")\n      @throwTypeError(\"callback must be a function\");\n    dns.resolvePtr(hostname, callback).then((results) => {\n      callback(null, results);\n    }, (error) => {\n      callback(error);\n    });\n  }\n  resolveSrv(hostname, callback) {\n    if (typeof callback != \"function\")\n      @throwTypeError(\"callback must be a function\");\n    dns.resolveSrv(hostname, callback).then((results) => {\n      callback(null, results);\n    }, (error) => {\n      callback(error);\n    });\n  }\n  resolveCaa(hostname, callback) {\n    if (typeof callback != \"function\")\n      @throwTypeError(\"callback must be a function\");\n    dns.resolveCaa(hostname, callback).then((results) => {\n      callback(null, results);\n    }, (error) => {\n      callback(error);\n    });\n  }\n  resolveTxt(hostname, callback) {\n    if (typeof callback != \"function\")\n      @throwTypeError(\"callback must be a function\");\n    dns.resolveTxt(hostname, callback).then((results) => {\n      callback(null, results);\n    }, (error) => {\n      callback(error);\n    });\n  }\n  resolveSoa(hostname, callback) {\n    if (typeof callback != \"function\")\n      @throwTypeError(\"callback must be a function\");\n    dns.resolveSoa(hostname, callback).then((results) => {\n      callback(null, results);\n    }, (error) => {\n      callback(error);\n    });\n  }\n  reverse(ip, callback) {\n    callback(null, []);\n  }\n  setServers(servers) {\n  }\n};\nResolver.prototype = {};\nObject.setPrototypeOf(Resolver.prototype, InternalResolver.prototype);\nObject.setPrototypeOf(Resolver, InternalResolver);\nvar {\n  resolve,\n  resolve4,\n  resolve6,\n  resolveAny,\n  resolveCname,\n  resolveCaa,\n  resolveMx,\n  resolveNaptr,\n  resolveNs,\n  resolvePtr,\n  resolveSoa,\n  resolveSrv,\n  reverse,\n  resolveTxt\n} = InternalResolver.prototype, promisifyLookup = (res) => {\n  res.sort((a, b) => a.family - b.family);\n  const [{ address, family }] = res;\n  return { address, family };\n}, mapLookupAll = (res) => {\n  const { address, family } = res;\n  return { address, family };\n}, promisifyLookupAll = (res) => {\n  return res.sort((a, b) => a.family - b.family), res.map(mapLookupAll);\n}, mapResolveX = (a) => a.address, promisifyResolveX = (res) => {\n  return res\?.map(mapResolveX);\n}, promises = {\n  lookup(domain, options) {\n    if (options\?.all)\n      return dns.lookup(domain, options).then(promisifyLookupAll);\n    return dns.lookup(domain, options).then(promisifyLookup);\n  },\n  lookupService(address, port) {\n    return Promise.resolve([]);\n  },\n  resolve(hostname, rrtype) {\n    if (typeof rrtype !== \"string\")\n      rrtype = null;\n    switch (rrtype\?.toLowerCase()) {\n      case \"a\":\n      case \"aaaa\":\n        return dns.resolve(hostname, rrtype).then(promisifyLookup);\n      default:\n        return dns.resolve(hostname, rrtype);\n    }\n  },\n  resolve4(hostname, options) {\n    if (options\?.ttl)\n      return dns.lookup(hostname, { family: 4 });\n    return dns.lookup(hostname, { family: 4 }).then(promisifyResolveX);\n  },\n  resolve6(hostname, options) {\n    if (options\?.ttl)\n      return dns.lookup(hostname, { family: 6 });\n    return dns.lookup(hostname, { family: 6 }).then(promisifyResolveX);\n  },\n  resolveSrv(hostname) {\n    return dns.resolveSrv(hostname);\n  },\n  resolveTxt(hostname) {\n    return dns.resolveTxt(hostname);\n  },\n  resolveSoa(hostname) {\n    return dns.resolveSoa(hostname);\n  },\n  resolveNaptr(hostname) {\n    return dns.resolveNaptr(hostname);\n  },\n  resolveMx(hostname) {\n    return dns.resolveMx(hostname);\n  },\n  resolveCaa(hostname) {\n    return dns.resolveCaa(hostname);\n  },\n  resolveNs(hostname) {\n    return dns.resolveNs(hostname);\n  },\n  resolvePtr(hostname) {\n    return dns.resolvePtr(hostname);\n  },\n  resolveCname(hostname) {\n    return dns.resolveCname(hostname);\n  },\n  Resolver: class Resolver3 {\n    constructor(options) {\n    }\n    cancel() {\n    }\n    getServers() {\n      return [];\n    }\n    resolve(hostname, rrtype) {\n      if (typeof rrtype !== \"string\")\n        rrtype = null;\n      switch (rrtype\?.toLowerCase()) {\n        case \"a\":\n        case \"aaaa\":\n          return dns.resolve(hostname, rrtype).then(promisifyLookup);\n        default:\n          return dns.resolve(hostname, rrtype);\n      }\n    }\n    resolve4(hostname, options) {\n      if (options\?.ttl)\n        return dns.lookup(hostname, { family: 4 });\n      return dns.lookup(hostname, { family: 4 }).then(promisifyResolveX);\n    }\n    resolve6(hostname, options) {\n      if (options\?.ttl)\n        return dns.lookup(hostname, { family: 6 });\n      return dns.lookup(hostname, { family: 6 }).then(promisifyResolveX);\n    }\n    resolveAny(hostname) {\n      return Promise.resolve([]);\n    }\n    resolveCname(hostname) {\n      return dns.resolveCname(hostname);\n    }\n    resolveMx(hostname) {\n      return dns.resolveMx(hostname);\n    }\n    resolveNaptr(hostname) {\n      return dns.resolveNaptr(hostname);\n    }\n    resolveNs(hostname) {\n      return dns.resolveNs(hostname);\n    }\n    resolvePtr(hostname) {\n      return dns.resolvePtr(hostname);\n    }\n    resolveSoa(hostname) {\n      return dns.resolveSoa(hostname);\n    }\n    resolveSrv(hostname) {\n      return dns.resolveSrv(hostname);\n    }\n    resolveCaa(hostname) {\n      return dns.resolveCaa(hostname);\n    }\n    resolveTxt(hostname) {\n      return dns.resolveTxt(hostname);\n    }\n    reverse(ip) {\n      return Promise.resolve([]);\n    }\n    setServers(servers) {\n    }\n  }\n};\nfor (let key of [\"resolveAny\", \"reverse\"])\n  promises[key] = () => Promise.resolve(void 0);\n$ = {\n  ADDRCONFIG: 0,\n  ALL: 1,\n  V4MAPPED: 2,\n  NODATA: \"DNS_ENODATA\",\n  FORMERR: \"DNS_EFORMERR\",\n  SERVFAIL: \"DNS_ESERVFAIL\",\n  NOTFOUND: \"DNS_ENOTFOUND\",\n  NOTIMP: \"DNS_ENOTIMP\",\n  REFUSED: \"DNS_EREFUSED\",\n  BADQUERY: \"DNS_EBADQUERY\",\n  BADNAME: \"DNS_EBADNAME\",\n  BADFAMILY: \"DNS_EBADFAMILY\",\n  BADRESP: \"DNS_EBADRESP\",\n  CONNREFUSED: \"DNS_ECONNREFUSED\",\n  TIMEOUT: \"DNS_ETIMEOUT\",\n  EOF: \"DNS_EEOF\",\n  FILE: \"DNS_EFILE\",\n  NOMEM: \"DNS_ENOMEM\",\n  DESTRUCTION: \"DNS_EDESTRUCTION\",\n  BADSTR: \"DNS_EBADSTR\",\n  BADFLAGS: \"DNS_EBADFLAGS\",\n  NONAME: \"DNS_ENONAME\",\n  BADHINTS: \"DNS_EBADHINTS\",\n  NOTINITIALIZED: \"DNS_ENOTINITIALIZED\",\n  LOADIPHLPAPI: \"DNS_ELOADIPHLPAPI\",\n  ADDRGETNETWORKPARAMS: \"DNS_EADDRGETNETWORKPARAMS\",\n  CANCELLED: \"DNS_ECANCELLED\",\n  lookup,\n  lookupService,\n  Resolver,\n  setServers,\n  setDefaultResultOrder,\n  resolve,\n  reverse,\n  resolve4,\n  resolve6,\n  resolveAny,\n  resolveCname,\n  resolveCaa,\n  resolveMx,\n  resolveNs,\n  resolvePtr,\n  resolveSoa,\n  resolveSrv,\n  resolveTxt,\n  resolveNaptr,\n  promises,\n  getServers\n};\nreturn $})\n"_s;
//

//
static constexpr ASCIILiteral NodeDNSPromisesCode = "(function (){\"use strict\";// src/js/out/tmp/node/dns.promises.ts\nreturn (@getInternalField(@internalModuleRegistry, 13) || @createInternalModuleById(13)).promises})\n"_s;
//

//
static constexpr ASCIILiteral NodeDomainCode = "(function (){\"use strict\";// src/js/out/tmp/node/domain.ts\nvar EventEmitter = @getInternalField(@internalModuleRegistry, 16) || @createInternalModuleById(16), domain = {};\ndomain.createDomain = domain.create = function() {\n  var d = new EventEmitter;\n  function emitError(e) {\n    d.emit(\"error\", e);\n  }\n  return d.add = function(emitter) {\n    emitter.on(\"error\", emitError);\n  }, d.remove = function(emitter) {\n    emitter.removeListener(\"error\", emitError);\n  }, d.bind = function(fn) {\n    return function() {\n      var args = Array.prototype.slice.call(arguments);\n      try {\n        fn.apply(null, args);\n      } catch (err) {\n        emitError(err);\n      }\n    };\n  }, d.intercept = function(fn) {\n    return function(err) {\n      if (err)\n        emitError(err);\n      else {\n        var args = Array.prototype.slice.call(arguments, 1);\n        try {\n          fn.apply(null, args);\n        } catch (err2) {\n          emitError(err2);\n        }\n      }\n    };\n  }, d.run = function(fn) {\n    try {\n      fn();\n    } catch (err) {\n      emitError(err);\n    }\n    return this;\n  }, d.dispose = function() {\n    return this.removeAllListeners(), this;\n  }, d.enter = d.exit = function() {\n    return this;\n  }, d;\n};\nreturn domain})\n"_s;
//

//
static constexpr ASCIILiteral NodeEventsCode = "(function (){\"use strict\";// src/js/out/tmp/node/events.ts\nvar emitError = function(emitter, args) {\n  var { _events: events } = emitter;\n  if (args[0] \?\?= new Error(\"Unhandled error.\"), !events)\n    throw args[0];\n  var errorMonitor = events[kErrorMonitor];\n  if (errorMonitor)\n    for (var handler of ArrayPrototypeSlice.call(errorMonitor))\n      handler.apply(emitter, args);\n  var handlers = events.error;\n  if (!handlers)\n    throw args[0];\n  for (var handler of ArrayPrototypeSlice.call(handlers))\n    handler.apply(emitter, args);\n  return !0;\n}, addCatch = function(emitter, promise, type, args) {\n  promise.then(void 0, function(err) {\n    process.nextTick(emitUnhandledRejectionOrErr, emitter, err, type, args);\n  });\n}, emitUnhandledRejectionOrErr = function(emitter, err, type, args) {\n  if (typeof emitter[kRejection] === \"function\")\n    emitter[kRejection](err, type, ...args);\n  else\n    try {\n      emitter[kCapture] = !1, emitter.emit(\"error\", err);\n    } finally {\n      emitter[kCapture] = !0;\n    }\n}, overflowWarning = function(emitter, type, handlers) {\n  handlers.warned = !0;\n  const warn = new Error(`Possible EventEmitter memory leak detected. ${handlers.length} ${String(type)} listeners ` + `added to [${emitter.constructor.name}]. Use emitter.setMaxListeners() to increase limit`);\n  warn.name = \"MaxListenersExceededWarning\", warn.emitter = emitter, warn.type = type, warn.count = handlers.length, process.emitWarning(warn);\n}, onceWrapper = function(type, listener, ...args) {\n  this.removeListener(type, listener), listener.apply(this, args);\n}, once = function(emitter, type, options) {\n  var signal = options\?.signal;\n  if (validateAbortSignal(signal, \"options.signal\"), signal\?.aborted)\n    throw new AbortError(void 0, { cause: signal\?.reason });\n  return new Promise((resolve, reject) => {\n    const errorListener = (err) => {\n      if (emitter.removeListener(type, resolver), signal != null)\n        eventTargetAgnosticRemoveListener(signal, \"abort\", abortListener);\n      reject(err);\n    }, resolver = (...args) => {\n      if (typeof emitter.removeListener === \"function\")\n        emitter.removeListener(\"error\", errorListener);\n      if (signal != null)\n        eventTargetAgnosticRemoveListener(signal, \"abort\", abortListener);\n      resolve(args);\n    };\n    if (eventTargetAgnosticAddListener(emitter, type, resolver, { once: !0 }), type !== \"error\" && typeof emitter.once === \"function\")\n      emitter.once(\"error\", errorListener);\n    function abortListener() {\n      eventTargetAgnosticRemoveListener(emitter, type, resolver), eventTargetAgnosticRemoveListener(emitter, \"error\", errorListener), reject(new AbortError(void 0, { cause: signal\?.reason }));\n    }\n    if (signal != null)\n      eventTargetAgnosticAddListener(signal, \"abort\", abortListener, { once: !0 });\n  });\n}, on = function(emitter, type, options) {\n  var { signal, close, highWatermark = Number.MAX_SAFE_INTEGER, lowWatermark = 1 } = options || {};\n  throwNotImplemented(\"events.on\", 2679);\n}, getEventListeners = function(emitter, type) {\n  if (emitter instanceof EventTarget)\n    throwNotImplemented(\"getEventListeners with an EventTarget\", 2678);\n  return emitter.listeners(type);\n}, setMaxListeners = function(n, ...eventTargets) {\n  validateNumber(n, \"setMaxListeners\", 0);\n  var length;\n  if (eventTargets && (length = eventTargets.length))\n    for (let i = 0;i < length; i++)\n      eventTargets[i].setMaxListeners(n);\n  else\n    defaultMaxListeners = n;\n}, listenerCount = function(emitter, type) {\n  return emitter.listenerCount(type);\n}, eventTargetAgnosticRemoveListener = function(emitter, name, listener, flags) {\n  if (typeof emitter.removeListener === \"function\")\n    emitter.removeListener(name, listener);\n  else\n    emitter.removeEventListener(name, listener, flags);\n}, eventTargetAgnosticAddListener = function(emitter, name, listener, flags) {\n  if (typeof emitter.on === \"function\")\n    emitter.on(name, listener);\n  else\n    emitter.addEventListener(name, listener);\n}, ERR_INVALID_ARG_TYPE = function(name, type, value) {\n  const err = @makeTypeError(`The \"${name}\" argument must be of type ${type}. Received ${value}`);\n  return err.code = \"ERR_INVALID_ARG_TYPE\", err;\n}, ERR_OUT_OF_RANGE = function(name, range, value) {\n  const err = new RangeError(`The \"${name}\" argument is out of range. It must be ${range}. Received ${value}`);\n  return err.code = \"ERR_OUT_OF_RANGE\", err;\n}, validateAbortSignal = function(signal, name) {\n  if (signal !== void 0 && (signal === null || typeof signal !== \"object\" || !(\"aborted\" in signal)))\n    throw new ERR_INVALID_ARG_TYPE(name, \"AbortSignal\", signal);\n}, validateNumber = function(value, name, min = void 0, max) {\n  if (typeof value !== \"number\")\n    throw new ERR_INVALID_ARG_TYPE(name, \"number\", value);\n  if (min != null && value < min || max != null && value > max || (min != null || max != null) && Number.isNaN(value))\n    throw new ERR_OUT_OF_RANGE(name, `${min != null \? `>= ${min}` : \"\"}${min != null && max != null \? \" && \" : \"\"}${max != null \? `<= ${max}` : \"\"}`, value);\n}, checkListener = function(listener) {\n  if (typeof listener !== \"function\")\n    @throwTypeError(\"The listener must be a function\");\n}, { throwNotImplemented } = @getInternalField(@internalModuleRegistry, 3) || @createInternalModuleById(3), SymbolFor = Symbol.for, kCapture = Symbol(\"kCapture\"), kErrorMonitor = SymbolFor(\"events.errorMonitor\"), kMaxEventTargetListeners = Symbol(\"events.maxEventTargetListeners\"), kMaxEventTargetListenersWarned = Symbol(\"events.maxEventTargetListenersWarned\"), kWatermarkData = SymbolFor(\"nodejs.watermarkData\"), kRejection = SymbolFor(\"nodejs.rejection\"), captureRejectionSymbol = SymbolFor(\"nodejs.rejection\"), ArrayPrototypeSlice = Array.prototype.slice, defaultMaxListeners = 10, EventEmitter = function EventEmitter2(opts) {\n  if (this._events === void 0 || this._events === this.__proto__._events)\n    this._events = { __proto__: null }, this._eventsCount = 0;\n  if (this._maxListeners \?\?= void 0, this[kCapture] = opts\?.captureRejections \? Boolean(opts\?.captureRejections) : EventEmitterPrototype[kCapture])\n    this.emit = emitWithRejectionCapture;\n}, EventEmitterPrototype = EventEmitter.prototype = {};\nEventEmitterPrototype._events = void 0;\nEventEmitterPrototype._eventsCount = 0;\nEventEmitterPrototype._maxListeners = void 0;\nEventEmitterPrototype.setMaxListeners = function setMaxListeners2(n) {\n  return validateNumber(n, \"setMaxListeners\", 0), this._maxListeners = n, this;\n};\nEventEmitterPrototype.getMaxListeners = function getMaxListeners() {\n  return this._maxListeners \?\? defaultMaxListeners;\n};\nvar emitWithoutRejectionCapture = function emit(type, ...args) {\n  if (type === \"error\")\n    return emitError(this, args);\n  var { _events: events } = this;\n  if (events === void 0)\n    return !1;\n  var handlers = events[type];\n  if (handlers === void 0)\n    return !1;\n  for (var handler of [...handlers])\n    handler.apply(this, args);\n  return !0;\n}, emitWithRejectionCapture = function emit2(type, ...args) {\n  if (type === \"error\")\n    return emitError(this, args);\n  var { _events: events } = this;\n  if (events === void 0)\n    return !1;\n  var handlers = events[type];\n  if (handlers === void 0)\n    return !1;\n  for (var handler of [...handlers]) {\n    var result = handler.apply(this, args);\n    if (result !== void 0 && @isPromise(result))\n      addCatch(this, result, type, args);\n  }\n  return !0;\n};\nEventEmitterPrototype.emit = emitWithoutRejectionCapture;\nEventEmitterPrototype.addListener = function addListener(type, fn) {\n  checkListener(fn);\n  var events = this._events;\n  if (!events)\n    events = this._events = { __proto__: null }, this._eventsCount = 0;\n  else if (events.newListener)\n    this.emit(\"newListener\", type, fn.listener \?\? fn);\n  var handlers = events[type];\n  if (!handlers)\n    events[type] = [fn], this._eventsCount++;\n  else {\n    handlers.push(fn);\n    var m = this._maxListeners \?\? defaultMaxListeners;\n    if (m > 0 && handlers.length > m && !handlers.warned)\n      overflowWarning(this, type, handlers);\n  }\n  return this;\n};\nEventEmitterPrototype.on = EventEmitterPrototype.addListener;\nEventEmitterPrototype.prependListener = function prependListener(type, fn) {\n  checkListener(fn);\n  var events = this._events;\n  if (!events)\n    events = this._events = { __proto__: null }, this._eventsCount = 0;\n  else if (events.newListener)\n    this.emit(\"newListener\", type, fn.listener \?\? fn);\n  var handlers = events[type];\n  if (!handlers)\n    events[type] = [fn], this._eventsCount++;\n  else {\n    handlers.unshift(fn);\n    var m = this._maxListeners \?\? defaultMaxListeners;\n    if (m > 0 && handlers.length > m && !handlers.warned)\n      overflowWarning(this, type, handlers);\n  }\n  return this;\n};\nEventEmitterPrototype.once = function once2(type, fn) {\n  checkListener(fn);\n  const bound = onceWrapper.bind(this, type, fn);\n  return bound.listener = fn, this.addListener(type, bound), this;\n};\nEventEmitterPrototype.prependOnceListener = function prependOnceListener(type, fn) {\n  checkListener(fn);\n  const bound = onceWrapper.bind(this, type, fn);\n  return bound.listener = fn, this.prependListener(type, bound), this;\n};\nEventEmitterPrototype.removeListener = function removeListener(type, fn) {\n  checkListener(fn);\n  var { _events: events } = this;\n  if (!events)\n    return this;\n  var handlers = events[type];\n  if (!handlers)\n    return this;\n  var length = handlers.length;\n  let position = -1;\n  for (let i = length - 1;i >= 0; i--)\n    if (handlers[i] === fn || handlers[i].listener === fn) {\n      position = i;\n      break;\n    }\n  if (position < 0)\n    return this;\n  if (position === 0)\n    handlers.shift();\n  else\n    handlers.splice(position, 1);\n  if (handlers.length === 0)\n    delete events[type], this._eventsCount--;\n  return this;\n};\nEventEmitterPrototype.off = EventEmitterPrototype.removeListener;\nEventEmitterPrototype.removeAllListeners = function removeAllListeners(type) {\n  var { _events: events } = this;\n  if (type && events) {\n    if (events[type])\n      delete events[type], this._eventsCount--;\n  } else\n    this._events = { __proto__: null };\n  return this;\n};\nEventEmitterPrototype.listeners = function listeners(type) {\n  var { _events: events } = this;\n  if (!events)\n    return [];\n  var handlers = events[type];\n  if (!handlers)\n    return [];\n  return handlers.map((x) => x.listener \?\? x);\n};\nEventEmitterPrototype.rawListeners = function rawListeners(type) {\n  var { _events } = this;\n  if (!_events)\n    return [];\n  var handlers = _events[type];\n  if (!handlers)\n    return [];\n  return handlers.slice();\n};\nEventEmitterPrototype.listenerCount = function listenerCount2(type) {\n  var { _events: events } = this;\n  if (!events)\n    return 0;\n  return events[type]\?.length \?\? 0;\n};\nEventEmitterPrototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 \? Reflect.ownKeys(this._events) : [];\n};\nEventEmitterPrototype[kCapture] = !1;\n\nclass AbortError extends Error {\n  constructor(message = \"The operation was aborted\", options = void 0) {\n    if (options !== void 0 && typeof options !== \"object\")\n      throw new codes.ERR_INVALID_ARG_TYPE(\"options\", \"Object\", options);\n    super(message, options);\n    this.code = \"ABORT_ERR\", this.name = \"AbortError\";\n  }\n}\nvar AsyncResource = null;\n\nclass EventEmitterAsyncResource extends EventEmitter {\n  triggerAsyncId;\n  asyncResource;\n  constructor(options) {\n    if (!AsyncResource)\n      AsyncResource = (@getInternalField(@internalModuleRegistry, 6) || @createInternalModuleById(6)).AsyncResource;\n    var { captureRejections = !1, triggerAsyncId, name = new.target.name, requireManualDestroy } = options || {};\n    super({ captureRejections });\n    this.triggerAsyncId = triggerAsyncId \?\? 0, this.asyncResource = new AsyncResource(name, { triggerAsyncId, requireManualDestroy });\n  }\n  emit(...args) {\n    this.asyncResource.runInAsyncScope(() => super.emit(...args));\n  }\n  emitDestroy() {\n    this.asyncResource.emitDestroy();\n  }\n}\nObject.defineProperties(EventEmitter, {\n  captureRejections: {\n    get() {\n      return EventEmitterPrototype[kCapture];\n    },\n    set(value) {\n      validateBoolean(value, \"EventEmitter.captureRejections\"), EventEmitterPrototype[kCapture] = value;\n    },\n    enumerable: !0\n  },\n  defaultMaxListeners: {\n    enumerable: !0,\n    get: () => {\n      return defaultMaxListeners;\n    },\n    set: (arg) => {\n      validateNumber(arg, \"defaultMaxListeners\", 0), defaultMaxListeners = arg;\n    }\n  },\n  kMaxEventTargetListeners: {\n    value: kMaxEventTargetListeners,\n    enumerable: !1,\n    configurable: !1,\n    writable: !1\n  },\n  kMaxEventTargetListenersWarned: {\n    value: kMaxEventTargetListenersWarned,\n    enumerable: !1,\n    configurable: !1,\n    writable: !1\n  }\n});\nObject.assign(EventEmitter, {\n  once,\n  on,\n  getEventListeners,\n  setMaxListeners,\n  EventEmitter,\n  usingDomains: !1,\n  captureRejectionSymbol,\n  EventEmitterAsyncResource,\n  errorMonitor: kErrorMonitor,\n  setMaxListeners,\n  init: EventEmitter,\n  listenerCount\n});\nreturn EventEmitter})\n"_s;
//

//
static constexpr ASCIILiteral NodeFSCode = "(function (){\"use strict\";// src/js/out/tmp/node/fs.ts\nvar callbackify = function(fsFunction, args) {\n  try {\n    const result = fsFunction.apply(fs, args.slice(0, args.length - 1)), callback = args[args.length - 1];\n    if (typeof callback === \"function\")\n      queueMicrotask(() => callback(null, result));\n  } catch (e) {\n    const callback = args[args.length - 1];\n    if (typeof callback === \"function\")\n      queueMicrotask(() => callback(e));\n  }\n}, createReadStream = function(path, options) {\n  return new ReadStream(path, options);\n}, createWriteStream = function(path, options) {\n  return new WriteStream(path, options);\n}, $, ReadStream, WriteStream, EventEmitter = @getInternalField(@internalModuleRegistry, 16) || @createInternalModuleById(16), promises = @getInternalField(@internalModuleRegistry, 18) || @createInternalModuleById(18), Stream = @getInternalField(@internalModuleRegistry, 35) || @createInternalModuleById(35), { isArrayBufferView } = @requireNativeModule(\"node:util/types\"), fs = Bun.fs();\n\nclass FSWatcher extends EventEmitter {\n  #watcher;\n  #listener;\n  constructor(path, options, listener) {\n    super();\n    if (typeof options === \"function\")\n      listener = options, options = {};\n    else if (typeof options === \"string\")\n      options = { encoding: options };\n    if (typeof listener !== \"function\")\n      listener = () => {\n      };\n    this.#listener = listener;\n    try {\n      this.#watcher = fs.watch(path, options || {}, this.#onEvent.bind(this));\n    } catch (e) {\n      if (!e.message\?.startsWith(\"FileNotFound\"))\n        throw e;\n      const notFound = new Error(`ENOENT: no such file or directory, watch '${path}'`);\n      throw notFound.code = \"ENOENT\", notFound.errno = -2, notFound.path = path, notFound.syscall = \"watch\", notFound.filename = path, notFound;\n    }\n  }\n  #onEvent(eventType, filenameOrError) {\n    if (eventType === \"error\" || eventType === \"close\")\n      this.emit(eventType, filenameOrError);\n    else\n      this.emit(\"change\", eventType, filenameOrError), this.#listener(eventType, filenameOrError);\n  }\n  close() {\n    this.#watcher\?.close(), this.#watcher = null;\n  }\n  ref() {\n    this.#watcher\?.ref();\n  }\n  unref() {\n    this.#watcher\?.unref();\n  }\n}\nvar access = function access2(...args) {\n  callbackify(fs.accessSync, args);\n}, appendFile = function appendFile2(...args) {\n  callbackify(fs.appendFileSync, args);\n}, close = function close2(...args) {\n  callbackify(fs.closeSync, args);\n}, rm = function rm2(...args) {\n  callbackify(fs.rmSync, args);\n}, rmdir = function rmdir2(...args) {\n  callbackify(fs.rmdirSync, args);\n}, copyFile = function copyFile2(...args) {\n  callbackify(fs.copyFileSync, args);\n}, exists = function exists2(...args) {\n  callbackify(fs.existsSync, args);\n}, chown = function chown2(...args) {\n  callbackify(fs.chownSync, args);\n}, chmod = function chmod2(...args) {\n  callbackify(fs.chmodSync, args);\n}, fchmod = function fchmod2(...args) {\n  callbackify(fs.fchmodSync, args);\n}, fchown = function fchown2(...args) {\n  callbackify(fs.fchownSync, args);\n}, fstat = function fstat2(...args) {\n  callbackify(fs.fstatSync, args);\n}, fsync = function fsync2(...args) {\n  callbackify(fs.fsyncSync, args);\n}, ftruncate = function ftruncate2(...args) {\n  callbackify(fs.ftruncateSync, args);\n}, futimes = function futimes2(...args) {\n  callbackify(fs.futimesSync, args);\n}, lchmod = function lchmod2(...args) {\n  callbackify(fs.lchmodSync, args);\n}, lchown = function lchown2(...args) {\n  callbackify(fs.lchownSync, args);\n}, link = function link2(...args) {\n  callbackify(fs.linkSync, args);\n}, mkdir = function mkdir2(...args) {\n  callbackify(fs.mkdirSync, args);\n}, mkdtemp = function mkdtemp2(...args) {\n  callbackify(fs.mkdtempSync, args);\n}, open = function open2(...args) {\n  callbackify(fs.openSync, args);\n}, read = function read2(fd, buffer, offsetOrOptions, length, position, callback) {\n  let offset = offsetOrOptions, params = null;\n  if (arguments.length <= 4) {\n    if (arguments.length === 4)\n      callback = length, params = offsetOrOptions;\n    else if (arguments.length === 3) {\n      if (!isArrayBufferView(buffer))\n        params = buffer, { buffer = Buffer.alloc(16384) } = params \?\? {};\n      callback = offsetOrOptions;\n    } else\n      callback = buffer, buffer = Buffer.alloc(16384);\n    ({ offset = 0, length = buffer\?.byteLength - offset, position = null } = params \?\? {});\n  }\n  queueMicrotask(() => {\n    try {\n      var bytesRead = fs.readSync(fd, buffer, offset, length, position);\n    } catch (e) {\n      callback(e);\n    }\n    callback(null, bytesRead, buffer);\n  });\n}, write = function write2(...args) {\n  callbackify(fs.writeSync, args);\n}, readdir = function readdir2(...args) {\n  const callback = args[args.length - 1];\n  if (typeof callback !== \"function\")\n    @throwTypeError(\"Callback must be a function\");\n  fs.readdir(...args).then((result) => callback(null, result), callback);\n}, readFile = function readFile2(...args) {\n  const callback = args[args.length - 1];\n  if (typeof callback !== \"function\")\n    @throwTypeError(\"Callback must be a function\");\n  fs.readFile(...args).then((result) => callback(null, result), callback);\n}, writeFile = function writeFile2(...args) {\n  callbackify(fs.writeFileSync, args);\n}, readlink = function readlink2(...args) {\n  callbackify(fs.readlinkSync, args);\n}, realpath = function realpath2(...args) {\n  const callback = args[args.length - 1];\n  if (typeof callback !== \"function\")\n    @throwTypeError(\"Callback must be a function\");\n  fs.realpath(...args).then((result) => callback(null, result), callback);\n}, rename = function rename2(...args) {\n  callbackify(fs.renameSync, args);\n}, lstat = function lstat2(...args) {\n  const callback = args[args.length - 1];\n  if (typeof callback !== \"function\")\n    @throwTypeError(\"Callback must be a function\");\n  fs.lstat(...args).then((result) => callback(null, result), callback);\n}, stat = function stat2(...args) {\n  const callback = args[args.length - 1];\n  if (typeof callback !== \"function\")\n    @throwTypeError(\"Callback must be a function\");\n  fs.stat(...args).then((result) => callback(null, result), callback);\n}, symlink = function symlink2(...args) {\n  callbackify(fs.symlinkSync, args);\n}, truncate = function truncate2(...args) {\n  callbackify(fs.truncateSync, args);\n}, unlink = function unlink2(...args) {\n  callbackify(fs.unlinkSync, args);\n}, utimes = function utimes2(...args) {\n  callbackify(fs.utimesSync, args);\n}, lutimes = function lutimes2(...args) {\n  callbackify(fs.lutimesSync, args);\n}, accessSync = fs.accessSync.bind(fs), appendFileSync = fs.appendFileSync.bind(fs), closeSync = fs.closeSync.bind(fs), copyFileSync = fs.copyFileSync.bind(fs), existsSync = fs.existsSync.bind(fs), chownSync = fs.chownSync.bind(fs), chmodSync = fs.chmodSync.bind(fs), fchmodSync = fs.fchmodSync.bind(fs), fchownSync = fs.fchownSync.bind(fs), fstatSync = fs.fstatSync.bind(fs), fsyncSync = fs.fsyncSync.bind(fs), ftruncateSync = fs.ftruncateSync.bind(fs), futimesSync = fs.futimesSync.bind(fs), lchmodSync = fs.lchmodSync.bind(fs), lchownSync = fs.lchownSync.bind(fs), linkSync = fs.linkSync.bind(fs), lstatSync = fs.lstatSync.bind(fs), mkdirSync = fs.mkdirSync.bind(fs), mkdtempSync = fs.mkdtempSync.bind(fs), openSync = fs.openSync.bind(fs), readSync = fs.readSync.bind(fs), writeSync = fs.writeSync.bind(fs), readdirSync = fs.readdirSync.bind(fs), readFileSync = fs.readFileSync.bind(fs), writeFileSync = fs.writeFileSync.bind(fs), readlinkSync = fs.readlinkSync.bind(fs), realpathSync = fs.realpathSync.bind(fs), renameSync = fs.renameSync.bind(fs), statSync = fs.statSync.bind(fs), symlinkSync = fs.symlinkSync.bind(fs), truncateSync = fs.truncateSync.bind(fs), unlinkSync = fs.unlinkSync.bind(fs), utimesSync = fs.utimesSync.bind(fs), lutimesSync = fs.lutimesSync.bind(fs), rmSync = fs.rmSync.bind(fs), rmdirSync = fs.rmdirSync.bind(fs), writev = (fd, buffers, position, callback) => {\n  if (typeof position === \"function\")\n    callback = position, position = null;\n  queueMicrotask(() => {\n    try {\n      var written = fs.writevSync(fd, buffers, position);\n    } catch (e) {\n      callback(e);\n    }\n    callback(null, written, buffers);\n  });\n}, writevSync = fs.writevSync.bind(fs), readv = (fd, buffers, position, callback) => {\n  if (typeof position === \"function\")\n    callback = position, position = null;\n  queueMicrotask(() => {\n    try {\n      var written = fs.readvSync(fd, buffers, position);\n    } catch (e) {\n      callback(e);\n    }\n    callback(null, written, buffers);\n  });\n}, readvSync = fs.readvSync.bind(fs), Dirent = fs.Dirent, Stats = fs.Stats, watch = function watch2(path, options, listener) {\n  return new FSWatcher(path, options, listener);\n}, readStreamPathFastPathSymbol = Symbol.for(\"Bun.Node.readStreamPathFastPath\"), readStreamSymbol = Symbol.for(\"Bun.NodeReadStream\"), readStreamPathOrFdSymbol = Symbol.for(\"Bun.NodeReadStreamPathOrFd\"), writeStreamSymbol = Symbol.for(\"Bun.NodeWriteStream\"), writeStreamPathFastPathSymbol = Symbol.for(\"Bun.NodeWriteStreamFastPath\"), writeStreamPathFastPathCallSymbol = Symbol.for(\"Bun.NodeWriteStreamFastPathCall\"), kIoDone = Symbol.for(\"kIoDone\"), defaultReadStreamOptions = {\n  file: void 0,\n  fd: void 0,\n  flags: \"r\",\n  encoding: void 0,\n  mode: 438,\n  autoClose: !0,\n  emitClose: !0,\n  start: 0,\n  end: Infinity,\n  highWaterMark: 65536,\n  fs: {\n    read,\n    open: (path, flags, mode, cb) => {\n      var fd;\n      try {\n        fd = openSync(path, flags, mode);\n      } catch (e) {\n        cb(e);\n        return;\n      }\n      cb(null, fd);\n    },\n    openSync,\n    close\n  },\n  autoDestroy: !0\n}, ReadStreamClass;\nReadStream = function(InternalReadStream) {\n  ReadStreamClass = InternalReadStream, Object.defineProperty(ReadStreamClass.prototype, Symbol.toStringTag, {\n    value: \"ReadStream\",\n    enumerable: !1\n  });\n  function ReadStream3(path, options) {\n    return new InternalReadStream(path, options);\n  }\n  return ReadStream3.prototype = InternalReadStream.prototype, Object.defineProperty(ReadStream3, Symbol.hasInstance, {\n    value(instance) {\n      return instance instanceof InternalReadStream;\n    }\n  });\n}(class ReadStream2 extends Stream._getNativeReadableStreamPrototype(2, Stream.Readable) {\n  constructor(pathOrFd, options = defaultReadStreamOptions) {\n    if (typeof options !== \"object\" || !options)\n      @throwTypeError(\"Expected options to be an object\");\n    var {\n      flags = defaultReadStreamOptions.flags,\n      encoding = defaultReadStreamOptions.encoding,\n      mode = defaultReadStreamOptions.mode,\n      autoClose = defaultReadStreamOptions.autoClose,\n      emitClose = defaultReadStreamOptions.emitClose,\n      start = defaultReadStreamOptions.start,\n      end = defaultReadStreamOptions.end,\n      autoDestroy = defaultReadStreamOptions.autoClose,\n      fs: fs2 = defaultReadStreamOptions.fs,\n      highWaterMark = defaultReadStreamOptions.highWaterMark\n    } = options;\n    if (pathOrFd\?.constructor\?.name === \"URL\")\n      pathOrFd = Bun.fileURLToPath(pathOrFd);\n    var tempThis = {};\n    if (typeof pathOrFd === \"string\") {\n      if (pathOrFd.startsWith(\"file://\"))\n        pathOrFd = Bun.fileURLToPath(pathOrFd);\n      if (pathOrFd.length === 0)\n        @throwTypeError(\"Expected path to be a non-empty string\");\n      tempThis.path = tempThis.file = tempThis[readStreamPathOrFdSymbol] = pathOrFd;\n    } else if (typeof pathOrFd === \"number\") {\n      if (pathOrFd |= 0, pathOrFd < 0)\n        @throwTypeError(\"Expected fd to be a positive integer\");\n      tempThis.fd = tempThis[readStreamPathOrFdSymbol] = pathOrFd, tempThis.autoClose = !1;\n    } else\n      @throwTypeError(\"Expected a path or file descriptor\");\n    if (!tempThis.fd)\n      tempThis.fd = fs2.openSync(pathOrFd, flags, mode);\n    var fileRef = Bun.file(tempThis.fd), stream = fileRef.stream(), native = @direct(stream);\n    if (!native)\n      throw new Error(\"no native readable stream\");\n    var { stream: ptr } = native;\n    super(ptr, {\n      ...options,\n      encoding,\n      autoDestroy,\n      autoClose,\n      emitClose,\n      highWaterMark\n    });\n    if (Object.assign(this, tempThis), this.#fileRef = fileRef, this.end = end, this._read = this.#internalRead, this.start = start, this.flags = flags, this.mode = mode, this.emitClose = emitClose, this[readStreamPathFastPathSymbol] = start === 0 && end === Infinity && autoClose && fs2 === defaultReadStreamOptions.fs && (encoding === \"buffer\" || encoding === \"binary\" || encoding == null || encoding === \"utf-8\" || encoding === \"utf8\"), this._readableState.autoClose = autoDestroy = autoClose, this._readableState.highWaterMark = highWaterMark, start !== void 0)\n      this.pos = start;\n  }\n  #fileRef;\n  #fs;\n  file;\n  path;\n  fd = null;\n  flags;\n  mode;\n  start;\n  end;\n  pos;\n  bytesRead = 0;\n  #fileSize = -1;\n  _read;\n  [readStreamSymbol] = !0;\n  [readStreamPathOrFdSymbol];\n  [readStreamPathFastPathSymbol];\n  _construct(callback) {\n    if (super._construct)\n      super._construct(callback);\n    else\n      callback();\n    this.emit(\"open\", this.fd), this.emit(\"ready\");\n  }\n  _destroy(err, cb) {\n    super._destroy(err, cb);\n    try {\n      var fd = this.fd;\n      if (this[readStreamPathFastPathSymbol] = !1, !fd)\n        cb(err);\n      else\n        this.#fs.close(fd, (er) => {\n          cb(er || err);\n        }), this.fd = null;\n    } catch (e) {\n      throw e;\n    }\n  }\n  close(cb) {\n    if (typeof cb === \"function\")\n      eos_()(this, cb);\n    this.destroy();\n  }\n  push(chunk) {\n    var bytesRead = chunk\?.length \?\? 0;\n    if (bytesRead > 0) {\n      this.bytesRead += bytesRead;\n      var currPos = this.pos;\n      if (currPos !== void 0) {\n        if (this.bytesRead < currPos)\n          return !0;\n        if (currPos === this.start) {\n          var n = this.bytesRead - currPos;\n          chunk = chunk.slice(-n);\n          var [_, ...rest] = arguments;\n          if (this.pos = this.bytesRead, this.end !== void 0 && this.bytesRead > this.end)\n            chunk = chunk.slice(0, this.end - this.start + 1);\n          return super.push(chunk, ...rest);\n        }\n        var end = this.end;\n        if (end !== void 0 && this.bytesRead > end) {\n          chunk = chunk.slice(0, end - currPos + 1);\n          var [_, ...rest] = arguments;\n          return this.pos = this.bytesRead, super.push(chunk, ...rest);\n        }\n        this.pos = this.bytesRead;\n      }\n    }\n    return super.push(...arguments);\n  }\n  #internalRead(n) {\n    var { pos, end, bytesRead, fd, encoding } = this;\n    if (n = pos !== void 0 \? Math.min(end - pos + 1, n) : Math.min(end - bytesRead + 1, n), n <= 0) {\n      this.push(null);\n      return;\n    }\n    if (this.#fileSize === -1 && bytesRead === 0 && pos === void 0) {\n      var stat3 = fstatSync(fd);\n      if (this.#fileSize = stat3.size, this.#fileSize > 0 && n > this.#fileSize)\n        n = this.#fileSize + 1;\n    }\n    this[kIoDone] = !1;\n    var res = super._read(n);\n    if (@isPromise(res)) {\n      var then = res\?.then;\n      if (then && @isCallable(then))\n        res.then(() => {\n          if (this[kIoDone] = !0, this.destroyed)\n            this.emit(kIoDone);\n        }, (er) => {\n          this[kIoDone] = !0, this.#errorOrDestroy(er);\n        });\n    } else if (this[kIoDone] = !0, this.destroyed)\n      this.emit(kIoDone), this.#errorOrDestroy(new Error(\"ERR_STREAM_PREMATURE_CLOSE\"));\n  }\n  #errorOrDestroy(err, sync = null) {\n    var {\n      _readableState: r = { destroyed: !1, autoDestroy: !1 },\n      _writableState: w = { destroyed: !1, autoDestroy: !1 }\n    } = this;\n    if (w\?.destroyed || r\?.destroyed)\n      return this;\n    if (r\?.autoDestroy || w\?.autoDestroy)\n      this.destroy(err);\n    else if (err)\n      this.emit(\"error\", err);\n  }\n  pause() {\n    return this[readStreamPathFastPathSymbol] = !1, super.pause();\n  }\n  resume() {\n    return this[readStreamPathFastPathSymbol] = !1, super.resume();\n  }\n  unshift(...args) {\n    return this[readStreamPathFastPathSymbol] = !1, super.unshift(...args);\n  }\n  pipe(dest, pipeOpts) {\n    if (this[readStreamPathFastPathSymbol] && (pipeOpts\?.end \?\? !0) && this._readableState\?.pipes\?.length === 0) {\n      if ((writeStreamPathFastPathSymbol in dest) && dest[writeStreamPathFastPathSymbol]) {\n        if (dest[writeStreamPathFastPathCallSymbol](this, pipeOpts))\n          return this;\n      }\n    }\n    return this[readStreamPathFastPathSymbol] = !1, super.pipe(dest, pipeOpts);\n  }\n});\nvar defaultWriteStreamOptions = {\n  fd: null,\n  start: void 0,\n  pos: void 0,\n  encoding: void 0,\n  flags: \"w\",\n  mode: 438,\n  fs: {\n    write,\n    close,\n    open,\n    openSync\n  }\n}, WriteStreamClass;\nWriteStream = function(InternalWriteStream) {\n  WriteStreamClass = InternalWriteStream, Object.defineProperty(WriteStreamClass.prototype, Symbol.toStringTag, {\n    value: \"WritesStream\",\n    enumerable: !1\n  });\n  function WriteStream3(path, options) {\n    return new InternalWriteStream(path, options);\n  }\n  return WriteStream3.prototype = InternalWriteStream.prototype, Object.defineProperty(WriteStream3, Symbol.hasInstance, {\n    value(instance) {\n      return instance instanceof InternalWriteStream;\n    }\n  });\n}(class WriteStream2 extends Stream.NativeWritable {\n  constructor(path, options = defaultWriteStreamOptions) {\n    if (!options)\n      @throwTypeError(\"Expected options to be an object\");\n    var {\n      fs: fs2 = defaultWriteStreamOptions.fs,\n      start = defaultWriteStreamOptions.start,\n      flags = defaultWriteStreamOptions.flags,\n      mode = defaultWriteStreamOptions.mode,\n      autoClose = !0,\n      emitClose = !1,\n      autoDestroy = autoClose,\n      encoding = defaultWriteStreamOptions.encoding,\n      fd = defaultWriteStreamOptions.fd,\n      pos = defaultWriteStreamOptions.pos\n    } = options, tempThis = {};\n    if (typeof path === \"string\") {\n      if (path.length === 0)\n        @throwTypeError(\"Expected a non-empty path\");\n      if (path.startsWith(\"file:\"))\n        path = Bun.fileURLToPath(path);\n      tempThis.path = path, tempThis.fd = null, tempThis[writeStreamPathFastPathSymbol] = autoClose && (start === void 0 || start === 0) && fs2.write === defaultWriteStreamOptions.fs.write && fs2.close === defaultWriteStreamOptions.fs.close;\n    } else\n      tempThis.fd = fd, tempThis[writeStreamPathFastPathSymbol] = !1;\n    if (!tempThis.fd)\n      tempThis.fd = fs2.openSync(path, flags, mode);\n    super(tempThis.fd, {\n      ...options,\n      decodeStrings: !1,\n      autoDestroy,\n      emitClose,\n      fd: tempThis\n    });\n    if (Object.assign(this, tempThis), typeof fs2\?.write !== \"function\")\n      @throwTypeError(\"Expected fs.write to be a function\");\n    if (typeof fs2\?.close !== \"function\")\n      @throwTypeError(\"Expected fs.close to be a function\");\n    if (typeof fs2\?.open !== \"function\")\n      @throwTypeError(\"Expected fs.open to be a function\");\n    if (typeof path === \"object\" && path) {\n      if (path instanceof URL)\n        path = Bun.fileURLToPath(path);\n    }\n    if (typeof path !== \"string\" && typeof fd !== \"number\")\n      @throwTypeError(\"Expected a path or file descriptor\");\n    if (this.start = start, this.#fs = fs2, this.flags = flags, this.mode = mode, this.start !== void 0)\n      this.pos = this.start;\n    if (encoding !== defaultWriteStreamOptions.encoding) {\n      if (this.setDefaultEncoding(encoding), encoding !== \"buffer\" && encoding !== \"utf8\" && encoding !== \"utf-8\" && encoding !== \"binary\")\n        this[writeStreamPathFastPathSymbol] = !1;\n    }\n  }\n  get autoClose() {\n    return this._writableState.autoDestroy;\n  }\n  set autoClose(val) {\n    this._writableState.autoDestroy = val;\n  }\n  destroySoon = this.end;\n  open() {\n  }\n  path;\n  fd;\n  flags;\n  mode;\n  #fs;\n  bytesWritten = 0;\n  pos;\n  [writeStreamPathFastPathSymbol];\n  [writeStreamSymbol] = !0;\n  start;\n  [writeStreamPathFastPathCallSymbol](readStream, pipeOpts) {\n    if (!this[writeStreamPathFastPathSymbol])\n      return !1;\n    if (this.fd !== null)\n      return this[writeStreamPathFastPathSymbol] = !1, !1;\n    return this[kIoDone] = !1, readStream[kIoDone] = !1, Bun.write(this[writeStreamPathFastPathSymbol], readStream[readStreamPathOrFdSymbol]).then((bytesWritten) => {\n      readStream[kIoDone] = this[kIoDone] = !0, this.bytesWritten += bytesWritten, readStream.bytesRead += bytesWritten, this.end(), readStream.close();\n    }, (err) => {\n      readStream[kIoDone] = this[kIoDone] = !0, this.#errorOrDestroy(err), readStream.emit(\"error\", err);\n    });\n  }\n  isBunFastPathEnabled() {\n    return this[writeStreamPathFastPathSymbol];\n  }\n  disableBunFastPath() {\n    this[writeStreamPathFastPathSymbol] = !1;\n  }\n  #handleWrite(er, bytes) {\n    if (er)\n      return this.#errorOrDestroy(er);\n    this.bytesWritten += bytes;\n  }\n  #internalClose(err, cb) {\n    this[writeStreamPathFastPathSymbol] = !1;\n    var fd = this.fd;\n    this.#fs.close(fd, (er) => {\n      this.fd = null, cb(err || er);\n    });\n  }\n  _construct(callback) {\n    if (typeof this.fd === \"number\") {\n      callback();\n      return;\n    }\n    callback(), this.emit(\"open\", this.fd), this.emit(\"ready\");\n  }\n  _destroy(err, cb) {\n    if (this.fd === null)\n      return cb(err);\n    if (this[kIoDone]) {\n      this.once(kIoDone, () => this.#internalClose(err, cb));\n      return;\n    }\n    this.#internalClose(err, cb);\n  }\n  [kIoDone] = !1;\n  close(cb) {\n    if (cb) {\n      if (this.closed) {\n        process.nextTick(cb);\n        return;\n      }\n      this.on(\"close\", cb);\n    }\n    if (!this.autoClose)\n      this.on(\"finish\", this.destroy);\n    this.end();\n  }\n  write(chunk, encoding = this._writableState.defaultEncoding, cb) {\n    if (this[writeStreamPathFastPathSymbol] = !1, typeof chunk === \"string\")\n      chunk = Buffer.from(chunk, encoding);\n    var native = this.pos === void 0;\n    return this[kIoDone] = !0, super.write(chunk, encoding, native \? (err, bytes) => {\n      if (this[kIoDone] = !1, this.#handleWrite(err, bytes), this.emit(kIoDone), cb)\n        !err \? cb() : cb(err);\n    } : () => {\n    }, native);\n  }\n  #internalWriteSlow(chunk, encoding, cb) {\n    this.#fs.write(this.fd, chunk, 0, chunk.length, this.pos, (err, bytes) => {\n      this[kIoDone] = !1, this.#handleWrite(err, bytes), this.emit(kIoDone), !err \? cb() : cb(err);\n    });\n  }\n  end(chunk, encoding, cb) {\n    var native = this.pos === void 0;\n    return super.end(chunk, encoding, cb, native);\n  }\n  _write = this.#internalWriteSlow;\n  _writev = void 0;\n  get pending() {\n    return this.fd === null;\n  }\n  _destroy(err, cb) {\n    this.close(err, cb);\n  }\n  #errorOrDestroy(err) {\n    var {\n      _readableState: r = { destroyed: !1, autoDestroy: !1 },\n      _writableState: w = { destroyed: !1, autoDestroy: !1 }\n    } = this;\n    if (w\?.destroyed || r\?.destroyed)\n      return this;\n    if (r\?.autoDestroy || w\?.autoDestroy)\n      this.destroy(err);\n    else if (err)\n      this.emit(\"error\", err);\n  }\n});\nObject.defineProperties(fs, {\n  createReadStream: {\n    value: createReadStream\n  },\n  createWriteStream: {\n    value: createWriteStream\n  },\n  ReadStream: {\n    value: ReadStream\n  },\n  WriteStream: {\n    value: WriteStream\n  }\n});\nrealpath.native = realpath;\nrealpathSync.native = realpathSync;\n$ = {\n  access,\n  accessSync,\n  appendFile,\n  appendFileSync,\n  chmod,\n  chmodSync,\n  chown,\n  chownSync,\n  close,\n  closeSync,\n  constants: promises.constants,\n  copyFile,\n  copyFileSync,\n  createReadStream,\n  createWriteStream,\n  Dirent,\n  exists,\n  existsSync,\n  fchmod,\n  fchmodSync,\n  fchown,\n  fchownSync,\n  fstat,\n  fstatSync,\n  fsync,\n  fsyncSync,\n  ftruncate,\n  ftruncateSync,\n  futimes,\n  futimesSync,\n  lchmod,\n  lchmodSync,\n  lchown,\n  lchownSync,\n  link,\n  linkSync,\n  lstat,\n  lstatSync,\n  lutimes,\n  lutimesSync,\n  mkdir,\n  mkdirSync,\n  mkdtemp,\n  mkdtempSync,\n  open,\n  openSync,\n  promises,\n  read,\n  readFile,\n  readFileSync,\n  readSync,\n  readdir,\n  readdirSync,\n  readlink,\n  readlinkSync,\n  realpath,\n  realpathSync,\n  rename,\n  renameSync,\n  rm,\n  rmSync,\n  rmdir,\n  rmdirSync,\n  stat,\n  statSync,\n  Stats,\n  symlink,\n  symlinkSync,\n  truncate,\n  truncateSync,\n  unlink,\n  unlinkSync,\n  utimes,\n  utimesSync,\n  write,\n  writeFile,\n  writeFileSync,\n  writeSync,\n  WriteStream,\n  ReadStream,\n  watch,\n  FSWatcher,\n  writev,\n  writevSync,\n  readv,\n  readvSync,\n  [Symbol.for(\"::bunternal::\")]: {\n    ReadStreamClass,\n    WriteStreamClass\n  }\n};\nreturn $})\n"_s;
//

//
static constexpr ASCIILiteral NodeFSPromisesCode = "(function (){\"use strict\";// src/js/out/tmp/node/fs.promises.ts\nvar watch = function(filename, options = {}) {\n  if (filename instanceof URL)\n    @throwTypeError(\"Watch URLs are not supported yet\");\n  else if (Buffer.isBuffer(filename))\n    filename = filename.toString();\n  else if (typeof filename !== \"string\")\n    @throwTypeError(\"Expected path to be a string or Buffer\");\n  let nextEventResolve = null;\n  if (typeof options === \"string\")\n    options = { encoding: options };\n  const queue = @createFIFO(), watcher = fs.watch(filename, options || {}, (eventType, filename2) => {\n    if (queue.push({ eventType, filename: filename2 }), nextEventResolve) {\n      const resolve = nextEventResolve;\n      nextEventResolve = null, resolve();\n    }\n  });\n  return {\n    [Symbol.asyncIterator]() {\n      let closed = !1;\n      return {\n        async next() {\n          while (!closed) {\n            let event;\n            while (event = queue.shift()) {\n              if (event.eventType === \"close\")\n                return closed = !0, { value: void 0, done: !0 };\n              if (event.eventType === \"error\")\n                throw closed = !0, event.filename;\n              return { value: event, done: !1 };\n            }\n            const { promise, resolve } = Promise.withResolvers();\n            nextEventResolve = resolve, await promise;\n          }\n          return { value: void 0, done: !0 };\n        },\n        return() {\n          if (!closed) {\n            if (watcher.close(), closed = !0, nextEventResolve) {\n              const resolve = nextEventResolve;\n              nextEventResolve = null, resolve();\n            }\n          }\n          return { value: void 0, done: !0 };\n        }\n      };\n    }\n  };\n}, $, constants = @processBindingConstants.fs, fs = Bun.fs(), notrace = \"::bunternal::\", promisify = {\n  [notrace]: (fsFunction) => {\n    return async function(...args) {\n      return await 1, fsFunction.apply(fs, args);\n    };\n  }\n}[notrace];\n$ = {\n  access: promisify(fs.accessSync),\n  appendFile: promisify(fs.appendFileSync),\n  close: promisify(fs.closeSync),\n  copyFile: promisify(fs.copyFileSync),\n  exists: promisify(fs.existsSync),\n  chown: promisify(fs.chownSync),\n  chmod: promisify(fs.chmodSync),\n  fchmod: promisify(fs.fchmodSync),\n  fchown: promisify(fs.fchownSync),\n  fstat: promisify(fs.fstatSync),\n  fsync: promisify(fs.fsyncSync),\n  ftruncate: promisify(fs.ftruncateSync),\n  futimes: promisify(fs.futimesSync),\n  lchmod: promisify(fs.lchmodSync),\n  lchown: promisify(fs.lchownSync),\n  link: promisify(fs.linkSync),\n  lstat: fs.lstat.bind(fs),\n  mkdir: promisify(fs.mkdirSync),\n  mkdtemp: promisify(fs.mkdtempSync),\n  open: promisify(fs.openSync),\n  read: promisify(fs.readSync),\n  write: promisify(fs.writeSync),\n  readdir: fs.readdir.bind(fs),\n  readFile: fs.readFile.bind(fs),\n  writeFile: promisify(fs.writeFileSync),\n  readlink: promisify(fs.readlinkSync),\n  realpath: fs.realpath.bind(fs),\n  rename: promisify(fs.renameSync),\n  stat: fs.stat.bind(fs),\n  symlink: promisify(fs.symlinkSync),\n  truncate: promisify(fs.truncateSync),\n  unlink: promisify(fs.unlinkSync),\n  utimes: promisify(fs.utimesSync),\n  lutimes: promisify(fs.lutimesSync),\n  rm: promisify(fs.rmSync),\n  rmdir: promisify(fs.rmdirSync),\n  writev: (fd, buffers, position) => {\n    return new Promise((resolve, reject) => {\n      try {\n        var bytesWritten = fs.writevSync(fd, buffers, position);\n      } catch (err) {\n        reject(err);\n        return;\n      }\n      resolve({\n        bytesWritten,\n        buffers\n      });\n    });\n  },\n  readv: (fd, buffers, position) => {\n    return new Promise((resolve, reject) => {\n      try {\n        var bytesRead = fs.readvSync(fd, buffers, position);\n      } catch (err) {\n        reject(err);\n        return;\n      }\n      resolve({\n        bytesRead,\n        buffers\n      });\n    });\n  },\n  constants,\n  watch\n};\nreturn $})\n"_s;
//

//
static constexpr ASCIILiteral NodeHttpCode = "(function (){\"use strict\";// src/js/out/tmp/node/http.ts\nvar checkInvalidHeaderChar = function(val) {\n  return RegExpPrototypeExec.call(headerCharRegex, val) !== null;\n}, isIPv6 = function(input) {\n  return new RegExp(\"^((\?:(\?:[0-9a-fA-F]{1,4}):){7}(\?:(\?:[0-9a-fA-F]{1,4})|:)|(\?:(\?:[0-9a-fA-F]{1,4}):){6}(\?:((\?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])[.]){3}(\?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])|:(\?:[0-9a-fA-F]{1,4})|:)|(\?:(\?:[0-9a-fA-F]{1,4}):){5}(\?::((\?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])[.]){3}(\?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])|(:(\?:[0-9a-fA-F]{1,4})){1,2}|:)|(\?:(\?:[0-9a-fA-F]{1,4}):){4}(\?:(:(\?:[0-9a-fA-F]{1,4})){0,1}:((\?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])[.]){3}(\?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])|(:(\?:[0-9a-fA-F]{1,4})){1,3}|:)|(\?:(\?:[0-9a-fA-F]{1,4}):){3}(\?:(:(\?:[0-9a-fA-F]{1,4})){0,2}:((\?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])[.]){3}(\?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])|(:(\?:[0-9a-fA-F]{1,4})){1,4}|:)|(\?:(\?:[0-9a-fA-F]{1,4}):){2}(\?:(:(\?:[0-9a-fA-F]{1,4})){0,3}:((\?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])[.]){3}(\?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])|(:(\?:[0-9a-fA-F]{1,4})){1,5}|:)|(\?:(\?:[0-9a-fA-F]{1,4}):){1}(\?:(:(\?:[0-9a-fA-F]{1,4})){0,4}:((\?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])[.]){3}(\?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])|(:(\?:[0-9a-fA-F]{1,4})){1,6}|:)|(\?::((\?::(\?:[0-9a-fA-F]{1,4})){0,5}:((\?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])[.]){3}(\?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])|(\?::(\?:[0-9a-fA-F]{1,4})){1,7}|:)))(%[0-9a-zA-Z-.:]{1,})\?$\").test(input);\n}, isValidTLSArray = function(obj) {\n  if (typeof obj === \"string\" || isTypedArray(obj) || obj instanceof ArrayBuffer || obj instanceof Blob)\n    return !0;\n  if (Array.isArray(obj)) {\n    for (var i = 0;i < obj.length; i++)\n      if (typeof obj !== \"string\" && !isTypedArray(obj) && !(obj instanceof ArrayBuffer) && !(obj instanceof Blob))\n        return !1;\n    return !0;\n  }\n}, validateMsecs = function(numberlike, field) {\n  if (typeof numberlike !== \"number\" || numberlike < 0)\n    throw new ERR_INVALID_ARG_TYPE(field, \"number\", numberlike);\n  return numberlike;\n}, validateFunction = function(callable, field) {\n  if (typeof callable !== \"function\")\n    throw new ERR_INVALID_ARG_TYPE(field, \"Function\", callable);\n  return callable;\n}, getHeader = function(headers, name) {\n  if (!headers)\n    return;\n  const result = headers.get(name);\n  return result == null \? void 0 : result;\n}, createServer = function(options, callback) {\n  return new Server(options, callback);\n}, emitListeningNextTick = function(self, onListen, err, hostname, port) {\n  if (typeof onListen === \"function\")\n    try {\n      onListen(err, hostname, port);\n    } catch (err2) {\n      self.emit(\"error\", err2);\n    }\n  if (self.listening = !err, err)\n    self.emit(\"error\", err);\n  else\n    self.emit(\"listening\", hostname, port);\n}, assignHeaders = function(object, req) {\n  var headers = req.headers.toJSON();\n  const rawHeaders = @newArrayWithSize(req.headers.count * 2);\n  var i = 0;\n  for (let key in headers)\n    rawHeaders[i++] = key, rawHeaders[i++] = headers[key];\n  object.headers = headers, object.rawHeaders = rawHeaders;\n};\nvar getDefaultHTTPSAgent = function() {\n  return _defaultHTTPSAgent \?\?= new Agent({ defaultPort: 443, protocol: \"https:\" });\n};\nvar urlToHttpOptions = function(url) {\n  var { protocol, hostname, hash, search, pathname, href, port, username, password } = url;\n  return {\n    protocol,\n    hostname: typeof hostname === \"string\" && StringPrototypeStartsWith.call(hostname, \"[\") \? StringPrototypeSlice.call(hostname, 1, -1) : hostname,\n    hash,\n    search,\n    pathname,\n    path: `${pathname || \"\"}${search || \"\"}`,\n    href,\n    port: port \? Number(port) : protocol === \"https:\" \? 443 : protocol === \"http:\" \? 80 : void 0,\n    auth: username || password \? `${decodeURIComponent(username)}:${decodeURIComponent(password)}` : void 0\n  };\n}, validateHost = function(host, name) {\n  if (host !== null && host !== void 0 && typeof host !== \"string\")\n    throw new Error(\"Invalid arg type in options\");\n  return host;\n}, checkIsHttpToken = function(val) {\n  return RegExpPrototypeExec.call(tokenRegExp, val) !== null;\n};\nvar _writeHead = function(statusCode, reason, obj, response) {\n  if (statusCode |= 0, statusCode < 100 || statusCode > 999)\n    throw new Error(\"status code must be between 100 and 999\");\n  if (typeof reason === \"string\")\n    response.statusMessage = reason;\n  else {\n    if (!response.statusMessage)\n      response.statusMessage = STATUS_CODES[statusCode] || \"unknown\";\n    obj = reason;\n  }\n  response.statusCode = statusCode;\n  {\n    let k;\n    if (Array.isArray(obj)) {\n      if (obj.length % 2 !== 0)\n        throw new Error(\"raw headers must have an even number of elements\");\n      for (let n = 0;n < obj.length; n += 2)\n        if (k = obj[n + 0], k)\n          response.setHeader(k, obj[n + 1]);\n    } else if (obj) {\n      const keys = Object.keys(obj);\n      for (let i = 0;i < keys.length; i++)\n        if (k = keys[i], k)\n          response.setHeader(k, obj[k]);\n    }\n  }\n  if (statusCode === 204 || statusCode === 304 || statusCode >= 100 && statusCode <= 199)\n    response._hasBody = !1;\n}, request = function(url, options, cb) {\n  return new ClientRequest(url, options, cb);\n}, get = function(url, options, cb) {\n  const req = request(url, options, cb);\n  return req.end(), req;\n}, $, EventEmitter = @getInternalField(@internalModuleRegistry, 16) || @createInternalModuleById(16), { isTypedArray } = @requireNativeModule(\"node:util/types\"), { Duplex, Readable, Writable } = @getInternalField(@internalModuleRegistry, 35) || @createInternalModuleById(35), headerCharRegex = /[^\\t\\x20-\\x7e\\x80-\\xff]/, validateHeaderName = (name, label) => {\n  if (typeof name !== \"string\" || !name || !checkIsHttpToken(name))\n    throw new Error(\"ERR_INVALID_HTTP_TOKEN\");\n}, validateHeaderValue = (name, value) => {\n  if (value === void 0)\n    throw new Error(\"ERR_HTTP_INVALID_HEADER_VALUE\");\n  if (checkInvalidHeaderChar(value))\n    throw new Error(\"ERR_INVALID_CHAR\");\n}, { URL } = globalThis, globalReportError = globalThis.reportError, setTimeout = globalThis.setTimeout, fetch = Bun.fetch;\nvar kEmptyObject = Object.freeze(Object.create(null)), kOutHeaders = Symbol.for(\"kOutHeaders\"), kEndCalled = Symbol.for(\"kEndCalled\"), kAbortController = Symbol.for(\"kAbortController\"), kClearTimeout = Symbol(\"kClearTimeout\"), kCorked = Symbol.for(\"kCorked\"), searchParamsSymbol = Symbol.for(\"query\"), StringPrototypeSlice = String.prototype.slice, StringPrototypeStartsWith = String.prototype.startsWith, StringPrototypeToUpperCase = String.prototype.toUpperCase, StringPrototypeIncludes = String.prototype.includes, StringPrototypeCharCodeAt = String.prototype.charCodeAt, StringPrototypeIndexOf = String.prototype.indexOf, ArrayIsArray = Array.isArray, RegExpPrototypeExec = RegExp.prototype.exec, ObjectAssign = Object.assign;\nvar INVALID_PATH_REGEX = /[^\\u0021-\\u00ff]/;\nvar _defaultHTTPSAgent, kInternalRequest = Symbol(\"kInternalRequest\"), kInternalSocketData = Symbol.for(\"::bunternal::\"), kEmptyBuffer = Buffer.alloc(0);\n\nclass ERR_INVALID_ARG_TYPE extends TypeError {\n  constructor(name, expected, actual) {\n    super(`The ${name} argument must be of type ${expected}. Received type ${typeof actual}`);\n    this.code = \"ERR_INVALID_ARG_TYPE\";\n  }\n}\nvar FakeSocket = class Socket extends Duplex {\n  bytesRead = 0;\n  bytesWritten = 0;\n  connecting = !1;\n  remoteAddress = null;\n  remotePort;\n  timeout = 0;\n  isServer = !1;\n  address() {\n    return {\n      address: this.localAddress,\n      family: this.localFamily,\n      port: this.localPort\n    };\n  }\n  get bufferSize() {\n    return this.writableLength;\n  }\n  connect(port, host, connectListener) {\n    return this;\n  }\n  _destroy(err, callback) {\n  }\n  _final(callback) {\n  }\n  get localAddress() {\n    return \"127.0.0.1\";\n  }\n  get localFamily() {\n    return \"IPv4\";\n  }\n  get localPort() {\n    return 80;\n  }\n  get pending() {\n    return this.connecting;\n  }\n  _read(size) {\n  }\n  get readyState() {\n    if (this.connecting)\n      return \"opening\";\n    if (this.readable)\n      return this.writable \? \"open\" : \"readOnly\";\n    else\n      return this.writable \? \"writeOnly\" : \"closed\";\n  }\n  ref() {\n  }\n  get remoteFamily() {\n    return \"IPv4\";\n  }\n  resetAndDestroy() {\n  }\n  setKeepAlive(enable = !1, initialDelay = 0) {\n  }\n  setNoDelay(noDelay = !0) {\n    return this;\n  }\n  setTimeout(timeout, callback) {\n    return this;\n  }\n  unref() {\n  }\n  _write(chunk, encoding, callback) {\n  }\n};\n\nclass Agent extends EventEmitter {\n  defaultPort = 80;\n  protocol = \"http:\";\n  options;\n  requests;\n  sockets;\n  freeSockets;\n  keepAliveMsecs;\n  keepAlive;\n  maxSockets;\n  maxFreeSockets;\n  scheduling;\n  maxTotalSockets;\n  totalSocketCount;\n  #fakeSocket;\n  static get globalAgent() {\n    return globalAgent;\n  }\n  static get defaultMaxSockets() {\n    return Infinity;\n  }\n  constructor(options = kEmptyObject) {\n    super();\n    if (this.options = options = { ...options, path: null }, options.noDelay === void 0)\n      options.noDelay = !0;\n    this.requests = kEmptyObject, this.sockets = kEmptyObject, this.freeSockets = kEmptyObject, this.keepAliveMsecs = options.keepAliveMsecs || 1000, this.keepAlive = options.keepAlive || !1, this.maxSockets = options.maxSockets || Agent.defaultMaxSockets, this.maxFreeSockets = options.maxFreeSockets || 256, this.scheduling = options.scheduling || \"lifo\", this.maxTotalSockets = options.maxTotalSockets, this.totalSocketCount = 0, this.defaultPort = options.defaultPort || 80, this.protocol = options.protocol || \"http:\";\n  }\n  createConnection() {\n    return this.#fakeSocket \?\?= new FakeSocket;\n  }\n  getName(options = kEmptyObject) {\n    let name = `http:${options.host || \"localhost\"}:`;\n    if (options.port)\n      name += options.port;\n    if (name += \":\", options.localAddress)\n      name += options.localAddress;\n    if (options.family === 4 || options.family === 6)\n      name += `:${options.family}`;\n    if (options.socketPath)\n      name += `:${options.socketPath}`;\n    return name;\n  }\n  addRequest() {\n  }\n  createSocket(req, options, cb) {\n    cb(null, this.#fakeSocket \?\?= new FakeSocket);\n  }\n  removeSocket() {\n  }\n  keepSocketAlive() {\n    return !0;\n  }\n  reuseSocket() {\n  }\n  destroy() {\n  }\n}\n\nclass Server extends EventEmitter {\n  #server;\n  #options;\n  #tls;\n  #is_tls = !1;\n  listening = !1;\n  serverName;\n  constructor(options, callback) {\n    super();\n    if (typeof options === \"function\")\n      callback = options, options = {};\n    else if (options == null || typeof options === \"object\") {\n      options = { ...options }, this.#tls = null;\n      let key = options.key;\n      if (key) {\n        if (!isValidTLSArray(key))\n          @throwTypeError(\"key argument must be an string, Buffer, TypedArray, BunFile or an array containing string, Buffer, TypedArray or BunFile\");\n        this.#is_tls = !0;\n      }\n      let cert = options.cert;\n      if (cert) {\n        if (!isValidTLSArray(cert))\n          @throwTypeError(\"cert argument must be an string, Buffer, TypedArray, BunFile or an array containing string, Buffer, TypedArray or BunFile\");\n        this.#is_tls = !0;\n      }\n      let ca = options.ca;\n      if (ca) {\n        if (!isValidTLSArray(ca))\n          @throwTypeError(\"ca argument must be an string, Buffer, TypedArray, BunFile or an array containing string, Buffer, TypedArray or BunFile\");\n        this.#is_tls = !0;\n      }\n      let passphrase = options.passphrase;\n      if (passphrase && typeof passphrase !== \"string\")\n        @throwTypeError(\"passphrase argument must be an string\");\n      let serverName = options.servername;\n      if (serverName && typeof serverName !== \"string\")\n        @throwTypeError(\"servername argument must be an string\");\n      let secureOptions = options.secureOptions || 0;\n      if (secureOptions && typeof secureOptions !== \"number\")\n        @throwTypeError(\"secureOptions argument must be an number\");\n      if (this.#is_tls)\n        this.#tls = {\n          serverName,\n          key,\n          cert,\n          ca,\n          passphrase,\n          secureOptions\n        };\n      else\n        this.#tls = null;\n    } else\n      throw new Error(\"bun-http-polyfill: invalid arguments\");\n    if (this.#options = options, callback)\n      this.on(\"request\", callback);\n  }\n  closeAllConnections() {\n    const server = this.#server;\n    if (!server)\n      return;\n    this.#server = void 0, server.stop(!0), this.emit(\"close\");\n  }\n  closeIdleConnections() {\n  }\n  close(optionalCallback) {\n    const server = this.#server;\n    if (!server) {\n      if (typeof optionalCallback === \"function\")\n        process.nextTick(optionalCallback, new Error(\"Server is not running\"));\n      return;\n    }\n    if (this.#server = void 0, typeof optionalCallback === \"function\")\n      this.once(\"close\", optionalCallback);\n    server.stop(), this.emit(\"close\");\n  }\n  address() {\n    if (!this.#server)\n      return null;\n    const address = this.#server.hostname;\n    return {\n      address,\n      family: isIPv6(address) \? \"IPv6\" : \"IPv4\",\n      port: this.#server.port\n    };\n  }\n  listen(port, host, backlog, onListen) {\n    const server = this;\n    if (typeof host === \"function\")\n      onListen = host, host = void 0;\n    if (typeof port === \"function\")\n      onListen = port;\n    else if (typeof port === \"object\") {\n      if (port\?.signal\?.addEventListener(\"abort\", () => {\n        this.close();\n      }), host = port\?.host, port = port\?.port, typeof port\?.callback === \"function\")\n        onListen = port\?.callback;\n    }\n    if (typeof backlog === \"function\")\n      onListen = backlog;\n    const ResponseClass = this.#options.ServerResponse || ServerResponse, RequestClass = this.#options.IncomingMessage || IncomingMessage;\n    try {\n      const tls = this.#tls;\n      if (tls)\n        this.serverName = tls.serverName || host || \"localhost\";\n      this.#server = Bun.serve({\n        tls,\n        port,\n        hostname: host,\n        websocket: {\n          open(ws) {\n            ws.data.open(ws);\n          },\n          message(ws, message) {\n            ws.data.message(ws, message);\n          },\n          close(ws, code, reason) {\n            ws.data.close(ws, code, reason);\n          },\n          drain(ws) {\n            ws.data.drain(ws);\n          }\n        },\n        fetch(req, _server) {\n          var pendingResponse, pendingError, rejectFunction, resolveFunction, reject = (err) => {\n            if (pendingError)\n              return;\n            if (pendingError = err, rejectFunction)\n              rejectFunction(err);\n          }, reply = function(resp) {\n            if (pendingResponse)\n              return;\n            if (pendingResponse = resp, resolveFunction)\n              resolveFunction(resp);\n          };\n          const http_req = new RequestClass(req), http_res = new ResponseClass({ reply, req: http_req });\n          if (http_req.once(\"error\", (err) => reject(err)), http_res.once(\"error\", (err) => reject(err)), req.headers.get(\"upgrade\")) {\n            const socket = new FakeSocket;\n            socket[kInternalSocketData] = [_server, http_res, req], server.emit(\"upgrade\", http_req, socket, kEmptyBuffer);\n          } else\n            server.emit(\"request\", http_req, http_res);\n          if (pendingError)\n            throw pendingError;\n          if (pendingResponse)\n            return pendingResponse;\n          return new Promise((resolve, reject2) => {\n            resolveFunction = resolve, rejectFunction = reject2;\n          });\n        }\n      }), setTimeout(emitListeningNextTick, 1, this, onListen, null, this.#server.hostname, this.#server.port);\n    } catch (err) {\n      setTimeout(emitListeningNextTick, 1, this, onListen, err);\n    }\n    return this;\n  }\n  setTimeout(msecs, callback) {\n  }\n}\nclass IncomingMessage extends Readable {\n  method;\n  complete;\n  constructor(req, defaultIncomingOpts) {\n    const method = req.method;\n    super();\n    const url = new URL(req.url);\n    var { type = \"request\", [kInternalRequest]: nodeReq } = defaultIncomingOpts || {};\n    this.#noBody = type === \"request\" \? method === \"GET\" || method === \"HEAD\" || method === \"TRACE\" || method === \"CONNECT\" || method === \"OPTIONS\" || (parseInt(req.headers.get(\"Content-Length\") || \"\") || 0) === 0 : !1, this.#req = req, this.method = method, this.#type = type, this.complete = !!this.#noBody, this.#bodyStream = void 0;\n    const socket = new FakeSocket;\n    socket.remoteAddress = url.hostname, socket.remotePort = url.port, this.#fakeSocket = socket, this.url = url.pathname + url.search, this.#nodeReq = this.req = nodeReq, assignHeaders(this, req);\n  }\n  headers;\n  rawHeaders;\n  _consuming = !1;\n  _dumped = !1;\n  #bodyStream;\n  #fakeSocket;\n  #noBody = !1;\n  #aborted = !1;\n  #req;\n  url;\n  #type;\n  #nodeReq;\n  _construct(callback) {\n    if (this.#type === \"response\" || this.#noBody) {\n      callback();\n      return;\n    }\n    const contentLength = this.#req.headers.get(\"content-length\");\n    if ((contentLength \? parseInt(contentLength, 10) : 0) === 0) {\n      this.#noBody = !0, callback();\n      return;\n    }\n    callback();\n  }\n  async#consumeStream(reader) {\n    while (!0) {\n      var { done, value } = await reader.readMany();\n      if (this.#aborted)\n        return;\n      if (done) {\n        this.push(null), this.destroy();\n        break;\n      }\n      for (var v of value)\n        this.push(v);\n    }\n  }\n  _read(size) {\n    if (this.#noBody)\n      this.push(null), this.complete = !0;\n    else if (this.#bodyStream == null) {\n      const reader = this.#req.body\?.getReader();\n      if (!reader) {\n        this.push(null);\n        return;\n      }\n      this.#bodyStream = reader, this.#consumeStream(reader);\n    }\n  }\n  get aborted() {\n    return this.#aborted;\n  }\n  #abort() {\n    if (this.#aborted)\n      return;\n    this.#aborted = !0;\n    var bodyStream = this.#bodyStream;\n    if (!bodyStream)\n      return;\n    bodyStream.cancel(), this.complete = !0, this.#bodyStream = void 0, this.push(null);\n  }\n  get connection() {\n    return this.#fakeSocket;\n  }\n  get statusCode() {\n    return this.#req.status;\n  }\n  get statusMessage() {\n    return STATUS_CODES[this.#req.status];\n  }\n  get httpVersion() {\n    return \"1.1\";\n  }\n  get rawTrailers() {\n    return [];\n  }\n  get httpVersionMajor() {\n    return 1;\n  }\n  get httpVersionMinor() {\n    return 1;\n  }\n  get trailers() {\n    return kEmptyObject;\n  }\n  get socket() {\n    return this.#fakeSocket \?\?= new FakeSocket;\n  }\n  set socket(val) {\n    this.#fakeSocket = val;\n  }\n  setTimeout(msecs, callback) {\n    throw new Error(\"not implemented\");\n  }\n}\n\nclass OutgoingMessage extends Writable {\n  constructor() {\n    super(...arguments);\n  }\n  #headers;\n  headersSent = !1;\n  sendDate = !0;\n  req;\n  timeout;\n  #finished = !1;\n  [kEndCalled] = !1;\n  #fakeSocket;\n  #timeoutTimer;\n  [kAbortController] = null;\n  _implicitHeader() {\n  }\n  get headers() {\n    if (!this.#headers)\n      return kEmptyObject;\n    return this.#headers.toJSON();\n  }\n  get shouldKeepAlive() {\n    return !0;\n  }\n  get chunkedEncoding() {\n    return !1;\n  }\n  set chunkedEncoding(value) {\n  }\n  set shouldKeepAlive(value) {\n  }\n  get useChunkedEncodingByDefault() {\n    return !0;\n  }\n  set useChunkedEncodingByDefault(value) {\n  }\n  get socket() {\n    return this.#fakeSocket \?\?= new FakeSocket;\n  }\n  set socket(val) {\n    this.#fakeSocket = val;\n  }\n  get connection() {\n    return this.socket;\n  }\n  get finished() {\n    return this.#finished;\n  }\n  appendHeader(name, value) {\n    var headers = this.#headers \?\?= new Headers;\n    headers.append(name, value);\n  }\n  flushHeaders() {\n  }\n  getHeader(name) {\n    return getHeader(this.#headers, name);\n  }\n  getHeaders() {\n    if (!this.#headers)\n      return kEmptyObject;\n    return this.#headers.toJSON();\n  }\n  getHeaderNames() {\n    var headers = this.#headers;\n    if (!headers)\n      return [];\n    return Array.from(headers.keys());\n  }\n  removeHeader(name) {\n    if (!this.#headers)\n      return;\n    this.#headers.delete(name);\n  }\n  setHeader(name, value) {\n    var headers = this.#headers \?\?= new Headers;\n    return headers.set(name, value), this;\n  }\n  hasHeader(name) {\n    if (!this.#headers)\n      return !1;\n    return this.#headers.has(name);\n  }\n  addTrailers(headers) {\n    throw new Error(\"not implemented\");\n  }\n  [kClearTimeout]() {\n    if (this.#timeoutTimer)\n      clearTimeout(this.#timeoutTimer), this.removeAllListeners(\"timeout\"), this.#timeoutTimer = void 0;\n  }\n  #onTimeout() {\n    this.#timeoutTimer = void 0, this[kAbortController]\?.abort(), this.emit(\"timeout\");\n  }\n  setTimeout(msecs, callback) {\n    if (this.destroyed)\n      return this;\n    if (this.timeout = msecs = validateMsecs(msecs, \"msecs\"), clearTimeout(this.#timeoutTimer), msecs === 0) {\n      if (callback !== void 0)\n        validateFunction(callback, \"callback\"), this.removeListener(\"timeout\", callback);\n      this.#timeoutTimer = void 0;\n    } else if (this.#timeoutTimer = setTimeout(this.#onTimeout.bind(this), msecs).unref(), callback !== void 0)\n      validateFunction(callback, \"callback\"), this.once(\"timeout\", callback);\n    return this;\n  }\n}\nvar OriginalWriteHeadFn, OriginalImplicitHeadFn;\n\nclass ServerResponse extends Writable {\n  constructor({ req, reply }) {\n    super();\n    if (this.req = req, this._reply = reply, this.sendDate = !0, this.statusCode = 200, this.headersSent = !1, this.statusMessage = void 0, this.#controller = void 0, this.#firstWrite = void 0, this._writableState.decodeStrings = !1, this.#deferred = void 0, req.method === \"HEAD\")\n      this._hasBody = !1;\n  }\n  req;\n  _reply;\n  sendDate;\n  statusCode;\n  #headers;\n  headersSent = !1;\n  statusMessage;\n  #controller;\n  #firstWrite;\n  _sent100 = !1;\n  _defaultKeepAlive = !1;\n  _removedConnection = !1;\n  _removedContLen = !1;\n  _hasBody = !0;\n  #deferred = void 0;\n  #finished = !1;\n  _implicitHeader() {\n    this.writeHead(this.statusCode);\n  }\n  _write(chunk, encoding, callback) {\n    if (!this.#firstWrite && !this.headersSent) {\n      this.#firstWrite = chunk, callback();\n      return;\n    }\n    this.#ensureReadableStreamController((controller) => {\n      controller.write(chunk), callback();\n    });\n  }\n  _writev(chunks, callback) {\n    if (chunks.length === 1 && !this.headersSent && !this.#firstWrite) {\n      this.#firstWrite = chunks[0].chunk, callback();\n      return;\n    }\n    this.#ensureReadableStreamController((controller) => {\n      for (let chunk of chunks)\n        controller.write(chunk.chunk);\n      callback();\n    });\n  }\n  #ensureReadableStreamController(run) {\n    var thisController = this.#controller;\n    if (thisController)\n      return run(thisController);\n    this.headersSent = !0;\n    var firstWrite = this.#firstWrite;\n    this.#firstWrite = void 0, this._reply(new Response(new ReadableStream({\n      type: \"direct\",\n      pull: (controller) => {\n        if (this.#controller = controller, firstWrite)\n          controller.write(firstWrite);\n        if (firstWrite = void 0, run(controller), !this.#finished)\n          return new Promise((resolve) => {\n            this.#deferred = resolve;\n          });\n      }\n    }), {\n      headers: this.#headers,\n      status: this.statusCode,\n      statusText: this.statusMessage \?\? STATUS_CODES[this.statusCode]\n    }));\n  }\n  #drainHeadersIfObservable() {\n    if (this._implicitHeader === OriginalImplicitHeadFn && this.writeHead === OriginalWriteHeadFn)\n      return;\n    this._implicitHeader();\n  }\n  _final(callback) {\n    if (!this.headersSent) {\n      var data = this.#firstWrite || \"\";\n      this.#firstWrite = void 0, this.#finished = !0, this.#drainHeadersIfObservable(), this._reply(new Response(data, {\n        headers: this.#headers,\n        status: this.statusCode,\n        statusText: this.statusMessage \?\? STATUS_CODES[this.statusCode]\n      })), callback && callback();\n      return;\n    }\n    this.#finished = !0, this.#ensureReadableStreamController((controller) => {\n      controller.end(), callback();\n      var deferred = this.#deferred;\n      if (deferred)\n        this.#deferred = void 0, deferred();\n    });\n  }\n  writeProcessing() {\n    throw new Error(\"not implemented\");\n  }\n  addTrailers(headers) {\n    throw new Error(\"not implemented\");\n  }\n  assignSocket(socket) {\n    throw new Error(\"not implemented\");\n  }\n  detachSocket(socket) {\n    throw new Error(\"not implemented\");\n  }\n  writeContinue(callback) {\n    throw new Error(\"not implemented\");\n  }\n  setTimeout(msecs, callback) {\n    throw new Error(\"not implemented\");\n  }\n  get shouldKeepAlive() {\n    return !0;\n  }\n  get chunkedEncoding() {\n    return !1;\n  }\n  set chunkedEncoding(value) {\n  }\n  set shouldKeepAlive(value) {\n  }\n  get useChunkedEncodingByDefault() {\n    return !0;\n  }\n  set useChunkedEncodingByDefault(value) {\n  }\n  appendHeader(name, value) {\n    var headers = this.#headers \?\?= new Headers;\n    headers.append(name, value);\n  }\n  flushHeaders() {\n  }\n  getHeader(name) {\n    return getHeader(this.#headers, name);\n  }\n  getHeaders() {\n    var headers = this.#headers;\n    if (!headers)\n      return kEmptyObject;\n    return headers.toJSON();\n  }\n  getHeaderNames() {\n    var headers = this.#headers;\n    if (!headers)\n      return [];\n    return Array.from(headers.keys());\n  }\n  removeHeader(name) {\n    if (!this.#headers)\n      return;\n    this.#headers.delete(name);\n  }\n  setHeader(name, value) {\n    var headers = this.#headers \?\?= new Headers;\n    return headers.set(name, value), this;\n  }\n  hasHeader(name) {\n    if (!this.#headers)\n      return !1;\n    return this.#headers.has(name);\n  }\n  writeHead(statusCode, statusMessage, headers) {\n    return _writeHead(statusCode, statusMessage, headers, this), this;\n  }\n}\nOriginalWriteHeadFn = ServerResponse.prototype.writeHead;\nOriginalImplicitHeadFn = ServerResponse.prototype._implicitHeader;\n\nclass ClientRequest extends OutgoingMessage {\n  #timeout;\n  #res = null;\n  #upgradeOrConnect = !1;\n  #parser = null;\n  #maxHeadersCount = null;\n  #reusedSocket = !1;\n  #host;\n  #protocol;\n  #method;\n  #port;\n  #useDefaultPort;\n  #joinDuplicateHeaders;\n  #maxHeaderSize;\n  #agent = globalAgent;\n  #path;\n  #socketPath;\n  #bodyChunks = null;\n  #fetchRequest;\n  #signal = null;\n  [kAbortController] = null;\n  #timeoutTimer = void 0;\n  #options;\n  #finished;\n  get path() {\n    return this.#path;\n  }\n  get port() {\n    return this.#port;\n  }\n  get method() {\n    return this.#method;\n  }\n  get host() {\n    return this.#host;\n  }\n  get protocol() {\n    return this.#protocol;\n  }\n  _write(chunk, encoding, callback) {\n    if (!this.#bodyChunks) {\n      this.#bodyChunks = [chunk], callback();\n      return;\n    }\n    this.#bodyChunks.push(chunk), callback();\n  }\n  _writev(chunks, callback) {\n    if (!this.#bodyChunks) {\n      this.#bodyChunks = chunks, callback();\n      return;\n    }\n    this.#bodyChunks.push(...chunks), callback();\n  }\n  _final(callback) {\n    if (this.#finished = !0, this[kAbortController] = new AbortController, this[kAbortController].signal.addEventListener(\"abort\", () => {\n      this[kClearTimeout]();\n    }), this.#signal\?.aborted)\n      this[kAbortController].abort();\n    var method = this.#method, body = this.#bodyChunks\?.length === 1 \? this.#bodyChunks[0] : Buffer.concat(this.#bodyChunks || []);\n    try {\n      this.#fetchRequest = fetch(`${this.#protocol}//${this.#host}${this.#useDefaultPort \? \"\" : \":\" + this.#port}${this.#path}`, {\n        method,\n        headers: this.getHeaders(),\n        body: body && method !== \"GET\" && method !== \"HEAD\" && method !== \"OPTIONS\" \? body : void 0,\n        redirect: \"manual\",\n        verbose: !1,\n        signal: this[kAbortController].signal,\n        timeout: !1\n      }).then((response) => {\n        var res = this.#res = new IncomingMessage(response, {\n          type: \"response\",\n          [kInternalRequest]: this\n        });\n        this.emit(\"response\", res);\n      }).catch((err) => {\n        this.emit(\"error\", err);\n      }).finally(() => {\n        this.#fetchRequest = null, this[kClearTimeout]();\n      });\n    } catch (err) {\n      this.emit(\"error\", err);\n    } finally {\n      callback();\n    }\n  }\n  get aborted() {\n    return this.#signal\?.aborted || !!this[kAbortController]\?.signal.aborted;\n  }\n  abort() {\n    if (this.aborted)\n      return;\n    this[kAbortController].abort();\n  }\n  constructor(input, options, cb) {\n    super();\n    if (typeof input === \"string\") {\n      const urlStr = input;\n      try {\n        var urlObject = new URL(urlStr);\n      } catch (e) {\n        @throwTypeError(`Invalid URL: ${urlStr}`);\n      }\n      input = urlToHttpOptions(urlObject);\n    } else if (input && typeof input === \"object\" && input instanceof URL)\n      input = urlToHttpOptions(input);\n    else\n      cb = options, options = input, input = null;\n    if (typeof options === \"function\")\n      cb = options, options = input || kEmptyObject;\n    else\n      options = ObjectAssign(input || {}, options);\n    var defaultAgent = options._defaultAgent || Agent.globalAgent;\n    let protocol = options.protocol;\n    if (!protocol)\n      if (options.port === 443)\n        protocol = \"https:\";\n      else\n        protocol = defaultAgent.protocol || \"http:\";\n    switch (this.#protocol = protocol, this.#agent\?.protocol) {\n      case void 0:\n        break;\n      case \"http:\":\n        if (protocol === \"https:\") {\n          defaultAgent = this.#agent = getDefaultHTTPSAgent();\n          break;\n        }\n      case \"https:\":\n        if (protocol === \"https\") {\n          defaultAgent = this.#agent = Agent.globalAgent;\n          break;\n        }\n      default:\n        break;\n    }\n    if (options.path) {\n      const path = String(options.path);\n      if (RegExpPrototypeExec.call(INVALID_PATH_REGEX, path) !== null)\n        throw new Error(\"Path contains unescaped characters\");\n    }\n    if (protocol !== \"http:\" && protocol !== \"https:\" && protocol) {\n      const expectedProtocol = defaultAgent\?.protocol \?\? \"http:\";\n      throw new Error(`Protocol mismatch. Expected: ${expectedProtocol}. Got: ${protocol}`);\n    }\n    const defaultPort = protocol === \"https:\" \? 443 : 80;\n    this.#port = options.port || options.defaultPort || this.#agent\?.defaultPort || defaultPort, this.#useDefaultPort = this.#port === defaultPort;\n    const host = this.#host = options.host = validateHost(options.hostname, \"hostname\") || validateHost(options.host, \"host\") || \"localhost\";\n    this.#socketPath = options.socketPath;\n    const signal = options.signal;\n    if (signal)\n      signal.addEventListener(\"abort\", () => {\n        this[kAbortController]\?.abort();\n      }), this.#signal = signal;\n    let method = options.method;\n    const methodIsString = typeof method === \"string\";\n    if (method !== null && method !== void 0 && !methodIsString)\n      throw new Error(\"ERR_INVALID_ARG_TYPE: options.method\");\n    if (methodIsString && method) {\n      if (!checkIsHttpToken(method))\n        throw new Error(\"ERR_INVALID_HTTP_TOKEN: Method\");\n      method = this.#method = StringPrototypeToUpperCase.call(method);\n    } else\n      method = this.#method = \"GET\";\n    const _maxHeaderSize = options.maxHeaderSize;\n    this.#maxHeaderSize = _maxHeaderSize;\n    var _joinDuplicateHeaders = options.joinDuplicateHeaders;\n    if (this.#joinDuplicateHeaders = _joinDuplicateHeaders, this.#path = options.path || \"/\", cb)\n      this.once(\"response\", cb);\n    this.#finished = !1, this.#res = null, this.#upgradeOrConnect = !1, this.#parser = null, this.#maxHeadersCount = null, this.#reusedSocket = !1, this.#host = host, this.#protocol = protocol;\n    var timeout = options.timeout;\n    if (timeout !== void 0 && timeout !== 0)\n      this.setTimeout(timeout, void 0);\n    if (!ArrayIsArray(headers)) {\n      var headers = options.headers;\n      if (headers)\n        for (let key in headers)\n          this.setHeader(key, headers[key]);\n      var auth = options.auth;\n      if (auth && !this.getHeader(\"Authorization\"))\n        this.setHeader(\"Authorization\", \"Basic \" + Buffer.from(auth).toString(\"base64\"));\n    }\n    var { signal: _signal, ...optsWithoutSignal } = options;\n    this.#options = optsWithoutSignal;\n  }\n  setSocketKeepAlive(enable = !0, initialDelay = 0) {\n  }\n  setNoDelay(noDelay = !0) {\n  }\n  [kClearTimeout]() {\n    if (this.#timeoutTimer)\n      clearTimeout(this.#timeoutTimer), this.#timeoutTimer = void 0, this.removeAllListeners(\"timeout\");\n  }\n  #onTimeout() {\n    this.#timeoutTimer = void 0, this[kAbortController]\?.abort(), this.emit(\"timeout\");\n  }\n  setTimeout(msecs, callback) {\n    if (this.destroyed)\n      return this;\n    if (this.timeout = msecs = validateMsecs(msecs, \"msecs\"), clearTimeout(this.#timeoutTimer), msecs === 0) {\n      if (callback !== void 0)\n        validateFunction(callback, \"callback\"), this.removeListener(\"timeout\", callback);\n      this.#timeoutTimer = void 0;\n    } else if (this.#timeoutTimer = setTimeout(this.#onTimeout.bind(this), msecs).unref(), callback !== void 0)\n      validateFunction(callback, \"callback\"), this.once(\"timeout\", callback);\n    return this;\n  }\n}\nvar tokenRegExp = /^[\\^_`a-zA-Z\\-0-9!#$%&'*+.|~]+$/, METHODS = [\n  \"ACL\",\n  \"BIND\",\n  \"CHECKOUT\",\n  \"CONNECT\",\n  \"COPY\",\n  \"DELETE\",\n  \"GET\",\n  \"HEAD\",\n  \"LINK\",\n  \"LOCK\",\n  \"M-SEARCH\",\n  \"MERGE\",\n  \"MKACTIVITY\",\n  \"MKCALENDAR\",\n  \"MKCOL\",\n  \"MOVE\",\n  \"NOTIFY\",\n  \"OPTIONS\",\n  \"PATCH\",\n  \"POST\",\n  \"PROPFIND\",\n  \"PROPPATCH\",\n  \"PURGE\",\n  \"PUT\",\n  \"REBIND\",\n  \"REPORT\",\n  \"SEARCH\",\n  \"SOURCE\",\n  \"SUBSCRIBE\",\n  \"TRACE\",\n  \"UNBIND\",\n  \"UNLINK\",\n  \"UNLOCK\",\n  \"UNSUBSCRIBE\"\n], STATUS_CODES = {\n  100: \"Continue\",\n  101: \"Switching Protocols\",\n  102: \"Processing\",\n  103: \"Early Hints\",\n  200: \"OK\",\n  201: \"Created\",\n  202: \"Accepted\",\n  203: \"Non-Authoritative Information\",\n  204: \"No Content\",\n  205: \"Reset Content\",\n  206: \"Partial Content\",\n  207: \"Multi-Status\",\n  208: \"Already Reported\",\n  226: \"IM Used\",\n  300: \"Multiple Choices\",\n  301: \"Moved Permanently\",\n  302: \"Found\",\n  303: \"See Other\",\n  304: \"Not Modified\",\n  305: \"Use Proxy\",\n  307: \"Temporary Redirect\",\n  308: \"Permanent Redirect\",\n  400: \"Bad Request\",\n  401: \"Unauthorized\",\n  402: \"Payment Required\",\n  403: \"Forbidden\",\n  404: \"Not Found\",\n  405: \"Method Not Allowed\",\n  406: \"Not Acceptable\",\n  407: \"Proxy Authentication Required\",\n  408: \"Request Timeout\",\n  409: \"Conflict\",\n  410: \"Gone\",\n  411: \"Length Required\",\n  412: \"Precondition Failed\",\n  413: \"Payload Too Large\",\n  414: \"URI Too Long\",\n  415: \"Unsupported Media Type\",\n  416: \"Range Not Satisfiable\",\n  417: \"Expectation Failed\",\n  418: \"I'm a Teapot\",\n  421: \"Misdirected Request\",\n  422: \"Unprocessable Entity\",\n  423: \"Locked\",\n  424: \"Failed Dependency\",\n  425: \"Too Early\",\n  426: \"Upgrade Required\",\n  428: \"Precondition Required\",\n  429: \"Too Many Requests\",\n  431: \"Request Header Fields Too Large\",\n  451: \"Unavailable For Legal Reasons\",\n  500: \"Internal Server Error\",\n  501: \"Not Implemented\",\n  502: \"Bad Gateway\",\n  503: \"Service Unavailable\",\n  504: \"Gateway Timeout\",\n  505: \"HTTP Version Not Supported\",\n  506: \"Variant Also Negotiates\",\n  507: \"Insufficient Storage\",\n  508: \"Loop Detected\",\n  509: \"Bandwidth Limit Exceeded\",\n  510: \"Not Extended\",\n  511: \"Network Authentication Required\"\n}, globalAgent = new Agent;\n$ = {\n  Agent,\n  Server,\n  METHODS,\n  STATUS_CODES,\n  createServer,\n  ServerResponse,\n  IncomingMessage,\n  request,\n  get,\n  maxHeaderSize: 16384,\n  validateHeaderName,\n  validateHeaderValue,\n  setMaxIdleHTTPParsers(max) {\n  },\n  globalAgent,\n  ClientRequest,\n  OutgoingMessage\n};\nreturn $})\n"_s;
//

//
static constexpr ASCIILiteral NodeHttp2Code = "(function (){\"use strict\";// src/js/out/tmp/node/http2.ts\nvar connect = function() {\n  throwNotImplemented(\"node:http2 connect\", 887);\n}, createServer = function() {\n  throwNotImplemented(\"node:http2 createServer\", 887);\n}, createSecureServer = function() {\n  throwNotImplemented(\"node:http2 createSecureServer\", 887);\n}, getDefaultSettings = function() {\n  return {\n    headerTableSize: 4096,\n    enablePush: !0,\n    initialWindowSize: 65535,\n    maxFrameSize: 16384,\n    maxConcurrentStreams: 4294967295,\n    maxHeaderSize: 65535,\n    maxHeaderListSize: 65535,\n    enableConnectProtocol: !1\n  };\n}, getPackedSettings = function() {\n  return Buffer.alloc(0);\n}, getUnpackedSettings = function() {\n  return Buffer.alloc(0);\n}, Http2ServerRequest = function() {\n  throwNotImplemented(\"node:http2 Http2ServerRequest\", 887);\n}, Http2ServerResponse = function() {\n  throwNotImplemented(\"node:http2 Http2ServerResponse\", 887);\n}, $, { hideFromStack, throwNotImplemented } = @getInternalField(@internalModuleRegistry, 3) || @createInternalModuleById(3), constants = {\n  NGHTTP2_ERR_FRAME_SIZE_ERROR: -522,\n  NGHTTP2_SESSION_SERVER: 0,\n  NGHTTP2_SESSION_CLIENT: 1,\n  NGHTTP2_STREAM_STATE_IDLE: 1,\n  NGHTTP2_STREAM_STATE_OPEN: 2,\n  NGHTTP2_STREAM_STATE_RESERVED_LOCAL: 3,\n  NGHTTP2_STREAM_STATE_RESERVED_REMOTE: 4,\n  NGHTTP2_STREAM_STATE_HALF_CLOSED_LOCAL: 5,\n  NGHTTP2_STREAM_STATE_HALF_CLOSED_REMOTE: 6,\n  NGHTTP2_STREAM_STATE_CLOSED: 7,\n  NGHTTP2_FLAG_NONE: 0,\n  NGHTTP2_FLAG_END_STREAM: 1,\n  NGHTTP2_FLAG_END_HEADERS: 4,\n  NGHTTP2_FLAG_ACK: 1,\n  NGHTTP2_FLAG_PADDED: 8,\n  NGHTTP2_FLAG_PRIORITY: 32,\n  DEFAULT_SETTINGS_HEADER_TABLE_SIZE: 4096,\n  DEFAULT_SETTINGS_ENABLE_PUSH: 1,\n  DEFAULT_SETTINGS_MAX_CONCURRENT_STREAMS: 4294967295,\n  DEFAULT_SETTINGS_INITIAL_WINDOW_SIZE: 65535,\n  DEFAULT_SETTINGS_MAX_FRAME_SIZE: 16384,\n  DEFAULT_SETTINGS_MAX_HEADER_LIST_SIZE: 65535,\n  DEFAULT_SETTINGS_ENABLE_CONNECT_PROTOCOL: 0,\n  MAX_MAX_FRAME_SIZE: 16777215,\n  MIN_MAX_FRAME_SIZE: 16384,\n  MAX_INITIAL_WINDOW_SIZE: 2147483647,\n  NGHTTP2_SETTINGS_HEADER_TABLE_SIZE: 1,\n  NGHTTP2_SETTINGS_ENABLE_PUSH: 2,\n  NGHTTP2_SETTINGS_MAX_CONCURRENT_STREAMS: 3,\n  NGHTTP2_SETTINGS_INITIAL_WINDOW_SIZE: 4,\n  NGHTTP2_SETTINGS_MAX_FRAME_SIZE: 5,\n  NGHTTP2_SETTINGS_MAX_HEADER_LIST_SIZE: 6,\n  NGHTTP2_SETTINGS_ENABLE_CONNECT_PROTOCOL: 8,\n  PADDING_STRATEGY_NONE: 0,\n  PADDING_STRATEGY_ALIGNED: 1,\n  PADDING_STRATEGY_MAX: 2,\n  PADDING_STRATEGY_CALLBACK: 1,\n  NGHTTP2_NO_ERROR: 0,\n  NGHTTP2_PROTOCOL_ERROR: 1,\n  NGHTTP2_INTERNAL_ERROR: 2,\n  NGHTTP2_FLOW_CONTROL_ERROR: 3,\n  NGHTTP2_SETTINGS_TIMEOUT: 4,\n  NGHTTP2_STREAM_CLOSED: 5,\n  NGHTTP2_FRAME_SIZE_ERROR: 6,\n  NGHTTP2_REFUSED_STREAM: 7,\n  NGHTTP2_CANCEL: 8,\n  NGHTTP2_COMPRESSION_ERROR: 9,\n  NGHTTP2_CONNECT_ERROR: 10,\n  NGHTTP2_ENHANCE_YOUR_CALM: 11,\n  NGHTTP2_INADEQUATE_SECURITY: 12,\n  NGHTTP2_HTTP_1_1_REQUIRED: 13,\n  NGHTTP2_DEFAULT_WEIGHT: 16,\n  HTTP2_HEADER_STATUS: \":status\",\n  HTTP2_HEADER_METHOD: \":method\",\n  HTTP2_HEADER_AUTHORITY: \":authority\",\n  HTTP2_HEADER_SCHEME: \":scheme\",\n  HTTP2_HEADER_PATH: \":path\",\n  HTTP2_HEADER_PROTOCOL: \":protocol\",\n  HTTP2_HEADER_ACCEPT_ENCODING: \"accept-encoding\",\n  HTTP2_HEADER_ACCEPT_LANGUAGE: \"accept-language\",\n  HTTP2_HEADER_ACCEPT_RANGES: \"accept-ranges\",\n  HTTP2_HEADER_ACCEPT: \"accept\",\n  HTTP2_HEADER_ACCESS_CONTROL_ALLOW_CREDENTIALS: \"access-control-allow-credentials\",\n  HTTP2_HEADER_ACCESS_CONTROL_ALLOW_HEADERS: \"access-control-allow-headers\",\n  HTTP2_HEADER_ACCESS_CONTROL_ALLOW_METHODS: \"access-control-allow-methods\",\n  HTTP2_HEADER_ACCESS_CONTROL_ALLOW_ORIGIN: \"access-control-allow-origin\",\n  HTTP2_HEADER_ACCESS_CONTROL_EXPOSE_HEADERS: \"access-control-expose-headers\",\n  HTTP2_HEADER_ACCESS_CONTROL_REQUEST_HEADERS: \"access-control-request-headers\",\n  HTTP2_HEADER_ACCESS_CONTROL_REQUEST_METHOD: \"access-control-request-method\",\n  HTTP2_HEADER_AGE: \"age\",\n  HTTP2_HEADER_AUTHORIZATION: \"authorization\",\n  HTTP2_HEADER_CACHE_CONTROL: \"cache-control\",\n  HTTP2_HEADER_CONNECTION: \"connection\",\n  HTTP2_HEADER_CONTENT_DISPOSITION: \"content-disposition\",\n  HTTP2_HEADER_CONTENT_ENCODING: \"content-encoding\",\n  HTTP2_HEADER_CONTENT_LENGTH: \"content-length\",\n  HTTP2_HEADER_CONTENT_TYPE: \"content-type\",\n  HTTP2_HEADER_COOKIE: \"cookie\",\n  HTTP2_HEADER_DATE: \"date\",\n  HTTP2_HEADER_ETAG: \"etag\",\n  HTTP2_HEADER_FORWARDED: \"forwarded\",\n  HTTP2_HEADER_HOST: \"host\",\n  HTTP2_HEADER_IF_MODIFIED_SINCE: \"if-modified-since\",\n  HTTP2_HEADER_IF_NONE_MATCH: \"if-none-match\",\n  HTTP2_HEADER_IF_RANGE: \"if-range\",\n  HTTP2_HEADER_LAST_MODIFIED: \"last-modified\",\n  HTTP2_HEADER_LINK: \"link\",\n  HTTP2_HEADER_LOCATION: \"location\",\n  HTTP2_HEADER_RANGE: \"range\",\n  HTTP2_HEADER_REFERER: \"referer\",\n  HTTP2_HEADER_SERVER: \"server\",\n  HTTP2_HEADER_SET_COOKIE: \"set-cookie\",\n  HTTP2_HEADER_STRICT_TRANSPORT_SECURITY: \"strict-transport-security\",\n  HTTP2_HEADER_TRANSFER_ENCODING: \"transfer-encoding\",\n  HTTP2_HEADER_TE: \"te\",\n  HTTP2_HEADER_UPGRADE_INSECURE_REQUESTS: \"upgrade-insecure-requests\",\n  HTTP2_HEADER_UPGRADE: \"upgrade\",\n  HTTP2_HEADER_USER_AGENT: \"user-agent\",\n  HTTP2_HEADER_VARY: \"vary\",\n  HTTP2_HEADER_X_CONTENT_TYPE_OPTIONS: \"x-content-type-options\",\n  HTTP2_HEADER_X_FRAME_OPTIONS: \"x-frame-options\",\n  HTTP2_HEADER_KEEP_ALIVE: \"keep-alive\",\n  HTTP2_HEADER_PROXY_CONNECTION: \"proxy-connection\",\n  HTTP2_HEADER_X_XSS_PROTECTION: \"x-xss-protection\",\n  HTTP2_HEADER_ALT_SVC: \"alt-svc\",\n  HTTP2_HEADER_CONTENT_SECURITY_POLICY: \"content-security-policy\",\n  HTTP2_HEADER_EARLY_DATA: \"early-data\",\n  HTTP2_HEADER_EXPECT_CT: \"expect-ct\",\n  HTTP2_HEADER_ORIGIN: \"origin\",\n  HTTP2_HEADER_PURPOSE: \"purpose\",\n  HTTP2_HEADER_TIMING_ALLOW_ORIGIN: \"timing-allow-origin\",\n  HTTP2_HEADER_X_FORWARDED_FOR: \"x-forwarded-for\",\n  HTTP2_HEADER_PRIORITY: \"priority\",\n  HTTP2_HEADER_ACCEPT_CHARSET: \"accept-charset\",\n  HTTP2_HEADER_ACCESS_CONTROL_MAX_AGE: \"access-control-max-age\",\n  HTTP2_HEADER_ALLOW: \"allow\",\n  HTTP2_HEADER_CONTENT_LANGUAGE: \"content-language\",\n  HTTP2_HEADER_CONTENT_LOCATION: \"content-location\",\n  HTTP2_HEADER_CONTENT_MD5: \"content-md5\",\n  HTTP2_HEADER_CONTENT_RANGE: \"content-range\",\n  HTTP2_HEADER_DNT: \"dnt\",\n  HTTP2_HEADER_EXPECT: \"expect\",\n  HTTP2_HEADER_EXPIRES: \"expires\",\n  HTTP2_HEADER_FROM: \"from\",\n  HTTP2_HEADER_IF_MATCH: \"if-match\",\n  HTTP2_HEADER_IF_UNMODIFIED_SINCE: \"if-unmodified-since\",\n  HTTP2_HEADER_MAX_FORWARDS: \"max-forwards\",\n  HTTP2_HEADER_PREFER: \"prefer\",\n  HTTP2_HEADER_PROXY_AUTHENTICATE: \"proxy-authenticate\",\n  HTTP2_HEADER_PROXY_AUTHORIZATION: \"proxy-authorization\",\n  HTTP2_HEADER_REFRESH: \"refresh\",\n  HTTP2_HEADER_RETRY_AFTER: \"retry-after\",\n  HTTP2_HEADER_TRAILER: \"trailer\",\n  HTTP2_HEADER_TK: \"tk\",\n  HTTP2_HEADER_VIA: \"via\",\n  HTTP2_HEADER_WARNING: \"warning\",\n  HTTP2_HEADER_WWW_AUTHENTICATE: \"www-authenticate\",\n  HTTP2_HEADER_HTTP2_SETTINGS: \"http2-settings\",\n  HTTP2_METHOD_ACL: \"ACL\",\n  HTTP2_METHOD_BASELINE_CONTROL: \"BASELINE-CONTROL\",\n  HTTP2_METHOD_BIND: \"BIND\",\n  HTTP2_METHOD_CHECKIN: \"CHECKIN\",\n  HTTP2_METHOD_CHECKOUT: \"CHECKOUT\",\n  HTTP2_METHOD_CONNECT: \"CONNECT\",\n  HTTP2_METHOD_COPY: \"COPY\",\n  HTTP2_METHOD_DELETE: \"DELETE\",\n  HTTP2_METHOD_GET: \"GET\",\n  HTTP2_METHOD_HEAD: \"HEAD\",\n  HTTP2_METHOD_LABEL: \"LABEL\",\n  HTTP2_METHOD_LINK: \"LINK\",\n  HTTP2_METHOD_LOCK: \"LOCK\",\n  HTTP2_METHOD_MERGE: \"MERGE\",\n  HTTP2_METHOD_MKACTIVITY: \"MKACTIVITY\",\n  HTTP2_METHOD_MKCALENDAR: \"MKCALENDAR\",\n  HTTP2_METHOD_MKCOL: \"MKCOL\",\n  HTTP2_METHOD_MKREDIRECTREF: \"MKREDIRECTREF\",\n  HTTP2_METHOD_MKWORKSPACE: \"MKWORKSPACE\",\n  HTTP2_METHOD_MOVE: \"MOVE\",\n  HTTP2_METHOD_OPTIONS: \"OPTIONS\",\n  HTTP2_METHOD_ORDERPATCH: \"ORDERPATCH\",\n  HTTP2_METHOD_PATCH: \"PATCH\",\n  HTTP2_METHOD_POST: \"POST\",\n  HTTP2_METHOD_PRI: \"PRI\",\n  HTTP2_METHOD_PROPFIND: \"PROPFIND\",\n  HTTP2_METHOD_PROPPATCH: \"PROPPATCH\",\n  HTTP2_METHOD_PUT: \"PUT\",\n  HTTP2_METHOD_REBIND: \"REBIND\",\n  HTTP2_METHOD_REPORT: \"REPORT\",\n  HTTP2_METHOD_SEARCH: \"SEARCH\",\n  HTTP2_METHOD_TRACE: \"TRACE\",\n  HTTP2_METHOD_UNBIND: \"UNBIND\",\n  HTTP2_METHOD_UNCHECKOUT: \"UNCHECKOUT\",\n  HTTP2_METHOD_UNLINK: \"UNLINK\",\n  HTTP2_METHOD_UNLOCK: \"UNLOCK\",\n  HTTP2_METHOD_UPDATE: \"UPDATE\",\n  HTTP2_METHOD_UPDATEREDIRECTREF: \"UPDATEREDIRECTREF\",\n  HTTP2_METHOD_VERSION_CONTROL: \"VERSION-CONTROL\",\n  HTTP_STATUS_CONTINUE: 100,\n  HTTP_STATUS_SWITCHING_PROTOCOLS: 101,\n  HTTP_STATUS_PROCESSING: 102,\n  HTTP_STATUS_EARLY_HINTS: 103,\n  HTTP_STATUS_OK: 200,\n  HTTP_STATUS_CREATED: 201,\n  HTTP_STATUS_ACCEPTED: 202,\n  HTTP_STATUS_NON_AUTHORITATIVE_INFORMATION: 203,\n  HTTP_STATUS_NO_CONTENT: 204,\n  HTTP_STATUS_RESET_CONTENT: 205,\n  HTTP_STATUS_PARTIAL_CONTENT: 206,\n  HTTP_STATUS_MULTI_STATUS: 207,\n  HTTP_STATUS_ALREADY_REPORTED: 208,\n  HTTP_STATUS_IM_USED: 226,\n  HTTP_STATUS_MULTIPLE_CHOICES: 300,\n  HTTP_STATUS_MOVED_PERMANENTLY: 301,\n  HTTP_STATUS_FOUND: 302,\n  HTTP_STATUS_SEE_OTHER: 303,\n  HTTP_STATUS_NOT_MODIFIED: 304,\n  HTTP_STATUS_USE_PROXY: 305,\n  HTTP_STATUS_TEMPORARY_REDIRECT: 307,\n  HTTP_STATUS_PERMANENT_REDIRECT: 308,\n  HTTP_STATUS_BAD_REQUEST: 400,\n  HTTP_STATUS_UNAUTHORIZED: 401,\n  HTTP_STATUS_PAYMENT_REQUIRED: 402,\n  HTTP_STATUS_FORBIDDEN: 403,\n  HTTP_STATUS_NOT_FOUND: 404,\n  HTTP_STATUS_METHOD_NOT_ALLOWED: 405,\n  HTTP_STATUS_NOT_ACCEPTABLE: 406,\n  HTTP_STATUS_PROXY_AUTHENTICATION_REQUIRED: 407,\n  HTTP_STATUS_REQUEST_TIMEOUT: 408,\n  HTTP_STATUS_CONFLICT: 409,\n  HTTP_STATUS_GONE: 410,\n  HTTP_STATUS_LENGTH_REQUIRED: 411,\n  HTTP_STATUS_PRECONDITION_FAILED: 412,\n  HTTP_STATUS_PAYLOAD_TOO_LARGE: 413,\n  HTTP_STATUS_URI_TOO_LONG: 414,\n  HTTP_STATUS_UNSUPPORTED_MEDIA_TYPE: 415,\n  HTTP_STATUS_RANGE_NOT_SATISFIABLE: 416,\n  HTTP_STATUS_EXPECTATION_FAILED: 417,\n  HTTP_STATUS_TEAPOT: 418,\n  HTTP_STATUS_MISDIRECTED_REQUEST: 421,\n  HTTP_STATUS_UNPROCESSABLE_ENTITY: 422,\n  HTTP_STATUS_LOCKED: 423,\n  HTTP_STATUS_FAILED_DEPENDENCY: 424,\n  HTTP_STATUS_TOO_EARLY: 425,\n  HTTP_STATUS_UPGRADE_REQUIRED: 426,\n  HTTP_STATUS_PRECONDITION_REQUIRED: 428,\n  HTTP_STATUS_TOO_MANY_REQUESTS: 429,\n  HTTP_STATUS_REQUEST_HEADER_FIELDS_TOO_LARGE: 431,\n  HTTP_STATUS_UNAVAILABLE_FOR_LEGAL_REASONS: 451,\n  HTTP_STATUS_INTERNAL_SERVER_ERROR: 500,\n  HTTP_STATUS_NOT_IMPLEMENTED: 501,\n  HTTP_STATUS_BAD_GATEWAY: 502,\n  HTTP_STATUS_SERVICE_UNAVAILABLE: 503,\n  HTTP_STATUS_GATEWAY_TIMEOUT: 504,\n  HTTP_STATUS_HTTP_VERSION_NOT_SUPPORTED: 505,\n  HTTP_STATUS_VARIANT_ALSO_NEGOTIATES: 506,\n  HTTP_STATUS_INSUFFICIENT_STORAGE: 507,\n  HTTP_STATUS_LOOP_DETECTED: 508,\n  HTTP_STATUS_BANDWIDTH_LIMIT_EXCEEDED: 509,\n  HTTP_STATUS_NOT_EXTENDED: 510,\n  HTTP_STATUS_NETWORK_AUTHENTICATION_REQUIRED: 511\n}, sensitiveHeaders = Symbol.for(\"nodejs.http2.sensitiveHeaders\");\n$ = {\n  constants,\n  createServer,\n  createSecureServer,\n  getDefaultSettings,\n  getPackedSettings,\n  getUnpackedSettings,\n  sensitiveHeaders,\n  Http2ServerRequest,\n  Http2ServerResponse,\n  connect\n};\nhideFromStack([\n  Http2ServerRequest,\n  Http2ServerResponse,\n  connect,\n  createServer,\n  createSecureServer,\n  getDefaultSettings,\n  getPackedSettings,\n  getUnpackedSettings\n]);\nreturn $})\n"_s;
//

//
static constexpr ASCIILiteral NodeHttpsCode = "(function (){\"use strict\";// src/js/out/tmp/node/https.ts\nvar request = function(input, options, cb) {\n  if (input && typeof input === \"object\" && !(input instanceof URL))\n    input.protocol \?\?= \"https:\";\n  else if (typeof options === \"object\")\n    options.protocol \?\?= \"https:\";\n  return http.request(input, options, cb);\n}, get = function(input, options, cb) {\n  const req = request(input, options, cb);\n  return req.end(), req;\n}, $, http = @getInternalField(@internalModuleRegistry, 19) || @createInternalModuleById(19);\n$ = {\n  ...http,\n  get,\n  request\n};\nreturn $})\n"_s;
//

//
static constexpr ASCIILiteral NodeInspectorCode = "(function (){\"use strict\";// src/js/out/tmp/node/inspector.ts\nvar open = function() {\n  throwNotImplemented(\"node:inspector open\", 2445);\n}, close = function() {\n  throwNotImplemented(\"node:inspector close\", 2445);\n}, url = function() {\n  throwNotImplemented(\"node:inspector url\", 2445);\n}, waitForDebugger = function() {\n  throwNotImplemented(\"node:inspector waitForDebugger\", 2445);\n}, $, { hideFromStack, throwNotImplemented } = @getInternalField(@internalModuleRegistry, 3) || @createInternalModuleById(3), EventEmitter = @getInternalField(@internalModuleRegistry, 16) || @createInternalModuleById(16);\n\nclass Session extends EventEmitter {\n  constructor() {\n    super();\n    throwNotImplemented(\"node:inspector Session\", 2445);\n  }\n}\nvar console = {\n  ...globalThis.console,\n  context: {\n    console: globalThis.console\n  }\n};\n$ = {\n  console,\n  open,\n  close,\n  url,\n  waitForDebugger,\n  Session\n};\nhideFromStack(open, close, url, waitForDebugger, Session.prototype.constructor);\nreturn $})\n"_s;
//

//
static constexpr ASCIILiteral NodeNetCode = "(function (){\"use strict\";// src/js/out/tmp/node/net.ts\nvar isIPv4 = function(s) {\n  return IPv4Reg.test(s);\n}, isIPv6 = function(s) {\n  return IPv6Reg.test(s);\n}, isIP = function(s) {\n  if (isIPv4(s))\n    return 4;\n  if (isIPv6(s))\n    return 6;\n  return 0;\n}, createConnection = function(port, host, connectListener) {\n  if (typeof port === \"object\")\n    return new Socket(port).connect(port, host, connectListener);\n  return new Socket().connect(port, host, connectListener);\n}, emitErrorNextTick = function(self, error) {\n  self.emit(\"error\", error);\n}, emitListeningNextTick = function(self, onListen) {\n  if (typeof onListen === \"function\")\n    try {\n      onListen();\n    } catch (err) {\n      self.emit(\"error\", err);\n    }\n  self.emit(\"listening\");\n}, createServer = function(options, connectionListener) {\n  return new Server(options, connectionListener);\n}, $, { Duplex } = @getInternalField(@internalModuleRegistry, 35) || @createInternalModuleById(35), EventEmitter = @getInternalField(@internalModuleRegistry, 16) || @createInternalModuleById(16);\nvar IPv4Reg = new RegExp(\"^((\?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])[.]){3}(\?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])$\");\nvar IPv6Reg = new RegExp(\"^((\?:(\?:[0-9a-fA-F]{1,4}):){7}(\?:(\?:[0-9a-fA-F]{1,4})|:)|(\?:(\?:[0-9a-fA-F]{1,4}):){6}(\?:((\?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])[.]){3}(\?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])|:(\?:[0-9a-fA-F]{1,4})|:)|(\?:(\?:[0-9a-fA-F]{1,4}):){5}(\?::((\?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])[.]){3}(\?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])|(:(\?:[0-9a-fA-F]{1,4})){1,2}|:)|(\?:(\?:[0-9a-fA-F]{1,4}):){4}(\?:(:(\?:[0-9a-fA-F]{1,4})){0,1}:((\?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])[.]){3}(\?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])|(:(\?:[0-9a-fA-F]{1,4})){1,3}|:)|(\?:(\?:[0-9a-fA-F]{1,4}):){3}(\?:(:(\?:[0-9a-fA-F]{1,4})){0,2}:((\?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])[.]){3}(\?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])|(:(\?:[0-9a-fA-F]{1,4})){1,4}|:)|(\?:(\?:[0-9a-fA-F]{1,4}):){2}(\?:(:(\?:[0-9a-fA-F]{1,4})){0,3}:((\?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])[.]){3}(\?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])|(:(\?:[0-9a-fA-F]{1,4})){1,5}|:)|(\?:(\?:[0-9a-fA-F]{1,4}):){1}(\?:(:(\?:[0-9a-fA-F]{1,4})){0,4}:((\?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])[.]){3}(\?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])|(:(\?:[0-9a-fA-F]{1,4})){1,6}|:)|(\?::((\?::(\?:[0-9a-fA-F]{1,4})){0,5}:((\?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])[.]){3}(\?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])|(\?::(\?:[0-9a-fA-F]{1,4})){1,7}|:)))(%[0-9a-zA-Z-.:]{1,})\?$\"), { connect: bunConnect } = Bun, { setTimeout } = globalThis, bunTlsSymbol = Symbol.for(\"::buntls::\"), bunSocketServerHandlers = Symbol.for(\"::bunsocket_serverhandlers::\"), bunSocketServerConnections = Symbol.for(\"::bunnetserverconnections::\"), bunSocketServerOptions = Symbol.for(\"::bunnetserveroptions::\"), bunSocketInternal = Symbol.for(\"::bunnetsocketinternal::\"), bunTLSConnectOptions = Symbol.for(\"::buntlsconnectoptions::\"), SocketClass, Socket = function(InternalSocket) {\n  return SocketClass = InternalSocket, Object.defineProperty(SocketClass.prototype, Symbol.toStringTag, {\n    value: \"Socket\",\n    enumerable: !1\n  }), Object.defineProperty(function Socket(options) {\n    return new InternalSocket(options);\n  }, Symbol.hasInstance, {\n    value(instance) {\n      return instance instanceof InternalSocket;\n    }\n  });\n}(class Socket2 extends Duplex {\n  static #Handlers = {\n    close: Socket2.#Close,\n    connectError(socket, error) {\n      socket.data.emit(\"error\", error);\n    },\n    data({ data: self }, buffer) {\n      self.bytesRead += buffer.length;\n      const queue = self.#readQueue;\n      if (queue.isEmpty()) {\n        if (self.push(buffer))\n          return;\n      }\n      queue.push(buffer);\n    },\n    drain: Socket2.#Drain,\n    end: Socket2.#Close,\n    error(socket, error) {\n      const self = socket.data, callback = self.#writeCallback;\n      if (callback)\n        self.#writeCallback = null, callback(error);\n      self.emit(\"error\", error);\n    },\n    open(socket) {\n      const self = socket.data;\n      socket.timeout(self.timeout), socket.ref(), self[bunSocketInternal] = socket, self.connecting = !1;\n      const options = self[bunTLSConnectOptions];\n      if (options) {\n        const { session } = options;\n        if (session)\n          self.setSession(session);\n      }\n      if (!self.#upgraded)\n        self.emit(\"connect\", self);\n      Socket2.#Drain(socket);\n    },\n    handshake(socket, success, verifyError) {\n      const { data: self } = socket;\n      self._securePending = !1, self.secureConnecting = !1, self._secureEstablished = !!success, self.emit(\"secure\", self);\n      const { checkServerIdentity } = self[bunTLSConnectOptions];\n      if (!verifyError && typeof checkServerIdentity === \"function\" && self.servername) {\n        const cert = self.getPeerCertificate(!0);\n        verifyError = checkServerIdentity(self.servername, cert);\n      }\n      if (self._requestCert || self._rejectUnauthorized) {\n        if (verifyError) {\n          if (self.authorized = !1, self.authorizationError = verifyError.code || verifyError.message, self._rejectUnauthorized) {\n            self.destroy(verifyError);\n            return;\n          }\n        }\n      } else\n        self.authorized = !0;\n      self.emit(\"secureConnect\", verifyError);\n    },\n    timeout(socket) {\n      const self = socket.data;\n      self.emit(\"timeout\", self);\n    },\n    binaryType: \"buffer\"\n  };\n  static #Close(socket) {\n    const self = socket.data;\n    if (self.#closed)\n      return;\n    self.#closed = !0, self[bunSocketInternal] = null;\n    const queue = self.#readQueue;\n    if (queue.isEmpty()) {\n      if (self.push(null))\n        return;\n    }\n    queue.push(null);\n  }\n  static #Drain(socket) {\n    const self = socket.data, callback = self.#writeCallback;\n    if (callback) {\n      const chunk = self.#writeChunk, written = socket.write(chunk);\n      if (self.bytesWritten += written, written < chunk.length)\n        self.#writeChunk = chunk.slice(written);\n      else\n        self.#writeCallback = null, self.#writeChunk = null, callback(null);\n    }\n  }\n  static [bunSocketServerHandlers] = {\n    data: Socket2.#Handlers.data,\n    close(socket) {\n      Socket2.#Handlers.close(socket), this.data[bunSocketServerConnections]--;\n    },\n    end(socket) {\n      Socket2.#Handlers.end(socket), this.data[bunSocketServerConnections]--;\n    },\n    open(socket) {\n      const self = this.data, options = self[bunSocketServerOptions], { pauseOnConnect, connectionListener, InternalSocketClass, requestCert, rejectUnauthorized } = options, _socket = new InternalSocketClass({});\n      if (_socket.isServer = !0, _socket._requestCert = requestCert, _socket._rejectUnauthorized = rejectUnauthorized, _socket.#attach(this.localPort, socket), self.maxConnections && self[bunSocketServerConnections] >= self.maxConnections) {\n        const data = {\n          localAddress: _socket.localAddress,\n          localPort: _socket.localPort,\n          localFamily: _socket.localFamily,\n          remoteAddress: _socket.remoteAddress,\n          remotePort: _socket.remotePort,\n          remoteFamily: _socket.remoteFamily || \"IPv4\"\n        };\n        socket.end(), self.emit(\"drop\", data);\n        return;\n      }\n      if (!pauseOnConnect)\n        _socket.resume();\n      if (self[bunSocketServerConnections]++, typeof connectionListener == \"function\")\n        if (InternalSocketClass.name === \"TLSSocket\")\n          self.once(\"secureConnection\", () => connectionListener(_socket));\n        else\n          connectionListener(_socket);\n      self.emit(\"connection\", _socket);\n    },\n    handshake(socket, success, verifyError) {\n      const { data: self } = socket;\n      if (self.emit(\"secure\", self), self._securePending = !1, self.secureConnecting = !1, self._secureEstablished = !!success, self._requestCert || self._rejectUnauthorized) {\n        if (verifyError) {\n          if (self.authorized = !1, self.authorizationError = verifyError.code || verifyError.message, self._rejectUnauthorized) {\n            self.destroy(verifyError);\n            return;\n          }\n        }\n      } else\n        self.authorized = !0;\n      self.emit(\"secureConnection\", verifyError);\n    },\n    error(socket, error) {\n      Socket2.#Handlers.error(socket, error), this.data.emit(\"error\", error);\n    },\n    timeout: Socket2.#Handlers.timeout,\n    connectError: Socket2.#Handlers.connectError,\n    drain: Socket2.#Handlers.drain,\n    binaryType: \"buffer\"\n  };\n  bytesRead = 0;\n  bytesWritten = 0;\n  #closed = !1;\n  connecting = !1;\n  localAddress = \"127.0.0.1\";\n  #readQueue = @createFIFO();\n  remotePort;\n  [bunSocketInternal] = null;\n  [bunTLSConnectOptions] = null;\n  timeout = 0;\n  #writeCallback;\n  #writeChunk;\n  #pendingRead;\n  isServer = !1;\n  _handle;\n  _parent;\n  _parentWrap;\n  #socket;\n  #upgraded;\n  constructor(options) {\n    const { socket, signal, write, read, allowHalfOpen = !1, ...opts } = options || {};\n    super({\n      ...opts,\n      allowHalfOpen,\n      readable: !0,\n      writable: !0\n    });\n    if (this._handle = this, this._parent = this, this._parentWrap = this, this.#pendingRead = void 0, this.#upgraded = !1, socket instanceof Socket2)\n      this.#socket = socket;\n    signal\?.once(\"abort\", () => this.destroy()), this.once(\"connect\", () => this.emit(\"ready\"));\n  }\n  address() {\n    return {\n      address: this.localAddress,\n      family: this.localFamily,\n      port: this.localPort\n    };\n  }\n  get bufferSize() {\n    return this.writableLength;\n  }\n  #attach(port, socket) {\n    if (this.remotePort = port, socket.data = this, socket.timeout(this.timeout), socket.ref(), this[bunSocketInternal] = socket, this.connecting = !1, !this.#upgraded)\n      this.emit(\"connect\", this);\n    Socket2.#Drain(socket);\n  }\n  connect(port, host, connectListener) {\n    var path, connection = this.#socket, _checkServerIdentity = void 0;\n    if (typeof port === \"string\") {\n      if (path = port, port = void 0, typeof host === \"function\")\n        connectListener = host, host = void 0;\n    } else if (typeof host == \"function\") {\n      if (typeof port === \"string\")\n        path = port, port = void 0;\n      connectListener = host, host = void 0;\n    }\n    if (typeof port == \"object\") {\n      var {\n        port,\n        host,\n        path,\n        socket,\n        localAddress,\n        localPort,\n        family,\n        hints,\n        lookup,\n        noDelay,\n        keepAlive,\n        keepAliveInitialDelay,\n        requestCert,\n        rejectUnauthorized,\n        pauseOnConnect,\n        servername,\n        checkServerIdentity,\n        session\n      } = port;\n      if (_checkServerIdentity = checkServerIdentity, this.servername = servername, socket)\n        connection = socket;\n    }\n    if (!pauseOnConnect)\n      this.resume();\n    this.connecting = !0, this.remotePort = port;\n    const bunTLS = this[bunTlsSymbol];\n    var tls = void 0;\n    if (typeof bunTLS === \"function\") {\n      if (tls = bunTLS.call(this, port, host, !0), this._requestCert = !0, this._rejectUnauthorized = rejectUnauthorized, tls) {\n        if (tls.rejectUnauthorized = rejectUnauthorized, tls.requestCert = !0, tls.session = session || tls.session, this.servername = tls.servername, tls.checkServerIdentity = _checkServerIdentity || tls.checkServerIdentity, this[bunTLSConnectOptions] = tls, !connection && tls.socket)\n          connection = tls.socket;\n      }\n      if (connection) {\n        if (typeof connection !== \"object\" || !(connection instanceof Socket2) || typeof connection[bunTlsSymbol] === \"function\")\n          @throwTypeError(\"socket must be an instance of net.Socket\");\n      }\n      if (this.authorized = !1, this.secureConnecting = !0, this._secureEstablished = !1, this._securePending = !0, connectListener)\n        this.on(\"secureConnect\", connectListener);\n    } else if (connectListener)\n      this.on(\"connect\", connectListener);\n    if (connection) {\n      const socket2 = connection[bunSocketInternal];\n      if (socket2) {\n        this.connecting = !0, this.#upgraded = !0;\n        const result = socket2.upgradeTLS({\n          data: this,\n          tls,\n          socket: Socket2.#Handlers\n        });\n        if (result) {\n          const [raw, tls2] = result;\n          connection[bunSocketInternal] = raw, raw.timeout(raw.timeout), raw.connecting = !1, this[bunSocketInternal] = tls2;\n        } else\n          throw this[bunSocketInternal] = null, new Error(\"Invalid socket\");\n      } else\n        connection.once(\"connect\", () => {\n          const socket3 = connection[bunSocketInternal];\n          if (!socket3)\n            return;\n          this.connecting = !0, this.#upgraded = !0;\n          const result = socket3.upgradeTLS({\n            data: this,\n            tls,\n            socket: Socket2.#Handlers\n          });\n          if (result) {\n            const [raw, tls2] = result;\n            connection[bunSocketInternal] = raw, raw.timeout(raw.timeout), raw.connecting = !1, this[bunSocketInternal] = tls2;\n          } else\n            throw this[bunSocketInternal] = null, new Error(\"Invalid socket\");\n        });\n    } else if (path)\n      bunConnect({\n        data: this,\n        unix: path,\n        socket: Socket2.#Handlers,\n        tls\n      }).catch((error) => {\n        this.emit(\"error\", error);\n      });\n    else\n      bunConnect({\n        data: this,\n        hostname: host || \"localhost\",\n        port,\n        socket: Socket2.#Handlers,\n        tls\n      }).catch((error) => {\n        this.emit(\"error\", error);\n      });\n    return this;\n  }\n  _destroy(err, callback) {\n    this[bunSocketInternal]\?.end(), callback(err);\n  }\n  _final(callback) {\n    this[bunSocketInternal]\?.end(), callback();\n  }\n  get localAddress() {\n    return \"127.0.0.1\";\n  }\n  get localFamily() {\n    return \"IPv4\";\n  }\n  get localPort() {\n    return this[bunSocketInternal]\?.localPort;\n  }\n  get pending() {\n    return this.connecting;\n  }\n  _read(size) {\n    const queue = this.#readQueue;\n    let chunk;\n    while (chunk = queue.peek()) {\n      if (!this.push(chunk))\n        return;\n      queue.shift();\n    }\n  }\n  get readyState() {\n    if (this.connecting)\n      return \"opening\";\n    if (this.readable)\n      return this.writable \? \"open\" : \"readOnly\";\n    else\n      return this.writable \? \"writeOnly\" : \"closed\";\n  }\n  ref() {\n    this[bunSocketInternal]\?.ref();\n  }\n  get remoteAddress() {\n    return this[bunSocketInternal]\?.remoteAddress;\n  }\n  get remoteFamily() {\n    return \"IPv4\";\n  }\n  resetAndDestroy() {\n    this[bunSocketInternal]\?.end();\n  }\n  setKeepAlive(enable = !1, initialDelay = 0) {\n    return this;\n  }\n  setNoDelay(noDelay = !0) {\n    return this;\n  }\n  setTimeout(timeout, callback) {\n    if (this[bunSocketInternal]\?.timeout(timeout), this.timeout = timeout, callback)\n      this.once(\"timeout\", callback);\n    return this;\n  }\n  unref() {\n    this[bunSocketInternal]\?.unref();\n  }\n  _write(chunk, encoding, callback) {\n    if (typeof chunk == \"string\" && encoding !== \"ascii\")\n      chunk = Buffer.from(chunk, encoding);\n    var written = this[bunSocketInternal]\?.write(chunk);\n    if (written == chunk.length)\n      callback();\n    else if (this.#writeCallback)\n      callback(new Error(\"overlapping _write()\"));\n    else {\n      if (written > 0)\n        if (typeof chunk == \"string\")\n          chunk = chunk.slice(written);\n        else\n          chunk = chunk.subarray(written);\n      this.#writeCallback = callback, this.#writeChunk = chunk;\n    }\n  }\n}), connect = createConnection;\n\nclass Server extends EventEmitter {\n  #server;\n  #listening = !1;\n  [bunSocketServerConnections] = 0;\n  [bunSocketServerOptions];\n  maxConnections = 0;\n  constructor(options, connectionListener) {\n    super();\n    if (typeof options === \"function\")\n      connectionListener = options, options = {};\n    else if (options == null || typeof options === \"object\")\n      options = { ...options };\n    else\n      throw new Error(\"bun-net-polyfill: invalid arguments\");\n    const { maxConnections } = options;\n    this.maxConnections = Number.isSafeInteger(maxConnections) && maxConnections > 0 \? maxConnections : 0, options.connectionListener = connectionListener, this[bunSocketServerOptions] = options;\n  }\n  ref() {\n    return this.#server\?.ref(), this;\n  }\n  unref() {\n    return this.#server\?.unref(), this;\n  }\n  close(callback) {\n    if (this.#server) {\n      if (this.#server.stop(!0), this.#server = null, this.#listening = !1, this[bunSocketServerConnections] = 0, this.emit(\"close\"), typeof callback === \"function\")\n        callback();\n      return this;\n    }\n    if (typeof callback === \"function\") {\n      const error = new Error(\"Server is not running\");\n      error.code = \"ERR_SERVER_NOT_RUNNING\", callback(error);\n    }\n    return this;\n  }\n  address() {\n    const server = this.#server;\n    if (server) {\n      const unix = server.unix;\n      if (unix)\n        return unix;\n      let address = server.hostname;\n      const type = isIP(address), port = server.port;\n      if (typeof port === \"number\")\n        return {\n          port,\n          address,\n          family: type \? `IPv${type}` : void 0\n        };\n      if (type)\n        return {\n          address,\n          family: type \? `IPv${type}` : void 0\n        };\n      return address;\n    }\n    return null;\n  }\n  getConnections(callback) {\n    if (typeof callback === \"function\")\n      callback(null, this.#server \? this[bunSocketServerConnections] : 0);\n    return this;\n  }\n  listen(port, hostname, onListen) {\n    let backlog, path, exclusive = !1;\n    if (typeof port === \"string\") {\n      if (Number.isSafeInteger(hostname)) {\n        if (hostname > 0)\n          backlog = hostname;\n      } else if (typeof hostname === \"function\")\n        onListen = hostname;\n      path = port, hostname = void 0, port = void 0;\n    } else {\n      if (typeof hostname === \"function\")\n        onListen = hostname, hostname = void 0;\n      if (typeof port === \"function\")\n        onListen = port, port = 0;\n      else if (typeof port === \"object\") {\n        const options = port;\n        options.signal\?.addEventListener(\"abort\", () => this.close()), hostname = options.host, exclusive = options.exclusive === !0;\n        const path2 = options.path;\n        if (port = options.port, !Number.isSafeInteger(port) || port < 0)\n          if (path2)\n            hostname = path2, port = void 0;\n          else {\n            let message = 'The argument \\'options\\' must have the property \"port\" or \"path\"';\n            try {\n              message = `${message}. Received ${JSON.stringify(options)}`;\n            } catch {\n            }\n            const error = @makeTypeError(message);\n            throw error.code = \"ERR_INVALID_ARG_VALUE\", error;\n          }\n        else if (!Number.isSafeInteger(port) || port < 0)\n          port = 0;\n        if (typeof port.callback === \"function\")\n          onListen = port\?.callback;\n      } else if (!Number.isSafeInteger(port) || port < 0)\n        port = 0;\n      hostname = hostname || \"::\";\n    }\n    try {\n      var tls = void 0, TLSSocketClass = void 0;\n      const bunTLS = this[bunTlsSymbol], options = this[bunSocketServerOptions];\n      if (typeof bunTLS === \"function\")\n        [tls, TLSSocketClass] = bunTLS.call(this, port, hostname, !1), options.servername = tls.serverName, options.InternalSocketClass = TLSSocketClass;\n      else\n        options.InternalSocketClass = SocketClass;\n      this.#server = Bun.listen(path \? {\n        exclusive,\n        unix: path,\n        tls,\n        socket: SocketClass[bunSocketServerHandlers]\n      } : {\n        exclusive,\n        port,\n        hostname,\n        tls,\n        socket: SocketClass[bunSocketServerHandlers]\n      }), this.#server.data = this, this.#listening = !0, setTimeout(emitListeningNextTick, 1, this, onListen);\n    } catch (err) {\n      this.#listening = !1, setTimeout(emitErrorNextTick, 1, this, err);\n    }\n    return this;\n  }\n}\n$ = {\n  createServer,\n  Server,\n  createConnection,\n  connect,\n  isIP,\n  isIPv4,\n  isIPv6,\n  Socket,\n  [Symbol.for(\"::bunternal::\")]: SocketClass\n};\nreturn $})\n"_s;
//

//
static constexpr ASCIILiteral NodeOSCode = "(function (){\"use strict\";// src/js/out/tmp/node/os.ts\nvar lazyCpus = function({ cpus }) {\n  return () => {\n    const array = new Array(navigator.hardwareConcurrency);\n    function populate() {\n      const results = cpus(), length = results.length;\n      array.length = length;\n      for (let i = 0;i < length; i++)\n        array[i] = results[i];\n    }\n    for (let i = 0;i < array.length; i++) {\n      const instance = {\n        get model() {\n          if (array[i] === instance)\n            populate();\n          return array[i].model;\n        },\n        set model(value) {\n          if (array[i] === instance)\n            populate();\n          array[i].model = value;\n        },\n        get speed() {\n          if (array[i] === instance)\n            populate();\n          return array[i].speed;\n        },\n        set speed(value) {\n          if (array[i] === instance)\n            populate();\n          array[i].speed = value;\n        },\n        get times() {\n          if (array[i] === instance)\n            populate();\n          return array[i].times;\n        },\n        set times(value) {\n          if (array[i] === instance)\n            populate();\n          array[i].times = value;\n        },\n        toJSON() {\n          if (array[i] === instance)\n            populate();\n          return array[i];\n        }\n      };\n      array[i] = instance;\n    }\n    return array;\n  };\n}, bound = function(obj) {\n  return {\n    arch: obj.arch.bind(obj),\n    cpus: lazyCpus(obj),\n    endianness: obj.endianness.bind(obj),\n    freemem: obj.freemem.bind(obj),\n    getPriority: obj.getPriority.bind(obj),\n    homedir: obj.homedir.bind(obj),\n    hostname: obj.hostname.bind(obj),\n    loadavg: obj.loadavg.bind(obj),\n    networkInterfaces: obj.networkInterfaces.bind(obj),\n    platform: obj.platform.bind(obj),\n    release: obj.release.bind(obj),\n    setPriority: obj.setPriority.bind(obj),\n    get tmpdir() {\n      return tmpdir;\n    },\n    totalmem: obj.totalmem.bind(obj),\n    type: obj.type.bind(obj),\n    uptime: obj.uptime.bind(obj),\n    userInfo: obj.userInfo.bind(obj),\n    version: obj.version.bind(obj),\n    machine: obj.machine.bind(obj),\n    devNull: obj.devNull,\n    EOL: obj.EOL,\n    constants: @processBindingConstants.os\n  };\n}, tmpdir = function() {\n  var env = Bun.env;\n  return tmpdir = function() {\n    var path = env.TMPDIR || env.TMP || env.TEMP || \"/tmp\";\n    const length = path.length;\n    if (length > 1 && path[length - 1] === \"/\")\n      path = path.slice(0, -1);\n    return path;\n  }, tmpdir();\n};\nreturn bound(Bun._Os())})\n"_s;
//

//
static constexpr ASCIILiteral NodePathPosixCode = "(function (){\"use strict\";// src/js/out/tmp/node/path.posix.ts\nreturn (@getInternalField(@internalModuleRegistry, 26) || @createInternalModuleById(26)).posix})\n"_s;
//

//
static constexpr ASCIILiteral NodePathCode = "(function (){\"use strict\";// src/js/out/tmp/node/path.ts\nvar bound = function(obj) {\n  const toNamespacedPath = obj.toNamespacedPath.bind(obj);\n  return {\n    resolve: obj.resolve.bind(obj),\n    normalize: obj.normalize.bind(obj),\n    isAbsolute: obj.isAbsolute.bind(obj),\n    join: obj.join.bind(obj),\n    relative: obj.relative.bind(obj),\n    toNamespacedPath,\n    dirname: obj.dirname.bind(obj),\n    basename: obj.basename.bind(obj),\n    extname: obj.extname.bind(obj),\n    format: obj.format.bind(obj),\n    parse: obj.parse.bind(obj),\n    sep: obj.sep,\n    delimiter: obj.delimiter,\n    win32: void 0,\n    posix: void 0,\n    _makeLong: toNamespacedPath\n  };\n}, posix = bound(Bun._Path(!1)), win32 = bound(Bun._Path(!0));\nposix.win32 = win32.win32 = win32;\nposix.posix = win32.posix = posix;\nreturn posix})\n"_s;
//

//
static constexpr ASCIILiteral NodePathWin32Code = "(function (){\"use strict\";// src/js/out/tmp/node/path.win32.ts\nreturn (@getInternalField(@internalModuleRegistry, 26) || @createInternalModuleById(26)).win32})\n"_s;
//

//
static constexpr ASCIILiteral NodePerfHooksCode = "(function (){\"use strict\";// src/js/out/tmp/node/perf_hooks.ts\nvar $, { throwNotImplemented } = @getInternalField(@internalModuleRegistry, 3) || @createInternalModuleById(3), constants = {\n  NODE_PERFORMANCE_GC_MAJOR: 4,\n  NODE_PERFORMANCE_GC_MINOR: 1,\n  NODE_PERFORMANCE_GC_INCREMENTAL: 8,\n  NODE_PERFORMANCE_GC_WEAKCB: 16,\n  NODE_PERFORMANCE_GC_FLAGS_NO: 0,\n  NODE_PERFORMANCE_GC_FLAGS_CONSTRUCT_RETAINED: 2,\n  NODE_PERFORMANCE_GC_FLAGS_FORCED: 4,\n  NODE_PERFORMANCE_GC_FLAGS_SYNCHRONOUS_PHANTOM_PROCESSING: 8,\n  NODE_PERFORMANCE_GC_FLAGS_ALL_AVAILABLE_GARBAGE: 16,\n  NODE_PERFORMANCE_GC_FLAGS_ALL_EXTERNAL_MEMORY: 32,\n  NODE_PERFORMANCE_GC_FLAGS_SCHEDULE_IDLE: 64\n}, performance = globalThis.performance;\n\nclass PerformanceObserver {\n  constructor() {\n    throwNotImplemented(\"PerformanceObserver\");\n  }\n}\n\nclass PerformanceEntry {\n  constructor() {\n    throwNotImplemented(\"PerformanceEntry\");\n  }\n}\n$ = {\n  performance,\n  constants,\n  PerformanceEntry,\n  PerformanceObserver\n};\nreturn $})\n"_s;
//

//
static constexpr ASCIILiteral NodePunycodeCode = "(function (){\"use strict\";// src/js/out/tmp/node/punycode.ts\nvar error = function(type) {\n  @throwRangeError(errors[type]);\n}, map = function(array, callback) {\n  const result = [];\n  let length = array.length;\n  while (length--)\n    result[length] = callback(array[length]);\n  return result;\n}, mapDomain = function(domain, callback) {\n  const parts = domain.split(\"@\");\n  let result = \"\";\n  if (parts.length > 1)\n    result = parts[0] + \"@\", domain = parts[1];\n  domain = domain.replace(regexSeparators, \".\");\n  const labels = domain.split(\".\"), encoded = map(labels, callback).join(\".\");\n  return result + encoded;\n}, ucs2decode = function(string) {\n  const output = [];\n  let counter = 0;\n  const length = string.length;\n  while (counter < length) {\n    const value = string.charCodeAt(counter++);\n    if (value >= 55296 && value <= 56319 && counter < length) {\n      const extra = string.charCodeAt(counter++);\n      if ((extra & 64512) == 56320)\n        output.push(((value & 1023) << 10) + (extra & 1023) + 65536);\n      else\n        output.push(value), counter--;\n    } else\n      output.push(value);\n  }\n  return output;\n}, $, maxInt = 2147483647, base = 36, tMin = 1, tMax = 26, skew = 38, damp = 700, initialBias = 72, initialN = 128, delimiter = \"-\", regexPunycode = /^xn--/, regexNonASCII = /[^\\0-\\x7F]/, regexSeparators = /[\\x2E\\u3002\\uFF0E\\uFF61]/g, errors = {\n  overflow: \"Overflow: input needs wider integers to process\",\n  \"not-basic\": \"Illegal input >= 0x80 (not a basic code point)\",\n  \"invalid-input\": \"Invalid input\"\n}, baseMinusTMin = base - tMin, floor = Math.floor, stringFromCharCode = String.fromCharCode, ucs2encode = (codePoints) => String.fromCodePoint(...codePoints), basicToDigit = function(codePoint) {\n  if (codePoint >= 48 && codePoint < 58)\n    return 26 + (codePoint - 48);\n  if (codePoint >= 65 && codePoint < 91)\n    return codePoint - 65;\n  if (codePoint >= 97 && codePoint < 123)\n    return codePoint - 97;\n  return base;\n}, digitToBasic = function(digit, flag) {\n  return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);\n}, adapt = function(delta, numPoints, firstTime) {\n  let k = 0;\n  delta = firstTime \? floor(delta / damp) : delta >> 1, delta += floor(delta / numPoints);\n  for (;delta > baseMinusTMin * tMax >> 1; k += base)\n    delta = floor(delta / baseMinusTMin);\n  return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));\n}, decode = function(input) {\n  const output = [], inputLength = input.length;\n  let i = 0, n = initialN, bias = initialBias, basic = input.lastIndexOf(delimiter);\n  if (basic < 0)\n    basic = 0;\n  for (let j = 0;j < basic; ++j) {\n    if (input.charCodeAt(j) >= 128)\n      error(\"not-basic\");\n    output.push(input.charCodeAt(j));\n  }\n  for (let index = basic > 0 \? basic + 1 : 0;index < inputLength; ) {\n    const oldi = i;\n    for (let w = 1, k = base;; k += base) {\n      if (index >= inputLength)\n        error(\"invalid-input\");\n      const digit = basicToDigit(input.charCodeAt(index++));\n      if (digit >= base)\n        error(\"invalid-input\");\n      if (digit > floor((maxInt - i) / w))\n        error(\"overflow\");\n      i += digit * w;\n      const t = k <= bias \? tMin : k >= bias + tMax \? tMax : k - bias;\n      if (digit < t)\n        break;\n      const baseMinusT = base - t;\n      if (w > floor(maxInt / baseMinusT))\n        error(\"overflow\");\n      w *= baseMinusT;\n    }\n    const out = output.length + 1;\n    if (bias = adapt(i - oldi, out, oldi == 0), floor(i / out) > maxInt - n)\n      error(\"overflow\");\n    n += floor(i / out), i %= out, output.splice(i++, 0, n);\n  }\n  return String.fromCodePoint(...output);\n}, encode = function(input) {\n  const output = [];\n  input = ucs2decode(input);\n  const inputLength = input.length;\n  let n = initialN, delta = 0, bias = initialBias;\n  for (let currentValue of input)\n    if (currentValue < 128)\n      output.push(stringFromCharCode(currentValue));\n  const basicLength = output.length;\n  let handledCPCount = basicLength;\n  if (basicLength)\n    output.push(delimiter);\n  while (handledCPCount < inputLength) {\n    let m = maxInt;\n    for (let currentValue of input)\n      if (currentValue >= n && currentValue < m)\n        m = currentValue;\n    const handledCPCountPlusOne = handledCPCount + 1;\n    if (m - n > floor((maxInt - delta) / handledCPCountPlusOne))\n      error(\"overflow\");\n    delta += (m - n) * handledCPCountPlusOne, n = m;\n    for (let currentValue of input) {\n      if (currentValue < n && ++delta > maxInt)\n        error(\"overflow\");\n      if (currentValue === n) {\n        let q = delta;\n        for (let k = base;; k += base) {\n          const t = k <= bias \? tMin : k >= bias + tMax \? tMax : k - bias;\n          if (q < t)\n            break;\n          const qMinusT = q - t, baseMinusT = base - t;\n          output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))), q = floor(qMinusT / baseMinusT);\n        }\n        output.push(stringFromCharCode(digitToBasic(q, 0))), bias = adapt(delta, handledCPCountPlusOne, handledCPCount === basicLength), delta = 0, ++handledCPCount;\n      }\n    }\n    ++delta, ++n;\n  }\n  return output.join(\"\");\n}, toUnicode = function(input) {\n  return mapDomain(input, function(string) {\n    return regexPunycode.test(string) \? decode(string.slice(4).toLowerCase()) : string;\n  });\n}, toASCII = function(input) {\n  return mapDomain(input, function(string) {\n    return regexNonASCII.test(string) \? \"xn--\" + encode(string) : string;\n  });\n};\n$ = {\n  version: \"2.1.0\",\n  ucs2: {\n    decode: ucs2decode,\n    encode: ucs2encode\n  },\n  decode,\n  encode,\n  toASCII,\n  toUnicode\n};\nreturn $})\n"_s;
//

//
static constexpr ASCIILiteral NodeQuerystringCode = "(function (){\"use strict\";// src/js/out/tmp/node/querystring.ts\nvar __commonJS = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports), Buffer = @requireNativeModule(\"node:buffer\").Buffer, require_object_keys = __commonJS((exports, module) => {\n  var objectKeys = Object.keys || function() {\n    var hasOwnProperty = Object.prototype.hasOwnProperty, hasDontEnumBug = !{ toString: null }.propertyIsEnumerable(\"toString\"), dontEnums = [\n      \"toString\",\n      \"toLocaleString\",\n      \"valueOf\",\n      \"hasOwnProperty\",\n      \"isPrototypeOf\",\n      \"propertyIsEnumerable\",\n      \"constructor\"\n    ], dontEnumsLength = dontEnums.length;\n    return function(obj) {\n      if (typeof obj !== \"function\" && (typeof obj !== \"object\" || obj === null))\n        @throwTypeError(\"Object.keys called on non-object\");\n      var result = [], prop, i;\n      for (prop in obj)\n        if (hasOwnProperty.call(obj, prop))\n          result.push(prop);\n      if (hasDontEnumBug) {\n        for (i = 0;i < dontEnumsLength; i++)\n          if (hasOwnProperty.call(obj, dontEnums[i]))\n            result.push(dontEnums[i]);\n      }\n      return result;\n    };\n  }();\n  module.exports = objectKeys;\n}), require_src = __commonJS((exports, module) => {\n  var ParsedQueryString = function() {\n  }, unescapeBuffer = function(s, decodeSpaces) {\n    var out = Buffer.allocUnsafe(s.length), state = 0, n, m, hexchar, c;\n    for (var inIndex = 0, outIndex = 0;; inIndex++) {\n      if (inIndex < s.length)\n        c = s.charCodeAt(inIndex);\n      else {\n        if (state > 0) {\n          if (out[outIndex++] = 37, state === 2)\n            out[outIndex++] = hexchar;\n        }\n        break;\n      }\n      switch (state) {\n        case 0:\n          switch (c) {\n            case 37:\n              n = 0, m = 0, state = 1;\n              break;\n            case 43:\n              if (decodeSpaces)\n                c = 32;\n            default:\n              out[outIndex++] = c;\n              break;\n          }\n          break;\n        case 1:\n          if (hexchar = c, n = unhexTable[c], !(n >= 0)) {\n            out[outIndex++] = 37, out[outIndex++] = c, state = 0;\n            break;\n          }\n          state = 2;\n          break;\n        case 2:\n          if (state = 0, m = unhexTable[c], !(m >= 0)) {\n            out[outIndex++] = 37, out[outIndex++] = hexchar, out[outIndex++] = c;\n            break;\n          }\n          out[outIndex++] = 16 * n + m;\n          break;\n      }\n    }\n    return out.slice(0, outIndex);\n  }, qsUnescape = function(s, decodeSpaces) {\n    try {\n      return decodeURIComponent(s);\n    } catch (e) {\n      return QueryString.unescapeBuffer(s, decodeSpaces).toString();\n    }\n  }, qsEscape = function(str) {\n    if (typeof str !== \"string\")\n      if (typeof str === \"object\")\n        str = String(str);\n      else\n        str += \"\";\n    var out = \"\", lastPos = 0;\n    for (var i2 = 0;i2 < str.length; ++i2) {\n      var c = str.charCodeAt(i2);\n      if (c < 128) {\n        if (noEscape[c] === 1)\n          continue;\n        if (lastPos < i2)\n          out += str.slice(lastPos, i2);\n        lastPos = i2 + 1, out += hexTable[c];\n        continue;\n      }\n      if (lastPos < i2)\n        out += str.slice(lastPos, i2);\n      if (c < 2048) {\n        lastPos = i2 + 1, out += hexTable[192 | c >> 6] + hexTable[128 | c & 63];\n        continue;\n      }\n      if (c < 55296 || c >= 57344) {\n        lastPos = i2 + 1, out += hexTable[224 | c >> 12] + hexTable[128 | c >> 6 & 63] + hexTable[128 | c & 63];\n        continue;\n      }\n      ++i2;\n      var c2;\n      if (i2 < str.length)\n        c2 = str.charCodeAt(i2) & 1023;\n      else\n        throw new URIError(\"URI malformed\");\n      lastPos = i2 + 1, c = 65536 + ((c & 1023) << 10 | c2), out += hexTable[240 | c >> 18] + hexTable[128 | c >> 12 & 63] + hexTable[128 | c >> 6 & 63] + hexTable[128 | c & 63];\n    }\n    if (lastPos === 0)\n      return str;\n    if (lastPos < str.length)\n      return out + str.slice(lastPos);\n    return out;\n  }, stringifyPrimitive = function(v) {\n    if (typeof v === \"string\")\n      return v;\n    if (typeof v === \"number\" && isFinite(v))\n      return \"\" + v;\n    if (typeof v === \"boolean\")\n      return v \? \"true\" : \"false\";\n    return \"\";\n  }, stringify = function(obj, sep, eq, options) {\n    sep = sep || \"&\", eq = eq || \"=\";\n    var encode = QueryString.escape;\n    if (options && typeof options.encodeURIComponent === \"function\")\n      encode = options.encodeURIComponent;\n    if (obj !== null && typeof obj === \"object\") {\n      var keys = objectKeys(obj), len = keys.length, flast = len - 1, fields = \"\";\n      for (var i2 = 0;i2 < len; ++i2) {\n        var k = keys[i2], v = obj[k], ks = encode(stringifyPrimitive(k)) + eq;\n        if (isArray(v)) {\n          var vlen = v.length, vlast = vlen - 1;\n          for (var j = 0;j < vlen; ++j)\n            if (fields += ks + encode(stringifyPrimitive(v[j])), j < vlast)\n              fields += sep;\n          if (vlen && i2 < flast)\n            fields += sep;\n        } else if (fields += ks + encode(stringifyPrimitive(v)), i2 < flast)\n          fields += sep;\n      }\n      return fields;\n    }\n    return \"\";\n  }, charCodes = function(str) {\n    if (str.length === 0)\n      return [];\n    if (str.length === 1)\n      return [str.charCodeAt(0)];\n    const ret = [];\n    for (var i2 = 0;i2 < str.length; ++i2)\n      ret[ret.length] = str.charCodeAt(i2);\n    return ret;\n  }, parse = function(qs, sep, eq, options) {\n    const obj = new ParsedQueryString;\n    if (typeof qs !== \"string\" || qs.length === 0)\n      return obj;\n    var sepCodes = !sep \? defSepCodes : charCodes(sep + \"\"), eqCodes = !eq \? defEqCodes : charCodes(eq + \"\");\n    const sepLen = sepCodes.length, eqLen = eqCodes.length;\n    var pairs = 1000;\n    if (options && typeof options.maxKeys === \"number\")\n      pairs = options.maxKeys > 0 \? options.maxKeys : -1;\n    var decode = QueryString.unescape;\n    if (options && typeof options.decodeURIComponent === \"function\")\n      decode = options.decodeURIComponent;\n    const customDecode = decode !== qsUnescape, keys = [];\n    var posIdx = 0, lastPos = 0, sepIdx = 0, eqIdx = 0, key = \"\", value = \"\", keyEncoded = customDecode, valEncoded = customDecode, encodeCheck = 0;\n    for (var i2 = 0;i2 < qs.length; ++i2) {\n      const code = qs.charCodeAt(i2);\n      if (code === sepCodes[sepIdx]) {\n        if (++sepIdx === sepLen) {\n          const end = i2 - sepIdx + 1;\n          if (eqIdx < eqLen) {\n            if (lastPos < end)\n              key += qs.slice(lastPos, end);\n          } else if (lastPos < end)\n            value += qs.slice(lastPos, end);\n          if (keyEncoded)\n            key = decodeStr(key, decode);\n          if (valEncoded)\n            value = decodeStr(value, decode);\n          if (key || value || lastPos - posIdx > sepLen || i2 === 0)\n            if (indexOf(keys, key) === -1)\n              obj[key] = value, keys[keys.length] = key;\n            else {\n              const curValue = obj[key] || \"\";\n              if (curValue.pop)\n                curValue[curValue.length] = value;\n              else if (curValue)\n                obj[key] = [curValue, value];\n            }\n          else if (i2 === 1)\n            delete obj[key];\n          if (--pairs === 0)\n            break;\n          keyEncoded = valEncoded = customDecode, encodeCheck = 0, key = value = \"\", posIdx = lastPos, lastPos = i2 + 1, sepIdx = eqIdx = 0;\n        }\n        continue;\n      } else if (sepIdx = 0, !valEncoded)\n        if (code === 37)\n          encodeCheck = 1;\n        else if (encodeCheck > 0 && (code >= 48 && code <= 57 || code >= 65 && code <= 70 || code >= 97 && code <= 102)) {\n          if (++encodeCheck === 3)\n            valEncoded = !0;\n        } else\n          encodeCheck = 0;\n      if (eqIdx < eqLen) {\n        if (code === eqCodes[eqIdx]) {\n          if (++eqIdx === eqLen) {\n            const end = i2 - eqIdx + 1;\n            if (lastPos < end)\n              key += qs.slice(lastPos, end);\n            encodeCheck = 0, lastPos = i2 + 1;\n          }\n          continue;\n        } else if (eqIdx = 0, !keyEncoded)\n          if (code === 37)\n            encodeCheck = 1;\n          else if (encodeCheck > 0 && (code >= 48 && code <= 57 || code >= 65 && code <= 70 || code >= 97 && code <= 102)) {\n            if (++encodeCheck === 3)\n              keyEncoded = !0;\n          } else\n            encodeCheck = 0;\n      }\n      if (code === 43) {\n        if (eqIdx < eqLen) {\n          if (lastPos < i2)\n            key += qs.slice(lastPos, i2);\n          key += \"%20\", keyEncoded = !0;\n        } else {\n          if (lastPos < i2)\n            value += qs.slice(lastPos, i2);\n          value += \"%20\", valEncoded = !0;\n        }\n        lastPos = i2 + 1;\n      }\n    }\n    if (pairs !== 0 && (lastPos < qs.length || eqIdx > 0)) {\n      if (lastPos < qs.length) {\n        if (eqIdx < eqLen)\n          key += qs.slice(lastPos);\n        else if (sepIdx < sepLen)\n          value += qs.slice(lastPos);\n      }\n      if (keyEncoded)\n        key = decodeStr(key, decode);\n      if (valEncoded)\n        value = decodeStr(value, decode);\n      if (indexOf(keys, key) === -1)\n        obj[key] = value, keys[keys.length] = key;\n      else {\n        const curValue = obj[key];\n        if (curValue.pop)\n          curValue[curValue.length] = value;\n        else\n          obj[key] = [curValue, value];\n      }\n    }\n    return obj;\n  }, decodeStr = function(s, decoder) {\n    try {\n      return decoder(s);\n    } catch (e) {\n      return QueryString.unescape(s, !0);\n    }\n  }, QueryString = module.exports = {\n    unescapeBuffer,\n    unescape: qsUnescape,\n    escape: qsEscape,\n    stringify,\n    encode: stringify,\n    parse,\n    decode: parse\n  }, objectKeys = require_object_keys(), isArray = (arg) => Object.prototype.toString.call(arg) === \"[object Array]\", indexOf = (arr, searchElement, fromIndex) => {\n    var k;\n    if (arr == null)\n      @throwTypeError('\"arr\" is null or not defined');\n    var o = Object(arr), len = o.length >>> 0;\n    if (len === 0)\n      return -1;\n    var n = fromIndex | 0;\n    if (n >= len)\n      return -1;\n    k = Math.max(n >= 0 \? n : len - Math.abs(n), 0);\n    while (k < len) {\n      if ((k in o) && o[k] === searchElement)\n        return k;\n      k++;\n    }\n    return -1;\n  };\n  ParsedQueryString.prototype = Object.create \? Object.create(null) : {};\n  var unhexTable = [\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    0,\n    1,\n    2,\n    3,\n    4,\n    5,\n    6,\n    7,\n    8,\n    9,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    10,\n    11,\n    12,\n    13,\n    14,\n    15,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    10,\n    11,\n    12,\n    13,\n    14,\n    15,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1\n  ], hexTable = [];\n  for (i = 0;i < 256; ++i)\n    hexTable[i] = \"%\" + ((i < 16 \? \"0\" : \"\") + i.toString(16)).toUpperCase();\n  var i, noEscape = [\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    1,\n    0,\n    0,\n    0,\n    0,\n    0,\n    1,\n    1,\n    1,\n    1,\n    0,\n    0,\n    1,\n    1,\n    0,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    0,\n    0,\n    0,\n    0,\n    1,\n    0,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    0,\n    0,\n    0,\n    1,\n    0\n  ], defSepCodes = [38], defEqCodes = [61];\n});\nreturn require_src()})\n"_s;
//

//
static constexpr ASCIILiteral NodeReadlineCode = "(function (){\"use strict\";// src/js/out/tmp/node/readline.ts\nvar stripVTControlCharacters = function(str) {\n  return validateString(str, \"str\"), RegExpPrototypeSymbolReplace.call(ansi, str, \"\");\n}, promisify = function(original) {\n  if (validateFunction(original, \"original\"), original[kCustomPromisifiedSymbol]) {\n    var fn = original[kCustomPromisifiedSymbol];\n    return validateFunction(fn, \"util.promisify.custom\"), ObjectDefineProperty(fn, kCustomPromisifiedSymbol, {\n      __proto__: null,\n      value: fn,\n      enumerable: !1,\n      writable: !1,\n      configurable: !0\n    });\n  }\n  var argumentNames = original[kCustomPromisifyArgsSymbol];\n  function fn(...args) {\n    return new Promise((resolve, reject) => {\n      ArrayPrototypePush.call(args, (err, ...values) => {\n        if (err)\n          return reject(err);\n        if (argumentNames !== void 0 && values.length > 1) {\n          var obj = {};\n          for (var i2 = 0;i2 < argumentNames.length; i2++)\n            obj[argumentNames[i2]] = values[i2];\n          resolve(obj);\n        } else\n          resolve(values[0]);\n      }), ReflectApply(original, this, args);\n    });\n  }\n  ObjectSetPrototypeOf(fn, ObjectGetPrototypeOf(original)), ObjectDefineProperty(fn, kCustomPromisifiedSymbol, {\n    __proto__: null,\n    value: fn,\n    enumerable: !1,\n    writable: !1,\n    configurable: !0\n  });\n  var descriptors = ObjectGetOwnPropertyDescriptors(original), propertiesValues = ObjectValues(descriptors);\n  for (var i = 0;i < propertiesValues.length; i++)\n    ObjectSetPrototypeOf(propertiesValues[i], null);\n  return ObjectDefineProperties(fn, descriptors);\n}, getNodeErrorByName = function(typeName) {\n  var base = errorBases[typeName];\n  if (base)\n    return base;\n  if (!ObjectKeys(VALID_NODE_ERROR_BASES).includes(typeName))\n    throw new Error(\"Invalid NodeError type\");\n  var Base = VALID_NODE_ERROR_BASES[typeName];\n\n  class NodeError extends Base {\n    [kIsNodeError] = !0;\n    code;\n    constructor(msg, opts) {\n      super(msg, opts);\n      this.code = opts\?.code || \"ERR_GENERIC\";\n    }\n    toString() {\n      return `${this.name} [${this.code}]: ${this.message}`;\n    }\n  }\n  return errorBases[typeName] = NodeError, NodeError;\n}, validateFunction = function(value, name) {\n  if (typeof value !== \"function\")\n    throw new ERR_INVALID_ARG_TYPE(name, \"Function\", value);\n}, validateAbortSignal = function(signal, name) {\n  if (signal !== void 0 && (signal === null || typeof signal !== \"object\" || !(\"aborted\" in signal)))\n    throw new ERR_INVALID_ARG_TYPE(name, \"AbortSignal\", signal);\n}, validateArray = function(value, name, minLength = 0) {\n  if (!ArrayIsArray(value))\n    throw new ERR_INVALID_ARG_TYPE(name, \"Array\", value);\n  if (value.length < minLength) {\n    var reason = `must be longer than ${minLength}`;\n    throw new ERR_INVALID_ARG_VALUE(name, value, reason);\n  }\n}, validateString = function(value, name) {\n  if (typeof value !== \"string\")\n    throw new ERR_INVALID_ARG_TYPE(name, \"string\", value);\n}, validateBoolean = function(value, name) {\n  if (typeof value !== \"boolean\")\n    throw new ERR_INVALID_ARG_TYPE(name, \"boolean\", value);\n};\nvar validateInteger = function(value, name, min = NumberMIN_SAFE_INTEGER, max = NumberMAX_SAFE_INTEGER) {\n  if (typeof value !== \"number\")\n    throw new ERR_INVALID_ARG_TYPE(name, \"number\", value);\n  if (!NumberIsInteger(value))\n    throw new ERR_OUT_OF_RANGE(name, \"an integer\", value);\n  if (value < min || value > max)\n    throw new ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value);\n}, validateUint32 = function(value, name, positive = !1) {\n  if (typeof value !== \"number\")\n    throw new ERR_INVALID_ARG_TYPE(name, \"number\", value);\n  if (!NumberIsInteger(value))\n    throw new ERR_OUT_OF_RANGE(name, \"an integer\", value);\n  var min = positive \? 1 : 0, max = 4294967295;\n  if (value < min || value > max)\n    throw new ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value);\n}, CSI = function(strings, ...args) {\n  var ret = `${kEscape}[`;\n  for (var n = 0;n < strings.length; n++)\n    if (ret += strings[n], n < args.length)\n      ret += args[n];\n  return ret;\n}, charLengthLeft = function(str, i) {\n  if (i <= 0)\n    return 0;\n  if (i > 1 && StringPrototypeCodePointAt.call(str, i - 2) >= kUTF16SurrogateThreshold || StringPrototypeCodePointAt.call(str, i - 1) >= kUTF16SurrogateThreshold)\n    return 2;\n  return 1;\n}, charLengthAt = function(str, i) {\n  if (str.length <= i)\n    return 1;\n  return StringPrototypeCodePointAt.call(str, i) >= kUTF16SurrogateThreshold \? 2 : 1;\n};\nfunction* emitKeys(stream) {\n  while (!0) {\n    var ch = yield, s = ch, escaped = !1, keySeq = null, keyName, keyCtrl2 = !1, keyMeta = !1, keyShift = !1;\n    if (ch === kEscape) {\n      if (escaped = !0, s += ch = yield, ch === kEscape)\n        s += ch = yield;\n    }\n    if (escaped && (ch === \"O\" || ch === \"[\")) {\n      var code = ch, modifier = 0;\n      if (ch === \"O\") {\n        if (s += ch = yield, ch >= \"0\" && ch <= \"9\")\n          modifier = (ch >> 0) - 1, s += ch = yield;\n        code += ch;\n      } else if (ch === \"[\") {\n        if (s += ch = yield, ch === \"[\")\n          code += ch, s += ch = yield;\n        var cmdStart = s.length - 1;\n        if (ch >= \"0\" && ch <= \"9\") {\n          if (s += ch = yield, ch >= \"0\" && ch <= \"9\")\n            s += ch = yield;\n        }\n        if (ch === \";\") {\n          if (s += ch = yield, ch >= \"0\" && ch <= \"9\")\n            s += yield;\n        }\n        var cmd = StringPrototypeSlice.call(s, cmdStart), match;\n        if (match = RegExpPrototypeExec.call(/^(\\d\\d\?)(;(\\d))\?([~^$])$/, cmd))\n          code += match[1] + match[4], modifier = (match[3] || 1) - 1;\n        else if (match = RegExpPrototypeExec.call(/^((\\d;)\?(\\d))\?([A-Za-z])$/, cmd))\n          code += match[4], modifier = (match[3] || 1) - 1;\n        else\n          code += cmd;\n      }\n      switch (keyCtrl2 = !!(modifier & 4), keyMeta = !!(modifier & 10), keyShift = !!(modifier & 1), code) {\n        case \"[P\":\n          keyName = \"f1\";\n          break;\n        case \"[Q\":\n          keyName = \"f2\";\n          break;\n        case \"[R\":\n          keyName = \"f3\";\n          break;\n        case \"[S\":\n          keyName = \"f4\";\n          break;\n        case \"OP\":\n          keyName = \"f1\";\n          break;\n        case \"OQ\":\n          keyName = \"f2\";\n          break;\n        case \"OR\":\n          keyName = \"f3\";\n          break;\n        case \"OS\":\n          keyName = \"f4\";\n          break;\n        case \"[11~\":\n          keyName = \"f1\";\n          break;\n        case \"[12~\":\n          keyName = \"f2\";\n          break;\n        case \"[13~\":\n          keyName = \"f3\";\n          break;\n        case \"[14~\":\n          keyName = \"f4\";\n          break;\n        case \"[[A\":\n          keyName = \"f1\";\n          break;\n        case \"[[B\":\n          keyName = \"f2\";\n          break;\n        case \"[[C\":\n          keyName = \"f3\";\n          break;\n        case \"[[D\":\n          keyName = \"f4\";\n          break;\n        case \"[[E\":\n          keyName = \"f5\";\n          break;\n        case \"[15~\":\n          keyName = \"f5\";\n          break;\n        case \"[17~\":\n          keyName = \"f6\";\n          break;\n        case \"[18~\":\n          keyName = \"f7\";\n          break;\n        case \"[19~\":\n          keyName = \"f8\";\n          break;\n        case \"[20~\":\n          keyName = \"f9\";\n          break;\n        case \"[21~\":\n          keyName = \"f10\";\n          break;\n        case \"[23~\":\n          keyName = \"f11\";\n          break;\n        case \"[24~\":\n          keyName = \"f12\";\n          break;\n        case \"[A\":\n          keyName = \"up\";\n          break;\n        case \"[B\":\n          keyName = \"down\";\n          break;\n        case \"[C\":\n          keyName = \"right\";\n          break;\n        case \"[D\":\n          keyName = \"left\";\n          break;\n        case \"[E\":\n          keyName = \"clear\";\n          break;\n        case \"[F\":\n          keyName = \"end\";\n          break;\n        case \"[H\":\n          keyName = \"home\";\n          break;\n        case \"OA\":\n          keyName = \"up\";\n          break;\n        case \"OB\":\n          keyName = \"down\";\n          break;\n        case \"OC\":\n          keyName = \"right\";\n          break;\n        case \"OD\":\n          keyName = \"left\";\n          break;\n        case \"OE\":\n          keyName = \"clear\";\n          break;\n        case \"OF\":\n          keyName = \"end\";\n          break;\n        case \"OH\":\n          keyName = \"home\";\n          break;\n        case \"[1~\":\n          keyName = \"home\";\n          break;\n        case \"[2~\":\n          keyName = \"insert\";\n          break;\n        case \"[3~\":\n          keyName = \"delete\";\n          break;\n        case \"[4~\":\n          keyName = \"end\";\n          break;\n        case \"[5~\":\n          keyName = \"pageup\";\n          break;\n        case \"[6~\":\n          keyName = \"pagedown\";\n          break;\n        case \"[[5~\":\n          keyName = \"pageup\";\n          break;\n        case \"[[6~\":\n          keyName = \"pagedown\";\n          break;\n        case \"[7~\":\n          keyName = \"home\";\n          break;\n        case \"[8~\":\n          keyName = \"end\";\n          break;\n        case \"[a\":\n          keyName = \"up\", keyShift = !0;\n          break;\n        case \"[b\":\n          keyName = \"down\", keyShift = !0;\n          break;\n        case \"[c\":\n          keyName = \"right\", keyShift = !0;\n          break;\n        case \"[d\":\n          keyName = \"left\", keyShift = !0;\n          break;\n        case \"[e\":\n          keyName = \"clear\", keyShift = !0;\n          break;\n        case \"[2$\":\n          keyName = \"insert\", keyShift = !0;\n          break;\n        case \"[3$\":\n          keyName = \"delete\", keyShift = !0;\n          break;\n        case \"[5$\":\n          keyName = \"pageup\", keyShift = !0;\n          break;\n        case \"[6$\":\n          keyName = \"pagedown\", keyShift = !0;\n          break;\n        case \"[7$\":\n          keyName = \"home\", keyShift = !0;\n          break;\n        case \"[8$\":\n          keyName = \"end\", keyShift = !0;\n          break;\n        case \"Oa\":\n          keyName = \"up\", keyCtrl2 = !0;\n          break;\n        case \"Ob\":\n          keyName = \"down\", keyCtrl2 = !0;\n          break;\n        case \"Oc\":\n          keyName = \"right\", keyCtrl2 = !0;\n          break;\n        case \"Od\":\n          keyName = \"left\", keyCtrl2 = !0;\n          break;\n        case \"Oe\":\n          keyName = \"clear\", keyCtrl2 = !0;\n          break;\n        case \"[2^\":\n          keyName = \"insert\", keyCtrl2 = !0;\n          break;\n        case \"[3^\":\n          keyName = \"delete\", keyCtrl2 = !0;\n          break;\n        case \"[5^\":\n          keyName = \"pageup\", keyCtrl2 = !0;\n          break;\n        case \"[6^\":\n          keyName = \"pagedown\", keyCtrl2 = !0;\n          break;\n        case \"[7^\":\n          keyName = \"home\", keyCtrl2 = !0;\n          break;\n        case \"[8^\":\n          keyName = \"end\", keyCtrl2 = !0;\n          break;\n        case \"[Z\":\n          keyName = \"tab\", keyShift = !0;\n          break;\n        default:\n          keyName = \"undefined\";\n          break;\n      }\n    } else if (ch === \"\\r\")\n      keyName = \"return\", keyMeta = escaped;\n    else if (ch === \"\\n\")\n      keyName = \"enter\", keyMeta = escaped;\n    else if (ch === \"\\t\")\n      keyName = \"tab\", keyMeta = escaped;\n    else if (ch === \"\\b\" || ch === \"\\x7F\")\n      keyName = \"backspace\", keyMeta = escaped;\n    else if (ch === kEscape)\n      keyName = \"escape\", keyMeta = escaped;\n    else if (ch === \" \")\n      keyName = \"space\", keyMeta = escaped;\n    else if (!escaped && ch <= \"\\x1A\")\n      keyName = StringFromCharCode(StringPrototypeCharCodeAt.call(ch) + StringPrototypeCharCodeAt.call(\"a\") - 1), keyCtrl2 = !0;\n    else if (RegExpPrototypeExec.call(/^[0-9A-Za-z]$/, ch) !== null)\n      keyName = StringPrototypeToLowerCase.call(ch), keyShift = RegExpPrototypeExec.call(/^[A-Z]$/, ch) !== null, keyMeta = escaped;\n    else if (escaped)\n      keyName = ch.length \? void 0 : \"escape\", keyMeta = !0;\n    if (keySeq = s, s.length !== 0 && (keyName !== void 0 || escaped))\n      stream.emit(\"keypress\", escaped \? void 0 : s, {\n        sequence: keySeq,\n        name: keyName,\n        ctrl: keyCtrl2,\n        meta: keyMeta,\n        shift: keyShift\n      });\n    else if (charLengthAt(s, 0) === s.length)\n      stream.emit(\"keypress\", s, {\n        sequence: keySeq,\n        name: keyName,\n        ctrl: keyCtrl2,\n        meta: keyMeta,\n        shift: keyShift\n      });\n  }\n}\nvar commonPrefix = function(strings) {\n  if (strings.length === 0)\n    return \"\";\n  if (strings.length === 1)\n    return strings[0];\n  var sorted = ArrayPrototypeSort.call(ArrayPrototypeSlice.call(strings)), min = sorted[0], max = sorted[sorted.length - 1];\n  for (var i = 0;i < min.length; i++)\n    if (min[i] !== max[i])\n      return StringPrototypeSlice.call(min, 0, i);\n  return min;\n}, cursorTo = function(stream, x, y, callback) {\n  if (callback !== void 0)\n    validateFunction(callback, \"callback\");\n  if (typeof y === \"function\")\n    callback = y, y = void 0;\n  if (NumberIsNaN(x))\n    throw new ERR_INVALID_ARG_VALUE(\"x\", x);\n  if (NumberIsNaN(y))\n    throw new ERR_INVALID_ARG_VALUE(\"y\", y);\n  if (stream == null || typeof x !== \"number\" && typeof y !== \"number\") {\n    if (typeof callback === \"function\")\n      process.nextTick(callback, null);\n    return !0;\n  }\n  if (typeof x !== \"number\")\n    throw new ERR_INVALID_CURSOR_POS;\n  var data = typeof y !== \"number\" \? CSI`${x + 1}G` : CSI`${y + 1};${x + 1}H`;\n  return stream.write(data, callback);\n}, moveCursor = function(stream, dx, dy, callback) {\n  if (callback !== void 0)\n    validateFunction(callback, \"callback\");\n  if (stream == null || !(dx || dy)) {\n    if (typeof callback === \"function\")\n      process.nextTick(callback, null);\n    return !0;\n  }\n  var data = \"\";\n  if (dx < 0)\n    data += CSI`${-dx}D`;\n  else if (dx > 0)\n    data += CSI`${dx}C`;\n  if (dy < 0)\n    data += CSI`${-dy}A`;\n  else if (dy > 0)\n    data += CSI`${dy}B`;\n  return stream.write(data, callback);\n}, clearLine = function(stream, dir, callback) {\n  if (callback !== void 0)\n    validateFunction(callback, \"callback\");\n  if (stream === null || stream === void 0) {\n    if (typeof callback === \"function\")\n      process.nextTick(callback, null);\n    return !0;\n  }\n  var type = dir < 0 \? kClearToLineBeginning : dir > 0 \? kClearToLineEnd : kClearLine;\n  return stream.write(type, callback);\n}, clearScreenDown = function(stream, callback) {\n  if (callback !== void 0)\n    validateFunction(callback, \"callback\");\n  if (stream === null || stream === void 0) {\n    if (typeof callback === \"function\")\n      process.nextTick(callback, null);\n    return !0;\n  }\n  return stream.write(kClearScreenDown, callback);\n}, emitKeypressEvents = function(stream, iface = {}) {\n  if (stream[KEYPRESS_DECODER])\n    return;\n  stream[KEYPRESS_DECODER] = new StringDecoder(\"utf8\"), stream[ESCAPE_DECODER] = emitKeys(stream), stream[ESCAPE_DECODER].next();\n  var triggerEscape = () => stream[ESCAPE_DECODER].next(\"\"), { escapeCodeTimeout = ESCAPE_CODE_TIMEOUT } = iface, timeoutId;\n  function onData(input) {\n    if (stream.listenerCount(\"keypress\") > 0) {\n      var string = stream[KEYPRESS_DECODER].write(input);\n      if (string) {\n        clearTimeout(timeoutId), iface[kSawKeyPress] = charLengthAt(string, 0) === string.length, iface.isCompletionEnabled = !1;\n        var length = 0;\n        for (var character of new SafeStringIterator(string)) {\n          if (length += character.length, length === string.length)\n            iface.isCompletionEnabled = !0;\n          try {\n            if (stream[ESCAPE_DECODER].next(character), length === string.length && character === kEscape)\n              timeoutId = setTimeout(triggerEscape, escapeCodeTimeout);\n          } catch (err) {\n            throw stream[ESCAPE_DECODER] = emitKeys(stream), stream[ESCAPE_DECODER].next(), err;\n          }\n        }\n      }\n    } else\n      stream.removeListener(\"data\", onData), stream.on(\"newListener\", onNewListener);\n  }\n  function onNewListener(event) {\n    if (event === \"keypress\")\n      stream.on(\"data\", onData), stream.removeListener(\"newListener\", onNewListener);\n  }\n  if (stream.listenerCount(\"keypress\") > 0)\n    stream.on(\"data\", onData);\n  else\n    stream.on(\"newListener\", onNewListener);\n}, onSelfCloseWithTerminal = function() {\n  var input = this.input, output = this.output;\n  if (!input)\n    throw new Error(\"Input not set, invalid state for readline!\");\n  if (input.removeListener(\"keypress\", this[kOnKeyPress]), input.removeListener(\"error\", this[kOnError]), input.removeListener(\"end\", this[kOnTermEnd]), output !== null && output !== void 0)\n    output.removeListener(\"resize\", this[kOnResize]);\n}, onSelfCloseWithoutTerminal = function() {\n  var input = this.input;\n  if (!input)\n    throw new Error(\"Input not set, invalid state for readline!\");\n  input.removeListener(\"data\", this[kOnData]), input.removeListener(\"error\", this[kOnError]), input.removeListener(\"end\", this[kOnEnd]);\n}, onError = function(err) {\n  this.emit(\"error\", err);\n}, onData = function(data) {\n  debug(\"onData\"), this[kNormalWrite](data);\n}, onEnd = function() {\n  if (debug(\"onEnd\"), typeof this[kLine_buffer] === \"string\" && this[kLine_buffer].length > 0)\n    this.emit(\"line\", this[kLine_buffer]);\n  this.close();\n}, onTermEnd = function() {\n  if (debug(\"onTermEnd\"), typeof this.line === \"string\" && this.line.length > 0)\n    this.emit(\"line\", this.line);\n  this.close();\n}, onKeyPress = function(s, key) {\n  if (this[kTtyWrite](s, key), key && key.sequence) {\n    var ch = StringPrototypeCodePointAt.call(key.sequence, 0);\n    if (ch >= 55296 && ch <= 57343)\n      this[kRefreshLine]();\n  }\n}, onResize = function() {\n  this[kRefreshLine]();\n}, InterfaceConstructor = function(input, output, completer, terminal) {\n  if (!(this instanceof InterfaceConstructor))\n    return new InterfaceConstructor(input, output, completer, terminal);\n  EventEmitter.call(this), this[kOnSelfCloseWithoutTerminal] = onSelfCloseWithoutTerminal.bind(this), this[kOnSelfCloseWithTerminal] = onSelfCloseWithTerminal.bind(this), this[kOnError] = onError.bind(this), this[kOnData] = onData.bind(this), this[kOnEnd] = onEnd.bind(this), this[kOnTermEnd] = onTermEnd.bind(this), this[kOnKeyPress] = onKeyPress.bind(this), this[kOnResize] = onResize.bind(this), this[kSawReturnAt] = 0, this.isCompletionEnabled = !0, this[kSawKeyPress] = !1, this[kPreviousKey] = null, this.escapeCodeTimeout = ESCAPE_CODE_TIMEOUT, this.tabSize = 8;\n  var history, historySize, removeHistoryDuplicates = !1, crlfDelay, prompt = \"> \", signal;\n  if (input\?.input) {\n    output = input.output, completer = input.completer, terminal = input.terminal, history = input.history, historySize = input.historySize, signal = input.signal;\n    var tabSize = input.tabSize;\n    if (tabSize !== void 0)\n      validateUint32(tabSize, \"tabSize\", !0), this.tabSize = tabSize;\n    removeHistoryDuplicates = input.removeHistoryDuplicates;\n    var inputPrompt = input.prompt;\n    if (inputPrompt !== void 0)\n      prompt = inputPrompt;\n    var inputEscapeCodeTimeout = input.escapeCodeTimeout;\n    if (inputEscapeCodeTimeout !== void 0)\n      if (NumberIsFinite(inputEscapeCodeTimeout))\n        this.escapeCodeTimeout = inputEscapeCodeTimeout;\n      else\n        throw new ERR_INVALID_ARG_VALUE(\"input.escapeCodeTimeout\", this.escapeCodeTimeout);\n    if (signal)\n      validateAbortSignal(signal, \"options.signal\");\n    crlfDelay = input.crlfDelay, input = input.input;\n  }\n  if (completer !== void 0 && typeof completer !== \"function\")\n    throw new ERR_INVALID_ARG_VALUE(\"completer\", completer);\n  if (history === void 0)\n    history = [];\n  else\n    validateArray(history, \"history\");\n  if (historySize === void 0)\n    historySize = kHistorySize;\n  if (typeof historySize !== \"number\" || NumberIsNaN(historySize) || historySize < 0)\n    throw new ERR_INVALID_ARG_VALUE(\"historySize\", historySize);\n  if (terminal === void 0 && !(output === null || output === void 0))\n    terminal = !!output.isTTY;\n  if (this.line = \"\", this[kSubstringSearch] = null, this.output = output, this.input = input, this[kUndoStack] = [], this[kRedoStack] = [], this.history = history, this.historySize = historySize, this[kKillRing] = [], this[kKillRingCursor] = 0, this.removeHistoryDuplicates = !!removeHistoryDuplicates, this.crlfDelay = crlfDelay \? MathMax(kMincrlfDelay, crlfDelay) : kMincrlfDelay, this.completer = completer, this.setPrompt(prompt), this.terminal = !!terminal, this[kLineObjectStream] = void 0, input.on(\"error\", this[kOnError]), !this.terminal)\n    input.on(\"data\", this[kOnData]), input.on(\"end\", this[kOnEnd]), this.once(\"close\", this[kOnSelfCloseWithoutTerminal]), this[kDecoder] = new StringDecoder(\"utf8\");\n  else {\n    if (emitKeypressEvents(input, this), input.on(\"keypress\", this[kOnKeyPress]), input.on(\"end\", this[kOnTermEnd]), this[kSetRawMode](!0), this.terminal = !0, this.cursor = 0, this.historyIndex = -1, output !== null && output !== void 0)\n      output.on(\"resize\", this[kOnResize]);\n    this.once(\"close\", this[kOnSelfCloseWithTerminal]);\n  }\n  if (signal) {\n    var onAborted = (() => this.close()).bind(this);\n    if (signal.aborted)\n      process.nextTick(onAborted);\n    else\n      signal.addEventListener(\"abort\", onAborted, { once: !0 }), this.once(\"close\", () => signal.removeEventListener(\"abort\", onAborted));\n  }\n  this.line = \"\", input.resume();\n}, Interface = function(input, output, completer, terminal) {\n  if (!(this instanceof Interface))\n    return new Interface(input, output, completer, terminal);\n  if (input\?.input && typeof input.completer === \"function\" && input.completer.length !== 2) {\n    var { completer } = input;\n    input.completer = (v, cb) => cb(null, completer(v));\n  } else if (typeof completer === \"function\" && completer.length !== 2) {\n    var realCompleter = completer;\n    completer = (v, cb) => cb(null, realCompleter(v));\n  }\n  InterfaceConstructor.call(this, input, output, completer, terminal);\n}, createInterface = function(input, output, completer, terminal) {\n  return new Interface(input, output, completer, terminal);\n};\nvar $, EventEmitter = @getInternalField(@internalModuleRegistry, 16) || @createInternalModuleById(16), { StringDecoder } = @requireNativeModule(\"node:string_decoder\"), isWritable, { inspect } = Bun, debug = process.env.BUN_JS_DEBUG \? console.log : () => {\n}, SymbolAsyncIterator = Symbol.asyncIterator, SymbolIterator = Symbol.iterator, SymbolFor = Symbol.for, SymbolReplace = Symbol.replace, ArrayFrom = Array.from, ArrayIsArray = Array.isArray, ArrayPrototypeFilter = Array.prototype.filter, ArrayPrototypeSort = Array.prototype.sort, ArrayPrototypeIndexOf = Array.prototype.indexOf, ArrayPrototypeJoin = Array.prototype.join, ArrayPrototypeMap = Array.prototype.map, ArrayPrototypePop = Array.prototype.pop, ArrayPrototypePush = Array.prototype.push, ArrayPrototypeSlice = Array.prototype.slice, ArrayPrototypeSplice = Array.prototype.splice, ArrayPrototypeReverse = Array.prototype.reverse, ArrayPrototypeShift = Array.prototype.shift, ArrayPrototypeUnshift = Array.prototype.unshift, RegExpPrototypeExec = RegExp.prototype.exec, RegExpPrototypeSymbolReplace = RegExp.prototype[SymbolReplace], StringFromCharCode = String.fromCharCode, StringPrototypeCharCodeAt = String.prototype.charCodeAt, StringPrototypeCodePointAt = String.prototype.codePointAt, StringPrototypeSlice = String.prototype.slice, StringPrototypeToLowerCase = String.prototype.toLowerCase, StringPrototypeEndsWith = String.prototype.endsWith, StringPrototypeRepeat = String.prototype.repeat, StringPrototypeStartsWith = String.prototype.startsWith, StringPrototypeTrim = String.prototype.trim, StringPrototypeNormalize = String.prototype.normalize, NumberIsNaN = Number.isNaN, NumberIsFinite = Number.isFinite, NumberIsInteger = Number.isInteger, NumberMAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER, NumberMIN_SAFE_INTEGER = Number.MIN_SAFE_INTEGER, MathCeil = Math.ceil, MathFloor = Math.floor, MathMax = Math.max, MathMaxApply = Math.max.apply, DateNow = Date.now, FunctionPrototype = Function.prototype, StringPrototype = String.prototype, StringPrototypeSymbolIterator = StringPrototype[SymbolIterator], StringIteratorPrototypeNext = StringPrototypeSymbolIterator.call(\"\").next, ObjectSetPrototypeOf = Object.setPrototypeOf, ObjectDefineProperty = Object.defineProperty, ObjectDefineProperties = Object.defineProperties, ObjectFreeze = Object.freeze;\nvar { create: ObjectCreate, keys: ObjectKeys } = Object;\nvar createSafeIterator = (factory, next) => {\n  class SafeIterator {\n    #iterator;\n    constructor(iterable) {\n      this.#iterator = factory.call(iterable);\n    }\n    next() {\n      return next.call(this.#iterator);\n    }\n    [SymbolIterator]() {\n      return this;\n    }\n  }\n  return ObjectSetPrototypeOf(SafeIterator.prototype, null), ObjectFreeze(SafeIterator.prototype), ObjectFreeze(SafeIterator), SafeIterator;\n}, SafeStringIterator = createSafeIterator(StringPrototypeSymbolIterator, StringIteratorPrototypeNext), isFullWidthCodePoint = (code) => {\n  return code >= 4352 && (code <= 4447 || code === 9001 || code === 9002 || code >= 11904 && code <= 12871 && code !== 12351 || code >= 12880 && code <= 19903 || code >= 19968 && code <= 42182 || code >= 43360 && code <= 43388 || code >= 44032 && code <= 55203 || code >= 63744 && code <= 64255 || code >= 65040 && code <= 65049 || code >= 65072 && code <= 65131 || code >= 65281 && code <= 65376 || code >= 65504 && code <= 65510 || code >= 110592 && code <= 110593 || code >= 127488 && code <= 127569 || code >= 127744 && code <= 128591 || code >= 131072 && code <= 262141);\n}, isZeroWidthCodePoint = (code) => {\n  return code <= 31 || code >= 127 && code <= 159 || code >= 768 && code <= 879 || code >= 8203 && code <= 8207 || code >= 8400 && code <= 8447 || code >= 65024 && code <= 65039 || code >= 65056 && code <= 65071 || code >= 917760 && code <= 917999;\n}, getStringWidth = function getStringWidth2(str, removeControlChars = !0) {\n  var width = 0;\n  if (removeControlChars)\n    str = stripVTControlCharacters(str);\n  str = StringPrototypeNormalize.call(str, \"NFC\");\n  for (var char of new SafeStringIterator(str)) {\n    var code = StringPrototypeCodePointAt.call(char, 0);\n    if (isFullWidthCodePoint(code))\n      width += 2;\n    else if (!isZeroWidthCodePoint(code))\n      width++;\n  }\n  return width;\n}, ansiPattern = \"[\\\\u001B\\\\u009B][[\\\\]()#;\?]*(\?:(\?:(\?:(\?:;[-a-zA-Z\\\\d\\\\/#&.:=\?%@~_]+)*|[a-zA-Z\\\\d]+(\?:;[-a-zA-Z\\\\d\\\\/#&.:=\?%@~_]*)*)\?\\\\u0007)|(\?:(\?:\\\\d{1,4}(\?:;\\\\d{0,4})*)\?[\\\\dA-PR-TZcf-ntqry=><~]))\", ansi = new RegExp(ansiPattern, \"g\"), kCustomPromisifiedSymbol = SymbolFor(\"nodejs.util.promisify.custom\"), kCustomPromisifyArgsSymbol = Symbol(\"customPromisifyArgs\");\npromisify.custom = kCustomPromisifiedSymbol;\nvar kUTF16SurrogateThreshold = 65536, kEscape = \"\\x1B\", kSubstringSearch = Symbol(\"kSubstringSearch\"), kIsNodeError = Symbol(\"kIsNodeError\"), errorBases = {}, VALID_NODE_ERROR_BASES = {\n  TypeError,\n  RangeError,\n  Error\n}, NodeError = getNodeErrorByName(\"Error\"), NodeTypeError = getNodeErrorByName(\"TypeError\"), NodeRangeError = getNodeErrorByName(\"RangeError\");\n\nclass ERR_INVALID_ARG_TYPE extends NodeTypeError {\n  constructor(name, type, value) {\n    super(`The \"${name}\" argument must be of type ${type}. Received type ${typeof value}`, {\n      code: \"ERR_INVALID_ARG_TYPE\"\n    });\n  }\n}\n\nclass ERR_INVALID_ARG_VALUE extends NodeTypeError {\n  constructor(name, value, reason = \"not specified\") {\n    super(`The value \"${String(value)}\" is invalid for argument '${name}'. Reason: ${reason}`, {\n      code: \"ERR_INVALID_ARG_VALUE\"\n    });\n  }\n}\n\nclass ERR_INVALID_CURSOR_POS extends NodeTypeError {\n  constructor() {\n    super(\"Cannot set cursor row without setting its column\", {\n      code: \"ERR_INVALID_CURSOR_POS\"\n    });\n  }\n}\n\nclass ERR_OUT_OF_RANGE extends NodeRangeError {\n  constructor(name, range, received) {\n    super(`The value of \"${name}\" is out of range. It must be ${range}. Received ${received}`, {\n      code: \"ERR_OUT_OF_RANGE\"\n    });\n  }\n}\n\nclass ERR_USE_AFTER_CLOSE extends NodeError {\n  constructor() {\n    super(\"This socket has been ended by the other party\", {\n      code: \"ERR_USE_AFTER_CLOSE\"\n    });\n  }\n}\n\nclass AbortError extends Error {\n  code;\n  constructor() {\n    super(\"The operation was aborted\");\n    this.code = \"ABORT_ERR\";\n  }\n}\nvar kClearLine, kClearScreenDown, kClearToLineBeginning, kClearToLineEnd;\nCSI.kEscape = kEscape;\nCSI.kClearLine = kClearLine = CSI`2K`;\nCSI.kClearScreenDown = kClearScreenDown = CSI`0J`;\nCSI.kClearToLineBeginning = kClearToLineBeginning = CSI`1K`;\nCSI.kClearToLineEnd = kClearToLineEnd = CSI`0K`;\nvar KEYPRESS_DECODER = Symbol(\"keypress-decoder\"), ESCAPE_DECODER = Symbol(\"escape-decoder\"), ESCAPE_CODE_TIMEOUT = 500, kEmptyObject = ObjectFreeze(ObjectCreate(null)), kHistorySize = 30, kMaxUndoRedoStackSize = 2048, kMincrlfDelay = 100, lineEnding = /\\r\?\\n|\\r(\?!\\n)/g, kMaxLengthOfKillRing = 32, kLineObjectStream = Symbol(\"line object stream\"), kQuestionCancel = Symbol(\"kQuestionCancel\"), kQuestion = Symbol(\"kQuestion\"), kAddHistory = Symbol(\"_addHistory\"), kBeforeEdit = Symbol(\"_beforeEdit\"), kDecoder = Symbol(\"_decoder\"), kDeleteLeft = Symbol(\"_deleteLeft\"), kDeleteLineLeft = Symbol(\"_deleteLineLeft\"), kDeleteLineRight = Symbol(\"_deleteLineRight\"), kDeleteRight = Symbol(\"_deleteRight\"), kDeleteWordLeft = Symbol(\"_deleteWordLeft\"), kDeleteWordRight = Symbol(\"_deleteWordRight\"), kGetDisplayPos = Symbol(\"_getDisplayPos\"), kHistoryNext = Symbol(\"_historyNext\"), kHistoryPrev = Symbol(\"_historyPrev\"), kInsertString = Symbol(\"_insertString\"), kLine = Symbol(\"_line\"), kLine_buffer = Symbol(\"_line_buffer\"), kKillRing = Symbol(\"_killRing\"), kKillRingCursor = Symbol(\"_killRingCursor\"), kMoveCursor = Symbol(\"_moveCursor\"), kNormalWrite = Symbol(\"_normalWrite\"), kOldPrompt = Symbol(\"_oldPrompt\"), kOnLine = Symbol(\"_onLine\"), kPreviousKey = Symbol(\"_previousKey\"), kPrompt = Symbol(\"_prompt\"), kPushToKillRing = Symbol(\"_pushToKillRing\"), kPushToUndoStack = Symbol(\"_pushToUndoStack\"), kQuestionCallback = Symbol(\"_questionCallback\"), kRedo = Symbol(\"_redo\"), kRedoStack = Symbol(\"_redoStack\"), kRefreshLine = Symbol(\"_refreshLine\"), kSawKeyPress = Symbol(\"_sawKeyPress\"), kSawReturnAt = Symbol(\"_sawReturnAt\"), kSetRawMode = Symbol(\"_setRawMode\"), kTabComplete = Symbol(\"_tabComplete\"), kTabCompleter = Symbol(\"_tabCompleter\"), kTtyWrite = Symbol(\"_ttyWrite\"), kUndo = Symbol(\"_undo\"), kUndoStack = Symbol(\"_undoStack\"), kWordLeft = Symbol(\"_wordLeft\"), kWordRight = Symbol(\"_wordRight\"), kWriteToOutput = Symbol(\"_writeToOutput\"), kYank = Symbol(\"_yank\"), kYanking = Symbol(\"_yanking\"), kYankPop = Symbol(\"_yankPop\"), kFirstEventParam = Symbol(\"nodejs.kFirstEventParam\"), kOnSelfCloseWithTerminal = Symbol(\"_onSelfCloseWithTerminal\"), kOnSelfCloseWithoutTerminal = Symbol(\"_onSelfCloseWithoutTerminal\"), kOnKeyPress = Symbol(\"_onKeyPress\"), kOnError = Symbol(\"_onError\"), kOnData = Symbol(\"_onData\"), kOnEnd = Symbol(\"_onEnd\"), kOnTermEnd = Symbol(\"_onTermEnd\"), kOnResize = Symbol(\"_onResize\");\nInterfaceConstructor.prototype = {};\nObjectSetPrototypeOf(InterfaceConstructor.prototype, EventEmitter.prototype);\nvar _Interface = class Interface2 extends InterfaceConstructor {\n  constructor(input, output, completer, terminal) {\n    super(input, output, completer, terminal);\n  }\n  get columns() {\n    var output = this.output;\n    if (output && output.columns)\n      return output.columns;\n    return Infinity;\n  }\n  setPrompt(prompt) {\n    this[kPrompt] = prompt;\n  }\n  getPrompt() {\n    return this[kPrompt];\n  }\n  [kSetRawMode](mode) {\n    var input = this.input, { setRawMode, wasInRawMode } = input;\n    return debug(\"setRawMode\", mode, \"set!\"), wasInRawMode;\n  }\n  prompt(preserveCursor) {\n    if (this.paused)\n      this.resume();\n    if (this.terminal) {\n      if (!preserveCursor)\n        this.cursor = 0;\n      this[kRefreshLine]();\n    } else\n      this[kWriteToOutput](this[kPrompt]);\n  }\n  [kQuestion](query, cb) {\n    if (this.closed)\n      throw new ERR_USE_AFTER_CLOSE(\"readline\");\n    if (this[kQuestionCallback])\n      this.prompt();\n    else\n      this[kOldPrompt] = this[kPrompt], this.setPrompt(query), this[kQuestionCallback] = cb, this.prompt();\n  }\n  [kOnLine](line) {\n    if (this[kQuestionCallback]) {\n      var cb = this[kQuestionCallback];\n      this[kQuestionCallback] = null, this.setPrompt(this[kOldPrompt]), cb(line);\n    } else\n      this.emit(\"line\", line);\n  }\n  [kBeforeEdit](oldText, oldCursor) {\n    this[kPushToUndoStack](oldText, oldCursor);\n  }\n  [kQuestionCancel]() {\n    if (this[kQuestionCallback])\n      this[kQuestionCallback] = null, this.setPrompt(this[kOldPrompt]), this.clearLine();\n  }\n  [kWriteToOutput](stringToWrite) {\n    if (validateString(stringToWrite, \"stringToWrite\"), this.output !== null && this.output !== void 0)\n      this.output.write(stringToWrite);\n  }\n  [kAddHistory]() {\n    if (this.line.length === 0)\n      return \"\";\n    if (this.historySize === 0)\n      return this.line;\n    if (StringPrototypeTrim.call(this.line).length === 0)\n      return this.line;\n    if (this.history.length === 0 || this.history[0] !== this.line) {\n      if (this.removeHistoryDuplicates) {\n        var dupIndex = ArrayPrototypeIndexOf.call(this.history, this.line);\n        if (dupIndex !== -1)\n          ArrayPrototypeSplice.call(this.history, dupIndex, 1);\n      }\n      if (ArrayPrototypeUnshift.call(this.history, this.line), this.history.length > this.historySize)\n        ArrayPrototypePop.call(this.history);\n    }\n    this.historyIndex = -1;\n    var line = this.history[0];\n    return this.emit(\"history\", this.history), line;\n  }\n  [kRefreshLine]() {\n    var line = this[kPrompt] + this.line, dispPos = this[kGetDisplayPos](line), lineCols = dispPos.cols, lineRows = dispPos.rows, cursorPos = this.getCursorPos(), prevRows = this.prevRows || 0;\n    if (prevRows > 0)\n      moveCursor(this.output, 0, -prevRows);\n    if (cursorTo(this.output, 0), clearScreenDown(this.output), this[kWriteToOutput](line), lineCols === 0)\n      this[kWriteToOutput](\" \");\n    cursorTo(this.output, cursorPos.cols);\n    var diff = lineRows - cursorPos.rows;\n    if (diff > 0)\n      moveCursor(this.output, 0, -diff);\n    this.prevRows = cursorPos.rows;\n  }\n  close() {\n    if (this.closed)\n      return;\n    if (this.pause(), this.terminal)\n      this[kSetRawMode](!1);\n    this.closed = !0, this.emit(\"close\");\n  }\n  pause() {\n    if (this.paused)\n      return;\n    return this.input.pause(), this.paused = !0, this.emit(\"pause\"), this;\n  }\n  resume() {\n    if (!this.paused)\n      return;\n    return this.input.resume(), this.paused = !1, this.emit(\"resume\"), this;\n  }\n  write(d, key) {\n    if (this.paused)\n      this.resume();\n    if (this.terminal)\n      this[kTtyWrite](d, key);\n    else\n      this[kNormalWrite](d);\n  }\n  [kNormalWrite](b) {\n    if (b === void 0)\n      return;\n    var string = this[kDecoder].write(b);\n    if (this[kSawReturnAt] && DateNow() - this[kSawReturnAt] <= this.crlfDelay) {\n      if (StringPrototypeCodePointAt.call(string) === 10)\n        string = StringPrototypeSlice.call(string, 1);\n      this[kSawReturnAt] = 0;\n    }\n    var newPartContainsEnding = RegExpPrototypeExec.call(lineEnding, string);\n    if (newPartContainsEnding !== null) {\n      if (this[kLine_buffer])\n        string = this[kLine_buffer] + string, this[kLine_buffer] = null, newPartContainsEnding = RegExpPrototypeExec.call(lineEnding, string);\n      this[kSawReturnAt] = StringPrototypeEndsWith.call(string, \"\\r\") \? DateNow() : 0;\n      var indexes = [0, newPartContainsEnding.index, lineEnding.lastIndex], nextMatch;\n      while ((nextMatch = RegExpPrototypeExec.call(lineEnding, string)) !== null)\n        ArrayPrototypePush.call(indexes, nextMatch.index, lineEnding.lastIndex);\n      var lastIndex = indexes.length - 1;\n      this[kLine_buffer] = StringPrototypeSlice.call(string, indexes[lastIndex]);\n      for (var i = 1;i < lastIndex; i += 2)\n        this[kOnLine](StringPrototypeSlice.call(string, indexes[i - 1], indexes[i]));\n    } else if (string)\n      if (this[kLine_buffer])\n        this[kLine_buffer] += string;\n      else\n        this[kLine_buffer] = string;\n  }\n  [kInsertString](c) {\n    if (this[kBeforeEdit](this.line, this.cursor), this.cursor < this.line.length) {\n      var beg = StringPrototypeSlice.call(this.line, 0, this.cursor), end = StringPrototypeSlice.call(this.line, this.cursor, this.line.length);\n      this.line = beg + c + end, this.cursor += c.length, this[kRefreshLine]();\n    } else {\n      var oldPos = this.getCursorPos();\n      this.line += c, this.cursor += c.length;\n      var newPos = this.getCursorPos();\n      if (oldPos.rows < newPos.rows)\n        this[kRefreshLine]();\n      else\n        this[kWriteToOutput](c);\n    }\n  }\n  async[kTabComplete](lastKeypressWasTab) {\n    this.pause();\n    var string = StringPrototypeSlice.call(this.line, 0, this.cursor), value;\n    try {\n      value = await this.completer(string);\n    } catch (err) {\n      this[kWriteToOutput](`Tab completion error: ${inspect(err)}`);\n      return;\n    } finally {\n      this.resume();\n    }\n    this[kTabCompleter](lastKeypressWasTab, value);\n  }\n  [kTabCompleter](lastKeypressWasTab, { 0: completions, 1: completeOn }) {\n    if (!completions || completions.length === 0)\n      return;\n    var prefix = commonPrefix(ArrayPrototypeFilter.call(completions, (e) => e !== \"\"));\n    if (StringPrototypeStartsWith.call(prefix, completeOn) && prefix.length > completeOn.length) {\n      this[kInsertString](StringPrototypeSlice.call(prefix, completeOn.length));\n      return;\n    } else if (!StringPrototypeStartsWith.call(completeOn, prefix)) {\n      this.line = StringPrototypeSlice.call(this.line, 0, this.cursor - completeOn.length) + prefix + StringPrototypeSlice.call(this.line, this.cursor, this.line.length), this.cursor = this.cursor - completeOn.length + prefix.length, this._refreshLine();\n      return;\n    }\n    if (!lastKeypressWasTab)\n      return;\n    this[kBeforeEdit](this.line, this.cursor);\n    var completionsWidth = ArrayPrototypeMap.call(completions, (e) => getStringWidth(e)), width = MathMaxApply(completionsWidth) + 2, maxColumns = MathFloor(this.columns / width) || 1;\n    if (maxColumns === Infinity)\n      maxColumns = 1;\n    var output = \"\\r\\n\", lineIndex = 0, whitespace = 0;\n    for (var i = 0;i < completions.length; i++) {\n      var completion = completions[i];\n      if (completion === \"\" || lineIndex === maxColumns)\n        output += \"\\r\\n\", lineIndex = 0, whitespace = 0;\n      else\n        output += StringPrototypeRepeat.call(\" \", whitespace);\n      if (completion !== \"\")\n        output += completion, whitespace = width - completionsWidth[i], lineIndex++;\n      else\n        output += \"\\r\\n\";\n    }\n    if (lineIndex !== 0)\n      output += \"\\r\\n\\r\\n\";\n    this[kWriteToOutput](output), this[kRefreshLine]();\n  }\n  [kWordLeft]() {\n    if (this.cursor > 0) {\n      var leading = StringPrototypeSlice.call(this.line, 0, this.cursor), reversed = ArrayPrototypeJoin.call(ArrayPrototypeReverse.call(ArrayFrom(leading)), \"\"), match = RegExpPrototypeExec.call(/^\\s*(\?:[^\\w\\s]+|\\w+)\?/, reversed);\n      this[kMoveCursor](-match[0].length);\n    }\n  }\n  [kWordRight]() {\n    if (this.cursor < this.line.length) {\n      var trailing = StringPrototypeSlice.call(this.line, this.cursor), match = RegExpPrototypeExec.call(/^(\?:\\s+|[^\\w\\s]+|\\w+)\\s*/, trailing);\n      this[kMoveCursor](match[0].length);\n    }\n  }\n  [kDeleteLeft]() {\n    if (this.cursor > 0 && this.line.length > 0) {\n      this[kBeforeEdit](this.line, this.cursor);\n      var charSize = charLengthLeft(this.line, this.cursor);\n      this.line = StringPrototypeSlice.call(this.line, 0, this.cursor - charSize) + StringPrototypeSlice.call(this.line, this.cursor, this.line.length), this.cursor -= charSize, this[kRefreshLine]();\n    }\n  }\n  [kDeleteRight]() {\n    if (this.cursor < this.line.length) {\n      this[kBeforeEdit](this.line, this.cursor);\n      var charSize = charLengthAt(this.line, this.cursor);\n      this.line = StringPrototypeSlice.call(this.line, 0, this.cursor) + StringPrototypeSlice.call(this.line, this.cursor + charSize, this.line.length), this[kRefreshLine]();\n    }\n  }\n  [kDeleteWordLeft]() {\n    if (this.cursor > 0) {\n      this[kBeforeEdit](this.line, this.cursor);\n      var leading = StringPrototypeSlice.call(this.line, 0, this.cursor), reversed = ArrayPrototypeJoin.call(ArrayPrototypeReverse.call(ArrayFrom(leading)), \"\"), match = RegExpPrototypeExec.call(/^\\s*(\?:[^\\w\\s]+|\\w+)\?/, reversed);\n      leading = StringPrototypeSlice.call(leading, 0, leading.length - match[0].length), this.line = leading + StringPrototypeSlice.call(this.line, this.cursor, this.line.length), this.cursor = leading.length, this[kRefreshLine]();\n    }\n  }\n  [kDeleteWordRight]() {\n    if (this.cursor < this.line.length) {\n      this[kBeforeEdit](this.line, this.cursor);\n      var trailing = StringPrototypeSlice.call(this.line, this.cursor), match = RegExpPrototypeExec.call(/^(\?:\\s+|\\W+|\\w+)\\s*/, trailing);\n      this.line = StringPrototypeSlice.call(this.line, 0, this.cursor) + StringPrototypeSlice.call(trailing, match[0].length), this[kRefreshLine]();\n    }\n  }\n  [kDeleteLineLeft]() {\n    this[kBeforeEdit](this.line, this.cursor);\n    var del = StringPrototypeSlice.call(this.line, 0, this.cursor);\n    this.line = StringPrototypeSlice.call(this.line, this.cursor), this.cursor = 0, this[kPushToKillRing](del), this[kRefreshLine]();\n  }\n  [kDeleteLineRight]() {\n    this[kBeforeEdit](this.line, this.cursor);\n    var del = StringPrototypeSlice.call(this.line, this.cursor);\n    this.line = StringPrototypeSlice.call(this.line, 0, this.cursor), this[kPushToKillRing](del), this[kRefreshLine]();\n  }\n  [kPushToKillRing](del) {\n    if (!del || del === this[kKillRing][0])\n      return;\n    ArrayPrototypeUnshift.call(this[kKillRing], del), this[kKillRingCursor] = 0;\n    while (this[kKillRing].length > kMaxLengthOfKillRing)\n      ArrayPrototypePop.call(this[kKillRing]);\n  }\n  [kYank]() {\n    if (this[kKillRing].length > 0)\n      this[kYanking] = !0, this[kInsertString](this[kKillRing][this[kKillRingCursor]]);\n  }\n  [kYankPop]() {\n    if (!this[kYanking])\n      return;\n    if (this[kKillRing].length > 1) {\n      var lastYank = this[kKillRing][this[kKillRingCursor]];\n      if (this[kKillRingCursor]++, this[kKillRingCursor] >= this[kKillRing].length)\n        this[kKillRingCursor] = 0;\n      var currentYank = this[kKillRing][this[kKillRingCursor]], head = StringPrototypeSlice.call(this.line, 0, this.cursor - lastYank.length), tail = StringPrototypeSlice.call(this.line, this.cursor);\n      this.line = head + currentYank + tail, this.cursor = head.length + currentYank.length, this[kRefreshLine]();\n    }\n  }\n  clearLine() {\n    this[kMoveCursor](Infinity), this[kWriteToOutput](\"\\r\\n\"), this.line = \"\", this.cursor = 0, this.prevRows = 0;\n  }\n  [kLine]() {\n    var line = this[kAddHistory]();\n    this[kUndoStack] = [], this[kRedoStack] = [], this.clearLine(), this[kOnLine](line);\n  }\n  [kPushToUndoStack](text, cursor) {\n    if (ArrayPrototypePush.call(this[kUndoStack], { text, cursor }) > kMaxUndoRedoStackSize)\n      ArrayPrototypeShift.call(this[kUndoStack]);\n  }\n  [kUndo]() {\n    if (this[kUndoStack].length <= 0)\n      return;\n    ArrayPrototypePush.call(this[kRedoStack], {\n      text: this.line,\n      cursor: this.cursor\n    });\n    var entry = ArrayPrototypePop.call(this[kUndoStack]);\n    this.line = entry.text, this.cursor = entry.cursor, this[kRefreshLine]();\n  }\n  [kRedo]() {\n    if (this[kRedoStack].length <= 0)\n      return;\n    ArrayPrototypePush.call(this[kUndoStack], {\n      text: this.line,\n      cursor: this.cursor\n    });\n    var entry = ArrayPrototypePop.call(this[kRedoStack]);\n    this.line = entry.text, this.cursor = entry.cursor, this[kRefreshLine]();\n  }\n  [kHistoryNext]() {\n    if (this.historyIndex >= 0) {\n      this[kBeforeEdit](this.line, this.cursor);\n      var search = this[kSubstringSearch] || \"\", index = this.historyIndex - 1;\n      while (index >= 0 && (!StringPrototypeStartsWith.call(this.history[index], search) || this.line === this.history[index]))\n        index--;\n      if (index === -1)\n        this.line = search;\n      else\n        this.line = this.history[index];\n      this.historyIndex = index, this.cursor = this.line.length, this[kRefreshLine]();\n    }\n  }\n  [kHistoryPrev]() {\n    if (this.historyIndex < this.history.length && this.history.length) {\n      this[kBeforeEdit](this.line, this.cursor);\n      var search = this[kSubstringSearch] || \"\", index = this.historyIndex + 1;\n      while (index < this.history.length && (!StringPrototypeStartsWith.call(this.history[index], search) || this.line === this.history[index]))\n        index++;\n      if (index === this.history.length)\n        this.line = search;\n      else\n        this.line = this.history[index];\n      this.historyIndex = index, this.cursor = this.line.length, this[kRefreshLine]();\n    }\n  }\n  [kGetDisplayPos](str) {\n    var offset = 0, col = this.columns, rows = 0;\n    str = stripVTControlCharacters(str);\n    for (var char of new SafeStringIterator(str)) {\n      if (char === \"\\n\") {\n        rows += MathCeil(offset / col) || 1, offset = 0;\n        continue;\n      }\n      if (char === \"\\t\") {\n        offset += this.tabSize - offset % this.tabSize;\n        continue;\n      }\n      var width = getStringWidth(char, !1);\n      if (width === 0 || width === 1)\n        offset += width;\n      else {\n        if ((offset + 1) % col === 0)\n          offset++;\n        offset += 2;\n      }\n    }\n    var cols = offset % col;\n    return rows += (offset - cols) / col, { cols, rows };\n  }\n  getCursorPos() {\n    var strBeforeCursor = this[kPrompt] + StringPrototypeSlice.call(this.line, 0, this.cursor);\n    return this[kGetDisplayPos](strBeforeCursor);\n  }\n  [kMoveCursor](dx) {\n    if (dx === 0)\n      return;\n    var oldPos = this.getCursorPos();\n    if (this.cursor += dx, this.cursor < 0)\n      this.cursor = 0;\n    else if (this.cursor > this.line.length)\n      this.cursor = this.line.length;\n    var newPos = this.getCursorPos();\n    if (oldPos.rows === newPos.rows) {\n      var diffWidth = newPos.cols - oldPos.cols;\n      moveCursor(this.output, diffWidth, 0);\n    } else\n      this[kRefreshLine]();\n  }\n  [kTtyWrite](s, key) {\n    var previousKey = this[kPreviousKey];\n    key = key || kEmptyObject, this[kPreviousKey] = key;\n    var { name: keyName, meta: keyMeta, ctrl: keyCtrl2, shift: keyShift, sequence: keySeq } = key;\n    if (!keyMeta || keyName !== \"y\")\n      this[kYanking] = !1;\n    if ((keyName === \"up\" || keyName === \"down\") && !keyCtrl2 && !keyMeta && !keyShift) {\n      if (this[kSubstringSearch] === null)\n        this[kSubstringSearch] = StringPrototypeSlice.call(this.line, 0, this.cursor);\n    } else if (this[kSubstringSearch] !== null) {\n      if (this[kSubstringSearch] = null, this.history.length === this.historyIndex)\n        this.historyIndex = -1;\n    }\n    if (typeof keySeq === \"string\")\n      switch (StringPrototypeCodePointAt.call(keySeq, 0)) {\n        case 31:\n          this[kUndo]();\n          return;\n        case 30:\n          this[kRedo]();\n          return;\n        default:\n          break;\n      }\n    if (keyName === \"escape\")\n      return;\n    if (keyCtrl2 && keyShift)\n      switch (keyName) {\n        case \"backspace\":\n          this[kDeleteLineLeft]();\n          break;\n        case \"delete\":\n          this[kDeleteLineRight]();\n          break;\n      }\n    else if (keyCtrl2)\n      switch (keyName) {\n        case \"c\":\n          if (this.listenerCount(\"SIGINT\") > 0)\n            this.emit(\"SIGINT\");\n          else\n            this.close();\n          break;\n        case \"h\":\n          this[kDeleteLeft]();\n          break;\n        case \"d\":\n          if (this.cursor === 0 && this.line.length === 0)\n            this.close();\n          else if (this.cursor < this.line.length)\n            this[kDeleteRight]();\n          break;\n        case \"u\":\n          this[kDeleteLineLeft]();\n          break;\n        case \"k\":\n          this[kDeleteLineRight]();\n          break;\n        case \"a\":\n          this[kMoveCursor]((-Infinity));\n          break;\n        case \"e\":\n          this[kMoveCursor](Infinity);\n          break;\n        case \"b\":\n          this[kMoveCursor](-charLengthLeft(this.line, this.cursor));\n          break;\n        case \"f\":\n          this[kMoveCursor](+charLengthAt(this.line, this.cursor));\n          break;\n        case \"l\":\n          cursorTo(this.output, 0, 0), clearScreenDown(this.output), this[kRefreshLine]();\n          break;\n        case \"n\":\n          this[kHistoryNext]();\n          break;\n        case \"p\":\n          this[kHistoryPrev]();\n          break;\n        case \"y\":\n          this[kYank]();\n          break;\n        case \"z\":\n          if (this.listenerCount(\"SIGTSTP\") > 0)\n            this.emit(\"SIGTSTP\");\n          else\n            process.once(\"SIGCONT\", () => {\n              if (!this.paused)\n                this.pause(), this.emit(\"SIGCONT\");\n              this[kSetRawMode](!0), this[kRefreshLine]();\n            }), this[kSetRawMode](!1), process.kill(process.pid, \"SIGTSTP\");\n          break;\n        case \"w\":\n        case \"backspace\":\n          this[kDeleteWordLeft]();\n          break;\n        case \"delete\":\n          this[kDeleteWordRight]();\n          break;\n        case \"left\":\n          this[kWordLeft]();\n          break;\n        case \"right\":\n          this[kWordRight]();\n          break;\n      }\n    else if (keyMeta)\n      switch (keyName) {\n        case \"b\":\n          this[kWordLeft]();\n          break;\n        case \"f\":\n          this[kWordRight]();\n          break;\n        case \"d\":\n        case \"delete\":\n          this[kDeleteWordRight]();\n          break;\n        case \"backspace\":\n          this[kDeleteWordLeft]();\n          break;\n        case \"y\":\n          this[kYankPop]();\n          break;\n      }\n    else {\n      if (this[kSawReturnAt] && keyName !== \"enter\")\n        this[kSawReturnAt] = 0;\n      switch (keyName) {\n        case \"return\":\n          this[kSawReturnAt] = DateNow(), this[kLine]();\n          break;\n        case \"enter\":\n          if (this[kSawReturnAt] === 0 || DateNow() - this[kSawReturnAt] > this.crlfDelay)\n            this[kLine]();\n          this[kSawReturnAt] = 0;\n          break;\n        case \"backspace\":\n          this[kDeleteLeft]();\n          break;\n        case \"delete\":\n          this[kDeleteRight]();\n          break;\n        case \"left\":\n          this[kMoveCursor](-charLengthLeft(this.line, this.cursor));\n          break;\n        case \"right\":\n          this[kMoveCursor](+charLengthAt(this.line, this.cursor));\n          break;\n        case \"home\":\n          this[kMoveCursor]((-Infinity));\n          break;\n        case \"end\":\n          this[kMoveCursor](Infinity);\n          break;\n        case \"up\":\n          this[kHistoryPrev]();\n          break;\n        case \"down\":\n          this[kHistoryNext]();\n          break;\n        case \"tab\":\n          if (typeof this.completer === \"function\" && this.isCompletionEnabled) {\n            var lastKeypressWasTab = previousKey && previousKey.name === \"tab\";\n            this[kTabComplete](lastKeypressWasTab);\n            break;\n          }\n        default:\n          if (typeof s === \"string\" && s) {\n            var nextMatch = RegExpPrototypeExec.call(lineEnding, s);\n            if (nextMatch !== null) {\n              this[kInsertString](StringPrototypeSlice.call(s, 0, nextMatch.index));\n              var { lastIndex } = lineEnding;\n              while ((nextMatch = RegExpPrototypeExec.call(lineEnding, s)) !== null)\n                this[kLine](), this[kInsertString](StringPrototypeSlice.call(s, lastIndex, nextMatch.index)), { lastIndex } = lineEnding;\n              if (lastIndex === s.length)\n                this[kLine]();\n            } else\n              this[kInsertString](s);\n          }\n      }\n    }\n  }\n  [SymbolAsyncIterator]() {\n    if (this[kLineObjectStream] === void 0)\n      this[kLineObjectStream] = EventEmitter.on(this, \"line\", {\n        close: [\"close\"],\n        highWatermark: 1024,\n        [kFirstEventParam]: !0\n      });\n    return this[kLineObjectStream];\n  }\n};\nInterface.prototype = {};\nObjectSetPrototypeOf(Interface.prototype, _Interface.prototype);\nObjectSetPrototypeOf(Interface, _Interface);\nInterface.prototype.question = function question(query, options, cb) {\n  if (cb = typeof options === \"function\" \? options : cb, options === null || typeof options !== \"object\")\n    options = kEmptyObject;\n  var signal = options\?.signal;\n  if (signal) {\n    if (validateAbortSignal(signal, \"options.signal\"), signal.aborted)\n      return;\n    var onAbort = () => {\n      this[kQuestionCancel]();\n    };\n    signal.addEventListener(\"abort\", onAbort, { once: !0 });\n    var cleanup = () => {\n      signal.removeEventListener(\"abort\", onAbort);\n    }, originalCb = cb;\n    cb = typeof cb === \"function\" \? (answer) => {\n      return cleanup(), originalCb(answer);\n    } : cleanup;\n  }\n  if (typeof cb === \"function\")\n    this[kQuestion](query, cb);\n};\nInterface.prototype.question[promisify.custom] = function question2(query, options) {\n  if (options === null || typeof options !== \"object\")\n    options = kEmptyObject;\n  var signal = options\?.signal;\n  if (signal && signal.aborted)\n    return PromiseReject(new AbortError(void 0, { cause: signal.reason }));\n  return new Promise((resolve, reject) => {\n    var cb = resolve;\n    if (signal) {\n      var onAbort = () => {\n        reject(new AbortError(void 0, { cause: signal.reason }));\n      };\n      signal.addEventListener(\"abort\", onAbort, { once: !0 }), cb = (answer) => {\n        signal.removeEventListener(\"abort\", onAbort), resolve(answer);\n      };\n    }\n    this.question(query, options, cb);\n  });\n};\nObjectDefineProperties(Interface.prototype, {\n  [kSetRawMode]: {\n    __proto__: null,\n    get() {\n      return this._setRawMode;\n    }\n  },\n  [kOnLine]: {\n    __proto__: null,\n    get() {\n      return this._onLine;\n    }\n  },\n  [kWriteToOutput]: {\n    __proto__: null,\n    get() {\n      return this._writeToOutput;\n    }\n  },\n  [kAddHistory]: {\n    __proto__: null,\n    get() {\n      return this._addHistory;\n    }\n  },\n  [kRefreshLine]: {\n    __proto__: null,\n    get() {\n      return this._refreshLine;\n    }\n  },\n  [kNormalWrite]: {\n    __proto__: null,\n    get() {\n      return this._normalWrite;\n    }\n  },\n  [kInsertString]: {\n    __proto__: null,\n    get() {\n      return this._insertString;\n    }\n  },\n  [kTabComplete]: {\n    __proto__: null,\n    get() {\n      return this._tabComplete;\n    }\n  },\n  [kWordLeft]: {\n    __proto__: null,\n    get() {\n      return this._wordLeft;\n    }\n  },\n  [kWordRight]: {\n    __proto__: null,\n    get() {\n      return this._wordRight;\n    }\n  },\n  [kDeleteLeft]: {\n    __proto__: null,\n    get() {\n      return this._deleteLeft;\n    }\n  },\n  [kDeleteRight]: {\n    __proto__: null,\n    get() {\n      return this._deleteRight;\n    }\n  },\n  [kDeleteWordLeft]: {\n    __proto__: null,\n    get() {\n      return this._deleteWordLeft;\n    }\n  },\n  [kDeleteWordRight]: {\n    __proto__: null,\n    get() {\n      return this._deleteWordRight;\n    }\n  },\n  [kDeleteLineLeft]: {\n    __proto__: null,\n    get() {\n      return this._deleteLineLeft;\n    }\n  },\n  [kDeleteLineRight]: {\n    __proto__: null,\n    get() {\n      return this._deleteLineRight;\n    }\n  },\n  [kLine]: {\n    __proto__: null,\n    get() {\n      return this._line;\n    }\n  },\n  [kHistoryNext]: {\n    __proto__: null,\n    get() {\n      return this._historyNext;\n    }\n  },\n  [kHistoryPrev]: {\n    __proto__: null,\n    get() {\n      return this._historyPrev;\n    }\n  },\n  [kGetDisplayPos]: {\n    __proto__: null,\n    get() {\n      return this._getDisplayPos;\n    }\n  },\n  [kMoveCursor]: {\n    __proto__: null,\n    get() {\n      return this._moveCursor;\n    }\n  },\n  [kTtyWrite]: {\n    __proto__: null,\n    get() {\n      return this._ttyWrite;\n    }\n  },\n  _decoder: {\n    __proto__: null,\n    get() {\n      return this[kDecoder];\n    },\n    set(value) {\n      this[kDecoder] = value;\n    }\n  },\n  _line_buffer: {\n    __proto__: null,\n    get() {\n      return this[kLine_buffer];\n    },\n    set(value) {\n      this[kLine_buffer] = value;\n    }\n  },\n  _oldPrompt: {\n    __proto__: null,\n    get() {\n      return this[kOldPrompt];\n    },\n    set(value) {\n      this[kOldPrompt] = value;\n    }\n  },\n  _previousKey: {\n    __proto__: null,\n    get() {\n      return this[kPreviousKey];\n    },\n    set(value) {\n      this[kPreviousKey] = value;\n    }\n  },\n  _prompt: {\n    __proto__: null,\n    get() {\n      return this[kPrompt];\n    },\n    set(value) {\n      this[kPrompt] = value;\n    }\n  },\n  _questionCallback: {\n    __proto__: null,\n    get() {\n      return this[kQuestionCallback];\n    },\n    set(value) {\n      this[kQuestionCallback] = value;\n    }\n  },\n  _sawKeyPress: {\n    __proto__: null,\n    get() {\n      return this[kSawKeyPress];\n    },\n    set(value) {\n      this[kSawKeyPress] = value;\n    }\n  },\n  _sawReturnAt: {\n    __proto__: null,\n    get() {\n      return this[kSawReturnAt];\n    },\n    set(value) {\n      this[kSawReturnAt] = value;\n    }\n  }\n});\nInterface.prototype._setRawMode = _Interface.prototype[kSetRawMode];\nInterface.prototype._onLine = _Interface.prototype[kOnLine];\nInterface.prototype._writeToOutput = _Interface.prototype[kWriteToOutput];\nInterface.prototype._addHistory = _Interface.prototype[kAddHistory];\nInterface.prototype._refreshLine = _Interface.prototype[kRefreshLine];\nInterface.prototype._normalWrite = _Interface.prototype[kNormalWrite];\nInterface.prototype._insertString = _Interface.prototype[kInsertString];\nInterface.prototype._tabComplete = function(lastKeypressWasTab) {\n  this.pause();\n  var string = StringPrototypeSlice.call(this.line, 0, this.cursor);\n  this.completer(string, (err, value) => {\n    if (this.resume(), err) {\n      this._writeToOutput(`Tab completion error: ${inspect(err)}`);\n      return;\n    }\n    this[kTabCompleter](lastKeypressWasTab, value);\n  });\n};\nInterface.prototype._wordLeft = _Interface.prototype[kWordLeft];\nInterface.prototype._wordRight = _Interface.prototype[kWordRight];\nInterface.prototype._deleteLeft = _Interface.prototype[kDeleteLeft];\nInterface.prototype._deleteRight = _Interface.prototype[kDeleteRight];\nInterface.prototype._deleteWordLeft = _Interface.prototype[kDeleteWordLeft];\nInterface.prototype._deleteWordRight = _Interface.prototype[kDeleteWordRight];\nInterface.prototype._deleteLineLeft = _Interface.prototype[kDeleteLineLeft];\nInterface.prototype._deleteLineRight = _Interface.prototype[kDeleteLineRight];\nInterface.prototype._line = _Interface.prototype[kLine];\nInterface.prototype._historyNext = _Interface.prototype[kHistoryNext];\nInterface.prototype._historyPrev = _Interface.prototype[kHistoryPrev];\nInterface.prototype._getDisplayPos = _Interface.prototype[kGetDisplayPos];\nInterface.prototype._getCursorPos = _Interface.prototype.getCursorPos;\nInterface.prototype._moveCursor = _Interface.prototype[kMoveCursor];\nInterface.prototype._ttyWrite = _Interface.prototype[kTtyWrite];\n\nclass Readline {\n  #autoCommit = !1;\n  #stream;\n  #todo = [];\n  constructor(stream, options = void 0) {\n    if (isWritable \?\?= (@getInternalField(@internalModuleRegistry, 35) || @createInternalModuleById(35)).isWritable, !isWritable(stream))\n      throw new ERR_INVALID_ARG_TYPE(\"stream\", \"Writable\", stream);\n    if (this.#stream = stream, options\?.autoCommit != null)\n      validateBoolean(options.autoCommit, \"options.autoCommit\"), this.#autoCommit = options.autoCommit;\n  }\n  cursorTo(x, y = void 0) {\n    if (validateInteger(x, \"x\"), y != null)\n      validateInteger(y, \"y\");\n    var data = y == null \? CSI`${x + 1}G` : CSI`${y + 1};${x + 1}H`;\n    if (this.#autoCommit)\n      process.nextTick(() => this.#stream.write(data));\n    else\n      ArrayPrototypePush.call(this.#todo, data);\n    return this;\n  }\n  moveCursor(dx, dy) {\n    if (dx || dy) {\n      validateInteger(dx, \"dx\"), validateInteger(dy, \"dy\");\n      var data = \"\";\n      if (dx < 0)\n        data += CSI`${-dx}D`;\n      else if (dx > 0)\n        data += CSI`${dx}C`;\n      if (dy < 0)\n        data += CSI`${-dy}A`;\n      else if (dy > 0)\n        data += CSI`${dy}B`;\n      if (this.#autoCommit)\n        process.nextTick(() => this.#stream.write(data));\n      else\n        ArrayPrototypePush.call(this.#todo, data);\n    }\n    return this;\n  }\n  clearLine(dir) {\n    validateInteger(dir, \"dir\", -1, 1);\n    var data = dir < 0 \? kClearToLineBeginning : dir > 0 \? kClearToLineEnd : kClearLine;\n    if (this.#autoCommit)\n      process.nextTick(() => this.#stream.write(data));\n    else\n      ArrayPrototypePush.call(this.#todo, data);\n    return this;\n  }\n  clearScreenDown() {\n    if (this.#autoCommit)\n      process.nextTick(() => this.#stream.write(kClearScreenDown));\n    else\n      ArrayPrototypePush.call(this.#todo, kClearScreenDown);\n    return this;\n  }\n  commit() {\n    return new Promise((resolve) => {\n      this.#stream.write(ArrayPrototypeJoin.call(this.#todo, \"\"), resolve), this.#todo = [];\n    });\n  }\n  rollback() {\n    return this.#todo = [], this;\n  }\n}\nvar PromisesInterface = class Interface3 extends _Interface {\n  constructor(input, output, completer, terminal) {\n    super(input, output, completer, terminal);\n  }\n  question(query, options = kEmptyObject) {\n    var signal = options\?.signal;\n    if (signal) {\n      if (validateAbortSignal(signal, \"options.signal\"), signal.aborted)\n        return PromiseReject(new AbortError(void 0, { cause: signal.reason }));\n    }\n    return new Promise((resolve, reject) => {\n      var cb = resolve;\n      if (options\?.signal) {\n        var onAbort = () => {\n          this[kQuestionCancel](), reject(new AbortError(void 0, { cause: signal.reason }));\n        };\n        signal.addEventListener(\"abort\", onAbort, { once: !0 }), cb = (answer) => {\n          signal.removeEventListener(\"abort\", onAbort), resolve(answer);\n        };\n      }\n      this[kQuestion](query, cb);\n    });\n  }\n};\n$ = {\n  Interface,\n  clearLine,\n  clearScreenDown,\n  createInterface,\n  cursorTo,\n  emitKeypressEvents,\n  moveCursor,\n  promises: {\n    Readline,\n    Interface: PromisesInterface,\n    createInterface(input, output, completer, terminal) {\n      return new PromisesInterface(input, output, completer, terminal);\n    }\n  },\n  [SymbolFor(\"__BUN_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED__\")]: {\n    CSI,\n    utils: {\n      getStringWidth,\n      stripVTControlCharacters\n    }\n  }\n};\nreturn $})\n"_s;
//

//
static constexpr ASCIILiteral NodeReadlinePromisesCode = "(function (){\"use strict\";// src/js/out/tmp/node/readline.promises.ts\nreturn (@getInternalField(@internalModuleRegistry, 31) || @createInternalModuleById(31)).promises})\n"_s;
//

//
static constexpr ASCIILiteral NodeReplCode = "(function (){\"use strict\";// src/js/out/tmp/node/repl.ts\nvar $, { throwNotImplemented } = @getInternalField(@internalModuleRegistry, 3) || @createInternalModuleById(3);\n$ = {\n  lines: [],\n  context: globalThis,\n  historyIndex: -1,\n  cursor: 0,\n  historySize: 1000,\n  removeHistoryDuplicates: !1,\n  crlfDelay: 100,\n  completer: () => {\n    throwNotImplemented(\"node:repl\");\n  },\n  history: [],\n  _initialPrompt: \"> \",\n  terminal: !0,\n  input: new Proxy({}, {\n    get() {\n      throwNotImplemented(\"node:repl\");\n    },\n    has: () => !1,\n    ownKeys: () => [],\n    getOwnPropertyDescriptor: () => {\n      return;\n    },\n    set() {\n      throwNotImplemented(\"node:repl\");\n    }\n  }),\n  line: \"\",\n  eval: () => {\n    throwNotImplemented(\"node:repl\");\n  },\n  isCompletionEnabled: !0,\n  escapeCodeTimeout: 500,\n  tabSize: 8,\n  breakEvalOnSigint: !0,\n  useGlobal: !0,\n  underscoreAssigned: !1,\n  last: void 0,\n  _domain: void 0,\n  allowBlockingCompletions: !1,\n  useColors: !0,\n  output: new Proxy({}, {\n    get() {\n      throwNotImplemented(\"node:repl\");\n    },\n    has: () => !1,\n    ownKeys: () => [],\n    getOwnPropertyDescriptor: () => {\n      return;\n    },\n    set() {\n      throwNotImplemented(\"node:repl\");\n    }\n  }),\n  _builtinLibs: [\n    \"bun\",\n    \"ffi\",\n    \"assert\",\n    \"assert/strict\",\n    \"async_hooks\",\n    \"buffer\",\n    \"child_process\",\n    \"cluster\",\n    \"console\",\n    \"constants\",\n    \"crypto\",\n    \"dgram\",\n    \"diagnostics_channel\",\n    \"dns\",\n    \"dns/promises\",\n    \"domain\",\n    \"events\",\n    \"fs\",\n    \"fs/promises\",\n    \"http\",\n    \"http2\",\n    \"https\",\n    \"inspector\",\n    \"inspector/promises\",\n    \"module\",\n    \"net\",\n    \"os\",\n    \"path\",\n    \"path/posix\",\n    \"path/win32\",\n    \"perf_hooks\",\n    \"process\",\n    \"punycode\",\n    \"querystring\",\n    \"readline\",\n    \"readline/promises\",\n    \"repl\",\n    \"stream\",\n    \"stream/consumers\",\n    \"stream/promises\",\n    \"stream/web\",\n    \"string_decoder\",\n    \"sys\",\n    \"timers\",\n    \"timers/promises\",\n    \"tls\",\n    \"trace_events\",\n    \"tty\",\n    \"url\",\n    \"util\",\n    \"util/types\",\n    \"v8\",\n    \"vm\",\n    \"wasi\",\n    \"worker_threads\",\n    \"zlib\"\n  ]\n};\nreturn $})\n"_s;
//

//
static constexpr ASCIILiteral NodeStreamConsumersCode = "(function (){\"use strict\";// src/js/out/tmp/node/stream.consumers.ts\nvar $, arrayBuffer = Bun.readableStreamToArrayBuffer, text = Bun.readableStreamToText, json = (stream) => Bun.readableStreamToText(stream).then(JSON.parse), buffer = async (readableStream) => {\n  return new Buffer(await arrayBuffer(readableStream));\n}, blob = Bun.readableStreamToBlob;\n$ = {\n  arrayBuffer,\n  text,\n  json,\n  buffer,\n  blob\n};\nreturn $})\n"_s;
//

//
static constexpr ASCIILiteral NodeStreamCode = "(function (){\"use strict\";// src/js/out/tmp/node/stream.ts\nvar isReadableStream = function(value) {\n  return typeof value === \"object\" && value !== null && value instanceof ReadableStream;\n}, validateBoolean = function(value, name) {\n  if (typeof value !== \"boolean\")\n    throw new ERR_INVALID_ARG_TYPE(name, \"boolean\", value);\n};\nvar ERR_INVALID_ARG_TYPE = function(name, type, value) {\n  return new Error(`The argument '${name}' is invalid. Received '${value}' for type '${type}'`);\n}, ERR_INVALID_ARG_VALUE = function(name, value, reason) {\n  return new Error(`The value '${value}' is invalid for argument '${name}'. Reason: ${reason}`);\n}, createNativeStreamReadable = function(nativeType, Readable) {\n  var [pull, start, cancel, setClose, deinit, updateRef, drainFn] = globalThis[globalThis.Symbol.for('Bun.lazy')](nativeType), closer = [!1], handleNumberResult = function(nativeReadable, result, view, isClosed) {\n    if (result > 0) {\n      const slice = view.subarray(0, result), remainder = view.subarray(result);\n      if (slice.byteLength > 0)\n        nativeReadable.push(slice);\n      if (isClosed)\n        nativeReadable.push(null);\n      return remainder.byteLength > 0 \? remainder : void 0;\n    }\n    if (isClosed)\n      nativeReadable.push(null);\n    return view;\n  }, handleArrayBufferViewResult = function(nativeReadable, result, view, isClosed) {\n    if (result.byteLength > 0)\n      nativeReadable.push(result);\n    if (isClosed)\n      nativeReadable.push(null);\n    return view;\n  }, DYNAMICALLY_ADJUST_CHUNK_SIZE = process.env.BUN_DISABLE_DYNAMIC_CHUNK_SIZE !== \"1\";\n  const finalizer = new FinalizationRegistry((ptr) => ptr && deinit(ptr)), MIN_BUFFER_SIZE = 512;\n  var NativeReadable = class NativeReadable2 extends Readable {\n    #bunNativePtr;\n    #refCount = 1;\n    #constructed = !1;\n    #remainingChunk = void 0;\n    #highWaterMark;\n    #pendingRead = !1;\n    #hasResized = !DYNAMICALLY_ADJUST_CHUNK_SIZE;\n    #unregisterToken;\n    constructor(ptr, options = {}) {\n      super(options);\n      if (typeof options.highWaterMark === \"number\")\n        this.#highWaterMark = options.highWaterMark;\n      else\n        this.#highWaterMark = 262144;\n      this.#bunNativePtr = ptr, this.#constructed = !1, this.#remainingChunk = void 0, this.#pendingRead = !1, this.#unregisterToken = {}, finalizer.register(this, this.#bunNativePtr, this.#unregisterToken);\n    }\n    _read(maxToRead) {\n      if (this.#pendingRead)\n        return;\n      var ptr = this.#bunNativePtr;\n      if (ptr === 0) {\n        this.push(null);\n        return;\n      }\n      if (!this.#constructed)\n        this.#internalConstruct(ptr);\n      return this.#internalRead(this.#getRemainingChunk(maxToRead), ptr);\n    }\n    #internalConstruct(ptr) {\n      this.#constructed = !0;\n      const result = start(ptr, this.#highWaterMark);\n      if (typeof result === \"number\" && result > 1)\n        this.#hasResized = !0, this.#highWaterMark = Math.min(this.#highWaterMark, result);\n      if (drainFn) {\n        const drainResult = drainFn(ptr);\n        if ((drainResult\?.byteLength \?\? 0) > 0)\n          this.push(drainResult);\n      }\n    }\n    #getRemainingChunk(maxToRead = this.#highWaterMark) {\n      var chunk = this.#remainingChunk;\n      if (chunk\?.byteLength \?\? 0 < MIN_BUFFER_SIZE) {\n        var size = maxToRead > MIN_BUFFER_SIZE \? maxToRead : MIN_BUFFER_SIZE;\n        this.#remainingChunk = chunk = new Buffer(size);\n      }\n      return chunk;\n    }\n    #handleResult(result, view, isClosed) {\n      if (typeof result === \"number\") {\n        if (result >= this.#highWaterMark && !this.#hasResized && !isClosed)\n          this.#highWaterMark *= 2, this.#hasResized = !0;\n        return handleNumberResult(this, result, view, isClosed);\n      } else if (typeof result === \"boolean\")\n        return process.nextTick(() => {\n          this.push(null);\n        }), view\?.byteLength \?\? 0 > 0 \? view : void 0;\n      else if (ArrayBuffer.isView(result)) {\n        if (result.byteLength >= this.#highWaterMark && !this.#hasResized && !isClosed)\n          this.#highWaterMark *= 2, this.#hasResized = !0;\n        return handleArrayBufferViewResult(this, result, view, isClosed);\n      } else\n        throw new Error(\"Invalid result from pull\");\n    }\n    #internalRead(view, ptr) {\n      closer[0] = !1;\n      var result = pull(ptr, view, closer);\n      if (@isPromise(result))\n        return this.#pendingRead = !0, result.then((result2) => {\n          this.#pendingRead = !1, this.#remainingChunk = this.#handleResult(result2, view, closer[0]);\n        }, (reason) => {\n          errorOrDestroy(this, reason);\n        });\n      else\n        this.#remainingChunk = this.#handleResult(result, view, closer[0]);\n    }\n    _destroy(error, callback) {\n      var ptr = this.#bunNativePtr;\n      if (ptr === 0) {\n        callback(error);\n        return;\n      }\n      if (finalizer.unregister(this.#unregisterToken), this.#bunNativePtr = 0, updateRef)\n        updateRef(ptr, !1);\n      cancel(ptr, error), callback(error);\n    }\n    ref() {\n      var ptr = this.#bunNativePtr;\n      if (ptr === 0)\n        return;\n      if (this.#refCount++ === 0)\n        updateRef(ptr, !0);\n    }\n    unref() {\n      var ptr = this.#bunNativePtr;\n      if (ptr === 0)\n        return;\n      if (this.#refCount-- === 1)\n        updateRef(ptr, !1);\n    }\n  };\n  if (!updateRef)\n    NativeReadable.prototype.ref = void 0, NativeReadable.prototype.unref = void 0;\n  return NativeReadable;\n}, getNativeReadableStreamPrototype = function(nativeType, Readable) {\n  return nativeReadableStreamPrototypes[nativeType] ||= createNativeStreamReadable(nativeType, Readable);\n}, getNativeReadableStream = function(Readable, stream, options) {\n  if (!(stream && typeof stream === \"object\" && stream instanceof ReadableStream))\n    return;\n  const native = @direct(stream);\n  if (!native)\n    return;\n  const { stream: ptr, data: type } = native;\n  return new (getNativeReadableStreamPrototype(type, Readable))(ptr, options);\n}, EE = globalThis[globalThis.Symbol.for('Bun.lazy')](\"events\"), StringDecoder = @requireNativeModule(\"node:string_decoder\").StringDecoder, __getOwnPropNames = Object.getOwnPropertyNames, __commonJS = (cb, mod) => function __require2() {\n  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;\n}, runOnNextTick = process.nextTick;\nvar ArrayIsArray = Array.isArray, require_primordials = __commonJS({\n  \"node_modules/readable-stream/lib/ours/primordials.js\"(exports, module) {\n    module.exports = {\n      ArrayIsArray(self) {\n        return Array.isArray(self);\n      },\n      ArrayPrototypeIncludes(self, el) {\n        return self.includes(el);\n      },\n      ArrayPrototypeIndexOf(self, el) {\n        return self.indexOf(el);\n      },\n      ArrayPrototypeJoin(self, sep) {\n        return self.join(sep);\n      },\n      ArrayPrototypeMap(self, fn) {\n        return self.map(fn);\n      },\n      ArrayPrototypePop(self, el) {\n        return self.pop(el);\n      },\n      ArrayPrototypePush(self, el) {\n        return self.push(el);\n      },\n      ArrayPrototypeSlice(self, start, end) {\n        return self.slice(start, end);\n      },\n      Error,\n      FunctionPrototypeCall(fn, thisArgs, ...args) {\n        return fn.call(thisArgs, ...args);\n      },\n      FunctionPrototypeSymbolHasInstance(self, instance) {\n        return Function.prototype[Symbol.hasInstance].call(self, instance);\n      },\n      MathFloor: Math.floor,\n      Number,\n      NumberIsInteger: Number.isInteger,\n      NumberIsNaN: Number.isNaN,\n      NumberMAX_SAFE_INTEGER: Number.MAX_SAFE_INTEGER,\n      NumberMIN_SAFE_INTEGER: Number.MIN_SAFE_INTEGER,\n      NumberParseInt: Number.parseInt,\n      ObjectDefineProperties(self, props) {\n        return Object.defineProperties(self, props);\n      },\n      ObjectDefineProperty(self, name, prop) {\n        return Object.defineProperty(self, name, prop);\n      },\n      ObjectGetOwnPropertyDescriptor(self, name) {\n        return Object.getOwnPropertyDescriptor(self, name);\n      },\n      ObjectKeys(obj) {\n        return Object.keys(obj);\n      },\n      ObjectSetPrototypeOf(target, proto) {\n        return Object.setPrototypeOf(target, proto);\n      },\n      Promise,\n      PromisePrototypeCatch(self, fn) {\n        return self.catch(fn);\n      },\n      PromisePrototypeThen(self, thenFn, catchFn) {\n        return self.then(thenFn, catchFn);\n      },\n      PromiseReject(err) {\n        return Promise.reject(err);\n      },\n      ReflectApply: Reflect.apply,\n      RegExpPrototypeTest(self, value) {\n        return self.test(value);\n      },\n      SafeSet: Set,\n      String,\n      StringPrototypeSlice(self, start, end) {\n        return self.slice(start, end);\n      },\n      StringPrototypeToLowerCase(self) {\n        return self.toLowerCase();\n      },\n      StringPrototypeToUpperCase(self) {\n        return self.toUpperCase();\n      },\n      StringPrototypeTrim(self) {\n        return self.trim();\n      },\n      Symbol,\n      SymbolAsyncIterator: Symbol.asyncIterator,\n      SymbolHasInstance: Symbol.hasInstance,\n      SymbolIterator: Symbol.iterator,\n      TypedArrayPrototypeSet(self, buf, len) {\n        return self.set(buf, len);\n      },\n      Uint8Array\n    };\n  }\n}), require_util = __commonJS({\n  \"node_modules/readable-stream/lib/ours/util.js\"(exports, module) {\n    var AsyncFunction = Object.getPrototypeOf(async function() {\n    }).constructor, isBlob = typeof Blob !== \"undefined\" \? function isBlob2(b) {\n      return b instanceof Blob;\n    } : function isBlob2(b) {\n      return !1;\n    }, AggregateError = class extends Error {\n      constructor(errors) {\n        if (!Array.isArray(errors))\n          @throwTypeError(`Expected input to be an Array, got ${typeof errors}`);\n        let message = \"\";\n        for (let i = 0;i < errors.length; i++)\n          message += `    ${errors[i].stack}\n`;\n        super(message);\n        this.name = \"AggregateError\", this.errors = errors;\n      }\n    };\n    module.exports = {\n      AggregateError,\n      once(callback) {\n        let called = !1;\n        return function(...args) {\n          if (called)\n            return;\n          called = !0, callback.apply(this, args);\n        };\n      },\n      createDeferredPromise: function() {\n        let resolve, reject;\n        return {\n          promise: new Promise((res, rej) => {\n            resolve = res, reject = rej;\n          }),\n          resolve,\n          reject\n        };\n      },\n      promisify(fn) {\n        return new Promise((resolve, reject) => {\n          fn((err, ...args) => {\n            if (err)\n              return reject(err);\n            return resolve(...args);\n          });\n        });\n      },\n      debuglog() {\n        return function() {\n        };\n      },\n      format(format, ...args) {\n        return format.replace(/%([sdifj])/g, function(...[_unused, type]) {\n          const replacement = args.shift();\n          if (type === \"f\")\n            return replacement.toFixed(6);\n          else if (type === \"j\")\n            return JSON.stringify(replacement);\n          else if (type === \"s\" && typeof replacement === \"object\")\n            return `${replacement.constructor !== Object \? replacement.constructor.name : \"\"} {}`.trim();\n          else\n            return replacement.toString();\n        });\n      },\n      inspect(value) {\n        switch (typeof value) {\n          case \"string\":\n            if (value.includes(\"'\")) {\n              if (!value.includes('\"'))\n                return `\"${value}\"`;\n              else if (!value.includes(\"`\") && !value.includes(\"${\"))\n                return `\\`${value}\\``;\n            }\n            return `'${value}'`;\n          case \"number\":\n            if (isNaN(value))\n              return \"NaN\";\n            else if (Object.is(value, -0))\n              return String(value);\n            return value;\n          case \"bigint\":\n            return `${String(value)}n`;\n          case \"boolean\":\n          case \"undefined\":\n            return String(value);\n          case \"object\":\n            return \"{}\";\n        }\n      },\n      types: {\n        isAsyncFunction(fn) {\n          return fn instanceof AsyncFunction;\n        },\n        isArrayBufferView(arr) {\n          return ArrayBuffer.isView(arr);\n        }\n      },\n      isBlob\n    }, module.exports.promisify.custom = Symbol.for(\"nodejs.util.promisify.custom\");\n  }\n}), require_errors = __commonJS({\n  \"node_modules/readable-stream/lib/ours/errors.js\"(exports, module) {\n    var { format, inspect, AggregateError: CustomAggregateError } = require_util(), AggregateError = globalThis.AggregateError || CustomAggregateError, kIsNodeError = Symbol(\"kIsNodeError\"), kTypes = [\"string\", \"function\", \"number\", \"object\", \"Function\", \"Object\", \"boolean\", \"bigint\", \"symbol\"], classRegExp = /^([A-Z][a-z0-9]*)+$/, nodeInternalPrefix = \"__node_internal_\", codes = {};\n    function assert(value, message) {\n      if (!value)\n        throw new codes.ERR_INTERNAL_ASSERTION(message);\n    }\n    function addNumericalSeparator(val) {\n      let res = \"\", i = val.length;\n      const start = val[0] === \"-\" \? 1 : 0;\n      for (;i >= start + 4; i -= 3)\n        res = `_${val.slice(i - 3, i)}${res}`;\n      return `${val.slice(0, i)}${res}`;\n    }\n    function getMessage(key, msg, args) {\n      if (typeof msg === \"function\")\n        return assert(msg.length <= args.length, `Code: ${key}; The provided arguments length (${args.length}) does not match the required ones (${msg.length}).`), msg(...args);\n      const expectedLength = (msg.match(/%[dfijoOs]/g) || []).length;\n      if (assert(expectedLength === args.length, `Code: ${key}; The provided arguments length (${args.length}) does not match the required ones (${expectedLength}).`), args.length === 0)\n        return msg;\n      return format(msg, ...args);\n    }\n    function E(code, message, Base) {\n      if (!Base)\n        Base = Error;\n\n      class NodeError extends Base {\n        constructor(...args) {\n          super(getMessage(code, message, args));\n        }\n        toString() {\n          return `${this.name} [${code}]: ${this.message}`;\n        }\n      }\n      Object.defineProperties(NodeError.prototype, {\n        name: {\n          value: Base.name,\n          writable: !0,\n          enumerable: !1,\n          configurable: !0\n        },\n        toString: {\n          value() {\n            return `${this.name} [${code}]: ${this.message}`;\n          },\n          writable: !0,\n          enumerable: !1,\n          configurable: !0\n        }\n      }), NodeError.prototype.code = code, NodeError.prototype[kIsNodeError] = !0, codes[code] = NodeError;\n    }\n    function hideStackFrames(fn) {\n      const hidden = nodeInternalPrefix + fn.name;\n      return Object.defineProperty(fn, \"name\", {\n        value: hidden\n      }), fn;\n    }\n    function aggregateTwoErrors(innerError, outerError) {\n      if (innerError && outerError && innerError !== outerError) {\n        if (Array.isArray(outerError.errors))\n          return outerError.errors.push(innerError), outerError;\n        const err = new AggregateError([outerError, innerError], outerError.message);\n        return err.code = outerError.code, err;\n      }\n      return innerError || outerError;\n    }\n    var AbortError2 = class extends Error {\n      constructor(message = \"The operation was aborted\", options = void 0) {\n        if (options !== void 0 && typeof options !== \"object\")\n          throw new codes.ERR_INVALID_ARG_TYPE(\"options\", \"Object\", options);\n        super(message, options);\n        this.code = \"ABORT_ERR\", this.name = \"AbortError\";\n      }\n    };\n    E(\"ERR_ASSERTION\", \"%s\", Error), E(\"ERR_INVALID_ARG_TYPE\", (name, expected, actual) => {\n      if (assert(typeof name === \"string\", \"'name' must be a string\"), !Array.isArray(expected))\n        expected = [expected];\n      let msg = \"The \";\n      if (name.endsWith(\" argument\"))\n        msg += `${name} `;\n      else\n        msg += `\"${name}\" ${name.includes(\".\") \? \"property\" : \"argument\"} `;\n      msg += \"must be \";\n      const types = [], instances = [], other = [];\n      for (let value of expected)\n        if (assert(typeof value === \"string\", \"All expected entries have to be of type string\"), kTypes.includes(value))\n          types.push(value.toLowerCase());\n        else if (classRegExp.test(value))\n          instances.push(value);\n        else\n          assert(value !== \"object\", 'The value \"object\" should be written as \"Object\"'), other.push(value);\n      if (instances.length > 0) {\n        const pos = types.indexOf(\"object\");\n        if (pos !== -1)\n          types.splice(types, pos, 1), instances.push(\"Object\");\n      }\n      if (types.length > 0) {\n        switch (types.length) {\n          case 1:\n            msg += `of type ${types[0]}`;\n            break;\n          case 2:\n            msg += `one of type ${types[0]} or ${types[1]}`;\n            break;\n          default: {\n            const last = types.pop();\n            msg += `one of type ${types.join(\", \")}, or ${last}`;\n          }\n        }\n        if (instances.length > 0 || other.length > 0)\n          msg += \" or \";\n      }\n      if (instances.length > 0) {\n        switch (instances.length) {\n          case 1:\n            msg += `an instance of ${instances[0]}`;\n            break;\n          case 2:\n            msg += `an instance of ${instances[0]} or ${instances[1]}`;\n            break;\n          default: {\n            const last = instances.pop();\n            msg += `an instance of ${instances.join(\", \")}, or ${last}`;\n          }\n        }\n        if (other.length > 0)\n          msg += \" or \";\n      }\n      switch (other.length) {\n        case 0:\n          break;\n        case 1:\n          if (other[0].toLowerCase() !== other[0])\n            msg += \"an \";\n          msg += `${other[0]}`;\n          break;\n        case 2:\n          msg += `one of ${other[0]} or ${other[1]}`;\n          break;\n        default: {\n          const last = other.pop();\n          msg += `one of ${other.join(\", \")}, or ${last}`;\n        }\n      }\n      if (actual == null)\n        msg += `. Received ${actual}`;\n      else if (typeof actual === \"function\" && actual.name)\n        msg += `. Received function ${actual.name}`;\n      else if (typeof actual === \"object\") {\n        var _actual$constructor;\n        if ((_actual$constructor = actual.constructor) !== null && _actual$constructor !== void 0 && _actual$constructor.name)\n          msg += `. Received an instance of ${actual.constructor.name}`;\n        else {\n          const inspected = inspect(actual, {\n            depth: -1\n          });\n          msg += `. Received ${inspected}`;\n        }\n      } else {\n        let inspected = inspect(actual, {\n          colors: !1\n        });\n        if (inspected.length > 25)\n          inspected = `${inspected.slice(0, 25)}...`;\n        msg += `. Received type ${typeof actual} (${inspected})`;\n      }\n      return msg;\n    }, TypeError), E(\"ERR_INVALID_ARG_VALUE\", (name, value, reason = \"is invalid\") => {\n      let inspected = inspect(value);\n      if (inspected.length > 128)\n        inspected = inspected.slice(0, 128) + \"...\";\n      return `The ${name.includes(\".\") \? \"property\" : \"argument\"} '${name}' ${reason}. Received ${inspected}`;\n    }, TypeError), E(\"ERR_INVALID_RETURN_VALUE\", (input, name, value) => {\n      var _value$constructor;\n      const type = value !== null && value !== void 0 && (_value$constructor = value.constructor) !== null && _value$constructor !== void 0 && _value$constructor.name \? `instance of ${value.constructor.name}` : `type ${typeof value}`;\n      return `Expected ${input} to be returned from the \"${name}\" function but got ${type}.`;\n    }, TypeError), E(\"ERR_MISSING_ARGS\", (...args) => {\n      assert(args.length > 0, \"At least one arg needs to be specified\");\n      let msg;\n      const len = args.length;\n      switch (args = (Array.isArray(args) \? args : [args]).map((a) => `\"${a}\"`).join(\" or \"), len) {\n        case 1:\n          msg += `The ${args[0]} argument`;\n          break;\n        case 2:\n          msg += `The ${args[0]} and ${args[1]} arguments`;\n          break;\n        default:\n          {\n            const last = args.pop();\n            msg += `The ${args.join(\", \")}, and ${last} arguments`;\n          }\n          break;\n      }\n      return `${msg} must be specified`;\n    }, TypeError), E(\"ERR_OUT_OF_RANGE\", (str, range, input) => {\n      assert(range, 'Missing \"range\" argument');\n      let received;\n      if (Number.isInteger(input) && Math.abs(input) > 4294967296)\n        received = addNumericalSeparator(String(input));\n      else if (typeof input === \"bigint\") {\n        if (received = String(input), input > 2n ** 32n || input < -(2n ** 32n))\n          received = addNumericalSeparator(received);\n        received += \"n\";\n      } else\n        received = inspect(input);\n      return `The value of \"${str}\" is out of range. It must be ${range}. Received ${received}`;\n    }, RangeError), E(\"ERR_MULTIPLE_CALLBACK\", \"Callback called multiple times\", Error), E(\"ERR_METHOD_NOT_IMPLEMENTED\", \"The %s method is not implemented\", Error), E(\"ERR_STREAM_ALREADY_FINISHED\", \"Cannot call %s after a stream was finished\", Error), E(\"ERR_STREAM_CANNOT_PIPE\", \"Cannot pipe, not readable\", Error), E(\"ERR_STREAM_DESTROYED\", \"Cannot call %s after a stream was destroyed\", Error), E(\"ERR_STREAM_NULL_VALUES\", \"May not write null values to stream\", TypeError), E(\"ERR_STREAM_PREMATURE_CLOSE\", \"Premature close\", Error), E(\"ERR_STREAM_PUSH_AFTER_EOF\", \"stream.push() after EOF\", Error), E(\"ERR_STREAM_UNSHIFT_AFTER_END_EVENT\", \"stream.unshift() after end event\", Error), E(\"ERR_STREAM_WRITE_AFTER_END\", \"write after end\", Error), E(\"ERR_UNKNOWN_ENCODING\", \"Unknown encoding: %s\", TypeError), module.exports = {\n      AbortError: AbortError2,\n      aggregateTwoErrors: hideStackFrames(aggregateTwoErrors),\n      hideStackFrames,\n      codes\n    };\n  }\n}), require_validators = __commonJS({\n  \"node_modules/readable-stream/lib/internal/validators.js\"(exports, module) {\n    var {\n      ArrayIsArray: ArrayIsArray2,\n      ArrayPrototypeIncludes,\n      ArrayPrototypeJoin,\n      ArrayPrototypeMap,\n      NumberIsInteger,\n      NumberMAX_SAFE_INTEGER,\n      NumberMIN_SAFE_INTEGER,\n      NumberParseInt,\n      RegExpPrototypeTest,\n      String: String2,\n      StringPrototypeToUpperCase,\n      StringPrototypeTrim\n    } = require_primordials(), {\n      hideStackFrames,\n      codes: { ERR_SOCKET_BAD_PORT, ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE2, ERR_INVALID_ARG_VALUE: ERR_INVALID_ARG_VALUE2, ERR_OUT_OF_RANGE, ERR_UNKNOWN_SIGNAL }\n    } = require_errors(), { normalizeEncoding } = require_util(), { isAsyncFunction, isArrayBufferView } = require_util().types, signals = {};\n    function isInt32(value) {\n      return value === (value | 0);\n    }\n    function isUint32(value) {\n      return value === value >>> 0;\n    }\n    var octalReg = /^[0-7]+$/, modeDesc = \"must be a 32-bit unsigned integer or an octal string\";\n    function parseFileMode(value, name, def) {\n      if (typeof value === \"undefined\")\n        value = def;\n      if (typeof value === \"string\") {\n        if (!RegExpPrototypeTest(octalReg, value))\n          throw new ERR_INVALID_ARG_VALUE2(name, value, modeDesc);\n        value = NumberParseInt(value, 8);\n      }\n      return validateInt32(value, name, 0, 4294967295), value;\n    }\n    var validateInteger = hideStackFrames((value, name, min = NumberMIN_SAFE_INTEGER, max = NumberMAX_SAFE_INTEGER) => {\n      if (typeof value !== \"number\")\n        throw new ERR_INVALID_ARG_TYPE2(name, \"number\", value);\n      if (!NumberIsInteger(value))\n        throw new ERR_OUT_OF_RANGE(name, \"an integer\", value);\n      if (value < min || value > max)\n        throw new ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value);\n    }), validateInt32 = hideStackFrames((value, name, min = -2147483648, max = 2147483647) => {\n      if (typeof value !== \"number\")\n        throw new ERR_INVALID_ARG_TYPE2(name, \"number\", value);\n      if (!isInt32(value)) {\n        if (!NumberIsInteger(value))\n          throw new ERR_OUT_OF_RANGE(name, \"an integer\", value);\n        throw new ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value);\n      }\n      if (value < min || value > max)\n        throw new ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value);\n    }), validateUint32 = hideStackFrames((value, name, positive) => {\n      if (typeof value !== \"number\")\n        throw new ERR_INVALID_ARG_TYPE2(name, \"number\", value);\n      if (!isUint32(value)) {\n        if (!NumberIsInteger(value))\n          throw new ERR_OUT_OF_RANGE(name, \"an integer\", value);\n        throw new ERR_OUT_OF_RANGE(name, `>= ${positive \? 1 : 0} && < 4294967296`, value);\n      }\n      if (positive && value === 0)\n        throw new ERR_OUT_OF_RANGE(name, \">= 1 && < 4294967296\", value);\n    });\n    function validateString(value, name) {\n      if (typeof value !== \"string\")\n        throw new ERR_INVALID_ARG_TYPE2(name, \"string\", value);\n    }\n    function validateNumber(value, name) {\n      if (typeof value !== \"number\")\n        throw new ERR_INVALID_ARG_TYPE2(name, \"number\", value);\n    }\n    var validateOneOf = hideStackFrames((value, name, oneOf) => {\n      if (!ArrayPrototypeIncludes(oneOf, value)) {\n        const reason = \"must be one of: \" + ArrayPrototypeJoin(ArrayPrototypeMap(oneOf, (v) => typeof v === \"string\" \? `'${v}'` : String2(v)), \", \");\n        throw new ERR_INVALID_ARG_VALUE2(name, value, reason);\n      }\n    });\n    function validateBoolean2(value, name) {\n      if (typeof value !== \"boolean\")\n        throw new ERR_INVALID_ARG_TYPE2(name, \"boolean\", value);\n    }\n    var validateObject = hideStackFrames((value, name, options) => {\n      const useDefaultOptions = options == null, allowArray = useDefaultOptions \? !1 : options.allowArray, allowFunction = useDefaultOptions \? !1 : options.allowFunction;\n      if (!(useDefaultOptions \? !1 : options.nullable) && value === null || !allowArray && ArrayIsArray2(value) || typeof value !== \"object\" && (!allowFunction || typeof value !== \"function\"))\n        throw new ERR_INVALID_ARG_TYPE2(name, \"Object\", value);\n    }), validateArray = hideStackFrames((value, name, minLength = 0) => {\n      if (!ArrayIsArray2(value))\n        throw new ERR_INVALID_ARG_TYPE2(name, \"Array\", value);\n      if (value.length < minLength) {\n        const reason = `must be longer than ${minLength}`;\n        throw new ERR_INVALID_ARG_VALUE2(name, value, reason);\n      }\n    });\n    function validateSignalName(signal, name = \"signal\") {\n      if (validateString(signal, name), signals[signal] === void 0) {\n        if (signals[StringPrototypeToUpperCase(signal)] !== void 0)\n          throw new ERR_UNKNOWN_SIGNAL(signal + \" (signals must use all capital letters)\");\n        throw new ERR_UNKNOWN_SIGNAL(signal);\n      }\n    }\n    var validateBuffer = hideStackFrames((buffer, name = \"buffer\") => {\n      if (!isArrayBufferView(buffer))\n        throw new ERR_INVALID_ARG_TYPE2(name, [\"Buffer\", \"TypedArray\", \"DataView\"], buffer);\n    });\n    function validateEncoding(data, encoding) {\n      const normalizedEncoding = normalizeEncoding(encoding), length = data.length;\n      if (normalizedEncoding === \"hex\" && length % 2 !== 0)\n        throw new ERR_INVALID_ARG_VALUE2(\"encoding\", encoding, `is invalid for data of length ${length}`);\n    }\n    function validatePort(port, name = \"Port\", allowZero = !0) {\n      if (typeof port !== \"number\" && typeof port !== \"string\" || typeof port === \"string\" && StringPrototypeTrim(port).length === 0 || +port !== +port >>> 0 || port > 65535 || port === 0 && !allowZero)\n        throw new ERR_SOCKET_BAD_PORT(name, port, allowZero);\n      return port | 0;\n    }\n    var validateAbortSignal = hideStackFrames((signal, name) => {\n      if (signal !== void 0 && (signal === null || typeof signal !== \"object\" || !(\"aborted\" in signal)))\n        throw new ERR_INVALID_ARG_TYPE2(name, \"AbortSignal\", signal);\n    }), validateFunction = hideStackFrames((value, name) => {\n      if (typeof value !== \"function\")\n        throw new ERR_INVALID_ARG_TYPE2(name, \"Function\", value);\n    }), validatePlainFunction = hideStackFrames((value, name) => {\n      if (typeof value !== \"function\" || isAsyncFunction(value))\n        throw new ERR_INVALID_ARG_TYPE2(name, \"Function\", value);\n    }), validateUndefined = hideStackFrames((value, name) => {\n      if (value !== void 0)\n        throw new ERR_INVALID_ARG_TYPE2(name, \"undefined\", value);\n    });\n    module.exports = {\n      isInt32,\n      isUint32,\n      parseFileMode,\n      validateArray,\n      validateBoolean: validateBoolean2,\n      validateBuffer,\n      validateEncoding,\n      validateFunction,\n      validateInt32,\n      validateInteger,\n      validateNumber,\n      validateObject,\n      validateOneOf,\n      validatePlainFunction,\n      validatePort,\n      validateSignalName,\n      validateString,\n      validateUint32,\n      validateUndefined,\n      validateAbortSignal\n    };\n  }\n}), require_utils = __commonJS({\n  \"node_modules/readable-stream/lib/internal/streams/utils.js\"(exports, module) {\n    var { Symbol: Symbol2, SymbolAsyncIterator, SymbolIterator } = require_primordials(), kDestroyed = Symbol2(\"kDestroyed\"), kIsErrored = Symbol2(\"kIsErrored\"), kIsReadable = Symbol2(\"kIsReadable\"), kIsDisturbed = Symbol2(\"kIsDisturbed\");\n    function isReadableNodeStream(obj, strict = !1) {\n      var _obj$_readableState;\n      return !!(obj && typeof obj.pipe === \"function\" && typeof obj.on === \"function\" && (!strict || typeof obj.pause === \"function\" && typeof obj.resume === \"function\") && (!obj._writableState || ((_obj$_readableState = obj._readableState) === null || _obj$_readableState === void 0 \? void 0 : _obj$_readableState.readable) !== !1) && (!obj._writableState || obj._readableState));\n    }\n    function isWritableNodeStream(obj) {\n      var _obj$_writableState;\n      return !!(obj && typeof obj.write === \"function\" && typeof obj.on === \"function\" && (!obj._readableState || ((_obj$_writableState = obj._writableState) === null || _obj$_writableState === void 0 \? void 0 : _obj$_writableState.writable) !== !1));\n    }\n    function isDuplexNodeStream(obj) {\n      return !!(obj && typeof obj.pipe === \"function\" && obj._readableState && typeof obj.on === \"function\" && typeof obj.write === \"function\");\n    }\n    function isNodeStream(obj) {\n      return obj && (obj._readableState || obj._writableState || typeof obj.write === \"function\" && typeof obj.on === \"function\" || typeof obj.pipe === \"function\" && typeof obj.on === \"function\");\n    }\n    function isIterable(obj, isAsync) {\n      if (obj == null)\n        return !1;\n      if (isAsync === !0)\n        return typeof obj[SymbolAsyncIterator] === \"function\";\n      if (isAsync === !1)\n        return typeof obj[SymbolIterator] === \"function\";\n      return typeof obj[SymbolAsyncIterator] === \"function\" || typeof obj[SymbolIterator] === \"function\";\n    }\n    function isDestroyed(stream) {\n      if (!isNodeStream(stream))\n        return null;\n      const { _writableState: wState, _readableState: rState } = stream, state = wState || rState;\n      return !!(stream.destroyed || stream[kDestroyed] || state !== null && state !== void 0 && state.destroyed);\n    }\n    function isWritableEnded(stream) {\n      if (!isWritableNodeStream(stream))\n        return null;\n      if (stream.writableEnded === !0)\n        return !0;\n      const wState = stream._writableState;\n      if (wState !== null && wState !== void 0 && wState.errored)\n        return !1;\n      if (typeof (wState === null || wState === void 0 \? void 0 : wState.ended) !== \"boolean\")\n        return null;\n      return wState.ended;\n    }\n    function isWritableFinished(stream, strict) {\n      if (!isWritableNodeStream(stream))\n        return null;\n      if (stream.writableFinished === !0)\n        return !0;\n      const wState = stream._writableState;\n      if (wState !== null && wState !== void 0 && wState.errored)\n        return !1;\n      if (typeof (wState === null || wState === void 0 \? void 0 : wState.finished) !== \"boolean\")\n        return null;\n      return !!(wState.finished || strict === !1 && wState.ended === !0 && wState.length === 0);\n    }\n    function isReadableEnded(stream) {\n      if (!isReadableNodeStream(stream))\n        return null;\n      if (stream.readableEnded === !0)\n        return !0;\n      const rState = stream._readableState;\n      if (!rState || rState.errored)\n        return !1;\n      if (typeof (rState === null || rState === void 0 \? void 0 : rState.ended) !== \"boolean\")\n        return null;\n      return rState.ended;\n    }\n    function isReadableFinished(stream, strict) {\n      if (!isReadableNodeStream(stream))\n        return null;\n      const rState = stream._readableState;\n      if (rState !== null && rState !== void 0 && rState.errored)\n        return !1;\n      if (typeof (rState === null || rState === void 0 \? void 0 : rState.endEmitted) !== \"boolean\")\n        return null;\n      return !!(rState.endEmitted || strict === !1 && rState.ended === !0 && rState.length === 0);\n    }\n    function isReadable(stream) {\n      if (stream && stream[kIsReadable] != null)\n        return stream[kIsReadable];\n      if (typeof (stream === null || stream === void 0 \? void 0 : stream.readable) !== \"boolean\")\n        return null;\n      if (isDestroyed(stream))\n        return !1;\n      return isReadableNodeStream(stream) && stream.readable && !isReadableFinished(stream);\n    }\n    function isWritable(stream) {\n      if (typeof (stream === null || stream === void 0 \? void 0 : stream.writable) !== \"boolean\")\n        return null;\n      if (isDestroyed(stream))\n        return !1;\n      return isWritableNodeStream(stream) && stream.writable && !isWritableEnded(stream);\n    }\n    function isFinished(stream, opts) {\n      if (!isNodeStream(stream))\n        return null;\n      if (isDestroyed(stream))\n        return !0;\n      if ((opts === null || opts === void 0 \? void 0 : opts.readable) !== !1 && isReadable(stream))\n        return !1;\n      if ((opts === null || opts === void 0 \? void 0 : opts.writable) !== !1 && isWritable(stream))\n        return !1;\n      return !0;\n    }\n    function isWritableErrored(stream) {\n      var _stream$_writableStat, _stream$_writableStat2;\n      if (!isNodeStream(stream))\n        return null;\n      if (stream.writableErrored)\n        return stream.writableErrored;\n      return (_stream$_writableStat = (_stream$_writableStat2 = stream._writableState) === null || _stream$_writableStat2 === void 0 \? void 0 : _stream$_writableStat2.errored) !== null && _stream$_writableStat !== void 0 \? _stream$_writableStat : null;\n    }\n    function isReadableErrored(stream) {\n      var _stream$_readableStat, _stream$_readableStat2;\n      if (!isNodeStream(stream))\n        return null;\n      if (stream.readableErrored)\n        return stream.readableErrored;\n      return (_stream$_readableStat = (_stream$_readableStat2 = stream._readableState) === null || _stream$_readableStat2 === void 0 \? void 0 : _stream$_readableStat2.errored) !== null && _stream$_readableStat !== void 0 \? _stream$_readableStat : null;\n    }\n    function isClosed(stream) {\n      if (!isNodeStream(stream))\n        return null;\n      if (typeof stream.closed === \"boolean\")\n        return stream.closed;\n      const { _writableState: wState, _readableState: rState } = stream;\n      if (typeof (wState === null || wState === void 0 \? void 0 : wState.closed) === \"boolean\" || typeof (rState === null || rState === void 0 \? void 0 : rState.closed) === \"boolean\")\n        return (wState === null || wState === void 0 \? void 0 : wState.closed) || (rState === null || rState === void 0 \? void 0 : rState.closed);\n      if (typeof stream._closed === \"boolean\" && isOutgoingMessage(stream))\n        return stream._closed;\n      return null;\n    }\n    function isOutgoingMessage(stream) {\n      return typeof stream._closed === \"boolean\" && typeof stream._defaultKeepAlive === \"boolean\" && typeof stream._removedConnection === \"boolean\" && typeof stream._removedContLen === \"boolean\";\n    }\n    function isServerResponse(stream) {\n      return typeof stream._sent100 === \"boolean\" && isOutgoingMessage(stream);\n    }\n    function isServerRequest(stream) {\n      var _stream$req;\n      return typeof stream._consuming === \"boolean\" && typeof stream._dumped === \"boolean\" && ((_stream$req = stream.req) === null || _stream$req === void 0 \? void 0 : _stream$req.upgradeOrConnect) === void 0;\n    }\n    function willEmitClose(stream) {\n      if (!isNodeStream(stream))\n        return null;\n      const { _writableState: wState, _readableState: rState } = stream, state = wState || rState;\n      return !state && isServerResponse(stream) || !!(state && state.autoDestroy && state.emitClose && state.closed === !1);\n    }\n    function isDisturbed(stream) {\n      var _stream$kIsDisturbed;\n      return !!(stream && ((_stream$kIsDisturbed = stream[kIsDisturbed]) !== null && _stream$kIsDisturbed !== void 0 \? _stream$kIsDisturbed : stream.readableDidRead || stream.readableAborted));\n    }\n    function isErrored(stream) {\n      var _ref, _ref2, _ref3, _ref4, _ref5, _stream$kIsErrored, _stream$_readableStat3, _stream$_writableStat3, _stream$_readableStat4, _stream$_writableStat4;\n      return !!(stream && ((_ref = (_ref2 = (_ref3 = (_ref4 = (_ref5 = (_stream$kIsErrored = stream[kIsErrored]) !== null && _stream$kIsErrored !== void 0 \? _stream$kIsErrored : stream.readableErrored) !== null && _ref5 !== void 0 \? _ref5 : stream.writableErrored) !== null && _ref4 !== void 0 \? _ref4 : (_stream$_readableStat3 = stream._readableState) === null || _stream$_readableStat3 === void 0 \? void 0 : _stream$_readableStat3.errorEmitted) !== null && _ref3 !== void 0 \? _ref3 : (_stream$_writableStat3 = stream._writableState) === null || _stream$_writableStat3 === void 0 \? void 0 : _stream$_writableStat3.errorEmitted) !== null && _ref2 !== void 0 \? _ref2 : (_stream$_readableStat4 = stream._readableState) === null || _stream$_readableStat4 === void 0 \? void 0 : _stream$_readableStat4.errored) !== null && _ref !== void 0 \? _ref : (_stream$_writableStat4 = stream._writableState) === null || _stream$_writableStat4 === void 0 \? void 0 : _stream$_writableStat4.errored));\n    }\n    module.exports = {\n      kDestroyed,\n      isDisturbed,\n      kIsDisturbed,\n      isErrored,\n      kIsErrored,\n      isReadable,\n      kIsReadable,\n      isClosed,\n      isDestroyed,\n      isDuplexNodeStream,\n      isFinished,\n      isIterable,\n      isReadableNodeStream,\n      isReadableEnded,\n      isReadableFinished,\n      isReadableErrored,\n      isNodeStream,\n      isWritable,\n      isWritableNodeStream,\n      isWritableEnded,\n      isWritableFinished,\n      isWritableErrored,\n      isServerRequest,\n      isServerResponse,\n      willEmitClose\n    };\n  }\n}), require_end_of_stream = __commonJS({\n  \"node_modules/readable-stream/lib/internal/streams/end-of-stream.js\"(exports, module) {\n    var { AbortError: AbortError2, codes } = require_errors(), { ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE2, ERR_STREAM_PREMATURE_CLOSE } = codes, { once } = require_util(), { validateAbortSignal, validateFunction, validateObject } = require_validators(), { Promise: Promise2 } = require_primordials(), {\n      isClosed,\n      isReadable,\n      isReadableNodeStream,\n      isReadableFinished,\n      isReadableErrored,\n      isWritable,\n      isWritableNodeStream,\n      isWritableFinished,\n      isWritableErrored,\n      isNodeStream,\n      willEmitClose: _willEmitClose\n    } = require_utils();\n    function isRequest(stream) {\n      return stream.setHeader && typeof stream.abort === \"function\";\n    }\n    var nop = () => {\n    };\n    function eos(stream, options, callback) {\n      var _options$readable, _options$writable;\n      if (arguments.length === 2)\n        callback = options, options = {};\n      else if (options == null)\n        options = {};\n      else\n        validateObject(options, \"options\");\n      validateFunction(callback, \"callback\"), validateAbortSignal(options.signal, \"options.signal\"), callback = once(callback);\n      const readable = (_options$readable = options.readable) !== null && _options$readable !== void 0 \? _options$readable : isReadableNodeStream(stream), writable = (_options$writable = options.writable) !== null && _options$writable !== void 0 \? _options$writable : isWritableNodeStream(stream);\n      if (!isNodeStream(stream))\n        throw new ERR_INVALID_ARG_TYPE2(\"stream\", \"Stream\", stream);\n      const { _writableState: wState, _readableState: rState } = stream, onlegacyfinish = () => {\n        if (!stream.writable)\n          onfinish();\n      };\n      let willEmitClose = _willEmitClose(stream) && isReadableNodeStream(stream) === readable && isWritableNodeStream(stream) === writable, writableFinished = isWritableFinished(stream, !1);\n      const onfinish = () => {\n        if (writableFinished = !0, stream.destroyed)\n          willEmitClose = !1;\n        if (willEmitClose && (!stream.readable || readable))\n          return;\n        if (!readable || readableFinished)\n          callback.call(stream);\n      };\n      let readableFinished = isReadableFinished(stream, !1);\n      const onend = () => {\n        if (readableFinished = !0, stream.destroyed)\n          willEmitClose = !1;\n        if (willEmitClose && (!stream.writable || writable))\n          return;\n        if (!writable || writableFinished)\n          callback.call(stream);\n      }, onerror = (err) => {\n        callback.call(stream, err);\n      };\n      let closed = isClosed(stream);\n      const onclose = () => {\n        closed = !0;\n        const errored = isWritableErrored(stream) || isReadableErrored(stream);\n        if (errored && typeof errored !== \"boolean\")\n          return callback.call(stream, errored);\n        if (readable && !readableFinished && isReadableNodeStream(stream, !0)) {\n          if (!isReadableFinished(stream, !1))\n            return callback.call(stream, new ERR_STREAM_PREMATURE_CLOSE);\n        }\n        if (writable && !writableFinished) {\n          if (!isWritableFinished(stream, !1))\n            return callback.call(stream, new ERR_STREAM_PREMATURE_CLOSE);\n        }\n        callback.call(stream);\n      }, onrequest = () => {\n        stream.req.on(\"finish\", onfinish);\n      };\n      if (isRequest(stream)) {\n        if (stream.on(\"complete\", onfinish), !willEmitClose)\n          stream.on(\"abort\", onclose);\n        if (stream.req)\n          onrequest();\n        else\n          stream.on(\"request\", onrequest);\n      } else if (writable && !wState)\n        stream.on(\"end\", onlegacyfinish), stream.on(\"close\", onlegacyfinish);\n      if (!willEmitClose && typeof stream.aborted === \"boolean\")\n        stream.on(\"aborted\", onclose);\n      if (stream.on(\"end\", onend), stream.on(\"finish\", onfinish), options.error !== !1)\n        stream.on(\"error\", onerror);\n      if (stream.on(\"close\", onclose), closed)\n        runOnNextTick(onclose);\n      else if (wState !== null && wState !== void 0 && wState.errorEmitted || rState !== null && rState !== void 0 && rState.errorEmitted) {\n        if (!willEmitClose)\n          runOnNextTick(onclose);\n      } else if (!readable && (!willEmitClose || isReadable(stream)) && (writableFinished || isWritable(stream) === !1))\n        runOnNextTick(onclose);\n      else if (!writable && (!willEmitClose || isWritable(stream)) && (readableFinished || isReadable(stream) === !1))\n        runOnNextTick(onclose);\n      else if (rState && stream.req && stream.aborted)\n        runOnNextTick(onclose);\n      const cleanup = () => {\n        if (callback = nop, stream.removeListener(\"aborted\", onclose), stream.removeListener(\"complete\", onfinish), stream.removeListener(\"abort\", onclose), stream.removeListener(\"request\", onrequest), stream.req)\n          stream.req.removeListener(\"finish\", onfinish);\n        stream.removeListener(\"end\", onlegacyfinish), stream.removeListener(\"close\", onlegacyfinish), stream.removeListener(\"finish\", onfinish), stream.removeListener(\"end\", onend), stream.removeListener(\"error\", onerror), stream.removeListener(\"close\", onclose);\n      };\n      if (options.signal && !closed) {\n        const abort = () => {\n          const endCallback = callback;\n          cleanup(), endCallback.call(stream, new AbortError2(void 0, {\n            cause: options.signal.reason\n          }));\n        };\n        if (options.signal.aborted)\n          runOnNextTick(abort);\n        else {\n          const originalCallback = callback;\n          callback = once((...args) => {\n            options.signal.removeEventListener(\"abort\", abort), originalCallback.apply(stream, args);\n          }), options.signal.addEventListener(\"abort\", abort);\n        }\n      }\n      return cleanup;\n    }\n    function finished2(stream, opts) {\n      return new Promise2((resolve, reject) => {\n        eos(stream, opts, (err) => {\n          if (err)\n            reject(err);\n          else\n            resolve();\n        });\n      });\n    }\n    module.exports = eos, module.exports.finished = finished2;\n  }\n}), require_operators = __commonJS({\n  \"node_modules/readable-stream/lib/internal/streams/operators.js\"(exports, module) {\n    var {\n      codes: { ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE2, ERR_MISSING_ARGS, ERR_OUT_OF_RANGE },\n      AbortError: AbortError2\n    } = require_errors(), { validateAbortSignal, validateInteger, validateObject } = require_validators(), kWeakHandler = require_primordials().Symbol(\"kWeak\"), { finished: finished2 } = require_end_of_stream(), {\n      ArrayPrototypePush,\n      MathFloor,\n      Number: Number2,\n      NumberIsNaN,\n      Promise: Promise2,\n      PromiseReject,\n      PromisePrototypeCatch,\n      Symbol: Symbol2\n    } = require_primordials(), kEmpty = Symbol2(\"kEmpty\"), kEof = Symbol2(\"kEof\");\n    function map(fn, options) {\n      if (typeof fn !== \"function\")\n        throw new ERR_INVALID_ARG_TYPE2(\"fn\", [\"Function\", \"AsyncFunction\"], fn);\n      if (options != null)\n        validateObject(options, \"options\");\n      if ((options === null || options === void 0 \? void 0 : options.signal) != null)\n        validateAbortSignal(options.signal, \"options.signal\");\n      let concurrency = 1;\n      if ((options === null || options === void 0 \? void 0 : options.concurrency) != null)\n        concurrency = MathFloor(options.concurrency);\n      return validateInteger(concurrency, \"concurrency\", 1), async function* map2() {\n        var _options$signal, _options$signal2;\n        const ac = new AbortController, stream = this, queue = [], signal = ac.signal, signalOpt = {\n          signal\n        }, abort = () => ac.abort();\n        if (options !== null && options !== void 0 && (_options$signal = options.signal) !== null && _options$signal !== void 0 && _options$signal.aborted)\n          abort();\n        options === null || options === void 0 || (_options$signal2 = options.signal) === null || _options$signal2 === void 0 || _options$signal2.addEventListener(\"abort\", abort);\n        let next, resume, done = !1;\n        function onDone() {\n          done = !0;\n        }\n        async function pump() {\n          try {\n            for await (let val of stream) {\n              var _val;\n              if (done)\n                return;\n              if (signal.aborted)\n                throw new AbortError2;\n              try {\n                val = fn(val, signalOpt);\n              } catch (err) {\n                val = PromiseReject(err);\n              }\n              if (val === kEmpty)\n                continue;\n              if (typeof ((_val = val) === null || _val === void 0 \? void 0 : _val.catch) === \"function\")\n                val.catch(onDone);\n              if (queue.push(val), next)\n                next(), next = null;\n              if (!done && queue.length && queue.length >= concurrency)\n                await new Promise2((resolve) => {\n                  resume = resolve;\n                });\n            }\n            queue.push(kEof);\n          } catch (err) {\n            const val = PromiseReject(err);\n            PromisePrototypeCatch(val, onDone), queue.push(val);\n          } finally {\n            var _options$signal3;\n            if (done = !0, next)\n              next(), next = null;\n            options === null || options === void 0 || (_options$signal3 = options.signal) === null || _options$signal3 === void 0 || _options$signal3.removeEventListener(\"abort\", abort);\n          }\n        }\n        pump();\n        try {\n          while (!0) {\n            while (queue.length > 0) {\n              const val = await queue[0];\n              if (val === kEof)\n                return;\n              if (signal.aborted)\n                throw new AbortError2;\n              if (val !== kEmpty)\n                yield val;\n              if (queue.shift(), resume)\n                resume(), resume = null;\n            }\n            await new Promise2((resolve) => {\n              next = resolve;\n            });\n          }\n        } finally {\n          if (ac.abort(), done = !0, resume)\n            resume(), resume = null;\n        }\n      }.call(this);\n    }\n    function asIndexedPairs(options = void 0) {\n      if (options != null)\n        validateObject(options, \"options\");\n      if ((options === null || options === void 0 \? void 0 : options.signal) != null)\n        validateAbortSignal(options.signal, \"options.signal\");\n      return async function* asIndexedPairs2() {\n        let index = 0;\n        for await (let val of this) {\n          var _options$signal4;\n          if (options !== null && options !== void 0 && (_options$signal4 = options.signal) !== null && _options$signal4 !== void 0 && _options$signal4.aborted)\n            throw new AbortError2({\n              cause: options.signal.reason\n            });\n          yield [index++, val];\n        }\n      }.call(this);\n    }\n    async function some(fn, options = void 0) {\n      for await (let unused of filter.call(this, fn, options))\n        return !0;\n      return !1;\n    }\n    async function every(fn, options = void 0) {\n      if (typeof fn !== \"function\")\n        throw new ERR_INVALID_ARG_TYPE2(\"fn\", [\"Function\", \"AsyncFunction\"], fn);\n      return !await some.call(this, async (...args) => {\n        return !await fn(...args);\n      }, options);\n    }\n    async function find(fn, options) {\n      for await (let result of filter.call(this, fn, options))\n        return result;\n      return;\n    }\n    async function forEach(fn, options) {\n      if (typeof fn !== \"function\")\n        throw new ERR_INVALID_ARG_TYPE2(\"fn\", [\"Function\", \"AsyncFunction\"], fn);\n      async function forEachFn(value, options2) {\n        return await fn(value, options2), kEmpty;\n      }\n      for await (let unused of map.call(this, forEachFn, options))\n        ;\n    }\n    function filter(fn, options) {\n      if (typeof fn !== \"function\")\n        throw new ERR_INVALID_ARG_TYPE2(\"fn\", [\"Function\", \"AsyncFunction\"], fn);\n      async function filterFn(value, options2) {\n        if (await fn(value, options2))\n          return value;\n        return kEmpty;\n      }\n      return map.call(this, filterFn, options);\n    }\n    var ReduceAwareErrMissingArgs = class extends ERR_MISSING_ARGS {\n      constructor() {\n        super(\"reduce\");\n        this.message = \"Reduce of an empty stream requires an initial value\";\n      }\n    };\n    async function reduce(reducer, initialValue, options) {\n      var _options$signal5;\n      if (typeof reducer !== \"function\")\n        throw new ERR_INVALID_ARG_TYPE2(\"reducer\", [\"Function\", \"AsyncFunction\"], reducer);\n      if (options != null)\n        validateObject(options, \"options\");\n      if ((options === null || options === void 0 \? void 0 : options.signal) != null)\n        validateAbortSignal(options.signal, \"options.signal\");\n      let hasInitialValue = arguments.length > 1;\n      if (options !== null && options !== void 0 && (_options$signal5 = options.signal) !== null && _options$signal5 !== void 0 && _options$signal5.aborted) {\n        const err = new AbortError2(void 0, {\n          cause: options.signal.reason\n        });\n        throw this.once(\"error\", () => {\n        }), await finished2(this.destroy(err)), err;\n      }\n      const ac = new AbortController, signal = ac.signal;\n      if (options !== null && options !== void 0 && options.signal) {\n        const opts = {\n          once: !0,\n          [kWeakHandler]: this\n        };\n        options.signal.addEventListener(\"abort\", () => ac.abort(), opts);\n      }\n      let gotAnyItemFromStream = !1;\n      try {\n        for await (let value of this) {\n          var _options$signal6;\n          if (gotAnyItemFromStream = !0, options !== null && options !== void 0 && (_options$signal6 = options.signal) !== null && _options$signal6 !== void 0 && _options$signal6.aborted)\n            throw new AbortError2;\n          if (!hasInitialValue)\n            initialValue = value, hasInitialValue = !0;\n          else\n            initialValue = await reducer(initialValue, value, {\n              signal\n            });\n        }\n        if (!gotAnyItemFromStream && !hasInitialValue)\n          throw new ReduceAwareErrMissingArgs;\n      } finally {\n        ac.abort();\n      }\n      return initialValue;\n    }\n    async function toArray(options) {\n      if (options != null)\n        validateObject(options, \"options\");\n      if ((options === null || options === void 0 \? void 0 : options.signal) != null)\n        validateAbortSignal(options.signal, \"options.signal\");\n      const result = [];\n      for await (let val of this) {\n        var _options$signal7;\n        if (options !== null && options !== void 0 && (_options$signal7 = options.signal) !== null && _options$signal7 !== void 0 && _options$signal7.aborted)\n          throw new AbortError2(void 0, {\n            cause: options.signal.reason\n          });\n        ArrayPrototypePush(result, val);\n      }\n      return result;\n    }\n    function flatMap(fn, options) {\n      const values = map.call(this, fn, options);\n      return async function* flatMap2() {\n        for await (let val of values)\n          yield* val;\n      }.call(this);\n    }\n    function toIntegerOrInfinity(number) {\n      if (number = Number2(number), NumberIsNaN(number))\n        return 0;\n      if (number < 0)\n        throw new ERR_OUT_OF_RANGE(\"number\", \">= 0\", number);\n      return number;\n    }\n    function drop(number, options = void 0) {\n      if (options != null)\n        validateObject(options, \"options\");\n      if ((options === null || options === void 0 \? void 0 : options.signal) != null)\n        validateAbortSignal(options.signal, \"options.signal\");\n      return number = toIntegerOrInfinity(number), async function* drop2() {\n        var _options$signal8;\n        if (options !== null && options !== void 0 && (_options$signal8 = options.signal) !== null && _options$signal8 !== void 0 && _options$signal8.aborted)\n          throw new AbortError2;\n        for await (let val of this) {\n          var _options$signal9;\n          if (options !== null && options !== void 0 && (_options$signal9 = options.signal) !== null && _options$signal9 !== void 0 && _options$signal9.aborted)\n            throw new AbortError2;\n          if (number-- <= 0)\n            yield val;\n        }\n      }.call(this);\n    }\n    function take(number, options = void 0) {\n      if (options != null)\n        validateObject(options, \"options\");\n      if ((options === null || options === void 0 \? void 0 : options.signal) != null)\n        validateAbortSignal(options.signal, \"options.signal\");\n      return number = toIntegerOrInfinity(number), async function* take2() {\n        var _options$signal10;\n        if (options !== null && options !== void 0 && (_options$signal10 = options.signal) !== null && _options$signal10 !== void 0 && _options$signal10.aborted)\n          throw new AbortError2;\n        for await (let val of this) {\n          var _options$signal11;\n          if (options !== null && options !== void 0 && (_options$signal11 = options.signal) !== null && _options$signal11 !== void 0 && _options$signal11.aborted)\n            throw new AbortError2;\n          if (number-- > 0)\n            yield val;\n          else\n            return;\n        }\n      }.call(this);\n    }\n    module.exports.streamReturningOperators = {\n      asIndexedPairs,\n      drop,\n      filter,\n      flatMap,\n      map,\n      take\n    }, module.exports.promiseReturningOperators = {\n      every,\n      forEach,\n      reduce,\n      toArray,\n      some,\n      find\n    };\n  }\n}), require_destroy = __commonJS({\n  \"node_modules/readable-stream/lib/internal/streams/destroy.js\"(exports, module) {\n    var {\n      aggregateTwoErrors,\n      codes: { ERR_MULTIPLE_CALLBACK },\n      AbortError: AbortError2\n    } = require_errors(), { Symbol: Symbol2 } = require_primordials(), { kDestroyed, isDestroyed, isFinished, isServerRequest } = require_utils(), kDestroy = \"#kDestroy\", kConstruct = \"#kConstruct\";\n    function checkError(err, w, r) {\n      if (err) {\n        if (err.stack, w && !w.errored)\n          w.errored = err;\n        if (r && !r.errored)\n          r.errored = err;\n      }\n    }\n    function destroy2(err, cb) {\n      const r = this._readableState, w = this._writableState, s = w || r;\n      if (w && w.destroyed || r && r.destroyed) {\n        if (typeof cb === \"function\")\n          cb();\n        return this;\n      }\n      if (checkError(err, w, r), w)\n        w.destroyed = !0;\n      if (r)\n        r.destroyed = !0;\n      if (!s.constructed)\n        this.once(kDestroy, (er) => {\n          _destroy(this, aggregateTwoErrors(er, err), cb);\n        });\n      else\n        _destroy(this, err, cb);\n      return this;\n    }\n    function _destroy(self, err, cb) {\n      let called = !1;\n      function onDestroy(err2) {\n        if (called)\n          return;\n        called = !0;\n        const { _readableState: r, _writableState: w } = self;\n        if (checkError(err2, w, r), w)\n          w.closed = !0;\n        if (r)\n          r.closed = !0;\n        if (typeof cb === \"function\")\n          cb(err2);\n        if (err2)\n          runOnNextTick(emitErrorCloseNT, self, err2);\n        else\n          runOnNextTick(emitCloseNT, self);\n      }\n      try {\n        self._destroy(err || null, onDestroy);\n      } catch (err2) {\n        onDestroy(err2);\n      }\n    }\n    function emitErrorCloseNT(self, err) {\n      emitErrorNT(self, err), emitCloseNT(self);\n    }\n    function emitCloseNT(self) {\n      const { _readableState: r, _writableState: w } = self;\n      if (w)\n        w.closeEmitted = !0;\n      if (r)\n        r.closeEmitted = !0;\n      if (w && w.emitClose || r && r.emitClose)\n        self.emit(\"close\");\n    }\n    function emitErrorNT(self, err) {\n      const r = self\?._readableState, w = self\?._writableState;\n      if (w\?.errorEmitted || r\?.errorEmitted)\n        return;\n      if (w)\n        w.errorEmitted = !0;\n      if (r)\n        r.errorEmitted = !0;\n      self\?.emit\?.(\"error\", err);\n    }\n    function undestroy() {\n      const r = this._readableState, w = this._writableState;\n      if (r)\n        r.constructed = !0, r.closed = !1, r.closeEmitted = !1, r.destroyed = !1, r.errored = null, r.errorEmitted = !1, r.reading = !1, r.ended = r.readable === !1, r.endEmitted = r.readable === !1;\n      if (w)\n        w.constructed = !0, w.destroyed = !1, w.closed = !1, w.closeEmitted = !1, w.errored = null, w.errorEmitted = !1, w.finalCalled = !1, w.prefinished = !1, w.ended = w.writable === !1, w.ending = w.writable === !1, w.finished = w.writable === !1;\n    }\n    function errorOrDestroy2(stream, err, sync) {\n      const r = stream\?._readableState, w = stream\?._writableState;\n      if (w && w.destroyed || r && r.destroyed)\n        return this;\n      if (r && r.autoDestroy || w && w.autoDestroy)\n        stream.destroy(err);\n      else if (err) {\n        if (Error.captureStackTrace(err), w && !w.errored)\n          w.errored = err;\n        if (r && !r.errored)\n          r.errored = err;\n        if (sync)\n          runOnNextTick(emitErrorNT, stream, err);\n        else\n          emitErrorNT(stream, err);\n      }\n    }\n    function construct(stream, cb) {\n      if (typeof stream._construct !== \"function\")\n        return;\n      const { _readableState: r, _writableState: w } = stream;\n      if (r)\n        r.constructed = !1;\n      if (w)\n        w.constructed = !1;\n      if (stream.once(kConstruct, cb), stream.listenerCount(kConstruct) > 1)\n        return;\n      runOnNextTick(constructNT, stream);\n    }\n    function constructNT(stream) {\n      let called = !1;\n      function onConstruct(err) {\n        if (called) {\n          errorOrDestroy2(stream, err !== null && err !== void 0 \? err : new ERR_MULTIPLE_CALLBACK);\n          return;\n        }\n        called = !0;\n        const { _readableState: r, _writableState: w } = stream, s = w || r;\n        if (r)\n          r.constructed = !0;\n        if (w)\n          w.constructed = !0;\n        if (s.destroyed)\n          stream.emit(kDestroy, err);\n        else if (err)\n          errorOrDestroy2(stream, err, !0);\n        else\n          runOnNextTick(emitConstructNT, stream);\n      }\n      try {\n        stream._construct(onConstruct);\n      } catch (err) {\n        onConstruct(err);\n      }\n    }\n    function emitConstructNT(stream) {\n      stream.emit(kConstruct);\n    }\n    function isRequest(stream) {\n      return stream && stream.setHeader && typeof stream.abort === \"function\";\n    }\n    function emitCloseLegacy(stream) {\n      stream.emit(\"close\");\n    }\n    function emitErrorCloseLegacy(stream, err) {\n      stream.emit(\"error\", err), runOnNextTick(emitCloseLegacy, stream);\n    }\n    function destroyer(stream, err) {\n      if (!stream || isDestroyed(stream))\n        return;\n      if (!err && !isFinished(stream))\n        err = new AbortError2;\n      if (isServerRequest(stream))\n        stream.socket = null, stream.destroy(err);\n      else if (isRequest(stream))\n        stream.abort();\n      else if (isRequest(stream.req))\n        stream.req.abort();\n      else if (typeof stream.destroy === \"function\")\n        stream.destroy(err);\n      else if (typeof stream.close === \"function\")\n        stream.close();\n      else if (err)\n        runOnNextTick(emitErrorCloseLegacy, stream);\n      else\n        runOnNextTick(emitCloseLegacy, stream);\n      if (!stream.destroyed)\n        stream[kDestroyed] = !0;\n    }\n    module.exports = {\n      construct,\n      destroyer,\n      destroy: destroy2,\n      undestroy,\n      errorOrDestroy: errorOrDestroy2\n    };\n  }\n}), require_legacy = __commonJS({\n  \"node_modules/readable-stream/lib/internal/streams/legacy.js\"(exports, module) {\n    var { ArrayIsArray: ArrayIsArray2, ObjectSetPrototypeOf } = require_primordials();\n    function Stream(options) {\n      if (!(this instanceof Stream))\n        return new Stream(options);\n      EE.call(this, options);\n    }\n    Stream.prototype = {}, ObjectSetPrototypeOf(Stream.prototype, EE.prototype), ObjectSetPrototypeOf(Stream, EE), Stream.prototype.pipe = function(dest, options) {\n      const source = this;\n      function ondata(chunk) {\n        if (dest.writable && dest.write(chunk) === !1 && source.pause)\n          source.pause();\n      }\n      source.on(\"data\", ondata);\n      function ondrain() {\n        if (source.readable && source.resume)\n          source.resume();\n      }\n      if (dest.on(\"drain\", ondrain), !dest._isStdio && (!options || options.end !== !1))\n        source.on(\"end\", onend), source.on(\"close\", onclose);\n      let didOnEnd = !1;\n      function onend() {\n        if (didOnEnd)\n          return;\n        didOnEnd = !0, dest.end();\n      }\n      function onclose() {\n        if (didOnEnd)\n          return;\n        if (didOnEnd = !0, typeof dest.destroy === \"function\")\n          dest.destroy();\n      }\n      function onerror(er) {\n        if (cleanup(), EE.listenerCount(this, \"error\") === 0)\n          this.emit(\"error\", er);\n      }\n      prependListener(source, \"error\", onerror), prependListener(dest, \"error\", onerror);\n      function cleanup() {\n        source.removeListener(\"data\", ondata), dest.removeListener(\"drain\", ondrain), source.removeListener(\"end\", onend), source.removeListener(\"close\", onclose), source.removeListener(\"error\", onerror), dest.removeListener(\"error\", onerror), source.removeListener(\"end\", cleanup), source.removeListener(\"close\", cleanup), dest.removeListener(\"close\", cleanup);\n      }\n      return source.on(\"end\", cleanup), source.on(\"close\", cleanup), dest.on(\"close\", cleanup), dest.emit(\"pipe\", source), dest;\n    };\n    function prependListener(emitter, event, fn) {\n      if (typeof emitter.prependListener === \"function\")\n        return emitter.prependListener(event, fn);\n      if (!emitter._events || !emitter._events[event])\n        emitter.on(event, fn);\n      else if (ArrayIsArray2(emitter._events[event]))\n        emitter._events[event].unshift(fn);\n      else\n        emitter._events[event] = [fn, emitter._events[event]];\n    }\n    module.exports = {\n      Stream,\n      prependListener\n    };\n  }\n}), require_add_abort_signal = __commonJS({\n  \"node_modules/readable-stream/lib/internal/streams/add-abort-signal.js\"(exports, module) {\n    var { AbortError: AbortError2, codes } = require_errors(), eos = require_end_of_stream(), { ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE2 } = codes, validateAbortSignal = (signal, name) => {\n      if (typeof signal !== \"object\" || !(\"aborted\" in signal))\n        throw new ERR_INVALID_ARG_TYPE2(name, \"AbortSignal\", signal);\n    };\n    function isNodeStream(obj) {\n      return !!(obj && typeof obj.pipe === \"function\");\n    }\n    module.exports.addAbortSignal = function addAbortSignal(signal, stream) {\n      if (validateAbortSignal(signal, \"signal\"), !isNodeStream(stream))\n        throw new ERR_INVALID_ARG_TYPE2(\"stream\", \"stream.Stream\", stream);\n      return module.exports.addAbortSignalNoValidate(signal, stream);\n    }, module.exports.addAbortSignalNoValidate = function(signal, stream) {\n      if (typeof signal !== \"object\" || !(\"aborted\" in signal))\n        return stream;\n      const onAbort = () => {\n        stream.destroy(new AbortError2(void 0, {\n          cause: signal.reason\n        }));\n      };\n      if (signal.aborted)\n        onAbort();\n      else\n        signal.addEventListener(\"abort\", onAbort), eos(stream, () => signal.removeEventListener(\"abort\", onAbort));\n      return stream;\n    };\n  }\n}), require_state = __commonJS({\n  \"node_modules/readable-stream/lib/internal/streams/state.js\"(exports, module) {\n    var { MathFloor, NumberIsInteger } = require_primordials(), { ERR_INVALID_ARG_VALUE: ERR_INVALID_ARG_VALUE2 } = require_errors().codes;\n    function highWaterMarkFrom(options, isDuplex, duplexKey) {\n      return options.highWaterMark != null \? options.highWaterMark : isDuplex \? options[duplexKey] : null;\n    }\n    function getDefaultHighWaterMark(objectMode) {\n      return objectMode \? 16 : 16384;\n    }\n    function getHighWaterMark(state, options, duplexKey, isDuplex) {\n      const hwm = highWaterMarkFrom(options, isDuplex, duplexKey);\n      if (hwm != null) {\n        if (!NumberIsInteger(hwm) || hwm < 0) {\n          const name = isDuplex \? `options.${duplexKey}` : \"options.highWaterMark\";\n          throw new ERR_INVALID_ARG_VALUE2(name, hwm);\n        }\n        return MathFloor(hwm);\n      }\n      return getDefaultHighWaterMark(state.objectMode);\n    }\n    module.exports = {\n      getHighWaterMark,\n      getDefaultHighWaterMark\n    };\n  }\n}), require_from = __commonJS({\n  \"node_modules/readable-stream/lib/internal/streams/from.js\"(exports, module) {\n    var { PromisePrototypeThen, SymbolAsyncIterator, SymbolIterator } = require_primordials(), { ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE2, ERR_STREAM_NULL_VALUES } = require_errors().codes;\n    function from(Readable, iterable, opts) {\n      let iterator;\n      if (typeof iterable === \"string\" || iterable instanceof Buffer)\n        return new Readable({\n          objectMode: !0,\n          ...opts,\n          read() {\n            this.push(iterable), this.push(null);\n          }\n        });\n      let isAsync;\n      if (iterable && iterable[SymbolAsyncIterator])\n        isAsync = !0, iterator = iterable[SymbolAsyncIterator]();\n      else if (iterable && iterable[SymbolIterator])\n        isAsync = !1, iterator = iterable[SymbolIterator]();\n      else\n        throw new ERR_INVALID_ARG_TYPE2(\"iterable\", [\"Iterable\"], iterable);\n      const readable = new Readable({\n        objectMode: !0,\n        highWaterMark: 1,\n        ...opts\n      });\n      let reading = !1;\n      readable._read = function() {\n        if (!reading)\n          reading = !0, next();\n      }, readable._destroy = function(error, cb) {\n        PromisePrototypeThen(close(error), () => runOnNextTick(cb, error), (e) => runOnNextTick(cb, e || error));\n      };\n      async function close(error) {\n        const hadError = error !== void 0 && error !== null, hasThrow = typeof iterator.throw === \"function\";\n        if (hadError && hasThrow) {\n          const { value, done } = await iterator.throw(error);\n          if (await value, done)\n            return;\n        }\n        if (typeof iterator.return === \"function\") {\n          const { value } = await iterator.return();\n          await value;\n        }\n      }\n      async function next() {\n        for (;; ) {\n          try {\n            const { value, done } = isAsync \? await iterator.next() : iterator.next();\n            if (done)\n              readable.push(null);\n            else {\n              const res = value && typeof value.then === \"function\" \? await value : value;\n              if (res === null)\n                throw reading = !1, new ERR_STREAM_NULL_VALUES;\n              else if (readable.push(res))\n                continue;\n              else\n                reading = !1;\n            }\n          } catch (err) {\n            readable.destroy(err);\n          }\n          break;\n        }\n      }\n      return readable;\n    }\n    module.exports = from;\n  }\n}), _ReadableFromWeb, _ReadableFromWebForUndici, require_readable = __commonJS({\n  \"node_modules/readable-stream/lib/internal/streams/readable.js\"(exports, module) {\n    var {\n      ArrayPrototypeIndexOf,\n      NumberIsInteger,\n      NumberIsNaN,\n      NumberParseInt,\n      ObjectDefineProperties,\n      ObjectKeys,\n      ObjectSetPrototypeOf,\n      Promise: Promise2,\n      SafeSet,\n      SymbolAsyncIterator,\n      Symbol: Symbol2\n    } = require_primordials(), ReadableState = globalThis[globalThis.Symbol.for('Bun.lazy')](\"bun:stream\").ReadableState, { Stream, prependListener } = require_legacy();\n    function Readable(options) {\n      if (!(this instanceof Readable))\n        return new Readable(options);\n      const isDuplex = this instanceof require_duplex();\n      if (this._readableState = new ReadableState(options, this, isDuplex), options) {\n        const { read, destroy: destroy2, construct, signal } = options;\n        if (typeof read === \"function\")\n          this._read = read;\n        if (typeof destroy2 === \"function\")\n          this._destroy = destroy2;\n        if (typeof construct === \"function\")\n          this._construct = construct;\n        if (signal && !isDuplex)\n          addAbortSignal(signal, this);\n      }\n      Stream.call(this, options), destroyImpl.construct(this, () => {\n        if (this._readableState.needReadable)\n          maybeReadMore(this, this._readableState);\n      });\n    }\n    Readable.prototype = {}, ObjectSetPrototypeOf(Readable.prototype, Stream.prototype), ObjectSetPrototypeOf(Readable, Stream), Readable.prototype.on = function(ev, fn) {\n      const res = Stream.prototype.on.call(this, ev, fn), state = this._readableState;\n      if (ev === \"data\") {\n        if (state.readableListening = this.listenerCount(\"readable\") > 0, state.flowing !== !1)\n          this.resume();\n      } else if (ev === \"readable\") {\n        if (!state.endEmitted && !state.readableListening) {\n          if (state.readableListening = state.needReadable = !0, state.flowing = !1, state.emittedReadable = !1, state.length)\n            emitReadable(this, state);\n          else if (!state.reading)\n            runOnNextTick(nReadingNextTick, this);\n        } else if (state.endEmitted)\n          ;\n      }\n      return res;\n    };\n\n    class ReadableFromWeb extends Readable {\n      #reader;\n      #closed;\n      #pendingChunks;\n      #stream;\n      constructor(options, stream) {\n        const { objectMode, highWaterMark, encoding, signal } = options;\n        super({\n          objectMode,\n          highWaterMark,\n          encoding,\n          signal\n        });\n        this.#pendingChunks = [], this.#reader = void 0, this.#stream = stream, this.#closed = !1;\n      }\n      #drainPending() {\n        var pendingChunks = this.#pendingChunks, pendingChunksI = 0, pendingChunksCount = pendingChunks.length;\n        for (;pendingChunksI < pendingChunksCount; pendingChunksI++) {\n          const chunk = pendingChunks[pendingChunksI];\n          if (pendingChunks[pendingChunksI] = void 0, !this.push(chunk, void 0))\n            return this.#pendingChunks = pendingChunks.slice(pendingChunksI + 1), !0;\n        }\n        if (pendingChunksCount > 0)\n          this.#pendingChunks = [];\n        return !1;\n      }\n      #handleDone(reader) {\n        reader.releaseLock(), this.#reader = void 0, this.#closed = !0, this.push(null);\n        return;\n      }\n      async _read() {\n        var stream = this.#stream, reader = this.#reader;\n        if (stream)\n          reader = this.#reader = stream.getReader(), this.#stream = void 0;\n        else if (this.#drainPending())\n          return;\n        var deferredError;\n        try {\n          do {\n            var done = !1, value;\n            const firstResult = reader.readMany();\n            if (@isPromise(firstResult)) {\n              if ({ done, value } = await firstResult, this.#closed) {\n                this.#pendingChunks.push(...value);\n                return;\n              }\n            } else\n              ({ done, value } = firstResult);\n            if (done) {\n              this.#handleDone(reader);\n              return;\n            }\n            if (!this.push(value[0])) {\n              this.#pendingChunks = value.slice(1);\n              return;\n            }\n            for (let i = 1, count = value.length;i < count; i++)\n              if (!this.push(value[i])) {\n                this.#pendingChunks = value.slice(i + 1);\n                return;\n              }\n          } while (!this.#closed);\n        } catch (e) {\n          deferredError = e;\n        } finally {\n          if (deferredError)\n            throw deferredError;\n        }\n      }\n      _destroy(error, callback) {\n        if (!this.#closed) {\n          var reader = this.#reader;\n          if (reader)\n            this.#reader = void 0, reader.cancel(error).finally(() => {\n              this.#closed = !0, callback(error);\n            });\n          return;\n        }\n        try {\n          callback(error);\n        } catch (error2) {\n          globalThis.reportError(error2);\n        }\n      }\n    }\n    _ReadableFromWebForUndici = ReadableFromWeb;\n    function newStreamReadableFromReadableStream(readableStream, options = {}) {\n      if (!isReadableStream(readableStream))\n        throw new ERR_INVALID_ARG_TYPE2(\"readableStream\", \"ReadableStream\", readableStream);\n      validateObject(options, \"options\");\n      const {\n        highWaterMark,\n        encoding,\n        objectMode = !1,\n        signal\n      } = options;\n      if (encoding !== void 0 && !Buffer.isEncoding(encoding))\n        throw new ERR_INVALID_ARG_VALUE(encoding, \"options.encoding\");\n      return validateBoolean(objectMode, \"options.objectMode\"), getNativeReadableStream(Readable, readableStream, options) || new ReadableFromWeb({\n        highWaterMark,\n        encoding,\n        objectMode,\n        signal\n      }, readableStream);\n    }\n    module.exports = Readable, _ReadableFromWeb = newStreamReadableFromReadableStream;\n    var { addAbortSignal } = require_add_abort_signal(), eos = require_end_of_stream();\n    const { maybeReadMore: _maybeReadMore, resume, emitReadable: _emitReadable, onEofChunk } = globalThis[globalThis.Symbol.for('Bun.lazy')](\"bun:stream\");\n    function maybeReadMore(stream, state) {\n      process.nextTick(_maybeReadMore, stream, state);\n    }\n    function emitReadable(stream, state) {\n      _emitReadable(stream, state);\n    }\n    var destroyImpl = require_destroy(), {\n      aggregateTwoErrors,\n      codes: {\n        ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE2,\n        ERR_METHOD_NOT_IMPLEMENTED,\n        ERR_OUT_OF_RANGE,\n        ERR_STREAM_PUSH_AFTER_EOF,\n        ERR_STREAM_UNSHIFT_AFTER_END_EVENT\n      }\n    } = require_errors(), { validateObject } = require_validators(), from = require_from(), nop = () => {\n    }, { errorOrDestroy: errorOrDestroy2 } = destroyImpl;\n    Readable.prototype.destroy = destroyImpl.destroy, Readable.prototype._undestroy = destroyImpl.undestroy, Readable.prototype._destroy = function(err, cb) {\n      cb(err);\n    }, Readable.prototype[EE.captureRejectionSymbol] = function(err) {\n      this.destroy(err);\n    }, Readable.prototype.push = function(chunk, encoding) {\n      return readableAddChunk(this, chunk, encoding, !1);\n    }, Readable.prototype.unshift = function(chunk, encoding) {\n      return readableAddChunk(this, chunk, encoding, !0);\n    };\n    function readableAddChunk(stream, chunk, encoding, addToFront) {\n      const state = stream._readableState;\n      let err;\n      if (!state.objectMode) {\n        if (typeof chunk === \"string\") {\n          if (encoding = encoding || state.defaultEncoding, state.encoding !== encoding)\n            if (addToFront && state.encoding)\n              chunk = Buffer.from(chunk, encoding).toString(state.encoding);\n            else\n              chunk = Buffer.from(chunk, encoding), encoding = \"\";\n        } else if (chunk instanceof Buffer)\n          encoding = \"\";\n        else if (Stream._isUint8Array(chunk)) {\n          if (addToFront || !state.decoder)\n            chunk = Stream._uint8ArrayToBuffer(chunk);\n          encoding = \"\";\n        } else if (chunk != null)\n          err = new ERR_INVALID_ARG_TYPE2(\"chunk\", [\"string\", \"Buffer\", \"Uint8Array\"], chunk);\n      }\n      if (err)\n        errorOrDestroy2(stream, err);\n      else if (chunk === null)\n        state.reading = !1, onEofChunk(stream, state);\n      else if (state.objectMode || chunk && chunk.length > 0)\n        if (addToFront)\n          if (state.endEmitted)\n            errorOrDestroy2(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT);\n          else if (state.destroyed || state.errored)\n            return !1;\n          else\n            addChunk(stream, state, chunk, !0);\n        else if (state.ended)\n          errorOrDestroy2(stream, new ERR_STREAM_PUSH_AFTER_EOF);\n        else if (state.destroyed || state.errored)\n          return !1;\n        else if (state.reading = !1, state.decoder && !encoding)\n          if (chunk = state.decoder.write(chunk), state.objectMode || chunk.length !== 0)\n            addChunk(stream, state, chunk, !1);\n          else\n            maybeReadMore(stream, state);\n        else\n          addChunk(stream, state, chunk, !1);\n      else if (!addToFront)\n        state.reading = !1, maybeReadMore(stream, state);\n      return !state.ended && (state.length < state.highWaterMark || state.length === 0);\n    }\n    function addChunk(stream, state, chunk, addToFront) {\n      if (state.flowing && state.length === 0 && !state.sync && stream.listenerCount(\"data\") > 0) {\n        if (state.multiAwaitDrain)\n          state.awaitDrainWriters.clear();\n        else\n          state.awaitDrainWriters = null;\n        state.dataEmitted = !0, stream.emit(\"data\", chunk);\n      } else {\n        if (state.length += state.objectMode \? 1 : chunk.length, addToFront)\n          state.buffer.unshift(chunk);\n        else\n          state.buffer.push(chunk);\n        if (state.needReadable)\n          emitReadable(stream, state);\n      }\n      maybeReadMore(stream, state);\n    }\n    Readable.prototype.isPaused = function() {\n      const state = this._readableState;\n      return state.paused === !0 || state.flowing === !1;\n    }, Readable.prototype.setEncoding = function(enc) {\n      const decoder = new StringDecoder(enc);\n      this._readableState.decoder = decoder, this._readableState.encoding = this._readableState.decoder.encoding;\n      const buffer = this._readableState.buffer;\n      let content = \"\";\n      for (let i = buffer.length;i > 0; i--)\n        content += decoder.write(buffer.shift());\n      if (content !== \"\")\n        buffer.push(content);\n      return this._readableState.length = content.length, this;\n    };\n    var MAX_HWM = 1073741824;\n    function computeNewHighWaterMark(n) {\n      if (n > MAX_HWM)\n        throw new ERR_OUT_OF_RANGE(\"size\", \"<= 1GiB\", n);\n      else\n        n--, n |= n >>> 1, n |= n >>> 2, n |= n >>> 4, n |= n >>> 8, n |= n >>> 16, n++;\n      return n;\n    }\n    function howMuchToRead(n, state) {\n      if (n <= 0 || state.length === 0 && state.ended)\n        return 0;\n      if (state.objectMode)\n        return 1;\n      if (NumberIsNaN(n)) {\n        if (state.flowing && state.length)\n          return state.buffer.first().length;\n        return state.length;\n      }\n      if (n <= state.length)\n        return n;\n      return state.ended \? state.length : 0;\n    }\n    Readable.prototype.read = function(n) {\n      if (!NumberIsInteger(n))\n        n = NumberParseInt(n, 10);\n      const state = this._readableState, nOrig = n;\n      if (n > state.highWaterMark)\n        state.highWaterMark = computeNewHighWaterMark(n);\n      if (n !== 0)\n        state.emittedReadable = !1;\n      if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 \? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {\n        if (state.length === 0 && state.ended)\n          endReadable(this);\n        else\n          emitReadable(this, state);\n        return null;\n      }\n      if (n = howMuchToRead(n, state), n === 0 && state.ended) {\n        if (state.length === 0)\n          endReadable(this);\n        return null;\n      }\n      let doRead = state.needReadable;\n      if (state.length === 0 || state.length - n < state.highWaterMark)\n        doRead = !0;\n      if (state.ended || state.reading || state.destroyed || state.errored || !state.constructed)\n        doRead = !1;\n      else if (doRead) {\n        if (state.reading = !0, state.sync = !0, state.length === 0)\n          state.needReadable = !0;\n        try {\n          var result = this._read(state.highWaterMark);\n          if (@isPromise(result)) {\n            const peeked = Bun.peek(result);\n            if (peeked !== result)\n              result = peeked;\n          }\n          if (@isPromise(result) && result\?.then && @isCallable(result.then))\n            result.then(nop, function(err) {\n              errorOrDestroy2(this, err);\n            });\n        } catch (err) {\n          errorOrDestroy2(this, err);\n        }\n        if (state.sync = !1, !state.reading)\n          n = howMuchToRead(nOrig, state);\n      }\n      let ret;\n      if (n > 0)\n        ret = fromList(n, state);\n      else\n        ret = null;\n      if (ret === null)\n        state.needReadable = state.length <= state.highWaterMark, n = 0;\n      else if (state.length -= n, state.multiAwaitDrain)\n        state.awaitDrainWriters.clear();\n      else\n        state.awaitDrainWriters = null;\n      if (state.length === 0) {\n        if (!state.ended)\n          state.needReadable = !0;\n        if (nOrig !== n && state.ended)\n          endReadable(this);\n      }\n      if (ret !== null && !state.errorEmitted && !state.closeEmitted)\n        state.dataEmitted = !0, this.emit(\"data\", ret);\n      return ret;\n    }, Readable.prototype._read = function(n) {\n      throw new ERR_METHOD_NOT_IMPLEMENTED(\"_read()\");\n    }, Readable.prototype.pipe = function(dest, pipeOpts) {\n      const src = this, state = this._readableState;\n      if (state.pipes.length === 1) {\n        if (!state.multiAwaitDrain)\n          state.multiAwaitDrain = !0, state.awaitDrainWriters = new SafeSet(state.awaitDrainWriters \? [state.awaitDrainWriters] : []);\n      }\n      state.pipes.push(dest);\n      const endFn = (!pipeOpts || pipeOpts.end !== !1) && dest !== process.stdout && dest !== process.stderr \? onend : unpipe;\n      if (state.endEmitted)\n        runOnNextTick(endFn);\n      else\n        src.once(\"end\", endFn);\n      dest.on(\"unpipe\", onunpipe);\n      function onunpipe(readable, unpipeInfo) {\n        if (readable === src) {\n          if (unpipeInfo && unpipeInfo.hasUnpiped === !1)\n            unpipeInfo.hasUnpiped = !0, cleanup();\n        }\n      }\n      function onend() {\n        dest.end();\n      }\n      let ondrain, cleanedUp = !1;\n      function cleanup() {\n        if (dest.removeListener(\"close\", onclose), dest.removeListener(\"finish\", onfinish), ondrain)\n          dest.removeListener(\"drain\", ondrain);\n        if (dest.removeListener(\"error\", onerror), dest.removeListener(\"unpipe\", onunpipe), src.removeListener(\"end\", onend), src.removeListener(\"end\", unpipe), src.removeListener(\"data\", ondata), cleanedUp = !0, ondrain && state.awaitDrainWriters && (!dest._writableState || dest._writableState.needDrain))\n          ondrain();\n      }\n      function pause() {\n        if (!cleanedUp) {\n          if (state.pipes.length === 1 && state.pipes[0] === dest)\n            state.awaitDrainWriters = dest, state.multiAwaitDrain = !1;\n          else if (state.pipes.length > 1 && state.pipes.includes(dest))\n            state.awaitDrainWriters.add(dest);\n          src.pause();\n        }\n        if (!ondrain)\n          ondrain = pipeOnDrain(src, dest), dest.on(\"drain\", ondrain);\n      }\n      src.on(\"data\", ondata);\n      function ondata(chunk) {\n        if (dest.write(chunk) === !1)\n          pause();\n      }\n      function onerror(er) {\n        if (unpipe(), dest.removeListener(\"error\", onerror), dest.listenerCount(\"error\") === 0) {\n          const s = dest._writableState || dest._readableState;\n          if (s && !s.errorEmitted)\n            errorOrDestroy2(dest, er);\n          else\n            dest.emit(\"error\", er);\n        }\n      }\n      prependListener(dest, \"error\", onerror);\n      function onclose() {\n        dest.removeListener(\"finish\", onfinish), unpipe();\n      }\n      dest.once(\"close\", onclose);\n      function onfinish() {\n        dest.removeListener(\"close\", onclose), unpipe();\n      }\n      dest.once(\"finish\", onfinish);\n      function unpipe() {\n        src.unpipe(dest);\n      }\n      if (dest.emit(\"pipe\", src), dest.writableNeedDrain === !0) {\n        if (state.flowing)\n          pause();\n      } else if (!state.flowing)\n        src.resume();\n      return dest;\n    };\n    function pipeOnDrain(src, dest) {\n      return function pipeOnDrainFunctionResult() {\n        const state = src._readableState;\n        if (state.awaitDrainWriters === dest)\n          state.awaitDrainWriters = null;\n        else if (state.multiAwaitDrain)\n          state.awaitDrainWriters.delete(dest);\n        if ((!state.awaitDrainWriters || state.awaitDrainWriters.size === 0) && src.listenerCount(\"data\"))\n          src.resume();\n      };\n    }\n    Readable.prototype.unpipe = function(dest) {\n      const state = this._readableState, unpipeInfo = {\n        hasUnpiped: !1\n      };\n      if (state.pipes.length === 0)\n        return this;\n      if (!dest) {\n        const dests = state.pipes;\n        state.pipes = [], this.pause();\n        for (let i = 0;i < dests.length; i++)\n          dests[i].emit(\"unpipe\", this, {\n            hasUnpiped: !1\n          });\n        return this;\n      }\n      const index = ArrayPrototypeIndexOf(state.pipes, dest);\n      if (index === -1)\n        return this;\n      if (state.pipes.splice(index, 1), state.pipes.length === 0)\n        this.pause();\n      return dest.emit(\"unpipe\", this, unpipeInfo), this;\n    }, Readable.prototype.addListener = Readable.prototype.on, Readable.prototype.removeListener = function(ev, fn) {\n      const res = Stream.prototype.removeListener.call(this, ev, fn);\n      if (ev === \"readable\")\n        runOnNextTick(updateReadableListening, this);\n      return res;\n    }, Readable.prototype.off = Readable.prototype.removeListener, Readable.prototype.removeAllListeners = function(ev) {\n      const res = Stream.prototype.removeAllListeners.apply(this, arguments);\n      if (ev === \"readable\" || ev === void 0)\n        runOnNextTick(updateReadableListening, this);\n      return res;\n    };\n    function updateReadableListening(self) {\n      const state = self._readableState;\n      if (state.readableListening = self.listenerCount(\"readable\") > 0, state.resumeScheduled && state.paused === !1)\n        state.flowing = !0;\n      else if (self.listenerCount(\"data\") > 0)\n        self.resume();\n      else if (!state.readableListening)\n        state.flowing = null;\n    }\n    function nReadingNextTick(self) {\n      self.read(0);\n    }\n    Readable.prototype.resume = function() {\n      const state = this._readableState;\n      if (!state.flowing)\n        state.flowing = !state.readableListening, resume(this, state);\n      return state.paused = !1, this;\n    }, Readable.prototype.pause = function() {\n      if (this._readableState.flowing !== !1)\n        this._readableState.flowing = !1, this.emit(\"pause\");\n      return this._readableState.paused = !0, this;\n    }, Readable.prototype.wrap = function(stream) {\n      let paused = !1;\n      stream.on(\"data\", (chunk) => {\n        if (!this.push(chunk) && stream.pause)\n          paused = !0, stream.pause();\n      }), stream.on(\"end\", () => {\n        this.push(null);\n      }), stream.on(\"error\", (err) => {\n        errorOrDestroy2(this, err);\n      }), stream.on(\"close\", () => {\n        this.destroy();\n      }), stream.on(\"destroy\", () => {\n        this.destroy();\n      }), this._read = () => {\n        if (paused && stream.resume)\n          paused = !1, stream.resume();\n      };\n      const streamKeys = ObjectKeys(stream);\n      for (let j = 1;j < streamKeys.length; j++) {\n        const i = streamKeys[j];\n        if (this[i] === void 0 && typeof stream[i] === \"function\")\n          this[i] = stream[i].bind(stream);\n      }\n      return this;\n    }, Readable.prototype[SymbolAsyncIterator] = function() {\n      return streamToAsyncIterator(this);\n    }, Readable.prototype.iterator = function(options) {\n      if (options !== void 0)\n        validateObject(options, \"options\");\n      return streamToAsyncIterator(this, options);\n    };\n    function streamToAsyncIterator(stream, options) {\n      if (typeof stream.read !== \"function\")\n        stream = Readable.wrap(stream, {\n          objectMode: !0\n        });\n      const iter = createAsyncIterator(stream, options);\n      return iter.stream = stream, iter;\n    }\n    async function* createAsyncIterator(stream, options) {\n      let callback = nop;\n      function next(resolve) {\n        if (this === stream)\n          callback(), callback = nop;\n        else\n          callback = resolve;\n      }\n      stream.on(\"readable\", next);\n      let error;\n      const cleanup = eos(stream, {\n        writable: !1\n      }, (err) => {\n        error = err \? aggregateTwoErrors(error, err) : null, callback(), callback = nop;\n      });\n      try {\n        while (!0) {\n          const chunk = stream.destroyed \? null : stream.read();\n          if (chunk !== null)\n            yield chunk;\n          else if (error)\n            throw error;\n          else if (error === null)\n            return;\n          else\n            await new Promise2(next);\n        }\n      } catch (err) {\n        throw error = aggregateTwoErrors(error, err), error;\n      } finally {\n        if ((error || (options === null || options === void 0 \? void 0 : options.destroyOnReturn) !== !1) && (error === void 0 || stream._readableState.autoDestroy))\n          destroyImpl.destroyer(stream, null);\n        else\n          stream.off(\"readable\", next), cleanup();\n      }\n    }\n    ObjectDefineProperties(Readable.prototype, {\n      readable: {\n        get() {\n          const r = this._readableState;\n          return !!r && r.readable !== !1 && !r.destroyed && !r.errorEmitted && !r.endEmitted;\n        },\n        set(val) {\n          if (this._readableState)\n            this._readableState.readable = !!val;\n        }\n      },\n      readableDidRead: {\n        enumerable: !1,\n        get: function() {\n          return this._readableState.dataEmitted;\n        }\n      },\n      readableAborted: {\n        enumerable: !1,\n        get: function() {\n          return !!(this._readableState.readable !== !1 && (this._readableState.destroyed || this._readableState.errored) && !this._readableState.endEmitted);\n        }\n      },\n      readableHighWaterMark: {\n        enumerable: !1,\n        get: function() {\n          return this._readableState.highWaterMark;\n        }\n      },\n      readableBuffer: {\n        enumerable: !1,\n        get: function() {\n          return this._readableState && this._readableState.buffer;\n        }\n      },\n      readableFlowing: {\n        enumerable: !1,\n        get: function() {\n          return this._readableState.flowing;\n        },\n        set: function(state) {\n          if (this._readableState)\n            this._readableState.flowing = state;\n        }\n      },\n      readableLength: {\n        enumerable: !1,\n        get() {\n          return this._readableState.length;\n        }\n      },\n      readableObjectMode: {\n        enumerable: !1,\n        get() {\n          return this._readableState \? this._readableState.objectMode : !1;\n        }\n      },\n      readableEncoding: {\n        enumerable: !1,\n        get() {\n          return this._readableState \? this._readableState.encoding : null;\n        }\n      },\n      errored: {\n        enumerable: !1,\n        get() {\n          return this._readableState \? this._readableState.errored : null;\n        }\n      },\n      closed: {\n        get() {\n          return this._readableState \? this._readableState.closed : !1;\n        }\n      },\n      destroyed: {\n        enumerable: !1,\n        get() {\n          return this._readableState \? this._readableState.destroyed : !1;\n        },\n        set(value) {\n          if (!this._readableState)\n            return;\n          this._readableState.destroyed = value;\n        }\n      },\n      readableEnded: {\n        enumerable: !1,\n        get() {\n          return this._readableState \? this._readableState.endEmitted : !1;\n        }\n      }\n    }), Readable._fromList = fromList;\n    function fromList(n, state) {\n      if (state.length === 0)\n        return null;\n      let ret;\n      if (state.objectMode)\n        ret = state.buffer.shift();\n      else if (!n || n >= state.length) {\n        if (state.decoder)\n          ret = state.buffer.join(\"\");\n        else if (state.buffer.length === 1)\n          ret = state.buffer.first();\n        else\n          ret = state.buffer.concat(state.length);\n        state.buffer.clear();\n      } else\n        ret = state.buffer.consume(n, state.decoder);\n      return ret;\n    }\n    function endReadable(stream) {\n      const state = stream._readableState;\n      if (!state.endEmitted)\n        state.ended = !0, runOnNextTick(endReadableNT, state, stream);\n    }\n    function endReadableNT(state, stream) {\n      if (!state.errored && !state.closeEmitted && !state.endEmitted && state.length === 0) {\n        if (state.endEmitted = !0, stream.emit(\"end\"), stream.writable && stream.allowHalfOpen === !1)\n          runOnNextTick(endWritableNT, stream);\n        else if (state.autoDestroy) {\n          const wState = stream._writableState;\n          if (!wState || wState.autoDestroy && (wState.finished || wState.writable === !1))\n            stream.destroy();\n        }\n      }\n    }\n    function endWritableNT(stream) {\n      if (stream.writable && !stream.writableEnded && !stream.destroyed)\n        stream.end();\n    }\n    Readable.from = function(iterable, opts) {\n      return from(Readable, iterable, opts);\n    };\n    var webStreamsAdapters = {\n      newStreamReadableFromReadableStream,\n      newReadableStreamFromStreamReadable(streamReadable, options = {}) {\n        if (typeof streamReadable\?._readableState !== \"object\")\n          throw new ERR_INVALID_ARG_TYPE2(\"streamReadable\", \"stream.Readable\", streamReadable);\n        var { isDestroyed, isReadable } = require_utils();\n        if (isDestroyed(streamReadable) || !isReadable(streamReadable)) {\n          const readable = new ReadableStream;\n          return readable.cancel(), readable;\n        }\n        const { readableObjectMode: objectMode, readableHighWaterMark: highWaterMark } = streamReadable, strategy = ((strategy2) => {\n          if (strategy2)\n            return strategy2;\n          if (objectMode)\n            return new CountQueuingStrategy({ highWaterMark });\n          return { highWaterMark };\n        })(options\?.strategy);\n        let controller;\n        function onData(chunk) {\n          if (controller.enqueue(chunk), controller.desiredSize <= 0)\n            streamReadable.pause();\n        }\n        streamReadable.pause();\n        const cleanup = finished(streamReadable, (error) => {\n          if (error\?.code === \"ERR_STREAM_PREMATURE_CLOSE\")\n            error = new AbortError(void 0, { cause: error });\n          if (cleanup(), streamReadable.on(\"error\", () => {\n          }), error)\n            return controller.error(error);\n          controller.close();\n        });\n        return streamReadable.on(\"data\", onData), new ReadableStream({\n          start(c) {\n            controller = c;\n          },\n          pull() {\n            streamReadable.resume();\n          },\n          cancel(reason) {\n            destroy(streamReadable, reason);\n          }\n        }, strategy);\n      }\n    };\n    Readable.fromWeb = function(readableStream, options) {\n      return webStreamsAdapters.newStreamReadableFromReadableStream(readableStream, options);\n    }, Readable.toWeb = function(streamReadable, options) {\n      return webStreamsAdapters.newReadableStreamFromStreamReadable(streamReadable, options);\n    }, Readable.wrap = function(src, options) {\n      var _ref, _src$readableObjectMo;\n      return new Readable({\n        objectMode: (_ref = (_src$readableObjectMo = src.readableObjectMode) !== null && _src$readableObjectMo !== void 0 \? _src$readableObjectMo : src.objectMode) !== null && _ref !== void 0 \? _ref : !0,\n        ...options,\n        destroy(err, callback) {\n          destroyImpl.destroyer(src, err), callback(err);\n        }\n      }).wrap(src);\n    };\n  }\n}), require_writable = __commonJS({\n  \"node_modules/readable-stream/lib/internal/streams/writable.js\"(exports, module) {\n    var {\n      ArrayPrototypeSlice,\n      Error: Error2,\n      FunctionPrototypeSymbolHasInstance,\n      ObjectDefineProperty,\n      ObjectDefineProperties,\n      ObjectSetPrototypeOf,\n      StringPrototypeToLowerCase,\n      Symbol: Symbol2,\n      SymbolHasInstance\n    } = require_primordials(), Stream = require_legacy().Stream, destroyImpl = require_destroy(), { addAbortSignal } = require_add_abort_signal(), { getHighWaterMark, getDefaultHighWaterMark } = require_state(), {\n      ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE2,\n      ERR_METHOD_NOT_IMPLEMENTED,\n      ERR_MULTIPLE_CALLBACK,\n      ERR_STREAM_CANNOT_PIPE,\n      ERR_STREAM_DESTROYED,\n      ERR_STREAM_ALREADY_FINISHED,\n      ERR_STREAM_NULL_VALUES,\n      ERR_STREAM_WRITE_AFTER_END,\n      ERR_UNKNOWN_ENCODING\n    } = require_errors().codes, { errorOrDestroy: errorOrDestroy2 } = destroyImpl;\n    function Writable(options = {}) {\n      const isDuplex = this instanceof require_duplex();\n      if (!isDuplex && !FunctionPrototypeSymbolHasInstance(Writable, this))\n        return new Writable(options);\n      if (this._writableState = new WritableState(options, this, isDuplex), options) {\n        if (typeof options.write === \"function\")\n          this._write = options.write;\n        if (typeof options.writev === \"function\")\n          this._writev = options.writev;\n        if (typeof options.destroy === \"function\")\n          this._destroy = options.destroy;\n        if (typeof options.final === \"function\")\n          this._final = options.final;\n        if (typeof options.construct === \"function\")\n          this._construct = options.construct;\n        if (options.signal)\n          addAbortSignal(options.signal, this);\n      }\n      Stream.call(this, options), destroyImpl.construct(this, () => {\n        const state = this._writableState;\n        if (!state.writing)\n          clearBuffer(this, state);\n        finishMaybe(this, state);\n      });\n    }\n    Writable.prototype = {}, ObjectSetPrototypeOf(Writable.prototype, Stream.prototype), ObjectSetPrototypeOf(Writable, Stream), module.exports = Writable;\n    function nop() {\n    }\n    var kOnFinished = Symbol2(\"kOnFinished\");\n    function WritableState(options, stream, isDuplex) {\n      if (typeof isDuplex !== \"boolean\")\n        isDuplex = stream instanceof require_duplex();\n      if (this.objectMode = !!(options && options.objectMode), isDuplex)\n        this.objectMode = this.objectMode || !!(options && options.writableObjectMode);\n      this.highWaterMark = options \? getHighWaterMark(this, options, \"writableHighWaterMark\", isDuplex) : getDefaultHighWaterMark(!1), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;\n      const noDecode = !!(options && options.decodeStrings === !1);\n      this.decodeStrings = !noDecode, this.defaultEncoding = options && options.defaultEncoding || \"utf8\", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = onwrite.bind(void 0, stream), this.writecb = null, this.writelen = 0, this.afterWriteTickInfo = null, resetBuffer(this), this.pendingcb = 0, this.constructed = !0, this.prefinished = !1, this.errorEmitted = !1, this.emitClose = !options || options.emitClose !== !1, this.autoDestroy = !options || options.autoDestroy !== !1, this.errored = null, this.closed = !1, this.closeEmitted = !1, this[kOnFinished] = [];\n    }\n    WritableState.prototype = {};\n    function resetBuffer(state) {\n      state.buffered = [], state.bufferedIndex = 0, state.allBuffers = !0, state.allNoop = !0;\n    }\n    WritableState.prototype.getBuffer = function getBuffer() {\n      return ArrayPrototypeSlice(this.buffered, this.bufferedIndex);\n    }, ObjectDefineProperty(WritableState.prototype, \"bufferedRequestCount\", {\n      get() {\n        return this.buffered.length - this.bufferedIndex;\n      }\n    }), ObjectDefineProperty(Writable, SymbolHasInstance, {\n      value: function(object) {\n        if (FunctionPrototypeSymbolHasInstance(this, object))\n          return !0;\n        if (this !== Writable)\n          return !1;\n        return object && object._writableState instanceof WritableState;\n      }\n    }), Writable.prototype.pipe = function() {\n      errorOrDestroy2(this, new ERR_STREAM_CANNOT_PIPE);\n    };\n    function _write(stream, chunk, encoding, cb) {\n      const state = stream._writableState;\n      if (typeof encoding === \"function\")\n        cb = encoding, encoding = state.defaultEncoding;\n      else {\n        if (!encoding)\n          encoding = state.defaultEncoding;\n        else if (encoding !== \"buffer\" && !Buffer.isEncoding(encoding))\n          throw new ERR_UNKNOWN_ENCODING(encoding);\n        if (typeof cb !== \"function\")\n          cb = nop;\n      }\n      if (chunk === null)\n        throw new ERR_STREAM_NULL_VALUES;\n      else if (!state.objectMode)\n        if (typeof chunk === \"string\") {\n          if (state.decodeStrings !== !1)\n            chunk = Buffer.from(chunk, encoding), encoding = \"buffer\";\n        } else if (chunk instanceof Buffer)\n          encoding = \"buffer\";\n        else if (Stream._isUint8Array(chunk))\n          chunk = Stream._uint8ArrayToBuffer(chunk), encoding = \"buffer\";\n        else\n          throw new ERR_INVALID_ARG_TYPE2(\"chunk\", [\"string\", \"Buffer\", \"Uint8Array\"], chunk);\n      let err;\n      if (state.ending)\n        err = new ERR_STREAM_WRITE_AFTER_END;\n      else if (state.destroyed)\n        err = new ERR_STREAM_DESTROYED(\"write\");\n      if (err)\n        return runOnNextTick(cb, err), errorOrDestroy2(stream, err, !0), err;\n      return state.pendingcb++, writeOrBuffer(stream, state, chunk, encoding, cb);\n    }\n    Writable.prototype.write = function(chunk, encoding, cb) {\n      return _write(this, chunk, encoding, cb) === !0;\n    }, Writable.prototype.cork = function() {\n      this._writableState.corked++;\n    }, Writable.prototype.uncork = function() {\n      const state = this._writableState;\n      if (state.corked) {\n        if (state.corked--, !state.writing)\n          clearBuffer(this, state);\n      }\n    }, Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {\n      if (typeof encoding === \"string\")\n        encoding = StringPrototypeToLowerCase(encoding);\n      if (!Buffer.isEncoding(encoding))\n        throw new ERR_UNKNOWN_ENCODING(encoding);\n      return this._writableState.defaultEncoding = encoding, this;\n    };\n    function writeOrBuffer(stream, state, chunk, encoding, callback) {\n      const len = state.objectMode \? 1 : chunk.length;\n      state.length += len;\n      const ret = state.length < state.highWaterMark;\n      if (!ret)\n        state.needDrain = !0;\n      if (state.writing || state.corked || state.errored || !state.constructed) {\n        if (state.buffered.push({\n          chunk,\n          encoding,\n          callback\n        }), state.allBuffers && encoding !== \"buffer\")\n          state.allBuffers = !1;\n        if (state.allNoop && callback !== nop)\n          state.allNoop = !1;\n      } else\n        state.writelen = len, state.writecb = callback, state.writing = !0, state.sync = !0, stream._write(chunk, encoding, state.onwrite), state.sync = !1;\n      return ret && !state.errored && !state.destroyed;\n    }\n    function doWrite(stream, state, writev, len, chunk, encoding, cb) {\n      if (state.writelen = len, state.writecb = cb, state.writing = !0, state.sync = !0, state.destroyed)\n        state.onwrite(new ERR_STREAM_DESTROYED(\"write\"));\n      else if (writev)\n        stream._writev(chunk, state.onwrite);\n      else\n        stream._write(chunk, encoding, state.onwrite);\n      state.sync = !1;\n    }\n    function onwriteError(stream, state, er, cb) {\n      --state.pendingcb, cb(er), errorBuffer(state), errorOrDestroy2(stream, er);\n    }\n    function onwrite(stream, er) {\n      const state = stream._writableState, sync = state.sync, cb = state.writecb;\n      if (typeof cb !== \"function\") {\n        errorOrDestroy2(stream, new ERR_MULTIPLE_CALLBACK);\n        return;\n      }\n      if (state.writing = !1, state.writecb = null, state.length -= state.writelen, state.writelen = 0, er) {\n        if (Error.captureStackTrace(er), !state.errored)\n          state.errored = er;\n        if (stream._readableState && !stream._readableState.errored)\n          stream._readableState.errored = er;\n        if (sync)\n          runOnNextTick(onwriteError, stream, state, er, cb);\n        else\n          onwriteError(stream, state, er, cb);\n      } else {\n        if (state.buffered.length > state.bufferedIndex)\n          clearBuffer(stream, state);\n        if (sync)\n          if (state.afterWriteTickInfo !== null && state.afterWriteTickInfo.cb === cb)\n            state.afterWriteTickInfo.count++;\n          else\n            state.afterWriteTickInfo = {\n              count: 1,\n              cb,\n              stream,\n              state\n            }, runOnNextTick(afterWriteTick, state.afterWriteTickInfo);\n        else\n          afterWrite(stream, state, 1, cb);\n      }\n    }\n    function afterWriteTick({ stream, state, count, cb }) {\n      return state.afterWriteTickInfo = null, afterWrite(stream, state, count, cb);\n    }\n    function afterWrite(stream, state, count, cb) {\n      if (!state.ending && !stream.destroyed && state.length === 0 && state.needDrain)\n        state.needDrain = !1, stream.emit(\"drain\");\n      while (count-- > 0)\n        state.pendingcb--, cb();\n      if (state.destroyed)\n        errorBuffer(state);\n      finishMaybe(stream, state);\n    }\n    function errorBuffer(state) {\n      if (state.writing)\n        return;\n      for (let n = state.bufferedIndex;n < state.buffered.length; ++n) {\n        var _state$errored;\n        const { chunk, callback } = state.buffered[n], len = state.objectMode \? 1 : chunk.length;\n        state.length -= len, callback((_state$errored = state.errored) !== null && _state$errored !== void 0 \? _state$errored : new ERR_STREAM_DESTROYED(\"write\"));\n      }\n      const onfinishCallbacks = state[kOnFinished].splice(0);\n      for (let i = 0;i < onfinishCallbacks.length; i++) {\n        var _state$errored2;\n        onfinishCallbacks[i]((_state$errored2 = state.errored) !== null && _state$errored2 !== void 0 \? _state$errored2 : new ERR_STREAM_DESTROYED(\"end\"));\n      }\n      resetBuffer(state);\n    }\n    function clearBuffer(stream, state) {\n      if (state.corked || state.bufferProcessing || state.destroyed || !state.constructed)\n        return;\n      const { buffered, bufferedIndex, objectMode } = state, bufferedLength = buffered.length - bufferedIndex;\n      if (!bufferedLength)\n        return;\n      let i = bufferedIndex;\n      if (state.bufferProcessing = !0, bufferedLength > 1 && stream._writev) {\n        state.pendingcb -= bufferedLength - 1;\n        const callback = state.allNoop \? nop : (err) => {\n          for (let n = i;n < buffered.length; ++n)\n            buffered[n].callback(err);\n        }, chunks = state.allNoop && i === 0 \? buffered : ArrayPrototypeSlice(buffered, i);\n        chunks.allBuffers = state.allBuffers, doWrite(stream, state, !0, state.length, chunks, \"\", callback), resetBuffer(state);\n      } else {\n        do {\n          const { chunk, encoding, callback } = buffered[i];\n          buffered[i++] = null;\n          const len = objectMode \? 1 : chunk.length;\n          doWrite(stream, state, !1, len, chunk, encoding, callback);\n        } while (i < buffered.length && !state.writing);\n        if (i === buffered.length)\n          resetBuffer(state);\n        else if (i > 256)\n          buffered.splice(0, i), state.bufferedIndex = 0;\n        else\n          state.bufferedIndex = i;\n      }\n      state.bufferProcessing = !1;\n    }\n    Writable.prototype._write = function(chunk, encoding, cb) {\n      if (this._writev)\n        this._writev([\n          {\n            chunk,\n            encoding\n          }\n        ], cb);\n      else\n        throw new ERR_METHOD_NOT_IMPLEMENTED(\"_write()\");\n    }, Writable.prototype._writev = null, Writable.prototype.end = function(chunk, encoding, cb, native = !1) {\n      const state = this._writableState;\n      if (typeof chunk === \"function\")\n        cb = chunk, chunk = null, encoding = null;\n      else if (typeof encoding === \"function\")\n        cb = encoding, encoding = null;\n      let err;\n      if (chunk !== null && chunk !== void 0) {\n        let ret;\n        if (!native)\n          ret = _write(this, chunk, encoding);\n        else\n          ret = this.write(chunk, encoding);\n        if (ret instanceof Error2)\n          err = ret;\n      }\n      if (state.corked)\n        state.corked = 1, this.uncork();\n      if (err)\n        this.emit(\"error\", err);\n      else if (!state.errored && !state.ending)\n        state.ending = !0, finishMaybe(this, state, !0), state.ended = !0;\n      else if (state.finished)\n        err = new ERR_STREAM_ALREADY_FINISHED(\"end\");\n      else if (state.destroyed)\n        err = new ERR_STREAM_DESTROYED(\"end\");\n      if (typeof cb === \"function\")\n        if (err || state.finished)\n          runOnNextTick(cb, err);\n        else\n          state[kOnFinished].push(cb);\n      return this;\n    };\n    function needFinish(state, tag) {\n      var needFinish2 = state.ending && !state.destroyed && state.constructed && state.length === 0 && !state.errored && state.buffered.length === 0 && !state.finished && !state.writing && !state.errorEmitted && !state.closeEmitted;\n      return needFinish2;\n    }\n    function callFinal(stream, state) {\n      let called = !1;\n      function onFinish(err) {\n        if (called) {\n          errorOrDestroy2(stream, err !== null && err !== void 0 \? err : ERR_MULTIPLE_CALLBACK());\n          return;\n        }\n        if (called = !0, state.pendingcb--, err) {\n          const onfinishCallbacks = state[kOnFinished].splice(0);\n          for (let i = 0;i < onfinishCallbacks.length; i++)\n            onfinishCallbacks[i](err);\n          errorOrDestroy2(stream, err, state.sync);\n        } else if (needFinish(state))\n          state.prefinished = !0, stream.emit(\"prefinish\"), state.pendingcb++, runOnNextTick(finish, stream, state);\n      }\n      state.sync = !0, state.pendingcb++;\n      try {\n        stream._final(onFinish);\n      } catch (err) {\n        onFinish(err);\n      }\n      state.sync = !1;\n    }\n    function prefinish(stream, state) {\n      if (!state.prefinished && !state.finalCalled)\n        if (typeof stream._final === \"function\" && !state.destroyed)\n          state.finalCalled = !0, callFinal(stream, state);\n        else\n          state.prefinished = !0, stream.emit(\"prefinish\");\n    }\n    function finishMaybe(stream, state, sync) {\n      if (!needFinish(state, stream.__id))\n        return;\n      if (prefinish(stream, state), state.pendingcb === 0) {\n        if (sync)\n          state.pendingcb++, runOnNextTick((stream2, state2) => {\n            if (needFinish(state2))\n              finish(stream2, state2);\n            else\n              state2.pendingcb--;\n          }, stream, state);\n        else if (needFinish(state))\n          state.pendingcb++, finish(stream, state);\n      }\n    }\n    function finish(stream, state) {\n      state.pendingcb--, state.finished = !0;\n      const onfinishCallbacks = state[kOnFinished].splice(0);\n      for (let i = 0;i < onfinishCallbacks.length; i++)\n        onfinishCallbacks[i]();\n      if (stream.emit(\"finish\"), state.autoDestroy) {\n        const rState = stream._readableState;\n        if (!rState || rState.autoDestroy && (rState.endEmitted || rState.readable === !1))\n          stream.destroy();\n      }\n    }\n    ObjectDefineProperties(Writable.prototype, {\n      closed: {\n        get() {\n          return this._writableState \? this._writableState.closed : !1;\n        }\n      },\n      destroyed: {\n        get() {\n          return this._writableState \? this._writableState.destroyed : !1;\n        },\n        set(value) {\n          if (this._writableState)\n            this._writableState.destroyed = value;\n        }\n      },\n      writable: {\n        get() {\n          const w = this._writableState;\n          return !!w && w.writable !== !1 && !w.destroyed && !w.errored && !w.ending && !w.ended;\n        },\n        set(val) {\n          if (this._writableState)\n            this._writableState.writable = !!val;\n        }\n      },\n      writableFinished: {\n        get() {\n          return this._writableState \? this._writableState.finished : !1;\n        }\n      },\n      writableObjectMode: {\n        get() {\n          return this._writableState \? this._writableState.objectMode : !1;\n        }\n      },\n      writableBuffer: {\n        get() {\n          return this._writableState && this._writableState.getBuffer();\n        }\n      },\n      writableEnded: {\n        get() {\n          return this._writableState \? this._writableState.ending : !1;\n        }\n      },\n      writableNeedDrain: {\n        get() {\n          const wState = this._writableState;\n          if (!wState)\n            return !1;\n          return !wState.destroyed && !wState.ending && wState.needDrain;\n        }\n      },\n      writableHighWaterMark: {\n        get() {\n          return this._writableState && this._writableState.highWaterMark;\n        }\n      },\n      writableCorked: {\n        get() {\n          return this._writableState \? this._writableState.corked : 0;\n        }\n      },\n      writableLength: {\n        get() {\n          return this._writableState && this._writableState.length;\n        }\n      },\n      errored: {\n        enumerable: !1,\n        get() {\n          return this._writableState \? this._writableState.errored : null;\n        }\n      },\n      writableAborted: {\n        enumerable: !1,\n        get: function() {\n          return !!(this._writableState.writable !== !1 && (this._writableState.destroyed || this._writableState.errored) && !this._writableState.finished);\n        }\n      }\n    });\n    var destroy2 = destroyImpl.destroy;\n    Writable.prototype.destroy = function(err, cb) {\n      const state = this._writableState;\n      if (!state.destroyed && (state.bufferedIndex < state.buffered.length || state[kOnFinished].length))\n        runOnNextTick(errorBuffer, state);\n      return destroy2.call(this, err, cb), this;\n    }, Writable.prototype._undestroy = destroyImpl.undestroy, Writable.prototype._destroy = function(err, cb) {\n      cb(err);\n    }, Writable.prototype[EE.captureRejectionSymbol] = function(err) {\n      this.destroy(err);\n    };\n    var webStreamsAdapters;\n    function lazyWebStreams() {\n      if (webStreamsAdapters === void 0)\n        webStreamsAdapters = {};\n      return webStreamsAdapters;\n    }\n    Writable.fromWeb = function(writableStream, options) {\n      return lazyWebStreams().newStreamWritableFromWritableStream(writableStream, options);\n    }, Writable.toWeb = function(streamWritable) {\n      return lazyWebStreams().newWritableStreamFromStreamWritable(streamWritable);\n    };\n  }\n}), require_duplexify = __commonJS({\n  \"node_modules/readable-stream/lib/internal/streams/duplexify.js\"(exports, module) {\n    var {\n      isReadable,\n      isWritable,\n      isIterable,\n      isNodeStream,\n      isReadableNodeStream,\n      isWritableNodeStream,\n      isDuplexNodeStream\n    } = require_utils(), eos = require_end_of_stream(), {\n      AbortError: AbortError2,\n      codes: { ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE2, ERR_INVALID_RETURN_VALUE }\n    } = require_errors(), { destroyer } = require_destroy(), Duplex = require_duplex(), Readable = require_readable(), { createDeferredPromise } = require_util(), from = require_from(), isBlob = typeof Blob !== \"undefined\" \? function isBlob2(b) {\n      return b instanceof Blob;\n    } : function isBlob2(b) {\n      return !1;\n    }, { FunctionPrototypeCall } = require_primordials();\n\n    class Duplexify extends Duplex {\n      constructor(options) {\n        super(options);\n        if ((options === null || options === void 0 \? void 0 : options.readable) === !1)\n          this._readableState.readable = !1, this._readableState.ended = !0, this._readableState.endEmitted = !0;\n        if ((options === null || options === void 0 \? void 0 : options.writable) === !1)\n          this._writableState.writable = !1, this._writableState.ending = !0, this._writableState.ended = !0, this._writableState.finished = !0;\n      }\n    }\n    module.exports = function duplexify(body, name) {\n      if (isDuplexNodeStream(body))\n        return body;\n      if (isReadableNodeStream(body))\n        return _duplexify({\n          readable: body\n        });\n      if (isWritableNodeStream(body))\n        return _duplexify({\n          writable: body\n        });\n      if (isNodeStream(body))\n        return _duplexify({\n          writable: !1,\n          readable: !1\n        });\n      if (typeof body === \"function\") {\n        const { value, write, final, destroy: destroy2 } = fromAsyncGen(body);\n        if (isIterable(value))\n          return from(Duplexify, value, {\n            objectMode: !0,\n            write,\n            final,\n            destroy: destroy2\n          });\n        const then2 = value === null || value === void 0 \? void 0 : value.then;\n        if (typeof then2 === \"function\") {\n          let d;\n          const promise = FunctionPrototypeCall(then2, value, (val) => {\n            if (val != null)\n              throw new ERR_INVALID_RETURN_VALUE(\"nully\", \"body\", val);\n          }, (err) => {\n            destroyer(d, err);\n          });\n          return d = new Duplexify({\n            objectMode: !0,\n            readable: !1,\n            write,\n            final(cb) {\n              final(async () => {\n                try {\n                  await promise, runOnNextTick(cb, null);\n                } catch (err) {\n                  runOnNextTick(cb, err);\n                }\n              });\n            },\n            destroy: destroy2\n          });\n        }\n        throw new ERR_INVALID_RETURN_VALUE(\"Iterable, AsyncIterable or AsyncFunction\", name, value);\n      }\n      if (isBlob(body))\n        return duplexify(body.arrayBuffer());\n      if (isIterable(body))\n        return from(Duplexify, body, {\n          objectMode: !0,\n          writable: !1\n        });\n      if (typeof (body === null || body === void 0 \? void 0 : body.writable) === \"object\" || typeof (body === null || body === void 0 \? void 0 : body.readable) === \"object\") {\n        const readable = body !== null && body !== void 0 && body.readable \? isReadableNodeStream(body === null || body === void 0 \? void 0 : body.readable) \? body === null || body === void 0 \? void 0 : body.readable : duplexify(body.readable) : void 0, writable = body !== null && body !== void 0 && body.writable \? isWritableNodeStream(body === null || body === void 0 \? void 0 : body.writable) \? body === null || body === void 0 \? void 0 : body.writable : duplexify(body.writable) : void 0;\n        return _duplexify({\n          readable,\n          writable\n        });\n      }\n      const then = body === null || body === void 0 \? void 0 : body.then;\n      if (typeof then === \"function\") {\n        let d;\n        return FunctionPrototypeCall(then, body, (val) => {\n          if (val != null)\n            d.push(val);\n          d.push(null);\n        }, (err) => {\n          destroyer(d, err);\n        }), d = new Duplexify({\n          objectMode: !0,\n          writable: !1,\n          read() {\n          }\n        });\n      }\n      throw new ERR_INVALID_ARG_TYPE2(name, [\n        \"Blob\",\n        \"ReadableStream\",\n        \"WritableStream\",\n        \"Stream\",\n        \"Iterable\",\n        \"AsyncIterable\",\n        \"Function\",\n        \"{ readable, writable } pair\",\n        \"Promise\"\n      ], body);\n    };\n    function fromAsyncGen(fn) {\n      let { promise, resolve } = createDeferredPromise();\n      const ac = new AbortController, signal = ac.signal;\n      return {\n        value: fn(async function* () {\n          while (!0) {\n            const _promise = promise;\n            promise = null;\n            const { chunk, done, cb } = await _promise;\n            if (runOnNextTick(cb), done)\n              return;\n            if (signal.aborted)\n              throw new AbortError2(void 0, {\n                cause: signal.reason\n              });\n            ({ promise, resolve } = createDeferredPromise()), yield chunk;\n          }\n        }(), {\n          signal\n        }),\n        write(chunk, encoding, cb) {\n          const _resolve = resolve;\n          resolve = null, _resolve({\n            chunk,\n            done: !1,\n            cb\n          });\n        },\n        final(cb) {\n          const _resolve = resolve;\n          resolve = null, _resolve({\n            done: !0,\n            cb\n          });\n        },\n        destroy(err, cb) {\n          ac.abort(), cb(err);\n        }\n      };\n    }\n    function _duplexify(pair) {\n      const r = pair.readable && typeof pair.readable.read !== \"function\" \? Readable.wrap(pair.readable) : pair.readable, w = pair.writable;\n      let readable = !!isReadable(r), writable = !!isWritable(w), ondrain, onfinish, onreadable, onclose, d;\n      function onfinished(err) {\n        const cb = onclose;\n        if (onclose = null, cb)\n          cb(err);\n        else if (err)\n          d.destroy(err);\n        else if (!readable && !writable)\n          d.destroy();\n      }\n      if (d = new Duplexify({\n        readableObjectMode: !!(r !== null && r !== void 0 && r.readableObjectMode),\n        writableObjectMode: !!(w !== null && w !== void 0 && w.writableObjectMode),\n        readable,\n        writable\n      }), writable)\n        eos(w, (err) => {\n          if (writable = !1, err)\n            destroyer(r, err);\n          onfinished(err);\n        }), d._write = function(chunk, encoding, callback) {\n          if (w.write(chunk, encoding))\n            callback();\n          else\n            ondrain = callback;\n        }, d._final = function(callback) {\n          w.end(), onfinish = callback;\n        }, w.on(\"drain\", function() {\n          if (ondrain) {\n            const cb = ondrain;\n            ondrain = null, cb();\n          }\n        }), w.on(\"finish\", function() {\n          if (onfinish) {\n            const cb = onfinish;\n            onfinish = null, cb();\n          }\n        });\n      if (readable)\n        eos(r, (err) => {\n          if (readable = !1, err)\n            destroyer(r, err);\n          onfinished(err);\n        }), r.on(\"readable\", function() {\n          if (onreadable) {\n            const cb = onreadable;\n            onreadable = null, cb();\n          }\n        }), r.on(\"end\", function() {\n          d.push(null);\n        }), d._read = function() {\n          while (!0) {\n            const buf = r.read();\n            if (buf === null) {\n              onreadable = d._read;\n              return;\n            }\n            if (!d.push(buf))\n              return;\n          }\n        };\n      return d._destroy = function(err, callback) {\n        if (!err && onclose !== null)\n          err = new AbortError2;\n        if (onreadable = null, ondrain = null, onfinish = null, onclose === null)\n          callback(err);\n        else\n          onclose = callback, destroyer(w, err), destroyer(r, err);\n      }, d;\n    }\n  }\n}), require_duplex = __commonJS({\n  \"node_modules/readable-stream/lib/internal/streams/duplex.js\"(exports, module) {\n    var { ObjectDefineProperties, ObjectGetOwnPropertyDescriptor, ObjectKeys, ObjectSetPrototypeOf } = require_primordials(), Readable = require_readable();\n    function Duplex(options) {\n      if (!(this instanceof Duplex))\n        return new Duplex(options);\n      if (Readable.call(this, options), Writable.call(this, options), options) {\n        if (this.allowHalfOpen = options.allowHalfOpen !== !1, options.readable === !1)\n          this._readableState.readable = !1, this._readableState.ended = !0, this._readableState.endEmitted = !0;\n        if (options.writable === !1)\n          this._writableState.writable = !1, this._writableState.ending = !0, this._writableState.ended = !0, this._writableState.finished = !0;\n      } else\n        this.allowHalfOpen = !0;\n    }\n    Duplex.prototype = {}, module.exports = Duplex, ObjectSetPrototypeOf(Duplex.prototype, Readable.prototype), ObjectSetPrototypeOf(Duplex, Readable);\n    for (var method in Writable.prototype)\n      if (!Duplex.prototype[method])\n        Duplex.prototype[method] = Writable.prototype[method];\n    ObjectDefineProperties(Duplex.prototype, {\n      writable: ObjectGetOwnPropertyDescriptor(Writable.prototype, \"writable\"),\n      writableHighWaterMark: ObjectGetOwnPropertyDescriptor(Writable.prototype, \"writableHighWaterMark\"),\n      writableObjectMode: ObjectGetOwnPropertyDescriptor(Writable.prototype, \"writableObjectMode\"),\n      writableBuffer: ObjectGetOwnPropertyDescriptor(Writable.prototype, \"writableBuffer\"),\n      writableLength: ObjectGetOwnPropertyDescriptor(Writable.prototype, \"writableLength\"),\n      writableFinished: ObjectGetOwnPropertyDescriptor(Writable.prototype, \"writableFinished\"),\n      writableCorked: ObjectGetOwnPropertyDescriptor(Writable.prototype, \"writableCorked\"),\n      writableEnded: ObjectGetOwnPropertyDescriptor(Writable.prototype, \"writableEnded\"),\n      writableNeedDrain: ObjectGetOwnPropertyDescriptor(Writable.prototype, \"writableNeedDrain\"),\n      destroyed: {\n        get() {\n          if (this._readableState === void 0 || this._writableState === void 0)\n            return !1;\n          return this._readableState.destroyed && this._writableState.destroyed;\n        },\n        set(value) {\n          if (this._readableState && this._writableState)\n            this._readableState.destroyed = value, this._writableState.destroyed = value;\n        }\n      }\n    });\n    var webStreamsAdapters;\n    function lazyWebStreams() {\n      if (webStreamsAdapters === void 0)\n        webStreamsAdapters = {};\n      return webStreamsAdapters;\n    }\n    Duplex.fromWeb = function(pair, options) {\n      return lazyWebStreams().newStreamDuplexFromReadableWritablePair(pair, options);\n    }, Duplex.toWeb = function(duplex) {\n      return lazyWebStreams().newReadableWritablePairFromDuplex(duplex);\n    };\n    var duplexify;\n    Duplex.from = function(body) {\n      if (!duplexify)\n        duplexify = require_duplexify();\n      return duplexify(body, \"body\");\n    };\n  }\n}), require_transform = __commonJS({\n  \"node_modules/readable-stream/lib/internal/streams/transform.js\"(exports, module) {\n    var { ObjectSetPrototypeOf, Symbol: Symbol2 } = require_primordials(), { ERR_METHOD_NOT_IMPLEMENTED } = require_errors().codes, Duplex = require_duplex();\n    function Transform(options) {\n      if (!(this instanceof Transform))\n        return new Transform(options);\n      if (Duplex.call(this, options), this._readableState.sync = !1, this[kCallback] = null, options) {\n        if (typeof options.transform === \"function\")\n          this._transform = options.transform;\n        if (typeof options.flush === \"function\")\n          this._flush = options.flush;\n      }\n      this.on(\"prefinish\", prefinish.bind(this));\n    }\n    Transform.prototype = {}, ObjectSetPrototypeOf(Transform.prototype, Duplex.prototype), ObjectSetPrototypeOf(Transform, Duplex), module.exports = Transform;\n    var kCallback = Symbol2(\"kCallback\");\n    function final(cb) {\n      if (typeof this._flush === \"function\" && !this.destroyed)\n        this._flush((er, data) => {\n          if (er) {\n            if (cb)\n              cb(er);\n            else\n              this.destroy(er);\n            return;\n          }\n          if (data != null)\n            this.push(data);\n          if (this.push(null), cb)\n            cb();\n        });\n      else if (this.push(null), cb)\n        cb();\n    }\n    function prefinish() {\n      if (this._final !== final)\n        final.call(this);\n    }\n    Transform.prototype._final = final, Transform.prototype._transform = function(chunk, encoding, callback) {\n      throw new ERR_METHOD_NOT_IMPLEMENTED(\"_transform()\");\n    }, Transform.prototype._write = function(chunk, encoding, callback) {\n      const rState = this._readableState, wState = this._writableState, length = rState.length;\n      this._transform(chunk, encoding, (err, val) => {\n        if (err) {\n          callback(err);\n          return;\n        }\n        if (val != null)\n          this.push(val);\n        if (wState.ended || length === rState.length || rState.length < rState.highWaterMark || rState.highWaterMark === 0 || rState.length === 0)\n          callback();\n        else\n          this[kCallback] = callback;\n      });\n    }, Transform.prototype._read = function() {\n      if (this[kCallback]) {\n        const callback = this[kCallback];\n        this[kCallback] = null, callback();\n      }\n    };\n  }\n}), require_passthrough = __commonJS({\n  \"node_modules/readable-stream/lib/internal/streams/passthrough.js\"(exports, module) {\n    var { ObjectSetPrototypeOf } = require_primordials(), Transform = require_transform();\n    function PassThrough(options) {\n      if (!(this instanceof PassThrough))\n        return new PassThrough(options);\n      Transform.call(this, options);\n    }\n    PassThrough.prototype = {}, ObjectSetPrototypeOf(PassThrough.prototype, Transform.prototype), ObjectSetPrototypeOf(PassThrough, Transform), PassThrough.prototype._transform = function(chunk, encoding, cb) {\n      cb(null, chunk);\n    }, module.exports = PassThrough;\n  }\n}), require_pipeline = __commonJS({\n  \"node_modules/readable-stream/lib/internal/streams/pipeline.js\"(exports, module) {\n    var { ArrayIsArray: ArrayIsArray2, Promise: Promise2, SymbolAsyncIterator } = require_primordials(), eos = require_end_of_stream(), { once } = require_util(), destroyImpl = require_destroy(), Duplex = require_duplex(), {\n      aggregateTwoErrors,\n      codes: { ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE2, ERR_INVALID_RETURN_VALUE, ERR_MISSING_ARGS, ERR_STREAM_DESTROYED },\n      AbortError: AbortError2\n    } = require_errors(), { validateFunction, validateAbortSignal } = require_validators(), { isIterable, isReadable, isReadableNodeStream, isNodeStream } = require_utils(), PassThrough, Readable;\n    function destroyer(stream, reading, writing) {\n      let finished2 = !1;\n      stream.on(\"close\", () => {\n        finished2 = !0;\n      });\n      const cleanup = eos(stream, {\n        readable: reading,\n        writable: writing\n      }, (err) => {\n        finished2 = !err;\n      });\n      return {\n        destroy: (err) => {\n          if (finished2)\n            return;\n          finished2 = !0, destroyImpl.destroyer(stream, err || new ERR_STREAM_DESTROYED(\"pipe\"));\n        },\n        cleanup\n      };\n    }\n    function popCallback(streams) {\n      return validateFunction(streams[streams.length - 1], \"streams[stream.length - 1]\"), streams.pop();\n    }\n    function makeAsyncIterable(val) {\n      if (isIterable(val))\n        return val;\n      else if (isReadableNodeStream(val))\n        return fromReadable(val);\n      throw new ERR_INVALID_ARG_TYPE2(\"val\", [\"Readable\", \"Iterable\", \"AsyncIterable\"], val);\n    }\n    async function* fromReadable(val) {\n      if (!Readable)\n        Readable = require_readable();\n      yield* Readable.prototype[SymbolAsyncIterator].call(val);\n    }\n    async function pump(iterable, writable, finish, { end }) {\n      let error, onresolve = null;\n      const resume = (err) => {\n        if (err)\n          error = err;\n        if (onresolve) {\n          const callback = onresolve;\n          onresolve = null, callback();\n        }\n      }, wait = () => new Promise2((resolve, reject) => {\n        if (error)\n          reject(error);\n        else\n          onresolve = () => {\n            if (error)\n              reject(error);\n            else\n              resolve();\n          };\n      });\n      writable.on(\"drain\", resume);\n      const cleanup = eos(writable, {\n        readable: !1\n      }, resume);\n      try {\n        if (writable.writableNeedDrain)\n          await wait();\n        for await (let chunk of iterable)\n          if (!writable.write(chunk))\n            await wait();\n        if (end)\n          writable.end();\n        await wait(), finish();\n      } catch (err) {\n        finish(error !== err \? aggregateTwoErrors(error, err) : err);\n      } finally {\n        cleanup(), writable.off(\"drain\", resume);\n      }\n    }\n    function pipeline(...streams) {\n      return pipelineImpl(streams, once(popCallback(streams)));\n    }\n    function pipelineImpl(streams, callback, opts) {\n      if (streams.length === 1 && ArrayIsArray2(streams[0]))\n        streams = streams[0];\n      if (streams.length < 2)\n        throw new ERR_MISSING_ARGS(\"streams\");\n      const ac = new AbortController, signal = ac.signal, outerSignal = opts === null || opts === void 0 \? void 0 : opts.signal, lastStreamCleanup = [];\n      validateAbortSignal(outerSignal, \"options.signal\");\n      function abort() {\n        finishImpl(new AbortError2);\n      }\n      outerSignal === null || outerSignal === void 0 || outerSignal.addEventListener(\"abort\", abort);\n      let error, value;\n      const destroys = [];\n      let finishCount = 0;\n      function finish(err) {\n        finishImpl(err, --finishCount === 0);\n      }\n      function finishImpl(err, final) {\n        if (err && (!error || error.code === \"ERR_STREAM_PREMATURE_CLOSE\"))\n          error = err;\n        if (!error && !final)\n          return;\n        while (destroys.length)\n          destroys.shift()(error);\n        if (outerSignal === null || outerSignal === void 0 || outerSignal.removeEventListener(\"abort\", abort), ac.abort(), final) {\n          if (!error)\n            lastStreamCleanup.forEach((fn) => fn());\n          runOnNextTick(callback, error, value);\n        }\n      }\n      let ret;\n      for (let i = 0;i < streams.length; i++) {\n        const stream = streams[i], reading = i < streams.length - 1, writing = i > 0, end = reading || (opts === null || opts === void 0 \? void 0 : opts.end) !== !1, isLastStream = i === streams.length - 1;\n        if (isNodeStream(stream)) {\n          let onError = function(err) {\n            if (err && err.name !== \"AbortError\" && err.code !== \"ERR_STREAM_PREMATURE_CLOSE\")\n              finish(err);\n          };\n          if (end) {\n            const { destroy: destroy2, cleanup } = destroyer(stream, reading, writing);\n            if (destroys.push(destroy2), isReadable(stream) && isLastStream)\n              lastStreamCleanup.push(cleanup);\n          }\n          if (stream.on(\"error\", onError), isReadable(stream) && isLastStream)\n            lastStreamCleanup.push(() => {\n              stream.removeListener(\"error\", onError);\n            });\n        }\n        if (i === 0)\n          if (typeof stream === \"function\") {\n            if (ret = stream({\n              signal\n            }), !isIterable(ret))\n              throw new ERR_INVALID_RETURN_VALUE(\"Iterable, AsyncIterable or Stream\", \"source\", ret);\n          } else if (isIterable(stream) || isReadableNodeStream(stream))\n            ret = stream;\n          else\n            ret = Duplex.from(stream);\n        else if (typeof stream === \"function\")\n          if (ret = makeAsyncIterable(ret), ret = stream(ret, {\n            signal\n          }), reading) {\n            if (!isIterable(ret, !0))\n              throw new ERR_INVALID_RETURN_VALUE(\"AsyncIterable\", `transform[${i - 1}]`, ret);\n          } else {\n            var _ret;\n            if (!PassThrough)\n              PassThrough = require_passthrough();\n            const pt = new PassThrough({\n              objectMode: !0\n            }), then = (_ret = ret) === null || _ret === void 0 \? void 0 : _ret.then;\n            if (typeof then === \"function\")\n              finishCount++, then.call(ret, (val) => {\n                if (value = val, val != null)\n                  pt.write(val);\n                if (end)\n                  pt.end();\n                runOnNextTick(finish);\n              }, (err) => {\n                pt.destroy(err), runOnNextTick(finish, err);\n              });\n            else if (isIterable(ret, !0))\n              finishCount++, pump(ret, pt, finish, {\n                end\n              });\n            else\n              throw new ERR_INVALID_RETURN_VALUE(\"AsyncIterable or Promise\", \"destination\", ret);\n            ret = pt;\n            const { destroy: destroy2, cleanup } = destroyer(ret, !1, !0);\n            if (destroys.push(destroy2), isLastStream)\n              lastStreamCleanup.push(cleanup);\n          }\n        else if (isNodeStream(stream)) {\n          if (isReadableNodeStream(ret)) {\n            finishCount += 2;\n            const cleanup = pipe(ret, stream, finish, {\n              end\n            });\n            if (isReadable(stream) && isLastStream)\n              lastStreamCleanup.push(cleanup);\n          } else if (isIterable(ret))\n            finishCount++, pump(ret, stream, finish, {\n              end\n            });\n          else\n            throw new ERR_INVALID_ARG_TYPE2(\"val\", [\"Readable\", \"Iterable\", \"AsyncIterable\"], ret);\n          ret = stream;\n        } else\n          ret = Duplex.from(stream);\n      }\n      if (signal !== null && signal !== void 0 && signal.aborted || outerSignal !== null && outerSignal !== void 0 && outerSignal.aborted)\n        runOnNextTick(abort);\n      return ret;\n    }\n    function pipe(src, dst, finish, { end }) {\n      if (src.pipe(dst, {\n        end\n      }), end)\n        src.once(\"end\", () => dst.end());\n      else\n        finish();\n      return eos(src, {\n        readable: !0,\n        writable: !1\n      }, (err) => {\n        const rState = src._readableState;\n        if (err && err.code === \"ERR_STREAM_PREMATURE_CLOSE\" && rState && rState.ended && !rState.errored && !rState.errorEmitted)\n          src.once(\"end\", finish).once(\"error\", finish);\n        else\n          finish(err);\n      }), eos(dst, {\n        readable: !1,\n        writable: !0\n      }, finish);\n    }\n    module.exports = {\n      pipelineImpl,\n      pipeline\n    };\n  }\n}), require_compose = __commonJS({\n  \"node_modules/readable-stream/lib/internal/streams/compose.js\"(exports, module) {\n    var { pipeline } = require_pipeline(), Duplex = require_duplex(), { destroyer } = require_destroy(), { isNodeStream, isReadable, isWritable } = require_utils(), {\n      AbortError: AbortError2,\n      codes: { ERR_INVALID_ARG_VALUE: ERR_INVALID_ARG_VALUE2, ERR_MISSING_ARGS }\n    } = require_errors();\n    module.exports = function compose(...streams) {\n      if (streams.length === 0)\n        throw new ERR_MISSING_ARGS(\"streams\");\n      if (streams.length === 1)\n        return Duplex.from(streams[0]);\n      const orgStreams = [...streams];\n      if (typeof streams[0] === \"function\")\n        streams[0] = Duplex.from(streams[0]);\n      if (typeof streams[streams.length - 1] === \"function\") {\n        const idx = streams.length - 1;\n        streams[idx] = Duplex.from(streams[idx]);\n      }\n      for (let n = 0;n < streams.length; ++n) {\n        if (!isNodeStream(streams[n]))\n          continue;\n        if (n < streams.length - 1 && !isReadable(streams[n]))\n          throw new ERR_INVALID_ARG_VALUE2(`streams[${n}]`, orgStreams[n], \"must be readable\");\n        if (n > 0 && !isWritable(streams[n]))\n          throw new ERR_INVALID_ARG_VALUE2(`streams[${n}]`, orgStreams[n], \"must be writable\");\n      }\n      let ondrain, onfinish, onreadable, onclose, d;\n      function onfinished(err) {\n        const cb = onclose;\n        if (onclose = null, cb)\n          cb(err);\n        else if (err)\n          d.destroy(err);\n        else if (!readable && !writable)\n          d.destroy();\n      }\n      const head = streams[0], tail = pipeline(streams, onfinished), writable = !!isWritable(head), readable = !!isReadable(tail);\n      if (d = new Duplex({\n        writableObjectMode: !!(head !== null && head !== void 0 && head.writableObjectMode),\n        readableObjectMode: !!(tail !== null && tail !== void 0 && tail.writableObjectMode),\n        writable,\n        readable\n      }), writable)\n        d._write = function(chunk, encoding, callback) {\n          if (head.write(chunk, encoding))\n            callback();\n          else\n            ondrain = callback;\n        }, d._final = function(callback) {\n          head.end(), onfinish = callback;\n        }, head.on(\"drain\", function() {\n          if (ondrain) {\n            const cb = ondrain;\n            ondrain = null, cb();\n          }\n        }), tail.on(\"finish\", function() {\n          if (onfinish) {\n            const cb = onfinish;\n            onfinish = null, cb();\n          }\n        });\n      if (readable)\n        tail.on(\"readable\", function() {\n          if (onreadable) {\n            const cb = onreadable;\n            onreadable = null, cb();\n          }\n        }), tail.on(\"end\", function() {\n          d.push(null);\n        }), d._read = function() {\n          while (!0) {\n            const buf = tail.read();\n            if (buf === null) {\n              onreadable = d._read;\n              return;\n            }\n            if (!d.push(buf))\n              return;\n          }\n        };\n      return d._destroy = function(err, callback) {\n        if (!err && onclose !== null)\n          err = new AbortError2;\n        if (onreadable = null, ondrain = null, onfinish = null, onclose === null)\n          callback(err);\n        else\n          onclose = callback, destroyer(tail, err);\n      }, d;\n    };\n  }\n}), require_promises = __commonJS({\n  \"node_modules/readable-stream/lib/stream/promises.js\"(exports, module) {\n    var { ArrayPrototypePop, Promise: Promise2 } = require_primordials(), { isIterable, isNodeStream } = require_utils(), { pipelineImpl: pl } = require_pipeline(), { finished: finished2 } = require_end_of_stream();\n    function pipeline(...streams) {\n      return new Promise2((resolve, reject) => {\n        let signal, end;\n        const lastArg = streams[streams.length - 1];\n        if (lastArg && typeof lastArg === \"object\" && !isNodeStream(lastArg) && !isIterable(lastArg)) {\n          const options = ArrayPrototypePop(streams);\n          signal = options.signal, end = options.end;\n        }\n        pl(streams, (err, value) => {\n          if (err)\n            reject(err);\n          else\n            resolve(value);\n        }, {\n          signal,\n          end\n        });\n      });\n    }\n    module.exports = {\n      finished: finished2,\n      pipeline\n    };\n  }\n}), require_stream = __commonJS({\n  \"node_modules/readable-stream/lib/stream.js\"(exports, module) {\n    var { ObjectDefineProperty, ObjectKeys, ReflectApply } = require_primordials(), {\n      promisify: { custom: customPromisify }\n    } = require_util(), { streamReturningOperators, promiseReturningOperators } = require_operators(), {\n      codes: { ERR_ILLEGAL_CONSTRUCTOR }\n    } = require_errors(), compose = require_compose(), { pipeline } = require_pipeline(), { destroyer } = require_destroy(), eos = require_end_of_stream(), promises = require_promises(), utils = require_utils(), Stream = module.exports = require_legacy().Stream;\n    Stream.isDisturbed = utils.isDisturbed, Stream.isErrored = utils.isErrored, Stream.isWritable = utils.isWritable, Stream.isReadable = utils.isReadable, Stream.Readable = require_readable();\n    for (let key of ObjectKeys(streamReturningOperators)) {\n      let fn = function(...args) {\n        if (new.target)\n          throw ERR_ILLEGAL_CONSTRUCTOR();\n        return Stream.Readable.from(ReflectApply(op, this, args));\n      };\n      const op = streamReturningOperators[key];\n      ObjectDefineProperty(fn, \"name\", {\n        value: op.name\n      }), ObjectDefineProperty(fn, \"length\", {\n        value: op.length\n      }), ObjectDefineProperty(Stream.Readable.prototype, key, {\n        value: fn,\n        enumerable: !1,\n        configurable: !0,\n        writable: !0\n      });\n    }\n    for (let key of ObjectKeys(promiseReturningOperators)) {\n      let fn = function(...args) {\n        if (new.target)\n          throw ERR_ILLEGAL_CONSTRUCTOR();\n        return ReflectApply(op, this, args);\n      };\n      const op = promiseReturningOperators[key];\n      ObjectDefineProperty(fn, \"name\", {\n        value: op.name\n      }), ObjectDefineProperty(fn, \"length\", {\n        value: op.length\n      }), ObjectDefineProperty(Stream.Readable.prototype, key, {\n        value: fn,\n        enumerable: !1,\n        configurable: !0,\n        writable: !0\n      });\n    }\n    Stream.Writable = require_writable(), Stream.Duplex = require_duplex(), Stream.Transform = require_transform(), Stream.PassThrough = require_passthrough(), Stream.pipeline = pipeline;\n    var { addAbortSignal } = require_add_abort_signal();\n    Stream.addAbortSignal = addAbortSignal, Stream.finished = eos, Stream.destroy = destroyer, Stream.compose = compose, ObjectDefineProperty(Stream, \"promises\", {\n      configurable: !0,\n      enumerable: !0,\n      get() {\n        return promises;\n      }\n    }), ObjectDefineProperty(pipeline, customPromisify, {\n      enumerable: !0,\n      get() {\n        return promises.pipeline;\n      }\n    }), ObjectDefineProperty(eos, customPromisify, {\n      enumerable: !0,\n      get() {\n        return promises.finished;\n      }\n    }), Stream.Stream = Stream, Stream._isUint8Array = function isUint8Array(value) {\n      return value instanceof Uint8Array;\n    }, Stream._uint8ArrayToBuffer = function _uint8ArrayToBuffer(chunk) {\n      return new Buffer(chunk.buffer, chunk.byteOffset, chunk.byteLength);\n    };\n  }\n}), nativeReadableStreamPrototypes = {\n  0: void 0,\n  1: void 0,\n  2: void 0,\n  3: void 0,\n  4: void 0,\n  5: void 0\n}, Writable = require_writable(), NativeWritable = class NativeWritable2 extends Writable {\n  #pathOrFdOrSink;\n  #fileSink;\n  #native = !0;\n  _construct;\n  _destroy;\n  _final;\n  constructor(pathOrFdOrSink, options = {}) {\n    super(options);\n    this._construct = this.#internalConstruct, this._destroy = this.#internalDestroy, this._final = this.#internalFinal, this.#pathOrFdOrSink = pathOrFdOrSink;\n  }\n  #internalConstruct(cb) {\n    this._writableState.constructed = !0, this.constructed = !0, cb();\n  }\n  #lazyConstruct() {\n    if (typeof this.#pathOrFdOrSink === \"object\")\n      if (typeof this.#pathOrFdOrSink.write === \"function\")\n        this.#fileSink = this.#pathOrFdOrSink;\n      else\n        throw new Error(\"Invalid FileSink\");\n    else\n      this.#fileSink = Bun.file(this.#pathOrFdOrSink).writer();\n  }\n  write(chunk, encoding, cb, native = this.#native) {\n    if (!native)\n      return this.#native = !1, super.write(chunk, encoding, cb);\n    if (!this.#fileSink)\n      this.#lazyConstruct();\n    var fileSink = this.#fileSink, result = fileSink.write(chunk);\n    if (@isPromise(result))\n      return result.then(() => {\n        this.emit(\"drain\"), fileSink.flush(!0);\n      }), !1;\n    if (fileSink.flush(!0), cb)\n      cb(null, chunk.byteLength);\n    return !0;\n  }\n  end(chunk, encoding, cb, native = this.#native) {\n    return super.end(chunk, encoding, cb, native);\n  }\n  #internalDestroy(error, cb) {\n    if (this._writableState.destroyed = !0, cb)\n      cb(error);\n  }\n  #internalFinal(cb) {\n    if (this.#fileSink)\n      this.#fileSink.end();\n    if (cb)\n      cb();\n  }\n  ref() {\n    if (!this.#fileSink)\n      this.#lazyConstruct();\n    this.#fileSink.ref();\n  }\n  unref() {\n    if (!this.#fileSink)\n      return;\n    this.#fileSink.unref();\n  }\n}, exports = require_stream(), promises = require_promises();\nexports._getNativeReadableStreamPrototype = getNativeReadableStreamPrototype;\nexports.NativeWritable = NativeWritable;\nObject.defineProperty(exports, \"promises\", {\n  configurable: !0,\n  enumerable: !0,\n  get() {\n    return promises;\n  }\n});\nexports[Symbol.for(\"::bunternal::\")] = { _ReadableFromWeb, _ReadableFromWebForUndici };\nexports.eos = require_end_of_stream();\nreturn exports})\n"_s;
//

//
static constexpr ASCIILiteral NodeStreamPromisesCode = "(function (){\"use strict\";// src/js/out/tmp/node/stream.promises.ts\nreturn (@getInternalField(@internalModuleRegistry, 35) || @createInternalModuleById(35)).promises})\n"_s;
//

//
static constexpr ASCIILiteral NodeStreamWebCode = "(function (){\"use strict\";// src/js/out/tmp/node/stream.web.ts\nvar $;\n$ = {\n  ReadableStream,\n  ReadableStreamDefaultReader,\n  ReadableStreamBYOBReader,\n  ReadableStreamBYOBRequest,\n  ReadableByteStreamController,\n  ReadableStreamDefaultController,\n  TransformStream,\n  TransformStreamDefaultController,\n  WritableStream,\n  WritableStreamDefaultWriter,\n  WritableStreamDefaultController,\n  ByteLengthQueuingStrategy,\n  CountQueuingStrategy\n};\nreturn $})\n"_s;
//

//
static constexpr ASCIILiteral NodeTimersCode = "(function (){\"use strict\";// src/js/out/tmp/node/timers.ts\nvar $;\n$ = {\n  setTimeout,\n  clearTimeout,\n  setInterval,\n  setImmediate,\n  clearInterval,\n  clearImmediate\n};\nreturn $})\n"_s;
//

//
static constexpr ASCIILiteral NodeTimersPromisesCode = "(function (){\"use strict\";// src/js/out/tmp/node/timers.promises.ts\nvar validateObject = function(object, name) {\n  if (object === null || typeof object !== \"object\")\n    throw new ERR_INVALID_ARG_TYPE(name, \"Object\", object);\n}, validateBoolean = function(value, name) {\n  if (typeof value !== \"boolean\")\n    throw new ERR_INVALID_ARG_TYPE(name, \"boolean\", value);\n}, validateAbortSignal = function(signal, name) {\n  if (typeof signal !== \"undefined\" && (signal === null || typeof signal !== \"object\" || !(\"aborted\" in signal)))\n    throw new ERR_INVALID_ARG_TYPE(name, \"AbortSignal\", signal);\n}, asyncIterator = function({ next: nextFunction, return: returnFunction }) {\n  const result = {};\n  if (typeof nextFunction === \"function\")\n    result.next = nextFunction;\n  if (typeof returnFunction === \"function\")\n    result.return = returnFunction;\n  return result[symbolAsyncIterator] = function() {\n    return this;\n  }, result;\n}, setTimeoutPromise = function(after = 1, value, options = {}) {\n  const arguments_ = [].concat(value \?\? []);\n  try {\n    validateObject(options, \"options\");\n  } catch (error) {\n    return Promise.reject(error);\n  }\n  const { signal, ref: reference = !0 } = options;\n  try {\n    validateAbortSignal(signal, \"options.signal\");\n  } catch (error) {\n    return Promise.reject(error);\n  }\n  try {\n    validateBoolean(reference, \"options.ref\");\n  } catch (error) {\n    return Promise.reject(error);\n  }\n  if (signal\?.aborted)\n    return Promise.reject(new AbortError);\n  let onCancel;\n  const returnValue = new Promise((resolve, reject) => {\n    const timeout = setTimeout(() => resolve(value), after, ...arguments_);\n    if (!reference)\n      timeout\?.unref\?.();\n    if (signal)\n      onCancel = () => {\n        clearTimeout(timeout), reject(new AbortError);\n      }, signal.addEventListener(\"abort\", onCancel);\n  });\n  if (typeof onCancel !== \"undefined\")\n    returnValue.finally(() => signal.removeEventListener(\"abort\", onCancel));\n  return returnValue;\n}, setImmediatePromise = function(value, options = {}) {\n  try {\n    validateObject(options, \"options\");\n  } catch (error) {\n    return Promise.reject(error);\n  }\n  const { signal, ref: reference = !0 } = options;\n  try {\n    validateAbortSignal(signal, \"options.signal\");\n  } catch (error) {\n    return Promise.reject(error);\n  }\n  try {\n    validateBoolean(reference, \"options.ref\");\n  } catch (error) {\n    return Promise.reject(error);\n  }\n  if (signal\?.aborted)\n    return Promise.reject(new AbortError);\n  let onCancel;\n  const returnValue = new Promise((resolve, reject) => {\n    const immediate = setImmediate(() => resolve(value));\n    if (!reference)\n      immediate\?.unref\?.();\n    if (signal)\n      onCancel = () => {\n        clearImmediate(immediate), reject(new AbortError);\n      }, signal.addEventListener(\"abort\", onCancel);\n  });\n  if (typeof onCancel !== \"undefined\")\n    returnValue.finally(() => signal.removeEventListener(\"abort\", onCancel));\n  return returnValue;\n}, setIntervalPromise = function(after = 1, value, options = {}) {\n  try {\n    validateObject(options, \"options\");\n  } catch (error) {\n    return asyncIterator({\n      next: function() {\n        return Promise.reject(error);\n      }\n    });\n  }\n  const { signal, ref: reference = !0 } = options;\n  try {\n    validateAbortSignal(signal, \"options.signal\");\n  } catch (error) {\n    return asyncIterator({\n      next: function() {\n        return Promise.reject(error);\n      }\n    });\n  }\n  try {\n    validateBoolean(reference, \"options.ref\");\n  } catch (error) {\n    return asyncIterator({\n      next: function() {\n        return Promise.reject(error);\n      }\n    });\n  }\n  if (signal\?.aborted)\n    return asyncIterator({\n      next: function() {\n        return Promise.reject(new AbortError);\n      }\n    });\n  let onCancel, interval;\n  try {\n    let notYielded = 0, callback;\n    if (interval = setInterval(() => {\n      if (notYielded++, callback)\n        callback(), callback = void 0;\n    }, after), !reference)\n      interval\?.unref\?.();\n    if (signal)\n      onCancel = () => {\n        if (clearInterval(interval), callback)\n          callback(), callback = void 0;\n      }, signal.addEventListener(\"abort\", onCancel);\n    return asyncIterator({\n      next: function() {\n        return new Promise((resolve, reject) => {\n          if (!signal\?.aborted)\n            if (notYielded === 0)\n              callback = resolve;\n            else\n              resolve();\n          else if (notYielded === 0)\n            reject(new AbortError);\n          else\n            resolve();\n        }).then(() => {\n          if (notYielded > 0)\n            return notYielded = notYielded - 1, { done: !1, value };\n          return { done: !0 };\n        });\n      },\n      return: function() {\n        return clearInterval(interval), signal\?.removeEventListener(\"abort\", onCancel), Promise.resolve({});\n      }\n    });\n  } catch (error) {\n    return asyncIterator({\n      next: function() {\n        clearInterval(interval), signal\?.removeEventListener(\"abort\", onCancel);\n      }\n    });\n  }\n}, $, symbolAsyncIterator = Symbol.asyncIterator;\n\nclass ERR_INVALID_ARG_TYPE extends Error {\n  constructor(name, expected, actual) {\n    super(`${name} must be ${expected}, ${typeof actual} given`);\n    this.code = \"ERR_INVALID_ARG_TYPE\";\n  }\n}\n\nclass AbortError extends Error {\n  constructor() {\n    super(\"The operation was aborted\");\n    this.code = \"ABORT_ERR\";\n  }\n}\n$ = {\n  setTimeout: setTimeoutPromise,\n  setImmediate: setImmediatePromise,\n  setInterval: setIntervalPromise,\n  scheduler: {\n    wait: (delay, options) => setTimeoutPromise(delay, void 0, options),\n    yield: setImmediatePromise\n  }\n};\nreturn $})\n"_s;
//

//
static constexpr ASCIILiteral NodeTLSCode = "(function (){\"use strict\";// src/js/out/tmp/node/tls.ts\nvar parseCertString = function() {\n  throwNotImplemented(\"Not implemented\");\n}, isValidTLSArray = function(obj) {\n  if (typeof obj === \"string\" || isTypedArray(obj) || obj instanceof ArrayBuffer || obj instanceof Blob)\n    return !0;\n  if (Array.isArray(obj)) {\n    for (var i = 0;i < obj.length; i++)\n      if (typeof obj !== \"string\" && !isTypedArray(obj) && !(obj instanceof ArrayBuffer) && !(obj instanceof Blob))\n        return !1;\n    return !0;\n  }\n}, unfqdn = function(host2) {\n  return RegExpPrototypeSymbolReplace.call(/[.]$/, host2, \"\");\n}, toLowerCase = function(c) {\n  return StringFromCharCode.call(32 + StringPrototypeCharCodeAt.call(c, 0));\n}, splitHost = function(host2) {\n  return StringPrototypeSplit.call(RegExpPrototypeSymbolReplace.call(/[A-Z]/g, unfqdn(host2), toLowerCase), \".\");\n}, check = function(hostParts, pattern, wildcards) {\n  if (!pattern)\n    return !1;\n  const patternParts = splitHost(pattern);\n  if (hostParts.length !== patternParts.length)\n    return !1;\n  if (ArrayPrototypeIncludes.call(patternParts, \"\"))\n    return !1;\n  const isBad = (s) => RegExpPrototypeExec.call(/[^\\u0021-\\u007F]/u, s) !== null;\n  if (ArrayPrototypeSome.call(patternParts, isBad))\n    return !1;\n  for (let i = hostParts.length - 1;i > 0; i -= 1)\n    if (hostParts[i] !== patternParts[i])\n      return !1;\n  const hostSubdomain = hostParts[0], patternSubdomain = patternParts[0], patternSubdomainParts = StringPrototypeSplit.call(patternSubdomain, \"*\");\n  if (patternSubdomainParts.length === 1 || StringPrototypeIncludes.call(patternSubdomain, \"xn--\"))\n    return hostSubdomain === patternSubdomain;\n  if (!wildcards)\n    return !1;\n  if (patternSubdomainParts.length > 2)\n    return !1;\n  if (patternParts.length <= 2)\n    return !1;\n  const { 0: prefix, 1: suffix } = patternSubdomainParts;\n  if (prefix.length + suffix.length > hostSubdomain.length)\n    return !1;\n  if (!StringPrototypeStartsWith.call(hostSubdomain, prefix))\n    return !1;\n  if (!StringPrototypeEndsWith.call(hostSubdomain, suffix))\n    return !1;\n  return !0;\n}, splitEscapedAltNames = function(altNames) {\n  const result = [];\n  let currentToken = \"\", offset = 0;\n  while (offset !== altNames.length) {\n    const nextSep = StringPrototypeIndexOf.call(altNames, \", \", offset), nextQuote = StringPrototypeIndexOf.call(altNames, '\"', offset);\n    if (nextQuote !== -1 && (nextSep === -1 || nextQuote < nextSep)) {\n      currentToken += StringPrototypeSubstring.call(altNames, offset, nextQuote);\n      const match = RegExpPrototypeExec.call(jsonStringPattern, StringPrototypeSubstring.call(altNames, nextQuote));\n      if (!match) {\n        let error = new SyntaxError(\"ERR_TLS_CERT_ALTNAME_FORMAT: Invalid subject alternative name string\");\n        throw error.name = ERR_TLS_CERT_ALTNAME_FORMAT, error;\n      }\n      currentToken += JSON.parse(match[0]), offset = nextQuote + match[0].length;\n    } else if (nextSep !== -1)\n      currentToken += StringPrototypeSubstring.call(altNames, offset, nextSep), ArrayPrototypePush.call(result, currentToken), currentToken = \"\", offset = nextSep + 2;\n    else\n      currentToken += StringPrototypeSubstring.call(altNames, offset), offset = altNames.length;\n  }\n  return ArrayPrototypePush.call(result, currentToken), result;\n}, checkServerIdentity = function(hostname, cert) {\n  const { subject, subjectaltname: altNames } = cert, dnsNames = [], ips = [];\n  if (hostname = \"\" + hostname, altNames) {\n    const splitAltNames = StringPrototypeIncludes.call(altNames, '\"') \? splitEscapedAltNames(altNames) : StringPrototypeSplit.call(altNames, \", \");\n    ArrayPrototypeForEach.call(splitAltNames, (name) => {\n      if (StringPrototypeStartsWith.call(name, \"DNS:\"))\n        ArrayPrototypePush.call(dnsNames, StringPrototypeSlice.call(name, 4));\n      else if (StringPrototypeStartsWith.call(name, \"IP Address:\"))\n        ArrayPrototypePush.call(ips, canonicalizeIP(StringPrototypeSlice.call(name, 11)));\n    });\n  }\n  let valid = !1, reason = \"Unknown reason\";\n  if (hostname = unfqdn(hostname), net.isIP(hostname)) {\n    if (valid = ArrayPrototypeIncludes.call(ips, canonicalizeIP(hostname)), !valid)\n      reason = `IP: ${hostname} is not in the cert's list: ` + ArrayPrototypeJoin.call(ips, \", \");\n  } else if (dnsNames.length > 0 || subject\?.CN) {\n    const hostParts = splitHost(hostname), wildcard = (pattern) => check(hostParts, pattern, !0);\n    if (dnsNames.length > 0) {\n      if (valid = ArrayPrototypeSome.call(dnsNames, wildcard), !valid)\n        reason = `Host: ${hostname}. is not in the cert's altnames: ${altNames}`;\n    } else {\n      const cn = subject.CN;\n      if (Array.isArray(cn))\n        valid = ArrayPrototypeSome.call(cn, wildcard);\n      else if (cn)\n        valid = wildcard(cn);\n      if (!valid)\n        reason = `Host: ${hostname}. is not cert's CN: ${cn}`;\n    }\n  } else\n    reason = \"Cert does not contain a DNS name\";\n  if (!valid) {\n    let error = new Error(`ERR_TLS_CERT_ALTNAME_INVALID: Hostname/IP does not match certificate's altnames: ${reason}`);\n    return error.name = \"ERR_TLS_CERT_ALTNAME_INVALID\", error.reason = reason, error.host = host, error.cert = cert, error;\n  }\n}, SecureContext = function(options) {\n  return new InternalSecureContext(options);\n}, createSecureContext = function(options) {\n  return new SecureContext(options);\n}, translatePeerCertificate = function(c) {\n  if (!c)\n    return null;\n  if (c.issuerCertificate != null && c.issuerCertificate !== c)\n    c.issuerCertificate = translatePeerCertificate(c.issuerCertificate);\n  if (c.infoAccess != null) {\n    const info = c.infoAccess;\n    c.infoAccess = { __proto__: null }, RegExpPrototypeSymbolReplace.call(/([^\\n:]*):([^\\n]*)(\?:\\n|$)/g, info, (all, key, val) => {\n      if (val.charCodeAt(0) === 34)\n        val = JSONParse(val);\n      if (key in c.infoAccess)\n        ArrayPrototypePush.call(c.infoAccess[key], val);\n      else\n        c.infoAccess[key] = [val];\n    });\n  }\n  return c;\n}, createServer = function(options, connectionListener) {\n  return new Server(options, connectionListener);\n}, getCiphers = function() {\n  return DEFAULT_CIPHERS.split(\":\");\n}, convertProtocols = function(protocols) {\n  const lens = new Array(protocols.length), buff = Buffer.allocUnsafe(ArrayPrototypeReduce.call(protocols, (p, c, i) => {\n    const len = Buffer.byteLength(c);\n    if (len > 255)\n      @throwRangeError(\"The byte length of the protocol at index \" + `${i} exceeds the maximum length.`, \"<= 255\", len, !0);\n    return lens[i] = len, p + 1 + len;\n  }, 0));\n  let offset = 0;\n  for (let i = 0, c = protocols.length;i < c; i++)\n    buff[offset++] = lens[i], buff.write(protocols[i], offset), offset += lens[i];\n  return buff;\n}, convertALPNProtocols = function(protocols, out) {\n  if (Array.isArray(protocols))\n    out.ALPNProtocols = convertProtocols(protocols);\n  else if (isTypedArray(protocols))\n    out.ALPNProtocols = Buffer.from(protocols);\n  else if (isArrayBufferView(protocols))\n    out.ALPNProtocols = Buffer.from(protocols.buffer.slice(protocols.byteOffset, protocols.byteOffset + protocols.byteLength));\n  else if (Buffer.isBuffer(protocols))\n    out.ALPNProtocols = protocols;\n}, $, { isArrayBufferView, isTypedArray } = @requireNativeModule(\"node:util/types\"), net = @getInternalField(@internalModuleRegistry, 23) || @createInternalModuleById(23), { Server: NetServer, [Symbol.for(\"::bunternal::\")]: InternalTCPSocket } = net, bunSocketInternal = Symbol.for(\"::bunnetsocketinternal::\"), { rootCertificates, canonicalizeIP } = globalThis[globalThis.Symbol.for('Bun.lazy')](\"internal/tls\"), SymbolReplace = Symbol.replace, RegExpPrototypeSymbolReplace = RegExp.prototype[SymbolReplace], RegExpPrototypeExec = RegExp.prototype.exec, StringPrototypeStartsWith = String.prototype.startsWith, StringPrototypeSlice = String.prototype.slice, StringPrototypeIncludes = String.prototype.includes, StringPrototypeSplit = String.prototype.split, StringPrototypeIndexOf = String.prototype.indexOf, StringPrototypeSubstring = String.prototype.substring, StringPrototypeEndsWith = String.prototype.endsWith, StringFromCharCode = String.fromCharCode, StringPrototypeCharCodeAt = String.prototype.charCodeAt, ArrayPrototypeIncludes = Array.prototype.includes, ArrayPrototypeJoin = Array.prototype.join, ArrayPrototypeForEach = Array.prototype.forEach, ArrayPrototypePush = Array.prototype.push, ArrayPrototypeSome = Array.prototype.some, ArrayPrototypeReduce = Array.prototype.reduce, jsonStringPattern = /^\"(\?:[^\"\\\\\\u0000-\\u001f]|\\\\(\?:[\"\\\\/bfnrt]|u[0-9a-fA-F]{4}))*\"/, InternalSecureContext = class SecureContext2 {\n  context;\n  constructor(options) {\n    const context = {};\n    if (options) {\n      let key = options.key;\n      if (key) {\n        if (!isValidTLSArray(key))\n          @throwTypeError(\"key argument must be an string, Buffer, TypedArray, BunFile or an array containing string, Buffer, TypedArray or BunFile\");\n        this.key = key;\n      }\n      let cert = options.cert;\n      if (cert) {\n        if (!isValidTLSArray(cert))\n          @throwTypeError(\"cert argument must be an string, Buffer, TypedArray, BunFile or an array containing string, Buffer, TypedArray or BunFile\");\n        this.cert = cert;\n      }\n      let ca = options.ca;\n      if (ca) {\n        if (!isValidTLSArray(ca))\n          @throwTypeError(\"ca argument must be an string, Buffer, TypedArray, BunFile or an array containing string, Buffer, TypedArray or BunFile\");\n        this.ca = ca;\n      }\n      let passphrase = options.passphrase;\n      if (passphrase && typeof passphrase !== \"string\")\n        @throwTypeError(\"passphrase argument must be an string\");\n      this.passphrase = passphrase;\n      let servername = options.servername;\n      if (servername && typeof servername !== \"string\")\n        @throwTypeError(\"servername argument must be an string\");\n      this.servername = servername;\n      let secureOptions = options.secureOptions || 0;\n      if (secureOptions && typeof secureOptions !== \"number\")\n        @throwTypeError(\"secureOptions argument must be an number\");\n      this.secureOptions = secureOptions;\n    }\n    this.context = context;\n  }\n}, buntls = Symbol.for(\"::buntls::\"), SocketClass, TLSSocket = function(InternalTLSSocket) {\n  return SocketClass = InternalTLSSocket, Object.defineProperty(SocketClass.prototype, Symbol.toStringTag, {\n    value: \"TLSSocket\",\n    enumerable: !1\n  }), Object.defineProperty(function Socket(options) {\n    return new InternalTLSSocket(options);\n  }, Symbol.hasInstance, {\n    value(instance) {\n      return instance instanceof InternalTLSSocket;\n    }\n  });\n}(class TLSSocket2 extends InternalTCPSocket {\n  #secureContext;\n  ALPNProtocols;\n  #socket;\n  #checkServerIdentity;\n  #session;\n  constructor(socket, options) {\n    super(socket instanceof InternalTCPSocket \? options : options || socket);\n    if (options = options || socket || {}, typeof options === \"object\") {\n      const { ALPNProtocols } = options;\n      if (ALPNProtocols)\n        convertALPNProtocols(ALPNProtocols, this);\n      if (socket instanceof InternalTCPSocket)\n        this.#socket = socket;\n    }\n    this.#secureContext = options.secureContext || createSecureContext(options), this.authorized = !1, this.secureConnecting = !0, this._secureEstablished = !1, this._securePending = !0, this.#checkServerIdentity = options.checkServerIdentity || checkServerIdentity, this.#session = options.session || null;\n  }\n  _secureEstablished = !1;\n  _securePending = !0;\n  _newSessionPending;\n  _controlReleased;\n  secureConnecting = !1;\n  _SNICallback;\n  servername;\n  authorized = !1;\n  authorizationError;\n  #renegotiationDisabled = !1;\n  encrypted = !0;\n  _start() {\n    this.connect();\n  }\n  getSession() {\n    return this[bunSocketInternal]\?.getSession();\n  }\n  getEphemeralKeyInfo() {\n    return this[bunSocketInternal]\?.getEphemeralKeyInfo();\n  }\n  getCipher() {\n    return this[bunSocketInternal]\?.getCipher();\n  }\n  getSharedSigalgs() {\n    return this[bunSocketInternal]\?.getSharedSigalgs();\n  }\n  getProtocol() {\n    return this[bunSocketInternal]\?.getTLSVersion();\n  }\n  getFinished() {\n    return this[bunSocketInternal]\?.getTLSFinishedMessage() || void 0;\n  }\n  getPeerFinished() {\n    return this[bunSocketInternal]\?.getTLSPeerFinishedMessage() || void 0;\n  }\n  isSessionReused() {\n    return !!this.#session;\n  }\n  renegotiate() {\n    if (this.#renegotiationDisabled) {\n      const error = new Error(\"ERR_TLS_RENEGOTIATION_DISABLED: TLS session renegotiation disabled for this socket\");\n      throw error.name = \"ERR_TLS_RENEGOTIATION_DISABLED\", error;\n    }\n    throw Error(\"Not implented in Bun yet\");\n  }\n  disableRenegotiation() {\n    this.#renegotiationDisabled = !0;\n  }\n  getTLSTicket() {\n    return this[bunSocketInternal]\?.getTLSTicket();\n  }\n  exportKeyingMaterial(length, label, context) {\n    if (context)\n      return this[bunSocketInternal]\?.exportKeyingMaterial(length, label, context);\n    return this[bunSocketInternal]\?.exportKeyingMaterial(length, label);\n  }\n  setMaxSendFragment(size) {\n    return this[bunSocketInternal]\?.setMaxSendFragment(size) || !1;\n  }\n  enableTrace() {\n  }\n  setServername(name) {\n    if (this.isServer) {\n      let error = new Error(\"ERR_TLS_SNI_FROM_SERVER: Cannot issue SNI from a TLS server-side socket\");\n      throw error.name = \"ERR_TLS_SNI_FROM_SERVER\", error;\n    }\n    this.servername = name, this[bunSocketInternal]\?.setServername(name);\n  }\n  setSession(session) {\n    if (this.#session = session, typeof session === \"string\")\n      session = Buffer.from(session, \"latin1\");\n    return this[bunSocketInternal]\?.setSession(session);\n  }\n  getPeerCertificate(abbreviated) {\n    const cert = arguments.length < 1 \? this[bunSocketInternal]\?.getPeerCertificate() : this[bunSocketInternal]\?.getPeerCertificate(abbreviated);\n    if (cert)\n      return translatePeerCertificate(cert);\n  }\n  getCertificate() {\n    const cert = this[bunSocketInternal]\?.getCertificate();\n    if (cert)\n      return translatePeerCertificate(cert);\n  }\n  getPeerX509Certificate() {\n    throw Error(\"Not implented in Bun yet\");\n  }\n  getX509Certificate() {\n    throw Error(\"Not implented in Bun yet\");\n  }\n  get alpnProtocol() {\n    return this[bunSocketInternal]\?.alpnProtocol;\n  }\n  [buntls](port, host2) {\n    return {\n      socket: this.#socket,\n      ALPNProtocols: this.ALPNProtocols,\n      serverName: this.servername || host2 || \"localhost\",\n      checkServerIdentity: this.#checkServerIdentity,\n      session: this.#session,\n      ...this.#secureContext\n    };\n  }\n});\n\nclass Server extends NetServer {\n  key;\n  cert;\n  ca;\n  passphrase;\n  secureOptions;\n  _rejectUnauthorized;\n  _requestCert;\n  servername;\n  ALPNProtocols;\n  constructor(options, secureConnectionListener) {\n    super(options, secureConnectionListener);\n    this.setSecureContext(options);\n  }\n  setSecureContext(options) {\n    if (options instanceof InternalSecureContext)\n      options = options.context;\n    if (options) {\n      const { ALPNProtocols } = options;\n      if (ALPNProtocols)\n        convertALPNProtocols(ALPNProtocols, this);\n      let key = options.key;\n      if (key) {\n        if (!isValidTLSArray(key))\n          @throwTypeError(\"key argument must be an string, Buffer, TypedArray, BunFile or an array containing string, Buffer, TypedArray or BunFile\");\n        this.key = key;\n      }\n      let cert = options.cert;\n      if (cert) {\n        if (!isValidTLSArray(cert))\n          @throwTypeError(\"cert argument must be an string, Buffer, TypedArray, BunFile or an array containing string, Buffer, TypedArray or BunFile\");\n        this.cert = cert;\n      }\n      let ca = options.ca;\n      if (ca) {\n        if (!isValidTLSArray(ca))\n          @throwTypeError(\"ca argument must be an string, Buffer, TypedArray, BunFile or an array containing string, Buffer, TypedArray or BunFile\");\n        this.ca = ca;\n      }\n      let passphrase = options.passphrase;\n      if (passphrase && typeof passphrase !== \"string\")\n        @throwTypeError(\"passphrase argument must be an string\");\n      this.passphrase = passphrase;\n      let servername = options.servername;\n      if (servername && typeof servername !== \"string\")\n        @throwTypeError(\"servername argument must be an string\");\n      this.servername = servername;\n      let secureOptions = options.secureOptions || 0;\n      if (secureOptions && typeof secureOptions !== \"number\")\n        @throwTypeError(\"secureOptions argument must be an number\");\n      this.secureOptions = secureOptions;\n      const requestCert = options.requestCert || !1;\n      if (requestCert)\n        this._requestCert = requestCert;\n      else\n        this._requestCert = void 0;\n      const rejectUnauthorized = options.rejectUnauthorized || !1;\n      if (rejectUnauthorized)\n        this._rejectUnauthorized = rejectUnauthorized;\n      else\n        this._rejectUnauthorized = void 0;\n    }\n  }\n  getTicketKeys() {\n    throw Error(\"Not implented in Bun yet\");\n  }\n  setTicketKeys() {\n    throw Error(\"Not implented in Bun yet\");\n  }\n  [buntls](port, host2, isClient) {\n    return [\n      {\n        serverName: this.servername || host2 || \"localhost\",\n        key: this.key,\n        cert: this.cert,\n        ca: this.ca,\n        passphrase: this.passphrase,\n        secureOptions: this.secureOptions,\n        rejectUnauthorized: isClient \? !1 : this._rejectUnauthorized,\n        requestCert: isClient \? !1 : this._requestCert,\n        ALPNProtocols: this.ALPNProtocols\n      },\n      SocketClass\n    ];\n  }\n}\nvar CLIENT_RENEG_LIMIT = 3, CLIENT_RENEG_WINDOW = 600, DEFAULT_ECDH_CURVE = \"auto\", DEFAULT_CIPHERS = \"DHE-RSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-RSA-AES128-GCM-SHA256\", DEFAULT_MIN_VERSION = \"TLSv1.2\", DEFAULT_MAX_VERSION = \"TLSv1.3\", createConnection = (port, host2, connectListener) => {\n  if (typeof port === \"object\") {\n    port.checkServerIdentity;\n    const { ALPNProtocols } = port;\n    if (ALPNProtocols)\n      convertALPNProtocols(ALPNProtocols, port);\n    return new TLSSocket(port).connect(port, host2, connectListener);\n  }\n  return new TLSSocket().connect(port, host2, connectListener);\n}, connect = createConnection;\n$ = {\n  CLIENT_RENEG_LIMIT,\n  CLIENT_RENEG_WINDOW,\n  connect,\n  convertALPNProtocols,\n  createConnection,\n  createSecureContext,\n  createServer,\n  DEFAULT_CIPHERS,\n  DEFAULT_ECDH_CURVE,\n  DEFAULT_MAX_VERSION,\n  DEFAULT_MIN_VERSION,\n  getCiphers,\n  parseCertString,\n  SecureContext,\n  Server,\n  TLSSocket,\n  checkServerIdentity,\n  rootCertificates\n};\nreturn $})\n"_s;
//

//
static constexpr ASCIILiteral NodeTraceEventsCode = "(function (){\"use strict\";// src/js/out/tmp/node/trace_events.ts\nvar ERR_INVALID_ARG_TYPE = function(name, type, value) {\n  const err = @makeTypeError(`The \"${name}\" argument must be of type ${type}. Received ${value}`);\n  return err.code = \"ERR_INVALID_ARG_TYPE\", err;\n}, createTracing = function(opts) {\n  if (typeof opts !== \"object\" || opts == null)\n    throw new ERR_INVALID_ARG_TYPE(\"options\", \"Object\", opts);\n  return new Tracing(opts);\n}, getEnabledCategories = function() {\n  return \"\";\n}, $;\n\nclass Tracing {\n  enabled = !1;\n  categories = \"\";\n}\n$ = {\n  createTracing,\n  getEnabledCategories\n};\nreturn $})\n"_s;
//

//
static constexpr ASCIILiteral NodeUrlCode = "(function (){\"use strict\";// src/js/out/tmp/node/url.ts\nvar Url = function() {\n  this.protocol = null, this.slashes = null, this.auth = null, this.host = null, this.port = null, this.hostname = null, this.hash = null, this.search = null, this.query = null, this.pathname = null, this.path = null, this.href = null;\n}, urlParse = function(url, parseQueryString, slashesDenoteHost) {\n  if (url && typeof url === \"object\" && url instanceof Url)\n    return url;\n  var u = new Url;\n  return u.parse(url, parseQueryString, slashesDenoteHost), u;\n}, urlFormat = function(obj) {\n  if (typeof obj === \"string\")\n    obj = urlParse(obj);\n  if (!(obj instanceof Url))\n    return Url.prototype.format.call(obj);\n  return obj.format();\n}, urlResolve = function(source, relative) {\n  return urlParse(source, !1, !0).resolve(relative);\n}, urlResolveObject = function(source, relative) {\n  if (!source)\n    return relative;\n  return urlParse(source, !1, !0).resolveObject(relative);\n}, urlToHttpOptions = function(url) {\n  const options = {\n    protocol: url.protocol,\n    hostname: typeof url.hostname === \"string\" && url.hostname.startsWith(\"[\") \? url.hostname.slice(1, -1) : url.hostname,\n    hash: url.hash,\n    search: url.search,\n    pathname: url.pathname,\n    path: `${url.pathname || \"\"}${url.search || \"\"}`,\n    href: url.href\n  };\n  if (url.port !== \"\")\n    options.port = Number(url.port);\n  if (url.username || url.password)\n    options.auth = `${decodeURIComponent(url.username)}:${decodeURIComponent(url.password)}`;\n  return options;\n}, $, { URL, URLSearchParams } = globalThis;\nUrl.prototype = {};\nvar protocolPattern = /^([a-z0-9.+-]+:)/i, portPattern = /:[0-9]*$/, simplePathPattern = /^(\\/\\/\?(\?!\\/)[^\?\\s]*)(\\\?[^\\s]*)\?$/, delims = [\"<\", \">\", '\"', \"`\", \" \", \"\\r\", \"\\n\", \"\\t\"], unwise = [\"{\", \"}\", \"|\", \"\\\\\", \"^\", \"`\"].concat(delims), autoEscape = [\"'\"].concat(unwise), nonHostChars = [\"%\", \"/\", \"\?\", \";\", \"#\"].concat(autoEscape), hostEndingChars = [\"/\", \"\?\", \"#\"], hostnameMaxLen = 255, hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/, hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/, unsafeProtocol = {\n  javascript: !0,\n  \"javascript:\": !0\n}, hostlessProtocol = {\n  javascript: !0,\n  \"javascript:\": !0\n}, slashedProtocol = {\n  http: !0,\n  https: !0,\n  ftp: !0,\n  gopher: !0,\n  file: !0,\n  \"http:\": !0,\n  \"https:\": !0,\n  \"ftp:\": !0,\n  \"gopher:\": !0,\n  \"file:\": !0\n};\nUrl.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {\n  if (typeof url !== \"string\")\n    @throwTypeError(\"Parameter 'url' must be a string, not \" + typeof url);\n  var queryIndex = url.indexOf(\"\?\"), splitter = queryIndex !== -1 && queryIndex < url.indexOf(\"#\") \? \"\?\" : \"#\", uSplit = url.split(splitter), slashRegex = /\\\\/g;\n  uSplit[0] = uSplit[0].replace(slashRegex, \"/\"), url = uSplit.join(splitter);\n  var rest = url;\n  if (rest = rest.trim(), !slashesDenoteHost && url.split(\"#\").length === 1) {\n    var simplePath = simplePathPattern.exec(rest);\n    if (simplePath) {\n      if (this.path = rest, this.href = rest, this.pathname = simplePath[1], simplePath[2])\n        if (this.search = simplePath[2], parseQueryString)\n          this.query = new URLSearchParams(this.search.substr(1)).toJSON();\n        else\n          this.query = this.search.substr(1);\n      else if (parseQueryString)\n        this.search = \"\", this.query = {};\n      return this;\n    }\n  }\n  var proto = protocolPattern.exec(rest);\n  if (proto) {\n    proto = proto[0];\n    var lowerProto = proto.toLowerCase();\n    this.protocol = lowerProto, rest = rest.substr(proto.length);\n  }\n  if (slashesDenoteHost || proto || rest.match(/^\\/\\/[^@/]+@[^@/]+/)) {\n    var slashes = rest.substr(0, 2) === \"//\";\n    if (slashes && !(proto && hostlessProtocol[proto]))\n      rest = rest.substr(2), this.slashes = !0;\n  }\n  if (!hostlessProtocol[proto] && (slashes || proto && !slashedProtocol[proto])) {\n    var hostEnd = -1;\n    for (var i = 0;i < hostEndingChars.length; i++) {\n      var hec = rest.indexOf(hostEndingChars[i]);\n      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))\n        hostEnd = hec;\n    }\n    var auth, atSign;\n    if (hostEnd === -1)\n      atSign = rest.lastIndexOf(\"@\");\n    else\n      atSign = rest.lastIndexOf(\"@\", hostEnd);\n    if (atSign !== -1)\n      auth = rest.slice(0, atSign), rest = rest.slice(atSign + 1), this.auth = decodeURIComponent(auth);\n    hostEnd = -1;\n    for (var i = 0;i < nonHostChars.length; i++) {\n      var hec = rest.indexOf(nonHostChars[i]);\n      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))\n        hostEnd = hec;\n    }\n    if (hostEnd === -1)\n      hostEnd = rest.length;\n    this.host = rest.slice(0, hostEnd), rest = rest.slice(hostEnd), this.parseHost(), this.hostname = this.hostname || \"\";\n    var ipv6Hostname = this.hostname[0] === \"[\" && this.hostname[this.hostname.length - 1] === \"]\";\n    if (!ipv6Hostname) {\n      var hostparts = this.hostname.split(/\\./);\n      for (var i = 0, l = hostparts.length;i < l; i++) {\n        var part = hostparts[i];\n        if (!part)\n          continue;\n        if (!part.match(hostnamePartPattern)) {\n          var newpart = \"\";\n          for (var j = 0, k = part.length;j < k; j++)\n            if (part.charCodeAt(j) > 127)\n              newpart += \"x\";\n            else\n              newpart += part[j];\n          if (!newpart.match(hostnamePartPattern)) {\n            var validParts = hostparts.slice(0, i), notHost = hostparts.slice(i + 1), bit = part.match(hostnamePartStart);\n            if (bit)\n              validParts.push(bit[1]), notHost.unshift(bit[2]);\n            if (notHost.length)\n              rest = \"/\" + notHost.join(\".\") + rest;\n            this.hostname = validParts.join(\".\");\n            break;\n          }\n        }\n      }\n    }\n    if (this.hostname.length > hostnameMaxLen)\n      this.hostname = \"\";\n    else\n      this.hostname = this.hostname.toLowerCase();\n    if (!ipv6Hostname)\n      this.hostname = new URL(\"http://\" + this.hostname).hostname;\n    var p = this.port \? \":\" + this.port : \"\", h = this.hostname || \"\";\n    if (this.host = h + p, this.href += this.host, ipv6Hostname) {\n      if (this.hostname = this.hostname.substr(1, this.hostname.length - 2), rest[0] !== \"/\")\n        rest = \"/\" + rest;\n    }\n  }\n  if (!unsafeProtocol[lowerProto])\n    for (var i = 0, l = autoEscape.length;i < l; i++) {\n      var ae = autoEscape[i];\n      if (rest.indexOf(ae) === -1)\n        continue;\n      var esc = encodeURIComponent(ae);\n      if (esc === ae)\n        esc = escape(ae);\n      rest = rest.split(ae).join(esc);\n    }\n  var hash = rest.indexOf(\"#\");\n  if (hash !== -1)\n    this.hash = rest.substr(hash), rest = rest.slice(0, hash);\n  var qm = rest.indexOf(\"\?\");\n  if (qm !== -1) {\n    if (this.search = rest.substr(qm), this.query = rest.substr(qm + 1), parseQueryString)\n      this.query = new URLSearchParams(this.query);\n    rest = rest.slice(0, qm);\n  } else if (parseQueryString)\n    this.search = \"\", this.query = {};\n  if (rest)\n    this.pathname = rest;\n  if (slashedProtocol[lowerProto] && this.hostname && !this.pathname)\n    this.pathname = \"/\";\n  if (this.pathname || this.search) {\n    var p = this.pathname || \"\", s = this.search || \"\";\n    this.path = p + s;\n  }\n  return this.href = this.format(), this;\n};\nUrl.prototype.format = function() {\n  var auth = this.auth || \"\";\n  if (auth)\n    auth = encodeURIComponent(auth), auth = auth.replace(/%3A/i, \":\"), auth += \"@\";\n  var protocol = this.protocol || \"\", pathname = this.pathname || \"\", hash = this.hash || \"\", host = !1, query = \"\";\n  if (this.host)\n    host = auth + this.host;\n  else if (this.hostname) {\n    if (host = auth + (this.hostname.indexOf(\":\") === -1 \? this.hostname : \"[\" + this.hostname + \"]\"), this.port)\n      host += \":\" + this.port;\n  }\n  if (this.query && typeof this.query === \"object\" && Object.keys(this.query).length)\n    query = new URLSearchParams(this.query).toString();\n  var search = this.search || query && \"\?\" + query || \"\";\n  if (protocol && protocol.substr(-1) !== \":\")\n    protocol += \":\";\n  if (this.slashes || (!protocol || slashedProtocol[protocol]) && host !== !1) {\n    if (host = \"//\" + (host || \"\"), pathname && pathname.charAt(0) !== \"/\")\n      pathname = \"/\" + pathname;\n  } else if (!host)\n    host = \"\";\n  if (hash && hash.charAt(0) !== \"#\")\n    hash = \"#\" + hash;\n  if (search && search.charAt(0) !== \"\?\")\n    search = \"\?\" + search;\n  return pathname = pathname.replace(/[\?#]/g, function(match) {\n    return encodeURIComponent(match);\n  }), search = search.replace(\"#\", \"%23\"), protocol + host + pathname + search + hash;\n};\nUrl.prototype.resolve = function(relative) {\n  return this.resolveObject(urlParse(relative, !1, !0)).format();\n};\nUrl.prototype.resolveObject = function(relative) {\n  if (typeof relative === \"string\") {\n    var rel = new Url;\n    rel.parse(relative, !1, !0), relative = rel;\n  }\n  var result = new Url, tkeys = Object.keys(this);\n  for (var tk = 0;tk < tkeys.length; tk++) {\n    var tkey = tkeys[tk];\n    result[tkey] = this[tkey];\n  }\n  if (result.hash = relative.hash, relative.href === \"\")\n    return result.href = result.format(), result;\n  if (relative.slashes && !relative.protocol) {\n    var rkeys = Object.keys(relative);\n    for (var rk = 0;rk < rkeys.length; rk++) {\n      var rkey = rkeys[rk];\n      if (rkey !== \"protocol\")\n        result[rkey] = relative[rkey];\n    }\n    if (slashedProtocol[result.protocol] && result.hostname && !result.pathname)\n      result.pathname = \"/\", result.path = result.pathname;\n    return result.href = result.format(), result;\n  }\n  if (relative.protocol && relative.protocol !== result.protocol) {\n    if (!slashedProtocol[relative.protocol]) {\n      var keys = Object.keys(relative);\n      for (var v = 0;v < keys.length; v++) {\n        var k = keys[v];\n        result[k] = relative[k];\n      }\n      return result.href = result.format(), result;\n    }\n    if (result.protocol = relative.protocol, !relative.host && !hostlessProtocol[relative.protocol]) {\n      var relPath = (relative.pathname || \"\").split(\"/\");\n      while (relPath.length && !(relative.host = relPath.shift()))\n        ;\n      if (!relative.host)\n        relative.host = \"\";\n      if (!relative.hostname)\n        relative.hostname = \"\";\n      if (relPath[0] !== \"\")\n        relPath.unshift(\"\");\n      if (relPath.length < 2)\n        relPath.unshift(\"\");\n      result.pathname = relPath.join(\"/\");\n    } else\n      result.pathname = relative.pathname;\n    if (result.search = relative.search, result.query = relative.query, result.host = relative.host || \"\", result.auth = relative.auth, result.hostname = relative.hostname || relative.host, result.port = relative.port, result.pathname || result.search) {\n      var p = result.pathname || \"\", s = result.search || \"\";\n      result.path = p + s;\n    }\n    return result.slashes = result.slashes || relative.slashes, result.href = result.format(), result;\n  }\n  var isSourceAbs = result.pathname && result.pathname.charAt(0) === \"/\", isRelAbs = relative.host || relative.pathname && relative.pathname.charAt(0) === \"/\", mustEndAbs = isRelAbs || isSourceAbs || result.host && relative.pathname, removeAllDots = mustEndAbs, srcPath = result.pathname && result.pathname.split(\"/\") || [], relPath = relative.pathname && relative.pathname.split(\"/\") || [], psychotic = result.protocol && !slashedProtocol[result.protocol];\n  if (psychotic) {\n    if (result.hostname = \"\", result.port = null, result.host)\n      if (srcPath[0] === \"\")\n        srcPath[0] = result.host;\n      else\n        srcPath.unshift(result.host);\n    if (result.host = \"\", relative.protocol) {\n      if (relative.hostname = null, relative.port = null, relative.host)\n        if (relPath[0] === \"\")\n          relPath[0] = relative.host;\n        else\n          relPath.unshift(relative.host);\n      relative.host = null;\n    }\n    mustEndAbs = mustEndAbs && (relPath[0] === \"\" || srcPath[0] === \"\");\n  }\n  if (isRelAbs)\n    result.host = relative.host || relative.host === \"\" \? relative.host : result.host, result.hostname = relative.hostname || relative.hostname === \"\" \? relative.hostname : result.hostname, result.search = relative.search, result.query = relative.query, srcPath = relPath;\n  else if (relPath.length) {\n    if (!srcPath)\n      srcPath = [];\n    srcPath.pop(), srcPath = srcPath.concat(relPath), result.search = relative.search, result.query = relative.query;\n  } else if (relative.search != null) {\n    if (psychotic) {\n      result.host = srcPath.shift(), result.hostname = result.host;\n      var authInHost = result.host && result.host.indexOf(\"@\") > 0 \? result.host.split(\"@\") : !1;\n      if (authInHost)\n        result.auth = authInHost.shift(), result.hostname = authInHost.shift(), result.host = result.hostname;\n    }\n    if (result.search = relative.search, result.query = relative.query, result.pathname !== null || result.search !== null)\n      result.path = (result.pathname \? result.pathname : \"\") + (result.search \? result.search : \"\");\n    return result.href = result.format(), result;\n  }\n  if (!srcPath.length) {\n    if (result.pathname = null, result.search)\n      result.path = \"/\" + result.search;\n    else\n      result.path = null;\n    return result.href = result.format(), result;\n  }\n  var last = srcPath.slice(-1)[0], hasTrailingSlash = (result.host || relative.host || srcPath.length > 1) && (last === \".\" || last === \"..\") || last === \"\", up = 0;\n  for (var i = srcPath.length;i >= 0; i--)\n    if (last = srcPath[i], last === \".\")\n      srcPath.splice(i, 1);\n    else if (last === \"..\")\n      srcPath.splice(i, 1), up++;\n    else if (up)\n      srcPath.splice(i, 1), up--;\n  if (!mustEndAbs && !removeAllDots)\n    for (;up--; up)\n      srcPath.unshift(\"..\");\n  if (mustEndAbs && srcPath[0] !== \"\" && (!srcPath[0] || srcPath[0].charAt(0) !== \"/\"))\n    srcPath.unshift(\"\");\n  if (hasTrailingSlash && srcPath.join(\"/\").substr(-1) !== \"/\")\n    srcPath.push(\"\");\n  var isAbsolute = srcPath[0] === \"\" || srcPath[0] && srcPath[0].charAt(0) === \"/\";\n  if (psychotic) {\n    result.hostname = isAbsolute \? \"\" : srcPath.length \? srcPath.shift() : \"\", result.host = result.hostname;\n    var authInHost = result.host && result.host.indexOf(\"@\") > 0 \? result.host.split(\"@\") : !1;\n    if (authInHost)\n      result.auth = authInHost.shift(), result.hostname = authInHost.shift(), result.host = result.hostname;\n  }\n  if (mustEndAbs = mustEndAbs || result.host && srcPath.length, mustEndAbs && !isAbsolute)\n    srcPath.unshift(\"\");\n  if (srcPath.length > 0)\n    result.pathname = srcPath.join(\"/\");\n  else\n    result.pathname = null, result.path = null;\n  if (result.pathname !== null || result.search !== null)\n    result.path = (result.pathname \? result.pathname : \"\") + (result.search \? result.search : \"\");\n  return result.auth = relative.auth || result.auth, result.slashes = result.slashes || relative.slashes, result.href = result.format(), result;\n};\nUrl.prototype.parseHost = function() {\n  var host = this.host, port = portPattern.exec(host);\n  if (port) {\n    if (port = port[0], port !== \":\")\n      this.port = port.substr(1);\n    host = host.substr(0, host.length - port.length);\n  }\n  if (host)\n    this.hostname = host;\n};\nvar pathToFileURL = globalThis[globalThis.Symbol.for('Bun.lazy')](\"pathToFileURL\"), fileURLToPath = globalThis[globalThis.Symbol.for('Bun.lazy')](\"fileURLToPath\");\n$ = {\n  parse: urlParse,\n  resolve: urlResolve,\n  resolveObject: urlResolveObject,\n  format: urlFormat,\n  Url,\n  URLSearchParams,\n  URL,\n  pathToFileURL,\n  fileURLToPath,\n  urlToHttpOptions\n};\nreturn $})\n"_s;
//

//
static constexpr ASCIILiteral NodeUtilCode = "(function (){\"use strict\";// src/js/out/tmp/node/util.ts\nvar isBufferInterface = function({ copy, fill, readUint8 }) {\n  return typeof copy === \"function\" && typeof fill === \"function\" && typeof readUint8 === \"function\";\n}, isBuffer = function(value) {\n  return Buffer.isBuffer(value) || typeof value === \"object\" && isBufferInterface(value || {});\n}, isFunction = function(value) {\n  return typeof value === \"function\";\n}, formatWithOptions = function(inspectOptions, f) {\n  if (!isString(f)) {\n    var objects = [];\n    for (var i = 0;i < arguments.length; i++)\n      objects.push(inspect(arguments[i], inspectOptions));\n    return objects.join(\" \");\n  }\n  var i = 2, args = arguments, len = args.length, str = String(f).replace(formatRegExp, function(x2) {\n    if (x2 === \"%%\")\n      return \"%\";\n    if (i >= len)\n      return x2;\n    switch (x2) {\n      case \"%s\":\n        return String(args[i++]);\n      case \"%f\":\n        return Number(args[i++]);\n      case \"%d\":\n        return Math.round(Number(args[i++]));\n      case \"%j\":\n        try {\n          return JSON.stringify(args[i++]);\n        } catch (_) {\n          return \"[Circular]\";\n        }\n      case \"%o\":\n        return inspect(args[i++], { showHidden: !0, showProxy: !0, ...inspectOptions });\n      case \"%O\":\n        return inspect(args[i++], { showHidden: !0, showProxy: !0, ...inspectOptions });\n      default:\n        return x2;\n    }\n  });\n  for (var x = args[i];i < len; x = args[++i])\n    if (isNull(x) || !isObject(x))\n      str += \" \" + x;\n    else\n      str += \" \" + inspect(x, inspectOptions);\n  return str;\n}, format = function(...args) {\n  return formatWithOptions({}, ...args);\n}, deprecate = function(fn, msg, code) {\n  if (process.noDeprecation === !0)\n    return fn;\n  var warned = !1;\n  function deprecated() {\n    if (!warned) {\n      if (process.throwDeprecation) {\n        var err = new Error(msg);\n        if (code)\n          err.code = code;\n        throw err;\n      } else if (process.traceDeprecation)\n        console.trace(msg);\n      else\n        console.error(msg);\n      warned = !0;\n    }\n    return fn.apply(this, arguments);\n  }\n  return deprecated;\n}, debuglog = function(set) {\n  if (set = set.toUpperCase(), !debugs[set])\n    if (debugEnvRegex.test(set)) {\n      var pid = process.pid;\n      debugs[set] = function() {\n        var msg = format.apply(cjs_exports, arguments);\n        console.error(\"%s %d: %s\", set, pid, msg);\n      };\n    } else\n      debugs[set] = function() {\n      };\n  return debugs[set];\n}, inspect = function(obj, opts) {\n  var ctx = {\n    seen: [],\n    stylize: stylizeNoColor\n  };\n  if (arguments.length >= 3)\n    ctx.depth = arguments[2];\n  if (arguments.length >= 4)\n    ctx.colors = arguments[3];\n  if (isBoolean(opts))\n    ctx.showHidden = opts;\n  else if (opts)\n    _extend(ctx, opts);\n  if (isUndefined(ctx.showHidden))\n    ctx.showHidden = !1;\n  if (isUndefined(ctx.depth))\n    ctx.depth = 2;\n  if (isUndefined(ctx.colors))\n    ctx.colors = !1;\n  if (isUndefined(ctx.customInspect))\n    ctx.customInspect = !0;\n  if (ctx.colors)\n    ctx.stylize = stylizeWithColor;\n  return formatValue(ctx, obj, ctx.depth);\n}, stylizeWithColor = function(str, styleType) {\n  const style = inspect.styles[styleType];\n  if (style !== void 0) {\n    const color = inspect.colors[style];\n    if (color !== void 0)\n      return `\\x1B[${color[0]}m${str}\\x1B[${color[1]}m`;\n  }\n  return str;\n}, stylizeNoColor = function(str, styleType) {\n  return str;\n}, arrayToHash = function(array) {\n  var hash = {};\n  return array.forEach(function(val, idx) {\n    hash[val] = !0;\n  }), hash;\n}, formatValue = function(ctx, value, recurseTimes) {\n  if (ctx.customInspect && value) {\n    const customInspect = value[kInspectCustom];\n    if (isFunction(customInspect)) {\n      var ret = customInspect.call(value, recurseTimes, ctx, inspect);\n      if (!isString(ret))\n        ret = formatValue(ctx, ret, recurseTimes);\n      return ret;\n    }\n  }\n  var primitive = formatPrimitive(ctx, value);\n  if (primitive)\n    return primitive;\n  var keys = Object.keys(value).concat(Object.getOwnPropertySymbols(value)), visibleKeys = arrayToHash(keys);\n  if (ctx.showHidden)\n    keys = Object.getOwnPropertyNames(value);\n  if (isError(value) && (keys.indexOf(\"message\") >= 0 || keys.indexOf(\"description\") >= 0))\n    return formatError(value);\n  if (keys.length === 0) {\n    if (isFunction(value)) {\n      var name = value.name \? \": \" + value.name : \"\";\n      return ctx.stylize(\"[Function\" + name + \"]\", \"special\");\n    }\n    if (isRegExp(value))\n      return ctx.stylize(RegExp.prototype.toString.call(value), \"regexp\");\n    if (isDate(value))\n      return ctx.stylize(Date.prototype.toString.call(value), \"date\");\n    if (isError(value))\n      return formatError(value);\n  }\n  var base = \"\", array = !1, braces = [\"{\", \"}\"];\n  if (@isArray(value))\n    array = !0, braces = [\"[\", \"]\"];\n  if (isFunction(value)) {\n    var n = value.name \? \": \" + value.name : \"\";\n    base = \" [Function\" + n + \"]\";\n  }\n  if (isRegExp(value))\n    base = \" \" + RegExp.prototype.toString.call(value);\n  if (isDate(value))\n    base = \" \" + Date.prototype.toUTCString.call(value);\n  if (isError(value))\n    base = \" \" + formatError(value);\n  if (keys.length === 0 && (!array || value.length == 0))\n    return braces[0] + base + braces[1];\n  if (recurseTimes < 0)\n    if (isRegExp(value))\n      return ctx.stylize(RegExp.prototype.toString.call(value), \"regexp\");\n    else\n      return ctx.stylize(\"[Object]\", \"special\");\n  ctx.seen.push(value);\n  var output;\n  if (array)\n    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);\n  else\n    output = keys.map(function(key) {\n      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);\n    });\n  return ctx.seen.pop(), reduceToSingleString(output, base, braces);\n}, formatPrimitive = function(ctx, value) {\n  if (isUndefined(value))\n    return ctx.stylize(\"undefined\", \"undefined\");\n  if (isString(value)) {\n    var simple = \"'\" + JSON.stringify(value).replace(/^\"|\"$/g, \"\").replace(/'/g, \"\\\\'\").replace(/\\\\\"/g, '\"') + \"'\";\n    return ctx.stylize(simple, \"string\");\n  }\n  if (isNumber(value))\n    return ctx.stylize(\"\" + value, \"number\");\n  if (isBoolean(value))\n    return ctx.stylize(\"\" + value, \"boolean\");\n  if (isNull(value))\n    return ctx.stylize(\"null\", \"null\");\n}, formatError = function(value) {\n  return \"[\" + Error.prototype.toString.call(value) + \"]\";\n}, formatArray = function(ctx, value, recurseTimes, visibleKeys, keys) {\n  var output = [];\n  for (var i = 0, l = value.length;i < l; ++i)\n    if (hasOwnProperty(value, String(i)))\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i), !0));\n    else\n      output.push(\"\");\n  return keys.forEach(function(key) {\n    if (!key.match(/^\\d+$/))\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, !0));\n  }), output;\n}, formatProperty = function(ctx, value, recurseTimes, visibleKeys, key, array) {\n  var name, str, desc;\n  if (desc = Object.getOwnPropertyDescriptor(value, key) || {\n    value: value[key]\n  }, desc.get)\n    if (desc.set)\n      str = ctx.stylize(\"[Getter/Setter]\", \"special\");\n    else\n      str = ctx.stylize(\"[Getter]\", \"special\");\n  else if (desc.set)\n    str = ctx.stylize(\"[Setter]\", \"special\");\n  if (!hasOwnProperty(visibleKeys, key))\n    name = \"[\" + (typeof key === \"symbol\" \? key.description : key) + \"]\";\n  if (typeof key === \"symbol\")\n    name = \"[\" + ctx.stylize(`Symbol(${key.description})`, \"string\") + \"]\";\n  if (!str)\n    if (ctx.seen.indexOf(desc.value) < 0) {\n      if (isNull(recurseTimes))\n        str = formatValue(ctx, desc.value, null);\n      else\n        str = formatValue(ctx, desc.value, recurseTimes - 1);\n      if (str.indexOf(\"\\n\") > -1)\n        if (array)\n          str = str.split(\"\\n\").map(function(line) {\n            return \"  \" + line;\n          }).join(\"\\n\").substr(2);\n        else\n          str = \"\\n\" + str.split(\"\\n\").map(function(line) {\n            return \"   \" + line;\n          }).join(\"\\n\");\n    } else\n      str = ctx.stylize(\"[Circular]\", \"special\");\n  if (isUndefined(name)) {\n    if (array && key.match(/^\\d+$/))\n      return str;\n    if (name = JSON.stringify(\"\" + key), name.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/))\n      name = name.substr(1, name.length - 2), name = ctx.stylize(name, \"name\");\n    else\n      name = name.replace(/'/g, \"\\\\'\").replace(/\\\\\"/g, '\"').replace(/(^\"|\"$)/g, \"'\"), name = ctx.stylize(name, \"string\");\n  }\n  return name + \": \" + str;\n}, reduceToSingleString = function(output, base, braces) {\n  var numLinesEst = 0, length = output.reduce(function(prev, cur) {\n    if (numLinesEst++, cur.indexOf(\"\\n\") >= 0)\n      numLinesEst++;\n    return prev + cur.replace(/\\u001b\\[\\d\\d\?m/g, \"\").length + 1;\n  }, 0);\n  if (length > 60)\n    return braces[0] + (base === \"\" \? \"\" : base + \"\\n \") + \" \" + output.join(\",\\n  \") + \" \" + braces[1];\n  return braces[0] + base + \" \" + output.join(\", \") + \" \" + braces[1];\n}, isBoolean = function(arg) {\n  return typeof arg === \"boolean\";\n}, isNull = function(arg) {\n  return arg === null;\n}, isNullOrUndefined = function(arg) {\n  return arg == null;\n}, isNumber = function(arg) {\n  return typeof arg === \"number\";\n}, isString = function(arg) {\n  return typeof arg === \"string\";\n}, isSymbol = function(arg) {\n  return typeof arg === \"symbol\";\n}, isUndefined = function(arg) {\n  return arg === void 0;\n}, isObject = function(arg) {\n  return typeof arg === \"object\" && arg !== null;\n}, isPrimitive = function(arg) {\n  return arg === null || typeof arg === \"boolean\" || typeof arg === \"number\" || typeof arg === \"string\" || typeof arg === \"symbol\" || typeof arg === \"undefined\";\n}, pad = function(n) {\n  return n < 10 \? \"0\" + n.toString(10) : n.toString(10);\n}, timestamp = function() {\n  var d = new Date, time = [pad(d.getHours()), pad(d.getMinutes()), pad(d.getSeconds())].join(\":\");\n  return [d.getDate(), months[d.getMonth()], time].join(\" \");\n}, hasOwnProperty = function(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}, callbackifyOnRejected = function(reason, cb) {\n  if (!reason) {\n    var newReason = new Error(\"Promise was rejected with a falsy value\");\n    newReason.reason = reason, newReason.code = \"ERR_FALSY_VALUE_REJECTION\", reason = newReason;\n  }\n  return cb(reason);\n}, callbackify = function(original) {\n  if (typeof original !== \"function\")\n    @throwTypeError('The \"original\" argument must be of type Function');\n  function callbackified() {\n    var args = Array.prototype.slice.call(arguments), maybeCb = args.pop();\n    if (typeof maybeCb !== \"function\")\n      @throwTypeError(\"The last argument must be of type Function\");\n    var self = this, cb = function() {\n      return maybeCb.apply(self, arguments);\n    };\n    original.apply(this, args).then(function(ret) {\n      process.nextTick(cb, null, ret);\n    }, function(rej) {\n      process.nextTick(callbackifyOnRejected, rej, cb);\n    });\n  }\n  return Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original)), Object.defineProperties(callbackified, getOwnPropertyDescriptors(original)), callbackified;\n}, $, types = @requireNativeModule(\"node:util/types\"), cjs_exports = {}, deepEquals = Bun.deepEquals, isDeepStrictEqual = (a, b) => deepEquals(a, b, !0), getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors, formatRegExp = /%[sdjfoc%]/g, debugs = {}, debugEnvRegex = /^$/;\nif (process.env.NODE_DEBUG)\n  debugEnv = process.env.NODE_DEBUG, debugEnv = debugEnv.replace(/[|\\\\{}()[\\]^$+\?.]/g, \"\\\\$&\").replace(/\\*/g, \".*\").replace(/,/g, \"$|^\").toUpperCase(), debugEnvRegex = new RegExp(\"^\" + debugEnv + \"$\", \"i\");\nvar debugEnv, kInspectCustom = Symbol.for(\"nodejs.util.inspect.custom\");\ninspect.colors = {\n  bold: [1, 22],\n  italic: [3, 23],\n  underline: [4, 24],\n  inverse: [7, 27],\n  white: [37, 39],\n  grey: [90, 39],\n  black: [30, 39],\n  blue: [34, 39],\n  cyan: [36, 39],\n  green: [32, 39],\n  magenta: [35, 39],\n  red: [31, 39],\n  yellow: [33, 39]\n};\ninspect.styles = {\n  special: \"cyan\",\n  number: \"yellow\",\n  boolean: \"yellow\",\n  undefined: \"grey\",\n  null: \"bold\",\n  string: \"green\",\n  date: \"magenta\",\n  regexp: \"red\"\n};\ninspect.custom = kInspectCustom;\ninspect.defaultOptions = {\n  showHidden: !1,\n  depth: 2,\n  colors: !1,\n  customInspect: !0,\n  showProxy: !1,\n  maxArrayLength: 100,\n  maxStringLength: 1e4,\n  breakLength: 80,\n  compact: 3,\n  sorted: !1,\n  getters: !1,\n  numericSeparator: !1\n};\nvar { isRegExp, isDate, isNativeError: isError } = types, months = [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"], log = function log2() {\n  console.log(\"%s - %s\", timestamp(), format.apply(cjs_exports, arguments));\n}, inherits = function inherits2(ctor, superCtor) {\n  ctor.super_ = superCtor, ctor.prototype = Object.create(superCtor.prototype, {\n    constructor: {\n      value: ctor,\n      enumerable: !1,\n      writable: !0,\n      configurable: !0\n    }\n  });\n}, _extend = function(origin, add) {\n  if (!add || !isObject(add))\n    return origin;\n  var keys = Object.keys(add), i = keys.length;\n  while (i--)\n    origin[keys[i]] = add[keys[i]];\n  return origin;\n}, kCustomPromisifiedSymbol = Symbol.for(\"util.promisify.custom\"), promisify = function promisify2(original) {\n  if (typeof original !== \"function\")\n    @throwTypeError('The \"original\" argument must be of type Function');\n  if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {\n    var fn = original[kCustomPromisifiedSymbol];\n    if (typeof fn !== \"function\")\n      @throwTypeError('The \"util.promisify.custom\" argument must be of type Function');\n    return Object.defineProperty(fn, kCustomPromisifiedSymbol, {\n      value: fn,\n      enumerable: !1,\n      writable: !1,\n      configurable: !0\n    }), fn;\n  }\n  function fn() {\n    var promiseResolve, promiseReject, promise = new Promise(function(resolve, reject) {\n      promiseResolve = resolve, promiseReject = reject;\n    }), args = [];\n    for (var i = 0;i < arguments.length; i++)\n      args.push(arguments[i]);\n    args.push(function(err, value) {\n      if (err)\n        promiseReject(err);\n      else\n        promiseResolve(value);\n    });\n    try {\n      original.apply(this, args);\n    } catch (err) {\n      promiseReject(err);\n    }\n    return promise;\n  }\n  if (Object.setPrototypeOf(fn, Object.getPrototypeOf(original)), kCustomPromisifiedSymbol)\n    Object.defineProperty(fn, kCustomPromisifiedSymbol, {\n      value: fn,\n      enumerable: !1,\n      writable: !1,\n      configurable: !0\n    });\n  return Object.defineProperties(fn, getOwnPropertyDescriptors(original));\n};\npromisify.custom = kCustomPromisifiedSymbol;\nvar toUSVString = (input) => {\n  return (input + \"\").toWellFormed();\n};\n$ = Object.assign(cjs_exports, {\n  format,\n  formatWithOptions,\n  deprecate,\n  debuglog,\n  _extend,\n  inspect,\n  types,\n  isArray: @isArray,\n  isBoolean,\n  isNull,\n  isNullOrUndefined,\n  isNumber,\n  isString,\n  isSymbol,\n  isUndefined,\n  isRegExp,\n  isObject,\n  isDate,\n  isFunction,\n  isError,\n  isPrimitive,\n  isBuffer,\n  log,\n  inherits,\n  toUSVString,\n  promisify,\n  callbackify,\n  isDeepStrictEqual,\n  TextDecoder,\n  TextEncoder\n});\nreturn $})\n"_s;
//

//
static constexpr ASCIILiteral NodeV8Code = "(function (){\"use strict\";// src/js/out/tmp/node/v8.ts\nvar notimpl = function(message) {\n  throwNotImplemented(\"node:v8 \" + message);\n}, cachedDataVersionTag = function() {\n  notimpl(\"cachedDataVersionTag\");\n}, getHeapSnapshot = function() {\n  notimpl(\"getHeapSnapshot\");\n}, getHeapStatistics = function() {\n  notimpl(\"getHeapStatistics\");\n}, getHeapSpaceStatistics = function() {\n  notimpl(\"getHeapSpaceStatistics\");\n}, getHeapCodeStatistics = function() {\n  notimpl(\"getHeapCodeStatistics\");\n}, setFlagsFromString = function() {\n  notimpl(\"setFlagsFromString\");\n}, deserialize = function(value) {\n  return jsc.deserialize(value);\n}, takeCoverage = function() {\n  notimpl(\"takeCoverage\");\n}, stopCoverage = function() {\n  notimpl(\"stopCoverage\");\n}, serialize = function(arg1) {\n  return jsc.serialize(arg1, { binaryType: \"nodebuffer\" });\n}, writeHeapSnapshot = function() {\n  notimpl(\"writeHeapSnapshot\");\n}, setHeapSnapshotNearHeapLimit = function() {\n  notimpl(\"setHeapSnapshotNearHeapLimit\");\n}, $, { hideFromStack, throwNotImplemented } = @getInternalField(@internalModuleRegistry, 3) || @createInternalModuleById(3), jsc = @requireNativeModule(\"bun:jsc\");\n\nclass Deserializer {\n  constructor() {\n    notimpl(\"Deserializer\");\n  }\n}\n\nclass Serializer {\n  constructor() {\n    notimpl(\"Serializer\");\n  }\n}\n\nclass DefaultDeserializer extends Deserializer {\n  constructor() {\n    super(...arguments);\n  }\n}\n\nclass DefaultSerializer extends Serializer {\n  constructor() {\n    super(...arguments);\n  }\n}\n\nclass GCProfiler {\n  constructor() {\n    notimpl(\"GCProfiler\");\n  }\n}\nvar promiseHooks = {\n  createHook: () => {\n    notimpl(\"createHook\");\n  },\n  onInit: () => {\n    notimpl(\"onInit\");\n  },\n  onBefore: () => {\n    notimpl(\"onBefore\");\n  },\n  onAfter: () => {\n    notimpl(\"onAfter\");\n  },\n  onSettled: () => {\n    notimpl(\"onSettled\");\n  }\n}, startupSnapshot = {\n  addDeserializeCallback: () => notimpl(\"addDeserializeCallback\"),\n  addSerializeCallback: () => notimpl(\"addSerializeCallback\"),\n  setDeserializeMainFunction: () => notimpl(\"setDeserializeMainFunction\"),\n  isBuildingSnapshot: () => notimpl(\"isBuildingSnapshot\")\n};\n$ = {\n  cachedDataVersionTag,\n  getHeapSnapshot,\n  getHeapStatistics,\n  getHeapSpaceStatistics,\n  getHeapCodeStatistics,\n  setFlagsFromString,\n  deserialize,\n  takeCoverage,\n  stopCoverage,\n  serialize,\n  writeHeapSnapshot,\n  setHeapSnapshotNearHeapLimit,\n  promiseHooks,\n  startupSnapshot,\n  Deserializer,\n  Serializer\n};\nhideFromStack(notimpl, cachedDataVersionTag, getHeapSnapshot, getHeapStatistics, getHeapSpaceStatistics, getHeapCodeStatistics, setFlagsFromString, deserialize, takeCoverage, stopCoverage, serialize, writeHeapSnapshot, setHeapSnapshotNearHeapLimit, Deserializer, Serializer, DefaultDeserializer, DefaultSerializer, GCProfiler);\nreturn $})\n"_s;
//

//
static constexpr ASCIILiteral NodeVMCode = "(function (){\"use strict\";// src/js/out/tmp/node/vm.ts\nvar runInContext = function(code, context, options) {\n  return new Script(code, options).runInContext(context);\n}, compileFunction = function() {\n  throwNotImplemented(\"node:vm compileFunction\");\n}, measureMemory = function() {\n  throwNotImplemented(\"node:vm measureMemory\");\n}, $, { throwNotImplemented } = @getInternalField(@internalModuleRegistry, 3) || @createInternalModuleById(3), vm = globalThis[globalThis.Symbol.for('Bun.lazy')](\"vm\"), { createContext, isContext, Script, runInNewContext, runInThisContext } = vm;\n\nclass Module {\n  constructor() {\n    throwNotImplemented(\"node:vm Module\");\n  }\n}\n\nclass SourceTextModule {\n  constructor() {\n    throwNotImplemented(\"node:vm Module\");\n  }\n}\n\nclass SyntheticModule {\n  constructor() {\n    throwNotImplemented(\"node:vm Module\");\n  }\n}\n$ = {\n  createContext,\n  runInContext,\n  runInNewContext,\n  runInThisContext,\n  isContext,\n  compileFunction,\n  measureMemory,\n  Script,\n  Module,\n  SourceTextModule,\n  SyntheticModule\n};\nreturn $})\n"_s;
//

//
static constexpr ASCIILiteral NodeWasiCode = "(function (){\"use strict\";// src/js/out/tmp/node/wasi.ts\nvar nodeFsConstants = @processBindingConstants.fs, __getOwnPropNames = Object.getOwnPropertyNames, __commonJS = (cb, mod) => function __require2() {\n  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;\n}, require_types = __commonJS({\n  \"node_modules/wasi-js/dist/types.js\"(exports) {\n    Object.defineProperty(exports, \"__esModule\", { value: !0 }), exports.WASIKillError = exports.WASIExitError = exports.WASIError = void 0;\n    var WASIError = class extends Error {\n      constructor(errno) {\n        super();\n        this.errno = errno, Object.setPrototypeOf(this, WASIError.prototype);\n      }\n    };\n    exports.WASIError = WASIError;\n    var WASIExitError = class extends Error {\n      constructor(code) {\n        super(`WASI Exit error: ${code}`);\n        this.code = code, Object.setPrototypeOf(this, WASIExitError.prototype);\n      }\n    };\n    exports.WASIExitError = WASIExitError;\n    var WASIKillError = class extends Error {\n      constructor(signal) {\n        super(`WASI Kill signal: ${signal}`);\n        this.signal = signal, Object.setPrototypeOf(this, WASIKillError.prototype);\n      }\n    };\n    exports.WASIKillError = WASIKillError;\n  }\n}), require_constants = __commonJS({\n  \"node_modules/wasi-js/dist/constants.js\"(exports) {\n    Object.defineProperty(exports, \"__esModule\", { value: !0 }), exports.WASI_ENOMSG = exports.WASI_ENOMEM = exports.WASI_ENOLINK = exports.WASI_ENOLCK = exports.WASI_ENOEXEC = exports.WASI_ENOENT = exports.WASI_ENODEV = exports.WASI_ENOBUFS = exports.WASI_ENFILE = exports.WASI_ENETUNREACH = exports.WASI_ENETRESET = exports.WASI_ENETDOWN = exports.WASI_ENAMETOOLONG = exports.WASI_EMULTIHOP = exports.WASI_EMSGSIZE = exports.WASI_EMLINK = exports.WASI_EMFILE = exports.WASI_ELOOP = exports.WASI_EISDIR = exports.WASI_EISCONN = exports.WASI_EIO = exports.WASI_EINVAL = exports.WASI_EINTR = exports.WASI_EINPROGRESS = exports.WASI_EILSEQ = exports.WASI_EIDRM = exports.WASI_EHOSTUNREACH = exports.WASI_EFBIG = exports.WASI_EFAULT = exports.WASI_EEXIST = exports.WASI_EDQUOT = exports.WASI_EDOM = exports.WASI_EDESTADDRREQ = exports.WASI_EDEADLK = exports.WASI_ECONNRESET = exports.WASI_ECONNREFUSED = exports.WASI_ECONNABORTED = exports.WASI_ECHILD = exports.WASI_ECANCELED = exports.WASI_EBUSY = exports.WASI_EBADMSG = exports.WASI_EBADF = exports.WASI_EALREADY = exports.WASI_EAGAIN = exports.WASI_EAFNOSUPPORT = exports.WASI_EADDRNOTAVAIL = exports.WASI_EADDRINUSE = exports.WASI_EACCES = exports.WASI_E2BIG = exports.WASI_ESUCCESS = void 0, exports.WASI_SIGVTALRM = exports.WASI_SIGUSR2 = exports.WASI_SIGUSR1 = exports.WASI_SIGURG = exports.WASI_SIGTTOU = exports.WASI_SIGTTIN = exports.WASI_SIGTSTP = exports.WASI_SIGTRAP = exports.WASI_SIGTERM = exports.WASI_SIGSTOP = exports.WASI_SIGSEGV = exports.WASI_SIGQUIT = exports.WASI_SIGPIPE = exports.WASI_SIGKILL = exports.WASI_SIGINT = exports.WASI_SIGILL = exports.WASI_SIGHUP = exports.WASI_SIGFPE = exports.WASI_SIGCONT = exports.WASI_SIGCHLD = exports.WASI_SIGBUS = exports.WASI_SIGALRM = exports.WASI_SIGABRT = exports.WASI_ENOTCAPABLE = exports.WASI_EXDEV = exports.WASI_ETXTBSY = exports.WASI_ETIMEDOUT = exports.WASI_ESTALE = exports.WASI_ESRCH = exports.WASI_ESPIPE = exports.WASI_EROFS = exports.WASI_ERANGE = exports.WASI_EPROTOTYPE = exports.WASI_EPROTONOSUPPORT = exports.WASI_EPROTO = exports.WASI_EPIPE = exports.WASI_EPERM = exports.WASI_EOWNERDEAD = exports.WASI_EOVERFLOW = exports.WASI_ENXIO = exports.WASI_ENOTTY = exports.WASI_ENOTSUP = exports.WASI_ENOTSOCK = exports.WASI_ENOTRECOVERABLE = exports.WASI_ENOTEMPTY = exports.WASI_ENOTDIR = exports.WASI_ENOTCONN = exports.WASI_ENOSYS = exports.WASI_ENOSPC = exports.WASI_ENOPROTOOPT = void 0, exports.RIGHTS_REGULAR_FILE_BASE = exports.RIGHTS_CHARACTER_DEVICE_INHERITING = exports.RIGHTS_CHARACTER_DEVICE_BASE = exports.RIGHTS_BLOCK_DEVICE_INHERITING = exports.RIGHTS_BLOCK_DEVICE_BASE = exports.RIGHTS_ALL = exports.WASI_RIGHT_SOCK_SHUTDOWN = exports.WASI_RIGHT_POLL_FD_READWRITE = exports.WASI_RIGHT_PATH_UNLINK_FILE = exports.WASI_RIGHT_PATH_REMOVE_DIRECTORY = exports.WASI_RIGHT_PATH_SYMLINK = exports.WASI_RIGHT_FD_FILESTAT_SET_TIMES = exports.WASI_RIGHT_FD_FILESTAT_SET_SIZE = exports.WASI_RIGHT_FD_FILESTAT_GET = exports.WASI_RIGHT_PATH_FILESTAT_SET_TIMES = exports.WASI_RIGHT_PATH_FILESTAT_SET_SIZE = exports.WASI_RIGHT_PATH_FILESTAT_GET = exports.WASI_RIGHT_PATH_RENAME_TARGET = exports.WASI_RIGHT_PATH_RENAME_SOURCE = exports.WASI_RIGHT_PATH_READLINK = exports.WASI_RIGHT_FD_READDIR = exports.WASI_RIGHT_PATH_OPEN = exports.WASI_RIGHT_PATH_LINK_TARGET = exports.WASI_RIGHT_PATH_LINK_SOURCE = exports.WASI_RIGHT_PATH_CREATE_FILE = exports.WASI_RIGHT_PATH_CREATE_DIRECTORY = exports.WASI_RIGHT_FD_ALLOCATE = exports.WASI_RIGHT_FD_ADVISE = exports.WASI_RIGHT_FD_WRITE = exports.WASI_RIGHT_FD_TELL = exports.WASI_RIGHT_FD_SYNC = exports.WASI_RIGHT_FD_FDSTAT_SET_FLAGS = exports.WASI_RIGHT_FD_SEEK = exports.WASI_RIGHT_FD_READ = exports.WASI_RIGHT_FD_DATASYNC = exports.WASI_FDFLAG_SYNC = exports.WASI_FDFLAG_RSYNC = exports.WASI_FDFLAG_NONBLOCK = exports.WASI_FDFLAG_DSYNC = exports.WASI_FDFLAG_APPEND = exports.WASI_FILETYPE_SYMBOLIC_LINK = exports.WASI_FILETYPE_SOCKET_STREAM = exports.WASI_FILETYPE_SOCKET_DGRAM = exports.WASI_FILETYPE_REGULAR_FILE = exports.WASI_FILETYPE_DIRECTORY = exports.WASI_FILETYPE_CHARACTER_DEVICE = exports.WASI_FILETYPE_BLOCK_DEVICE = exports.WASI_FILETYPE_UNKNOWN = exports.WASI_SIGXFSZ = exports.WASI_SIGXCPU = void 0, exports.SIGNAL_MAP = exports.ERROR_MAP = exports.WASI_WHENCE_END = exports.WASI_WHENCE_CUR = exports.WASI_WHENCE_SET = exports.WASI_STDERR_FILENO = exports.WASI_STDOUT_FILENO = exports.WASI_STDIN_FILENO = exports.WASI_DIRCOOKIE_START = exports.WASI_PREOPENTYPE_DIR = exports.WASI_O_TRUNC = exports.WASI_O_EXCL = exports.WASI_O_DIRECTORY = exports.WASI_O_CREAT = exports.WASI_FILESTAT_SET_MTIM_NOW = exports.WASI_FILESTAT_SET_MTIM = exports.WASI_FILESTAT_SET_ATIM_NOW = exports.WASI_FILESTAT_SET_ATIM = exports.WASI_EVENTTYPE_FD_WRITE = exports.WASI_EVENTTYPE_FD_READ = exports.WASI_EVENTTYPE_CLOCK = exports.WASI_CLOCK_THREAD_CPUTIME_ID = exports.WASI_CLOCK_PROCESS_CPUTIME_ID = exports.WASI_CLOCK_MONOTONIC = exports.WASI_CLOCK_REALTIME = exports.RIGHTS_TTY_INHERITING = exports.RIGHTS_TTY_BASE = exports.RIGHTS_SOCKET_INHERITING = exports.RIGHTS_SOCKET_BASE = exports.RIGHTS_DIRECTORY_INHERITING = exports.RIGHTS_DIRECTORY_BASE = exports.RIGHTS_REGULAR_FILE_INHERITING = void 0, exports.WASI_ESUCCESS = 0, exports.WASI_E2BIG = 1, exports.WASI_EACCES = 2, exports.WASI_EADDRINUSE = 3, exports.WASI_EADDRNOTAVAIL = 4, exports.WASI_EAFNOSUPPORT = 5, exports.WASI_EAGAIN = 6, exports.WASI_EALREADY = 7, exports.WASI_EBADF = 8, exports.WASI_EBADMSG = 9, exports.WASI_EBUSY = 10, exports.WASI_ECANCELED = 11, exports.WASI_ECHILD = 12, exports.WASI_ECONNABORTED = 13, exports.WASI_ECONNREFUSED = 14, exports.WASI_ECONNRESET = 15, exports.WASI_EDEADLK = 16, exports.WASI_EDESTADDRREQ = 17, exports.WASI_EDOM = 18, exports.WASI_EDQUOT = 19, exports.WASI_EEXIST = 20, exports.WASI_EFAULT = 21, exports.WASI_EFBIG = 22, exports.WASI_EHOSTUNREACH = 23, exports.WASI_EIDRM = 24, exports.WASI_EILSEQ = 25, exports.WASI_EINPROGRESS = 26, exports.WASI_EINTR = 27, exports.WASI_EINVAL = 28, exports.WASI_EIO = 29, exports.WASI_EISCONN = 30, exports.WASI_EISDIR = 31, exports.WASI_ELOOP = 32, exports.WASI_EMFILE = 33, exports.WASI_EMLINK = 34, exports.WASI_EMSGSIZE = 35, exports.WASI_EMULTIHOP = 36, exports.WASI_ENAMETOOLONG = 37, exports.WASI_ENETDOWN = 38, exports.WASI_ENETRESET = 39, exports.WASI_ENETUNREACH = 40, exports.WASI_ENFILE = 41, exports.WASI_ENOBUFS = 42, exports.WASI_ENODEV = 43, exports.WASI_ENOENT = 44, exports.WASI_ENOEXEC = 45, exports.WASI_ENOLCK = 46, exports.WASI_ENOLINK = 47, exports.WASI_ENOMEM = 48, exports.WASI_ENOMSG = 49, exports.WASI_ENOPROTOOPT = 50, exports.WASI_ENOSPC = 51, exports.WASI_ENOSYS = 52, exports.WASI_ENOTCONN = 53, exports.WASI_ENOTDIR = 54, exports.WASI_ENOTEMPTY = 55, exports.WASI_ENOTRECOVERABLE = 56, exports.WASI_ENOTSOCK = 57, exports.WASI_ENOTSUP = 58, exports.WASI_ENOTTY = 59, exports.WASI_ENXIO = 60, exports.WASI_EOVERFLOW = 61, exports.WASI_EOWNERDEAD = 62, exports.WASI_EPERM = 63, exports.WASI_EPIPE = 64, exports.WASI_EPROTO = 65, exports.WASI_EPROTONOSUPPORT = 66, exports.WASI_EPROTOTYPE = 67, exports.WASI_ERANGE = 68, exports.WASI_EROFS = 69, exports.WASI_ESPIPE = 70, exports.WASI_ESRCH = 71, exports.WASI_ESTALE = 72, exports.WASI_ETIMEDOUT = 73, exports.WASI_ETXTBSY = 74, exports.WASI_EXDEV = 75, exports.WASI_ENOTCAPABLE = 76, exports.WASI_SIGABRT = 0, exports.WASI_SIGALRM = 1, exports.WASI_SIGBUS = 2, exports.WASI_SIGCHLD = 3, exports.WASI_SIGCONT = 4, exports.WASI_SIGFPE = 5, exports.WASI_SIGHUP = 6, exports.WASI_SIGILL = 7, exports.WASI_SIGINT = 8, exports.WASI_SIGKILL = 9, exports.WASI_SIGPIPE = 10, exports.WASI_SIGQUIT = 11, exports.WASI_SIGSEGV = 12, exports.WASI_SIGSTOP = 13, exports.WASI_SIGTERM = 14, exports.WASI_SIGTRAP = 15, exports.WASI_SIGTSTP = 16, exports.WASI_SIGTTIN = 17, exports.WASI_SIGTTOU = 18, exports.WASI_SIGURG = 19, exports.WASI_SIGUSR1 = 20, exports.WASI_SIGUSR2 = 21, exports.WASI_SIGVTALRM = 22, exports.WASI_SIGXCPU = 23, exports.WASI_SIGXFSZ = 24, exports.WASI_FILETYPE_UNKNOWN = 0, exports.WASI_FILETYPE_BLOCK_DEVICE = 1, exports.WASI_FILETYPE_CHARACTER_DEVICE = 2, exports.WASI_FILETYPE_DIRECTORY = 3, exports.WASI_FILETYPE_REGULAR_FILE = 4, exports.WASI_FILETYPE_SOCKET_DGRAM = 5, exports.WASI_FILETYPE_SOCKET_STREAM = 6, exports.WASI_FILETYPE_SYMBOLIC_LINK = 7, exports.WASI_FDFLAG_APPEND = 1, exports.WASI_FDFLAG_DSYNC = 2, exports.WASI_FDFLAG_NONBLOCK = 4, exports.WASI_FDFLAG_RSYNC = 8, exports.WASI_FDFLAG_SYNC = 16, exports.WASI_RIGHT_FD_DATASYNC = BigInt(1), exports.WASI_RIGHT_FD_READ = BigInt(2), exports.WASI_RIGHT_FD_SEEK = BigInt(4), exports.WASI_RIGHT_FD_FDSTAT_SET_FLAGS = BigInt(8), exports.WASI_RIGHT_FD_SYNC = BigInt(16), exports.WASI_RIGHT_FD_TELL = BigInt(32), exports.WASI_RIGHT_FD_WRITE = BigInt(64), exports.WASI_RIGHT_FD_ADVISE = BigInt(128), exports.WASI_RIGHT_FD_ALLOCATE = BigInt(256), exports.WASI_RIGHT_PATH_CREATE_DIRECTORY = BigInt(512), exports.WASI_RIGHT_PATH_CREATE_FILE = BigInt(1024), exports.WASI_RIGHT_PATH_LINK_SOURCE = BigInt(2048), exports.WASI_RIGHT_PATH_LINK_TARGET = BigInt(4096), exports.WASI_RIGHT_PATH_OPEN = BigInt(8192), exports.WASI_RIGHT_FD_READDIR = BigInt(16384), exports.WASI_RIGHT_PATH_READLINK = BigInt(32768), exports.WASI_RIGHT_PATH_RENAME_SOURCE = BigInt(65536), exports.WASI_RIGHT_PATH_RENAME_TARGET = BigInt(131072), exports.WASI_RIGHT_PATH_FILESTAT_GET = BigInt(262144), exports.WASI_RIGHT_PATH_FILESTAT_SET_SIZE = BigInt(524288), exports.WASI_RIGHT_PATH_FILESTAT_SET_TIMES = BigInt(1048576), exports.WASI_RIGHT_FD_FILESTAT_GET = BigInt(2097152), exports.WASI_RIGHT_FD_FILESTAT_SET_SIZE = BigInt(4194304), exports.WASI_RIGHT_FD_FILESTAT_SET_TIMES = BigInt(8388608), exports.WASI_RIGHT_PATH_SYMLINK = BigInt(16777216), exports.WASI_RIGHT_PATH_REMOVE_DIRECTORY = BigInt(33554432), exports.WASI_RIGHT_PATH_UNLINK_FILE = BigInt(67108864), exports.WASI_RIGHT_POLL_FD_READWRITE = BigInt(134217728), exports.WASI_RIGHT_SOCK_SHUTDOWN = BigInt(268435456), exports.RIGHTS_ALL = exports.WASI_RIGHT_FD_DATASYNC | exports.WASI_RIGHT_FD_READ | exports.WASI_RIGHT_FD_SEEK | exports.WASI_RIGHT_FD_FDSTAT_SET_FLAGS | exports.WASI_RIGHT_FD_SYNC | exports.WASI_RIGHT_FD_TELL | exports.WASI_RIGHT_FD_WRITE | exports.WASI_RIGHT_FD_ADVISE | exports.WASI_RIGHT_FD_ALLOCATE | exports.WASI_RIGHT_PATH_CREATE_DIRECTORY | exports.WASI_RIGHT_PATH_CREATE_FILE | exports.WASI_RIGHT_PATH_LINK_SOURCE | exports.WASI_RIGHT_PATH_LINK_TARGET | exports.WASI_RIGHT_PATH_OPEN | exports.WASI_RIGHT_FD_READDIR | exports.WASI_RIGHT_PATH_READLINK | exports.WASI_RIGHT_PATH_RENAME_SOURCE | exports.WASI_RIGHT_PATH_RENAME_TARGET | exports.WASI_RIGHT_PATH_FILESTAT_GET | exports.WASI_RIGHT_PATH_FILESTAT_SET_SIZE | exports.WASI_RIGHT_PATH_FILESTAT_SET_TIMES | exports.WASI_RIGHT_FD_FILESTAT_GET | exports.WASI_RIGHT_FD_FILESTAT_SET_TIMES | exports.WASI_RIGHT_FD_FILESTAT_SET_SIZE | exports.WASI_RIGHT_PATH_SYMLINK | exports.WASI_RIGHT_PATH_UNLINK_FILE | exports.WASI_RIGHT_PATH_REMOVE_DIRECTORY | exports.WASI_RIGHT_POLL_FD_READWRITE | exports.WASI_RIGHT_SOCK_SHUTDOWN, exports.RIGHTS_BLOCK_DEVICE_BASE = exports.RIGHTS_ALL, exports.RIGHTS_BLOCK_DEVICE_INHERITING = exports.RIGHTS_ALL, exports.RIGHTS_CHARACTER_DEVICE_BASE = exports.RIGHTS_ALL, exports.RIGHTS_CHARACTER_DEVICE_INHERITING = exports.RIGHTS_ALL, exports.RIGHTS_REGULAR_FILE_BASE = exports.WASI_RIGHT_FD_DATASYNC | exports.WASI_RIGHT_FD_READ | exports.WASI_RIGHT_FD_SEEK | exports.WASI_RIGHT_FD_FDSTAT_SET_FLAGS | exports.WASI_RIGHT_FD_SYNC | exports.WASI_RIGHT_FD_TELL | exports.WASI_RIGHT_FD_WRITE | exports.WASI_RIGHT_FD_ADVISE | exports.WASI_RIGHT_FD_ALLOCATE | exports.WASI_RIGHT_FD_FILESTAT_GET | exports.WASI_RIGHT_FD_FILESTAT_SET_SIZE | exports.WASI_RIGHT_FD_FILESTAT_SET_TIMES | exports.WASI_RIGHT_POLL_FD_READWRITE, exports.RIGHTS_REGULAR_FILE_INHERITING = BigInt(0), exports.RIGHTS_DIRECTORY_BASE = exports.WASI_RIGHT_FD_FDSTAT_SET_FLAGS | exports.WASI_RIGHT_FD_SYNC | exports.WASI_RIGHT_FD_ADVISE | exports.WASI_RIGHT_PATH_CREATE_DIRECTORY | exports.WASI_RIGHT_PATH_CREATE_FILE | exports.WASI_RIGHT_PATH_LINK_SOURCE | exports.WASI_RIGHT_PATH_LINK_TARGET | exports.WASI_RIGHT_PATH_OPEN | exports.WASI_RIGHT_FD_READDIR | exports.WASI_RIGHT_PATH_READLINK | exports.WASI_RIGHT_PATH_RENAME_SOURCE | exports.WASI_RIGHT_PATH_RENAME_TARGET | exports.WASI_RIGHT_PATH_FILESTAT_GET | exports.WASI_RIGHT_PATH_FILESTAT_SET_SIZE | exports.WASI_RIGHT_PATH_FILESTAT_SET_TIMES | exports.WASI_RIGHT_FD_FILESTAT_GET | exports.WASI_RIGHT_FD_FILESTAT_SET_TIMES | exports.WASI_RIGHT_PATH_SYMLINK | exports.WASI_RIGHT_PATH_UNLINK_FILE | exports.WASI_RIGHT_PATH_REMOVE_DIRECTORY | exports.WASI_RIGHT_POLL_FD_READWRITE, exports.RIGHTS_DIRECTORY_INHERITING = exports.RIGHTS_DIRECTORY_BASE | exports.RIGHTS_REGULAR_FILE_BASE, exports.RIGHTS_SOCKET_BASE = exports.WASI_RIGHT_FD_READ | exports.WASI_RIGHT_FD_FDSTAT_SET_FLAGS | exports.WASI_RIGHT_FD_WRITE | exports.WASI_RIGHT_FD_FILESTAT_GET | exports.WASI_RIGHT_POLL_FD_READWRITE | exports.WASI_RIGHT_SOCK_SHUTDOWN, exports.RIGHTS_SOCKET_INHERITING = exports.RIGHTS_ALL, exports.RIGHTS_TTY_BASE = exports.WASI_RIGHT_FD_READ | exports.WASI_RIGHT_FD_FDSTAT_SET_FLAGS | exports.WASI_RIGHT_FD_WRITE | exports.WASI_RIGHT_FD_FILESTAT_GET | exports.WASI_RIGHT_POLL_FD_READWRITE, exports.RIGHTS_TTY_INHERITING = BigInt(0), exports.WASI_CLOCK_REALTIME = 0, exports.WASI_CLOCK_MONOTONIC = 1, exports.WASI_CLOCK_PROCESS_CPUTIME_ID = 2, exports.WASI_CLOCK_THREAD_CPUTIME_ID = 3, exports.WASI_EVENTTYPE_CLOCK = 0, exports.WASI_EVENTTYPE_FD_READ = 1, exports.WASI_EVENTTYPE_FD_WRITE = 2, exports.WASI_FILESTAT_SET_ATIM = 1 << 0, exports.WASI_FILESTAT_SET_ATIM_NOW = 1 << 1, exports.WASI_FILESTAT_SET_MTIM = 1 << 2, exports.WASI_FILESTAT_SET_MTIM_NOW = 1 << 3, exports.WASI_O_CREAT = 1 << 0, exports.WASI_O_DIRECTORY = 1 << 1, exports.WASI_O_EXCL = 1 << 2, exports.WASI_O_TRUNC = 1 << 3, exports.WASI_PREOPENTYPE_DIR = 0, exports.WASI_DIRCOOKIE_START = 0, exports.WASI_STDIN_FILENO = 0, exports.WASI_STDOUT_FILENO = 1, exports.WASI_STDERR_FILENO = 2, exports.WASI_WHENCE_SET = 0, exports.WASI_WHENCE_CUR = 1, exports.WASI_WHENCE_END = 2, exports.ERROR_MAP = {\n      E2BIG: exports.WASI_E2BIG,\n      EACCES: exports.WASI_EACCES,\n      EADDRINUSE: exports.WASI_EADDRINUSE,\n      EADDRNOTAVAIL: exports.WASI_EADDRNOTAVAIL,\n      EAFNOSUPPORT: exports.WASI_EAFNOSUPPORT,\n      EALREADY: exports.WASI_EALREADY,\n      EAGAIN: exports.WASI_EAGAIN,\n      EBADF: exports.WASI_EBADF,\n      EBADMSG: exports.WASI_EBADMSG,\n      EBUSY: exports.WASI_EBUSY,\n      ECANCELED: exports.WASI_ECANCELED,\n      ECHILD: exports.WASI_ECHILD,\n      ECONNABORTED: exports.WASI_ECONNABORTED,\n      ECONNREFUSED: exports.WASI_ECONNREFUSED,\n      ECONNRESET: exports.WASI_ECONNRESET,\n      EDEADLOCK: exports.WASI_EDEADLK,\n      EDESTADDRREQ: exports.WASI_EDESTADDRREQ,\n      EDOM: exports.WASI_EDOM,\n      EDQUOT: exports.WASI_EDQUOT,\n      EEXIST: exports.WASI_EEXIST,\n      EFAULT: exports.WASI_EFAULT,\n      EFBIG: exports.WASI_EFBIG,\n      EHOSTDOWN: exports.WASI_EHOSTUNREACH,\n      EHOSTUNREACH: exports.WASI_EHOSTUNREACH,\n      EIDRM: exports.WASI_EIDRM,\n      EILSEQ: exports.WASI_EILSEQ,\n      EINPROGRESS: exports.WASI_EINPROGRESS,\n      EINTR: exports.WASI_EINTR,\n      EINVAL: exports.WASI_EINVAL,\n      EIO: exports.WASI_EIO,\n      EISCONN: exports.WASI_EISCONN,\n      EISDIR: exports.WASI_EISDIR,\n      ELOOP: exports.WASI_ELOOP,\n      EMFILE: exports.WASI_EMFILE,\n      EMLINK: exports.WASI_EMLINK,\n      EMSGSIZE: exports.WASI_EMSGSIZE,\n      EMULTIHOP: exports.WASI_EMULTIHOP,\n      ENAMETOOLONG: exports.WASI_ENAMETOOLONG,\n      ENETDOWN: exports.WASI_ENETDOWN,\n      ENETRESET: exports.WASI_ENETRESET,\n      ENETUNREACH: exports.WASI_ENETUNREACH,\n      ENFILE: exports.WASI_ENFILE,\n      ENOBUFS: exports.WASI_ENOBUFS,\n      ENODEV: exports.WASI_ENODEV,\n      ENOENT: exports.WASI_ENOENT,\n      ENOEXEC: exports.WASI_ENOEXEC,\n      ENOLCK: exports.WASI_ENOLCK,\n      ENOLINK: exports.WASI_ENOLINK,\n      ENOMEM: exports.WASI_ENOMEM,\n      ENOMSG: exports.WASI_ENOMSG,\n      ENOPROTOOPT: exports.WASI_ENOPROTOOPT,\n      ENOSPC: exports.WASI_ENOSPC,\n      ENOSYS: exports.WASI_ENOSYS,\n      ENOTCONN: exports.WASI_ENOTCONN,\n      ENOTDIR: exports.WASI_ENOTDIR,\n      ENOTEMPTY: exports.WASI_ENOTEMPTY,\n      ENOTRECOVERABLE: exports.WASI_ENOTRECOVERABLE,\n      ENOTSOCK: exports.WASI_ENOTSOCK,\n      ENOTTY: exports.WASI_ENOTTY,\n      ENXIO: exports.WASI_ENXIO,\n      EOVERFLOW: exports.WASI_EOVERFLOW,\n      EOWNERDEAD: exports.WASI_EOWNERDEAD,\n      EPERM: exports.WASI_EPERM,\n      EPIPE: exports.WASI_EPIPE,\n      EPROTO: exports.WASI_EPROTO,\n      EPROTONOSUPPORT: exports.WASI_EPROTONOSUPPORT,\n      EPROTOTYPE: exports.WASI_EPROTOTYPE,\n      ERANGE: exports.WASI_ERANGE,\n      EROFS: exports.WASI_EROFS,\n      ESPIPE: exports.WASI_ESPIPE,\n      ESRCH: exports.WASI_ESRCH,\n      ESTALE: exports.WASI_ESTALE,\n      ETIMEDOUT: exports.WASI_ETIMEDOUT,\n      ETXTBSY: exports.WASI_ETXTBSY,\n      EXDEV: exports.WASI_EXDEV\n    }, exports.SIGNAL_MAP = {\n      [exports.WASI_SIGHUP]: \"SIGHUP\",\n      [exports.WASI_SIGINT]: \"SIGINT\",\n      [exports.WASI_SIGQUIT]: \"SIGQUIT\",\n      [exports.WASI_SIGILL]: \"SIGILL\",\n      [exports.WASI_SIGTRAP]: \"SIGTRAP\",\n      [exports.WASI_SIGABRT]: \"SIGABRT\",\n      [exports.WASI_SIGBUS]: \"SIGBUS\",\n      [exports.WASI_SIGFPE]: \"SIGFPE\",\n      [exports.WASI_SIGKILL]: \"SIGKILL\",\n      [exports.WASI_SIGUSR1]: \"SIGUSR1\",\n      [exports.WASI_SIGSEGV]: \"SIGSEGV\",\n      [exports.WASI_SIGUSR2]: \"SIGUSR2\",\n      [exports.WASI_SIGPIPE]: \"SIGPIPE\",\n      [exports.WASI_SIGALRM]: \"SIGALRM\",\n      [exports.WASI_SIGTERM]: \"SIGTERM\",\n      [exports.WASI_SIGCHLD]: \"SIGCHLD\",\n      [exports.WASI_SIGCONT]: \"SIGCONT\",\n      [exports.WASI_SIGSTOP]: \"SIGSTOP\",\n      [exports.WASI_SIGTSTP]: \"SIGTSTP\",\n      [exports.WASI_SIGTTIN]: \"SIGTTIN\",\n      [exports.WASI_SIGTTOU]: \"SIGTTOU\",\n      [exports.WASI_SIGURG]: \"SIGURG\",\n      [exports.WASI_SIGXCPU]: \"SIGXCPU\",\n      [exports.WASI_SIGXFSZ]: \"SIGXFSZ\",\n      [exports.WASI_SIGVTALRM]: \"SIGVTALRM\"\n    };\n  }\n}), require_wasi = __commonJS({\n  \"node_modules/wasi-js/dist/wasi.js\"(exports) {\n    var __importDefault = exports && exports.__importDefault || function(mod) {\n      return mod && mod.__esModule \? mod : { default: mod };\n    };\n    let fs;\n    Object.defineProperty(exports, \"__esModule\", { value: !0 }), exports.SOCKET_DEFAULT_RIGHTS = void 0;\n    var log = () => {\n    }, logOpen = () => {\n    }, SC_OPEN_MAX = 32768, types_1 = require_types(), constants_1 = require_constants(), STDIN_DEFAULT_RIGHTS = constants_1.WASI_RIGHT_FD_DATASYNC | constants_1.WASI_RIGHT_FD_READ | constants_1.WASI_RIGHT_FD_SYNC | constants_1.WASI_RIGHT_FD_ADVISE | constants_1.WASI_RIGHT_FD_FILESTAT_GET | constants_1.WASI_RIGHT_POLL_FD_READWRITE, STDOUT_DEFAULT_RIGHTS = constants_1.WASI_RIGHT_FD_DATASYNC | constants_1.WASI_RIGHT_FD_WRITE | constants_1.WASI_RIGHT_FD_SYNC | constants_1.WASI_RIGHT_FD_ADVISE | constants_1.WASI_RIGHT_FD_FILESTAT_GET | constants_1.WASI_RIGHT_POLL_FD_READWRITE, STDERR_DEFAULT_RIGHTS = STDOUT_DEFAULT_RIGHTS;\n    exports.SOCKET_DEFAULT_RIGHTS = constants_1.WASI_RIGHT_FD_DATASYNC | constants_1.WASI_RIGHT_FD_READ | constants_1.WASI_RIGHT_FD_WRITE | constants_1.WASI_RIGHT_FD_ADVISE | constants_1.WASI_RIGHT_FD_FILESTAT_GET | constants_1.WASI_RIGHT_POLL_FD_READWRITE | constants_1.WASI_RIGHT_FD_FDSTAT_SET_FLAGS;\n    var msToNs = (ms) => {\n      const msInt = Math.trunc(ms), decimal = BigInt(Math.round((ms - msInt) * 1e6));\n      return BigInt(msInt) * BigInt(1e6) + decimal;\n    }, nsToMs = (ns) => {\n      if (typeof ns === \"number\")\n        ns = Math.trunc(ns);\n      const nsInt = BigInt(ns);\n      return Number(nsInt / BigInt(1e6));\n    }, wrap = (f) => (...args) => {\n      try {\n        return f(...args);\n      } catch (err) {\n        let e = err;\n        while (e.prev != null)\n          e = e.prev;\n        if (e\?.code && typeof e\?.code === \"string\")\n          return constants_1.ERROR_MAP[e.code] || constants_1.WASI_EINVAL;\n        if (e instanceof types_1.WASIError)\n          return e.errno;\n        throw e;\n      }\n    }, stat = (wasi, fd) => {\n      const entry = wasi.FD_MAP.get(fd);\n      if (!entry)\n        throw new types_1.WASIError(constants_1.WASI_EBADF);\n      if (entry.filetype === void 0) {\n        const stats = wasi.fstatSync(entry.real), { filetype, rightsBase, rightsInheriting } = translateFileAttributes(wasi, fd, stats);\n        if (entry.filetype = filetype, !entry.rights)\n          entry.rights = {\n            base: rightsBase,\n            inheriting: rightsInheriting\n          };\n      }\n      return entry;\n    }, translateFileAttributes = (wasi, fd, stats) => {\n      switch (!0) {\n        case stats.isBlockDevice():\n          return {\n            filetype: constants_1.WASI_FILETYPE_BLOCK_DEVICE,\n            rightsBase: constants_1.RIGHTS_BLOCK_DEVICE_BASE,\n            rightsInheriting: constants_1.RIGHTS_BLOCK_DEVICE_INHERITING\n          };\n        case stats.isCharacterDevice(): {\n          const filetype = constants_1.WASI_FILETYPE_CHARACTER_DEVICE;\n          if (fd !== void 0 && wasi.bindings.isTTY(fd))\n            return {\n              filetype,\n              rightsBase: constants_1.RIGHTS_TTY_BASE,\n              rightsInheriting: constants_1.RIGHTS_TTY_INHERITING\n            };\n          return {\n            filetype,\n            rightsBase: constants_1.RIGHTS_CHARACTER_DEVICE_BASE,\n            rightsInheriting: constants_1.RIGHTS_CHARACTER_DEVICE_INHERITING\n          };\n        }\n        case stats.isDirectory():\n          return {\n            filetype: constants_1.WASI_FILETYPE_DIRECTORY,\n            rightsBase: constants_1.RIGHTS_DIRECTORY_BASE,\n            rightsInheriting: constants_1.RIGHTS_DIRECTORY_INHERITING\n          };\n        case stats.isFIFO():\n          return {\n            filetype: constants_1.WASI_FILETYPE_SOCKET_STREAM,\n            rightsBase: constants_1.RIGHTS_SOCKET_BASE,\n            rightsInheriting: constants_1.RIGHTS_SOCKET_INHERITING\n          };\n        case stats.isFile():\n          return {\n            filetype: constants_1.WASI_FILETYPE_REGULAR_FILE,\n            rightsBase: constants_1.RIGHTS_REGULAR_FILE_BASE,\n            rightsInheriting: constants_1.RIGHTS_REGULAR_FILE_INHERITING\n          };\n        case stats.isSocket():\n          return {\n            filetype: constants_1.WASI_FILETYPE_SOCKET_STREAM,\n            rightsBase: constants_1.RIGHTS_SOCKET_BASE,\n            rightsInheriting: constants_1.RIGHTS_SOCKET_INHERITING\n          };\n        case stats.isSymbolicLink():\n          return {\n            filetype: constants_1.WASI_FILETYPE_SYMBOLIC_LINK,\n            rightsBase: BigInt(0),\n            rightsInheriting: BigInt(0)\n          };\n        default:\n          return {\n            filetype: constants_1.WASI_FILETYPE_UNKNOWN,\n            rightsBase: BigInt(0),\n            rightsInheriting: BigInt(0)\n          };\n      }\n    }, warnedAboutSleep = !1, defaultConfig;\n    function getDefaults() {\n      if (defaultConfig)\n        return defaultConfig;\n      const defaultBindings = {\n        hrtime: () => process.hrtime.bigint(),\n        exit: (code) => {\n          process.exit(code);\n        },\n        kill: (signal) => {\n          process.kill(process.pid, signal);\n        },\n        randomFillSync: (array) => crypto.getRandomValues(array),\n        isTTY: (fd) => @requireNativeModule(\"node:tty\").isatty(fd),\n        fs: Bun.fs(),\n        path: @getInternalField(@internalModuleRegistry, 26) || @createInternalModuleById(26)\n      };\n      return defaultConfig = {\n        args: [],\n        env: {},\n        preopens: {},\n        bindings: defaultBindings,\n        sleep: (ms) => {\n          Bun.sleepSync(ms);\n        }\n      };\n    }\n    var WASI = class WASI2 {\n      constructor(wasiConfig = {}) {\n        const defaultConfig2 = getDefaults();\n        this.lastStdin = 0, this.sleep = wasiConfig.sleep || defaultConfig2.sleep, this.getStdin = wasiConfig.getStdin, this.sendStdout = wasiConfig.sendStdout, this.sendStderr = wasiConfig.sendStderr;\n        let preopens = wasiConfig.preopens \?\? defaultConfig2.preopens;\n        this.env = wasiConfig.env \?\? defaultConfig2.env;\n        const args = wasiConfig.args \?\? defaultConfig2.args;\n        this.memory = void 0, this.view = void 0, this.bindings = wasiConfig.bindings || defaultConfig2.bindings;\n        const bindings2 = this.bindings;\n        fs = bindings2.fs, this.FD_MAP = new Map([\n          [\n            constants_1.WASI_STDIN_FILENO,\n            {\n              real: 0,\n              filetype: constants_1.WASI_FILETYPE_CHARACTER_DEVICE,\n              rights: {\n                base: STDIN_DEFAULT_RIGHTS,\n                inheriting: BigInt(0)\n              },\n              path: \"/dev/stdin\"\n            }\n          ],\n          [\n            constants_1.WASI_STDOUT_FILENO,\n            {\n              real: 1,\n              filetype: constants_1.WASI_FILETYPE_CHARACTER_DEVICE,\n              rights: {\n                base: STDOUT_DEFAULT_RIGHTS,\n                inheriting: BigInt(0)\n              },\n              path: \"/dev/stdout\"\n            }\n          ],\n          [\n            constants_1.WASI_STDERR_FILENO,\n            {\n              real: 2,\n              filetype: constants_1.WASI_FILETYPE_CHARACTER_DEVICE,\n              rights: {\n                base: STDERR_DEFAULT_RIGHTS,\n                inheriting: BigInt(0)\n              },\n              path: \"/dev/stderr\"\n            }\n          ]\n        ]);\n        const path = bindings2.path;\n        for (let [k, v] of Object.entries(preopens)) {\n          const real = fs.openSync(v, nodeFsConstants.O_RDONLY), newfd = this.getUnusedFileDescriptor();\n          this.FD_MAP.set(newfd, {\n            real,\n            filetype: constants_1.WASI_FILETYPE_DIRECTORY,\n            rights: {\n              base: constants_1.RIGHTS_DIRECTORY_BASE,\n              inheriting: constants_1.RIGHTS_DIRECTORY_INHERITING\n            },\n            fakePath: k,\n            path: v\n          });\n        }\n        const getiovs = (iovs, iovsLen) => {\n          this.refreshMemory();\n          const { view, memory } = this, { buffer } = memory, { byteLength } = buffer;\n          if (iovsLen === 1) {\n            const ptr = iovs, buf = view.getUint32(ptr, !0);\n            let bufLen = view.getUint32(ptr + 4, !0);\n            if (bufLen > byteLength - buf)\n              console.log({\n                buf,\n                bufLen,\n                total_memory: byteLength\n              }), log(\"getiovs: warning -- truncating buffer to fit in memory\"), bufLen = Math.min(bufLen, Math.max(0, byteLength - buf));\n            try {\n              return [new Uint8Array(buffer, buf, bufLen)];\n            } catch (err) {\n              throw console.warn(\"WASI.getiovs -- invalid buffer\", err), new types_1.WASIError(constants_1.WASI_EINVAL);\n            }\n          }\n          const buffers = [];\n          buffers.length = iovsLen;\n          for (let i = 0, ptr = iovs;i < iovsLen; i++, ptr += 8) {\n            const buf = view.getUint32(ptr, !0);\n            let bufLen = view.getUint32(ptr + 4, !0);\n            if (bufLen > byteLength - buf)\n              console.log({\n                buf,\n                bufLen,\n                total_memory: byteLength\n              }), log(\"getiovs: warning -- truncating buffer to fit in memory\"), bufLen = Math.min(bufLen, Math.max(0, byteLength - buf));\n            try {\n              buffers[i] = new Uint8Array(buffer, buf, bufLen);\n            } catch (err) {\n              throw console.warn(\"WASI.getiovs -- invalid buffer\", err), new types_1.WASIError(constants_1.WASI_EINVAL);\n            }\n          }\n          return buffers;\n        }, CHECK_FD = (fd, rights) => {\n          const stats = stat(this, fd);\n          if (rights !== BigInt(0) && (stats.rights.base & rights) === BigInt(0))\n            throw new types_1.WASIError(constants_1.WASI_EPERM);\n          return stats;\n        }, CPUTIME_START = Bun.nanoseconds(), timeOrigin = Math.trunc(performance.timeOrigin * 1e6), now = (clockId) => {\n          switch (clockId) {\n            case constants_1.WASI_CLOCK_MONOTONIC:\n              return Bun.nanoseconds();\n            case constants_1.WASI_CLOCK_REALTIME:\n              return Bun.nanoseconds() + timeOrigin;\n            case constants_1.WASI_CLOCK_PROCESS_CPUTIME_ID:\n            case constants_1.WASI_CLOCK_THREAD_CPUTIME_ID:\n              return Bun.nanoseconds() - CPUTIME_START;\n            default:\n              return null;\n          }\n        };\n        if (this.wasiImport = {\n          args_get: (argv, argvBuf) => {\n            this.refreshMemory();\n            let coffset = argv, offset = argvBuf;\n            return args.forEach((a) => {\n              this.view.setUint32(coffset, offset, !0), coffset += 4, offset += Buffer.from(this.memory.buffer).write(`${a}\\0`, offset);\n            }), constants_1.WASI_ESUCCESS;\n          },\n          args_sizes_get: (argc, argvBufSize) => {\n            this.refreshMemory(), this.view.setUint32(argc, args.length, !0);\n            const size = args.reduce((acc, a) => acc + Buffer.byteLength(a) + 1, 0);\n            return this.view.setUint32(argvBufSize, size, !0), constants_1.WASI_ESUCCESS;\n          },\n          environ_get: (environ, environBuf) => {\n            this.refreshMemory();\n            let coffset = environ, offset = environBuf;\n            return Object.entries(this.env).forEach(([key, value]) => {\n              this.view.setUint32(coffset, offset, !0), coffset += 4, offset += Buffer.from(this.memory.buffer).write(`${key}=${value}\\0`, offset);\n            }), constants_1.WASI_ESUCCESS;\n          },\n          environ_sizes_get: (environCount, environBufSize) => {\n            this.refreshMemory();\n            const envProcessed = Object.entries(this.env).map(([key, value]) => `${key}=${value}\\0`), size = envProcessed.reduce((acc, e) => acc + Buffer.byteLength(e), 0);\n            return this.view.setUint32(environCount, envProcessed.length, !0), this.view.setUint32(environBufSize, size, !0), constants_1.WASI_ESUCCESS;\n          },\n          clock_res_get: (clockId, resolution) => {\n            let res;\n            switch (clockId) {\n              case constants_1.WASI_CLOCK_MONOTONIC:\n              case constants_1.WASI_CLOCK_PROCESS_CPUTIME_ID:\n              case constants_1.WASI_CLOCK_THREAD_CPUTIME_ID: {\n                res = BigInt(1);\n                break;\n              }\n              case constants_1.WASI_CLOCK_REALTIME: {\n                res = BigInt(1000);\n                break;\n              }\n            }\n            if (!res)\n              throw Error(\"invalid clockId\");\n            return this.view.setBigUint64(resolution, res), constants_1.WASI_ESUCCESS;\n          },\n          clock_time_get: (clockId, _precision, time) => {\n            this.refreshMemory();\n            const n = now(clockId);\n            if (n === null)\n              return constants_1.WASI_EINVAL;\n            return this.view.setBigUint64(time, BigInt(n), !0), constants_1.WASI_ESUCCESS;\n          },\n          fd_advise: wrap((fd, _offset, _len, _advice) => {\n            return CHECK_FD(fd, constants_1.WASI_RIGHT_FD_ADVISE), constants_1.WASI_ENOSYS;\n          }),\n          fd_allocate: wrap((fd, _offset, _len) => {\n            return CHECK_FD(fd, constants_1.WASI_RIGHT_FD_ALLOCATE), constants_1.WASI_ENOSYS;\n          }),\n          fd_close: wrap((fd) => {\n            const stats = CHECK_FD(fd, BigInt(0));\n            return fs.closeSync(stats.real), this.FD_MAP.delete(fd), constants_1.WASI_ESUCCESS;\n          }),\n          fd_datasync: wrap((fd) => {\n            const stats = CHECK_FD(fd, constants_1.WASI_RIGHT_FD_DATASYNC);\n            return fs.fdatasyncSync(stats.real), constants_1.WASI_ESUCCESS;\n          }),\n          fd_fdstat_get: wrap((fd, bufPtr) => {\n            const stats = CHECK_FD(fd, BigInt(0));\n            if (this.refreshMemory(), stats.filetype == null)\n              throw Error(\"stats.filetype must be set\");\n            return this.view.setUint8(bufPtr, stats.filetype), this.view.setUint16(bufPtr + 2, 0, !0), this.view.setUint16(bufPtr + 4, 0, !0), this.view.setBigUint64(bufPtr + 8, BigInt(stats.rights.base), !0), this.view.setBigUint64(bufPtr + 8 + 8, BigInt(stats.rights.inheriting), !0), constants_1.WASI_ESUCCESS;\n          }),\n          fd_fdstat_set_flags: wrap((fd, flags) => {\n            if (CHECK_FD(fd, constants_1.WASI_RIGHT_FD_FDSTAT_SET_FLAGS), this.wasiImport.sock_fcntlSetFlags(fd, flags) == 0)\n              return constants_1.WASI_ESUCCESS;\n            return constants_1.WASI_ENOSYS;\n          }),\n          fd_fdstat_set_rights: wrap((fd, fsRightsBase, fsRightsInheriting) => {\n            const stats = CHECK_FD(fd, BigInt(0));\n            if ((stats.rights.base | fsRightsBase) > stats.rights.base)\n              return constants_1.WASI_EPERM;\n            if ((stats.rights.inheriting | fsRightsInheriting) > stats.rights.inheriting)\n              return constants_1.WASI_EPERM;\n            return stats.rights.base = fsRightsBase, stats.rights.inheriting = fsRightsInheriting, constants_1.WASI_ESUCCESS;\n          }),\n          fd_filestat_get: wrap((fd, bufPtr) => {\n            const stats = CHECK_FD(fd, constants_1.WASI_RIGHT_FD_FILESTAT_GET), rstats = this.fstatSync(stats.real);\n            if (this.refreshMemory(), this.view.setBigUint64(bufPtr, BigInt(rstats.dev), !0), bufPtr += 8, this.view.setBigUint64(bufPtr, BigInt(rstats.ino), !0), bufPtr += 8, stats.filetype == null)\n              throw Error(\"stats.filetype must be set\");\n            return this.view.setUint8(bufPtr, stats.filetype), bufPtr += 8, this.view.setBigUint64(bufPtr, BigInt(rstats.nlink), !0), bufPtr += 8, this.view.setBigUint64(bufPtr, BigInt(rstats.size), !0), bufPtr += 8, this.view.setBigUint64(bufPtr, msToNs(rstats.atimeMs), !0), bufPtr += 8, this.view.setBigUint64(bufPtr, msToNs(rstats.mtimeMs), !0), bufPtr += 8, this.view.setBigUint64(bufPtr, msToNs(rstats.ctimeMs), !0), constants_1.WASI_ESUCCESS;\n          }),\n          fd_filestat_set_size: wrap((fd, stSize) => {\n            const stats = CHECK_FD(fd, constants_1.WASI_RIGHT_FD_FILESTAT_SET_SIZE);\n            return fs.ftruncateSync(stats.real, Number(stSize)), constants_1.WASI_ESUCCESS;\n          }),\n          fd_filestat_set_times: wrap((fd, stAtim, stMtim, fstflags) => {\n            const stats = CHECK_FD(fd, constants_1.WASI_RIGHT_FD_FILESTAT_SET_TIMES), rstats = this.fstatSync(stats.real);\n            let { atime: atim, mtime: mtim } = rstats;\n            const n = nsToMs(now(constants_1.WASI_CLOCK_REALTIME)), atimflags = constants_1.WASI_FILESTAT_SET_ATIM | constants_1.WASI_FILESTAT_SET_ATIM_NOW;\n            if ((fstflags & atimflags) === atimflags)\n              return constants_1.WASI_EINVAL;\n            const mtimflags = constants_1.WASI_FILESTAT_SET_MTIM | constants_1.WASI_FILESTAT_SET_MTIM_NOW;\n            if ((fstflags & mtimflags) === mtimflags)\n              return constants_1.WASI_EINVAL;\n            if ((fstflags & constants_1.WASI_FILESTAT_SET_ATIM) === constants_1.WASI_FILESTAT_SET_ATIM)\n              atim = nsToMs(stAtim);\n            else if ((fstflags & constants_1.WASI_FILESTAT_SET_ATIM_NOW) === constants_1.WASI_FILESTAT_SET_ATIM_NOW)\n              atim = n;\n            if ((fstflags & constants_1.WASI_FILESTAT_SET_MTIM) === constants_1.WASI_FILESTAT_SET_MTIM)\n              mtim = nsToMs(stMtim);\n            else if ((fstflags & constants_1.WASI_FILESTAT_SET_MTIM_NOW) === constants_1.WASI_FILESTAT_SET_MTIM_NOW)\n              mtim = n;\n            return fs.futimesSync(stats.real, new Date(atim), new Date(mtim)), constants_1.WASI_ESUCCESS;\n          }),\n          fd_prestat_get: wrap((fd, bufPtr) => {\n            const stats = CHECK_FD(fd, BigInt(0));\n            return this.refreshMemory(), this.view.setUint8(bufPtr, constants_1.WASI_PREOPENTYPE_DIR), this.view.setUint32(bufPtr + 4, Buffer.byteLength(stats.fakePath \?\? stats.path \?\? \"\"), !0), constants_1.WASI_ESUCCESS;\n          }),\n          fd_prestat_dir_name: wrap((fd, pathPtr, pathLen) => {\n            const stats = CHECK_FD(fd, BigInt(0));\n            return this.refreshMemory(), Buffer.from(this.memory.buffer).write(stats.fakePath \?\? stats.path \?\? \"\", pathPtr, pathLen, \"utf8\"), constants_1.WASI_ESUCCESS;\n          }),\n          fd_pwrite: wrap((fd, iovs, iovsLen, offset, nwritten) => {\n            const stats = CHECK_FD(fd, constants_1.WASI_RIGHT_FD_WRITE | constants_1.WASI_RIGHT_FD_SEEK);\n            let written = 0;\n            return getiovs(iovs, iovsLen).forEach((iov) => {\n              let w = 0;\n              while (w < iov.byteLength)\n                w += fs.writeSync(stats.real, iov, w, iov.byteLength - w, Number(offset) + written + w);\n              written += w;\n            }), this.view.setUint32(nwritten, written, !0), constants_1.WASI_ESUCCESS;\n          }),\n          fd_write: wrap((fd, iovs, iovsLen, nwritten) => {\n            const stats = CHECK_FD(fd, constants_1.WASI_RIGHT_FD_WRITE), IS_STDOUT = fd == constants_1.WASI_STDOUT_FILENO, IS_STDERR = fd == constants_1.WASI_STDERR_FILENO;\n            let written = 0;\n            return getiovs(iovs, iovsLen).forEach((iov) => {\n              if (iov.byteLength == 0)\n                return;\n              if (IS_STDOUT && this.sendStdout != null)\n                this.sendStdout(iov), written += iov.byteLength;\n              else if (IS_STDERR && this.sendStderr != null)\n                this.sendStderr(iov), written += iov.byteLength;\n              else {\n                let w = 0;\n                while (w < iov.byteLength) {\n                  const i = fs.writeSync(stats.real, iov, w, iov.byteLength - w, stats.offset \? Number(stats.offset) : null);\n                  if (stats.offset)\n                    stats.offset += BigInt(i);\n                  w += i;\n                }\n                written += w;\n              }\n            }), this.view.setUint32(nwritten, written, !0), constants_1.WASI_ESUCCESS;\n          }),\n          fd_pread: wrap((fd, iovs, iovsLen, offset, nread) => {\n            const stats = CHECK_FD(fd, constants_1.WASI_RIGHT_FD_READ | constants_1.WASI_RIGHT_FD_SEEK);\n            let read = 0;\n            outer:\n              for (let iov of getiovs(iovs, iovsLen)) {\n                let r = 0;\n                while (r < iov.byteLength) {\n                  const length = iov.byteLength - r, rr = fs.readSync(stats.real, iov, r, iov.byteLength - r, Number(offset) + read + r);\n                  if (r += rr, read += rr, rr === 0 || rr < length)\n                    break outer;\n                }\n                read += r;\n              }\n            return this.view.setUint32(nread, read, !0), constants_1.WASI_ESUCCESS;\n          }),\n          fd_read: wrap((fd, iovs, iovsLen, nread) => {\n            const stats = CHECK_FD(fd, constants_1.WASI_RIGHT_FD_READ), IS_STDIN = fd == constants_1.WASI_STDIN_FILENO;\n            let read = 0;\n            outer:\n              for (let iov of getiovs(iovs, iovsLen)) {\n                let r = 0;\n                while (r < iov.byteLength) {\n                  let length = iov.byteLength - r, position = IS_STDIN || stats.offset === void 0 \? null : Number(stats.offset), rr = 0;\n                  if (IS_STDIN)\n                    if (this.getStdin != null) {\n                      if (this.stdinBuffer == null)\n                        this.stdinBuffer = this.getStdin();\n                      if (this.stdinBuffer != null) {\n                        if (rr = this.stdinBuffer.copy(iov), rr == this.stdinBuffer.length)\n                          this.stdinBuffer = void 0;\n                        else\n                          this.stdinBuffer = this.stdinBuffer.slice(rr);\n                        if (rr > 0)\n                          this.lastStdin = (new Date()).valueOf();\n                      }\n                    } else {\n                      if (this.sleep == null && !warnedAboutSleep)\n                        warnedAboutSleep = !0, console.log(\"(cpu waiting for stdin: please define a way to sleep!) \");\n                      try {\n                        rr = fs.readSync(stats.real, iov, r, length, position);\n                      } catch (_err) {\n                      }\n                      if (rr == 0)\n                        this.shortPause();\n                      else\n                        this.lastStdin = (new Date()).valueOf();\n                    }\n                  else\n                    rr = fs.readSync(stats.real, iov, r, length, position);\n                  if (stats.filetype == constants_1.WASI_FILETYPE_REGULAR_FILE)\n                    stats.offset = (stats.offset \? stats.offset : BigInt(0)) + BigInt(rr);\n                  if (r += rr, read += rr, rr === 0 || rr < length)\n                    break outer;\n                }\n              }\n            return this.view.setUint32(nread, read, !0), constants_1.WASI_ESUCCESS;\n          }),\n          fd_readdir: wrap((fd, bufPtr, bufLen, cookie, bufusedPtr) => {\n            const stats = CHECK_FD(fd, constants_1.WASI_RIGHT_FD_READDIR);\n            this.refreshMemory();\n            const entries = fs.readdirSync(stats.path, { withFileTypes: !0 }), startPtr = bufPtr;\n            for (let i = Number(cookie);i < entries.length; i += 1) {\n              const entry = entries[i];\n              let nameLength = Buffer.byteLength(entry.name);\n              if (bufPtr - startPtr > bufLen)\n                break;\n              if (this.view.setBigUint64(bufPtr, BigInt(i + 1), !0), bufPtr += 8, bufPtr - startPtr > bufLen)\n                break;\n              const rstats = fs.lstatSync(path.resolve(stats.path, entry.name));\n              if (this.view.setBigUint64(bufPtr, BigInt(rstats.ino), !0), bufPtr += 8, bufPtr - startPtr > bufLen)\n                break;\n              if (this.view.setUint32(bufPtr, nameLength, !0), bufPtr += 4, bufPtr - startPtr > bufLen)\n                break;\n              let filetype;\n              switch (!0) {\n                case rstats.isBlockDevice():\n                  filetype = constants_1.WASI_FILETYPE_BLOCK_DEVICE;\n                  break;\n                case rstats.isCharacterDevice():\n                  filetype = constants_1.WASI_FILETYPE_CHARACTER_DEVICE;\n                  break;\n                case rstats.isDirectory():\n                  filetype = constants_1.WASI_FILETYPE_DIRECTORY;\n                  break;\n                case rstats.isFIFO():\n                  filetype = constants_1.WASI_FILETYPE_SOCKET_STREAM;\n                  break;\n                case rstats.isFile():\n                  filetype = constants_1.WASI_FILETYPE_REGULAR_FILE;\n                  break;\n                case rstats.isSocket():\n                  filetype = constants_1.WASI_FILETYPE_SOCKET_STREAM;\n                  break;\n                case rstats.isSymbolicLink():\n                  filetype = constants_1.WASI_FILETYPE_SYMBOLIC_LINK;\n                  break;\n                default:\n                  filetype = constants_1.WASI_FILETYPE_UNKNOWN;\n                  break;\n              }\n              if (this.view.setUint8(bufPtr, filetype), bufPtr += 1, bufPtr += 3, bufPtr + nameLength >= startPtr + bufLen)\n                break;\n              Buffer.from(this.memory.buffer).write(entry.name, bufPtr), bufPtr += nameLength;\n            }\n            const bufused = bufPtr - startPtr;\n            return this.view.setUint32(bufusedPtr, Math.min(bufused, bufLen), !0), constants_1.WASI_ESUCCESS;\n          }),\n          fd_renumber: wrap((from, to) => {\n            return CHECK_FD(from, BigInt(0)), CHECK_FD(to, BigInt(0)), fs.closeSync(this.FD_MAP.get(from).real), this.FD_MAP.set(from, this.FD_MAP.get(to)), this.FD_MAP.delete(to), constants_1.WASI_ESUCCESS;\n          }),\n          fd_seek: wrap((fd, offset, whence, newOffsetPtr) => {\n            const stats = CHECK_FD(fd, constants_1.WASI_RIGHT_FD_SEEK);\n            switch (this.refreshMemory(), whence) {\n              case constants_1.WASI_WHENCE_CUR:\n                stats.offset = (stats.offset \? stats.offset : BigInt(0)) + BigInt(offset);\n                break;\n              case constants_1.WASI_WHENCE_END:\n                const { size } = this.fstatSync(stats.real);\n                stats.offset = BigInt(size) + BigInt(offset);\n                break;\n              case constants_1.WASI_WHENCE_SET:\n                stats.offset = BigInt(offset);\n                break;\n            }\n            if (stats.offset == null)\n              throw Error(\"stats.offset must be defined\");\n            return this.view.setBigUint64(newOffsetPtr, stats.offset, !0), constants_1.WASI_ESUCCESS;\n          }),\n          fd_tell: wrap((fd, offsetPtr) => {\n            const stats = CHECK_FD(fd, constants_1.WASI_RIGHT_FD_TELL);\n            if (this.refreshMemory(), !stats.offset)\n              stats.offset = BigInt(0);\n            return this.view.setBigUint64(offsetPtr, stats.offset, !0), constants_1.WASI_ESUCCESS;\n          }),\n          fd_sync: wrap((fd) => {\n            const stats = CHECK_FD(fd, constants_1.WASI_RIGHT_FD_SYNC);\n            return fs.fsyncSync(stats.real), constants_1.WASI_ESUCCESS;\n          }),\n          path_create_directory: wrap((fd, pathPtr, pathLen) => {\n            const stats = CHECK_FD(fd, constants_1.WASI_RIGHT_PATH_CREATE_DIRECTORY);\n            if (!stats.path)\n              return constants_1.WASI_EINVAL;\n            this.refreshMemory();\n            const p = Buffer.from(this.memory.buffer, pathPtr, pathLen).toString();\n            return fs.mkdirSync(path.resolve(stats.path, p)), constants_1.WASI_ESUCCESS;\n          }),\n          path_filestat_get: wrap((fd, flags, pathPtr, pathLen, bufPtr) => {\n            const stats = CHECK_FD(fd, constants_1.WASI_RIGHT_PATH_FILESTAT_GET);\n            if (!stats.path)\n              return constants_1.WASI_EINVAL;\n            this.refreshMemory();\n            const p = Buffer.from(this.memory.buffer, pathPtr, pathLen).toString();\n            let rstats;\n            if (flags)\n              rstats = fs.statSync(path.resolve(stats.path, p));\n            else\n              rstats = fs.lstatSync(path.resolve(stats.path, p));\n            return this.view.setBigUint64(bufPtr, BigInt(rstats.dev), !0), bufPtr += 8, this.view.setBigUint64(bufPtr, BigInt(rstats.ino), !0), bufPtr += 8, this.view.setUint8(bufPtr, translateFileAttributes(this, void 0, rstats).filetype), bufPtr += 8, this.view.setBigUint64(bufPtr, BigInt(rstats.nlink), !0), bufPtr += 8, this.view.setBigUint64(bufPtr, BigInt(rstats.size), !0), bufPtr += 8, this.view.setBigUint64(bufPtr, BigInt(rstats.atime.getTime() * 1e6), !0), bufPtr += 8, this.view.setBigUint64(bufPtr, BigInt(rstats.mtime.getTime() * 1e6), !0), bufPtr += 8, this.view.setBigUint64(bufPtr, BigInt(rstats.ctime.getTime() * 1e6), !0), constants_1.WASI_ESUCCESS;\n          }),\n          path_filestat_set_times: wrap((fd, _dirflags, pathPtr, pathLen, stAtim, stMtim, fstflags) => {\n            const stats = CHECK_FD(fd, constants_1.WASI_RIGHT_PATH_FILESTAT_SET_TIMES);\n            if (!stats.path)\n              return constants_1.WASI_EINVAL;\n            this.refreshMemory();\n            const rstats = this.fstatSync(stats.real);\n            let { atime: atim, mtime: mtim } = rstats;\n            const n = nsToMs(now(constants_1.WASI_CLOCK_REALTIME)), atimflags = constants_1.WASI_FILESTAT_SET_ATIM | constants_1.WASI_FILESTAT_SET_ATIM_NOW;\n            if ((fstflags & atimflags) === atimflags)\n              return constants_1.WASI_EINVAL;\n            const mtimflags = constants_1.WASI_FILESTAT_SET_MTIM | constants_1.WASI_FILESTAT_SET_MTIM_NOW;\n            if ((fstflags & mtimflags) === mtimflags)\n              return constants_1.WASI_EINVAL;\n            if ((fstflags & constants_1.WASI_FILESTAT_SET_ATIM) === constants_1.WASI_FILESTAT_SET_ATIM)\n              atim = nsToMs(stAtim);\n            else if ((fstflags & constants_1.WASI_FILESTAT_SET_ATIM_NOW) === constants_1.WASI_FILESTAT_SET_ATIM_NOW)\n              atim = n;\n            if ((fstflags & constants_1.WASI_FILESTAT_SET_MTIM) === constants_1.WASI_FILESTAT_SET_MTIM)\n              mtim = nsToMs(stMtim);\n            else if ((fstflags & constants_1.WASI_FILESTAT_SET_MTIM_NOW) === constants_1.WASI_FILESTAT_SET_MTIM_NOW)\n              mtim = n;\n            const p = Buffer.from(this.memory.buffer, pathPtr, pathLen).toString();\n            return fs.utimesSync(path.resolve(stats.path, p), new Date(atim), new Date(mtim)), constants_1.WASI_ESUCCESS;\n          }),\n          path_link: wrap((oldFd, _oldFlags, oldPath, oldPathLen, newFd, newPath, newPathLen) => {\n            const ostats = CHECK_FD(oldFd, constants_1.WASI_RIGHT_PATH_LINK_SOURCE), nstats = CHECK_FD(newFd, constants_1.WASI_RIGHT_PATH_LINK_TARGET);\n            if (!ostats.path || !nstats.path)\n              return constants_1.WASI_EINVAL;\n            this.refreshMemory();\n            const op = Buffer.from(this.memory.buffer, oldPath, oldPathLen).toString(), np = Buffer.from(this.memory.buffer, newPath, newPathLen).toString();\n            return fs.linkSync(path.resolve(ostats.path, op), path.resolve(nstats.path, np)), constants_1.WASI_ESUCCESS;\n          }),\n          path_open: wrap((dirfd, _dirflags, pathPtr, pathLen, oflags, fsRightsBase, fsRightsInheriting, fsFlags, fdPtr) => {\n            try {\n              const stats = CHECK_FD(dirfd, constants_1.WASI_RIGHT_PATH_OPEN);\n              fsRightsBase = BigInt(fsRightsBase), fsRightsInheriting = BigInt(fsRightsInheriting);\n              const read = (fsRightsBase & (constants_1.WASI_RIGHT_FD_READ | constants_1.WASI_RIGHT_FD_READDIR)) !== BigInt(0), write = (fsRightsBase & (constants_1.WASI_RIGHT_FD_DATASYNC | constants_1.WASI_RIGHT_FD_WRITE | constants_1.WASI_RIGHT_FD_ALLOCATE | constants_1.WASI_RIGHT_FD_FILESTAT_SET_SIZE)) !== BigInt(0);\n              let noflags;\n              if (write && read)\n                noflags = nodeFsConstants.O_RDWR;\n              else if (read)\n                noflags = nodeFsConstants.O_RDONLY;\n              else if (write)\n                noflags = nodeFsConstants.O_WRONLY;\n              let neededBase = fsRightsBase | constants_1.WASI_RIGHT_PATH_OPEN, neededInheriting = fsRightsBase | fsRightsInheriting;\n              if ((oflags & constants_1.WASI_O_CREAT) !== 0)\n                noflags |= nodeFsConstants.O_CREAT, neededBase |= constants_1.WASI_RIGHT_PATH_CREATE_FILE;\n              if ((oflags & constants_1.WASI_O_DIRECTORY) !== 0)\n                noflags |= nodeFsConstants.O_DIRECTORY;\n              if ((oflags & constants_1.WASI_O_EXCL) !== 0)\n                noflags |= nodeFsConstants.O_EXCL;\n              if ((oflags & constants_1.WASI_O_TRUNC) !== 0)\n                noflags |= nodeFsConstants.O_TRUNC, neededBase |= constants_1.WASI_RIGHT_PATH_FILESTAT_SET_SIZE;\n              if ((fsFlags & constants_1.WASI_FDFLAG_APPEND) !== 0)\n                noflags |= nodeFsConstants.O_APPEND;\n              if ((fsFlags & constants_1.WASI_FDFLAG_DSYNC) !== 0) {\n                if (nodeFsConstants.O_DSYNC)\n                  noflags |= nodeFsConstants.O_DSYNC;\n                else\n                  noflags |= nodeFsConstants.O_SYNC;\n                neededInheriting |= constants_1.WASI_RIGHT_FD_DATASYNC;\n              }\n              if ((fsFlags & constants_1.WASI_FDFLAG_NONBLOCK) !== 0)\n                noflags |= nodeFsConstants.O_NONBLOCK;\n              if ((fsFlags & constants_1.WASI_FDFLAG_RSYNC) !== 0) {\n                if (nodeFsConstants.O_RSYNC)\n                  noflags |= nodeFsConstants.O_RSYNC;\n                else\n                  noflags |= nodeFsConstants.O_SYNC;\n                neededInheriting |= constants_1.WASI_RIGHT_FD_SYNC;\n              }\n              if ((fsFlags & constants_1.WASI_FDFLAG_SYNC) !== 0)\n                noflags |= nodeFsConstants.O_SYNC, neededInheriting |= constants_1.WASI_RIGHT_FD_SYNC;\n              if (write && (noflags & (nodeFsConstants.O_APPEND | nodeFsConstants.O_TRUNC)) === 0)\n                neededInheriting |= constants_1.WASI_RIGHT_FD_SEEK;\n              this.refreshMemory();\n              const p = Buffer.from(this.memory.buffer, pathPtr, pathLen).toString();\n              if (p == \"dev/tty\")\n                return this.view.setUint32(fdPtr, constants_1.WASI_STDIN_FILENO, !0), constants_1.WASI_ESUCCESS;\n              if (logOpen(\"path_open\", p), p.startsWith(\"proc/\"))\n                throw new types_1.WASIError(constants_1.WASI_EBADF);\n              const fullUnresolved = path.resolve(p);\n              let full;\n              try {\n                full = fs.realpathSync(fullUnresolved);\n              } catch (e) {\n                if (e\?.code === \"ENOENT\")\n                  full = fullUnresolved;\n                else\n                  throw e;\n              }\n              let isDirectory;\n              if (write)\n                try {\n                  isDirectory = fs.statSync(full).isDirectory();\n                } catch (_err) {\n                }\n              let realfd;\n              if (!write && isDirectory)\n                realfd = fs.openSync(full, nodeFsConstants.O_RDONLY);\n              else\n                realfd = fs.openSync(full, noflags);\n              const newfd = this.getUnusedFileDescriptor();\n              this.FD_MAP.set(newfd, {\n                real: realfd,\n                filetype: void 0,\n                rights: {\n                  base: neededBase,\n                  inheriting: neededInheriting\n                },\n                path: full\n              }), stat(this, newfd), this.view.setUint32(fdPtr, newfd, !0);\n            } catch (e) {\n              console.error(e);\n            }\n            return constants_1.WASI_ESUCCESS;\n          }),\n          path_readlink: wrap((fd, pathPtr, pathLen, buf, bufLen, bufused) => {\n            const stats = CHECK_FD(fd, constants_1.WASI_RIGHT_PATH_READLINK);\n            if (!stats.path)\n              return constants_1.WASI_EINVAL;\n            this.refreshMemory();\n            const p = Buffer.from(this.memory.buffer, pathPtr, pathLen).toString(), full = path.resolve(stats.path, p), r = fs.readlinkSync(full), used = Buffer.from(this.memory.buffer).write(r, buf, bufLen);\n            return this.view.setUint32(bufused, used, !0), constants_1.WASI_ESUCCESS;\n          }),\n          path_remove_directory: wrap((fd, pathPtr, pathLen) => {\n            const stats = CHECK_FD(fd, constants_1.WASI_RIGHT_PATH_REMOVE_DIRECTORY);\n            if (!stats.path)\n              return constants_1.WASI_EINVAL;\n            this.refreshMemory();\n            const p = Buffer.from(this.memory.buffer, pathPtr, pathLen).toString();\n            return fs.rmdirSync(path.resolve(stats.path, p)), constants_1.WASI_ESUCCESS;\n          }),\n          path_rename: wrap((oldFd, oldPath, oldPathLen, newFd, newPath, newPathLen) => {\n            const ostats = CHECK_FD(oldFd, constants_1.WASI_RIGHT_PATH_RENAME_SOURCE), nstats = CHECK_FD(newFd, constants_1.WASI_RIGHT_PATH_RENAME_TARGET);\n            if (!ostats.path || !nstats.path)\n              return constants_1.WASI_EINVAL;\n            this.refreshMemory();\n            const op = Buffer.from(this.memory.buffer, oldPath, oldPathLen).toString(), np = Buffer.from(this.memory.buffer, newPath, newPathLen).toString();\n            return fs.renameSync(path.resolve(ostats.path, op), path.resolve(nstats.path, np)), constants_1.WASI_ESUCCESS;\n          }),\n          path_symlink: wrap((oldPath, oldPathLen, fd, newPath, newPathLen) => {\n            const stats = CHECK_FD(fd, constants_1.WASI_RIGHT_PATH_SYMLINK);\n            if (!stats.path)\n              return constants_1.WASI_EINVAL;\n            this.refreshMemory();\n            const op = Buffer.from(this.memory.buffer, oldPath, oldPathLen).toString(), np = Buffer.from(this.memory.buffer, newPath, newPathLen).toString();\n            return fs.symlinkSync(op, path.resolve(stats.path, np)), constants_1.WASI_ESUCCESS;\n          }),\n          path_unlink_file: wrap((fd, pathPtr, pathLen) => {\n            const stats = CHECK_FD(fd, constants_1.WASI_RIGHT_PATH_UNLINK_FILE);\n            if (!stats.path)\n              return constants_1.WASI_EINVAL;\n            this.refreshMemory();\n            const p = Buffer.from(this.memory.buffer, pathPtr, pathLen).toString();\n            return fs.unlinkSync(path.resolve(stats.path, p)), constants_1.WASI_ESUCCESS;\n          }),\n          poll_oneoff: (sin, sout, nsubscriptions, neventsPtr) => {\n            let nevents = 0, name = \"\", waitTimeNs = BigInt(0), fd = -1, fd_type = \"read\", fd_timeout_ms = 0;\n            const startNs = BigInt(bindings2.hrtime());\n            this.refreshMemory();\n            let last_sin = sin;\n            for (let i = 0;i < nsubscriptions; i += 1) {\n              const userdata = this.view.getBigUint64(sin, !0);\n              sin += 8;\n              const type = this.view.getUint8(sin);\n              if (sin += 1, sin += 7, log.enabled) {\n                if (type == constants_1.WASI_EVENTTYPE_CLOCK)\n                  name = \"poll_oneoff (type=WASI_EVENTTYPE_CLOCK): \";\n                else if (type == constants_1.WASI_EVENTTYPE_FD_READ)\n                  name = \"poll_oneoff (type=WASI_EVENTTYPE_FD_READ): \";\n                else\n                  name = \"poll_oneoff (type=WASI_EVENTTYPE_FD_WRITE): \";\n                log(name);\n              }\n              switch (type) {\n                case constants_1.WASI_EVENTTYPE_CLOCK: {\n                  const clockid = this.view.getUint32(sin, !0);\n                  sin += 4, sin += 4;\n                  const timeout = this.view.getBigUint64(sin, !0);\n                  sin += 8, sin += 8;\n                  const subclockflags = this.view.getUint16(sin, !0);\n                  sin += 2, sin += 6;\n                  const absolute = subclockflags === 1;\n                  if (log.enabled)\n                    log(name, { clockid, timeout, absolute });\n                  if (!absolute)\n                    fd_timeout_ms = timeout / BigInt(1e6);\n                  let e = constants_1.WASI_ESUCCESS;\n                  const t = now(clockid);\n                  if (t == null)\n                    e = constants_1.WASI_EINVAL;\n                  else {\n                    const tNS = BigInt(t), waitNs = (absolute \? timeout : tNS + timeout) - tNS;\n                    if (waitNs > waitTimeNs)\n                      waitTimeNs = waitNs;\n                  }\n                  this.view.setBigUint64(sout, userdata, !0), sout += 8, this.view.setUint16(sout, e, !0), sout += 2, this.view.setUint8(sout, constants_1.WASI_EVENTTYPE_CLOCK), sout += 1, sout += 5, nevents += 1;\n                  break;\n                }\n                case constants_1.WASI_EVENTTYPE_FD_READ:\n                case constants_1.WASI_EVENTTYPE_FD_WRITE: {\n                  if (fd = this.view.getUint32(sin, !0), fd_type = type == constants_1.WASI_EVENTTYPE_FD_READ \? \"read\" : \"write\", sin += 4, log(name, \"fd =\", fd), sin += 28, this.view.setBigUint64(sout, userdata, !0), sout += 8, this.view.setUint16(sout, constants_1.WASI_ENOSYS, !0), sout += 2, this.view.setUint8(sout, type), sout += 1, sout += 5, nevents += 1, fd == constants_1.WASI_STDIN_FILENO && constants_1.WASI_EVENTTYPE_FD_READ == type)\n                    this.shortPause();\n                  break;\n                }\n                default:\n                  return constants_1.WASI_EINVAL;\n              }\n              if (sin - last_sin != 48)\n                console.warn(\"*** BUG in wasi-js in poll_oneoff \", {\n                  i,\n                  sin,\n                  last_sin,\n                  diff: sin - last_sin\n                });\n              last_sin = sin;\n            }\n            if (this.view.setUint32(neventsPtr, nevents, !0), nevents == 2 && fd >= 0) {\n              const r = this.wasiImport.sock_pollSocket(fd, fd_type, fd_timeout_ms);\n              if (r != constants_1.WASI_ENOSYS)\n                return r;\n            }\n            if (waitTimeNs > 0) {\n              if (waitTimeNs -= Bun.nanoseconds() - timeOrigin, waitTimeNs >= 1e6) {\n                if (this.sleep == null && !warnedAboutSleep)\n                  warnedAboutSleep = !0, console.log(\"(100% cpu burning waiting for stdin: please define a way to sleep!) \");\n                if (this.sleep != null) {\n                  const ms = nsToMs(waitTimeNs);\n                  this.sleep(ms);\n                } else {\n                  const end = BigInt(bindings2.hrtime()) + waitTimeNs;\n                  while (BigInt(bindings2.hrtime()) < end)\n                    ;\n                }\n              }\n            }\n            return constants_1.WASI_ESUCCESS;\n          },\n          proc_exit: (rval) => {\n            return bindings2.exit(rval), constants_1.WASI_ESUCCESS;\n          },\n          proc_raise: (sig) => {\n            if (!(sig in constants_1.SIGNAL_MAP))\n              return constants_1.WASI_EINVAL;\n            return bindings2.kill(constants_1.SIGNAL_MAP[sig]), constants_1.WASI_ESUCCESS;\n          },\n          random_get: (bufPtr, bufLen) => {\n            return this.refreshMemory(), crypto.getRandomValues(this.memory.buffer, bufPtr, bufLen), bufLen;\n          },\n          sched_yield() {\n            return constants_1.WASI_ESUCCESS;\n          },\n          sock_recv() {\n            return constants_1.WASI_ENOSYS;\n          },\n          sock_send() {\n            return constants_1.WASI_ENOSYS;\n          },\n          sock_shutdown() {\n            return constants_1.WASI_ENOSYS;\n          },\n          sock_fcntlSetFlags(_fd, _flags) {\n            return constants_1.WASI_ENOSYS;\n          },\n          sock_pollSocket(_fd, _eventtype, _timeout_ms) {\n            return constants_1.WASI_ENOSYS;\n          }\n        }, log.enabled)\n          Object.keys(this.wasiImport).forEach((key) => {\n            const prevImport = this.wasiImport[key];\n            this.wasiImport[key] = function(...args2) {\n              log(key, args2);\n              try {\n                let result = prevImport(...args2);\n                return log(\"result\", result), result;\n              } catch (e) {\n                throw log(\"error: \", e), e;\n              }\n            };\n          });\n      }\n      getState() {\n        return { env: this.env, FD_MAP: this.FD_MAP, bindings };\n      }\n      setState(state) {\n        this.env = state.env, this.FD_MAP = state.FD_MAP, bindings = state.bindings;\n      }\n      fstatSync(real_fd) {\n        if (real_fd <= 2)\n          try {\n            return fs.fstatSync(real_fd);\n          } catch (_) {\n            const now = new Date;\n            return {\n              dev: 0,\n              mode: 8592,\n              nlink: 1,\n              uid: 0,\n              gid: 0,\n              rdev: 0,\n              blksize: 65536,\n              ino: 0,\n              size: 0,\n              blocks: 0,\n              atimeMs: now.valueOf(),\n              mtimeMs: now.valueOf(),\n              ctimeMs: now.valueOf(),\n              birthtimeMs: 0,\n              atime: new Date,\n              mtime: new Date,\n              ctime: new Date,\n              birthtime: new Date(0)\n            };\n          }\n        return fs.fstatSync(real_fd);\n      }\n      shortPause() {\n        if (this.sleep == null)\n          return;\n        if ((new Date()).valueOf() - this.lastStdin > 2000)\n          this.sleep(50);\n      }\n      getUnusedFileDescriptor(start = 3) {\n        let fd = start;\n        while (this.FD_MAP.has(fd))\n          fd += 1;\n        if (fd > SC_OPEN_MAX)\n          throw Error(\"no available file descriptors\");\n        return fd;\n      }\n      refreshMemory() {\n        if (!this.view || this.view.buffer.byteLength === 0)\n          this.view = new DataView(this.memory.buffer);\n      }\n      setMemory(memory) {\n        this.memory = memory;\n      }\n      start(instance, memory) {\n        const exports2 = instance.exports;\n        if (exports2 === null || typeof exports2 !== \"object\")\n          throw new Error(`instance.exports must be an Object. Received ${exports2}.`);\n        if (memory == null) {\n          if (memory = exports2.memory, !(memory instanceof WebAssembly.Memory))\n            throw new Error(`instance.exports.memory must be a WebAssembly.Memory. Recceived ${memory}.`);\n        }\n        if (this.setMemory(memory), exports2._start)\n          exports2._start();\n      }\n      getImports(module2) {\n        let namespace = null;\n        const imports = WebAssembly.Module.imports(module2);\n        for (let imp of imports) {\n          if (imp.kind !== \"function\")\n            continue;\n          if (!imp.module.startsWith(\"wasi_\"))\n            continue;\n          namespace = imp.module;\n          break;\n        }\n        switch (namespace) {\n          case \"wasi_unstable\":\n            return {\n              wasi_unstable: this.wasiImport\n            };\n          case \"wasi_snapshot_preview1\":\n            return {\n              wasi_snapshot_preview1: this.wasiImport\n            };\n          default:\n            throw new Error(\"No WASI namespace found. Only wasi_unstable and wasi_snapshot_preview1 are supported.\\n\\nList of imports:\\n\\n\" + imports.map(({ name, kind, module }) => `${module}:${name} (${kind})`).join(\"\\n\") + \"\\n\");\n        }\n      }\n      initWasiFdInfo() {\n        if (this.env.WASI_FD_INFO != null) {\n          const fdInfo = JSON.parse(this.env.WASI_FD_INFO);\n          for (let wasi_fd in fdInfo) {\n            console.log(wasi_fd);\n            const fd = parseInt(wasi_fd);\n            if (this.FD_MAP.has(fd))\n              continue;\n            const real = fdInfo[wasi_fd];\n            try {\n              this.fstatSync(real);\n            } catch (_err) {\n              console.log(\"discarding \", { wasi_fd, real });\n              continue;\n            }\n            const file = {\n              real,\n              filetype: constants_1.WASI_FILETYPE_SOCKET_STREAM,\n              rights: {\n                base: STDIN_DEFAULT_RIGHTS,\n                inheriting: BigInt(0)\n              }\n            };\n            this.FD_MAP.set(fd, file);\n          }\n          console.log(\"after initWasiFdInfo: \", this.FD_MAP), console.log(\"fdInfo = \", fdInfo);\n        } else\n          console.log(\"no WASI_FD_INFO\");\n      }\n    };\n    exports.default = WASI;\n  }\n});\nreturn { WASI: require_wasi().default }})\n"_s;
//

//
static constexpr ASCIILiteral NodeWorkerThreadsCode = "(function (){\"use strict\";// src/js/out/tmp/node/worker_threads.ts\nvar emitWarning = function(type, message) {\n  if (emittedWarnings.has(type))\n    return;\n  emittedWarnings.add(type), console.warn(\"[bun] Warning:\", message);\n}, injectFakeEmitter = function(Class) {\n  function messageEventHandler(event) {\n    return event.data;\n  }\n  function errorEventHandler(event) {\n    return event.error;\n  }\n  const wrappedListener = Symbol(\"wrappedListener\");\n  function wrapped(run, listener) {\n    const callback = function(event) {\n      return listener(run(event));\n    };\n    return listener[wrappedListener] = callback, callback;\n  }\n  function functionForEventType(event, listener) {\n    switch (event) {\n      case \"error\":\n      case \"messageerror\":\n        return wrapped(errorEventHandler, listener);\n      default:\n        return wrapped(messageEventHandler, listener);\n    }\n  }\n  Class.prototype.on = function(event, listener) {\n    return this.addEventListener(event, functionForEventType(event, listener)), this;\n  }, Class.prototype.off = function(event, listener) {\n    if (listener)\n      this.removeEventListener(event, listener[wrappedListener] || listener);\n    else\n      this.removeEventListener(event);\n    return this;\n  }, Class.prototype.once = function(event, listener) {\n    return this.addEventListener(event, functionForEventType(event, listener), { once: !0 }), this;\n  };\n  function EventClass(eventName) {\n    if (eventName === \"error\" || eventName === \"messageerror\")\n      return ErrorEvent;\n    return MessageEvent;\n  }\n  Class.prototype.emit = function(event, ...args) {\n    return this.dispatchEvent(new (EventClass(event))(event, ...args)), this;\n  }, Class.prototype.prependListener = Class.prototype.on, Class.prototype.prependOnceListener = Class.prototype.once;\n}, receiveMessageOnPort = function(port) {\n  let res = _receiveMessageOnPort(port);\n  if (!res)\n    return;\n  return {\n    message: res\n  };\n}, fakeParentPort = function() {\n  const fake = Object.create(MessagePort.prototype);\n  return Object.defineProperty(fake, \"onmessage\", {\n    get() {\n      return self.onmessage;\n    },\n    set(value) {\n      self.onmessage = value;\n    }\n  }), Object.defineProperty(fake, \"onmessageerror\", {\n    get() {\n      return self.onmessageerror;\n    },\n    set(value) {\n    }\n  }), Object.defineProperty(fake, \"postMessage\", {\n    value(...args) {\n      return self.postMessage(...args);\n    }\n  }), Object.defineProperty(fake, \"close\", {\n    value() {\n      return process.exit(0);\n    }\n  }), Object.defineProperty(fake, \"start\", {\n    value() {\n    }\n  }), Object.defineProperty(fake, \"unref\", {\n    value() {\n    }\n  }), Object.defineProperty(fake, \"ref\", {\n    value() {\n    }\n  }), Object.defineProperty(fake, \"hasRef\", {\n    value() {\n      return !1;\n    }\n  }), Object.defineProperty(fake, \"setEncoding\", {\n    value() {\n    }\n  }), Object.defineProperty(fake, \"addEventListener\", {\n    value: self.addEventListener.bind(self)\n  }), Object.defineProperty(fake, \"removeEventListener\", {\n    value: self.removeEventListener.bind(self)\n  }), fake;\n}, getEnvironmentData = function() {\n  return process.env;\n}, setEnvironmentData = function(env) {\n  process.env = env;\n}, markAsUntransferable = function() {\n  throwNotImplemented(\"worker_threads.markAsUntransferable\");\n}, moveMessagePortToContext = function() {\n  throwNotImplemented(\"worker_threads.moveMessagePortToContext\");\n}, $, EventEmitter = @getInternalField(@internalModuleRegistry, 16) || @createInternalModuleById(16), { throwNotImplemented } = @getInternalField(@internalModuleRegistry, 3) || @createInternalModuleById(3), { MessageChannel, BroadcastChannel, Worker: WebWorker } = globalThis, SHARE_ENV = Symbol(\"nodejs.worker_threads.SHARE_ENV\"), isMainThread = Bun.isMainThread, [_workerData, _threadId, _receiveMessageOnPort] = globalThis[globalThis.Symbol.for('Bun.lazy')](\"worker_threads\"), emittedWarnings = new Set, _MessagePort = globalThis.MessagePort;\ninjectFakeEmitter(_MessagePort);\nvar MessagePort = _MessagePort, resourceLimits = {}, workerData = _workerData, threadId = _threadId, parentPort = isMainThread \? null : fakeParentPort(), unsupportedOptions = [\n  \"eval\",\n  \"argv\",\n  \"execArgv\",\n  \"stdin\",\n  \"stdout\",\n  \"stderr\",\n  \"trackedUnmanagedFds\",\n  \"resourceLimits\"\n];\n\nclass Worker extends EventEmitter {\n  #worker;\n  #performance;\n  #onExitPromise = void 0;\n  constructor(filename, options = {}) {\n    super();\n    for (let key of unsupportedOptions)\n      if (key in options)\n        emitWarning(\"option.\" + key, `worker_threads.Worker option \"${key}\" is not implemented.`);\n    this.#worker = new WebWorker(filename, options), this.#worker.addEventListener(\"close\", this.#onClose.bind(this)), this.#worker.addEventListener(\"error\", this.#onError.bind(this)), this.#worker.addEventListener(\"message\", this.#onMessage.bind(this)), this.#worker.addEventListener(\"messageerror\", this.#onMessageError.bind(this)), this.#worker.addEventListener(\"open\", this.#onOpen.bind(this));\n  }\n  ref() {\n    this.#worker.ref();\n  }\n  unref() {\n    this.#worker.unref();\n  }\n  get stdin() {\n    return null;\n  }\n  get stdout() {\n    return null;\n  }\n  get stderr() {\n    return null;\n  }\n  get performance() {\n    return this.#performance \?\?= {\n      eventLoopUtilization() {\n        return emitWarning(\"performance\", \"worker_threads.Worker.performance is not implemented.\"), {\n          idle: 0,\n          active: 0,\n          utilization: 0\n        };\n      }\n    };\n  }\n  terminate() {\n    var onExitPromise = this.#onExitPromise;\n    if (onExitPromise)\n      return @isPromise(onExitPromise) \? onExitPromise : Promise.resolve(onExitPromise);\n    const { resolve, promise } = Promise.withResolvers();\n    return this.#worker.addEventListener(\"close\", (event) => {\n      resolve(event.code);\n    }, { once: !0 }), this.#worker.terminate(), this.#onExitPromise = promise;\n  }\n  postMessage(...args) {\n    return this.#worker.postMessage(...args);\n  }\n  #onClose(e) {\n    this.#onExitPromise = e.code, this.emit(\"exit\", e.code);\n  }\n  #onError(error) {\n    this.emit(\"error\", error);\n  }\n  #onMessage(event) {\n    this.emit(\"message\", event.data);\n  }\n  #onMessageError(event) {\n    this.emit(\"messageerror\", event.error \?\? event.data \?\? event);\n  }\n  #onOpen() {\n    this.emit(\"online\");\n  }\n  async getHeapSnapshot() {\n    throwNotImplemented(\"worker_threads.Worker.getHeapSnapshot\");\n  }\n}\n$ = {\n  Worker,\n  workerData,\n  parentPort,\n  resourceLimits,\n  isMainThread,\n  MessageChannel,\n  BroadcastChannel,\n  MessagePort,\n  getEnvironmentData,\n  setEnvironmentData,\n  getHeapSnapshot() {\n    return {};\n  },\n  markAsUntransferable,\n  moveMessagePortToContext,\n  receiveMessageOnPort,\n  SHARE_ENV,\n  threadId\n};\nreturn $})\n"_s;
//

//
static constexpr ASCIILiteral NodeZlibCode = "(function (){\"use strict\";// src/js/out/tmp/node/zlib.ts\nvar assert = @getInternalField(@internalModuleRegistry, 4) || @createInternalModuleById(4), BufferModule = @requireNativeModule(\"node:buffer\"), StreamModule = @getInternalField(@internalModuleRegistry, 35) || @createInternalModuleById(35), Util = @getInternalField(@internalModuleRegistry, 43) || @createInternalModuleById(43), __getOwnPropNames = Object.getOwnPropertyNames, __commonJS = (cb, mod) => function __require() {\n  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;\n}, require_zstream = __commonJS({\n  \"node_modules/pako/lib/zlib/zstream.js\"(exports, module2) {\n    function ZStream() {\n      this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = \"\", this.state = null, this.data_type = 2, this.adler = 0;\n    }\n    module2.exports = ZStream;\n  }\n}), require_common = __commonJS({\n  \"node_modules/pako/lib/utils/common.js\"(exports) {\n    var TYPED_OK = typeof Uint8Array !== \"undefined\" && typeof Uint16Array !== \"undefined\" && typeof Int32Array !== \"undefined\";\n    function _has(obj, key) {\n      return Object.prototype.hasOwnProperty.call(obj, key);\n    }\n    exports.assign = function(obj) {\n      var sources = Array.prototype.slice.call(arguments, 1);\n      while (sources.length) {\n        var source = sources.shift();\n        if (!source)\n          continue;\n        if (typeof source !== \"object\")\n          @throwTypeError(source + \"must be non-object\");\n        for (var p in source)\n          if (_has(source, p))\n            obj[p] = source[p];\n      }\n      return obj;\n    }, exports.shrinkBuf = function(buf, size) {\n      if (buf.length === size)\n        return buf;\n      if (buf.subarray)\n        return buf.subarray(0, size);\n      return buf.length = size, buf;\n    };\n    var fnTyped = {\n      arraySet: function(dest, src, src_offs, len, dest_offs) {\n        if (src.subarray && dest.subarray) {\n          dest.set(src.subarray(src_offs, src_offs + len), dest_offs);\n          return;\n        }\n        for (var i = 0;i < len; i++)\n          dest[dest_offs + i] = src[src_offs + i];\n      },\n      flattenChunks: function(chunks) {\n        var i, l, len, pos, chunk, result;\n        len = 0;\n        for (i = 0, l = chunks.length;i < l; i++)\n          len += chunks[i].length;\n        result = new Uint8Array(len), pos = 0;\n        for (i = 0, l = chunks.length;i < l; i++)\n          chunk = chunks[i], result.set(chunk, pos), pos += chunk.length;\n        return result;\n      }\n    }, fnUntyped = {\n      arraySet: function(dest, src, src_offs, len, dest_offs) {\n        for (var i = 0;i < len; i++)\n          dest[dest_offs + i] = src[src_offs + i];\n      },\n      flattenChunks: function(chunks) {\n        return [].concat.apply([], chunks);\n      }\n    };\n    exports.setTyped = function(on) {\n      if (on)\n        exports.Buf8 = Uint8Array, exports.Buf16 = Uint16Array, exports.Buf32 = Int32Array, exports.assign(exports, fnTyped);\n      else\n        exports.Buf8 = Array, exports.Buf16 = Array, exports.Buf32 = Array, exports.assign(exports, fnUntyped);\n    }, exports.setTyped(TYPED_OK);\n  }\n}), require_trees = __commonJS({\n  \"node_modules/pako/lib/zlib/trees.js\"(exports) {\n    var utils = require_common(), Z_FIXED = 4, Z_BINARY = 0, Z_TEXT = 1, Z_UNKNOWN = 2;\n    function zero(buf) {\n      var len = buf.length;\n      while (--len >= 0)\n        buf[len] = 0;\n    }\n    var STORED_BLOCK = 0, STATIC_TREES = 1, DYN_TREES = 2, MIN_MATCH = 3, MAX_MATCH = 258, LENGTH_CODES = 29, LITERALS = 256, L_CODES = LITERALS + 1 + LENGTH_CODES, D_CODES = 30, BL_CODES = 19, HEAP_SIZE = 2 * L_CODES + 1, MAX_BITS = 15, Buf_size = 16, MAX_BL_BITS = 7, END_BLOCK = 256, REP_3_6 = 16, REPZ_3_10 = 17, REPZ_11_138 = 18, extra_lbits = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0], extra_dbits = [\n      0,\n      0,\n      0,\n      0,\n      1,\n      1,\n      2,\n      2,\n      3,\n      3,\n      4,\n      4,\n      5,\n      5,\n      6,\n      6,\n      7,\n      7,\n      8,\n      8,\n      9,\n      9,\n      10,\n      10,\n      11,\n      11,\n      12,\n      12,\n      13,\n      13\n    ], extra_blbits = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7], bl_order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], DIST_CODE_LEN = 512, static_ltree = new Array((L_CODES + 2) * 2);\n    zero(static_ltree);\n    var static_dtree = new Array(D_CODES * 2);\n    zero(static_dtree);\n    var _dist_code = new Array(DIST_CODE_LEN);\n    zero(_dist_code);\n    var _length_code = new Array(MAX_MATCH - MIN_MATCH + 1);\n    zero(_length_code);\n    var base_length = new Array(LENGTH_CODES);\n    zero(base_length);\n    var base_dist = new Array(D_CODES);\n    zero(base_dist);\n    function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {\n      this.static_tree = static_tree, this.extra_bits = extra_bits, this.extra_base = extra_base, this.elems = elems, this.max_length = max_length, this.has_stree = static_tree && static_tree.length;\n    }\n    var static_l_desc, static_d_desc, static_bl_desc;\n    function TreeDesc(dyn_tree, stat_desc) {\n      this.dyn_tree = dyn_tree, this.max_code = 0, this.stat_desc = stat_desc;\n    }\n    function d_code(dist) {\n      return dist < 256 \? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];\n    }\n    function put_short(s, w) {\n      s.pending_buf[s.pending++] = w & 255, s.pending_buf[s.pending++] = w >>> 8 & 255;\n    }\n    function send_bits(s, value, length) {\n      if (s.bi_valid > Buf_size - length)\n        s.bi_buf |= value << s.bi_valid & 65535, put_short(s, s.bi_buf), s.bi_buf = value >> Buf_size - s.bi_valid, s.bi_valid += length - Buf_size;\n      else\n        s.bi_buf |= value << s.bi_valid & 65535, s.bi_valid += length;\n    }\n    function send_code(s, c, tree) {\n      send_bits(s, tree[c * 2], tree[c * 2 + 1]);\n    }\n    function bi_reverse(code, len) {\n      var res = 0;\n      do\n        res |= code & 1, code >>>= 1, res <<= 1;\n      while (--len > 0);\n      return res >>> 1;\n    }\n    function bi_flush(s) {\n      if (s.bi_valid === 16)\n        put_short(s, s.bi_buf), s.bi_buf = 0, s.bi_valid = 0;\n      else if (s.bi_valid >= 8)\n        s.pending_buf[s.pending++] = s.bi_buf & 255, s.bi_buf >>= 8, s.bi_valid -= 8;\n    }\n    function gen_bitlen(s, desc) {\n      var { dyn_tree: tree, max_code } = desc, stree = desc.stat_desc.static_tree, has_stree = desc.stat_desc.has_stree, extra = desc.stat_desc.extra_bits, base = desc.stat_desc.extra_base, max_length = desc.stat_desc.max_length, h, n, m, bits, xbits, f, overflow = 0;\n      for (bits = 0;bits <= MAX_BITS; bits++)\n        s.bl_count[bits] = 0;\n      tree[s.heap[s.heap_max] * 2 + 1] = 0;\n      for (h = s.heap_max + 1;h < HEAP_SIZE; h++) {\n        if (n = s.heap[h], bits = tree[tree[n * 2 + 1] * 2 + 1] + 1, bits > max_length)\n          bits = max_length, overflow++;\n        if (tree[n * 2 + 1] = bits, n > max_code)\n          continue;\n        if (s.bl_count[bits]++, xbits = 0, n >= base)\n          xbits = extra[n - base];\n        if (f = tree[n * 2], s.opt_len += f * (bits + xbits), has_stree)\n          s.static_len += f * (stree[n * 2 + 1] + xbits);\n      }\n      if (overflow === 0)\n        return;\n      do {\n        bits = max_length - 1;\n        while (s.bl_count[bits] === 0)\n          bits--;\n        s.bl_count[bits]--, s.bl_count[bits + 1] += 2, s.bl_count[max_length]--, overflow -= 2;\n      } while (overflow > 0);\n      for (bits = max_length;bits !== 0; bits--) {\n        n = s.bl_count[bits];\n        while (n !== 0) {\n          if (m = s.heap[--h], m > max_code)\n            continue;\n          if (tree[m * 2 + 1] !== bits)\n            s.opt_len += (bits - tree[m * 2 + 1]) * tree[m * 2], tree[m * 2 + 1] = bits;\n          n--;\n        }\n      }\n    }\n    function gen_codes(tree, max_code, bl_count) {\n      var next_code = new Array(MAX_BITS + 1), code = 0, bits, n;\n      for (bits = 1;bits <= MAX_BITS; bits++)\n        next_code[bits] = code = code + bl_count[bits - 1] << 1;\n      for (n = 0;n <= max_code; n++) {\n        var len = tree[n * 2 + 1];\n        if (len === 0)\n          continue;\n        tree[n * 2] = bi_reverse(next_code[len]++, len);\n      }\n    }\n    function tr_static_init() {\n      var n, bits, length, code, dist, bl_count = new Array(MAX_BITS + 1);\n      length = 0;\n      for (code = 0;code < LENGTH_CODES - 1; code++) {\n        base_length[code] = length;\n        for (n = 0;n < 1 << extra_lbits[code]; n++)\n          _length_code[length++] = code;\n      }\n      _length_code[length - 1] = code, dist = 0;\n      for (code = 0;code < 16; code++) {\n        base_dist[code] = dist;\n        for (n = 0;n < 1 << extra_dbits[code]; n++)\n          _dist_code[dist++] = code;\n      }\n      dist >>= 7;\n      for (;code < D_CODES; code++) {\n        base_dist[code] = dist << 7;\n        for (n = 0;n < 1 << extra_dbits[code] - 7; n++)\n          _dist_code[256 + dist++] = code;\n      }\n      for (bits = 0;bits <= MAX_BITS; bits++)\n        bl_count[bits] = 0;\n      n = 0;\n      while (n <= 143)\n        static_ltree[n * 2 + 1] = 8, n++, bl_count[8]++;\n      while (n <= 255)\n        static_ltree[n * 2 + 1] = 9, n++, bl_count[9]++;\n      while (n <= 279)\n        static_ltree[n * 2 + 1] = 7, n++, bl_count[7]++;\n      while (n <= 287)\n        static_ltree[n * 2 + 1] = 8, n++, bl_count[8]++;\n      gen_codes(static_ltree, L_CODES + 1, bl_count);\n      for (n = 0;n < D_CODES; n++)\n        static_dtree[n * 2 + 1] = 5, static_dtree[n * 2] = bi_reverse(n, 5);\n      static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS), static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES, MAX_BITS), static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES, MAX_BL_BITS);\n    }\n    function init_block(s) {\n      var n;\n      for (n = 0;n < L_CODES; n++)\n        s.dyn_ltree[n * 2] = 0;\n      for (n = 0;n < D_CODES; n++)\n        s.dyn_dtree[n * 2] = 0;\n      for (n = 0;n < BL_CODES; n++)\n        s.bl_tree[n * 2] = 0;\n      s.dyn_ltree[END_BLOCK * 2] = 1, s.opt_len = s.static_len = 0, s.last_lit = s.matches = 0;\n    }\n    function bi_windup(s) {\n      if (s.bi_valid > 8)\n        put_short(s, s.bi_buf);\n      else if (s.bi_valid > 0)\n        s.pending_buf[s.pending++] = s.bi_buf;\n      s.bi_buf = 0, s.bi_valid = 0;\n    }\n    function copy_block(s, buf, len, header) {\n      if (bi_windup(s), header)\n        put_short(s, len), put_short(s, ~len);\n      utils.arraySet(s.pending_buf, s.window, buf, len, s.pending), s.pending += len;\n    }\n    function smaller(tree, n, m, depth) {\n      var _n2 = n * 2, _m2 = m * 2;\n      return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n] <= depth[m];\n    }\n    function pqdownheap(s, tree, k) {\n      var v = s.heap[k], j = k << 1;\n      while (j <= s.heap_len) {\n        if (j < s.heap_len && smaller(tree, s.heap[j + 1], s.heap[j], s.depth))\n          j++;\n        if (smaller(tree, v, s.heap[j], s.depth))\n          break;\n        s.heap[k] = s.heap[j], k = j, j <<= 1;\n      }\n      s.heap[k] = v;\n    }\n    function compress_block(s, ltree, dtree) {\n      var dist, lc, lx = 0, code, extra;\n      if (s.last_lit !== 0)\n        do\n          if (dist = s.pending_buf[s.d_buf + lx * 2] << 8 | s.pending_buf[s.d_buf + lx * 2 + 1], lc = s.pending_buf[s.l_buf + lx], lx++, dist === 0)\n            send_code(s, lc, ltree);\n          else {\n            if (code = _length_code[lc], send_code(s, code + LITERALS + 1, ltree), extra = extra_lbits[code], extra !== 0)\n              lc -= base_length[code], send_bits(s, lc, extra);\n            if (dist--, code = d_code(dist), send_code(s, code, dtree), extra = extra_dbits[code], extra !== 0)\n              dist -= base_dist[code], send_bits(s, dist, extra);\n          }\n        while (lx < s.last_lit);\n      send_code(s, END_BLOCK, ltree);\n    }\n    function build_tree(s, desc) {\n      var tree = desc.dyn_tree, stree = desc.stat_desc.static_tree, has_stree = desc.stat_desc.has_stree, elems = desc.stat_desc.elems, n, m, max_code = -1, node;\n      s.heap_len = 0, s.heap_max = HEAP_SIZE;\n      for (n = 0;n < elems; n++)\n        if (tree[n * 2] !== 0)\n          s.heap[++s.heap_len] = max_code = n, s.depth[n] = 0;\n        else\n          tree[n * 2 + 1] = 0;\n      while (s.heap_len < 2)\n        if (node = s.heap[++s.heap_len] = max_code < 2 \? ++max_code : 0, tree[node * 2] = 1, s.depth[node] = 0, s.opt_len--, has_stree)\n          s.static_len -= stree[node * 2 + 1];\n      desc.max_code = max_code;\n      for (n = s.heap_len >> 1;n >= 1; n--)\n        pqdownheap(s, tree, n);\n      node = elems;\n      do\n        n = s.heap[1], s.heap[1] = s.heap[s.heap_len--], pqdownheap(s, tree, 1), m = s.heap[1], s.heap[--s.heap_max] = n, s.heap[--s.heap_max] = m, tree[node * 2] = tree[n * 2] + tree[m * 2], s.depth[node] = (s.depth[n] >= s.depth[m] \? s.depth[n] : s.depth[m]) + 1, tree[n * 2 + 1] = tree[m * 2 + 1] = node, s.heap[1] = node++, pqdownheap(s, tree, 1);\n      while (s.heap_len >= 2);\n      s.heap[--s.heap_max] = s.heap[1], gen_bitlen(s, desc), gen_codes(tree, max_code, s.bl_count);\n    }\n    function scan_tree(s, tree, max_code) {\n      var n, prevlen = -1, curlen, nextlen = tree[1], count = 0, max_count = 7, min_count = 4;\n      if (nextlen === 0)\n        max_count = 138, min_count = 3;\n      tree[(max_code + 1) * 2 + 1] = 65535;\n      for (n = 0;n <= max_code; n++) {\n        if (curlen = nextlen, nextlen = tree[(n + 1) * 2 + 1], ++count < max_count && curlen === nextlen)\n          continue;\n        else if (count < min_count)\n          s.bl_tree[curlen * 2] += count;\n        else if (curlen !== 0) {\n          if (curlen !== prevlen)\n            s.bl_tree[curlen * 2]++;\n          s.bl_tree[REP_3_6 * 2]++;\n        } else if (count <= 10)\n          s.bl_tree[REPZ_3_10 * 2]++;\n        else\n          s.bl_tree[REPZ_11_138 * 2]++;\n        if (count = 0, prevlen = curlen, nextlen === 0)\n          max_count = 138, min_count = 3;\n        else if (curlen === nextlen)\n          max_count = 6, min_count = 3;\n        else\n          max_count = 7, min_count = 4;\n      }\n    }\n    function send_tree(s, tree, max_code) {\n      var n, prevlen = -1, curlen, nextlen = tree[1], count = 0, max_count = 7, min_count = 4;\n      if (nextlen === 0)\n        max_count = 138, min_count = 3;\n      for (n = 0;n <= max_code; n++) {\n        if (curlen = nextlen, nextlen = tree[(n + 1) * 2 + 1], ++count < max_count && curlen === nextlen)\n          continue;\n        else if (count < min_count)\n          do\n            send_code(s, curlen, s.bl_tree);\n          while (--count !== 0);\n        else if (curlen !== 0) {\n          if (curlen !== prevlen)\n            send_code(s, curlen, s.bl_tree), count--;\n          send_code(s, REP_3_6, s.bl_tree), send_bits(s, count - 3, 2);\n        } else if (count <= 10)\n          send_code(s, REPZ_3_10, s.bl_tree), send_bits(s, count - 3, 3);\n        else\n          send_code(s, REPZ_11_138, s.bl_tree), send_bits(s, count - 11, 7);\n        if (count = 0, prevlen = curlen, nextlen === 0)\n          max_count = 138, min_count = 3;\n        else if (curlen === nextlen)\n          max_count = 6, min_count = 3;\n        else\n          max_count = 7, min_count = 4;\n      }\n    }\n    function build_bl_tree(s) {\n      var max_blindex;\n      scan_tree(s, s.dyn_ltree, s.l_desc.max_code), scan_tree(s, s.dyn_dtree, s.d_desc.max_code), build_tree(s, s.bl_desc);\n      for (max_blindex = BL_CODES - 1;max_blindex >= 3; max_blindex--)\n        if (s.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0)\n          break;\n      return s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4, max_blindex;\n    }\n    function send_all_trees(s, lcodes, dcodes, blcodes) {\n      var rank;\n      send_bits(s, lcodes - 257, 5), send_bits(s, dcodes - 1, 5), send_bits(s, blcodes - 4, 4);\n      for (rank = 0;rank < blcodes; rank++)\n        send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1], 3);\n      send_tree(s, s.dyn_ltree, lcodes - 1), send_tree(s, s.dyn_dtree, dcodes - 1);\n    }\n    function detect_data_type(s) {\n      var black_mask = 4093624447, n;\n      for (n = 0;n <= 31; n++, black_mask >>>= 1)\n        if (black_mask & 1 && s.dyn_ltree[n * 2] !== 0)\n          return Z_BINARY;\n      if (s.dyn_ltree[18] !== 0 || s.dyn_ltree[20] !== 0 || s.dyn_ltree[26] !== 0)\n        return Z_TEXT;\n      for (n = 32;n < LITERALS; n++)\n        if (s.dyn_ltree[n * 2] !== 0)\n          return Z_TEXT;\n      return Z_BINARY;\n    }\n    var static_init_done = !1;\n    function _tr_init(s) {\n      if (!static_init_done)\n        tr_static_init(), static_init_done = !0;\n      s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc), s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc), s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc), s.bi_buf = 0, s.bi_valid = 0, init_block(s);\n    }\n    function _tr_stored_block(s, buf, stored_len, last) {\n      send_bits(s, (STORED_BLOCK << 1) + (last \? 1 : 0), 3), copy_block(s, buf, stored_len, !0);\n    }\n    function _tr_align(s) {\n      send_bits(s, STATIC_TREES << 1, 3), send_code(s, END_BLOCK, static_ltree), bi_flush(s);\n    }\n    function _tr_flush_block(s, buf, stored_len, last) {\n      var opt_lenb, static_lenb, max_blindex = 0;\n      if (s.level > 0) {\n        if (s.strm.data_type === Z_UNKNOWN)\n          s.strm.data_type = detect_data_type(s);\n        if (build_tree(s, s.l_desc), build_tree(s, s.d_desc), max_blindex = build_bl_tree(s), opt_lenb = s.opt_len + 3 + 7 >>> 3, static_lenb = s.static_len + 3 + 7 >>> 3, static_lenb <= opt_lenb)\n          opt_lenb = static_lenb;\n      } else\n        opt_lenb = static_lenb = stored_len + 5;\n      if (stored_len + 4 <= opt_lenb && buf !== -1)\n        _tr_stored_block(s, buf, stored_len, last);\n      else if (s.strategy === Z_FIXED || static_lenb === opt_lenb)\n        send_bits(s, (STATIC_TREES << 1) + (last \? 1 : 0), 3), compress_block(s, static_ltree, static_dtree);\n      else\n        send_bits(s, (DYN_TREES << 1) + (last \? 1 : 0), 3), send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1), compress_block(s, s.dyn_ltree, s.dyn_dtree);\n      if (init_block(s), last)\n        bi_windup(s);\n    }\n    function _tr_tally(s, dist, lc) {\n      if (s.pending_buf[s.d_buf + s.last_lit * 2] = dist >>> 8 & 255, s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 255, s.pending_buf[s.l_buf + s.last_lit] = lc & 255, s.last_lit++, dist === 0)\n        s.dyn_ltree[lc * 2]++;\n      else\n        s.matches++, dist--, s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]++, s.dyn_dtree[d_code(dist) * 2]++;\n      return s.last_lit === s.lit_bufsize - 1;\n    }\n    exports._tr_init = _tr_init, exports._tr_stored_block = _tr_stored_block, exports._tr_flush_block = _tr_flush_block, exports._tr_tally = _tr_tally, exports._tr_align = _tr_align;\n  }\n}), require_adler32 = __commonJS({\n  \"node_modules/pako/lib/zlib/adler32.js\"(exports, module2) {\n    function adler32(adler, buf, len, pos) {\n      var s1 = adler & 65535 | 0, s2 = adler >>> 16 & 65535 | 0, n = 0;\n      while (len !== 0) {\n        n = len > 2000 \? 2000 : len, len -= n;\n        do\n          s1 = s1 + buf[pos++] | 0, s2 = s2 + s1 | 0;\n        while (--n);\n        s1 %= 65521, s2 %= 65521;\n      }\n      return s1 | s2 << 16 | 0;\n    }\n    module2.exports = adler32;\n  }\n}), require_crc32 = __commonJS({\n  \"node_modules/pako/lib/zlib/crc32.js\"(exports, module2) {\n    function makeTable() {\n      var c, table = [];\n      for (var n = 0;n < 256; n++) {\n        c = n;\n        for (var k = 0;k < 8; k++)\n          c = c & 1 \? 3988292384 ^ c >>> 1 : c >>> 1;\n        table[n] = c;\n      }\n      return table;\n    }\n    var crcTable = makeTable();\n    function crc32(crc, buf, len, pos) {\n      var t = crcTable, end = pos + len;\n      crc ^= -1;\n      for (var i = pos;i < end; i++)\n        crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 255];\n      return crc ^ -1;\n    }\n    module2.exports = crc32;\n  }\n}), require_messages = __commonJS({\n  \"node_modules/pako/lib/zlib/messages.js\"(exports, module2) {\n    module2.exports = {\n      2: \"need dictionary\",\n      1: \"stream end\",\n      0: \"\",\n      \"-1\": \"file error\",\n      \"-2\": \"stream error\",\n      \"-3\": \"data error\",\n      \"-4\": \"insufficient memory\",\n      \"-5\": \"buffer error\",\n      \"-6\": \"incompatible version\"\n    };\n  }\n}), require_deflate = __commonJS({\n  \"node_modules/pako/lib/zlib/deflate.js\"(exports) {\n    var utils = require_common(), trees = require_trees(), adler32 = require_adler32(), crc32 = require_crc32(), msg = require_messages(), Z_NO_FLUSH = 0, Z_PARTIAL_FLUSH = 1, Z_FULL_FLUSH = 3, Z_FINISH = 4, Z_BLOCK = 5, Z_OK = 0, Z_STREAM_END = 1, Z_STREAM_ERROR = -2, Z_DATA_ERROR = -3, Z_BUF_ERROR = -5, Z_DEFAULT_COMPRESSION = -1, Z_FILTERED = 1, Z_HUFFMAN_ONLY = 2, Z_RLE = 3, Z_FIXED = 4, Z_DEFAULT_STRATEGY = 0, Z_UNKNOWN = 2, Z_DEFLATED = 8, MAX_MEM_LEVEL = 9, MAX_WBITS = 15, DEF_MEM_LEVEL = 8, LENGTH_CODES = 29, LITERALS = 256, L_CODES = LITERALS + 1 + LENGTH_CODES, D_CODES = 30, BL_CODES = 19, HEAP_SIZE = 2 * L_CODES + 1, MAX_BITS = 15, MIN_MATCH = 3, MAX_MATCH = 258, MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1, PRESET_DICT = 32, INIT_STATE = 42, EXTRA_STATE = 69, NAME_STATE = 73, COMMENT_STATE = 91, HCRC_STATE = 103, BUSY_STATE = 113, FINISH_STATE = 666, BS_NEED_MORE = 1, BS_BLOCK_DONE = 2, BS_FINISH_STARTED = 3, BS_FINISH_DONE = 4, OS_CODE = 3;\n    function err(strm, errorCode) {\n      return strm.msg = msg[errorCode], errorCode;\n    }\n    function rank(f) {\n      return (f << 1) - (f > 4 \? 9 : 0);\n    }\n    function zero(buf) {\n      var len = buf.length;\n      while (--len >= 0)\n        buf[len] = 0;\n    }\n    function flush_pending(strm) {\n      var s = strm.state, len = s.pending;\n      if (len > strm.avail_out)\n        len = strm.avail_out;\n      if (len === 0)\n        return;\n      if (utils.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out), strm.next_out += len, s.pending_out += len, strm.total_out += len, strm.avail_out -= len, s.pending -= len, s.pending === 0)\n        s.pending_out = 0;\n    }\n    function flush_block_only(s, last) {\n      trees._tr_flush_block(s, s.block_start >= 0 \? s.block_start : -1, s.strstart - s.block_start, last), s.block_start = s.strstart, flush_pending(s.strm);\n    }\n    function put_byte(s, b) {\n      s.pending_buf[s.pending++] = b;\n    }\n    function putShortMSB(s, b) {\n      s.pending_buf[s.pending++] = b >>> 8 & 255, s.pending_buf[s.pending++] = b & 255;\n    }\n    function read_buf(strm, buf, start, size) {\n      var len = strm.avail_in;\n      if (len > size)\n        len = size;\n      if (len === 0)\n        return 0;\n      if (strm.avail_in -= len, utils.arraySet(buf, strm.input, strm.next_in, len, start), strm.state.wrap === 1)\n        strm.adler = adler32(strm.adler, buf, len, start);\n      else if (strm.state.wrap === 2)\n        strm.adler = crc32(strm.adler, buf, len, start);\n      return strm.next_in += len, strm.total_in += len, len;\n    }\n    function longest_match(s, cur_match) {\n      var { max_chain_length: chain_length, strstart: scan } = s, match, len, best_len = s.prev_length, nice_match = s.nice_match, limit = s.strstart > s.w_size - MIN_LOOKAHEAD \? s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0, _win = s.window, wmask = s.w_mask, prev = s.prev, strend = s.strstart + MAX_MATCH, scan_end1 = _win[scan + best_len - 1], scan_end = _win[scan + best_len];\n      if (s.prev_length >= s.good_match)\n        chain_length >>= 2;\n      if (nice_match > s.lookahead)\n        nice_match = s.lookahead;\n      do {\n        if (match = cur_match, _win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1])\n          continue;\n        scan += 2, match++;\n        do\n          ;\n        while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);\n        if (len = MAX_MATCH - (strend - scan), scan = strend - MAX_MATCH, len > best_len) {\n          if (s.match_start = cur_match, best_len = len, len >= nice_match)\n            break;\n          scan_end1 = _win[scan + best_len - 1], scan_end = _win[scan + best_len];\n        }\n      } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);\n      if (best_len <= s.lookahead)\n        return best_len;\n      return s.lookahead;\n    }\n    function fill_window(s) {\n      var _w_size = s.w_size, p, n, m, more, str;\n      do {\n        if (more = s.window_size - s.lookahead - s.strstart, s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {\n          utils.arraySet(s.window, s.window, _w_size, _w_size, 0), s.match_start -= _w_size, s.strstart -= _w_size, s.block_start -= _w_size, n = s.hash_size, p = n;\n          do\n            m = s.head[--p], s.head[p] = m >= _w_size \? m - _w_size : 0;\n          while (--n);\n          n = _w_size, p = n;\n          do\n            m = s.prev[--p], s.prev[p] = m >= _w_size \? m - _w_size : 0;\n          while (--n);\n          more += _w_size;\n        }\n        if (s.strm.avail_in === 0)\n          break;\n        if (n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more), s.lookahead += n, s.lookahead + s.insert >= MIN_MATCH) {\n          str = s.strstart - s.insert, s.ins_h = s.window[str], s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + 1]) & s.hash_mask;\n          while (s.insert)\n            if (s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask, s.prev[str & s.w_mask] = s.head[s.ins_h], s.head[s.ins_h] = str, str++, s.insert--, s.lookahead + s.insert < MIN_MATCH)\n              break;\n        }\n      } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);\n    }\n    function deflate_stored(s, flush) {\n      var max_block_size = 65535;\n      if (max_block_size > s.pending_buf_size - 5)\n        max_block_size = s.pending_buf_size - 5;\n      for (;; ) {\n        if (s.lookahead <= 1) {\n          if (fill_window(s), s.lookahead === 0 && flush === Z_NO_FLUSH)\n            return BS_NEED_MORE;\n          if (s.lookahead === 0)\n            break;\n        }\n        s.strstart += s.lookahead, s.lookahead = 0;\n        var max_start = s.block_start + max_block_size;\n        if (s.strstart === 0 || s.strstart >= max_start) {\n          if (s.lookahead = s.strstart - max_start, s.strstart = max_start, flush_block_only(s, !1), s.strm.avail_out === 0)\n            return BS_NEED_MORE;\n        }\n        if (s.strstart - s.block_start >= s.w_size - MIN_LOOKAHEAD) {\n          if (flush_block_only(s, !1), s.strm.avail_out === 0)\n            return BS_NEED_MORE;\n        }\n      }\n      if (s.insert = 0, flush === Z_FINISH) {\n        if (flush_block_only(s, !0), s.strm.avail_out === 0)\n          return BS_FINISH_STARTED;\n        return BS_FINISH_DONE;\n      }\n      if (s.strstart > s.block_start) {\n        if (flush_block_only(s, !1), s.strm.avail_out === 0)\n          return BS_NEED_MORE;\n      }\n      return BS_NEED_MORE;\n    }\n    function deflate_fast(s, flush) {\n      var hash_head, bflush;\n      for (;; ) {\n        if (s.lookahead < MIN_LOOKAHEAD) {\n          if (fill_window(s), s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH)\n            return BS_NEED_MORE;\n          if (s.lookahead === 0)\n            break;\n        }\n        if (hash_head = 0, s.lookahead >= MIN_MATCH)\n          s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask, hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h], s.head[s.ins_h] = s.strstart;\n        if (hash_head !== 0 && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD)\n          s.match_length = longest_match(s, hash_head);\n        if (s.match_length >= MIN_MATCH)\n          if (bflush = trees._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH), s.lookahead -= s.match_length, s.match_length <= s.max_lazy_match && s.lookahead >= MIN_MATCH) {\n            s.match_length--;\n            do\n              s.strstart++, s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask, hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h], s.head[s.ins_h] = s.strstart;\n            while (--s.match_length !== 0);\n            s.strstart++;\n          } else\n            s.strstart += s.match_length, s.match_length = 0, s.ins_h = s.window[s.strstart], s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + 1]) & s.hash_mask;\n        else\n          bflush = trees._tr_tally(s, 0, s.window[s.strstart]), s.lookahead--, s.strstart++;\n        if (bflush) {\n          if (flush_block_only(s, !1), s.strm.avail_out === 0)\n            return BS_NEED_MORE;\n        }\n      }\n      if (s.insert = s.strstart < MIN_MATCH - 1 \? s.strstart : MIN_MATCH - 1, flush === Z_FINISH) {\n        if (flush_block_only(s, !0), s.strm.avail_out === 0)\n          return BS_FINISH_STARTED;\n        return BS_FINISH_DONE;\n      }\n      if (s.last_lit) {\n        if (flush_block_only(s, !1), s.strm.avail_out === 0)\n          return BS_NEED_MORE;\n      }\n      return BS_BLOCK_DONE;\n    }\n    function deflate_slow(s, flush) {\n      var hash_head, bflush, max_insert;\n      for (;; ) {\n        if (s.lookahead < MIN_LOOKAHEAD) {\n          if (fill_window(s), s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH)\n            return BS_NEED_MORE;\n          if (s.lookahead === 0)\n            break;\n        }\n        if (hash_head = 0, s.lookahead >= MIN_MATCH)\n          s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask, hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h], s.head[s.ins_h] = s.strstart;\n        if (s.prev_length = s.match_length, s.prev_match = s.match_start, s.match_length = MIN_MATCH - 1, hash_head !== 0 && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {\n          if (s.match_length = longest_match(s, hash_head), s.match_length <= 5 && (s.strategy === Z_FILTERED || s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096))\n            s.match_length = MIN_MATCH - 1;\n        }\n        if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {\n          max_insert = s.strstart + s.lookahead - MIN_MATCH, bflush = trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH), s.lookahead -= s.prev_length - 1, s.prev_length -= 2;\n          do\n            if (++s.strstart <= max_insert)\n              s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask, hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h], s.head[s.ins_h] = s.strstart;\n          while (--s.prev_length !== 0);\n          if (s.match_available = 0, s.match_length = MIN_MATCH - 1, s.strstart++, bflush) {\n            if (flush_block_only(s, !1), s.strm.avail_out === 0)\n              return BS_NEED_MORE;\n          }\n        } else if (s.match_available) {\n          if (bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]), bflush)\n            flush_block_only(s, !1);\n          if (s.strstart++, s.lookahead--, s.strm.avail_out === 0)\n            return BS_NEED_MORE;\n        } else\n          s.match_available = 1, s.strstart++, s.lookahead--;\n      }\n      if (s.match_available)\n        bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]), s.match_available = 0;\n      if (s.insert = s.strstart < MIN_MATCH - 1 \? s.strstart : MIN_MATCH - 1, flush === Z_FINISH) {\n        if (flush_block_only(s, !0), s.strm.avail_out === 0)\n          return BS_FINISH_STARTED;\n        return BS_FINISH_DONE;\n      }\n      if (s.last_lit) {\n        if (flush_block_only(s, !1), s.strm.avail_out === 0)\n          return BS_NEED_MORE;\n      }\n      return BS_BLOCK_DONE;\n    }\n    function deflate_rle(s, flush) {\n      var bflush, prev, scan, strend, _win = s.window;\n      for (;; ) {\n        if (s.lookahead <= MAX_MATCH) {\n          if (fill_window(s), s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH)\n            return BS_NEED_MORE;\n          if (s.lookahead === 0)\n            break;\n        }\n        if (s.match_length = 0, s.lookahead >= MIN_MATCH && s.strstart > 0) {\n          if (scan = s.strstart - 1, prev = _win[scan], prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {\n            strend = s.strstart + MAX_MATCH;\n            do\n              ;\n            while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);\n            if (s.match_length = MAX_MATCH - (strend - scan), s.match_length > s.lookahead)\n              s.match_length = s.lookahead;\n          }\n        }\n        if (s.match_length >= MIN_MATCH)\n          bflush = trees._tr_tally(s, 1, s.match_length - MIN_MATCH), s.lookahead -= s.match_length, s.strstart += s.match_length, s.match_length = 0;\n        else\n          bflush = trees._tr_tally(s, 0, s.window[s.strstart]), s.lookahead--, s.strstart++;\n        if (bflush) {\n          if (flush_block_only(s, !1), s.strm.avail_out === 0)\n            return BS_NEED_MORE;\n        }\n      }\n      if (s.insert = 0, flush === Z_FINISH) {\n        if (flush_block_only(s, !0), s.strm.avail_out === 0)\n          return BS_FINISH_STARTED;\n        return BS_FINISH_DONE;\n      }\n      if (s.last_lit) {\n        if (flush_block_only(s, !1), s.strm.avail_out === 0)\n          return BS_NEED_MORE;\n      }\n      return BS_BLOCK_DONE;\n    }\n    function deflate_huff(s, flush) {\n      var bflush;\n      for (;; ) {\n        if (s.lookahead === 0) {\n          if (fill_window(s), s.lookahead === 0) {\n            if (flush === Z_NO_FLUSH)\n              return BS_NEED_MORE;\n            break;\n          }\n        }\n        if (s.match_length = 0, bflush = trees._tr_tally(s, 0, s.window[s.strstart]), s.lookahead--, s.strstart++, bflush) {\n          if (flush_block_only(s, !1), s.strm.avail_out === 0)\n            return BS_NEED_MORE;\n        }\n      }\n      if (s.insert = 0, flush === Z_FINISH) {\n        if (flush_block_only(s, !0), s.strm.avail_out === 0)\n          return BS_FINISH_STARTED;\n        return BS_FINISH_DONE;\n      }\n      if (s.last_lit) {\n        if (flush_block_only(s, !1), s.strm.avail_out === 0)\n          return BS_NEED_MORE;\n      }\n      return BS_BLOCK_DONE;\n    }\n    function Config(good_length, max_lazy, nice_length, max_chain, func) {\n      this.good_length = good_length, this.max_lazy = max_lazy, this.nice_length = nice_length, this.max_chain = max_chain, this.func = func;\n    }\n    var configuration_table = [\n      new Config(0, 0, 0, 0, deflate_stored),\n      new Config(4, 4, 8, 4, deflate_fast),\n      new Config(4, 5, 16, 8, deflate_fast),\n      new Config(4, 6, 32, 32, deflate_fast),\n      new Config(4, 4, 16, 16, deflate_slow),\n      new Config(8, 16, 32, 32, deflate_slow),\n      new Config(8, 16, 128, 128, deflate_slow),\n      new Config(8, 32, 128, 256, deflate_slow),\n      new Config(32, 128, 258, 1024, deflate_slow),\n      new Config(32, 258, 258, 4096, deflate_slow)\n    ];\n    function lm_init(s) {\n      s.window_size = 2 * s.w_size, zero(s.head), s.max_lazy_match = configuration_table[s.level].max_lazy, s.good_match = configuration_table[s.level].good_length, s.nice_match = configuration_table[s.level].nice_length, s.max_chain_length = configuration_table[s.level].max_chain, s.strstart = 0, s.block_start = 0, s.lookahead = 0, s.insert = 0, s.match_length = s.prev_length = MIN_MATCH - 1, s.match_available = 0, s.ins_h = 0;\n    }\n    function DeflateState() {\n      this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = Z_DEFLATED, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new utils.Buf16(HEAP_SIZE * 2), this.dyn_dtree = new utils.Buf16((2 * D_CODES + 1) * 2), this.bl_tree = new utils.Buf16((2 * BL_CODES + 1) * 2), zero(this.dyn_ltree), zero(this.dyn_dtree), zero(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new utils.Buf16(MAX_BITS + 1), this.heap = new utils.Buf16(2 * L_CODES + 1), zero(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new utils.Buf16(2 * L_CODES + 1), zero(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;\n    }\n    function deflateResetKeep(strm) {\n      var s;\n      if (!strm || !strm.state)\n        return err(strm, Z_STREAM_ERROR);\n      if (strm.total_in = strm.total_out = 0, strm.data_type = Z_UNKNOWN, s = strm.state, s.pending = 0, s.pending_out = 0, s.wrap < 0)\n        s.wrap = -s.wrap;\n      return s.status = s.wrap \? INIT_STATE : BUSY_STATE, strm.adler = s.wrap === 2 \? 0 : 1, s.last_flush = Z_NO_FLUSH, trees._tr_init(s), Z_OK;\n    }\n    function deflateReset(strm) {\n      var ret = deflateResetKeep(strm);\n      if (ret === Z_OK)\n        lm_init(strm.state);\n      return ret;\n    }\n    function deflateSetHeader(strm, head) {\n      if (!strm || !strm.state)\n        return Z_STREAM_ERROR;\n      if (strm.state.wrap !== 2)\n        return Z_STREAM_ERROR;\n      return strm.state.gzhead = head, Z_OK;\n    }\n    function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {\n      if (!strm)\n        return Z_STREAM_ERROR;\n      var wrap = 1;\n      if (level === Z_DEFAULT_COMPRESSION)\n        level = 6;\n      if (windowBits < 0)\n        wrap = 0, windowBits = -windowBits;\n      else if (windowBits > 15)\n        wrap = 2, windowBits -= 16;\n      if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED)\n        return err(strm, Z_STREAM_ERROR);\n      if (windowBits === 8)\n        windowBits = 9;\n      var s = new DeflateState;\n      return strm.state = s, s.strm = strm, s.wrap = wrap, s.gzhead = null, s.w_bits = windowBits, s.w_size = 1 << s.w_bits, s.w_mask = s.w_size - 1, s.hash_bits = memLevel + 7, s.hash_size = 1 << s.hash_bits, s.hash_mask = s.hash_size - 1, s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH), s.window = new utils.Buf8(s.w_size * 2), s.head = new utils.Buf16(s.hash_size), s.prev = new utils.Buf16(s.w_size), s.lit_bufsize = 1 << memLevel + 6, s.pending_buf_size = s.lit_bufsize * 4, s.pending_buf = new utils.Buf8(s.pending_buf_size), s.d_buf = 1 * s.lit_bufsize, s.l_buf = 3 * s.lit_bufsize, s.level = level, s.strategy = strategy, s.method = method, deflateReset(strm);\n    }\n    function deflateInit(strm, level) {\n      return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);\n    }\n    function deflate(strm, flush) {\n      var old_flush, s, beg, val;\n      if (!strm || !strm.state || flush > Z_BLOCK || flush < 0)\n        return strm \? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;\n      if (s = strm.state, !strm.output || !strm.input && strm.avail_in !== 0 || s.status === FINISH_STATE && flush !== Z_FINISH)\n        return err(strm, strm.avail_out === 0 \? Z_BUF_ERROR : Z_STREAM_ERROR);\n      if (s.strm = strm, old_flush = s.last_flush, s.last_flush = flush, s.status === INIT_STATE)\n        if (s.wrap === 2)\n          if (strm.adler = 0, put_byte(s, 31), put_byte(s, 139), put_byte(s, 8), !s.gzhead)\n            put_byte(s, 0), put_byte(s, 0), put_byte(s, 0), put_byte(s, 0), put_byte(s, 0), put_byte(s, s.level === 9 \? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 \? 4 : 0), put_byte(s, OS_CODE), s.status = BUSY_STATE;\n          else {\n            if (put_byte(s, (s.gzhead.text \? 1 : 0) + (s.gzhead.hcrc \? 2 : 0) + (!s.gzhead.extra \? 0 : 4) + (!s.gzhead.name \? 0 : 8) + (!s.gzhead.comment \? 0 : 16)), put_byte(s, s.gzhead.time & 255), put_byte(s, s.gzhead.time >> 8 & 255), put_byte(s, s.gzhead.time >> 16 & 255), put_byte(s, s.gzhead.time >> 24 & 255), put_byte(s, s.level === 9 \? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 \? 4 : 0), put_byte(s, s.gzhead.os & 255), s.gzhead.extra && s.gzhead.extra.length)\n              put_byte(s, s.gzhead.extra.length & 255), put_byte(s, s.gzhead.extra.length >> 8 & 255);\n            if (s.gzhead.hcrc)\n              strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);\n            s.gzindex = 0, s.status = EXTRA_STATE;\n          }\n        else {\n          var header = Z_DEFLATED + (s.w_bits - 8 << 4) << 8, level_flags = -1;\n          if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2)\n            level_flags = 0;\n          else if (s.level < 6)\n            level_flags = 1;\n          else if (s.level === 6)\n            level_flags = 2;\n          else\n            level_flags = 3;\n          if (header |= level_flags << 6, s.strstart !== 0)\n            header |= PRESET_DICT;\n          if (header += 31 - header % 31, s.status = BUSY_STATE, putShortMSB(s, header), s.strstart !== 0)\n            putShortMSB(s, strm.adler >>> 16), putShortMSB(s, strm.adler & 65535);\n          strm.adler = 1;\n        }\n      if (s.status === EXTRA_STATE)\n        if (s.gzhead.extra) {\n          beg = s.pending;\n          while (s.gzindex < (s.gzhead.extra.length & 65535)) {\n            if (s.pending === s.pending_buf_size) {\n              if (s.gzhead.hcrc && s.pending > beg)\n                strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n              if (flush_pending(strm), beg = s.pending, s.pending === s.pending_buf_size)\n                break;\n            }\n            put_byte(s, s.gzhead.extra[s.gzindex] & 255), s.gzindex++;\n          }\n          if (s.gzhead.hcrc && s.pending > beg)\n            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n          if (s.gzindex === s.gzhead.extra.length)\n            s.gzindex = 0, s.status = NAME_STATE;\n        } else\n          s.status = NAME_STATE;\n      if (s.status === NAME_STATE)\n        if (s.gzhead.name) {\n          beg = s.pending;\n          do {\n            if (s.pending === s.pending_buf_size) {\n              if (s.gzhead.hcrc && s.pending > beg)\n                strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n              if (flush_pending(strm), beg = s.pending, s.pending === s.pending_buf_size) {\n                val = 1;\n                break;\n              }\n            }\n            if (s.gzindex < s.gzhead.name.length)\n              val = s.gzhead.name.charCodeAt(s.gzindex++) & 255;\n            else\n              val = 0;\n            put_byte(s, val);\n          } while (val !== 0);\n          if (s.gzhead.hcrc && s.pending > beg)\n            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n          if (val === 0)\n            s.gzindex = 0, s.status = COMMENT_STATE;\n        } else\n          s.status = COMMENT_STATE;\n      if (s.status === COMMENT_STATE)\n        if (s.gzhead.comment) {\n          beg = s.pending;\n          do {\n            if (s.pending === s.pending_buf_size) {\n              if (s.gzhead.hcrc && s.pending > beg)\n                strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n              if (flush_pending(strm), beg = s.pending, s.pending === s.pending_buf_size) {\n                val = 1;\n                break;\n              }\n            }\n            if (s.gzindex < s.gzhead.comment.length)\n              val = s.gzhead.comment.charCodeAt(s.gzindex++) & 255;\n            else\n              val = 0;\n            put_byte(s, val);\n          } while (val !== 0);\n          if (s.gzhead.hcrc && s.pending > beg)\n            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n          if (val === 0)\n            s.status = HCRC_STATE;\n        } else\n          s.status = HCRC_STATE;\n      if (s.status === HCRC_STATE)\n        if (s.gzhead.hcrc) {\n          if (s.pending + 2 > s.pending_buf_size)\n            flush_pending(strm);\n          if (s.pending + 2 <= s.pending_buf_size)\n            put_byte(s, strm.adler & 255), put_byte(s, strm.adler >> 8 & 255), strm.adler = 0, s.status = BUSY_STATE;\n        } else\n          s.status = BUSY_STATE;\n      if (s.pending !== 0) {\n        if (flush_pending(strm), strm.avail_out === 0)\n          return s.last_flush = -1, Z_OK;\n      } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH)\n        return err(strm, Z_BUF_ERROR);\n      if (s.status === FINISH_STATE && strm.avail_in !== 0)\n        return err(strm, Z_BUF_ERROR);\n      if (strm.avail_in !== 0 || s.lookahead !== 0 || flush !== Z_NO_FLUSH && s.status !== FINISH_STATE) {\n        var bstate = s.strategy === Z_HUFFMAN_ONLY \? deflate_huff(s, flush) : s.strategy === Z_RLE \? deflate_rle(s, flush) : configuration_table[s.level].func(s, flush);\n        if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE)\n          s.status = FINISH_STATE;\n        if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {\n          if (strm.avail_out === 0)\n            s.last_flush = -1;\n          return Z_OK;\n        }\n        if (bstate === BS_BLOCK_DONE) {\n          if (flush === Z_PARTIAL_FLUSH)\n            trees._tr_align(s);\n          else if (flush !== Z_BLOCK) {\n            if (trees._tr_stored_block(s, 0, 0, !1), flush === Z_FULL_FLUSH) {\n              if (zero(s.head), s.lookahead === 0)\n                s.strstart = 0, s.block_start = 0, s.insert = 0;\n            }\n          }\n          if (flush_pending(strm), strm.avail_out === 0)\n            return s.last_flush = -1, Z_OK;\n        }\n      }\n      if (flush !== Z_FINISH)\n        return Z_OK;\n      if (s.wrap <= 0)\n        return Z_STREAM_END;\n      if (s.wrap === 2)\n        put_byte(s, strm.adler & 255), put_byte(s, strm.adler >> 8 & 255), put_byte(s, strm.adler >> 16 & 255), put_byte(s, strm.adler >> 24 & 255), put_byte(s, strm.total_in & 255), put_byte(s, strm.total_in >> 8 & 255), put_byte(s, strm.total_in >> 16 & 255), put_byte(s, strm.total_in >> 24 & 255);\n      else\n        putShortMSB(s, strm.adler >>> 16), putShortMSB(s, strm.adler & 65535);\n      if (flush_pending(strm), s.wrap > 0)\n        s.wrap = -s.wrap;\n      return s.pending !== 0 \? Z_OK : Z_STREAM_END;\n    }\n    function deflateEnd(strm) {\n      var status;\n      if (!strm || !strm.state)\n        return Z_STREAM_ERROR;\n      if (status = strm.state.status, status !== INIT_STATE && status !== EXTRA_STATE && status !== NAME_STATE && status !== COMMENT_STATE && status !== HCRC_STATE && status !== BUSY_STATE && status !== FINISH_STATE)\n        return err(strm, Z_STREAM_ERROR);\n      return strm.state = null, status === BUSY_STATE \? err(strm, Z_DATA_ERROR) : Z_OK;\n    }\n    function deflateSetDictionary(strm, dictionary) {\n      var dictLength = dictionary.length, s, str, n, wrap, avail, next, input, tmpDict;\n      if (!strm || !strm.state)\n        return Z_STREAM_ERROR;\n      if (s = strm.state, wrap = s.wrap, wrap === 2 || wrap === 1 && s.status !== INIT_STATE || s.lookahead)\n        return Z_STREAM_ERROR;\n      if (wrap === 1)\n        strm.adler = adler32(strm.adler, dictionary, dictLength, 0);\n      if (s.wrap = 0, dictLength >= s.w_size) {\n        if (wrap === 0)\n          zero(s.head), s.strstart = 0, s.block_start = 0, s.insert = 0;\n        tmpDict = new utils.Buf8(s.w_size), utils.arraySet(tmpDict, dictionary, dictLength - s.w_size, s.w_size, 0), dictionary = tmpDict, dictLength = s.w_size;\n      }\n      avail = strm.avail_in, next = strm.next_in, input = strm.input, strm.avail_in = dictLength, strm.next_in = 0, strm.input = dictionary, fill_window(s);\n      while (s.lookahead >= MIN_MATCH) {\n        str = s.strstart, n = s.lookahead - (MIN_MATCH - 1);\n        do\n          s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask, s.prev[str & s.w_mask] = s.head[s.ins_h], s.head[s.ins_h] = str, str++;\n        while (--n);\n        s.strstart = str, s.lookahead = MIN_MATCH - 1, fill_window(s);\n      }\n      return s.strstart += s.lookahead, s.block_start = s.strstart, s.insert = s.lookahead, s.lookahead = 0, s.match_length = s.prev_length = MIN_MATCH - 1, s.match_available = 0, strm.next_in = next, strm.input = input, strm.avail_in = avail, s.wrap = wrap, Z_OK;\n    }\n    exports.deflateInit = deflateInit, exports.deflateInit2 = deflateInit2, exports.deflateReset = deflateReset, exports.deflateResetKeep = deflateResetKeep, exports.deflateSetHeader = deflateSetHeader, exports.deflate = deflate, exports.deflateEnd = deflateEnd, exports.deflateSetDictionary = deflateSetDictionary, exports.deflateInfo = \"pako deflate (from Nodeca project)\";\n  }\n}), require_inffast = __commonJS({\n  \"node_modules/pako/lib/zlib/inffast.js\"(exports, module2) {\n    var BAD = 30, TYPE = 12;\n    module2.exports = function inflate_fast(strm, start) {\n      var state, _in, last, _out, beg, end, dmax, wsize, whave, wnext, s_window, hold, bits, lcode, dcode, lmask, dmask, here, op, len, dist, from, from_source, input, output;\n      state = strm.state, _in = strm.next_in, input = strm.input, last = _in + (strm.avail_in - 5), _out = strm.next_out, output = strm.output, beg = _out - (start - strm.avail_out), end = _out + (strm.avail_out - 257), dmax = state.dmax, wsize = state.wsize, whave = state.whave, wnext = state.wnext, s_window = state.window, hold = state.hold, bits = state.bits, lcode = state.lencode, dcode = state.distcode, lmask = (1 << state.lenbits) - 1, dmask = (1 << state.distbits) - 1;\n      top:\n        do {\n          if (bits < 15)\n            hold += input[_in++] << bits, bits += 8, hold += input[_in++] << bits, bits += 8;\n          here = lcode[hold & lmask];\n          dolen:\n            for (;; ) {\n              if (op = here >>> 24, hold >>>= op, bits -= op, op = here >>> 16 & 255, op === 0)\n                output[_out++] = here & 65535;\n              else if (op & 16) {\n                if (len = here & 65535, op &= 15, op) {\n                  if (bits < op)\n                    hold += input[_in++] << bits, bits += 8;\n                  len += hold & (1 << op) - 1, hold >>>= op, bits -= op;\n                }\n                if (bits < 15)\n                  hold += input[_in++] << bits, bits += 8, hold += input[_in++] << bits, bits += 8;\n                here = dcode[hold & dmask];\n                dodist:\n                  for (;; ) {\n                    if (op = here >>> 24, hold >>>= op, bits -= op, op = here >>> 16 & 255, op & 16) {\n                      if (dist = here & 65535, op &= 15, bits < op) {\n                        if (hold += input[_in++] << bits, bits += 8, bits < op)\n                          hold += input[_in++] << bits, bits += 8;\n                      }\n                      if (dist += hold & (1 << op) - 1, dist > dmax) {\n                        strm.msg = \"invalid distance too far back\", state.mode = BAD;\n                        break top;\n                      }\n                      if (hold >>>= op, bits -= op, op = _out - beg, dist > op) {\n                        if (op = dist - op, op > whave) {\n                          if (state.sane) {\n                            strm.msg = \"invalid distance too far back\", state.mode = BAD;\n                            break top;\n                          }\n                        }\n                        if (from = 0, from_source = s_window, wnext === 0) {\n                          if (from += wsize - op, op < len) {\n                            len -= op;\n                            do\n                              output[_out++] = s_window[from++];\n                            while (--op);\n                            from = _out - dist, from_source = output;\n                          }\n                        } else if (wnext < op) {\n                          if (from += wsize + wnext - op, op -= wnext, op < len) {\n                            len -= op;\n                            do\n                              output[_out++] = s_window[from++];\n                            while (--op);\n                            if (from = 0, wnext < len) {\n                              op = wnext, len -= op;\n                              do\n                                output[_out++] = s_window[from++];\n                              while (--op);\n                              from = _out - dist, from_source = output;\n                            }\n                          }\n                        } else if (from += wnext - op, op < len) {\n                          len -= op;\n                          do\n                            output[_out++] = s_window[from++];\n                          while (--op);\n                          from = _out - dist, from_source = output;\n                        }\n                        while (len > 2)\n                          output[_out++] = from_source[from++], output[_out++] = from_source[from++], output[_out++] = from_source[from++], len -= 3;\n                        if (len) {\n                          if (output[_out++] = from_source[from++], len > 1)\n                            output[_out++] = from_source[from++];\n                        }\n                      } else {\n                        from = _out - dist;\n                        do\n                          output[_out++] = output[from++], output[_out++] = output[from++], output[_out++] = output[from++], len -= 3;\n                        while (len > 2);\n                        if (len) {\n                          if (output[_out++] = output[from++], len > 1)\n                            output[_out++] = output[from++];\n                        }\n                      }\n                    } else if ((op & 64) === 0) {\n                      here = dcode[(here & 65535) + (hold & (1 << op) - 1)];\n                      continue dodist;\n                    } else {\n                      strm.msg = \"invalid distance code\", state.mode = BAD;\n                      break top;\n                    }\n                    break;\n                  }\n              } else if ((op & 64) === 0) {\n                here = lcode[(here & 65535) + (hold & (1 << op) - 1)];\n                continue dolen;\n              } else if (op & 32) {\n                state.mode = TYPE;\n                break top;\n              } else {\n                strm.msg = \"invalid literal/length code\", state.mode = BAD;\n                break top;\n              }\n              break;\n            }\n        } while (_in < last && _out < end);\n      len = bits >> 3, _in -= len, bits -= len << 3, hold &= (1 << bits) - 1, strm.next_in = _in, strm.next_out = _out, strm.avail_in = _in < last \? 5 + (last - _in) : 5 - (_in - last), strm.avail_out = _out < end \? 257 + (end - _out) : 257 - (_out - end), state.hold = hold, state.bits = bits;\n      return;\n    };\n  }\n}), require_inftrees = __commonJS({\n  \"node_modules/pako/lib/zlib/inftrees.js\"(exports, module2) {\n    var utils = require_common(), MAXBITS = 15, ENOUGH_LENS = 852, ENOUGH_DISTS = 592, CODES = 0, LENS = 1, DISTS = 2, lbase = [\n      3,\n      4,\n      5,\n      6,\n      7,\n      8,\n      9,\n      10,\n      11,\n      13,\n      15,\n      17,\n      19,\n      23,\n      27,\n      31,\n      35,\n      43,\n      51,\n      59,\n      67,\n      83,\n      99,\n      115,\n      131,\n      163,\n      195,\n      227,\n      258,\n      0,\n      0\n    ], lext = [\n      16,\n      16,\n      16,\n      16,\n      16,\n      16,\n      16,\n      16,\n      17,\n      17,\n      17,\n      17,\n      18,\n      18,\n      18,\n      18,\n      19,\n      19,\n      19,\n      19,\n      20,\n      20,\n      20,\n      20,\n      21,\n      21,\n      21,\n      21,\n      16,\n      72,\n      78\n    ], dbase = [\n      1,\n      2,\n      3,\n      4,\n      5,\n      7,\n      9,\n      13,\n      17,\n      25,\n      33,\n      49,\n      65,\n      97,\n      129,\n      193,\n      257,\n      385,\n      513,\n      769,\n      1025,\n      1537,\n      2049,\n      3073,\n      4097,\n      6145,\n      8193,\n      12289,\n      16385,\n      24577,\n      0,\n      0\n    ], dext = [\n      16,\n      16,\n      16,\n      16,\n      17,\n      17,\n      18,\n      18,\n      19,\n      19,\n      20,\n      20,\n      21,\n      21,\n      22,\n      22,\n      23,\n      23,\n      24,\n      24,\n      25,\n      25,\n      26,\n      26,\n      27,\n      27,\n      28,\n      28,\n      29,\n      29,\n      64,\n      64\n    ];\n    module2.exports = function inflate_table(type, lens, lens_index, codes, table, table_index, work, opts) {\n      var bits = opts.bits, len = 0, sym = 0, min = 0, max = 0, root = 0, curr = 0, drop = 0, left = 0, used = 0, huff = 0, incr, fill, low, mask, next, base = null, base_index = 0, end, count = new utils.Buf16(MAXBITS + 1), offs = new utils.Buf16(MAXBITS + 1), extra = null, extra_index = 0, here_bits, here_op, here_val;\n      for (len = 0;len <= MAXBITS; len++)\n        count[len] = 0;\n      for (sym = 0;sym < codes; sym++)\n        count[lens[lens_index + sym]]++;\n      root = bits;\n      for (max = MAXBITS;max >= 1; max--)\n        if (count[max] !== 0)\n          break;\n      if (root > max)\n        root = max;\n      if (max === 0)\n        return table[table_index++] = 1 << 24 | 64 << 16 | 0, table[table_index++] = 1 << 24 | 64 << 16 | 0, opts.bits = 1, 0;\n      for (min = 1;min < max; min++)\n        if (count[min] !== 0)\n          break;\n      if (root < min)\n        root = min;\n      left = 1;\n      for (len = 1;len <= MAXBITS; len++)\n        if (left <<= 1, left -= count[len], left < 0)\n          return -1;\n      if (left > 0 && (type === CODES || max !== 1))\n        return -1;\n      offs[1] = 0;\n      for (len = 1;len < MAXBITS; len++)\n        offs[len + 1] = offs[len] + count[len];\n      for (sym = 0;sym < codes; sym++)\n        if (lens[lens_index + sym] !== 0)\n          work[offs[lens[lens_index + sym]]++] = sym;\n      if (type === CODES)\n        base = extra = work, end = 19;\n      else if (type === LENS)\n        base = lbase, base_index -= 257, extra = lext, extra_index -= 257, end = 256;\n      else\n        base = dbase, extra = dext, end = -1;\n      if (huff = 0, sym = 0, len = min, next = table_index, curr = root, drop = 0, low = -1, used = 1 << root, mask = used - 1, type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS)\n        return 1;\n      for (;; ) {\n        if (here_bits = len - drop, work[sym] < end)\n          here_op = 0, here_val = work[sym];\n        else if (work[sym] > end)\n          here_op = extra[extra_index + work[sym]], here_val = base[base_index + work[sym]];\n        else\n          here_op = 96, here_val = 0;\n        incr = 1 << len - drop, fill = 1 << curr, min = fill;\n        do\n          fill -= incr, table[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;\n        while (fill !== 0);\n        incr = 1 << len - 1;\n        while (huff & incr)\n          incr >>= 1;\n        if (incr !== 0)\n          huff &= incr - 1, huff += incr;\n        else\n          huff = 0;\n        if (sym++, --count[len] === 0) {\n          if (len === max)\n            break;\n          len = lens[lens_index + work[sym]];\n        }\n        if (len > root && (huff & mask) !== low) {\n          if (drop === 0)\n            drop = root;\n          next += min, curr = len - drop, left = 1 << curr;\n          while (curr + drop < max) {\n            if (left -= count[curr + drop], left <= 0)\n              break;\n            curr++, left <<= 1;\n          }\n          if (used += 1 << curr, type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS)\n            return 1;\n          low = huff & mask, table[low] = root << 24 | curr << 16 | next - table_index | 0;\n        }\n      }\n      if (huff !== 0)\n        table[next + huff] = len - drop << 24 | 64 << 16 | 0;\n      return opts.bits = root, 0;\n    };\n  }\n}), require_inflate = __commonJS({\n  \"node_modules/pako/lib/zlib/inflate.js\"(exports) {\n    var utils = require_common(), adler32 = require_adler32(), crc32 = require_crc32(), inflate_fast = require_inffast(), inflate_table = require_inftrees(), CODES = 0, LENS = 1, DISTS = 2, Z_FINISH = 4, Z_BLOCK = 5, Z_TREES = 6, Z_OK = 0, Z_STREAM_END = 1, Z_NEED_DICT = 2, Z_STREAM_ERROR = -2, Z_DATA_ERROR = -3, Z_MEM_ERROR = -4, Z_BUF_ERROR = -5, Z_DEFLATED = 8, HEAD = 1, FLAGS = 2, TIME = 3, OS = 4, EXLEN = 5, EXTRA = 6, NAME = 7, COMMENT = 8, HCRC = 9, DICTID = 10, DICT = 11, TYPE = 12, TYPEDO = 13, STORED = 14, COPY_ = 15, COPY = 16, TABLE = 17, LENLENS = 18, CODELENS = 19, LEN_ = 20, LEN = 21, LENEXT = 22, DIST = 23, DISTEXT = 24, MATCH = 25, LIT = 26, CHECK = 27, LENGTH = 28, DONE = 29, BAD = 30, MEM = 31, SYNC = 32, ENOUGH_LENS = 852, ENOUGH_DISTS = 592, MAX_WBITS = 15, DEF_WBITS = MAX_WBITS;\n    function zswap32(q) {\n      return (q >>> 24 & 255) + (q >>> 8 & 65280) + ((q & 65280) << 8) + ((q & 255) << 24);\n    }\n    function InflateState() {\n      this.mode = 0, this.last = !1, this.wrap = 0, this.havedict = !1, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new utils.Buf16(320), this.work = new utils.Buf16(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;\n    }\n    function inflateResetKeep(strm) {\n      var state;\n      if (!strm || !strm.state)\n        return Z_STREAM_ERROR;\n      if (state = strm.state, strm.total_in = strm.total_out = state.total = 0, strm.msg = \"\", state.wrap)\n        strm.adler = state.wrap & 1;\n      return state.mode = HEAD, state.last = 0, state.havedict = 0, state.dmax = 32768, state.head = null, state.hold = 0, state.bits = 0, state.lencode = state.lendyn = new utils.Buf32(ENOUGH_LENS), state.distcode = state.distdyn = new utils.Buf32(ENOUGH_DISTS), state.sane = 1, state.back = -1, Z_OK;\n    }\n    function inflateReset(strm) {\n      var state;\n      if (!strm || !strm.state)\n        return Z_STREAM_ERROR;\n      return state = strm.state, state.wsize = 0, state.whave = 0, state.wnext = 0, inflateResetKeep(strm);\n    }\n    function inflateReset2(strm, windowBits) {\n      var wrap, state;\n      if (!strm || !strm.state)\n        return Z_STREAM_ERROR;\n      if (state = strm.state, windowBits < 0)\n        wrap = 0, windowBits = -windowBits;\n      else if (wrap = (windowBits >> 4) + 1, windowBits < 48)\n        windowBits &= 15;\n      if (windowBits && (windowBits < 8 || windowBits > 15))\n        return Z_STREAM_ERROR;\n      if (state.window !== null && state.wbits !== windowBits)\n        state.window = null;\n      return state.wrap = wrap, state.wbits = windowBits, inflateReset(strm);\n    }\n    function inflateInit2(strm, windowBits) {\n      var ret, state;\n      if (!strm)\n        return Z_STREAM_ERROR;\n      if (state = new InflateState, strm.state = state, state.window = null, ret = inflateReset2(strm, windowBits), ret !== Z_OK)\n        strm.state = null;\n      return ret;\n    }\n    function inflateInit(strm) {\n      return inflateInit2(strm, DEF_WBITS);\n    }\n    var virgin = !0, lenfix, distfix;\n    function fixedtables(state) {\n      if (virgin) {\n        var sym;\n        lenfix = new utils.Buf32(512), distfix = new utils.Buf32(32), sym = 0;\n        while (sym < 144)\n          state.lens[sym++] = 8;\n        while (sym < 256)\n          state.lens[sym++] = 9;\n        while (sym < 280)\n          state.lens[sym++] = 7;\n        while (sym < 288)\n          state.lens[sym++] = 8;\n        inflate_table(LENS, state.lens, 0, 288, lenfix, 0, state.work, {\n          bits: 9\n        }), sym = 0;\n        while (sym < 32)\n          state.lens[sym++] = 5;\n        inflate_table(DISTS, state.lens, 0, 32, distfix, 0, state.work, {\n          bits: 5\n        }), virgin = !1;\n      }\n      state.lencode = lenfix, state.lenbits = 9, state.distcode = distfix, state.distbits = 5;\n    }\n    function updatewindow(strm, src, end, copy) {\n      var dist, state = strm.state;\n      if (state.window === null)\n        state.wsize = 1 << state.wbits, state.wnext = 0, state.whave = 0, state.window = new utils.Buf8(state.wsize);\n      if (copy >= state.wsize)\n        utils.arraySet(state.window, src, end - state.wsize, state.wsize, 0), state.wnext = 0, state.whave = state.wsize;\n      else {\n        if (dist = state.wsize - state.wnext, dist > copy)\n          dist = copy;\n        if (utils.arraySet(state.window, src, end - copy, dist, state.wnext), copy -= dist, copy)\n          utils.arraySet(state.window, src, end - copy, copy, 0), state.wnext = copy, state.whave = state.wsize;\n        else {\n          if (state.wnext += dist, state.wnext === state.wsize)\n            state.wnext = 0;\n          if (state.whave < state.wsize)\n            state.whave += dist;\n        }\n      }\n      return 0;\n    }\n    function inflate(strm, flush) {\n      var state, input, output, next, put, have, left, hold, bits, _in, _out, copy, from, from_source, here = 0, here_bits, here_op, here_val, last_bits, last_op, last_val, len, ret, hbuf = new utils.Buf8(4), opts, n, order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];\n      if (!strm || !strm.state || !strm.output || !strm.input && strm.avail_in !== 0)\n        return Z_STREAM_ERROR;\n      if (state = strm.state, state.mode === TYPE)\n        state.mode = TYPEDO;\n      put = strm.next_out, output = strm.output, left = strm.avail_out, next = strm.next_in, input = strm.input, have = strm.avail_in, hold = state.hold, bits = state.bits, _in = have, _out = left, ret = Z_OK;\n      inf_leave:\n        for (;; )\n          switch (state.mode) {\n            case HEAD:\n              if (state.wrap === 0) {\n                state.mode = TYPEDO;\n                break;\n              }\n              while (bits < 16) {\n                if (have === 0)\n                  break inf_leave;\n                have--, hold += input[next++] << bits, bits += 8;\n              }\n              if (state.wrap & 2 && hold === 35615) {\n                state.check = 0, hbuf[0] = hold & 255, hbuf[1] = hold >>> 8 & 255, state.check = crc32(state.check, hbuf, 2, 0), hold = 0, bits = 0, state.mode = FLAGS;\n                break;\n              }\n              if (state.flags = 0, state.head)\n                state.head.done = !1;\n              if (!(state.wrap & 1) || (((hold & 255) << 8) + (hold >> 8)) % 31) {\n                strm.msg = \"incorrect header check\", state.mode = BAD;\n                break;\n              }\n              if ((hold & 15) !== Z_DEFLATED) {\n                strm.msg = \"unknown compression method\", state.mode = BAD;\n                break;\n              }\n              if (hold >>>= 4, bits -= 4, len = (hold & 15) + 8, state.wbits === 0)\n                state.wbits = len;\n              else if (len > state.wbits) {\n                strm.msg = \"invalid window size\", state.mode = BAD;\n                break;\n              }\n              state.dmax = 1 << len, strm.adler = state.check = 1, state.mode = hold & 512 \? DICTID : TYPE, hold = 0, bits = 0;\n              break;\n            case FLAGS:\n              while (bits < 16) {\n                if (have === 0)\n                  break inf_leave;\n                have--, hold += input[next++] << bits, bits += 8;\n              }\n              if (state.flags = hold, (state.flags & 255) !== Z_DEFLATED) {\n                strm.msg = \"unknown compression method\", state.mode = BAD;\n                break;\n              }\n              if (state.flags & 57344) {\n                strm.msg = \"unknown header flags set\", state.mode = BAD;\n                break;\n              }\n              if (state.head)\n                state.head.text = hold >> 8 & 1;\n              if (state.flags & 512)\n                hbuf[0] = hold & 255, hbuf[1] = hold >>> 8 & 255, state.check = crc32(state.check, hbuf, 2, 0);\n              hold = 0, bits = 0, state.mode = TIME;\n            case TIME:\n              while (bits < 32) {\n                if (have === 0)\n                  break inf_leave;\n                have--, hold += input[next++] << bits, bits += 8;\n              }\n              if (state.head)\n                state.head.time = hold;\n              if (state.flags & 512)\n                hbuf[0] = hold & 255, hbuf[1] = hold >>> 8 & 255, hbuf[2] = hold >>> 16 & 255, hbuf[3] = hold >>> 24 & 255, state.check = crc32(state.check, hbuf, 4, 0);\n              hold = 0, bits = 0, state.mode = OS;\n            case OS:\n              while (bits < 16) {\n                if (have === 0)\n                  break inf_leave;\n                have--, hold += input[next++] << bits, bits += 8;\n              }\n              if (state.head)\n                state.head.xflags = hold & 255, state.head.os = hold >> 8;\n              if (state.flags & 512)\n                hbuf[0] = hold & 255, hbuf[1] = hold >>> 8 & 255, state.check = crc32(state.check, hbuf, 2, 0);\n              hold = 0, bits = 0, state.mode = EXLEN;\n            case EXLEN:\n              if (state.flags & 1024) {\n                while (bits < 16) {\n                  if (have === 0)\n                    break inf_leave;\n                  have--, hold += input[next++] << bits, bits += 8;\n                }\n                if (state.length = hold, state.head)\n                  state.head.extra_len = hold;\n                if (state.flags & 512)\n                  hbuf[0] = hold & 255, hbuf[1] = hold >>> 8 & 255, state.check = crc32(state.check, hbuf, 2, 0);\n                hold = 0, bits = 0;\n              } else if (state.head)\n                state.head.extra = null;\n              state.mode = EXTRA;\n            case EXTRA:\n              if (state.flags & 1024) {\n                if (copy = state.length, copy > have)\n                  copy = have;\n                if (copy) {\n                  if (state.head) {\n                    if (len = state.head.extra_len - state.length, !state.head.extra)\n                      state.head.extra = new Array(state.head.extra_len);\n                    utils.arraySet(state.head.extra, input, next, copy, len);\n                  }\n                  if (state.flags & 512)\n                    state.check = crc32(state.check, input, copy, next);\n                  have -= copy, next += copy, state.length -= copy;\n                }\n                if (state.length)\n                  break inf_leave;\n              }\n              state.length = 0, state.mode = NAME;\n            case NAME:\n              if (state.flags & 2048) {\n                if (have === 0)\n                  break inf_leave;\n                copy = 0;\n                do\n                  if (len = input[next + copy++], state.head && len && state.length < 65536)\n                    state.head.name += String.fromCharCode(len);\n                while (len && copy < have);\n                if (state.flags & 512)\n                  state.check = crc32(state.check, input, copy, next);\n                if (have -= copy, next += copy, len)\n                  break inf_leave;\n              } else if (state.head)\n                state.head.name = null;\n              state.length = 0, state.mode = COMMENT;\n            case COMMENT:\n              if (state.flags & 4096) {\n                if (have === 0)\n                  break inf_leave;\n                copy = 0;\n                do\n                  if (len = input[next + copy++], state.head && len && state.length < 65536)\n                    state.head.comment += String.fromCharCode(len);\n                while (len && copy < have);\n                if (state.flags & 512)\n                  state.check = crc32(state.check, input, copy, next);\n                if (have -= copy, next += copy, len)\n                  break inf_leave;\n              } else if (state.head)\n                state.head.comment = null;\n              state.mode = HCRC;\n            case HCRC:\n              if (state.flags & 512) {\n                while (bits < 16) {\n                  if (have === 0)\n                    break inf_leave;\n                  have--, hold += input[next++] << bits, bits += 8;\n                }\n                if (hold !== (state.check & 65535)) {\n                  strm.msg = \"header crc mismatch\", state.mode = BAD;\n                  break;\n                }\n                hold = 0, bits = 0;\n              }\n              if (state.head)\n                state.head.hcrc = state.flags >> 9 & 1, state.head.done = !0;\n              strm.adler = state.check = 0, state.mode = TYPE;\n              break;\n            case DICTID:\n              while (bits < 32) {\n                if (have === 0)\n                  break inf_leave;\n                have--, hold += input[next++] << bits, bits += 8;\n              }\n              strm.adler = state.check = zswap32(hold), hold = 0, bits = 0, state.mode = DICT;\n            case DICT:\n              if (state.havedict === 0)\n                return strm.next_out = put, strm.avail_out = left, strm.next_in = next, strm.avail_in = have, state.hold = hold, state.bits = bits, Z_NEED_DICT;\n              strm.adler = state.check = 1, state.mode = TYPE;\n            case TYPE:\n              if (flush === Z_BLOCK || flush === Z_TREES)\n                break inf_leave;\n            case TYPEDO:\n              if (state.last) {\n                hold >>>= bits & 7, bits -= bits & 7, state.mode = CHECK;\n                break;\n              }\n              while (bits < 3) {\n                if (have === 0)\n                  break inf_leave;\n                have--, hold += input[next++] << bits, bits += 8;\n              }\n              switch (state.last = hold & 1, hold >>>= 1, bits -= 1, hold & 3) {\n                case 0:\n                  state.mode = STORED;\n                  break;\n                case 1:\n                  if (fixedtables(state), state.mode = LEN_, flush === Z_TREES) {\n                    hold >>>= 2, bits -= 2;\n                    break inf_leave;\n                  }\n                  break;\n                case 2:\n                  state.mode = TABLE;\n                  break;\n                case 3:\n                  strm.msg = \"invalid block type\", state.mode = BAD;\n              }\n              hold >>>= 2, bits -= 2;\n              break;\n            case STORED:\n              hold >>>= bits & 7, bits -= bits & 7;\n              while (bits < 32) {\n                if (have === 0)\n                  break inf_leave;\n                have--, hold += input[next++] << bits, bits += 8;\n              }\n              if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {\n                strm.msg = \"invalid stored block lengths\", state.mode = BAD;\n                break;\n              }\n              if (state.length = hold & 65535, hold = 0, bits = 0, state.mode = COPY_, flush === Z_TREES)\n                break inf_leave;\n            case COPY_:\n              state.mode = COPY;\n            case COPY:\n              if (copy = state.length, copy) {\n                if (copy > have)\n                  copy = have;\n                if (copy > left)\n                  copy = left;\n                if (copy === 0)\n                  break inf_leave;\n                utils.arraySet(output, input, next, copy, put), have -= copy, next += copy, left -= copy, put += copy, state.length -= copy;\n                break;\n              }\n              state.mode = TYPE;\n              break;\n            case TABLE:\n              while (bits < 14) {\n                if (have === 0)\n                  break inf_leave;\n                have--, hold += input[next++] << bits, bits += 8;\n              }\n              if (state.nlen = (hold & 31) + 257, hold >>>= 5, bits -= 5, state.ndist = (hold & 31) + 1, hold >>>= 5, bits -= 5, state.ncode = (hold & 15) + 4, hold >>>= 4, bits -= 4, state.nlen > 286 || state.ndist > 30) {\n                strm.msg = \"too many length or distance symbols\", state.mode = BAD;\n                break;\n              }\n              state.have = 0, state.mode = LENLENS;\n            case LENLENS:\n              while (state.have < state.ncode) {\n                while (bits < 3) {\n                  if (have === 0)\n                    break inf_leave;\n                  have--, hold += input[next++] << bits, bits += 8;\n                }\n                state.lens[order[state.have++]] = hold & 7, hold >>>= 3, bits -= 3;\n              }\n              while (state.have < 19)\n                state.lens[order[state.have++]] = 0;\n              if (state.lencode = state.lendyn, state.lenbits = 7, opts = { bits: state.lenbits }, ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts), state.lenbits = opts.bits, ret) {\n                strm.msg = \"invalid code lengths set\", state.mode = BAD;\n                break;\n              }\n              state.have = 0, state.mode = CODELENS;\n            case CODELENS:\n              while (state.have < state.nlen + state.ndist) {\n                for (;; ) {\n                  if (here = state.lencode[hold & (1 << state.lenbits) - 1], here_bits = here >>> 24, here_op = here >>> 16 & 255, here_val = here & 65535, here_bits <= bits)\n                    break;\n                  if (have === 0)\n                    break inf_leave;\n                  have--, hold += input[next++] << bits, bits += 8;\n                }\n                if (here_val < 16)\n                  hold >>>= here_bits, bits -= here_bits, state.lens[state.have++] = here_val;\n                else {\n                  if (here_val === 16) {\n                    n = here_bits + 2;\n                    while (bits < n) {\n                      if (have === 0)\n                        break inf_leave;\n                      have--, hold += input[next++] << bits, bits += 8;\n                    }\n                    if (hold >>>= here_bits, bits -= here_bits, state.have === 0) {\n                      strm.msg = \"invalid bit length repeat\", state.mode = BAD;\n                      break;\n                    }\n                    len = state.lens[state.have - 1], copy = 3 + (hold & 3), hold >>>= 2, bits -= 2;\n                  } else if (here_val === 17) {\n                    n = here_bits + 3;\n                    while (bits < n) {\n                      if (have === 0)\n                        break inf_leave;\n                      have--, hold += input[next++] << bits, bits += 8;\n                    }\n                    hold >>>= here_bits, bits -= here_bits, len = 0, copy = 3 + (hold & 7), hold >>>= 3, bits -= 3;\n                  } else {\n                    n = here_bits + 7;\n                    while (bits < n) {\n                      if (have === 0)\n                        break inf_leave;\n                      have--, hold += input[next++] << bits, bits += 8;\n                    }\n                    hold >>>= here_bits, bits -= here_bits, len = 0, copy = 11 + (hold & 127), hold >>>= 7, bits -= 7;\n                  }\n                  if (state.have + copy > state.nlen + state.ndist) {\n                    strm.msg = \"invalid bit length repeat\", state.mode = BAD;\n                    break;\n                  }\n                  while (copy--)\n                    state.lens[state.have++] = len;\n                }\n              }\n              if (state.mode === BAD)\n                break;\n              if (state.lens[256] === 0) {\n                strm.msg = \"invalid code -- missing end-of-block\", state.mode = BAD;\n                break;\n              }\n              if (state.lenbits = 9, opts = { bits: state.lenbits }, ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts), state.lenbits = opts.bits, ret) {\n                strm.msg = \"invalid literal/lengths set\", state.mode = BAD;\n                break;\n              }\n              if (state.distbits = 6, state.distcode = state.distdyn, opts = { bits: state.distbits }, ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts), state.distbits = opts.bits, ret) {\n                strm.msg = \"invalid distances set\", state.mode = BAD;\n                break;\n              }\n              if (state.mode = LEN_, flush === Z_TREES)\n                break inf_leave;\n            case LEN_:\n              state.mode = LEN;\n            case LEN:\n              if (have >= 6 && left >= 258) {\n                if (strm.next_out = put, strm.avail_out = left, strm.next_in = next, strm.avail_in = have, state.hold = hold, state.bits = bits, inflate_fast(strm, _out), put = strm.next_out, output = strm.output, left = strm.avail_out, next = strm.next_in, input = strm.input, have = strm.avail_in, hold = state.hold, bits = state.bits, state.mode === TYPE)\n                  state.back = -1;\n                break;\n              }\n              state.back = 0;\n              for (;; ) {\n                if (here = state.lencode[hold & (1 << state.lenbits) - 1], here_bits = here >>> 24, here_op = here >>> 16 & 255, here_val = here & 65535, here_bits <= bits)\n                  break;\n                if (have === 0)\n                  break inf_leave;\n                have--, hold += input[next++] << bits, bits += 8;\n              }\n              if (here_op && (here_op & 240) === 0) {\n                last_bits = here_bits, last_op = here_op, last_val = here_val;\n                for (;; ) {\n                  if (here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)], here_bits = here >>> 24, here_op = here >>> 16 & 255, here_val = here & 65535, last_bits + here_bits <= bits)\n                    break;\n                  if (have === 0)\n                    break inf_leave;\n                  have--, hold += input[next++] << bits, bits += 8;\n                }\n                hold >>>= last_bits, bits -= last_bits, state.back += last_bits;\n              }\n              if (hold >>>= here_bits, bits -= here_bits, state.back += here_bits, state.length = here_val, here_op === 0) {\n                state.mode = LIT;\n                break;\n              }\n              if (here_op & 32) {\n                state.back = -1, state.mode = TYPE;\n                break;\n              }\n              if (here_op & 64) {\n                strm.msg = \"invalid literal/length code\", state.mode = BAD;\n                break;\n              }\n              state.extra = here_op & 15, state.mode = LENEXT;\n            case LENEXT:\n              if (state.extra) {\n                n = state.extra;\n                while (bits < n) {\n                  if (have === 0)\n                    break inf_leave;\n                  have--, hold += input[next++] << bits, bits += 8;\n                }\n                state.length += hold & (1 << state.extra) - 1, hold >>>= state.extra, bits -= state.extra, state.back += state.extra;\n              }\n              state.was = state.length, state.mode = DIST;\n            case DIST:\n              for (;; ) {\n                if (here = state.distcode[hold & (1 << state.distbits) - 1], here_bits = here >>> 24, here_op = here >>> 16 & 255, here_val = here & 65535, here_bits <= bits)\n                  break;\n                if (have === 0)\n                  break inf_leave;\n                have--, hold += input[next++] << bits, bits += 8;\n              }\n              if ((here_op & 240) === 0) {\n                last_bits = here_bits, last_op = here_op, last_val = here_val;\n                for (;; ) {\n                  if (here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)], here_bits = here >>> 24, here_op = here >>> 16 & 255, here_val = here & 65535, last_bits + here_bits <= bits)\n                    break;\n                  if (have === 0)\n                    break inf_leave;\n                  have--, hold += input[next++] << bits, bits += 8;\n                }\n                hold >>>= last_bits, bits -= last_bits, state.back += last_bits;\n              }\n              if (hold >>>= here_bits, bits -= here_bits, state.back += here_bits, here_op & 64) {\n                strm.msg = \"invalid distance code\", state.mode = BAD;\n                break;\n              }\n              state.offset = here_val, state.extra = here_op & 15, state.mode = DISTEXT;\n            case DISTEXT:\n              if (state.extra) {\n                n = state.extra;\n                while (bits < n) {\n                  if (have === 0)\n                    break inf_leave;\n                  have--, hold += input[next++] << bits, bits += 8;\n                }\n                state.offset += hold & (1 << state.extra) - 1, hold >>>= state.extra, bits -= state.extra, state.back += state.extra;\n              }\n              if (state.offset > state.dmax) {\n                strm.msg = \"invalid distance too far back\", state.mode = BAD;\n                break;\n              }\n              state.mode = MATCH;\n            case MATCH:\n              if (left === 0)\n                break inf_leave;\n              if (copy = _out - left, state.offset > copy) {\n                if (copy = state.offset - copy, copy > state.whave) {\n                  if (state.sane) {\n                    strm.msg = \"invalid distance too far back\", state.mode = BAD;\n                    break;\n                  }\n                }\n                if (copy > state.wnext)\n                  copy -= state.wnext, from = state.wsize - copy;\n                else\n                  from = state.wnext - copy;\n                if (copy > state.length)\n                  copy = state.length;\n                from_source = state.window;\n              } else\n                from_source = output, from = put - state.offset, copy = state.length;\n              if (copy > left)\n                copy = left;\n              left -= copy, state.length -= copy;\n              do\n                output[put++] = from_source[from++];\n              while (--copy);\n              if (state.length === 0)\n                state.mode = LEN;\n              break;\n            case LIT:\n              if (left === 0)\n                break inf_leave;\n              output[put++] = state.length, left--, state.mode = LEN;\n              break;\n            case CHECK:\n              if (state.wrap) {\n                while (bits < 32) {\n                  if (have === 0)\n                    break inf_leave;\n                  have--, hold |= input[next++] << bits, bits += 8;\n                }\n                if (_out -= left, strm.total_out += _out, state.total += _out, _out)\n                  strm.adler = state.check = state.flags \? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out);\n                if (_out = left, (state.flags \? hold : zswap32(hold)) !== state.check) {\n                  strm.msg = \"incorrect data check\", state.mode = BAD;\n                  break;\n                }\n                hold = 0, bits = 0;\n              }\n              state.mode = LENGTH;\n            case LENGTH:\n              if (state.wrap && state.flags) {\n                while (bits < 32) {\n                  if (have === 0)\n                    break inf_leave;\n                  have--, hold += input[next++] << bits, bits += 8;\n                }\n                if (hold !== (state.total & 4294967295)) {\n                  strm.msg = \"incorrect length check\", state.mode = BAD;\n                  break;\n                }\n                hold = 0, bits = 0;\n              }\n              state.mode = DONE;\n            case DONE:\n              ret = Z_STREAM_END;\n              break inf_leave;\n            case BAD:\n              ret = Z_DATA_ERROR;\n              break inf_leave;\n            case MEM:\n              return Z_MEM_ERROR;\n            case SYNC:\n            default:\n              return Z_STREAM_ERROR;\n          }\n      if (strm.next_out = put, strm.avail_out = left, strm.next_in = next, strm.avail_in = have, state.hold = hold, state.bits = bits, state.wsize || _out !== strm.avail_out && state.mode < BAD && (state.mode < CHECK || flush !== Z_FINISH)) {\n        if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out))\n          return state.mode = MEM, Z_MEM_ERROR;\n      }\n      if (_in -= strm.avail_in, _out -= strm.avail_out, strm.total_in += _in, strm.total_out += _out, state.total += _out, state.wrap && _out)\n        strm.adler = state.check = state.flags \? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out);\n      if (strm.data_type = state.bits + (state.last \? 64 : 0) + (state.mode === TYPE \? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ \? 256 : 0), (_in === 0 && _out === 0 || flush === Z_FINISH) && ret === Z_OK)\n        ret = Z_BUF_ERROR;\n      return ret;\n    }\n    function inflateEnd(strm) {\n      if (!strm || !strm.state)\n        return Z_STREAM_ERROR;\n      var state = strm.state;\n      if (state.window)\n        state.window = null;\n      return strm.state = null, Z_OK;\n    }\n    function inflateGetHeader(strm, head) {\n      var state;\n      if (!strm || !strm.state)\n        return Z_STREAM_ERROR;\n      if (state = strm.state, (state.wrap & 2) === 0)\n        return Z_STREAM_ERROR;\n      return state.head = head, head.done = !1, Z_OK;\n    }\n    function inflateSetDictionary(strm, dictionary) {\n      var dictLength = dictionary.length, state, dictid, ret;\n      if (!strm || !strm.state)\n        return Z_STREAM_ERROR;\n      if (state = strm.state, state.wrap !== 0 && state.mode !== DICT)\n        return Z_STREAM_ERROR;\n      if (state.mode === DICT) {\n        if (dictid = 1, dictid = adler32(dictid, dictionary, dictLength, 0), dictid !== state.check)\n          return Z_DATA_ERROR;\n      }\n      if (ret = updatewindow(strm, dictionary, dictLength, dictLength), ret)\n        return state.mode = MEM, Z_MEM_ERROR;\n      return state.havedict = 1, Z_OK;\n    }\n    exports.inflateReset = inflateReset, exports.inflateReset2 = inflateReset2, exports.inflateResetKeep = inflateResetKeep, exports.inflateInit = inflateInit, exports.inflateInit2 = inflateInit2, exports.inflate = inflate, exports.inflateEnd = inflateEnd, exports.inflateGetHeader = inflateGetHeader, exports.inflateSetDictionary = inflateSetDictionary, exports.inflateInfo = \"pako inflate (from Nodeca project)\";\n  }\n}), require_constants = __commonJS({\n  \"node_modules/pako/lib/zlib/constants.js\"(exports, module2) {\n    module2.exports = {\n      Z_NO_FLUSH: 0,\n      Z_PARTIAL_FLUSH: 1,\n      Z_SYNC_FLUSH: 2,\n      Z_FULL_FLUSH: 3,\n      Z_FINISH: 4,\n      Z_BLOCK: 5,\n      Z_TREES: 6,\n      Z_OK: 0,\n      Z_STREAM_END: 1,\n      Z_NEED_DICT: 2,\n      Z_ERRNO: -1,\n      Z_STREAM_ERROR: -2,\n      Z_DATA_ERROR: -3,\n      Z_BUF_ERROR: -5,\n      Z_NO_COMPRESSION: 0,\n      Z_BEST_SPEED: 1,\n      Z_BEST_COMPRESSION: 9,\n      Z_DEFAULT_COMPRESSION: -1,\n      Z_FILTERED: 1,\n      Z_HUFFMAN_ONLY: 2,\n      Z_RLE: 3,\n      Z_FIXED: 4,\n      Z_DEFAULT_STRATEGY: 0,\n      Z_BINARY: 0,\n      Z_TEXT: 1,\n      Z_UNKNOWN: 2,\n      Z_DEFLATED: 8\n    };\n  }\n}), require_binding = __commonJS({\n  \"node_modules/browserify-zlib/lib/binding.js\"(exports) {\n    var Zstream = require_zstream(), zlib_deflate = require_deflate(), zlib_inflate = require_inflate(), constants = require_constants();\n    for (key in constants)\n      exports[key] = constants[key];\n    var key;\n    exports.NONE = 0, exports.DEFLATE = 1, exports.INFLATE = 2, exports.GZIP = 3, exports.GUNZIP = 4, exports.DEFLATERAW = 5, exports.INFLATERAW = 6, exports.UNZIP = 7;\n    var GZIP_HEADER_ID1 = 31, GZIP_HEADER_ID2 = 139;\n    function Zlib(mode) {\n      if (typeof mode !== \"number\" || mode < exports.DEFLATE || mode > exports.UNZIP)\n        @throwTypeError(\"Bad argument\");\n      this.dictionary = null, this.err = 0, this.flush = 0, this.init_done = !1, this.level = 0, this.memLevel = 0, this.mode = mode, this.strategy = 0, this.windowBits = 0, this.write_in_progress = !1, this.pending_close = !1, this.gzip_id_bytes_read = 0;\n    }\n    Zlib.prototype = {}, Zlib.prototype.close = function() {\n      if (this.write_in_progress) {\n        this.pending_close = !0;\n        return;\n      }\n      if (this.pending_close = !1, assert(this.init_done, \"close before init\"), assert(this.mode <= exports.UNZIP), this.mode === exports.DEFLATE || this.mode === exports.GZIP || this.mode === exports.DEFLATERAW)\n        zlib_deflate.deflateEnd(this.strm);\n      else if (this.mode === exports.INFLATE || this.mode === exports.GUNZIP || this.mode === exports.INFLATERAW || this.mode === exports.UNZIP)\n        zlib_inflate.inflateEnd(this.strm);\n      this.mode = exports.NONE, this.dictionary = null;\n    }, Zlib.prototype.write = function(flush, input, in_off, in_len, out, out_off, out_len) {\n      return this._write(!0, flush, input, in_off, in_len, out, out_off, out_len);\n    }, Zlib.prototype.writeSync = function(flush, input, in_off, in_len, out, out_off, out_len) {\n      return this._write(!1, flush, input, in_off, in_len, out, out_off, out_len);\n    }, Zlib.prototype._write = function(async, flush, input, in_off, in_len, out, out_off, out_len) {\n      if (assert.equal(arguments.length, 8), assert(this.init_done, \"write before init\"), assert(this.mode !== exports.NONE, \"already finalized\"), assert.equal(!1, this.write_in_progress, \"write already in progress\"), assert.equal(!1, this.pending_close, \"close is pending\"), this.write_in_progress = !0, assert.equal(!1, flush === void 0, \"must provide flush value\"), this.write_in_progress = !0, flush !== exports.Z_NO_FLUSH && flush !== exports.Z_PARTIAL_FLUSH && flush !== exports.Z_SYNC_FLUSH && flush !== exports.Z_FULL_FLUSH && flush !== exports.Z_FINISH && flush !== exports.Z_BLOCK)\n        throw new Error(\"Invalid flush value\");\n      if (input == null)\n        input = Buffer.alloc(0), in_len = 0, in_off = 0;\n      if (this.strm.avail_in = in_len, this.strm.input = input, this.strm.next_in = in_off, this.strm.avail_out = out_len, this.strm.output = out, this.strm.next_out = out_off, this.flush = flush, !async) {\n        if (this._process(), this._checkError())\n          return this._afterSync();\n        return;\n      }\n      var self = this;\n      return process.nextTick(function() {\n        self._process(), self._after();\n      }), this;\n    }, Zlib.prototype._afterSync = function() {\n      var avail_out = this.strm.avail_out, avail_in = this.strm.avail_in;\n      return this.write_in_progress = !1, [avail_in, avail_out];\n    }, Zlib.prototype._process = function() {\n      var next_expected_header_byte = null;\n      switch (this.mode) {\n        case exports.DEFLATE:\n        case exports.GZIP:\n        case exports.DEFLATERAW:\n          this.err = zlib_deflate.deflate(this.strm, this.flush);\n          break;\n        case exports.UNZIP:\n          if (this.strm.avail_in > 0)\n            next_expected_header_byte = this.strm.next_in;\n          switch (this.gzip_id_bytes_read) {\n            case 0:\n              if (next_expected_header_byte === null)\n                break;\n              if (this.strm.input[next_expected_header_byte] === GZIP_HEADER_ID1) {\n                if (this.gzip_id_bytes_read = 1, next_expected_header_byte++, this.strm.avail_in === 1)\n                  break;\n              } else {\n                this.mode = exports.INFLATE;\n                break;\n              }\n            case 1:\n              if (next_expected_header_byte === null)\n                break;\n              if (this.strm.input[next_expected_header_byte] === GZIP_HEADER_ID2)\n                this.gzip_id_bytes_read = 2, this.mode = exports.GUNZIP;\n              else\n                this.mode = exports.INFLATE;\n              break;\n            default:\n              throw new Error(\"invalid number of gzip magic number bytes read\");\n          }\n        case exports.INFLATE:\n        case exports.GUNZIP:\n        case exports.INFLATERAW:\n          if (this.err = zlib_inflate.inflate(this.strm, this.flush), this.err === exports.Z_NEED_DICT && this.dictionary) {\n            if (this.err = zlib_inflate.inflateSetDictionary(this.strm, this.dictionary), this.err === exports.Z_OK)\n              this.err = zlib_inflate.inflate(this.strm, this.flush);\n            else if (this.err === exports.Z_DATA_ERROR)\n              this.err = exports.Z_NEED_DICT;\n          }\n          while (this.strm.avail_in > 0 && this.mode === exports.GUNZIP && this.err === exports.Z_STREAM_END && this.strm.next_in[0] !== 0)\n            this.reset(), this.err = zlib_inflate.inflate(this.strm, this.flush);\n          break;\n        default:\n          throw new Error(\"Unknown mode \" + this.mode);\n      }\n    }, Zlib.prototype._checkError = function() {\n      switch (this.err) {\n        case exports.Z_OK:\n        case exports.Z_BUF_ERROR:\n          if (this.strm.avail_out !== 0 && this.flush === exports.Z_FINISH)\n            return this._error(\"unexpected end of file\"), !1;\n          break;\n        case exports.Z_STREAM_END:\n          break;\n        case exports.Z_NEED_DICT:\n          if (this.dictionary == null)\n            this._error(\"Missing dictionary\");\n          else\n            this._error(\"Bad dictionary\");\n          return !1;\n        default:\n          return this._error(\"Zlib error\"), !1;\n      }\n      return !0;\n    }, Zlib.prototype._after = function() {\n      if (!this._checkError())\n        return;\n      var avail_out = this.strm.avail_out, avail_in = this.strm.avail_in;\n      if (this.write_in_progress = !1, this.callback(avail_in, avail_out), this.pending_close)\n        this.close();\n    }, Zlib.prototype._error = function(message) {\n      if (this.strm.msg)\n        message = this.strm.msg;\n      if (this.onerror(message, this.err), this.write_in_progress = !1, this.pending_close)\n        this.close();\n    }, Zlib.prototype.init = function(windowBits, level, memLevel, strategy, dictionary) {\n      assert(arguments.length === 4 || arguments.length === 5, \"init(windowBits, level, memLevel, strategy, [dictionary])\"), assert(windowBits >= 8 && windowBits <= 15, \"invalid windowBits\"), assert(level >= -1 && level <= 9, \"invalid compression level\"), assert(memLevel >= 1 && memLevel <= 9, \"invalid memlevel\"), assert(strategy === exports.Z_FILTERED || strategy === exports.Z_HUFFMAN_ONLY || strategy === exports.Z_RLE || strategy === exports.Z_FIXED || strategy === exports.Z_DEFAULT_STRATEGY, \"invalid strategy\"), this._init(level, windowBits, memLevel, strategy, dictionary), this._setDictionary();\n    }, Zlib.prototype.params = function() {\n      throw new Error(\"deflateParams Not supported\");\n    }, Zlib.prototype.reset = function() {\n      this._reset(), this._setDictionary();\n    }, Zlib.prototype._init = function(level, windowBits, memLevel, strategy, dictionary) {\n      if (this.level = level, this.windowBits = windowBits, this.memLevel = memLevel, this.strategy = strategy, this.flush = exports.Z_NO_FLUSH, this.err = exports.Z_OK, this.mode === exports.GZIP || this.mode === exports.GUNZIP)\n        this.windowBits += 16;\n      if (this.mode === exports.UNZIP)\n        this.windowBits += 32;\n      if (this.mode === exports.DEFLATERAW || this.mode === exports.INFLATERAW)\n        this.windowBits = -1 * this.windowBits;\n      switch (this.strm = new Zstream, this.mode) {\n        case exports.DEFLATE:\n        case exports.GZIP:\n        case exports.DEFLATERAW:\n          this.err = zlib_deflate.deflateInit2(this.strm, this.level, exports.Z_DEFLATED, this.windowBits, this.memLevel, this.strategy);\n          break;\n        case exports.INFLATE:\n        case exports.GUNZIP:\n        case exports.INFLATERAW:\n        case exports.UNZIP:\n          this.err = zlib_inflate.inflateInit2(this.strm, this.windowBits);\n          break;\n        default:\n          throw new Error(\"Unknown mode \" + this.mode);\n      }\n      if (this.err !== exports.Z_OK)\n        this._error(\"Init error\");\n      this.dictionary = dictionary, this.write_in_progress = !1, this.init_done = !0;\n    }, Zlib.prototype._setDictionary = function() {\n      if (this.dictionary == null)\n        return;\n      switch (this.err = exports.Z_OK, this.mode) {\n        case exports.DEFLATE:\n        case exports.DEFLATERAW:\n          this.err = zlib_deflate.deflateSetDictionary(this.strm, this.dictionary);\n          break;\n        default:\n          break;\n      }\n      if (this.err !== exports.Z_OK)\n        this._error(\"Failed to set dictionary\");\n    }, Zlib.prototype._reset = function() {\n      switch (this.err = exports.Z_OK, this.mode) {\n        case exports.DEFLATE:\n        case exports.DEFLATERAW:\n        case exports.GZIP:\n          this.err = zlib_deflate.deflateReset(this.strm);\n          break;\n        case exports.INFLATE:\n        case exports.INFLATERAW:\n        case exports.GUNZIP:\n          this.err = zlib_inflate.inflateReset(this.strm);\n          break;\n        default:\n          break;\n      }\n      if (this.err !== exports.Z_OK)\n        this._error(\"Failed to reset stream\");\n    }, exports.Zlib = Zlib;\n  }\n}), require_lib = __commonJS({\n  \"node_modules/browserify-zlib/lib/index.js\"(exports) {\n    var Buffer2 = BufferModule.Buffer, Transform = StreamModule.Transform, binding = require_binding(), util = Util, kMaxLength = BufferModule.kMaxLength, kRangeErrorMessage = \"Cannot create final Buffer. It would be larger than 0x\" + kMaxLength.toString(16) + \" bytes\";\n    binding.Z_MIN_WINDOWBITS = 8, binding.Z_MAX_WINDOWBITS = 15, binding.Z_DEFAULT_WINDOWBITS = 15, binding.Z_MIN_CHUNK = 64, binding.Z_MAX_CHUNK = Infinity, binding.Z_DEFAULT_CHUNK = 16384, binding.Z_MIN_MEMLEVEL = 1, binding.Z_MAX_MEMLEVEL = 9, binding.Z_DEFAULT_MEMLEVEL = 8, binding.Z_MIN_LEVEL = -1, binding.Z_MAX_LEVEL = 9, binding.Z_DEFAULT_LEVEL = binding.Z_DEFAULT_COMPRESSION;\n    var bkeys = Object.keys(binding);\n    for (bk = 0;bk < bkeys.length; bk++)\n      if (bkey = bkeys[bk], bkey.match(/^Z/))\n        Object.defineProperty(exports, bkey, {\n          enumerable: !0,\n          value: binding[bkey],\n          writable: !1\n        });\n    var bkey, bk, codes = {\n      Z_OK: binding.Z_OK,\n      Z_STREAM_END: binding.Z_STREAM_END,\n      Z_NEED_DICT: binding.Z_NEED_DICT,\n      Z_ERRNO: binding.Z_ERRNO,\n      Z_STREAM_ERROR: binding.Z_STREAM_ERROR,\n      Z_DATA_ERROR: binding.Z_DATA_ERROR,\n      Z_MEM_ERROR: binding.Z_MEM_ERROR,\n      Z_BUF_ERROR: binding.Z_BUF_ERROR,\n      Z_VERSION_ERROR: binding.Z_VERSION_ERROR\n    }, ckeys = Object.keys(codes);\n    for (ck = 0;ck < ckeys.length; ck++)\n      ckey = ckeys[ck], codes[codes[ckey]] = ckey;\n    var ckey, ck;\n    Object.defineProperty(exports, \"codes\", {\n      enumerable: !0,\n      value: Object.freeze(codes),\n      writable: !1\n    }), exports.constants = require_constants(), exports.Deflate = Deflate, exports.Inflate = Inflate, exports.Gzip = Gzip, exports.Gunzip = Gunzip, exports.DeflateRaw = DeflateRaw, exports.InflateRaw = InflateRaw, exports.Unzip = Unzip, exports.createDeflate = function(o) {\n      return new Deflate(o);\n    }, exports.createInflate = function(o) {\n      return new Inflate(o);\n    }, exports.createDeflateRaw = function(o) {\n      return new DeflateRaw(o);\n    }, exports.createInflateRaw = function(o) {\n      return new InflateRaw(o);\n    }, exports.createGzip = function(o) {\n      return new Gzip(o);\n    }, exports.createGunzip = function(o) {\n      return new Gunzip(o);\n    }, exports.createUnzip = function(o) {\n      return new Unzip(o);\n    }, exports.deflate = function(buffer, opts, callback) {\n      if (typeof opts === \"function\")\n        callback = opts, opts = {};\n      return zlibBuffer(new Deflate(opts), buffer, callback);\n    }, exports.deflateSync = function(buffer, opts) {\n      return zlibBufferSync(new Deflate(opts), buffer);\n    }, exports.gzip = function(buffer, opts, callback) {\n      if (typeof opts === \"function\")\n        callback = opts, opts = {};\n      return zlibBuffer(new Gzip(opts), buffer, callback);\n    }, exports.gzipSync = function(buffer, opts) {\n      return zlibBufferSync(new Gzip(opts), buffer);\n    }, exports.deflateRaw = function(buffer, opts, callback) {\n      if (typeof opts === \"function\")\n        callback = opts, opts = {};\n      return zlibBuffer(new DeflateRaw(opts), buffer, callback);\n    }, exports.deflateRawSync = function(buffer, opts) {\n      return zlibBufferSync(new DeflateRaw(opts), buffer);\n    }, exports.unzip = function(buffer, opts, callback) {\n      if (typeof opts === \"function\")\n        callback = opts, opts = {};\n      return zlibBuffer(new Unzip(opts), buffer, callback);\n    }, exports.unzipSync = function(buffer, opts) {\n      return zlibBufferSync(new Unzip(opts), buffer);\n    }, exports.inflate = function(buffer, opts, callback) {\n      if (typeof opts === \"function\")\n        callback = opts, opts = {};\n      return zlibBuffer(new Inflate(opts), buffer, callback);\n    }, exports.inflateSync = function(buffer, opts) {\n      return zlibBufferSync(new Inflate(opts), buffer);\n    }, exports.gunzip = function(buffer, opts, callback) {\n      if (typeof opts === \"function\")\n        callback = opts, opts = {};\n      return zlibBuffer(new Gunzip(opts), buffer, callback);\n    }, exports.gunzipSync = function(buffer, opts) {\n      return zlibBufferSync(new Gunzip(opts), buffer);\n    }, exports.inflateRaw = function(buffer, opts, callback) {\n      if (typeof opts === \"function\")\n        callback = opts, opts = {};\n      return zlibBuffer(new InflateRaw(opts), buffer, callback);\n    }, exports.inflateRawSync = function(buffer, opts) {\n      return zlibBufferSync(new InflateRaw(opts), buffer);\n    }, exports.brotliCompress = function(buffer, opts, callback) {\n      throw new Error(\"zlib.brotliCompress is not implemented\");\n    };\n    function zlibBuffer(engine, buffer, callback) {\n      var buffers = [], nread = 0;\n      engine.on(\"error\", onError), engine.on(\"end\", onEnd), engine.end(buffer), flow();\n      function flow() {\n        var chunk;\n        while ((chunk = engine.read()) !== null)\n          buffers.push(chunk), nread += chunk.length;\n        engine.once(\"readable\", flow);\n      }\n      function onError(err) {\n        engine.removeListener(\"end\", onEnd), engine.removeListener(\"readable\", flow), callback(err);\n      }\n      function onEnd() {\n        var buf, err = null;\n        if (nread >= kMaxLength)\n          err = new RangeError(kRangeErrorMessage);\n        else\n          buf = Buffer2.concat(buffers, nread);\n        buffers = [], engine.close(), callback(err, buf);\n      }\n    }\n    function zlibBufferSync(engine, buffer) {\n      if (typeof buffer === \"string\")\n        buffer = Buffer2.from(buffer);\n      if (!Buffer2.isBuffer(buffer))\n        @throwTypeError(\"Not a string or buffer\");\n      var flushFlag = engine._finishFlushFlag;\n      return engine._processChunk(buffer, flushFlag);\n    }\n    function Deflate(opts) {\n      if (!(this instanceof Deflate))\n        return new Deflate(opts);\n      Zlib.call(this, opts, binding.DEFLATE);\n    }\n    function Inflate(opts) {\n      if (!(this instanceof Inflate))\n        return new Inflate(opts);\n      Zlib.call(this, opts, binding.INFLATE);\n    }\n    function Gzip(opts) {\n      if (!(this instanceof Gzip))\n        return new Gzip(opts);\n      Zlib.call(this, opts, binding.GZIP);\n    }\n    function Gunzip(opts) {\n      if (!(this instanceof Gunzip))\n        return new Gunzip(opts);\n      Zlib.call(this, opts, binding.GUNZIP);\n    }\n    function DeflateRaw(opts) {\n      if (!(this instanceof DeflateRaw))\n        return new DeflateRaw(opts);\n      Zlib.call(this, opts, binding.DEFLATERAW);\n    }\n    function InflateRaw(opts) {\n      if (!(this instanceof InflateRaw))\n        return new InflateRaw(opts);\n      Zlib.call(this, opts, binding.INFLATERAW);\n    }\n    function Unzip(opts) {\n      if (!(this instanceof Unzip))\n        return new Unzip(opts);\n      Zlib.call(this, opts, binding.UNZIP);\n    }\n    function isValidFlushFlag(flag) {\n      return flag === binding.Z_NO_FLUSH || flag === binding.Z_PARTIAL_FLUSH || flag === binding.Z_SYNC_FLUSH || flag === binding.Z_FULL_FLUSH || flag === binding.Z_FINISH || flag === binding.Z_BLOCK;\n    }\n    function Zlib(opts, mode) {\n      var _this = this;\n      if (this._opts = opts = opts || {}, this._chunkSize = opts.chunkSize || exports.Z_DEFAULT_CHUNK, Transform.call(this, opts), opts.flush && !isValidFlushFlag(opts.flush))\n        throw new Error(\"Invalid flush flag: \" + opts.flush);\n      if (opts.finishFlush && !isValidFlushFlag(opts.finishFlush))\n        throw new Error(\"Invalid flush flag: \" + opts.finishFlush);\n      if (this._flushFlag = opts.flush || binding.Z_NO_FLUSH, this._finishFlushFlag = typeof opts.finishFlush !== \"undefined\" \? opts.finishFlush : binding.Z_FINISH, opts.chunkSize) {\n        if (opts.chunkSize < exports.Z_MIN_CHUNK || opts.chunkSize > exports.Z_MAX_CHUNK)\n          throw new Error(\"Invalid chunk size: \" + opts.chunkSize);\n      }\n      if (opts.windowBits) {\n        if (opts.windowBits < exports.Z_MIN_WINDOWBITS || opts.windowBits > exports.Z_MAX_WINDOWBITS)\n          throw new Error(\"Invalid windowBits: \" + opts.windowBits);\n      }\n      if (opts.level) {\n        if (opts.level < exports.Z_MIN_LEVEL || opts.level > exports.Z_MAX_LEVEL)\n          throw new Error(\"Invalid compression level: \" + opts.level);\n      }\n      if (opts.memLevel) {\n        if (opts.memLevel < exports.Z_MIN_MEMLEVEL || opts.memLevel > exports.Z_MAX_MEMLEVEL)\n          throw new Error(\"Invalid memLevel: \" + opts.memLevel);\n      }\n      if (opts.strategy) {\n        if (opts.strategy != exports.Z_FILTERED && opts.strategy != exports.Z_HUFFMAN_ONLY && opts.strategy != exports.Z_RLE && opts.strategy != exports.Z_FIXED && opts.strategy != exports.Z_DEFAULT_STRATEGY)\n          throw new Error(\"Invalid strategy: \" + opts.strategy);\n      }\n      if (opts.dictionary) {\n        if (!Buffer2.isBuffer(opts.dictionary))\n          throw new Error(\"Invalid dictionary: it should be a Buffer instance\");\n      }\n      this._handle = new binding.Zlib(mode);\n      var self = this;\n      this._hadError = !1, this._handle.onerror = function(message, errno) {\n        _close(self), self._hadError = !0;\n        var error = new Error(message);\n        error.errno = errno, error.code = exports.codes[errno], self.emit(\"error\", error);\n      };\n      var level = exports.Z_DEFAULT_COMPRESSION;\n      if (typeof opts.level === \"number\")\n        level = opts.level;\n      var strategy = exports.Z_DEFAULT_STRATEGY;\n      if (typeof opts.strategy === \"number\")\n        strategy = opts.strategy;\n      this._handle.init(opts.windowBits || exports.Z_DEFAULT_WINDOWBITS, level, opts.memLevel || exports.Z_DEFAULT_MEMLEVEL, strategy, opts.dictionary), this._buffer = Buffer2.allocUnsafe(this._chunkSize), this._offset = 0, this._level = level, this._strategy = strategy, this.once(\"end\", this.close), Object.defineProperty(this, \"_closed\", {\n        get: function() {\n          return !_this._handle;\n        },\n        configurable: !0,\n        enumerable: !0\n      });\n    }\n    util.inherits(Zlib, Transform), Zlib.prototype.params = function(level, strategy, callback) {\n      if (level < exports.Z_MIN_LEVEL || level > exports.Z_MAX_LEVEL)\n        @throwRangeError(\"Invalid compression level: \" + level);\n      if (strategy != exports.Z_FILTERED && strategy != exports.Z_HUFFMAN_ONLY && strategy != exports.Z_RLE && strategy != exports.Z_FIXED && strategy != exports.Z_DEFAULT_STRATEGY)\n        @throwTypeError(\"Invalid strategy: \" + strategy);\n      if (this._level !== level || this._strategy !== strategy) {\n        var self = this;\n        this.flush(binding.Z_SYNC_FLUSH, function() {\n          if (assert(self._handle, \"zlib binding closed\"), self._handle.params(level, strategy), !self._hadError) {\n            if (self._level = level, self._strategy = strategy, callback)\n              callback();\n          }\n        });\n      } else\n        process.nextTick(callback);\n    }, Zlib.prototype.reset = function() {\n      return assert(this._handle, \"zlib binding closed\"), this._handle.reset();\n    }, Zlib.prototype._flush = function(callback) {\n      this._transform(Buffer2.alloc(0), \"\", callback);\n    }, Zlib.prototype.flush = function(kind, callback) {\n      var _this2 = this, ws = this._writableState;\n      if (typeof kind === \"function\" || kind === void 0 && !callback)\n        callback = kind, kind = binding.Z_FULL_FLUSH;\n      if (ws.ended) {\n        if (callback)\n          process.nextTick(callback);\n      } else if (ws.ending) {\n        if (callback)\n          this.once(\"end\", callback);\n      } else if (ws.needDrain) {\n        if (callback)\n          this.once(\"drain\", function() {\n            return _this2.flush(kind, callback);\n          });\n      } else\n        this._flushFlag = kind, this.write(Buffer2.alloc(0), \"\", callback);\n    }, Zlib.prototype.close = function(callback) {\n      _close(this, callback), process.nextTick(emitCloseNT, this);\n    };\n    function _close(engine, callback) {\n      if (callback)\n        process.nextTick(callback);\n      if (!engine._handle)\n        return;\n      engine._handle.close(), engine._handle = null;\n    }\n    function emitCloseNT(self) {\n      self.emit(\"close\");\n    }\n    Zlib.prototype._transform = function(chunk, encoding, cb) {\n      var flushFlag, ws = this._writableState, ending = ws.ending || ws.ended, last = ending && (!chunk || ws.length === chunk.length);\n      if (chunk !== null && !Buffer2.isBuffer(chunk))\n        return cb(new Error(\"invalid input\"));\n      if (!this._handle)\n        return cb(new Error(\"zlib binding closed\"));\n      if (last)\n        flushFlag = this._finishFlushFlag;\n      else if (flushFlag = this._flushFlag, chunk.length >= ws.length)\n        this._flushFlag = this._opts.flush || binding.Z_NO_FLUSH;\n      this._processChunk(chunk, flushFlag, cb);\n    }, Zlib.prototype._processChunk = function(chunk, flushFlag, cb) {\n      var availInBefore = chunk && chunk.length, availOutBefore = this._chunkSize - this._offset, inOff = 0, self = this, async = typeof cb === \"function\";\n      if (!async) {\n        var buffers = [], nread = 0, error;\n        this.on(\"error\", function(er) {\n          error = er;\n        }), assert(this._handle, \"zlib binding closed\");\n        do\n          var res = this._handle.writeSync(flushFlag, chunk, inOff, availInBefore, this._buffer, this._offset, availOutBefore);\n        while (!this._hadError && callback(res[0], res[1]));\n        if (this._hadError)\n          throw error;\n        if (nread >= kMaxLength)\n          _close(this), @throwRangeError(kRangeErrorMessage);\n        var buf = Buffer2.concat(buffers, nread);\n        return _close(this), buf;\n      }\n      assert(this._handle, \"zlib binding closed\");\n      var req = this._handle.write(flushFlag, chunk, inOff, availInBefore, this._buffer, this._offset, availOutBefore);\n      req.buffer = chunk, req.callback = callback;\n      function callback(availInAfter, availOutAfter) {\n        if (this)\n          this.buffer = null, this.callback = null;\n        if (self._hadError)\n          return;\n        var have = availOutBefore - availOutAfter;\n        if (assert(have >= 0, \"have should not go down\"), have > 0) {\n          var out = self._buffer.slice(self._offset, self._offset + have);\n          if (self._offset += have, async)\n            self.push(out);\n          else\n            buffers.push(out), nread += out.length;\n        }\n        if (availOutAfter === 0 || self._offset >= self._chunkSize)\n          availOutBefore = self._chunkSize, self._offset = 0, self._buffer = Buffer2.allocUnsafe(self._chunkSize);\n        if (availOutAfter === 0) {\n          if (inOff += availInBefore - availInAfter, availInBefore = availInAfter, !async)\n            return !0;\n          var newReq = self._handle.write(flushFlag, chunk, inOff, availInBefore, self._buffer, self._offset, self._chunkSize);\n          newReq.callback = callback, newReq.buffer = chunk;\n          return;\n        }\n        if (!async)\n          return !1;\n        cb();\n      }\n    }, util.inherits(Deflate, Zlib), util.inherits(Inflate, Zlib), util.inherits(Gzip, Zlib), util.inherits(Gunzip, Zlib), util.inherits(DeflateRaw, Zlib), util.inherits(InflateRaw, Zlib), util.inherits(Unzip, Zlib);\n  }\n});\nreturn require_lib()})\n"_s;
//

//
static constexpr ASCIILiteral ThirdpartyDepdCode = "(function (){\"use strict\";// src/js/out/tmp/thirdparty/depd.ts\nvar wrapfunction = function(fn, message) {\n  if (typeof fn !== \"function\")\n    @throwTypeError(\"argument fn must be a function\");\n  return fn;\n}, wrapproperty = function(obj, prop, message) {\n  if (!obj || typeof obj !== \"object\" && typeof obj !== \"function\")\n    @throwTypeError(\"argument obj must be object\");\n  var descriptor = Object.getOwnPropertyDescriptor(obj, prop);\n  if (!descriptor)\n    @throwTypeError(\"must call property on owner object\");\n  if (!descriptor.configurable)\n    @throwTypeError(\"property must be configurable\");\n}, $;\n$ = function depd(namespace) {\n  if (!namespace)\n    @throwTypeError(\"argument namespace is required\");\n  function deprecate(message) {\n  }\n  return deprecate._file = void 0, deprecate._ignored = !0, deprecate._namespace = namespace, deprecate._traced = !1, deprecate._warned = Object.create(null), deprecate.function = wrapfunction, deprecate.property = wrapproperty, deprecate;\n};\nreturn $})\n"_s;
//

//
static constexpr ASCIILiteral ThirdpartyDetectLibcCode = "(function (){\"use strict\";// src/js/out/tmp/thirdparty/detect-libc.ts\nvar family = function() {\n  return Promise.resolve(familySync());\n}, familySync = function() {\n  return null;\n}, versionAsync = function() {\n  return Promise.resolve(version());\n}, version = function() {\n  return null;\n}, isNonGlibcLinuxSync = function() {\n  return !1;\n}, isNonGlibcLinux = function() {\n  return Promise.resolve(isNonGlibcLinuxSync());\n}, $, GLIBC = \"glibc\", MUSL = \"musl\";\n$ = {\n  GLIBC,\n  MUSL,\n  family,\n  familySync,\n  isNonGlibcLinux,\n  isNonGlibcLinuxSync,\n  version,\n  versionAsync\n};\nreturn $})\n"_s;
//

//
static constexpr ASCIILiteral ThirdpartyDetectLibcLinuxCode = "(function (){\"use strict\";// src/js/out/tmp/thirdparty/detect-libc.linux.ts\nvar family = function() {\n  return Promise.resolve(familySync());\n}, familySync = function() {\n  return GLIBC;\n}, versionAsync = function() {\n  return Promise.resolve(version());\n}, version = function() {\n  return \"2.29\";\n}, isNonGlibcLinuxSync = function() {\n  return !1;\n}, isNonGlibcLinux = function() {\n  return Promise.resolve(isNonGlibcLinuxSync());\n}, $, GLIBC = \"glibc\", MUSL = \"musl\";\n$ = {\n  GLIBC,\n  MUSL,\n  family,\n  familySync,\n  isNonGlibcLinux,\n  isNonGlibcLinuxSync,\n  version,\n  versionAsync\n};\nreturn $})\n"_s;
//

//
static constexpr ASCIILiteral ThirdpartyIsomorphicFetchCode = "(function (){\"use strict\";// src/js/out/tmp/thirdparty/isomorphic-fetch.ts\nvar bunFetch = Bun.fetch, fetch = (...args) => bunFetch(...args);\nfetch.default = fetch;\nfetch.fetch = fetch;\nreturn fetch})\n"_s;
//

//
static constexpr ASCIILiteral ThirdpartyNodeFetchCode = "(function (){\"use strict\";// src/js/out/tmp/thirdparty/node-fetch.ts\nvar fetch = function(...args) {\n  return realFetch(...args);\n}, blobFrom = function(path, options) {\n  return Promise.resolve(Bun.file(data));\n}, blobFromSync = function(path, options) {\n  return Bun.file(data);\n}, isRedirect = function(code) {\n  return code === 301 || code === 302 || code === 303 || code === 307 || code === 308;\n}, $, { Headers, Request, Response, Blob, File = Blob, FormData } = globalThis, realFetch = Bun.fetch;\n\nclass AbortError extends DOMException {\n  constructor(message) {\n    super(message, \"AbortError\");\n  }\n}\n\nclass FetchBaseError extends Error {\n  constructor(message, type) {\n    super(message);\n    this.type = type;\n  }\n}\n\nclass FetchError extends FetchBaseError {\n  constructor(message, type, systemError) {\n    super(message, type);\n    this.code = systemError\?.code;\n  }\n}\nvar fileFrom = blobFrom, fileFromSync = blobFromSync;\n$ = Object.assign(fetch, {\n  AbortError,\n  Blob,\n  FetchBaseError,\n  FetchError,\n  File,\n  FormData,\n  Headers,\n  Request,\n  Response,\n  blobFrom,\n  blobFromSync,\n  fileFrom,\n  fileFromSync,\n  isRedirect,\n  fetch,\n  default: fetch\n});\nreturn $})\n"_s;
//

//
static constexpr ASCIILiteral ThirdpartyUndiciCode = "(function (){\"use strict\";// src/js/out/tmp/thirdparty/undici.ts\nvar notImplemented = function() {\n  throw new Error(\"Not implemented in bun\");\n};\nasync function request(url, options = {\n  method: \"GET\",\n  signal: null,\n  headers: null,\n  query: null,\n  reset: !1,\n  throwOnError: !1,\n  body: null\n}) {\n  let {\n    method = \"GET\",\n    headers: inputHeaders,\n    query,\n    signal,\n    reset = !1,\n    throwOnError = !1,\n    body: inputBody,\n    maxRedirections\n  } = options;\n  if (typeof url === \"string\") {\n    if (query)\n      url = new URL(url);\n  } else if (typeof url === \"object\" && url !== null) {\n    if (!(url instanceof URL))\n      throw new Error(\"not implemented\");\n  } else\n    @throwTypeError(\"url must be a string, URL, or UrlObject\");\n  if (typeof url === \"string\" && query)\n    url = new URL(url);\n  if (typeof url === \"object\" && url !== null && query) {\n    if (query)\n      url.search = new URLSearchParams(query).toString();\n  }\n  if (method = method && typeof method === \"string\" \? method.toUpperCase() : null, inputBody && (method === \"GET\" || method === \"HEAD\"))\n    throw new Error(\"Body not allowed for GET or HEAD requests\");\n  if (inputBody && inputBody.read && inputBody instanceof Readable) {\n    let data = \"\";\n    inputBody.setEncoding(\"utf8\");\n    for await (let chunk of stream)\n      data += chunk;\n    inputBody = (new TextEncoder()).encode(data);\n  }\n  if (maxRedirections !== void 0 && Number.isNaN(maxRedirections))\n    throw new Error(\"maxRedirections must be a number if defined\");\n  if (signal && !(signal instanceof AbortSignal))\n    throw new Error(\"signal must be an instance of AbortSignal\");\n  let resp;\n  const {\n    status: statusCode,\n    headers,\n    trailers\n  } = resp = await fetch(url, {\n    signal,\n    mode: \"cors\",\n    method,\n    headers: inputHeaders || kEmptyObject,\n    body: inputBody,\n    redirect: maxRedirections === \"undefined\" || maxRedirections > 0 \? \"follow\" : \"manual\",\n    keepalive: !reset\n  });\n  if (throwOnError && statusCode >= 400 && statusCode < 600)\n    throw new Error(`Request failed with status code ${statusCode}`);\n  const body = resp.body \? new BodyReadable(resp) : null;\n  return { statusCode, headers: headers.toJSON(), body, trailers, opaque: kEmptyObject, context: kEmptyObject };\n}\nvar stream = function() {\n  throw new Error(\"Not implemented in bun\");\n}, pipeline = function() {\n  throw new Error(\"Not implemented in bun\");\n}, connect = function() {\n  throw new Error(\"Not implemented in bun\");\n}, upgrade = function() {\n  throw new Error(\"Not implemented in bun\");\n}, mockErrors = function() {\n  throw new Error(\"Not implemented in bun\");\n}, Undici = function() {\n  throw new Error(\"Not implemented in bun\");\n}, $, EventEmitter = @getInternalField(@internalModuleRegistry, 16) || @createInternalModuleById(16), StreamModule = @getInternalField(@internalModuleRegistry, 35) || @createInternalModuleById(35), { Readable } = StreamModule, { _ReadableFromWebForUndici: ReadableFromWeb } = StreamModule[Symbol.for(\"::bunternal::\")], ObjectCreate = Object.create, kEmptyObject = ObjectCreate(null), fetch = Bun.fetch, Response = globalThis.Response, Headers = globalThis.Headers, Request = globalThis.Request, URLSearchParams = globalThis.URLSearchParams, URL = globalThis.URL;\n\nclass File extends Blob {\n  constructor() {\n    super(...arguments);\n  }\n}\n\nclass FileReader extends EventTarget {\n  constructor() {\n    throw new Error(\"Not implemented yet!\");\n  }\n}\nvar FormData = globalThis.FormData;\n\nclass BodyReadable extends ReadableFromWeb {\n  #response;\n  #bodyUsed;\n  constructor(response, options = {}) {\n    var { body } = response;\n    if (!body)\n      throw new Error(\"Response body is null\");\n    super(options, body);\n    this.#response = response, this.#bodyUsed = response.bodyUsed;\n  }\n  get bodyUsed() {\n    return this.#bodyUsed;\n  }\n  #consume() {\n    if (this.#bodyUsed)\n      @throwTypeError(\"unusable\");\n    this.#bodyUsed = !0;\n  }\n  async arrayBuffer() {\n    return this.#consume(), await this.#response.arrayBuffer();\n  }\n  async blob() {\n    return this.#consume(), await this.#response.blob();\n  }\n  async formData() {\n    return this.#consume(), await this.#response.formData();\n  }\n  async json() {\n    return this.#consume(), await this.#response.json();\n  }\n  async text() {\n    return this.#consume(), await this.#response.text();\n  }\n}\n\nclass MockClient {\n  constructor() {\n    throw new Error(\"Not implemented in bun\");\n  }\n}\n\nclass MockPool {\n  constructor() {\n    throw new Error(\"Not implemented in bun\");\n  }\n}\n\nclass MockAgent {\n  constructor() {\n    throw new Error(\"Not implemented in bun\");\n  }\n}\n\nclass Dispatcher extends EventEmitter {\n  constructor() {\n    super(...arguments);\n  }\n}\n\nclass Agent extends Dispatcher {\n  constructor() {\n    super(...arguments);\n  }\n}\n\nclass Pool extends Dispatcher {\n  constructor() {\n    super(...arguments);\n  }\n  request() {\n    throw new Error(\"Not implemented in bun\");\n  }\n}\n\nclass BalancedPool extends Dispatcher {\n  constructor() {\n    super(...arguments);\n  }\n}\n\nclass Client extends Dispatcher {\n  constructor() {\n    super(...arguments);\n  }\n  request() {\n    throw new Error(\"Not implemented in bun\");\n  }\n}\nUndici.Dispatcher = Dispatcher;\nUndici.Pool = Pool;\nUndici.BalancedPool = BalancedPool;\nUndici.Client = Client;\nUndici.Agent = Agent;\nUndici.buildConnector = Undici.errors = Undici.setGlobalDispatcher = Undici.getGlobalDispatcher = Undici.request = Undici.stream = Undici.pipeline = Undici.connect = Undici.upgrade = Undici.MockClient = Undici.MockPool = Undici.MockAgent = Undici.mockErrors = notImplemented;\nUndici.fetch = fetch;\n$ = {\n  fetch,\n  Response,\n  Headers,\n  Request,\n  URLSearchParams,\n  URL,\n  File,\n  FileReader,\n  FormData,\n  request,\n  stream,\n  pipeline,\n  connect,\n  upgrade,\n  MockClient,\n  MockPool,\n  MockAgent,\n  mockErrors,\n  Dispatcher,\n  Pool,\n  BalancedPool,\n  Client,\n  Agent,\n  Undici\n};\nreturn $})\n"_s;
//

//
static constexpr ASCIILiteral ThirdpartyVercelFetchCode = "(function (){\"use strict\";// src/js/out/tmp/thirdparty/vercel_fetch.ts\nvar $;\n$ = (wrapper = Bun.fetch) => {\n  async function vercelFetch(url, opts = {}) {\n    if (opts.body && typeof opts.body === \"object\" && (!(\"buffer\" in opts.body) || typeof opts.body.buffer !== \"object\" || !(opts.body.buffer instanceof ArrayBuffer))) {\n      if (opts.body = JSON.stringify(opts.body), !opts.headers)\n        opts.headers = new Headers;\n      opts.headers.set(\"Content-Type\", \"application/json\");\n    }\n    try {\n      return await wrapper(url, opts);\n    } catch (err) {\n      if (typeof err === \"string\")\n        err = new Error(err);\n      throw err.url = url, err.opts = opts, err;\n    }\n  }\n  return vercelFetch.default = vercelFetch, vercelFetch;\n};\nreturn $})\n"_s;
//

//
static constexpr ASCIILiteral ThirdpartyWSCode = "(function (){\"use strict\";// src/js/out/tmp/thirdparty/ws.ts\nvar emitWarning = function(type, message) {\n  if (emittedWarnings.has(type))\n    return;\n  emittedWarnings.add(type), console.warn(\"[bun] Warning:\", message);\n}, subprotocolParse = function(header) {\n  const protocols = new Set;\n  let start = -1, end = -1, i = 0;\n  for (i;i < header.length; i++) {\n    const code = header.charCodeAt(i);\n    if (end === -1 && wsTokenChars[code] === 1) {\n      if (start === -1)\n        start = i;\n    } else if (i !== 0 && (code === 32 || code === 9)) {\n      if (end === -1 && start !== -1)\n        end = i;\n    } else if (code === 44) {\n      if (start === -1)\n        throw new SyntaxError(`Unexpected character at index ${i}`);\n      if (end === -1)\n        end = i;\n      const protocol2 = header.slice(start, end);\n      if (protocols.has(protocol2))\n        throw new SyntaxError(`The \"${protocol2}\" subprotocol is duplicated`);\n      protocols.add(protocol2), start = end = -1;\n    } else\n      throw new SyntaxError(`Unexpected character at index ${i}`);\n  }\n  if (start === -1 || end !== -1)\n    throw new SyntaxError(\"Unexpected end of input\");\n  const protocol = header.slice(start, i);\n  if (protocols.has(protocol))\n    throw new SyntaxError(`The \"${protocol}\" subprotocol is duplicated`);\n  return protocols.add(protocol), protocols;\n}, wsEmitClose = function(server) {\n  server._state = CLOSED, server.emit(\"close\");\n}, abortHandshake = function(response, code, message, headers) {\n  message = message || http.STATUS_CODES[code], headers = {\n    Connection: \"close\",\n    \"Content-Type\": \"text/html\",\n    \"Content-Length\": Buffer.byteLength(message),\n    ...headers\n  }, response.writeHead(code, headers), response.write(message), response.end();\n}, abortHandshakeOrEmitwsClientError = function(server, req, response, socket, code, message) {\n  if (server.listenerCount(\"wsClientError\")) {\n    const err = new Error(message);\n    Error.captureStackTrace(err, abortHandshakeOrEmitwsClientError), server.emit(\"wsClientError\", err, socket, req);\n  } else\n    abortHandshake(response, code, message);\n}, $, EventEmitter = @getInternalField(@internalModuleRegistry, 16) || @createInternalModuleById(16), http = @getInternalField(@internalModuleRegistry, 19) || @createInternalModuleById(19), kBunInternals = Symbol.for(\"::bunternal::\"), readyStates = [\"CONNECTING\", \"OPEN\", \"CLOSING\", \"CLOSED\"], encoder = new TextEncoder, eventIds = {\n  open: 1,\n  close: 2,\n  message: 3,\n  error: 4,\n  ping: 5,\n  pong: 6\n}, emittedWarnings = new Set;\n\nclass BunWebSocket extends EventEmitter {\n  static CONNECTING = 0;\n  static OPEN = 1;\n  static CLOSING = 2;\n  static CLOSED = 3;\n  #ws;\n  #paused = !1;\n  #fragments = !1;\n  #binaryType = \"nodebuffer\";\n  #eventId = 0;\n  constructor(url, protocols, options) {\n    super();\n    let ws = this.#ws = new WebSocket(url, protocols);\n    ws.binaryType = \"nodebuffer\";\n  }\n  on(event, listener) {\n    if (event === \"unexpected-response\" || event === \"upgrade\" || event === \"redirect\")\n      emitWarning(event, \"ws.WebSocket '\" + event + \"' event is not implemented in bun\");\n    const mask = 1 << eventIds[event];\n    if (mask && (this.#eventId & mask) !== mask) {\n      if (this.#eventId |= mask, event === \"open\")\n        this.#ws.addEventListener(\"open\", () => {\n          this.emit(\"open\");\n        });\n      else if (event === \"close\")\n        this.#ws.addEventListener(\"close\", ({ code, reason, wasClean }) => {\n          this.emit(\"close\", code, reason, wasClean);\n        });\n      else if (event === \"message\")\n        this.#ws.addEventListener(\"message\", ({ data }) => {\n          const isBinary = typeof data !== \"string\";\n          if (isBinary)\n            this.emit(\"message\", this.#fragments \? [data] : data, isBinary);\n          else {\n            let encoded = encoder.encode(data);\n            if (this.#binaryType !== \"arraybuffer\")\n              encoded = Buffer.from(encoded.buffer, encoded.byteOffset, encoded.byteLength);\n            this.emit(\"message\", this.#fragments \? [encoded] : encoded, isBinary);\n          }\n        });\n      else if (event === \"error\")\n        this.#ws.addEventListener(\"error\", (err) => {\n          this.emit(\"error\", err);\n        });\n      else if (event === \"ping\")\n        this.#ws.addEventListener(\"ping\", ({ data }) => {\n          this.emit(\"ping\", data);\n        });\n      else if (event === \"pong\")\n        this.#ws.addEventListener(\"pong\", ({ data }) => {\n          this.emit(\"pong\", data);\n        });\n    }\n    return super.on(event, listener);\n  }\n  send(data, opts, cb) {\n    try {\n      this.#ws.send(data, opts\?.compress);\n    } catch (error) {\n      typeof cb === \"function\" && cb(error);\n      return;\n    }\n    typeof cb === \"function\" && cb();\n  }\n  close(code, reason) {\n    this.#ws.close(code, reason);\n  }\n  terminate() {\n    this.#ws.terminate();\n  }\n  get url() {\n    return this.#ws.url;\n  }\n  get readyState() {\n    return this.#ws.readyState;\n  }\n  get binaryType() {\n    return this.#binaryType;\n  }\n  set binaryType(value) {\n    if (value === \"nodebuffer\" || value === \"arraybuffer\")\n      this.#ws.binaryType = this.#binaryType = value, this.#fragments = !1;\n    else if (value === \"fragments\")\n      this.#ws.binaryType = \"nodebuffer\", this.#binaryType = \"fragments\", this.#fragments = !0;\n    else\n      throw new Error(`Invalid binaryType: ${value}`);\n  }\n  get protocol() {\n    return this.#ws.protocol;\n  }\n  get extensions() {\n    return this.#ws.extensions;\n  }\n  addEventListener(type, listener, options) {\n    this.#ws.addEventListener(type, listener, options);\n  }\n  removeEventListener(type, listener) {\n    this.#ws.removeEventListener(type, listener);\n  }\n  get onopen() {\n    return this.#ws.onopen;\n  }\n  set onopen(value) {\n    this.#ws.onopen = value;\n  }\n  get onerror() {\n    return this.#ws.onerror;\n  }\n  set onerror(value) {\n    this.#ws.onerror = value;\n  }\n  get onclose() {\n    return this.#ws.onclose;\n  }\n  set onclose(value) {\n    this.#ws.onclose = value;\n  }\n  get onmessage() {\n    return this.#ws.onmessage;\n  }\n  set onmessage(value) {\n    this.#ws.onmessage = value;\n  }\n  get bufferedAmount() {\n    return this.#ws.bufferedAmount;\n  }\n  get isPaused() {\n    return this.#paused;\n  }\n  ping(data, mask, cb) {\n    if (typeof data === \"function\")\n      cb = data, data = mask = void 0;\n    else if (typeof mask === \"function\")\n      cb = mask, mask = void 0;\n    if (typeof data === \"number\")\n      data = data.toString();\n    try {\n      this.#ws.ping(data);\n    } catch (error) {\n      typeof cb === \"function\" && cb(error);\n      return;\n    }\n    typeof cb === \"function\" && cb();\n  }\n  pong(data, mask, cb) {\n    if (typeof data === \"function\")\n      cb = data, data = mask = void 0;\n    else if (typeof mask === \"function\")\n      cb = mask, mask = void 0;\n    if (typeof data === \"number\")\n      data = data.toString();\n    try {\n      this.#ws.pong(data);\n    } catch (error) {\n      typeof cb === \"function\" && cb(error);\n      return;\n    }\n    typeof cb === \"function\" && cb();\n  }\n  pause() {\n    switch (this.readyState) {\n      case WebSocket.CONNECTING:\n      case WebSocket.CLOSED:\n        return;\n    }\n    this.#paused = !0, emitWarning(\"pause()\", \"ws.WebSocket.pause() is not implemented in bun\");\n  }\n  resume() {\n    switch (this.readyState) {\n      case WebSocket.CONNECTING:\n      case WebSocket.CLOSED:\n        return;\n    }\n    this.#paused = !1, emitWarning(\"resume()\", \"ws.WebSocket.resume() is not implemented in bun\");\n  }\n}\nObject.defineProperty(BunWebSocket, \"name\", { value: \"WebSocket\" });\nvar wsKeyRegex = /^[+/0-9A-Za-z]{22}==$/, wsTokenChars = [\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  1,\n  0,\n  1,\n  1,\n  1,\n  1,\n  1,\n  0,\n  0,\n  1,\n  1,\n  0,\n  1,\n  1,\n  0,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  0,\n  0,\n  0,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  0,\n  1,\n  0,\n  1,\n  0\n], RUNNING = 0, CLOSING = 1, CLOSED = 2;\n\nclass BunWebSocketMocked extends EventEmitter {\n  #ws;\n  #state;\n  #enquedMessages = [];\n  #url;\n  #protocol;\n  #extensions;\n  #bufferedAmount = 0;\n  #binaryType = \"arraybuffer\";\n  #onclose;\n  #onerror;\n  #onmessage;\n  #onopen;\n  constructor(url, protocol, extensions, binaryType) {\n    super();\n    if (this.#ws = null, this.#state = 0, this.#url = url, this.#bufferedAmount = 0, binaryType = binaryType || \"arraybuffer\", binaryType !== \"nodebuffer\" && binaryType !== \"blob\" && binaryType !== \"arraybuffer\")\n      @throwTypeError(\"binaryType must be either 'blob', 'arraybuffer' or 'nodebuffer'\");\n    this.#binaryType = binaryType, this.#protocol = protocol, this.#extensions = extensions;\n    const message = this.#message.bind(this), open = this.#open.bind(this), close = this.#close.bind(this), drain = this.#drain.bind(this);\n    this[kBunInternals] = {\n      message,\n      open,\n      close,\n      drain\n    };\n  }\n  #message(ws, message) {\n    if (this.#ws = ws, typeof message === \"string\")\n      if (this.#binaryType === \"arraybuffer\")\n        message = encoder.encode(message).buffer;\n      else if (this.#binaryType === \"blob\")\n        message = new Blob([message], { type: \"text/plain\" });\n      else\n        message = Buffer.from(message);\n    else if (this.#binaryType !== \"nodebuffer\") {\n      if (this.#binaryType === \"arraybuffer\")\n        message = new Uint8Array(message);\n      else if (this.#binaryType === \"blob\")\n        message = new Blob([message]);\n    }\n    this.emit(\"message\", message);\n  }\n  #open(ws) {\n    this.#ws = ws, this.#state = 1, this.emit(\"open\", this), this.#drain(ws);\n  }\n  #close(ws, code, reason) {\n    this.#state = 3, this.#ws = null, this.emit(\"close\", code, reason);\n  }\n  #drain(ws) {\n    const chunk = this.#enquedMessages[0];\n    if (chunk) {\n      const [data, compress, cb] = chunk;\n      if (ws.send(data, compress) == -1)\n        return;\n      typeof cb === \"function\" && cb(), this.#bufferedAmount -= chunk.length, this.#enquedMessages.shift();\n    }\n  }\n  send(data, opts, cb) {\n    if (this.#state === 1) {\n      const compress = opts\?.compress;\n      if (this.#ws.send(data, compress) == -1) {\n        this.#enquedMessages.push([data, compress, cb]), this.#bufferedAmount += data.length;\n        return;\n      }\n      typeof cb === \"function\" && cb();\n    } else if (this.#state === 0)\n      this.#enquedMessages.push([data, opts\?.compress, cb]), this.#bufferedAmount += data.length;\n  }\n  close(code, reason) {\n    if (this.#state === 1)\n      this.#state = 2, this.#ws.close(code, reason);\n  }\n  get binaryType() {\n    return this.#binaryType;\n  }\n  set binaryType(type) {\n    if (type !== \"nodebuffer\" && type !== \"blob\" && type !== \"arraybuffer\")\n      @throwTypeError(\"binaryType must be either 'blob', 'arraybuffer' or 'nodebuffer'\");\n    this.#binaryType = type;\n  }\n  get readyState() {\n    return this.#state;\n  }\n  get url() {\n    return this.#url;\n  }\n  get protocol() {\n    return this.#protocol;\n  }\n  get extensions() {\n    return this.#extensions;\n  }\n  get bufferedAmount() {\n    return this.#bufferedAmount \?\? 0;\n  }\n  setSocket(socket, head, options) {\n    throw new Error(\"Not implemented\");\n  }\n  set onclose(cb) {\n    if (this.#onclose)\n      this.removeListener(\"close\", this.#onclose);\n    this.on(\"close\", cb), this.#onclose = cb;\n  }\n  set onerror(cb) {\n    if (this.#onerror)\n      this.removeListener(\"error\", this.#onerror);\n    this.on(\"error\", cb), this.#onerror = cb;\n  }\n  set onmessage(cb) {\n    if (this.#onmessage)\n      this.removeListener(\"message\", this.#onmessage);\n    this.on(\"message\", cb), this.#onmessage = cb;\n  }\n  set onopen(cb) {\n    if (this.#onopen)\n      this.removeListener(\"open\", this.#onopen);\n    this.on(\"open\", cb), this.#onopen = cb;\n  }\n  get onclose() {\n    return this.#onclose;\n  }\n  get onerror() {\n    return this.#onerror;\n  }\n  get onmessage() {\n    return this.#onmessage;\n  }\n  get onopen() {\n    return this.#onopen;\n  }\n}\n\nclass WebSocketServer extends EventEmitter {\n  _server;\n  options;\n  clients;\n  _shouldEmitClose;\n  _state;\n  _removeListeners;\n  constructor(options, callback) {\n    super();\n    if (options = {\n      maxPayload: 104857600,\n      skipUTF8Validation: !1,\n      perMessageDeflate: !1,\n      handleProtocols: null,\n      clientTracking: !0,\n      verifyClient: null,\n      noServer: !1,\n      backlog: null,\n      server: null,\n      host: null,\n      path: null,\n      port: null,\n      ...options\n    }, options.port == null && !options.server && !options.noServer || options.port != null && (options.server || options.noServer) || options.server && options.noServer)\n      @throwTypeError('One and only one of the \"port\", \"server\", or \"noServer\" options must be specified');\n    if (options.port != null)\n      this._server = http.createServer((req, res) => {\n        const body = http.STATUS_CODES[426];\n        res.writeHead(426, {\n          \"Content-Length\": body.length,\n          \"Content-Type\": \"text/plain\"\n        }), res.end(body);\n      }), this._server.listen(options.port, options.host, options.backlog, callback);\n    else if (options.server)\n      this._server = options.server;\n    if (this._server) {\n      const emitConnection = this.emit.bind(this, \"connection\"), emitListening = this.emit.bind(this, \"listening\"), emitError = this.emit.bind(this, \"error\"), doUpgrade = (req, socket, head) => {\n        this.handleUpgrade(req, socket, head, emitConnection);\n      };\n      this._server.on(\"listening\", emitListening), this._server.on(\"error\", emitError), this._server.on(\"upgrade\", doUpgrade), this._removeListeners = () => {\n        this._server.removeListener(\"upgrade\", doUpgrade), this._server.removeListener(\"listening\", emitListening), this._server.removeListener(\"error\", emitError);\n      };\n    }\n    if (options.perMessageDeflate === !0)\n      options.perMessageDeflate = {};\n    if (options.clientTracking)\n      this.clients = new Set, this._shouldEmitClose = !1;\n    this.options = options, this._state = RUNNING;\n  }\n  address() {\n    if (this.options.noServer)\n      throw new Error('The server is operating in \"noServer\" mode');\n    if (!this._server)\n      return null;\n    return this._server.address();\n  }\n  close(cb) {\n    if (this._state === CLOSED) {\n      if (cb)\n        this.once(\"close\", () => {\n          cb(new Error(\"The server is not running\"));\n        });\n      process.nextTick((server) => {\n        server._state = CLOSED, server.emit(\"close\");\n      }, this);\n      return;\n    }\n    if (cb)\n      this.once(\"close\", cb);\n    if (this._state === CLOSING)\n      return;\n    if (this._state = CLOSING, this.options.noServer || this.options.server) {\n      if (this._server)\n        this._removeListeners(), this._removeListeners = this._server = null;\n      if (this.clients)\n        if (!this.clients.size)\n          process.nextTick((server) => {\n            server._state = CLOSED, server.emit(\"close\");\n          }, this);\n        else\n          this._shouldEmitClose = !0;\n      else\n        process.nextTick((server) => {\n          server._state = CLOSED, server.emit(\"close\");\n        }, this);\n    } else {\n      const server = this._server;\n      this._removeListeners(), this._removeListeners = this._server = null, server.close(() => {\n        this._state = CLOSED, this.emit(\"close\");\n      });\n    }\n  }\n  shouldHandle(req) {\n    if (this.options.path) {\n      const index = req.url.indexOf(\"\?\");\n      if ((index !== -1 \? req.url.slice(0, index) : req.url) !== this.options.path)\n        return !1;\n    }\n    return !0;\n  }\n  completeUpgrade(extensions, key, protocols, request, socket, head, cb) {\n    const [server, response, req] = socket[kBunInternals];\n    if (this._state > RUNNING)\n      return abortHandshake(response, 503);\n    let protocol = \"\";\n    if (protocols.size)\n      protocol = this.options.handleProtocols \? this.options.handleProtocols(protocols, request) : protocols.values().next().value;\n    const ws = new BunWebSocketMocked(request.url, protocol, extensions, \"nodebuffer\"), headers = [\"HTTP/1.1 101 Switching Protocols\", \"Upgrade: websocket\", \"Connection: Upgrade\"];\n    if (this.emit(\"headers\", headers, request), server.upgrade(req, {\n      data: ws[kBunInternals]\n    })) {\n      if (response._reply(void 0), this.clients)\n        this.clients.add(ws), ws.on(\"close\", () => {\n          if (this.clients.delete(ws), this._shouldEmitClose && !this.clients.size)\n            process.nextTick(wsEmitClose, this);\n        });\n      cb(ws, request);\n    } else\n      abortHandshake(response, 500);\n  }\n  handleUpgrade(req, socket, head, cb) {\n    const [_, response] = socket[kBunInternals], key = req.headers[\"sec-websocket-key\"], version = +req.headers[\"sec-websocket-version\"];\n    if (req.method !== \"GET\") {\n      abortHandshakeOrEmitwsClientError(this, req, response, socket, 405, \"Invalid HTTP method\");\n      return;\n    }\n    if (req.headers.upgrade.toLowerCase() !== \"websocket\") {\n      abortHandshakeOrEmitwsClientError(this, req, response, socket, 400, \"Invalid Upgrade header\");\n      return;\n    }\n    if (!key || !wsKeyRegex.test(key)) {\n      abortHandshakeOrEmitwsClientError(this, req, response, socket, 400, \"Missing or invalid Sec-WebSocket-Key header\");\n      return;\n    }\n    if (version !== 8 && version !== 13) {\n      abortHandshakeOrEmitwsClientError(this, req, response, socket, 400, \"Missing or invalid Sec-WebSocket-Version header\");\n      return;\n    }\n    if (!this.shouldHandle(req)) {\n      abortHandshake(response, 400);\n      return;\n    }\n    const secWebSocketProtocol = req.headers[\"sec-websocket-protocol\"];\n    let protocols = new Set;\n    if (secWebSocketProtocol !== void 0)\n      try {\n        protocols = subprotocolParse(secWebSocketProtocol);\n      } catch (err) {\n        abortHandshakeOrEmitwsClientError(this, req, response, socket, 400, \"Invalid Sec-WebSocket-Protocol header\");\n        return;\n      }\n    const extensions = {};\n    if (this.options.verifyClient) {\n      const info = {\n        origin: req.headers[`${version === 8 \? \"sec-websocket-origin\" : \"origin\"}`],\n        secure: !!(req.socket.authorized || req.socket.encrypted),\n        req\n      };\n      if (this.options.verifyClient.length === 2) {\n        this.options.verifyClient(info, (verified, code, message, headers) => {\n          if (!verified)\n            return abortHandshake(response, code || 401, message, headers);\n          this.completeUpgrade(extensions, key, protocols, req, socket, head, cb);\n        });\n        return;\n      }\n      if (!this.options.verifyClient(info))\n        return abortHandshake(response, 401);\n    }\n    this.completeUpgrade(extensions, key, protocols, req, socket, head, cb);\n  }\n}\nObject.defineProperty(BunWebSocket, \"CONNECTING\", {\n  enumerable: !0,\n  value: readyStates.indexOf(\"CONNECTING\")\n});\nObject.defineProperty(BunWebSocket.prototype, \"CONNECTING\", {\n  enumerable: !0,\n  value: readyStates.indexOf(\"CONNECTING\")\n});\nObject.defineProperty(BunWebSocket, \"OPEN\", {\n  enumerable: !0,\n  value: readyStates.indexOf(\"OPEN\")\n});\nObject.defineProperty(BunWebSocket.prototype, \"OPEN\", {\n  enumerable: !0,\n  value: readyStates.indexOf(\"OPEN\")\n});\nObject.defineProperty(BunWebSocket, \"CLOSING\", {\n  enumerable: !0,\n  value: readyStates.indexOf(\"CLOSING\")\n});\nObject.defineProperty(BunWebSocket.prototype, \"CLOSING\", {\n  enumerable: !0,\n  value: readyStates.indexOf(\"CLOSING\")\n});\nObject.defineProperty(BunWebSocket, \"CLOSED\", {\n  enumerable: !0,\n  value: readyStates.indexOf(\"CLOSED\")\n});\nObject.defineProperty(BunWebSocket.prototype, \"CLOSED\", {\n  enumerable: !0,\n  value: readyStates.indexOf(\"CLOSED\")\n});\n\nclass Sender {\n  constructor() {\n    throw new Error(\"Not supported yet in Bun\");\n  }\n}\n\nclass Receiver {\n  constructor() {\n    throw new Error(\"Not supported yet in Bun\");\n  }\n}\nvar createWebSocketStream = (ws) => {\n  throw new Error(\"Not supported yet in Bun\");\n};\n$ = Object.assign(BunWebSocket, {\n  createWebSocketStream,\n  Receiver,\n  Sender,\n  WebSocket: BunWebSocket,\n  Server: WebSocketServer,\n  WebSocketServer\n});\nreturn $})\n"_s;
//

  #elif _WIN32
  //
static constexpr ASCIILiteral BunFFICode = "(function (){\"use strict\";// src/js/out/tmp/bun/ffi.ts\nvar FFIBuilder = function(params, returnType, functionToCall, name) {\n  const hasReturnType = typeof FFIType[returnType] === \"number\" && FFIType[returnType] !== FFIType.void;\n  var paramNames = new Array(params.length), args = new Array(params.length);\n  for (let i = 0;i < params.length; i++) {\n    paramNames[i] = `p${i}`;\n    const wrapper = ffiWrappers[FFIType[params[i]]];\n    if (wrapper)\n      args[i] = `(val=>${wrapper})(p${i})`;\n    else\n      @throwTypeError(`Unsupported type ${params[i]}. Must be one of: ${Object.keys(FFIType).sort().join(\", \")}`);\n  }\n  var code = `functionToCall(${args.join(\", \")})`;\n  if (hasReturnType)\n    if (FFIType[returnType] === FFIType.cstring)\n      code = `return new __GlobalBunCString(${code})`;\n    else\n      code = `return ${code}`;\n  var func = new Function(\"functionToCall\", ...paramNames, code);\n  Object.defineProperty(func, \"name\", {\n    value: name\n  });\n  var wrap;\n  switch (paramNames.length) {\n    case 0:\n      wrap = () => func(functionToCall);\n      break;\n    case 1:\n      wrap = (arg1) => func(functionToCall, arg1);\n      break;\n    case 2:\n      wrap = (arg1, arg2) => func(functionToCall, arg1, arg2);\n      break;\n    case 3:\n      wrap = (arg1, arg2, arg3) => func(functionToCall, arg1, arg2, arg3);\n      break;\n    case 4:\n      wrap = (arg1, arg2, arg3, arg4) => func(functionToCall, arg1, arg2, arg3, arg4);\n      break;\n    case 5:\n      wrap = (arg1, arg2, arg3, arg4, arg5) => func(functionToCall, arg1, arg2, arg3, arg4, arg5);\n      break;\n    case 6:\n      wrap = (arg1, arg2, arg3, arg4, arg5, arg6) => func(functionToCall, arg1, arg2, arg3, arg4, arg5, arg6);\n      break;\n    case 7:\n      wrap = (arg1, arg2, arg3, arg4, arg5, arg6, arg7) => func(functionToCall, arg1, arg2, arg3, arg4, arg5, arg6, arg7);\n      break;\n    case 8:\n      wrap = (arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) => func(functionToCall, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);\n      break;\n    case 9:\n      wrap = (arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9) => func(functionToCall, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9);\n      break;\n    default: {\n      wrap = (...args2) => func(functionToCall, ...args2);\n      break;\n    }\n  }\n  return wrap.native = functionToCall, wrap.ptr = functionToCall.ptr, wrap;\n}, dlopen = function(path, options) {\n  const result = nativeDLOpen(path, options);\n  for (let key in result.symbols) {\n    var symbol = result.symbols[key];\n    if (options[key]\?.args\?.length || FFIType[options[key]\?.returns] === FFIType.cstring)\n      result.symbols[key] = FFIBuilder(options[key].args \?\? [], options[key].returns \?\? FFIType.void, symbol, path.includes(\"/\") \? `${key} (${path.split(\"/\").pop()})` : `${key} (${path})`);\n    else\n      result.symbols[key].native = result.symbols[key];\n  }\n  return result;\n}, linkSymbols = function(options) {\n  const result = nativeLinkSymbols(options);\n  for (let key in result.symbols) {\n    var symbol = result.symbols[key];\n    if (options[key]\?.args\?.length || FFIType[options[key]\?.returns] === FFIType.cstring)\n      result.symbols[key] = FFIBuilder(options[key].args \?\? [], options[key].returns \?\? FFIType.void, symbol, key);\n    else\n      result.symbols[key].native = result.symbols[key];\n  }\n  return result;\n}, onCloseCFunction = function(close) {\n  close();\n}, CFunction = function(options) {\n  const identifier = `CFunction${cFunctionI++}`;\n  var result = linkSymbols({\n    [identifier]: options\n  }), hasClosed = !1, close = result.close;\n  return result.symbols[identifier].close = () => {\n    if (hasClosed || !close)\n      return;\n    hasClosed = !0, close(), close = void 0;\n  }, cFunctionRegistry ||= new FinalizationRegistry(onCloseCFunction), cFunctionRegistry.register(result.symbols[identifier], result.symbols[identifier].close), result.symbols[identifier];\n}, $, FFIType = {\n  \"0\": 0,\n  \"1\": 1,\n  \"2\": 2,\n  \"3\": 3,\n  \"4\": 4,\n  \"5\": 5,\n  \"6\": 6,\n  \"7\": 7,\n  \"8\": 8,\n  \"9\": 9,\n  \"10\": 10,\n  \"11\": 11,\n  \"12\": 12,\n  \"13\": 13,\n  \"14\": 14,\n  \"15\": 15,\n  \"16\": 16,\n  \"17\": 17,\n  bool: 11,\n  c_int: 5,\n  c_uint: 6,\n  char: 0,\n  \"char*\": 12,\n  double: 9,\n  f32: 10,\n  f64: 9,\n  float: 10,\n  i16: 3,\n  i32: 5,\n  i64: 7,\n  i8: 1,\n  int: 5,\n  int16_t: 3,\n  int32_t: 5,\n  int64_t: 7,\n  int8_t: 1,\n  isize: 7,\n  u16: 4,\n  u32: 6,\n  u64: 8,\n  u8: 2,\n  uint16_t: 4,\n  uint32_t: 6,\n  uint64_t: 8,\n  uint8_t: 2,\n  usize: 8,\n  \"void*\": 12,\n  ptr: 12,\n  pointer: 12,\n  void: 13,\n  cstring: 14,\n  i64_fast: 15,\n  u64_fast: 16,\n  function: 17,\n  callback: 17,\n  fn: 17\n};\nvar ffi = globalThis.Bun.FFI, ptr = (arg1, arg2) => typeof arg2 === \"undefined\" \? ffi.ptr(arg1) : ffi.ptr(arg1, arg2), toBuffer = ffi.toBuffer, toArrayBuffer = ffi.toArrayBuffer, viewSource = ffi.viewSource, BunCString = ffi.CString, nativeLinkSymbols = ffi.linkSymbols, nativeDLOpen = ffi.dlopen, nativeCallback = ffi.callback, closeCallback = ffi.closeCallback;\ndelete ffi.callback;\ndelete ffi.closeCallback;\n\nclass JSCallback {\n  constructor(cb, options) {\n    const { ctx, ptr: ptr2 } = nativeCallback(options, cb);\n    this.#ctx = ctx, this.ptr = ptr2, this.#threadsafe = !!options\?.threadsafe;\n  }\n  ptr;\n  #ctx;\n  #threadsafe;\n  get threadsafe() {\n    return this.#threadsafe;\n  }\n  [Symbol.toPrimitive]() {\n    const { ptr: ptr2 } = this;\n    return typeof ptr2 === \"number\" \? ptr2 : 0;\n  }\n  close() {\n    const ctx = this.#ctx;\n    if (this.ptr = null, this.#ctx = null, ctx)\n      closeCallback(ctx);\n  }\n}\n\nclass CString extends String {\n  constructor(ptr2, byteOffset, byteLength) {\n    super(ptr2 \? typeof byteLength === \"number\" && Number.isSafeInteger(byteLength) \? BunCString(ptr2, byteOffset || 0, byteLength) : BunCString(ptr2) : \"\");\n    if (this.ptr = typeof ptr2 === \"number\" \? ptr2 : 0, typeof byteOffset !== \"undefined\")\n      this.byteOffset = byteOffset;\n    if (typeof byteLength !== \"undefined\")\n      this.byteLength = byteLength;\n  }\n  ptr;\n  byteOffset;\n  byteLength;\n  #cachedArrayBuffer;\n  get arrayBuffer() {\n    if (this.#cachedArrayBuffer)\n      return this.#cachedArrayBuffer;\n    if (!this.ptr)\n      return this.#cachedArrayBuffer = new ArrayBuffer(0);\n    return this.#cachedArrayBuffer = toArrayBuffer(this.ptr, this.byteOffset, this.byteLength);\n  }\n}\nObject.defineProperty(globalThis, \"__GlobalBunCString\", {\n  value: CString,\n  enumerable: !1,\n  configurable: !1\n});\nvar ffiWrappers = new Array(18), char = \"val|0\";\nffiWrappers.fill(char);\nffiWrappers[FFIType.uint8_t] = \"val<0\?0:val>=255\?255:val|0\";\nffiWrappers[FFIType.int16_t] = \"val<=-32768\?-32768:val>=32768\?32768:val|0\";\nffiWrappers[FFIType.uint16_t] = \"val<=0\?0:val>=65536\?65536:val|0\";\nffiWrappers[FFIType.int32_t] = \"val|0\";\nffiWrappers[FFIType.uint32_t] = \"val<=0\?0:val>=0xffffffff\?0xffffffff:+val||0\";\nffiWrappers[FFIType.i64_fast] = `{\n  if (typeof val === \"bigint\") {\n    if (val <= BigInt(Number.MAX_SAFE_INTEGER) && val >= BigInt(-Number.MAX_SAFE_INTEGER)) {\n      return Number(val).valueOf() || 0;\n    }\n\n    return val;\n  }\n\n  return !val \? 0 : +val || 0;\n}`;\nffiWrappers[FFIType.i64_fast] = `{\n  if (typeof val === \"bigint\") {\n    if (val <= BigInt(Number.MAX_SAFE_INTEGER) && val >= BigInt(-Number.MAX_SAFE_INTEGER)) {\n      return Number(val).valueOf() || 0;\n    }\n\n    return val;\n  }\n\n  return !val \? 0 : +val || 0;\n}`;\nffiWrappers[FFIType.u64_fast] = `{\n  if (typeof val === \"bigint\") {\n    if (val <= BigInt(Number.MAX_SAFE_INTEGER) && val >= 0) {\n      return Number(val).valueOf() || 0;\n    }\n\n    return val;\n  }\n\n  return !val \? 0 : +val || 0;\n}`;\nffiWrappers[FFIType.int64_t] = `{\n  if (typeof val === \"bigint\") {\n    return val;\n  }\n\n  if (typeof val === \"number\") {\n    return BigInt(val || 0);\n  }\n\n  return BigInt(+val || 0);\n}`;\nffiWrappers[FFIType.uint64_t] = `{\n  if (typeof val === \"bigint\") {\n    return val;\n  }\n\n  if (typeof val === \"number\") {\n    return val <= 0 \? BigInt(0) : BigInt(val || 0);\n  }\n\n  return BigInt(+val || 0);\n}`;\nffiWrappers[FFIType.u64_fast] = `{\n  if (typeof val === \"bigint\") {\n    if (val <= BigInt(Number.MAX_SAFE_INTEGER) && val >= BigInt(0)) return Number(val);\n    return val;\n  }\n\n  return typeof val === \"number\" \? (val <= 0 \? 0 : +val || 0) : +val || 0;\n}`;\nffiWrappers[FFIType.uint16_t] = `{\n  const ret = (typeof val === \"bigint\" \? Number(val) : val) | 0;\n  return ret <= 0 \? 0 : ret > 0xffff \? 0xffff : ret;\n}`;\nffiWrappers[FFIType.double] = `{\n  if (typeof val === \"bigint\") {\n    if (val.valueOf() < BigInt(Number.MAX_VALUE)) {\n      return Math.abs(Number(val).valueOf()) + 0.00000000000001 - 0.00000000000001;\n    }\n  }\n\n  if (!val) {\n    return 0 + 0.00000000000001 - 0.00000000000001;\n  }\n\n  return val + 0.00000000000001 - 0.00000000000001;\n}`;\nffiWrappers[FFIType.float] = ffiWrappers[10] = `{\n  return Math.fround(val);\n}`;\nffiWrappers[FFIType.bool] = `{\n  return !!val;\n}`;\nObject.defineProperty(globalThis, \"__GlobalBunFFIPtrFunctionForWrapper\", {\n  value: ptr,\n  enumerable: !1,\n  configurable: !0\n});\nffiWrappers[FFIType.cstring] = ffiWrappers[FFIType.pointer] = `{\n  if (typeof val === \"number\") return val;\n  if (!val) {\n    return null;\n  }\n\n  if (ArrayBuffer.isView(val) || val instanceof ArrayBuffer) {\n    return __GlobalBunFFIPtrFunctionForWrapper(val);\n  }\n\n  if (typeof val === \"string\") {\n    throw new TypeError(\"To convert a string to a pointer, encode it as a buffer\");\n  }\n\n  throw new TypeError(\\`Unable to convert \\${ val } to a pointer\\`);\n}`;\nffiWrappers[FFIType.function] = `{\n  if (typeof val === \"number\") {\n    return val;\n  }\n\n  if (typeof val === \"bigint\") {\n    return Number(val);\n  }\n\n  var ptr = val && val.ptr;\n\n  if (!ptr) {\n    throw new TypeError(\"Expected function to be a JSCallback or a number\");\n  }\n\n  return ptr;\n}`;\nvar native = {\n  dlopen: nativeDLOpen,\n  callback: () => {\n    throw new Error(\"Deprecated. Use new JSCallback(options, fn) instead\");\n  }\n}, cFunctionI = 0, cFunctionRegistry, read = ffi.read;\n$ = {\n  CFunction,\n  CString,\n  FFIType,\n  JSCallback,\n  dlopen,\n  linkSymbols,\n  native,\n  ptr,\n  read,\n  suffix: \"dll\",\n  toArrayBuffer,\n  toBuffer,\n  viewSource\n};\nreturn $})\n"_s;
//

//
static constexpr ASCIILiteral BunSqliteCode = "(function (){\"use strict\";// src/js/out/tmp/bun/sqlite.ts\nvar $, defineProperties = Object.defineProperties, toStringTag = Symbol.toStringTag, isArray = Array.isArray, isTypedArray = ArrayBuffer.isView, constants = {\n  SQLITE_OPEN_READONLY: 1,\n  SQLITE_OPEN_READWRITE: 2,\n  SQLITE_OPEN_CREATE: 4,\n  SQLITE_OPEN_DELETEONCLOSE: 8,\n  SQLITE_OPEN_EXCLUSIVE: 16,\n  SQLITE_OPEN_AUTOPROXY: 32,\n  SQLITE_OPEN_URI: 64,\n  SQLITE_OPEN_MEMORY: 128,\n  SQLITE_OPEN_MAIN_DB: 256,\n  SQLITE_OPEN_TEMP_DB: 512,\n  SQLITE_OPEN_TRANSIENT_DB: 1024,\n  SQLITE_OPEN_MAIN_JOURNAL: 2048,\n  SQLITE_OPEN_TEMP_JOURNAL: 4096,\n  SQLITE_OPEN_SUBJOURNAL: 8192,\n  SQLITE_OPEN_SUPER_JOURNAL: 16384,\n  SQLITE_OPEN_NOMUTEX: 32768,\n  SQLITE_OPEN_FULLMUTEX: 65536,\n  SQLITE_OPEN_SHAREDCACHE: 131072,\n  SQLITE_OPEN_PRIVATECACHE: 262144,\n  SQLITE_OPEN_WAL: 524288,\n  SQLITE_OPEN_NOFOLLOW: 16777216,\n  SQLITE_OPEN_EXRESCODE: 33554432,\n  SQLITE_PREPARE_PERSISTENT: 1,\n  SQLITE_PREPARE_NORMALIZE: 2,\n  SQLITE_PREPARE_NO_VTAB: 4\n}, SQL, controllers;\n\nclass Statement {\n  constructor(raw) {\n    switch (this.#raw = raw, raw.paramsCount) {\n      case 0: {\n        this.get = this.#getNoArgs, this.all = this.#allNoArgs, this.values = this.#valuesNoArgs, this.run = this.#runNoArgs;\n        break;\n      }\n      default: {\n        this.get = this.#get, this.all = this.#all, this.values = this.#values, this.run = this.#run;\n        break;\n      }\n    }\n  }\n  #raw;\n  get;\n  all;\n  values;\n  run;\n  isFinalized = !1;\n  toJSON() {\n    return {\n      sql: this.native.toString(),\n      isFinalized: this.isFinalized,\n      paramsCount: this.paramsCount,\n      columnNames: this.columnNames\n    };\n  }\n  get [toStringTag]() {\n    return `\"${this.native.toString()}\"`;\n  }\n  toString() {\n    return this.native.toString();\n  }\n  get native() {\n    return this.#raw;\n  }\n  #getNoArgs() {\n    return this.#raw.get();\n  }\n  #allNoArgs() {\n    return this.#raw.all();\n  }\n  #valuesNoArgs() {\n    return this.#raw.values();\n  }\n  #runNoArgs() {\n    this.#raw.run();\n  }\n  #get(...args) {\n    if (args.length === 0)\n      return this.#getNoArgs();\n    var arg0 = args[0];\n    return !isArray(arg0) && (!arg0 || typeof arg0 !== \"object\" || isTypedArray(arg0)) \? this.#raw.get(args) : this.#raw.get(...args);\n  }\n  #all(...args) {\n    if (args.length === 0)\n      return this.#allNoArgs();\n    var arg0 = args[0];\n    return !isArray(arg0) && (!arg0 || typeof arg0 !== \"object\" || isTypedArray(arg0)) \? this.#raw.all(args) : this.#raw.all(...args);\n  }\n  #values(...args) {\n    if (args.length === 0)\n      return this.#valuesNoArgs();\n    var arg0 = args[0];\n    return !isArray(arg0) && (!arg0 || typeof arg0 !== \"object\" || isTypedArray(arg0)) \? this.#raw.values(args) : this.#raw.values(...args);\n  }\n  #run(...args) {\n    if (args.length === 0)\n      return this.#runNoArgs();\n    var arg0 = args[0];\n    !isArray(arg0) && (!arg0 || typeof arg0 !== \"object\" || isTypedArray(arg0)) \? this.#raw.run(args) : this.#raw.run(...args);\n  }\n  get columnNames() {\n    return this.#raw.columns;\n  }\n  get paramsCount() {\n    return this.#raw.paramsCount;\n  }\n  finalize(...args) {\n    return this.isFinalized = !0, this.#raw.finalize(...args);\n  }\n}\nvar cachedCount = Symbol.for(\"Bun.Database.cache.count\");\n\nclass Database {\n  constructor(filenameGiven, options) {\n    if (typeof filenameGiven === \"undefined\")\n      ;\n    else if (typeof filenameGiven !== \"string\") {\n      if (isTypedArray(filenameGiven)) {\n        this.#handle = Database.deserialize(filenameGiven, typeof options === \"object\" && options \? !!options.readonly : ((options | 0) & constants.SQLITE_OPEN_READONLY) != 0), this.filename = \":memory:\";\n        return;\n      }\n      @throwTypeError(`Expected 'filename' to be a string, got '${typeof filenameGiven}'`);\n    }\n    var filename = typeof filenameGiven === \"string\" \? filenameGiven.trim() : \":memory:\", flags = constants.SQLITE_OPEN_READWRITE | constants.SQLITE_OPEN_CREATE;\n    if (typeof options === \"object\" && options) {\n      if (flags = 0, options.readonly)\n        flags = constants.SQLITE_OPEN_READONLY;\n      if (\"readOnly\" in options)\n        @throwTypeError('Misspelled option \"readOnly\" should be \"readonly\"');\n      if (options.create)\n        flags = constants.SQLITE_OPEN_READWRITE | constants.SQLITE_OPEN_CREATE;\n      if (options.readwrite)\n        flags |= constants.SQLITE_OPEN_READWRITE;\n    } else if (typeof options === \"number\")\n      flags = options;\n    const anonymous = filename === \"\" || filename === \":memory:\";\n    if (anonymous && (flags & constants.SQLITE_OPEN_READONLY) !== 0)\n      throw new Error(\"Cannot open an anonymous database in read-only mode.\");\n    if (!SQL)\n      SQL = globalThis[globalThis.Symbol.for('Bun.lazy')](\"sqlite\");\n    this.#handle = SQL.open(anonymous \? \":memory:\" : filename, flags), this.filename = filename;\n  }\n  #handle;\n  #cachedQueriesKeys = [];\n  #cachedQueriesLengths = [];\n  #cachedQueriesValues = [];\n  filename;\n  get handle() {\n    return this.#handle;\n  }\n  get inTransaction() {\n    return SQL.isInTransaction(this.#handle);\n  }\n  static open(filename, options) {\n    return new Database(filename, options);\n  }\n  loadExtension(name, entryPoint) {\n    return SQL.loadExtension(this.#handle, name, entryPoint);\n  }\n  serialize(optionalName) {\n    return SQL.serialize(this.#handle, optionalName || \"main\");\n  }\n  static deserialize(serialized, isReadOnly = !1) {\n    if (!SQL)\n      SQL = globalThis[globalThis.Symbol.for('Bun.lazy')](\"sqlite\");\n    return SQL.deserialize(serialized, isReadOnly);\n  }\n  static setCustomSQLite(path) {\n    if (!SQL)\n      SQL = globalThis[globalThis.Symbol.for('Bun.lazy')](\"sqlite\");\n    return SQL.setCustomSQLite(path);\n  }\n  close() {\n    return this.clearQueryCache(), SQL.close(this.#handle);\n  }\n  clearQueryCache() {\n    for (let item of this.#cachedQueriesValues)\n      item.finalize();\n    this.#cachedQueriesKeys.length = 0, this.#cachedQueriesValues.length = 0, this.#cachedQueriesLengths.length = 0;\n  }\n  run(query, ...params) {\n    if (params.length === 0) {\n      SQL.run(this.#handle, query);\n      return;\n    }\n    var arg0 = params[0];\n    return !isArray(arg0) && (!arg0 || typeof arg0 !== \"object\" || isTypedArray(arg0)) \? SQL.run(this.#handle, query, params) : SQL.run(this.#handle, query, ...params);\n  }\n  prepare(query, params, flags) {\n    return new Statement(SQL.prepare(this.#handle, query, params, flags || 0));\n  }\n  static MAX_QUERY_CACHE_SIZE = 20;\n  get [cachedCount]() {\n    return this.#cachedQueriesKeys.length;\n  }\n  query(query) {\n    if (typeof query !== \"string\")\n      @throwTypeError(`Expected 'query' to be a string, got '${typeof query}'`);\n    if (query.length === 0)\n      throw new Error(\"SQL query cannot be empty.\");\n    var index = this.#cachedQueriesLengths.indexOf(query.length);\n    while (index !== -1) {\n      if (this.#cachedQueriesKeys[index] !== query) {\n        index = this.#cachedQueriesLengths.indexOf(query.length, index + 1);\n        continue;\n      }\n      var stmt = this.#cachedQueriesValues[index];\n      if (stmt.isFinalized)\n        return this.#cachedQueriesValues[index] = this.prepare(query, void 0, willCache \? constants.SQLITE_PREPARE_PERSISTENT : 0);\n      return stmt;\n    }\n    const willCache = this.#cachedQueriesKeys.length < Database.MAX_QUERY_CACHE_SIZE;\n    var stmt = this.prepare(query, void 0, willCache \? constants.SQLITE_PREPARE_PERSISTENT : 0);\n    if (willCache)\n      this.#cachedQueriesKeys.push(query), this.#cachedQueriesLengths.push(query.length), this.#cachedQueriesValues.push(stmt);\n    return stmt;\n  }\n  transaction(fn, self) {\n    if (typeof fn !== \"function\")\n      @throwTypeError(\"Expected first argument to be a function\");\n    const db = this, controller = getController(db, self), properties = {\n      default: { value: wrapTransaction(fn, db, controller.default) },\n      deferred: { value: wrapTransaction(fn, db, controller.deferred) },\n      immediate: {\n        value: wrapTransaction(fn, db, controller.immediate)\n      },\n      exclusive: {\n        value: wrapTransaction(fn, db, controller.exclusive)\n      },\n      database: { value: this, enumerable: !0 }\n    };\n    return defineProperties(properties.default.value, properties), defineProperties(properties.deferred.value, properties), defineProperties(properties.immediate.value, properties), defineProperties(properties.exclusive.value, properties), properties.default.value;\n  }\n}\nDatabase.prototype.exec = Database.prototype.run;\nvar getController = (db, self) => {\n  let controller = (controllers ||= new WeakMap).get(db);\n  if (!controller) {\n    const shared = {\n      commit: db.prepare(\"COMMIT\", void 0, 0),\n      rollback: db.prepare(\"ROLLBACK\", void 0, 0),\n      savepoint: db.prepare(\"SAVEPOINT `\\t_bs3.\\t`\", void 0, 0),\n      release: db.prepare(\"RELEASE `\\t_bs3.\\t`\", void 0, 0),\n      rollbackTo: db.prepare(\"ROLLBACK TO `\\t_bs3.\\t`\", void 0, 0)\n    };\n    controllers.set(db, controller = {\n      default: Object.assign({ begin: db.prepare(\"BEGIN\", void 0, 0) }, shared),\n      deferred: Object.assign({ begin: db.prepare(\"BEGIN DEFERRED\", void 0, 0) }, shared),\n      immediate: Object.assign({ begin: db.prepare(\"BEGIN IMMEDIATE\", void 0, 0) }, shared),\n      exclusive: Object.assign({ begin: db.prepare(\"BEGIN EXCLUSIVE\", void 0, 0) }, shared)\n    });\n  }\n  return controller;\n}, wrapTransaction = (fn, db, { begin, commit, rollback, savepoint, release, rollbackTo }) => function transaction(...args) {\n  let before, after, undo;\n  if (db.inTransaction)\n    before = savepoint, after = release, undo = rollbackTo;\n  else\n    before = begin, after = commit, undo = rollback;\n  try {\n    before.run();\n    const result = fn.apply(this, args);\n    return after.run(), result;\n  } catch (ex) {\n    if (db.inTransaction) {\n      if (undo.run(), undo !== rollback)\n        after.run();\n    }\n    throw ex;\n  }\n};\n$ = {\n  __esModule: !0,\n  Database,\n  Statement,\n  constants,\n  default: Database\n};\nreturn $})\n"_s;
//

//
static constexpr ASCIILiteral InternalDebuggerCode = "(function (){\"use strict\";// src/js/out/tmp/internal/debugger.ts\nvar generatePath = function() {\n  if (!generatedPath)\n    generatedPath = \"/\" + Math.random().toString(36).slice(2);\n  return generatedPath;\n}, terminalLink = function(url) {\n  if (Bun.enableANSIColors)\n    return \"\\x1B[1m\\x1B]8;;\" + url + \"\\x1B\\\\\" + url + \"\\x1B]8;;\\x1B\\\\\" + \"\\x1B[22m\";\n  return url;\n}, dim = function(text) {\n  if (Bun.enableANSIColors)\n    return \"\\x1B[2m\" + text + \"\\x1B[22m\";\n  return text;\n}, $, sendFn_, disconnectFn_, debuggerCounter = 1;\n\nclass DebuggerWithMessageQueue {\n  debugger = void 0;\n  messageQueue = [];\n  count = debuggerCounter++;\n  send(msg) {\n    sendFn_.call(this.debugger, msg);\n  }\n  disconnect() {\n    disconnectFn_.call(this.debugger), this.messageQueue.length = 0;\n  }\n}\nvar defaultPort = 6499, generatedPath = \"\";\n\nclass WebSocketListener {\n  server;\n  url = \"\";\n  createInspectorConnection;\n  scriptExecutionContextId = 0;\n  activeConnections = new Set;\n  constructor(scriptExecutionContextId = 0, url, createInspectorConnection) {\n    this.scriptExecutionContextId = scriptExecutionContextId, this.createInspectorConnection = createInspectorConnection, this.server = this.start(url);\n  }\n  start(url) {\n    let defaultHostname = \"localhost\", usingDefaultPort = !1;\n    if (/^[0-9]*$/.test(url))\n      url = \"ws://\" + defaultHostname + \":\" + url + generatePath();\n    else if (!url || url.startsWith(\"/\"))\n      url = \"ws://\" + defaultHostname + \":\" + defaultPort + generatePath(), usingDefaultPort = !0;\n    else if (url.includes(\":\") && !url.includes(\"://\"))\n      try {\n        const insertSlash = !url.includes(\"/\");\n        if (url = new URL(\"ws://\" + url).href, insertSlash)\n          url += generatePath().slice(1);\n      } catch (e) {\n        console.error(\"[Inspector]\", \"Failed to parse url\", '\"' + url + '\"'), process.exit(1);\n      }\n    try {\n      var { hostname, port, pathname } = new URL(url);\n      this.url = pathname.toLowerCase();\n    } catch (e) {\n      console.error(\"[Inspector]\", \"Failed to parse url\", '\"' + url + '\"'), process.exit(1);\n    }\n    const serveOptions = {\n      hostname,\n      development: !1,\n      reusePort: !1,\n      websocket: {\n        idleTimeout: 0,\n        open: (socket) => {\n          var connection = new DebuggerWithMessageQueue;\n          const shouldRefEventLoop = !!socket.data\?.shouldRefEventLoop;\n          socket.data = connection, this.activeConnections.add(socket), connection.debugger = this.createInspectorConnection(this.scriptExecutionContextId, shouldRefEventLoop, (...msgs) => {\n            if (socket.readyState > 1) {\n              connection.disconnect();\n              return;\n            }\n            if (connection.messageQueue.length > 0) {\n              connection.messageQueue.push(...msgs);\n              return;\n            }\n            for (let i = 0;i < msgs.length; i++)\n              if (!socket.sendText(msgs[i])) {\n                if (socket.readyState < 2)\n                  connection.messageQueue.push(...msgs.slice(i));\n                return;\n              }\n          }), console.log(\"[Inspector]\", \"Connection #\" + connection.count + \" opened\", \"(\" + new Intl.DateTimeFormat(void 0, {\n            timeStyle: \"long\",\n            dateStyle: \"short\"\n          }).format(new Date) + \")\");\n        },\n        drain: (socket) => {\n          const queue = socket.data.messageQueue;\n          for (let i = 0;i < queue.length; i++)\n            if (!socket.sendText(queue[i])) {\n              socket.data.messageQueue = queue.slice(i);\n              return;\n            }\n          queue.length = 0;\n        },\n        message: (socket, message) => {\n          if (typeof message !== \"string\") {\n            console.warn(\"[Inspector]\", \"Received non-string message\");\n            return;\n          }\n          socket.data.send(message);\n        },\n        close: (socket) => {\n          socket.data.disconnect(), console.log(\"[Inspector]\", \"Connection #\" + socket.data.count + \" closed\", \"(\" + new Intl.DateTimeFormat(void 0, {\n            timeStyle: \"long\",\n            dateStyle: \"short\"\n          }).format(new Date) + \")\"), this.activeConnections.delete(socket);\n        }\n      },\n      fetch: (req, server2) => {\n        let { pathname: pathname2 } = new URL(req.url);\n        if (pathname2 = pathname2.toLowerCase(), pathname2 === \"/json/version\")\n          return Response.json({\n            Browser: navigator.userAgent,\n            \"WebKit-Version\": process.versions.webkit,\n            \"Bun-Version\": Bun.version,\n            \"Bun-Revision\": Bun.revision\n          });\n        if (pathname2 === this.url) {\n          const refHeader = req.headers.get(\"Ref-Event-Loop\");\n          if (server2.upgrade(req, {\n            data: {\n              shouldRefEventLoop: !!refHeader && refHeader !== \"0\"\n            }\n          }))\n            return new Response;\n          return new Response(\"WebSocket expected\", {\n            status: 400\n          });\n        }\n        return new Response(\"Not found\", {\n          status: 404\n        });\n      }\n    };\n    if (port === \"\")\n      port = defaultPort + \"\";\n    let portNumber = Number(port);\n    var server, lastError;\n    if (usingDefaultPort)\n      for (let tries = 0;tries < 10 && !server; tries++)\n        try {\n          lastError = void 0, server = Bun.serve({\n            ...serveOptions,\n            port: portNumber++\n          });\n        } catch (e) {\n          lastError = e;\n        }\n    else\n      try {\n        server = Bun.serve({\n          ...serveOptions,\n          port: portNumber\n        });\n      } catch (e) {\n        lastError = e;\n      }\n    if (!server) {\n      if (console.error(\"[Inspector]\", \"Failed to start server\"), lastError)\n        console.error(lastError);\n      process.exit(1);\n    }\n    let textToWrite = \"\";\n    function writeToConsole(text) {\n      textToWrite += text;\n    }\n    function flushToConsole() {\n      console.write(textToWrite);\n    }\n    return writeToConsole(dim(\"------------------ Bun Inspector ------------------\\n\")), writeToConsole(\"\\x1B[49m\"), writeToConsole(\"Listening at:\\n  \" + `ws://${hostname}:${server.port}${this.url}` + \"\\n\\nInspect in browser:\\n  \" + terminalLink(new URL(`https://debug.bun.sh#${server.hostname}:${server.port}${this.url}`).href) + \"\\n\"), writeToConsole(dim(\"------------------ Bun Inspector ------------------\\n\")), flushToConsole(), server;\n  }\n}\nvar listener;\n$ = function start(debuggerId, hostOrPort, createInspectorConnection, sendFn, disconnectFn) {\n  try {\n    sendFn_ = sendFn, disconnectFn_ = disconnectFn, globalThis.listener = listener ||= new WebSocketListener(debuggerId, hostOrPort, createInspectorConnection);\n  } catch (e) {\n    console.error(\"Bun Inspector threw an exception\\n\", e), process.exit(1);\n  }\n  return `http://${listener.server.hostname}:${listener.server.port}${listener.url}`;\n};\nreturn $})\n"_s;
//

//
static constexpr ASCIILiteral InternalSharedCode = "(function (){\"use strict\";// src/js/out/tmp/internal/shared.ts\nvar throwNotImplemented = function(feature, issue) {\n  throw hideFromStack(throwNotImplemented), new NotImplementedError(feature, issue);\n}, hideFromStack = function(...fns) {\n  for (let fn of fns)\n    Object.defineProperty(fn, \"name\", {\n      value: \"::bunternal::\"\n    });\n}, $;\n\nclass NotImplementedError extends Error {\n  code;\n  constructor(feature, issue) {\n    super(feature + \" is not yet implemented in Bun.\" + (issue \? \" Track the status & thumbs up the issue: https://github.com/oven-sh/bun/issues/\" + issue : \"\"));\n    this.name = \"NotImplementedError\", this.code = \"ERR_NOT_IMPLEMENTED\", hideFromStack(NotImplementedError);\n  }\n}\n$ = {\n  NotImplementedError,\n  throwNotImplemented,\n  hideFromStack\n};\nreturn $})\n"_s;
//

//
static constexpr ASCIILiteral NodeAssertCode = "(function (){\"use strict\";// src/js/out/tmp/node/assert.ts\nvar CallTracker = function() {\n  throw new Error(\"CallTracker is not supported yet\");\n}, util = @getInternalField(@internalModuleRegistry, 43) || @createInternalModuleById(43), isDeepEqual = Bun.deepEquals, __commonJS = (cb, mod) => function() {\n  return mod || (0, cb[Object.keys(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;\n}, require_errors = __commonJS({\n  \"assert/build/internal/errors.js\"(exports, module2) {\n    function _typeof(obj) {\n      return typeof Symbol == \"function\" && typeof Symbol.iterator == \"symbol\" \? _typeof = function(obj2) {\n        return typeof obj2;\n      } : _typeof = function(obj2) {\n        return obj2 && typeof Symbol == \"function\" && obj2.constructor === Symbol && obj2 !== Symbol.prototype \? \"symbol\" : typeof obj2;\n      }, _typeof(obj);\n    }\n    function _classCallCheck(instance, Constructor) {\n      if (!(instance instanceof Constructor))\n        @throwTypeError(\"Cannot call a class as a function\");\n    }\n    function _possibleConstructorReturn(self, call) {\n      return call && (_typeof(call) === \"object\" || typeof call == \"function\") \? call : _assertThisInitialized(self);\n    }\n    function _assertThisInitialized(self) {\n      if (self === void 0)\n        throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n      return self;\n    }\n    function _getPrototypeOf(o) {\n      return _getPrototypeOf = Object.setPrototypeOf \? Object.getPrototypeOf : function(o2) {\n        return o2.__proto__ || Object.getPrototypeOf(o2);\n      }, _getPrototypeOf(o);\n    }\n    function _inherits(subClass, superClass) {\n      if (typeof superClass != \"function\" && superClass !== null)\n        @throwTypeError(\"Super expression must either be null or a function\");\n      subClass.prototype = Object.create(superClass && superClass.prototype, {\n        constructor: { value: subClass, writable: !0, configurable: !0 }\n      }), superClass && _setPrototypeOf(subClass, superClass);\n    }\n    function _setPrototypeOf(o, p) {\n      return _setPrototypeOf = Object.setPrototypeOf || function(o2, p2) {\n        return o2.__proto__ = p2, o2;\n      }, _setPrototypeOf(o, p);\n    }\n    var codes = {}, assert, util2;\n    function createErrorType(code, message, Base) {\n      Base || (Base = Error);\n      function getMessage(arg1, arg2, arg3) {\n        return typeof message == \"string\" \? message : message(arg1, arg2, arg3);\n      }\n      var NodeError = function(_Base) {\n        _inherits(NodeError2, _Base);\n        function NodeError2(arg1, arg2, arg3) {\n          var _this;\n          return _classCallCheck(this, NodeError2), _this = _possibleConstructorReturn(this, _getPrototypeOf(NodeError2).call(this, getMessage(arg1, arg2, arg3))), _this.code = code, _this;\n        }\n        return NodeError2;\n      }(Base);\n      codes[code] = NodeError;\n    }\n    function oneOf(expected, thing) {\n      if (Array.isArray(expected)) {\n        var len = expected.length;\n        return expected = expected.map(function(i) {\n          return String(i);\n        }), len > 2 \? \"one of \".concat(thing, \" \").concat(expected.slice(0, len - 1).join(\", \"), \", or \") + expected[len - 1] : len === 2 \? \"one of \".concat(thing, \" \").concat(expected[0], \" or \").concat(expected[1]) : \"of \".concat(thing, \" \").concat(expected[0]);\n      } else\n        return \"of \".concat(thing, \" \").concat(String(expected));\n    }\n    function startsWith(str, search, pos) {\n      return str.substr(!pos || pos < 0 \? 0 : +pos, search.length) === search;\n    }\n    function endsWith(str, search, this_len) {\n      return (this_len === void 0 || this_len > str.length) && (this_len = str.length), str.substring(this_len - search.length, this_len) === search;\n    }\n    function includes(str, search, start) {\n      return typeof start != \"number\" && (start = 0), start + search.length > str.length \? !1 : str.indexOf(search, start) !== -1;\n    }\n    createErrorType(\"ERR_AMBIGUOUS_ARGUMENT\", 'The \"%s\" argument is ambiguous. %s', TypeError), createErrorType(\"ERR_INVALID_ARG_TYPE\", function(name, expected, actual) {\n      assert === void 0 && (assert = require_assert()), assert(typeof name == \"string\", \"'name' must be a string\");\n      var determiner;\n      typeof expected == \"string\" && startsWith(expected, \"not \") \? (determiner = \"must not be\", expected = expected.replace(/^not /, \"\")) : determiner = \"must be\";\n      var msg;\n      if (endsWith(name, \" argument\"))\n        msg = \"The \".concat(name, \" \").concat(determiner, \" \").concat(oneOf(expected, \"type\"));\n      else {\n        var type = includes(name, \".\") \? \"property\" : \"argument\";\n        msg = 'The \"'.concat(name, '\" ').concat(type, \" \").concat(determiner, \" \").concat(oneOf(expected, \"type\"));\n      }\n      return msg += \". Received type \".concat(_typeof(actual)), msg;\n    }, TypeError), createErrorType(\"ERR_INVALID_ARG_VALUE\", function(name, value) {\n      var reason = arguments.length > 2 && arguments[2] !== void 0 \? arguments[2] : \"is invalid\", inspected = util2.inspect(value);\n      return inspected.length > 128 && (inspected = \"\".concat(inspected.slice(0, 128), \"...\")), \"The argument '\".concat(name, \"' \").concat(reason, \". Received \").concat(inspected);\n    }, TypeError, RangeError), createErrorType(\"ERR_INVALID_RETURN_VALUE\", function(input, name, value) {\n      var type;\n      return value && value.constructor && value.constructor.name \? type = \"instance of \".concat(value.constructor.name) : type = \"type \".concat(_typeof(value)), \"Expected \".concat(input, ' to be returned from the \"').concat(name, '\"') + \" function but got \".concat(type, \".\");\n    }, TypeError), createErrorType(\"ERR_MISSING_ARGS\", function() {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0;_key < _len; _key++)\n        args[_key] = arguments[_key];\n      assert === void 0 && (assert = require_assert()), assert(args.length > 0, \"At least one arg needs to be specified\");\n      var msg = \"The \", len = args.length;\n      switch (args = args.map(function(a) {\n        return '\"'.concat(a, '\"');\n      }), len) {\n        case 1:\n          msg += \"\".concat(args[0], \" argument\");\n          break;\n        case 2:\n          msg += \"\".concat(args[0], \" and \").concat(args[1], \" arguments\");\n          break;\n        default:\n          msg += args.slice(0, len - 1).join(\", \"), msg += \", and \".concat(args[len - 1], \" arguments\");\n          break;\n      }\n      return \"\".concat(msg, \" must be specified\");\n    }, TypeError), module2.exports.codes = codes;\n  }\n}), require_assertion_error = __commonJS({\n  \"assert/build/internal/assert/assertion_error.js\"(exports, module2) {\n    function _objectSpread(target) {\n      for (var i = 1;i < arguments.length; i++) {\n        var source = arguments[i] != null \? arguments[i] : {}, ownKeys = Object.keys(source);\n        typeof Object.getOwnPropertySymbols == \"function\" && (ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {\n          return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n        }))), ownKeys.forEach(function(key) {\n          _defineProperty(target, key, source[key]);\n        });\n      }\n      return target;\n    }\n    function _defineProperty(obj, key, value) {\n      return (key in obj) \? Object.defineProperty(obj, key, {\n        value,\n        enumerable: !0,\n        configurable: !0,\n        writable: !0\n      }) : obj[key] = value, obj;\n    }\n    function _classCallCheck(instance, Constructor) {\n      if (!(instance instanceof Constructor))\n        @throwTypeError(\"Cannot call a class as a function\");\n    }\n    function _defineProperties(target, props) {\n      for (var i = 0;i < props.length; i++) {\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, (\"value\" in descriptor) && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);\n      }\n    }\n    function _createClass(Constructor, protoProps, staticProps) {\n      return protoProps && _defineProperties(Constructor.prototype, protoProps), staticProps && _defineProperties(Constructor, staticProps), Constructor;\n    }\n    function _possibleConstructorReturn(self, call) {\n      return call && (_typeof(call) === \"object\" || typeof call == \"function\") \? call : _assertThisInitialized(self);\n    }\n    function _assertThisInitialized(self) {\n      if (self === void 0)\n        throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n      return self;\n    }\n    function _inherits(subClass, superClass) {\n      if (typeof superClass != \"function\" && superClass !== null)\n        @throwTypeError(\"Super expression must either be null or a function\");\n      subClass.prototype = Object.create(superClass && superClass.prototype, {\n        constructor: { value: subClass, writable: !0, configurable: !0 }\n      }), superClass && _setPrototypeOf(subClass, superClass);\n    }\n    function _wrapNativeSuper(Class) {\n      var _cache = typeof Map == \"function\" \? new Map : void 0;\n      return _wrapNativeSuper = function(Class2) {\n        if (Class2 === null || !_isNativeFunction(Class2))\n          return Class2;\n        if (typeof Class2 != \"function\")\n          @throwTypeError(\"Super expression must either be null or a function\");\n        if (typeof _cache != \"undefined\") {\n          if (_cache.has(Class2))\n            return _cache.get(Class2);\n          _cache.set(Class2, Wrapper);\n        }\n        function Wrapper() {\n          return _construct(Class2, arguments, _getPrototypeOf(this).constructor);\n        }\n        return Wrapper.prototype = Object.create(Class2.prototype, {\n          constructor: {\n            value: Wrapper,\n            enumerable: !1,\n            writable: !0,\n            configurable: !0\n          }\n        }), _setPrototypeOf(Wrapper, Class2);\n      }, _wrapNativeSuper(Class);\n    }\n    function isNativeReflectConstruct() {\n      if (typeof Reflect == \"undefined\" || !Reflect.construct || Reflect.construct.sham)\n        return !1;\n      if (typeof Proxy == \"function\")\n        return !0;\n      try {\n        return Date.prototype.toString.call(Reflect.construct(Date, [], function() {\n        })), !0;\n      } catch {\n        return !1;\n      }\n    }\n    function _construct(Parent, args, Class) {\n      return isNativeReflectConstruct() \? _construct = Reflect.construct : _construct = function(Parent2, args2, Class2) {\n        var a = [null];\n        a.push.apply(a, args2);\n        var Constructor = Function.bind.apply(Parent2, a), instance = new Constructor;\n        return Class2 && _setPrototypeOf(instance, Class2.prototype), instance;\n      }, _construct.apply(null, arguments);\n    }\n    function _isNativeFunction(fn) {\n      return Function.toString.call(fn).indexOf(\"[native code]\") !== -1;\n    }\n    function _setPrototypeOf(o, p) {\n      return _setPrototypeOf = Object.setPrototypeOf || function(o2, p2) {\n        return o2.__proto__ = p2, o2;\n      }, _setPrototypeOf(o, p);\n    }\n    function _getPrototypeOf(o) {\n      return _getPrototypeOf = Object.setPrototypeOf \? Object.getPrototypeOf : function(o2) {\n        return o2.__proto__ || Object.getPrototypeOf(o2);\n      }, _getPrototypeOf(o);\n    }\n    function _typeof(obj) {\n      return typeof Symbol == \"function\" && typeof Symbol.iterator == \"symbol\" \? _typeof = function(obj2) {\n        return typeof obj2;\n      } : _typeof = function(obj2) {\n        return obj2 && typeof Symbol == \"function\" && obj2.constructor === Symbol && obj2 !== Symbol.prototype \? \"symbol\" : typeof obj2;\n      }, _typeof(obj);\n    }\n    var inspect = util.inspect, _require2 = require_errors(), ERR_INVALID_ARG_TYPE = _require2.codes.ERR_INVALID_ARG_TYPE;\n    function endsWith(str, search, this_len) {\n      return (this_len === void 0 || this_len > str.length) && (this_len = str.length), str.substring(this_len - search.length, this_len) === search;\n    }\n    function repeat(str, count) {\n      if (count = Math.floor(count), str.length == 0 || count == 0)\n        return \"\";\n      var maxCount = str.length * count;\n      for (count = Math.floor(Math.log(count) / Math.log(2));count; )\n        str += str, count--;\n      return str += str.substring(0, maxCount - str.length), str;\n    }\n    var blue = \"\", green = \"\", red = \"\", white = \"\", kReadableOperator = {\n      deepStrictEqual: \"Expected values to be strictly deep-equal:\",\n      strictEqual: \"Expected values to be strictly equal:\",\n      strictEqualObject: 'Expected \"actual\" to be reference-equal to \"expected\":',\n      deepEqual: \"Expected values to be loosely deep-equal:\",\n      equal: \"Expected values to be loosely equal:\",\n      notDeepStrictEqual: 'Expected \"actual\" not to be strictly deep-equal to:',\n      notStrictEqual: 'Expected \"actual\" to be strictly unequal to:',\n      notStrictEqualObject: 'Expected \"actual\" not to be reference-equal to \"expected\":',\n      notDeepEqual: 'Expected \"actual\" not to be loosely deep-equal to:',\n      notEqual: 'Expected \"actual\" to be loosely unequal to:',\n      notIdentical: \"Values identical but not reference-equal:\"\n    }, kMaxShortLength = 10;\n    function copyError(source) {\n      var keys = Object.keys(source), target = Object.create(Object.getPrototypeOf(source));\n      return keys.forEach(function(key) {\n        target[key] = source[key];\n      }), Object.defineProperty(target, \"message\", {\n        value: source.message\n      }), target;\n    }\n    function inspectValue(val) {\n      return inspect(val, {\n        compact: !1,\n        customInspect: !1,\n        depth: 1000,\n        maxArrayLength: Infinity,\n        showHidden: !1,\n        breakLength: Infinity,\n        showProxy: !1,\n        sorted: !0,\n        getters: !0\n      });\n    }\n    function createErrDiff(actual, expected, operator) {\n      var other = \"\", res = \"\", lastPos = 0, end = \"\", skipped = !1, actualInspected = inspectValue(actual), actualLines = actualInspected.split(`\n`), expectedLines = inspectValue(expected).split(`\n`), i = 0, indicator = \"\";\n      if (operator === \"strictEqual\" && _typeof(actual) === \"object\" && _typeof(expected) === \"object\" && actual !== null && expected !== null && (operator = \"strictEqualObject\"), actualLines.length === 1 && expectedLines.length === 1 && actualLines[0] !== expectedLines[0]) {\n        var inputLength = actualLines[0].length + expectedLines[0].length;\n        if (inputLength <= kMaxShortLength) {\n          if ((_typeof(actual) !== \"object\" || actual === null) && (_typeof(expected) !== \"object\" || expected === null) && (actual !== 0 || expected !== 0))\n            return \"\".concat(kReadableOperator[operator], `\n\n`) + \"\".concat(actualLines[0], \" !== \").concat(expectedLines[0], `\n`);\n        } else if (operator !== \"strictEqualObject\") {\n          var maxLength = process.stderr && process.stderr.isTTY \? process.stderr.columns : 80;\n          if (inputLength < maxLength) {\n            for (;actualLines[0][i] === expectedLines[0][i]; )\n              i++;\n            i > 2 && (indicator = `\n  `.concat(repeat(\" \", i), \"^\"), i = 0);\n          }\n        }\n      }\n      for (var a = actualLines[actualLines.length - 1], b = expectedLines[expectedLines.length - 1];a === b && (i++ < 2 \? end = `\n  `.concat(a).concat(end) : other = a, actualLines.pop(), expectedLines.pop(), !(actualLines.length === 0 || expectedLines.length === 0)); )\n        a = actualLines[actualLines.length - 1], b = expectedLines[expectedLines.length - 1];\n      var maxLines = Math.max(actualLines.length, expectedLines.length);\n      if (maxLines === 0) {\n        var _actualLines = actualInspected.split(`\n`);\n        if (_actualLines.length > 30)\n          for (_actualLines[26] = \"\".concat(blue, \"...\").concat(white);_actualLines.length > 27; )\n            _actualLines.pop();\n        return \"\".concat(kReadableOperator.notIdentical, `\n\n`).concat(_actualLines.join(`\n`), `\n`);\n      }\n      i > 3 && (end = `\n`.concat(blue, \"...\").concat(white).concat(end), skipped = !0), other !== \"\" && (end = `\n  `.concat(other).concat(end), other = \"\");\n      var printedLines = 0, msg = kReadableOperator[operator] + `\n`.concat(green, \"+ actual\").concat(white, \" \").concat(red, \"- expected\").concat(white), skippedMsg = \" \".concat(blue, \"...\").concat(white, \" Lines skipped\");\n      for (i = 0;i < maxLines; i++) {\n        var cur = i - lastPos;\n        if (actualLines.length < i + 1)\n          cur > 1 && i > 2 && (cur > 4 \? (res += `\n`.concat(blue, \"...\").concat(white), skipped = !0) : cur > 3 && (res += `\n  `.concat(expectedLines[i - 2]), printedLines++), res += `\n  `.concat(expectedLines[i - 1]), printedLines++), lastPos = i, other += `\n`.concat(red, \"-\").concat(white, \" \").concat(expectedLines[i]), printedLines++;\n        else if (expectedLines.length < i + 1)\n          cur > 1 && i > 2 && (cur > 4 \? (res += `\n`.concat(blue, \"...\").concat(white), skipped = !0) : cur > 3 && (res += `\n  `.concat(actualLines[i - 2]), printedLines++), res += `\n  `.concat(actualLines[i - 1]), printedLines++), lastPos = i, res += `\n`.concat(green, \"+\").concat(white, \" \").concat(actualLines[i]), printedLines++;\n        else {\n          var expectedLine = expectedLines[i], actualLine = actualLines[i], divergingLines = actualLine !== expectedLine && (!endsWith(actualLine, \",\") || actualLine.slice(0, -1) !== expectedLine);\n          divergingLines && endsWith(expectedLine, \",\") && expectedLine.slice(0, -1) === actualLine && (divergingLines = !1, actualLine += \",\"), divergingLines \? (cur > 1 && i > 2 && (cur > 4 \? (res += `\n`.concat(blue, \"...\").concat(white), skipped = !0) : cur > 3 && (res += `\n  `.concat(actualLines[i - 2]), printedLines++), res += `\n  `.concat(actualLines[i - 1]), printedLines++), lastPos = i, res += `\n`.concat(green, \"+\").concat(white, \" \").concat(actualLine), other += `\n`.concat(red, \"-\").concat(white, \" \").concat(expectedLine), printedLines += 2) : (res += other, other = \"\", (cur === 1 || i === 0) && (res += `\n  `.concat(actualLine), printedLines++));\n        }\n        if (printedLines > 20 && i < maxLines - 2)\n          return \"\".concat(msg).concat(skippedMsg, `\n`).concat(res, `\n`).concat(blue, \"...\").concat(white).concat(other, `\n`) + \"\".concat(blue, \"...\").concat(white);\n      }\n      return \"\".concat(msg).concat(skipped \? skippedMsg : \"\", `\n`).concat(res).concat(other).concat(end).concat(indicator);\n    }\n    var AssertionError = function(_Error) {\n      function AssertionError2(options) {\n        var _this;\n        if (_classCallCheck(this, AssertionError2), _typeof(options) !== \"object\" || options === null)\n          throw new ERR_INVALID_ARG_TYPE(\"options\", \"Object\", options);\n        var { message, operator, stackStartFn, actual, expected } = options, limit = Error.stackTraceLimit;\n        if (Error.stackTraceLimit = 0, message != null)\n          _this = _possibleConstructorReturn(this, _getPrototypeOf(AssertionError2).call(this, String(message)));\n        else if (process.stderr && process.stderr.isTTY && (process.stderr && process.stderr.getColorDepth && process.stderr.getColorDepth() !== 1 \? (blue = \"[34m\", green = \"[32m\", white = \"[39m\", red = \"[31m\") : (blue = \"\", green = \"\", white = \"\", red = \"\")), _typeof(actual) === \"object\" && actual !== null && _typeof(expected) === \"object\" && expected !== null && (\"stack\" in actual) && actual instanceof Error && (\"stack\" in expected) && expected instanceof Error && (actual = copyError(actual), expected = copyError(expected)), operator === \"deepStrictEqual\" || operator === \"strictEqual\")\n          _this = _possibleConstructorReturn(this, _getPrototypeOf(AssertionError2).call(this, createErrDiff(actual, expected, operator)));\n        else if (operator === \"notDeepStrictEqual\" || operator === \"notStrictEqual\") {\n          var base = kReadableOperator[operator], res = inspectValue(actual).split(`\n`);\n          if (operator === \"notStrictEqual\" && _typeof(actual) === \"object\" && actual !== null && (base = kReadableOperator.notStrictEqualObject), res.length > 30)\n            for (res[26] = \"\".concat(blue, \"...\").concat(white);res.length > 27; )\n              res.pop();\n          res.length === 1 \? _this = _possibleConstructorReturn(this, _getPrototypeOf(AssertionError2).call(this, \"\".concat(base, \" \").concat(res[0]))) : _this = _possibleConstructorReturn(this, _getPrototypeOf(AssertionError2).call(this, \"\".concat(base, `\n\n`).concat(res.join(`\n`), `\n`)));\n        } else {\n          var _res = inspectValue(actual), other = \"\", knownOperators = kReadableOperator[operator];\n          operator === \"notDeepEqual\" || operator === \"notEqual\" \? (_res = \"\".concat(kReadableOperator[operator], `\n\n`).concat(_res), _res.length > 1024 && (_res = \"\".concat(_res.slice(0, 1021), \"...\"))) : (other = \"\".concat(inspectValue(expected)), _res.length > 512 && (_res = \"\".concat(_res.slice(0, 509), \"...\")), other.length > 512 && (other = \"\".concat(other.slice(0, 509), \"...\")), operator === \"deepEqual\" || operator === \"equal\" \? _res = \"\".concat(knownOperators, `\n\n`).concat(_res, `\n\nshould equal\n\n`) : other = \" \".concat(operator, \" \").concat(other)), _this = _possibleConstructorReturn(this, _getPrototypeOf(AssertionError2).call(this, \"\".concat(_res).concat(other)));\n        }\n        return Error.stackTraceLimit = limit, _this.generatedMessage = !message, Object.defineProperty(_assertThisInitialized(_this), \"name\", {\n          value: \"AssertionError [ERR_ASSERTION]\",\n          enumerable: !1,\n          writable: !0,\n          configurable: !0\n        }), _this.code = \"ERR_ASSERTION\", _this.actual = actual, _this.expected = expected, _this.operator = operator, Error.captureStackTrace && Error.captureStackTrace(_assertThisInitialized(_this), stackStartFn), _this.stack, _this.name = \"AssertionError\", _possibleConstructorReturn(_this);\n      }\n      return AssertionError2.prototype = {}, _inherits(AssertionError2, _Error), _createClass(AssertionError2, [\n        {\n          key: \"toString\",\n          value: function() {\n            return \"\".concat(this.name, \" [\").concat(this.code, \"]: \").concat(this.message);\n          }\n        },\n        {\n          key: inspect.custom,\n          value: function(recurseTimes, ctx) {\n            return inspect(this, _objectSpread({}, ctx, {\n              customInspect: !1,\n              depth: 0\n            }));\n          }\n        }\n      ]), AssertionError2;\n    }(_wrapNativeSuper(Error));\n    module2.exports = AssertionError;\n  }\n}), require_assert = __commonJS({\n  \"assert/build/assert.js\"(exports, module2) {\n    function _typeof(obj) {\n      return typeof Symbol == \"function\" && typeof Symbol.iterator == \"symbol\" \? _typeof = function(obj2) {\n        return typeof obj2;\n      } : _typeof = function(obj2) {\n        return obj2 && typeof Symbol == \"function\" && obj2.constructor === Symbol && obj2 !== Symbol.prototype \? \"symbol\" : typeof obj2;\n      }, _typeof(obj);\n    }\n    function _classCallCheck(instance, Constructor) {\n      if (!(instance instanceof Constructor))\n        @throwTypeError(\"Cannot call a class as a function\");\n    }\n    var _require = require_errors(), _require$codes = _require.codes, ERR_AMBIGUOUS_ARGUMENT = _require$codes.ERR_AMBIGUOUS_ARGUMENT, ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE, ERR_INVALID_ARG_VALUE = _require$codes.ERR_INVALID_ARG_VALUE, ERR_INVALID_RETURN_VALUE = _require$codes.ERR_INVALID_RETURN_VALUE, ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS, AssertionError = require_assertion_error(), _require2 = util, inspect = _require2.inspect, _require$types = util.types, isPromise = _require$types.isPromise, isRegExp = _require$types.isRegExp, objectAssign = Object.assign, objectIs = Object.is, errorCache = new Map, warned = !1, assert = module2.exports = ok, NO_EXCEPTION_SENTINEL = {};\n    function innerFail(obj) {\n      throw obj.message instanceof Error \? obj.message : new AssertionError(obj);\n    }\n    function fail(actual, expected, message, operator, stackStartFn) {\n      var argsLen = arguments.length, internalMessage;\n      if (argsLen === 0)\n        internalMessage = \"Failed\";\n      else if (argsLen === 1)\n        message = actual, actual = void 0;\n      else {\n        if (warned === !1) {\n          warned = !0;\n          var warn = process.emitWarning \? process.emitWarning : console.warn.bind(console);\n          warn(\"assert.fail() with more than one argument is deprecated. Please use assert.strictEqual() instead or only pass a message.\", \"DeprecationWarning\", \"DEP0094\");\n        }\n        argsLen === 2 && (operator = \"!=\");\n      }\n      if (message instanceof Error)\n        throw message;\n      var errArgs = {\n        actual,\n        expected,\n        operator: operator === void 0 \? \"fail\" : operator,\n        stackStartFn: stackStartFn || fail\n      };\n      message !== void 0 && (errArgs.message = message);\n      var err = new AssertionError(errArgs);\n      throw internalMessage && (err.message = internalMessage, err.generatedMessage = !0), err;\n    }\n    assert.fail = fail, assert.AssertionError = AssertionError;\n    function innerOk(fn, argLen, value, message) {\n      if (!value) {\n        var generatedMessage = !1;\n        if (argLen === 0)\n          generatedMessage = !0, message = \"No value argument passed to `assert.ok()`\";\n        else if (message instanceof Error)\n          throw message;\n        var err = new AssertionError({\n          actual: value,\n          expected: !0,\n          message,\n          operator: \"==\",\n          stackStartFn: fn\n        });\n        throw err.generatedMessage = generatedMessage, err;\n      }\n    }\n    function ok() {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0;_key < _len; _key++)\n        args[_key] = arguments[_key];\n      innerOk.apply(void 0, [ok, args.length].concat(args));\n    }\n    assert.ok = ok, assert.equal = function equal(actual, expected, message) {\n      if (arguments.length < 2)\n        throw new ERR_MISSING_ARGS(\"actual\", \"expected\");\n      actual != expected && innerFail({\n        actual,\n        expected,\n        message,\n        operator: \"==\",\n        stackStartFn: equal\n      });\n    }, assert.notEqual = function notEqual(actual, expected, message) {\n      if (arguments.length < 2)\n        throw new ERR_MISSING_ARGS(\"actual\", \"expected\");\n      actual == expected && innerFail({\n        actual,\n        expected,\n        message,\n        operator: \"!=\",\n        stackStartFn: notEqual\n      });\n    }, assert.deepEqual = function deepEqual(actual, expected, message) {\n      if (arguments.length < 2)\n        throw new ERR_MISSING_ARGS(\"actual\", \"expected\");\n      isDeepEqual(actual, expected, !1) || innerFail({\n        actual,\n        expected,\n        message,\n        operator: \"deepEqual\",\n        stackStartFn: deepEqual\n      });\n    }, assert.notDeepEqual = function notDeepEqual(actual, expected, message) {\n      if (arguments.length < 2)\n        throw new ERR_MISSING_ARGS(\"actual\", \"expected\");\n      isDeepEqual(actual, expected, !1) && innerFail({\n        actual,\n        expected,\n        message,\n        operator: \"notDeepEqual\",\n        stackStartFn: notDeepEqual\n      });\n    }, assert.deepStrictEqual = function deepStrictEqual(actual, expected, message) {\n      if (arguments.length < 2)\n        throw new ERR_MISSING_ARGS(\"actual\", \"expected\");\n      isDeepEqual(actual, expected, !0) || innerFail({\n        actual,\n        expected,\n        message,\n        operator: \"deepStrictEqual\",\n        stackStartFn: deepStrictEqual\n      });\n    }, assert.notDeepStrictEqual = notDeepStrictEqual;\n    function notDeepStrictEqual(actual, expected, message) {\n      if (arguments.length < 2)\n        throw new ERR_MISSING_ARGS(\"actual\", \"expected\");\n      isDeepEqual(actual, expected, !0) && innerFail({\n        actual,\n        expected,\n        message,\n        operator: \"notDeepStrictEqual\",\n        stackStartFn: notDeepStrictEqual\n      });\n    }\n    assert.strictEqual = function strictEqual(actual, expected, message) {\n      if (arguments.length < 2)\n        throw new ERR_MISSING_ARGS(\"actual\", \"expected\");\n      objectIs(actual, expected) || innerFail({\n        actual,\n        expected,\n        message,\n        operator: \"strictEqual\",\n        stackStartFn: strictEqual\n      });\n    }, assert.notStrictEqual = function notStrictEqual(actual, expected, message) {\n      if (arguments.length < 2)\n        throw new ERR_MISSING_ARGS(\"actual\", \"expected\");\n      objectIs(actual, expected) && innerFail({\n        actual,\n        expected,\n        message,\n        operator: \"notStrictEqual\",\n        stackStartFn: notStrictEqual\n      });\n    }, assert.match = function match(actual, expected, message) {\n      if (arguments.length < 2)\n        throw new ERR_MISSING_ARGS(\"actual\", \"expected\");\n      if (!isRegExp(expected))\n        throw new ERR_INVALID_ARG_TYPE(\"expected\", \"RegExp\", expected);\n      expected.test(actual) || innerFail({\n        actual,\n        expected,\n        message,\n        operator: \"match\",\n        stackStartFn: match\n      });\n    };\n    var Comparison = function Comparison2(obj, keys, actual) {\n      var _this = this;\n      _classCallCheck(this, Comparison2), keys.forEach(function(key) {\n        (key in obj) && (actual !== void 0 && typeof actual[key] == \"string\" && isRegExp(obj[key]) && obj[key].test(actual[key]) \? _this[key] = actual[key] : _this[key] = obj[key]);\n      });\n    };\n    function compareExceptionKey(actual, expected, key, message, keys, fn) {\n      if (!(key in actual) || !isDeepEqual(actual[key], expected[key], !0)) {\n        if (!message) {\n          var a = new Comparison(actual, keys), b = new Comparison(expected, keys, actual), err = new AssertionError({\n            actual: a,\n            expected: b,\n            operator: \"deepStrictEqual\",\n            stackStartFn: fn\n          });\n          throw err.actual = actual, err.expected = expected, err.operator = fn.name, err;\n        }\n        innerFail({\n          actual,\n          expected,\n          message,\n          operator: fn.name,\n          stackStartFn: fn\n        });\n      }\n    }\n    function expectedException(actual, expected, msg, fn) {\n      if (typeof expected != \"function\") {\n        if (isRegExp(expected))\n          return expected.test(actual);\n        if (arguments.length === 2)\n          throw new ERR_INVALID_ARG_TYPE(\"expected\", [\"Function\", \"RegExp\"], expected);\n        if (_typeof(actual) !== \"object\" || actual === null) {\n          var err = new AssertionError({\n            actual,\n            expected,\n            message: msg,\n            operator: \"deepStrictEqual\",\n            stackStartFn: fn\n          });\n          throw err.operator = fn.name, err;\n        }\n        var keys = Object.keys(expected);\n        if (expected instanceof Error)\n          keys.push(\"name\", \"message\");\n        else if (keys.length === 0)\n          throw new ERR_INVALID_ARG_VALUE(\"error\", expected, \"may not be an empty object\");\n        return keys.forEach(function(key) {\n          return typeof actual[key] == \"string\" && isRegExp(expected[key]) && expected[key].test(actual[key]) || compareExceptionKey(actual, expected, key, msg, keys, fn);\n        }), !0;\n      }\n      return expected.prototype !== void 0 && actual instanceof expected \? !0 : Error.isPrototypeOf(expected) \? !1 : expected.call({}, actual) === !0;\n    }\n    function getActual(fn) {\n      if (typeof fn != \"function\")\n        throw new ERR_INVALID_ARG_TYPE(\"fn\", \"Function\", fn);\n      try {\n        fn();\n      } catch (e) {\n        return e;\n      }\n      return NO_EXCEPTION_SENTINEL;\n    }\n    function checkIsPromise(obj) {\n      return isPromise(obj) || obj !== null && _typeof(obj) === \"object\" && typeof obj.then == \"function\" && typeof obj.catch == \"function\";\n    }\n    function waitForActual(promiseFn) {\n      return Promise.resolve().then(function() {\n        var resultPromise;\n        if (typeof promiseFn == \"function\") {\n          if (resultPromise = promiseFn(), !checkIsPromise(resultPromise))\n            throw new ERR_INVALID_RETURN_VALUE(\"instance of Promise\", \"promiseFn\", resultPromise);\n        } else if (checkIsPromise(promiseFn))\n          resultPromise = promiseFn;\n        else\n          throw new ERR_INVALID_ARG_TYPE(\"promiseFn\", [\"Function\", \"Promise\"], promiseFn);\n        return Promise.resolve().then(function() {\n          return resultPromise;\n        }).then(function() {\n          return NO_EXCEPTION_SENTINEL;\n        }).catch(function(e) {\n          return e;\n        });\n      });\n    }\n    function expectsError(stackStartFn, actual, error, message) {\n      if (typeof error == \"string\") {\n        if (arguments.length === 4)\n          throw new ERR_INVALID_ARG_TYPE(\"error\", [\"Object\", \"Error\", \"Function\", \"RegExp\"], error);\n        if (_typeof(actual) === \"object\" && actual !== null) {\n          if (actual.message === error)\n            throw new ERR_AMBIGUOUS_ARGUMENT(\"error/message\", 'The error message \"'.concat(actual.message, '\" is identical to the message.'));\n        } else if (actual === error)\n          throw new ERR_AMBIGUOUS_ARGUMENT(\"error/message\", 'The error \"'.concat(actual, '\" is identical to the message.'));\n        message = error, error = void 0;\n      } else if (error != null && _typeof(error) !== \"object\" && typeof error != \"function\")\n        throw new ERR_INVALID_ARG_TYPE(\"error\", [\"Object\", \"Error\", \"Function\", \"RegExp\"], error);\n      if (actual === NO_EXCEPTION_SENTINEL) {\n        var details = \"\";\n        error && error.name && (details += \" (\".concat(error.name, \")\")), details += message \? \": \".concat(message) : \".\";\n        var fnType = stackStartFn.name === \"rejects\" \? \"rejection\" : \"exception\";\n        innerFail({\n          actual: void 0,\n          expected: error,\n          operator: stackStartFn.name,\n          message: \"Missing expected \".concat(fnType).concat(details),\n          stackStartFn\n        });\n      }\n      if (error && !expectedException(actual, error, message, stackStartFn))\n        throw actual;\n    }\n    function expectsNoError(stackStartFn, actual, error, message) {\n      if (actual !== NO_EXCEPTION_SENTINEL) {\n        if (typeof error == \"string\" && (message = error, error = void 0), !error || expectedException(actual, error)) {\n          var details = message \? \": \".concat(message) : \".\", fnType = stackStartFn.name === \"doesNotReject\" \? \"rejection\" : \"exception\";\n          innerFail({\n            actual,\n            expected: error,\n            operator: stackStartFn.name,\n            message: \"Got unwanted \".concat(fnType).concat(details, `\n`) + 'Actual message: \"'.concat(actual && actual.message, '\"'),\n            stackStartFn\n          });\n        }\n        throw actual;\n      }\n    }\n    assert.throws = function throws(promiseFn) {\n      for (var _len2 = arguments.length, args = new Array(_len2 > 1 \? _len2 - 1 : 0), _key2 = 1;_key2 < _len2; _key2++)\n        args[_key2 - 1] = arguments[_key2];\n      expectsError.apply(void 0, [throws, getActual(promiseFn)].concat(args));\n    }, assert.rejects = function rejects(promiseFn) {\n      for (var _len3 = arguments.length, args = new Array(_len3 > 1 \? _len3 - 1 : 0), _key3 = 1;_key3 < _len3; _key3++)\n        args[_key3 - 1] = arguments[_key3];\n      return waitForActual(promiseFn).then(function(result) {\n        return expectsError.apply(void 0, [rejects, result].concat(args));\n      });\n    }, assert.doesNotThrow = function doesNotThrow(fn) {\n      for (var _len4 = arguments.length, args = new Array(_len4 > 1 \? _len4 - 1 : 0), _key4 = 1;_key4 < _len4; _key4++)\n        args[_key4 - 1] = arguments[_key4];\n      expectsNoError.apply(void 0, [doesNotThrow, getActual(fn)].concat(args));\n    }, assert.doesNotReject = function doesNotReject(fn) {\n      for (var _len5 = arguments.length, args = new Array(_len5 > 1 \? _len5 - 1 : 0), _key5 = 1;_key5 < _len5; _key5++)\n        args[_key5 - 1] = arguments[_key5];\n      return waitForActual(fn).then(function(result) {\n        return expectsNoError.apply(void 0, [doesNotReject, result].concat(args));\n      });\n    }, assert.ifError = function ifError(err) {\n      if (err != null) {\n        var message = \"ifError got unwanted exception: \";\n        _typeof(err) === \"object\" && typeof err.message == \"string\" \? err.message.length === 0 && err.constructor \? message += err.constructor.name : message += err.message : message += inspect(err);\n        var newErr = new AssertionError({\n          actual: err,\n          expected: null,\n          operator: \"ifError\",\n          message,\n          stackStartFn: ifError\n        }), origStack = err.stack;\n        if (typeof origStack == \"string\") {\n          var tmp2 = origStack.split(`\n`);\n          tmp2.shift();\n          for (var tmp1 = newErr.stack.split(`\n`), i = 0;i < tmp2.length; i++) {\n            var pos = tmp1.indexOf(tmp2[i]);\n            if (pos !== -1) {\n              tmp1 = tmp1.slice(0, pos);\n              break;\n            }\n          }\n          newErr.stack = \"\".concat(tmp1.join(`\n`), `\n`).concat(tmp2.join(`\n`));\n        }\n        throw newErr;\n      }\n    };\n    function strict() {\n      for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0;_key6 < _len6; _key6++)\n        args[_key6] = arguments[_key6];\n      innerOk.apply(void 0, [strict, args.length].concat(args));\n    }\n    assert.strict = objectAssign(strict, assert, {\n      equal: assert.strictEqual,\n      deepEqual: assert.deepStrictEqual,\n      notEqual: assert.notStrictEqual,\n      notDeepEqual: assert.notDeepStrictEqual\n    }), assert.strict.strict = assert.strict;\n  }\n}), assert_module = require_assert();\nassert_module.CallTracker = CallTracker;\nreturn assert_module})\n"_s;
//

//
static constexpr ASCIILiteral NodeAssertStrictCode = "(function (){\"use strict\";// src/js/out/tmp/node/assert.strict.ts\nreturn (@getInternalField(@internalModuleRegistry, 4) || @createInternalModuleById(4)).strict})\n"_s;
//

//
static constexpr ASCIILiteral NodeAsyncHooksCode = "(function (){\"use strict\";// src/js/out/tmp/node/async_hooks.ts\nvar get = function() {\n  return @getInternalField(@asyncContext, 0);\n}, set = function(contextValue) {\n  return @putInternalField(@asyncContext, 0, contextValue);\n}, createWarning = function(message) {\n  let warned = !1;\n  var wrapped = function() {\n    if (warned)\n      return;\n    if (new Error().stack.includes(\"zx/build/core.js\"))\n      return;\n    warned = !0, console.warn(\"[bun] Warning:\", message);\n  };\n  return wrapped;\n}, createHook = function(callbacks) {\n  return {\n    enable: createHookNotImpl,\n    disable: createHookNotImpl\n  };\n}, executionAsyncId = function() {\n  return executionAsyncIdNotImpl(), 0;\n}, triggerAsyncId = function() {\n  return 0;\n}, executionAsyncResource = function() {\n  return executionAsyncResourceWarning(), process.stdin;\n}, $, { cleanupLater } = globalThis[globalThis.Symbol.for('Bun.lazy')](\"async_hooks\");\n\nclass AsyncLocalStorage {\n  #disableCalled = !1;\n  constructor() {\n  }\n  static bind(fn, ...args) {\n    return this.snapshot().bind(null, fn, ...args);\n  }\n  static snapshot() {\n    var context = get();\n    return (fn, ...args) => {\n      var prev = get();\n      set(context);\n      try {\n        return fn(...args);\n      } catch (error) {\n        throw error;\n      } finally {\n        set(prev);\n      }\n    };\n  }\n  enterWith(store) {\n    cleanupLater();\n    var context = get();\n    if (!context) {\n      set([this, store]);\n      return;\n    }\n    var { length } = context;\n    for (var i = 0;i < length; i += 2)\n      if (context[i] === this) {\n        const clone = context.slice();\n        clone[i + 1] = store, set(clone);\n        return;\n      }\n    set(context.concat(this, store));\n  }\n  exit(cb, ...args) {\n    return this.run(void 0, cb, ...args);\n  }\n  run(store, callback, ...args) {\n    var context = get(), hasPrevious = !1, previous, i = 0, contextWasInit = !context;\n    if (contextWasInit)\n      set(context = [this, store]);\n    else {\n      if (context = context.slice(), i = context.indexOf(this), i > -1)\n        hasPrevious = !0, previous = context[i + 1], context[i + 1] = store;\n      else\n        context.push(this, store);\n      set(context);\n    }\n    try {\n      return callback(...args);\n    } catch (e) {\n      throw e;\n    } finally {\n      if (!this.#disableCalled) {\n        var context2 = get();\n        if (context2 === context && contextWasInit)\n          set(void 0);\n        else if (context2 = context2.slice(), hasPrevious)\n          context2[i + 1] = previous, set(context2);\n        else\n          context2.splice(i, 2), set(context2.length \? context2 : void 0);\n      }\n    }\n  }\n  disable() {\n    if (!this.#disableCalled) {\n      var context = get();\n      if (context) {\n        var { length } = context;\n        for (var i = 0;i < length; i += 2)\n          if (context[i] === this) {\n            context.splice(i, 2), set(context.length \? context : void 0);\n            break;\n          }\n      }\n      this.#disableCalled = !0;\n    }\n  }\n  getStore() {\n    var context = get();\n    if (!context)\n      return;\n    var { length } = context;\n    for (var i = 0;i < length; i += 2)\n      if (context[i] === this)\n        return context[i + 1];\n  }\n}\n\nclass AsyncResource {\n  type;\n  #snapshot;\n  constructor(type, options) {\n    if (typeof type !== \"string\")\n      @throwTypeError('The \"type\" argument must be of type string. Received type ' + typeof type);\n    this.type = type, this.#snapshot = get();\n  }\n  emitBefore() {\n    return !0;\n  }\n  emitAfter() {\n    return !0;\n  }\n  asyncId() {\n    return 0;\n  }\n  triggerAsyncId() {\n    return 0;\n  }\n  emitDestroy() {\n  }\n  runInAsyncScope(fn, thisArg, ...args) {\n    var prev = get();\n    set(this.#snapshot);\n    try {\n      return fn.apply(thisArg, args);\n    } catch (error) {\n      throw error;\n    } finally {\n      set(prev);\n    }\n  }\n}\nvar createHookNotImpl = createWarning(\"async_hooks.createHook is not implemented in Bun. Hooks can still be created but will never be called.\"), executionAsyncIdNotImpl = createWarning(\"async_hooks.executionAsyncId/triggerAsyncId are not implemented in Bun. It will return 0 every time.\"), executionAsyncResourceWarning = createWarning(\"async_hooks.executionAsyncResource is not implemented in Bun. It returns a reference to process.stdin every time.\"), asyncWrapProviders = {\n  NONE: 0,\n  DIRHANDLE: 1,\n  DNSCHANNEL: 2,\n  ELDHISTOGRAM: 3,\n  FILEHANDLE: 4,\n  FILEHANDLECLOSEREQ: 5,\n  FIXEDSIZEBLOBCOPY: 6,\n  FSEVENTWRAP: 7,\n  FSREQCALLBACK: 8,\n  FSREQPROMISE: 9,\n  GETADDRINFOREQWRAP: 10,\n  GETNAMEINFOREQWRAP: 11,\n  HEAPSNAPSHOT: 12,\n  HTTP2SESSION: 13,\n  HTTP2STREAM: 14,\n  HTTP2PING: 15,\n  HTTP2SETTINGS: 16,\n  HTTPINCOMINGMESSAGE: 17,\n  HTTPCLIENTREQUEST: 18,\n  JSSTREAM: 19,\n  JSUDPWRAP: 20,\n  MESSAGEPORT: 21,\n  PIPECONNECTWRAP: 22,\n  PIPESERVERWRAP: 23,\n  PIPEWRAP: 24,\n  PROCESSWRAP: 25,\n  PROMISE: 26,\n  QUERYWRAP: 27,\n  SHUTDOWNWRAP: 28,\n  SIGNALWRAP: 29,\n  STATWATCHER: 30,\n  STREAMPIPE: 31,\n  TCPCONNECTWRAP: 32,\n  TCPSERVERWRAP: 33,\n  TCPWRAP: 34,\n  TTYWRAP: 35,\n  UDPSENDWRAP: 36,\n  UDPWRAP: 37,\n  SIGINTWATCHDOG: 38,\n  WORKER: 39,\n  WORKERHEAPSNAPSHOT: 40,\n  WRITEWRAP: 41,\n  ZLIB: 42,\n  CHECKPRIMEREQUEST: 43,\n  PBKDF2REQUEST: 44,\n  KEYPAIRGENREQUEST: 45,\n  KEYGENREQUEST: 46,\n  KEYEXPORTREQUEST: 47,\n  CIPHERREQUEST: 48,\n  DERIVEBITSREQUEST: 49,\n  HASHREQUEST: 50,\n  RANDOMBYTESREQUEST: 51,\n  RANDOMPRIMEREQUEST: 52,\n  SCRYPTREQUEST: 53,\n  SIGNREQUEST: 54,\n  TLSWRAP: 55,\n  VERIFYREQUEST: 56,\n  INSPECTORJSBINDING: 57\n};\n$ = {\n  AsyncLocalStorage,\n  createHook,\n  executionAsyncId,\n  triggerAsyncId,\n  executionAsyncResource,\n  asyncWrapProviders,\n  AsyncResource\n};\nreturn $})\n"_s;
//

//
static constexpr ASCIILiteral NodeChildProcessCode = "(function (){\"use strict\";// src/js/out/tmp/node/child_process.ts\nvar spawn = function(file, args, options) {\n  options = normalizeSpawnArguments(file, args, options), validateTimeout(options.timeout), validateAbortSignal(options.signal, \"options.signal\");\n  const killSignal2 = sanitizeKillSignal(options.killSignal), child = new ChildProcess;\n  if (child.spawn(options), options.timeout > 0) {\n    let timeoutId = setTimeout(() => {\n      if (timeoutId) {\n        try {\n          child.kill(killSignal2);\n        } catch (err) {\n          child.emit(\"error\", err);\n        }\n        timeoutId = null;\n      }\n    });\n    child.once(\"exit\", () => {\n      if (timeoutId)\n        clearTimeout(timeoutId), timeoutId = null;\n    });\n  }\n  if (options.signal) {\n    let onAbortListener2 = function() {\n      abortChildProcess(child, killSignal2, options.signal.reason);\n    };\n    var onAbortListener = onAbortListener2;\n    const signal = options.signal;\n    if (signal.aborted)\n      process.nextTick(onAbortListener2);\n    else\n      signal.addEventListener(\"abort\", onAbortListener2, { once: !0 }), child.once(\"exit\", () => signal.removeEventListener(\"abort\", onAbortListener2));\n  }\n  return child;\n}, execFile = function(file, args, options, callback) {\n  ({ file, args, options, callback } = normalizeExecFileArgs(file, args, options, callback)), options = {\n    encoding: \"utf8\",\n    timeout: 0,\n    maxBuffer: MAX_BUFFER,\n    killSignal: \"SIGTERM\",\n    cwd: null,\n    env: null,\n    shell: !1,\n    ...options\n  };\n  const maxBuffer = options.maxBuffer;\n  validateTimeout(options.timeout), validateMaxBuffer(maxBuffer), options.killSignal = sanitizeKillSignal(options.killSignal);\n  const child = spawn(file, args, {\n    cwd: options.cwd,\n    env: options.env,\n    shell: options.shell,\n    signal: options.signal\n  });\n  let encoding;\n  const _stdout = [], _stderr = [];\n  if (options.encoding !== \"buffer\" && BufferIsEncoding(options.encoding))\n    encoding = options.encoding;\n  else\n    encoding = null;\n  let stdoutLen = 0, stderrLen = 0, killed = !1, exited = !1, timeoutId, encodedStdoutLen, encodedStderrLen, ex = null, cmd = file;\n  function exitHandler(code, signal) {\n    if (exited)\n      return;\n    if (exited = !0, timeoutId)\n      clearTimeout(timeoutId), timeoutId = null;\n    if (!callback)\n      return;\n    const readableEncoding = child\?.stdout\?.readableEncoding;\n    let stdout, stderr;\n    if (encoding || child.stdout && readableEncoding)\n      stdout = ArrayPrototypeJoin.call(_stdout, \"\");\n    else\n      stdout = BufferConcat(_stdout);\n    if (encoding || child.stderr && readableEncoding)\n      stderr = ArrayPrototypeJoin.call(_stderr, \"\");\n    else\n      stderr = BufferConcat(_stderr);\n    if (!ex && code === 0 && signal === null) {\n      callback(null, stdout, stderr);\n      return;\n    }\n    if (args\?.length)\n      cmd += ` ${ArrayPrototypeJoin.call(args, \" \")}`;\n    if (!ex) {\n      let message = `Command failed: ${cmd}`;\n      if (stderr)\n        message += `\\n${stderr}`;\n      ex = genericNodeError(message, {\n        code,\n        killed: child.killed || killed,\n        signal\n      });\n    }\n    ex.cmd = cmd, callback(ex, stdout, stderr);\n  }\n  function errorHandler(e) {\n    if (ex = e, child.stdout)\n      child.stdout.destroy();\n    if (child.stderr)\n      child.stderr.destroy();\n    exitHandler();\n  }\n  function kill() {\n    if (child.stdout)\n      child.stdout.destroy();\n    if (child.stderr)\n      child.stderr.destroy();\n    killed = !0;\n    try {\n      child.kill(options.killSignal);\n    } catch (e) {\n      ex = e, exitHandler();\n    }\n  }\n  if (options.timeout > 0)\n    timeoutId = setTimeout(function delayedKill() {\n      kill(), timeoutId = null;\n    }, options.timeout);\n  if (child.stdout) {\n    if (encoding)\n      child.stdout.setEncoding(encoding);\n    child.stdout.on(\"data\", maxBuffer === Infinity \? function onUnlimitedSizeBufferedData(chunk) {\n      ArrayPrototypePush.call(_stdout, chunk);\n    } : encoding \? function onChildStdoutEncoded(chunk) {\n      if (stdoutLen += chunk.length, stdoutLen * 4 > maxBuffer) {\n        const encoding2 = child.stdout.readableEncoding, actualLen = Buffer.byteLength(chunk, encoding2);\n        if (encodedStdoutLen === void 0)\n          for (let i = 0;i < _stdout.length; i++)\n            encodedStdoutLen += Buffer.byteLength(_stdout[i], encoding2);\n        else\n          encodedStdoutLen += actualLen;\n        const truncatedLen = maxBuffer - (encodedStdoutLen - actualLen);\n        ArrayPrototypePush.call(_stdout, StringPrototypeSlice.apply(chunk, 0, truncatedLen)), ex = new ERR_CHILD_PROCESS_STDIO_MAXBUFFER(\"stdout\"), kill();\n      } else\n        ArrayPrototypePush.call(_stdout, chunk);\n    } : function onChildStdoutRaw(chunk) {\n      if (stdoutLen += chunk.length, stdoutLen > maxBuffer) {\n        const truncatedLen = maxBuffer - (stdoutLen - chunk.length);\n        ArrayPrototypePush.call(_stdout, chunk.slice(0, truncatedLen)), ex = new ERR_CHILD_PROCESS_STDIO_MAXBUFFER(\"stdout\"), kill();\n      } else\n        ArrayPrototypePush.call(_stdout, chunk);\n    });\n  }\n  if (child.stderr) {\n    if (encoding)\n      child.stderr.setEncoding(encoding);\n    child.stderr.on(\"data\", maxBuffer === Infinity \? function onUnlimitedSizeBufferedData(chunk) {\n      ArrayPrototypePush.call(_stderr, chunk);\n    } : encoding \? function onChildStderrEncoded(chunk) {\n      if (stderrLen += chunk.length, stderrLen * 4 > maxBuffer) {\n        const encoding2 = child.stderr.readableEncoding, actualLen = Buffer.byteLength(chunk, encoding2);\n        if (encodedStderrLen === void 0)\n          for (let i = 0;i < _stderr.length; i++)\n            encodedStderrLen += Buffer.byteLength(_stderr[i], encoding2);\n        else\n          encodedStderrLen += actualLen;\n        const truncatedLen = maxBuffer - (encodedStderrLen - actualLen);\n        ArrayPrototypePush.call(_stderr, StringPrototypeSlice.call(chunk, 0, truncatedLen)), ex = new ERR_CHILD_PROCESS_STDIO_MAXBUFFER(\"stderr\"), kill();\n      } else\n        ArrayPrototypePush.call(_stderr, chunk);\n    } : function onChildStderrRaw(chunk) {\n      if (stderrLen += chunk.length, stderrLen > maxBuffer) {\n        const truncatedLen = maxBuffer - (stderrLen - chunk.length);\n        ArrayPrototypePush.call(_stderr, StringPrototypeSlice.call(chunk, 0, truncatedLen)), ex = new ERR_CHILD_PROCESS_STDIO_MAXBUFFER(\"stderr\"), kill();\n      } else\n        ArrayPrototypePush.call(_stderr, chunk);\n    });\n  }\n  return child.addListener(\"close\", exitHandler), child.addListener(\"error\", errorHandler), child;\n}, exec = function(command, options, callback) {\n  const opts = normalizeExecArgs(command, options, callback);\n  return execFile(opts.file, opts.options, opts.callback);\n}, spawnSync = function(file, args, options) {\n  options = {\n    maxBuffer: MAX_BUFFER,\n    ...normalizeSpawnArguments(file, args, options)\n  };\n  const { maxBuffer, encoding } = options;\n  validateTimeout(options.timeout), validateMaxBuffer(maxBuffer), options.killSignal = sanitizeKillSignal(options.killSignal);\n  const stdio = options.stdio || \"pipe\", bunStdio = getBunStdioFromOptions(stdio);\n  var { input } = options;\n  if (input)\n    if (ArrayBufferIsView(input))\n      bunStdio[0] = input;\n    else if (typeof input === \"string\")\n      bunStdio[0] = Buffer.from(input, encoding || \"utf8\");\n    else\n      throw new ERR_INVALID_ARG_TYPE(\"options.stdio[0]\", [\"Buffer\", \"TypedArray\", \"DataView\", \"string\"], input);\n  const { stdout, stderr, success, exitCode } = Bun.spawnSync({\n    cmd: options.args,\n    env: options.env || void 0,\n    cwd: options.cwd || void 0,\n    stdin: bunStdio[0],\n    stdout: bunStdio[1],\n    stderr: bunStdio[2]\n  }), result = {\n    signal: null,\n    status: exitCode,\n    output: [null, stdout, stderr]\n  };\n  if (stdout && encoding && encoding !== \"buffer\")\n    result.output[1] = result.output[1]\?.toString(encoding);\n  if (stderr && encoding && encoding !== \"buffer\")\n    result.output[2] = result.output[2]\?.toString(encoding);\n  if (result.stdout = result.output[1], result.stderr = result.output[2], !success)\n    result.error = new SystemError(result.output[2], options.file, \"spawnSync\", -1, result.status), result.error.spawnargs = ArrayPrototypeSlice.call(options.args, 1);\n  return result;\n}, execFileSync = function(file, args, options) {\n  ({ file, args, options } = normalizeExecFileArgs(file, args, options));\n  const ret = spawnSync(file, args, options), errArgs = [options.argv0 || file];\n  ArrayPrototypePush.apply(errArgs, args);\n  const err = checkExecSyncError(ret, errArgs);\n  if (err)\n    throw err;\n  return ret.stdout;\n}, execSync = function(command, options) {\n  const opts = normalizeExecArgs(command, options, null), ret = spawnSync(opts.file, opts.options), err = checkExecSyncError(ret, void 0, command);\n  if (err)\n    throw err;\n  return ret.stdout;\n}, stdioStringToArray = function(stdio, channel) {\n  const options = [];\n  switch (stdio) {\n    case \"ignore\":\n    case \"overlapped\":\n    case \"pipe\":\n      ArrayPrototypePush.call(options, stdio, stdio, stdio);\n      break;\n    case \"inherit\":\n      ArrayPrototypePush.call(options, 0, 1, 2);\n      break;\n    default:\n      throw new ERR_INVALID_ARG_VALUE(\"stdio\", stdio);\n  }\n  if (channel)\n    ArrayPrototypePush.call(options, channel);\n  return options;\n}, fork = function(modulePath, args = [], options) {\n  modulePath = getValidatedPath(modulePath, \"modulePath\");\n  let execArgv;\n  if (args == null)\n    args = [];\n  else if (typeof args === \"object\" && !ArrayIsArray(args))\n    options = args, args = [];\n  else\n    validateArray(args, \"args\");\n  if (options != null)\n    validateObject(options, \"options\");\n  if (options = { __proto__: null, ...options, shell: !1 }, options.execPath = options.execPath || process.execPath, validateArgumentNullCheck(options.execPath, \"options.execPath\"), execArgv = options.execArgv || process.execArgv, validateArgumentsNullCheck(execArgv, \"options.execArgv\"), execArgv === process.execArgv && process._eval != null) {\n    const index = ArrayPrototypeLastIndexOf.call(execArgv, process._eval);\n    if (index > 0)\n      execArgv = ArrayPrototypeSlice.call(execArgv), ArrayPrototypeSplice.call(execArgv, index - 1, 2);\n  }\n  if (args = [...execArgv, modulePath, ...args], typeof options.stdio === \"string\")\n    options.stdio = stdioStringToArray(options.stdio, \"ipc\");\n  else if (!ArrayIsArray(options.stdio))\n    options.stdio = stdioStringToArray(options.silent \? \"pipe\" : \"inherit\", \"ipc\");\n  else if (!ArrayPrototypeIncludes.call(options.stdio, \"ipc\"))\n    throw new ERR_CHILD_PROCESS_IPC_REQUIRED(\"options.stdio\");\n  return spawn(options.execPath, args, options);\n}, convertToValidSignal = function(signal) {\n  if (typeof signal === \"number\" && getSignalsToNamesMapping()[signal])\n    return signal;\n  if (typeof signal === \"string\") {\n    const signalName = signals[StringPrototypeToUpperCase.call(signal)];\n    if (signalName)\n      return signalName;\n  }\n  throw new ERR_UNKNOWN_SIGNAL(signal);\n}, sanitizeKillSignal = function(killSignal2) {\n  if (typeof killSignal2 === \"string\" || typeof killSignal2 === \"number\")\n    return convertToValidSignal(killSignal2);\n  else if (killSignal2 != null)\n    throw new ERR_INVALID_ARG_TYPE(\"options.killSignal\", [\"string\", \"number\"], killSignal2);\n}, getSignalsToNamesMapping = function() {\n  if (signalsToNamesMapping !== void 0)\n    return signalsToNamesMapping;\n  signalsToNamesMapping = ObjectCreate(null);\n  for (let key in signals)\n    signalsToNamesMapping[signals[key]] = key;\n  return signalsToNamesMapping;\n}, normalizeExecFileArgs = function(file, args, options, callback) {\n  if (ArrayIsArray(args))\n    args = ArrayPrototypeSlice.call(args);\n  else if (args != null && typeof args === \"object\")\n    callback = options, options = args, args = null;\n  else if (typeof args === \"function\")\n    callback = args, options = null, args = null;\n  if (args == null)\n    args = [];\n  if (typeof options === \"function\")\n    callback = options;\n  else if (options != null)\n    validateObject(options, \"options\");\n  if (options == null)\n    options = kEmptyObject;\n  if (callback != null)\n    validateFunction(callback, \"callback\");\n  if (options.argv0 != null)\n    validateString(options.argv0, \"options.argv0\"), validateArgumentNullCheck(options.argv0, \"options.argv0\");\n  return { file, args, options, callback };\n}, normalizeExecArgs = function(command, options, callback) {\n  if (validateString(command, \"command\"), validateArgumentNullCheck(command, \"command\"), typeof options === \"function\")\n    callback = options, options = void 0;\n  return options = { ...options }, options.shell = typeof options.shell === \"string\" \? options.shell : !0, {\n    file: command,\n    options,\n    callback\n  };\n}, normalizeSpawnArguments = function(file, args, options) {\n  if (validateString(file, \"file\"), validateArgumentNullCheck(file, \"file\"), file.length === 0)\n    throw new ERR_INVALID_ARG_VALUE(\"file\", file, \"cannot be empty\");\n  if (ArrayIsArray(args))\n    args = ArrayPrototypeSlice.call(args);\n  else if (args == null)\n    args = [];\n  else if (typeof args !== \"object\")\n    throw new ERR_INVALID_ARG_TYPE(\"args\", \"object\", args);\n  else\n    options = args, args = [];\n  if (validateArgumentsNullCheck(args, \"args\"), options === void 0)\n    options = {};\n  else\n    validateObject(options, \"options\");\n  let cwd = options.cwd;\n  if (cwd != null)\n    cwd = getValidatedPath(cwd, \"options.cwd\");\n  if (options.shell != null && typeof options.shell !== \"boolean\" && typeof options.shell !== \"string\")\n    throw new ERR_INVALID_ARG_TYPE(\"options.shell\", [\"boolean\", \"string\"], options.shell);\n  if (options.argv0 != null)\n    validateString(options.argv0, \"options.argv0\"), validateArgumentNullCheck(options.argv0, \"options.argv0\");\n  if (options.shell) {\n    validateArgumentNullCheck(options.shell, \"options.shell\");\n    const command = ArrayPrototypeJoin.call([file, ...args], \" \");\n    if (typeof options.shell === \"string\")\n      file = options.shell;\n    else\n      file = \"sh\";\n    args = [\"-c\", command];\n  }\n  if (typeof options.argv0 === \"string\")\n    ArrayPrototypeUnshift.call(args, options.argv0);\n  else\n    ArrayPrototypeUnshift.call(args, file);\n  const envPairs = options.env || process.env;\n  return { ...options, file, args, cwd, envPairs };\n}, checkExecSyncError = function(ret, args, cmd) {\n  let err;\n  if (ret.error)\n    err = ret.error, ObjectAssign(err, ret);\n  else if (ret.status !== 0) {\n    let msg = \"Command failed: \";\n    if (msg += cmd || ArrayPrototypeJoin.call(args, \" \"), ret.stderr && ret.stderr.length > 0)\n      msg += `\\n${ret.stderr.toString()}`;\n    err = genericNodeError(msg, ret);\n  }\n  return err;\n}, nodeToBun = function(item) {\n  if (typeof item === \"number\")\n    return item;\n  else {\n    const result = nodeToBunLookup[item];\n    if (result === void 0)\n      throw new Error(\"Invalid stdio option\");\n    return result;\n  }\n}, fdToStdioName = function(fd) {\n  switch (fd) {\n    case 0:\n      return \"stdin\";\n    case 1:\n      return \"stdout\";\n    case 2:\n      return \"stderr\";\n    default:\n      return null;\n  }\n}, getBunStdioFromOptions = function(stdio) {\n  return normalizeStdio(stdio).map((item) => nodeToBun(item));\n}, normalizeStdio = function(stdio) {\n  if (typeof stdio === \"string\")\n    switch (stdio) {\n      case \"ignore\":\n        return [\"ignore\", \"ignore\", \"ignore\"];\n      case \"pipe\":\n        return [\"pipe\", \"pipe\", \"pipe\"];\n      case \"inherit\":\n        return [\"inherit\", \"inherit\", \"inherit\"];\n      default:\n        throw new ERR_INVALID_OPT_VALUE(\"stdio\", stdio);\n    }\n  else if (ArrayIsArray(stdio)) {\n    let processedStdio;\n    if (stdio.length === 0)\n      processedStdio = [\"pipe\", \"pipe\", \"pipe\"];\n    else if (stdio.length === 1)\n      processedStdio = [stdio[0], \"pipe\", \"pipe\"];\n    else if (stdio.length === 2)\n      processedStdio = [stdio[0], stdio[1], \"pipe\"];\n    else if (stdio.length >= 3)\n      processedStdio = [stdio[0], stdio[1], stdio[2]];\n    return processedStdio.map((item) => !item \? \"pipe\" : item);\n  } else\n    throw new ERR_INVALID_OPT_VALUE(\"stdio\", stdio);\n}, flushStdio = function(subprocess) {\n  const stdio = subprocess.stdio;\n  if (stdio == null)\n    return;\n  for (let i = 0;i < stdio.length; i++) {\n    const stream = stdio[i];\n    if (!stream || !stream.readable)\n      continue;\n    stream.resume();\n  }\n}, onSpawnNT = function(self) {\n  self.emit(\"spawn\");\n}, abortChildProcess = function(child, killSignal2, reason) {\n  if (!child)\n    return;\n  try {\n    if (child.kill(killSignal2))\n      child.emit(\"error\", new AbortError(void 0, { cause: reason }));\n  } catch (err) {\n    child.emit(\"error\", err);\n  }\n}, validateMaxBuffer = function(maxBuffer) {\n  if (maxBuffer != null && !(typeof maxBuffer === \"number\" && maxBuffer >= 0))\n    throw new ERR_OUT_OF_RANGE(\"options.maxBuffer\", \"a positive number\", maxBuffer);\n}, validateArgumentNullCheck = function(arg, propName) {\n  if (typeof arg === \"string\" && StringPrototypeIncludes.call(arg, \"\\0\"))\n    throw new ERR_INVALID_ARG_VALUE(propName, arg, \"must be a string without null bytes\");\n}, validateArgumentsNullCheck = function(args, propName) {\n  for (let i = 0;i < args.length; ++i)\n    validateArgumentNullCheck(args[i], `${propName}[${i}]`);\n}, validateTimeout = function(timeout) {\n  if (timeout != null && !(NumberIsInteger(timeout) && timeout >= 0))\n    throw new ERR_OUT_OF_RANGE(\"timeout\", \"an unsigned integer\", timeout);\n};\nvar validateFunction = function(value, name) {\n  if (typeof value !== \"function\")\n    throw new ERR_INVALID_ARG_TYPE(name, \"Function\", value);\n}, validateString = function(value, name) {\n  if (typeof value !== \"string\")\n    throw new ERR_INVALID_ARG_TYPE(name, \"string\", value);\n}, nullCheck = function(path, propName, throwError = !0) {\n  const pathIsString = typeof path === \"string\", pathIsUint8Array = isUint8Array(path);\n  if (!pathIsString && !pathIsUint8Array || pathIsString && !StringPrototypeIncludes.call(path, \"\\0\") || pathIsUint8Array && !Uint8ArrayPrototypeIncludes.call(path, 0))\n    return;\n  const err = new ERR_INVALID_ARG_VALUE(propName, path, \"must be a string or Uint8Array without null bytes\");\n  if (throwError)\n    throw err;\n  return err;\n}, validatePath = function(path, propName = \"path\") {\n  if (typeof path !== \"string\" && !isUint8Array(path))\n    throw new ERR_INVALID_ARG_TYPE(propName, [\"string\", \"Buffer\", \"URL\"], path);\n  const err = nullCheck(path, propName, !1);\n  if (err !== void 0)\n    throw err;\n}, getValidatedPath = function(fileURLOrPath, propName = \"path\") {\n  const path = toPathIfFileURL(fileURLOrPath);\n  return validatePath(path, propName), path;\n}, isUint8Array = function(value) {\n  return typeof value === \"object\" && value !== null && value instanceof Uint8Array;\n}, isURLInstance = function(fileURLOrPath) {\n  return fileURLOrPath != null && fileURLOrPath.href && fileURLOrPath.origin;\n}, toPathIfFileURL = function(fileURLOrPath) {\n  if (!isURLInstance(fileURLOrPath))\n    return fileURLOrPath;\n  return Bun.fileURLToPath(fileURLOrPath);\n}, genericNodeError = function(message, options) {\n  const err = new Error(message);\n  return err.code = options.code, err.killed = options.killed, err.signal = options.signal, err;\n}, ERR_OUT_OF_RANGE = function(str, range, input, replaceDefaultBoolean = !1) {\n  return new RangeError(`The value of ${str} is out of range. It must be ${range}. Received ${input}`);\n}, ERR_CHILD_PROCESS_STDIO_MAXBUFFER = function(stdio) {\n  return Error(`${stdio} maxBuffer length exceeded`);\n}, ERR_UNKNOWN_SIGNAL = function(name) {\n  const err = @makeTypeError(`Unknown signal: ${name}`);\n  return err.code = \"ERR_UNKNOWN_SIGNAL\", err;\n}, ERR_INVALID_ARG_TYPE = function(name, type, value) {\n  const err = @makeTypeError(`The \"${name}\" argument must be of type ${type}. Received ${value\?.toString()}`);\n  return err.code = \"ERR_INVALID_ARG_TYPE\", err;\n}, ERR_INVALID_OPT_VALUE = function(name, value) {\n  return @makeTypeError(`The value \"${value}\" is invalid for option \"${name}\"`);\n}, ERR_INVALID_ARG_VALUE = function(name, value, reason) {\n  return new Error(`The value \"${value}\" is invalid for argument '${name}'. Reason: ${reason}`);\n}, ERR_CHILD_PROCESS_IPC_REQUIRED = function(name) {\n  const err = @makeTypeError(`Forked processes must have an IPC channel, missing value 'ipc' in ${name}`);\n  return err.code = \"ERR_CHILD_PROCESS_IPC_REQUIRED\", err;\n}, $, EventEmitter = @getInternalField(@internalModuleRegistry, 16) || @createInternalModuleById(16), StreamModule = @getInternalField(@internalModuleRegistry, 35) || @createInternalModuleById(35), {\n  constants: { signals }\n} = @getInternalField(@internalModuleRegistry, 24) || @createInternalModuleById(24), { promisify } = @getInternalField(@internalModuleRegistry, 43) || @createInternalModuleById(43), ObjectCreate = Object.create, ObjectAssign = Object.assign, ObjectDefineProperty = Object.defineProperty, BufferConcat = Buffer.concat, BufferIsEncoding = Buffer.isEncoding, kEmptyObject = ObjectCreate(null), ArrayPrototypePush = Array.prototype.push, ArrayPrototypeJoin = Array.prototype.join, ArrayPrototypeMap = Array.prototype.map, ArrayPrototypeIncludes = Array.prototype.includes, ArrayPrototypeSlice = Array.prototype.slice, ArrayPrototypeUnshift = Array.prototype.unshift, ArrayPrototypeLastIndexOf = Array.prototype.lastIndexOf, ArrayPrototypeSplice = Array.prototype.splice, ArrayIsArray = Array.isArray, ArrayBufferIsView = ArrayBuffer.isView, NumberIsInteger = Number.isInteger;\nvar StringPrototypeToUpperCase = String.prototype.toUpperCase, StringPrototypeIncludes = String.prototype.includes, StringPrototypeSlice = String.prototype.slice, Uint8ArrayPrototypeIncludes = Uint8Array.prototype.includes, MAX_BUFFER = 1048576, NativeWritable, ReadableFromWeb, customPromiseExecFunction = (orig) => {\n  return (...args) => {\n    let resolve, reject;\n    const promise = new Promise((res, rej) => {\n      resolve = res, reject = rej;\n    });\n    return promise.child = orig(...args, (err, stdout, stderr) => {\n      if (err !== null)\n        err.stdout = stdout, err.stderr = stderr, reject(err);\n      else\n        resolve({ stdout, stderr });\n    }), promise;\n  };\n};\nObjectDefineProperty(exec, promisify.custom, {\n  __proto__: null,\n  enumerable: !1,\n  value: customPromiseExecFunction(exec)\n});\nvar signalsToNamesMapping;\n\nclass ChildProcess extends EventEmitter {\n  constructor() {\n    super(...arguments);\n  }\n  #handle;\n  #exited = !1;\n  #closesNeeded = 1;\n  #closesGot = 0;\n  connected = !1;\n  signalCode = null;\n  exitCode = null;\n  spawnfile;\n  spawnargs;\n  pid;\n  channel;\n  get killed() {\n    if (this.#handle == null)\n      return !1;\n  }\n  #handleOnExit(exitCode, signalCode, err) {\n    if (this.#exited)\n      return;\n    if (signalCode)\n      this.signalCode = signalCode;\n    else\n      this.exitCode = exitCode;\n    if (this.#stdin)\n      this.#stdin.destroy();\n    if (this.#handle)\n      this.#handle = null;\n    if (exitCode < 0) {\n      const err2 = new SystemError(`Spawned process exited with error code: ${exitCode}`, void 0, \"spawn\", \"EUNKNOWN\", \"ERR_CHILD_PROCESS_UNKNOWN_ERROR\");\n      if (this.spawnfile)\n        err2.path = this.spawnfile;\n      err2.spawnargs = ArrayPrototypeSlice.call(this.spawnargs, 1), this.emit(\"error\", err2);\n    } else\n      this.emit(\"exit\", this.exitCode, this.signalCode);\n    process.nextTick(flushStdio, this), this.#maybeClose(), this.#exited = !0, this.#stdioOptions = [\"destroyed\", \"destroyed\", \"destroyed\"];\n  }\n  #getBunSpawnIo(i, encoding) {\n    NativeWritable ||= StreamModule.NativeWritable, ReadableFromWeb ||= StreamModule.Readable.fromWeb;\n    const io = this.#stdioOptions[i];\n    switch (i) {\n      case 0:\n        switch (io) {\n          case \"pipe\":\n            return new NativeWritable(this.#handle.stdin);\n          case \"inherit\":\n            return process.stdin || null;\n          case \"destroyed\":\n            return new ShimmedStdin;\n          default:\n            return null;\n        }\n      case 2:\n      case 1:\n        switch (io) {\n          case \"pipe\":\n            return ReadableFromWeb(this.#handle[fdToStdioName(i)], { encoding });\n          case \"inherit\":\n            return process[fdToStdioName(i)] || null;\n          case \"destroyed\":\n            return new ShimmedStdioOutStream;\n          default:\n            return null;\n        }\n    }\n  }\n  #stdin;\n  #stdout;\n  #stderr;\n  #stdioObject;\n  #encoding;\n  #stdioOptions;\n  #createStdioObject() {\n    return Object.create(null, {\n      0: {\n        get: () => this.stdin\n      },\n      1: {\n        get: () => this.stdout\n      },\n      2: {\n        get: () => this.stderr\n      }\n    });\n  }\n  get stdin() {\n    return this.#stdin \?\?= this.#getBunSpawnIo(0, this.#encoding);\n  }\n  get stdout() {\n    return this.#stdout \?\?= this.#getBunSpawnIo(1, this.#encoding);\n  }\n  get stderr() {\n    return this.#stderr \?\?= this.#getBunSpawnIo(2, this.#encoding);\n  }\n  get stdio() {\n    return this.#stdioObject \?\?= this.#createStdioObject();\n  }\n  spawn(options) {\n    validateObject(options, \"options\"), validateString(options.file, \"options.file\");\n    var file = this.spawnfile = options.file, spawnargs;\n    if (options.args == null)\n      spawnargs = this.spawnargs = [];\n    else\n      validateArray(options.args, \"options.args\"), spawnargs = this.spawnargs = options.args;\n    const stdio = options.stdio || [\"pipe\", \"pipe\", \"pipe\"], bunStdio = getBunStdioFromOptions(stdio);\n    var env = options.envPairs || void 0;\n    this.#encoding = options.encoding || void 0, this.#stdioOptions = bunStdio, this.#handle = Bun.spawn({\n      cmd: spawnargs,\n      stdin: bunStdio[0],\n      stdout: bunStdio[1],\n      stderr: bunStdio[2],\n      cwd: options.cwd || void 0,\n      env: env || process.env,\n      onExit: (handle, exitCode, signalCode, err) => {\n        this.#handle = handle, this.pid = this.#handle.pid, process.nextTick((exitCode2, signalCode2, err2) => this.#handleOnExit(exitCode2, signalCode2, err2), exitCode, signalCode, err);\n      },\n      lazy: !0\n    }), this.pid = this.#handle.pid, onSpawnNT(this);\n  }\n  send() {\n    console.log(\"ChildProcess.prototype.send() - Sorry! Not implemented yet\");\n  }\n  disconnect() {\n    console.log(\"ChildProcess.prototype.disconnect() - Sorry! Not implemented yet\");\n  }\n  kill(sig) {\n    const signal = sig === 0 \? sig : convertToValidSignal(sig === void 0 \? \"SIGTERM\" : sig);\n    if (this.#handle)\n      this.#handle.kill(signal);\n    return this.#maybeClose(), !0;\n  }\n  #maybeClose() {\n    if (this.#closesGot++, this.#closesGot === this.#closesNeeded)\n      this.emit(\"close\", this.exitCode, this.signalCode);\n  }\n  ref() {\n    if (this.#handle)\n      this.#handle.ref();\n  }\n  unref() {\n    if (this.#handle)\n      this.#handle.unref();\n  }\n}\nvar nodeToBunLookup = {\n  ignore: null,\n  pipe: \"pipe\",\n  overlapped: \"pipe\",\n  inherit: \"inherit\"\n};\n\nclass ShimmedStdin extends EventEmitter {\n  constructor() {\n    super();\n  }\n  write() {\n    return !1;\n  }\n  destroy() {\n  }\n  end() {\n  }\n  pipe() {\n  }\n}\n\nclass ShimmedStdioOutStream extends EventEmitter {\n  constructor() {\n    super(...arguments);\n  }\n  pipe() {\n  }\n}\nvar validateAbortSignal = (signal, name) => {\n  if (signal !== void 0 && (signal === null || typeof signal !== \"object\" || !(\"aborted\" in signal)))\n    throw new ERR_INVALID_ARG_TYPE(name, \"AbortSignal\", signal);\n};\nvar validateObject = (value, name, options = null) => {\n  const allowArray = options\?.allowArray \?\? !1, allowFunction = options\?.allowFunction \?\? !1;\n  if (!(options\?.nullable \?\? !1) && value === null || !allowArray && ArrayIsArray.call(value) || typeof value !== \"object\" && (!allowFunction || typeof value !== \"function\"))\n    throw new ERR_INVALID_ARG_TYPE(name, \"object\", value);\n}, validateArray = (value, name, minLength = 0) => {\n  if (!ArrayIsArray(value))\n    throw new ERR_INVALID_ARG_TYPE(name, \"Array\", value);\n  if (value.length < minLength) {\n    const reason = `must be longer than ${minLength}`;\n    throw new ERR_INVALID_ARG_VALUE(name, value, reason);\n  }\n}, Error = globalThis.Error, TypeError = globalThis.TypeError, RangeError = globalThis.RangeError;\n\nclass AbortError extends Error {\n  code = \"ABORT_ERR\";\n  name = \"AbortError\";\n  constructor(message = \"The operation was aborted\", options = void 0) {\n    if (options !== void 0 && typeof options !== \"object\")\n      throw new ERR_INVALID_ARG_TYPE(\"options\", \"Object\", options);\n    super(message, options);\n  }\n}\n\nclass SystemError extends Error {\n  path;\n  syscall;\n  errno;\n  code;\n  constructor(message, path, syscall, errno, code) {\n    super(message);\n    this.path = path, this.syscall = syscall, this.errno = errno, this.code = code;\n  }\n  get name() {\n    return \"SystemError\";\n  }\n}\n$ = {\n  ChildProcess,\n  spawn,\n  execFile,\n  exec,\n  fork,\n  spawnSync,\n  execFileSync,\n  execSync\n};\nreturn $})\n"_s;
//

//
static constexpr ASCIILiteral NodeClusterCode = "(function (){\"use strict\";// src/js/out/tmp/node/cluster.ts\nvar EventEmitter = @getInternalField(@internalModuleRegistry, 16) || @createInternalModuleById(16), { throwNotImplemented } = @getInternalField(@internalModuleRegistry, 3) || @createInternalModuleById(3);\n\nclass Cluster extends EventEmitter {\n  constructor() {\n    super(...arguments);\n  }\n  isWorker = !1;\n  isPrimary = !0;\n  isMaster = !0;\n  workers = {};\n  settings = {};\n  SCHED_NONE = 1;\n  SCHED_RR = 2;\n  schedulingPolicy = 2;\n  Worker = function Worker() {\n    throwNotImplemented(\"node:cluster Worker\", 2428);\n  };\n  setupPrimary() {\n    throwNotImplemented(\"node:cluster\", 2428);\n  }\n  setupMaster() {\n    throwNotImplemented(\"node:cluster\", 2428);\n  }\n  fork() {\n    throwNotImplemented(\"node:cluster\", 2428);\n  }\n  disconnect() {\n    throwNotImplemented(\"node:cluster\", 2428);\n  }\n}\nreturn new Cluster})\n"_s;
//

//
static constexpr ASCIILiteral NodeConsoleCode = "(function (){\"use strict\";// src/js/out/tmp/node/console.ts\nreturn console})\n"_s;
//

//
static constexpr ASCIILiteral NodeCryptoCode = "(function (){\"use strict\";// src/js/out/tmp/node/crypto.ts\nvar getArrayBufferOrView = function(buffer, name, encoding) {\n  if (isAnyArrayBuffer(buffer))\n    return buffer;\n  if (typeof buffer === \"string\") {\n    if (encoding === \"buffer\")\n      encoding = \"utf8\";\n    return Buffer.from(buffer, encoding);\n  }\n  if (!isArrayBufferView(buffer)) {\n    var error = @makeTypeError(`ERR_INVALID_ARG_TYPE: The \"${name}\" argument must be of type string or an instance of ArrayBuffer, Buffer, TypedArray, or DataView. Received ` + buffer);\n    throw error.code = \"ERR_INVALID_ARG_TYPE\", error;\n  }\n  return buffer;\n}, getCurves = function() {\n  return harcoded_curves;\n}, $, __defProp = Object.defineProperty, __getOwnPropNames = Object.getOwnPropertyNames, StreamModule = @getInternalField(@internalModuleRegistry, 35) || @createInternalModuleById(35), BufferModule = @requireNativeModule(\"node:buffer\"), StringDecoder = @requireNativeModule(\"node:string_decoder\").StringDecoder, MAX_STRING_LENGTH = 536870888, Buffer = globalThis.Buffer, EMPTY_BUFFER = Buffer.alloc(0), { isAnyArrayBuffer, isArrayBufferView } = @requireNativeModule(\"node:util/types\"), crypto = globalThis.crypto, globalCrypto = crypto, __commonJS = (cb, mod) => function() {\n  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;\n}, __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: !0 });\n}, require_safe_buffer = __commonJS({\n  \"node_modules/safe-buffer/index.js\"(exports, module) {\n    var buffer = BufferModule, Buffer2 = buffer.Buffer;\n    function copyProps(src, dst) {\n      for (var key in src)\n        dst[key] = src[key];\n    }\n    Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow \? module.exports = buffer : (copyProps(buffer, exports), exports.Buffer = SafeBuffer);\n    function SafeBuffer(arg, encodingOrOffset, length) {\n      return Buffer2(arg, encodingOrOffset, length);\n    }\n    SafeBuffer.prototype = Object.create(Buffer2.prototype), copyProps(Buffer2, SafeBuffer), SafeBuffer.from = function(arg, encodingOrOffset, length) {\n      if (typeof arg == \"number\")\n        @throwTypeError(\"Argument must not be a number\");\n      return Buffer2(arg, encodingOrOffset, length);\n    }, SafeBuffer.alloc = function(size, fill, encoding) {\n      if (typeof size != \"number\")\n        @throwTypeError(\"Argument must be a number\");\n      var buf = Buffer2(size);\n      return fill !== void 0 \? typeof encoding == \"string\" \? buf.fill(fill, encoding) : buf.fill(fill) : buf.fill(0), buf;\n    }, SafeBuffer.allocUnsafe = function(size) {\n      if (typeof size != \"number\")\n        @throwTypeError(\"Argument must be a number\");\n      return Buffer2(size);\n    }, SafeBuffer.allocUnsafeSlow = function(size) {\n      if (typeof size != \"number\")\n        @throwTypeError(\"Argument must be a number\");\n      return buffer.SlowBuffer(size);\n    };\n  }\n}), require_browser = __commonJS({\n  \"node_modules/randombytes/browser.js\"(exports, module) {\n    var MAX_BYTES = 65536, MAX_UINT32 = 4294967295;\n    function oldBrowser() {\n      throw new Error(`Secure random number generation is not supported by this browser.\nUse Chrome, Firefox or Internet Explorer 11`);\n    }\n    var Buffer2 = require_safe_buffer().Buffer, crypto2 = globalCrypto;\n    crypto2 && crypto2.getRandomValues \? module.exports = randomBytes : module.exports = oldBrowser;\n    function randomBytes(size, cb) {\n      if (size > MAX_UINT32)\n        @throwRangeError(\"requested too many random bytes\");\n      var bytes = Buffer2.allocUnsafe(size);\n      if (size > 0)\n        if (size > MAX_BYTES)\n          for (var generated = 0;generated < size; generated += MAX_BYTES)\n            crypto2.getRandomValues(bytes.slice(generated, generated + MAX_BYTES));\n        else\n          crypto2.getRandomValues(bytes);\n      return typeof cb == \"function\" \? process.nextTick(function() {\n        cb(null, bytes);\n      }) : bytes;\n    }\n  }\n}), require_inherits_browser = __commonJS({\n  \"node_modules/inherits/inherits_browser.js\"(exports, module) {\n    module.exports = function(ctor, superCtor) {\n      superCtor && (ctor.super_ = superCtor, ctor.prototype = Object.create(superCtor.prototype, {\n        constructor: {\n          value: ctor,\n          enumerable: !1,\n          writable: !0,\n          configurable: !0\n        }\n      }));\n    };\n  }\n}), require_hash_base = __commonJS({\n  \"node_modules/hash-base/index.js\"(exports, module) {\n    var Buffer2 = require_safe_buffer().Buffer, inherits = require_inherits_browser();\n    function throwIfNotStringOrBuffer(val, prefix) {\n      if (!Buffer2.isBuffer(val) && typeof val != \"string\")\n        @throwTypeError(prefix + \" must be a string or a buffer\");\n    }\n    function HashBase(blockSize) {\n      StreamModule.Transform.call(this), this._block = Buffer2.allocUnsafe(blockSize), this._blockSize = blockSize, this._blockOffset = 0, this._length = [0, 0, 0, 0], this._finalized = !1;\n    }\n    inherits(HashBase, StreamModule.Transform), HashBase.prototype._transform = function(chunk, encoding, callback) {\n      var error = null;\n      try {\n        this.update(chunk, encoding);\n      } catch (err) {\n        error = err;\n      }\n      callback(error);\n    }, HashBase.prototype._flush = function(callback) {\n      var error = null;\n      try {\n        this.push(this.digest());\n      } catch (err) {\n        error = err;\n      }\n      callback(error);\n    }, HashBase.prototype.update = function(data, encoding) {\n      if (throwIfNotStringOrBuffer(data, \"Data\"), this._finalized)\n        throw new Error(\"Digest already called\");\n      Buffer2.isBuffer(data) || (data = Buffer2.from(data, encoding));\n      for (var block = this._block, offset = 0;this._blockOffset + data.length - offset >= this._blockSize; ) {\n        for (var i = this._blockOffset;i < this._blockSize; )\n          block[i++] = data[offset++];\n        this._update(), this._blockOffset = 0;\n      }\n      for (;offset < data.length; )\n        block[this._blockOffset++] = data[offset++];\n      for (var j = 0, carry = data.length * 8;carry > 0; ++j)\n        this._length[j] += carry, carry = this._length[j] / 4294967296 | 0, carry > 0 && (this._length[j] -= 4294967296 * carry);\n      return this;\n    }, HashBase.prototype._update = function() {\n      throw new Error(\"_update is not implemented\");\n    }, HashBase.prototype.digest = function(encoding) {\n      if (this._finalized)\n        throw new Error(\"Digest already called\");\n      this._finalized = !0;\n      var digest = this._digest();\n      encoding !== void 0 && (digest = digest.toString(encoding)), this._block.fill(0), this._blockOffset = 0;\n      for (var i = 0;i < 4; ++i)\n        this._length[i] = 0;\n      return digest;\n    }, HashBase.prototype._digest = function() {\n      throw new Error(\"_digest is not implemented\");\n    }, module.exports = HashBase;\n  }\n}), require_md5 = __commonJS({\n  \"node_modules/md5.js/index.js\"(exports, module) {\n    var inherits = require_inherits_browser(), HashBase = require_hash_base(), Buffer2 = require_safe_buffer().Buffer, ARRAY16 = new Array(16);\n    function MD5() {\n      HashBase.call(this, 64), this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878;\n    }\n    inherits(MD5, HashBase), MD5.prototype._update = function() {\n      for (var M = ARRAY16, i = 0;i < 16; ++i)\n        M[i] = this._block.readInt32LE(i * 4);\n      var a = this._a, b = this._b, c = this._c, d = this._d;\n      a = fnF(a, b, c, d, M[0], 3614090360, 7), d = fnF(d, a, b, c, M[1], 3905402710, 12), c = fnF(c, d, a, b, M[2], 606105819, 17), b = fnF(b, c, d, a, M[3], 3250441966, 22), a = fnF(a, b, c, d, M[4], 4118548399, 7), d = fnF(d, a, b, c, M[5], 1200080426, 12), c = fnF(c, d, a, b, M[6], 2821735955, 17), b = fnF(b, c, d, a, M[7], 4249261313, 22), a = fnF(a, b, c, d, M[8], 1770035416, 7), d = fnF(d, a, b, c, M[9], 2336552879, 12), c = fnF(c, d, a, b, M[10], 4294925233, 17), b = fnF(b, c, d, a, M[11], 2304563134, 22), a = fnF(a, b, c, d, M[12], 1804603682, 7), d = fnF(d, a, b, c, M[13], 4254626195, 12), c = fnF(c, d, a, b, M[14], 2792965006, 17), b = fnF(b, c, d, a, M[15], 1236535329, 22), a = fnG(a, b, c, d, M[1], 4129170786, 5), d = fnG(d, a, b, c, M[6], 3225465664, 9), c = fnG(c, d, a, b, M[11], 643717713, 14), b = fnG(b, c, d, a, M[0], 3921069994, 20), a = fnG(a, b, c, d, M[5], 3593408605, 5), d = fnG(d, a, b, c, M[10], 38016083, 9), c = fnG(c, d, a, b, M[15], 3634488961, 14), b = fnG(b, c, d, a, M[4], 3889429448, 20), a = fnG(a, b, c, d, M[9], 568446438, 5), d = fnG(d, a, b, c, M[14], 3275163606, 9), c = fnG(c, d, a, b, M[3], 4107603335, 14), b = fnG(b, c, d, a, M[8], 1163531501, 20), a = fnG(a, b, c, d, M[13], 2850285829, 5), d = fnG(d, a, b, c, M[2], 4243563512, 9), c = fnG(c, d, a, b, M[7], 1735328473, 14), b = fnG(b, c, d, a, M[12], 2368359562, 20), a = fnH(a, b, c, d, M[5], 4294588738, 4), d = fnH(d, a, b, c, M[8], 2272392833, 11), c = fnH(c, d, a, b, M[11], 1839030562, 16), b = fnH(b, c, d, a, M[14], 4259657740, 23), a = fnH(a, b, c, d, M[1], 2763975236, 4), d = fnH(d, a, b, c, M[4], 1272893353, 11), c = fnH(c, d, a, b, M[7], 4139469664, 16), b = fnH(b, c, d, a, M[10], 3200236656, 23), a = fnH(a, b, c, d, M[13], 681279174, 4), d = fnH(d, a, b, c, M[0], 3936430074, 11), c = fnH(c, d, a, b, M[3], 3572445317, 16), b = fnH(b, c, d, a, M[6], 76029189, 23), a = fnH(a, b, c, d, M[9], 3654602809, 4), d = fnH(d, a, b, c, M[12], 3873151461, 11), c = fnH(c, d, a, b, M[15], 530742520, 16), b = fnH(b, c, d, a, M[2], 3299628645, 23), a = fnI(a, b, c, d, M[0], 4096336452, 6), d = fnI(d, a, b, c, M[7], 1126891415, 10), c = fnI(c, d, a, b, M[14], 2878612391, 15), b = fnI(b, c, d, a, M[5], 4237533241, 21), a = fnI(a, b, c, d, M[12], 1700485571, 6), d = fnI(d, a, b, c, M[3], 2399980690, 10), c = fnI(c, d, a, b, M[10], 4293915773, 15), b = fnI(b, c, d, a, M[1], 2240044497, 21), a = fnI(a, b, c, d, M[8], 1873313359, 6), d = fnI(d, a, b, c, M[15], 4264355552, 10), c = fnI(c, d, a, b, M[6], 2734768916, 15), b = fnI(b, c, d, a, M[13], 1309151649, 21), a = fnI(a, b, c, d, M[4], 4149444226, 6), d = fnI(d, a, b, c, M[11], 3174756917, 10), c = fnI(c, d, a, b, M[2], 718787259, 15), b = fnI(b, c, d, a, M[9], 3951481745, 21), this._a = this._a + a | 0, this._b = this._b + b | 0, this._c = this._c + c | 0, this._d = this._d + d | 0;\n    }, MD5.prototype._digest = function() {\n      this._block[this._blockOffset++] = 128, this._blockOffset > 56 && (this._block.fill(0, this._blockOffset, 64), this._update(), this._blockOffset = 0), this._block.fill(0, this._blockOffset, 56), this._block.writeUInt32LE(this._length[0], 56), this._block.writeUInt32LE(this._length[1], 60), this._update();\n      var buffer = Buffer2.allocUnsafe(16);\n      return buffer.writeInt32LE(this._a, 0), buffer.writeInt32LE(this._b, 4), buffer.writeInt32LE(this._c, 8), buffer.writeInt32LE(this._d, 12), buffer;\n    };\n    function rotl(x, n) {\n      return x << n | x >>> 32 - n;\n    }\n    function fnF(a, b, c, d, m, k, s) {\n      return rotl(a + (b & c | ~b & d) + m + k | 0, s) + b | 0;\n    }\n    function fnG(a, b, c, d, m, k, s) {\n      return rotl(a + (b & d | c & ~d) + m + k | 0, s) + b | 0;\n    }\n    function fnH(a, b, c, d, m, k, s) {\n      return rotl(a + (b ^ c ^ d) + m + k | 0, s) + b | 0;\n    }\n    function fnI(a, b, c, d, m, k, s) {\n      return rotl(a + (c ^ (b | ~d)) + m + k | 0, s) + b | 0;\n    }\n    module.exports = MD5;\n  }\n}), require_ripemd160 = __commonJS({\n  \"node_modules/ripemd160/index.js\"(exports, module) {\n    var Buffer2 = Buffer, inherits = require_inherits_browser(), HashBase = require_hash_base(), ARRAY16 = new Array(16), zl = [\n      0,\n      1,\n      2,\n      3,\n      4,\n      5,\n      6,\n      7,\n      8,\n      9,\n      10,\n      11,\n      12,\n      13,\n      14,\n      15,\n      7,\n      4,\n      13,\n      1,\n      10,\n      6,\n      15,\n      3,\n      12,\n      0,\n      9,\n      5,\n      2,\n      14,\n      11,\n      8,\n      3,\n      10,\n      14,\n      4,\n      9,\n      15,\n      8,\n      1,\n      2,\n      7,\n      0,\n      6,\n      13,\n      11,\n      5,\n      12,\n      1,\n      9,\n      11,\n      10,\n      0,\n      8,\n      12,\n      4,\n      13,\n      3,\n      7,\n      15,\n      14,\n      5,\n      6,\n      2,\n      4,\n      0,\n      5,\n      9,\n      7,\n      12,\n      2,\n      10,\n      14,\n      1,\n      3,\n      8,\n      11,\n      6,\n      15,\n      13\n    ], zr = [\n      5,\n      14,\n      7,\n      0,\n      9,\n      2,\n      11,\n      4,\n      13,\n      6,\n      15,\n      8,\n      1,\n      10,\n      3,\n      12,\n      6,\n      11,\n      3,\n      7,\n      0,\n      13,\n      5,\n      10,\n      14,\n      15,\n      8,\n      12,\n      4,\n      9,\n      1,\n      2,\n      15,\n      5,\n      1,\n      3,\n      7,\n      14,\n      6,\n      9,\n      11,\n      8,\n      12,\n      2,\n      10,\n      0,\n      4,\n      13,\n      8,\n      6,\n      4,\n      1,\n      3,\n      11,\n      15,\n      0,\n      5,\n      12,\n      2,\n      13,\n      9,\n      7,\n      10,\n      14,\n      12,\n      15,\n      10,\n      4,\n      1,\n      5,\n      8,\n      7,\n      6,\n      2,\n      13,\n      14,\n      0,\n      3,\n      9,\n      11\n    ], sl = [\n      11,\n      14,\n      15,\n      12,\n      5,\n      8,\n      7,\n      9,\n      11,\n      13,\n      14,\n      15,\n      6,\n      7,\n      9,\n      8,\n      7,\n      6,\n      8,\n      13,\n      11,\n      9,\n      7,\n      15,\n      7,\n      12,\n      15,\n      9,\n      11,\n      7,\n      13,\n      12,\n      11,\n      13,\n      6,\n      7,\n      14,\n      9,\n      13,\n      15,\n      14,\n      8,\n      13,\n      6,\n      5,\n      12,\n      7,\n      5,\n      11,\n      12,\n      14,\n      15,\n      14,\n      15,\n      9,\n      8,\n      9,\n      14,\n      5,\n      6,\n      8,\n      6,\n      5,\n      12,\n      9,\n      15,\n      5,\n      11,\n      6,\n      8,\n      13,\n      12,\n      5,\n      12,\n      13,\n      14,\n      11,\n      8,\n      5,\n      6\n    ], sr = [\n      8,\n      9,\n      9,\n      11,\n      13,\n      15,\n      15,\n      5,\n      7,\n      7,\n      8,\n      11,\n      14,\n      14,\n      12,\n      6,\n      9,\n      13,\n      15,\n      7,\n      12,\n      8,\n      9,\n      11,\n      7,\n      7,\n      12,\n      7,\n      6,\n      15,\n      13,\n      11,\n      9,\n      7,\n      15,\n      11,\n      8,\n      6,\n      6,\n      14,\n      12,\n      13,\n      5,\n      14,\n      13,\n      13,\n      7,\n      5,\n      15,\n      5,\n      8,\n      11,\n      14,\n      14,\n      6,\n      14,\n      6,\n      9,\n      12,\n      9,\n      12,\n      5,\n      15,\n      8,\n      8,\n      5,\n      12,\n      9,\n      12,\n      5,\n      14,\n      6,\n      8,\n      13,\n      6,\n      5,\n      15,\n      13,\n      11,\n      11\n    ], hl = [0, 1518500249, 1859775393, 2400959708, 2840853838], hr = [1352829926, 1548603684, 1836072691, 2053994217, 0];\n    function RIPEMD160() {\n      HashBase.call(this, 64), this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520;\n    }\n    inherits(RIPEMD160, HashBase), RIPEMD160.prototype._update = function() {\n      for (var words = ARRAY16, j = 0;j < 16; ++j)\n        words[j] = this._block.readInt32LE(j * 4);\n      for (var al = this._a | 0, bl = this._b | 0, cl = this._c | 0, dl = this._d | 0, el = this._e | 0, ar = this._a | 0, br = this._b | 0, cr = this._c | 0, dr = this._d | 0, er = this._e | 0, i = 0;i < 80; i += 1) {\n        var tl, tr;\n        i < 16 \? (tl = fn1(al, bl, cl, dl, el, words[zl[i]], hl[0], sl[i]), tr = fn5(ar, br, cr, dr, er, words[zr[i]], hr[0], sr[i])) : i < 32 \? (tl = fn2(al, bl, cl, dl, el, words[zl[i]], hl[1], sl[i]), tr = fn4(ar, br, cr, dr, er, words[zr[i]], hr[1], sr[i])) : i < 48 \? (tl = fn3(al, bl, cl, dl, el, words[zl[i]], hl[2], sl[i]), tr = fn3(ar, br, cr, dr, er, words[zr[i]], hr[2], sr[i])) : i < 64 \? (tl = fn4(al, bl, cl, dl, el, words[zl[i]], hl[3], sl[i]), tr = fn2(ar, br, cr, dr, er, words[zr[i]], hr[3], sr[i])) : (tl = fn5(al, bl, cl, dl, el, words[zl[i]], hl[4], sl[i]), tr = fn1(ar, br, cr, dr, er, words[zr[i]], hr[4], sr[i])), al = el, el = dl, dl = rotl(cl, 10), cl = bl, bl = tl, ar = er, er = dr, dr = rotl(cr, 10), cr = br, br = tr;\n      }\n      var t = this._b + cl + dr | 0;\n      this._b = this._c + dl + er | 0, this._c = this._d + el + ar | 0, this._d = this._e + al + br | 0, this._e = this._a + bl + cr | 0, this._a = t;\n    }, RIPEMD160.prototype._digest = function() {\n      this._block[this._blockOffset++] = 128, this._blockOffset > 56 && (this._block.fill(0, this._blockOffset, 64), this._update(), this._blockOffset = 0), this._block.fill(0, this._blockOffset, 56), this._block.writeUInt32LE(this._length[0], 56), this._block.writeUInt32LE(this._length[1], 60), this._update();\n      var buffer = Buffer2.alloc \? Buffer2.alloc(20) : new Buffer2(20);\n      return buffer.writeInt32LE(this._a, 0), buffer.writeInt32LE(this._b, 4), buffer.writeInt32LE(this._c, 8), buffer.writeInt32LE(this._d, 12), buffer.writeInt32LE(this._e, 16), buffer;\n    };\n    function rotl(x, n) {\n      return x << n | x >>> 32 - n;\n    }\n    function fn1(a, b, c, d, e, m, k, s) {\n      return rotl(a + (b ^ c ^ d) + m + k | 0, s) + e | 0;\n    }\n    function fn2(a, b, c, d, e, m, k, s) {\n      return rotl(a + (b & c | ~b & d) + m + k | 0, s) + e | 0;\n    }\n    function fn3(a, b, c, d, e, m, k, s) {\n      return rotl(a + ((b | ~c) ^ d) + m + k | 0, s) + e | 0;\n    }\n    function fn4(a, b, c, d, e, m, k, s) {\n      return rotl(a + (b & d | c & ~d) + m + k | 0, s) + e | 0;\n    }\n    function fn5(a, b, c, d, e, m, k, s) {\n      return rotl(a + (b ^ (c | ~d)) + m + k | 0, s) + e | 0;\n    }\n    module.exports = RIPEMD160;\n  }\n}), require_hash = __commonJS({\n  \"node_modules/sha.js/hash.js\"(exports, module) {\n    var Buffer2 = require_safe_buffer().Buffer;\n    function Hash(blockSize, finalSize) {\n      this._block = Buffer2.alloc(blockSize), this._finalSize = finalSize, this._blockSize = blockSize, this._len = 0;\n    }\n    Hash.prototype = {}, Hash.prototype.update = function(data, enc) {\n      typeof data == \"string\" && (enc = enc || \"utf8\", data = Buffer2.from(data, enc));\n      for (var block = this._block, blockSize = this._blockSize, length = data.length, accum = this._len, offset = 0;offset < length; ) {\n        for (var assigned = accum % blockSize, remainder = Math.min(length - offset, blockSize - assigned), i = 0;i < remainder; i++)\n          block[assigned + i] = data[offset + i];\n        accum += remainder, offset += remainder, accum % blockSize === 0 && this._update(block);\n      }\n      return this._len += length, this;\n    }, Hash.prototype.digest = function(enc) {\n      var rem = this._len % this._blockSize;\n      this._block[rem] = 128, this._block.fill(0, rem + 1), rem >= this._finalSize && (this._update(this._block), this._block.fill(0));\n      var bits = this._len * 8;\n      if (bits <= 4294967295)\n        this._block.writeUInt32BE(bits, this._blockSize - 4);\n      else {\n        var lowBits = (bits & 4294967295) >>> 0, highBits = (bits - lowBits) / 4294967296;\n        this._block.writeUInt32BE(highBits, this._blockSize - 8), this._block.writeUInt32BE(lowBits, this._blockSize - 4);\n      }\n      this._update(this._block);\n      var hash = this._hash();\n      return enc \? hash.toString(enc) : hash;\n    }, Hash.prototype._update = function() {\n      throw new Error(\"_update must be implemented by subclass\");\n    }, module.exports = Hash;\n  }\n}), require_sha = __commonJS({\n  \"node_modules/sha.js/sha.js\"(exports, module) {\n    var inherits = require_inherits_browser(), Hash = require_hash(), Buffer2 = require_safe_buffer().Buffer, K = [1518500249, 1859775393, -1894007588, -899497514], W = new Array(80);\n    function Sha() {\n      this.init(), this._w = W, Hash.call(this, 64, 56);\n    }\n    inherits(Sha, Hash), Sha.prototype.init = function() {\n      return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this;\n    };\n    function rotl5(num) {\n      return num << 5 | num >>> 27;\n    }\n    function rotl30(num) {\n      return num << 30 | num >>> 2;\n    }\n    function ft(s, b, c, d) {\n      return s === 0 \? b & c | ~b & d : s === 2 \? b & c | b & d | c & d : b ^ c ^ d;\n    }\n    Sha.prototype._update = function(M) {\n      for (var W2 = this._w, a = this._a | 0, b = this._b | 0, c = this._c | 0, d = this._d | 0, e = this._e | 0, i = 0;i < 16; ++i)\n        W2[i] = M.readInt32BE(i * 4);\n      for (;i < 80; ++i)\n        W2[i] = W2[i - 3] ^ W2[i - 8] ^ W2[i - 14] ^ W2[i - 16];\n      for (var j = 0;j < 80; ++j) {\n        var s = ~~(j / 20), t = rotl5(a) + ft(s, b, c, d) + e + W2[j] + K[s] | 0;\n        e = d, d = c, c = rotl30(b), b = a, a = t;\n      }\n      this._a = a + this._a | 0, this._b = b + this._b | 0, this._c = c + this._c | 0, this._d = d + this._d | 0, this._e = e + this._e | 0;\n    }, Sha.prototype._hash = function() {\n      var H = Buffer2.allocUnsafe(20);\n      return H.writeInt32BE(this._a | 0, 0), H.writeInt32BE(this._b | 0, 4), H.writeInt32BE(this._c | 0, 8), H.writeInt32BE(this._d | 0, 12), H.writeInt32BE(this._e | 0, 16), H;\n    }, module.exports = Sha;\n  }\n}), require_sha1 = __commonJS({\n  \"node_modules/sha.js/sha1.js\"(exports, module) {\n    var inherits = require_inherits_browser(), Hash = require_hash(), Buffer2 = require_safe_buffer().Buffer, K = [1518500249, 1859775393, -1894007588, -899497514], W = new Array(80);\n    function Sha1() {\n      this.init(), this._w = W, Hash.call(this, 64, 56);\n    }\n    inherits(Sha1, Hash), Sha1.prototype.init = function() {\n      return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this;\n    };\n    function rotl1(num) {\n      return num << 1 | num >>> 31;\n    }\n    function rotl5(num) {\n      return num << 5 | num >>> 27;\n    }\n    function rotl30(num) {\n      return num << 30 | num >>> 2;\n    }\n    function ft(s, b, c, d) {\n      return s === 0 \? b & c | ~b & d : s === 2 \? b & c | b & d | c & d : b ^ c ^ d;\n    }\n    Sha1.prototype._update = function(M) {\n      for (var W2 = this._w, a = this._a | 0, b = this._b | 0, c = this._c | 0, d = this._d | 0, e = this._e | 0, i = 0;i < 16; ++i)\n        W2[i] = M.readInt32BE(i * 4);\n      for (;i < 80; ++i)\n        W2[i] = rotl1(W2[i - 3] ^ W2[i - 8] ^ W2[i - 14] ^ W2[i - 16]);\n      for (var j = 0;j < 80; ++j) {\n        var s = ~~(j / 20), t = rotl5(a) + ft(s, b, c, d) + e + W2[j] + K[s] | 0;\n        e = d, d = c, c = rotl30(b), b = a, a = t;\n      }\n      this._a = a + this._a | 0, this._b = b + this._b | 0, this._c = c + this._c | 0, this._d = d + this._d | 0, this._e = e + this._e | 0;\n    }, Sha1.prototype._hash = function() {\n      var H = Buffer2.allocUnsafe(20);\n      return H.writeInt32BE(this._a | 0, 0), H.writeInt32BE(this._b | 0, 4), H.writeInt32BE(this._c | 0, 8), H.writeInt32BE(this._d | 0, 12), H.writeInt32BE(this._e | 0, 16), H;\n    }, module.exports = Sha1;\n  }\n}), require_sha256 = __commonJS({\n  \"node_modules/sha.js/sha256.js\"(exports, module) {\n    var inherits = require_inherits_browser(), Hash = require_hash(), Buffer2 = require_safe_buffer().Buffer, K = [\n      1116352408,\n      1899447441,\n      3049323471,\n      3921009573,\n      961987163,\n      1508970993,\n      2453635748,\n      2870763221,\n      3624381080,\n      310598401,\n      607225278,\n      1426881987,\n      1925078388,\n      2162078206,\n      2614888103,\n      3248222580,\n      3835390401,\n      4022224774,\n      264347078,\n      604807628,\n      770255983,\n      1249150122,\n      1555081692,\n      1996064986,\n      2554220882,\n      2821834349,\n      2952996808,\n      3210313671,\n      3336571891,\n      3584528711,\n      113926993,\n      338241895,\n      666307205,\n      773529912,\n      1294757372,\n      1396182291,\n      1695183700,\n      1986661051,\n      2177026350,\n      2456956037,\n      2730485921,\n      2820302411,\n      3259730800,\n      3345764771,\n      3516065817,\n      3600352804,\n      4094571909,\n      275423344,\n      430227734,\n      506948616,\n      659060556,\n      883997877,\n      958139571,\n      1322822218,\n      1537002063,\n      1747873779,\n      1955562222,\n      2024104815,\n      2227730452,\n      2361852424,\n      2428436474,\n      2756734187,\n      3204031479,\n      3329325298\n    ], W = new Array(64);\n    function Sha256() {\n      this.init(), this._w = W, Hash.call(this, 64, 56);\n    }\n    inherits(Sha256, Hash), Sha256.prototype.init = function() {\n      return this._a = 1779033703, this._b = 3144134277, this._c = 1013904242, this._d = 2773480762, this._e = 1359893119, this._f = 2600822924, this._g = 528734635, this._h = 1541459225, this;\n    };\n    function ch(x, y, z) {\n      return z ^ x & (y ^ z);\n    }\n    function maj(x, y, z) {\n      return x & y | z & (x | y);\n    }\n    function sigma0(x) {\n      return (x >>> 2 | x << 30) ^ (x >>> 13 | x << 19) ^ (x >>> 22 | x << 10);\n    }\n    function sigma1(x) {\n      return (x >>> 6 | x << 26) ^ (x >>> 11 | x << 21) ^ (x >>> 25 | x << 7);\n    }\n    function gamma0(x) {\n      return (x >>> 7 | x << 25) ^ (x >>> 18 | x << 14) ^ x >>> 3;\n    }\n    function gamma1(x) {\n      return (x >>> 17 | x << 15) ^ (x >>> 19 | x << 13) ^ x >>> 10;\n    }\n    Sha256.prototype._update = function(M) {\n      for (var W2 = this._w, a = this._a | 0, b = this._b | 0, c = this._c | 0, d = this._d | 0, e = this._e | 0, f = this._f | 0, g = this._g | 0, h = this._h | 0, i = 0;i < 16; ++i)\n        W2[i] = M.readInt32BE(i * 4);\n      for (;i < 64; ++i)\n        W2[i] = gamma1(W2[i - 2]) + W2[i - 7] + gamma0(W2[i - 15]) + W2[i - 16] | 0;\n      for (var j = 0;j < 64; ++j) {\n        var T1 = h + sigma1(e) + ch(e, f, g) + K[j] + W2[j] | 0, T2 = sigma0(a) + maj(a, b, c) | 0;\n        h = g, g = f, f = e, e = d + T1 | 0, d = c, c = b, b = a, a = T1 + T2 | 0;\n      }\n      this._a = a + this._a | 0, this._b = b + this._b | 0, this._c = c + this._c | 0, this._d = d + this._d | 0, this._e = e + this._e | 0, this._f = f + this._f | 0, this._g = g + this._g | 0, this._h = h + this._h | 0;\n    }, Sha256.prototype._hash = function() {\n      var H = Buffer2.allocUnsafe(32);\n      return H.writeInt32BE(this._a, 0), H.writeInt32BE(this._b, 4), H.writeInt32BE(this._c, 8), H.writeInt32BE(this._d, 12), H.writeInt32BE(this._e, 16), H.writeInt32BE(this._f, 20), H.writeInt32BE(this._g, 24), H.writeInt32BE(this._h, 28), H;\n    }, module.exports = Sha256;\n  }\n}), require_sha224 = __commonJS({\n  \"node_modules/sha.js/sha224.js\"(exports, module) {\n    var inherits = require_inherits_browser(), Sha256 = require_sha256(), Hash = require_hash(), Buffer2 = require_safe_buffer().Buffer, W = new Array(64);\n    function Sha224() {\n      this.init(), this._w = W, Hash.call(this, 64, 56);\n    }\n    inherits(Sha224, Sha256), Sha224.prototype.init = function() {\n      return this._a = 3238371032, this._b = 914150663, this._c = 812702999, this._d = 4144912697, this._e = 4290775857, this._f = 1750603025, this._g = 1694076839, this._h = 3204075428, this;\n    }, Sha224.prototype._hash = function() {\n      var H = Buffer2.allocUnsafe(28);\n      return H.writeInt32BE(this._a, 0), H.writeInt32BE(this._b, 4), H.writeInt32BE(this._c, 8), H.writeInt32BE(this._d, 12), H.writeInt32BE(this._e, 16), H.writeInt32BE(this._f, 20), H.writeInt32BE(this._g, 24), H;\n    }, module.exports = Sha224;\n  }\n}), require_sha512 = __commonJS({\n  \"node_modules/sha.js/sha512.js\"(exports, module) {\n    var inherits = require_inherits_browser(), Hash = require_hash(), Buffer2 = require_safe_buffer().Buffer, K = [\n      1116352408,\n      3609767458,\n      1899447441,\n      602891725,\n      3049323471,\n      3964484399,\n      3921009573,\n      2173295548,\n      961987163,\n      4081628472,\n      1508970993,\n      3053834265,\n      2453635748,\n      2937671579,\n      2870763221,\n      3664609560,\n      3624381080,\n      2734883394,\n      310598401,\n      1164996542,\n      607225278,\n      1323610764,\n      1426881987,\n      3590304994,\n      1925078388,\n      4068182383,\n      2162078206,\n      991336113,\n      2614888103,\n      633803317,\n      3248222580,\n      3479774868,\n      3835390401,\n      2666613458,\n      4022224774,\n      944711139,\n      264347078,\n      2341262773,\n      604807628,\n      2007800933,\n      770255983,\n      1495990901,\n      1249150122,\n      1856431235,\n      1555081692,\n      3175218132,\n      1996064986,\n      2198950837,\n      2554220882,\n      3999719339,\n      2821834349,\n      766784016,\n      2952996808,\n      2566594879,\n      3210313671,\n      3203337956,\n      3336571891,\n      1034457026,\n      3584528711,\n      2466948901,\n      113926993,\n      3758326383,\n      338241895,\n      168717936,\n      666307205,\n      1188179964,\n      773529912,\n      1546045734,\n      1294757372,\n      1522805485,\n      1396182291,\n      2643833823,\n      1695183700,\n      2343527390,\n      1986661051,\n      1014477480,\n      2177026350,\n      1206759142,\n      2456956037,\n      344077627,\n      2730485921,\n      1290863460,\n      2820302411,\n      3158454273,\n      3259730800,\n      3505952657,\n      3345764771,\n      106217008,\n      3516065817,\n      3606008344,\n      3600352804,\n      1432725776,\n      4094571909,\n      1467031594,\n      275423344,\n      851169720,\n      430227734,\n      3100823752,\n      506948616,\n      1363258195,\n      659060556,\n      3750685593,\n      883997877,\n      3785050280,\n      958139571,\n      3318307427,\n      1322822218,\n      3812723403,\n      1537002063,\n      2003034995,\n      1747873779,\n      3602036899,\n      1955562222,\n      1575990012,\n      2024104815,\n      1125592928,\n      2227730452,\n      2716904306,\n      2361852424,\n      442776044,\n      2428436474,\n      593698344,\n      2756734187,\n      3733110249,\n      3204031479,\n      2999351573,\n      3329325298,\n      3815920427,\n      3391569614,\n      3928383900,\n      3515267271,\n      566280711,\n      3940187606,\n      3454069534,\n      4118630271,\n      4000239992,\n      116418474,\n      1914138554,\n      174292421,\n      2731055270,\n      289380356,\n      3203993006,\n      460393269,\n      320620315,\n      685471733,\n      587496836,\n      852142971,\n      1086792851,\n      1017036298,\n      365543100,\n      1126000580,\n      2618297676,\n      1288033470,\n      3409855158,\n      1501505948,\n      4234509866,\n      1607167915,\n      987167468,\n      1816402316,\n      1246189591\n    ], W = new Array(160);\n    function Sha512() {\n      this.init(), this._w = W, Hash.call(this, 128, 112);\n    }\n    inherits(Sha512, Hash), Sha512.prototype.init = function() {\n      return this._ah = 1779033703, this._bh = 3144134277, this._ch = 1013904242, this._dh = 2773480762, this._eh = 1359893119, this._fh = 2600822924, this._gh = 528734635, this._hh = 1541459225, this._al = 4089235720, this._bl = 2227873595, this._cl = 4271175723, this._dl = 1595750129, this._el = 2917565137, this._fl = 725511199, this._gl = 4215389547, this._hl = 327033209, this;\n    };\n    function Ch(x, y, z) {\n      return z ^ x & (y ^ z);\n    }\n    function maj(x, y, z) {\n      return x & y | z & (x | y);\n    }\n    function sigma0(x, xl) {\n      return (x >>> 28 | xl << 4) ^ (xl >>> 2 | x << 30) ^ (xl >>> 7 | x << 25);\n    }\n    function sigma1(x, xl) {\n      return (x >>> 14 | xl << 18) ^ (x >>> 18 | xl << 14) ^ (xl >>> 9 | x << 23);\n    }\n    function Gamma0(x, xl) {\n      return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ x >>> 7;\n    }\n    function Gamma0l(x, xl) {\n      return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ (x >>> 7 | xl << 25);\n    }\n    function Gamma1(x, xl) {\n      return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ x >>> 6;\n    }\n    function Gamma1l(x, xl) {\n      return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ (x >>> 6 | xl << 26);\n    }\n    function getCarry(a, b) {\n      return a >>> 0 < b >>> 0 \? 1 : 0;\n    }\n    Sha512.prototype._update = function(M) {\n      for (var W2 = this._w, ah = this._ah | 0, bh = this._bh | 0, ch = this._ch | 0, dh = this._dh | 0, eh = this._eh | 0, fh = this._fh | 0, gh = this._gh | 0, hh = this._hh | 0, al = this._al | 0, bl = this._bl | 0, cl = this._cl | 0, dl = this._dl | 0, el = this._el | 0, fl = this._fl | 0, gl = this._gl | 0, hl = this._hl | 0, i = 0;i < 32; i += 2)\n        W2[i] = M.readInt32BE(i * 4), W2[i + 1] = M.readInt32BE(i * 4 + 4);\n      for (;i < 160; i += 2) {\n        var xh = W2[i - 30], xl = W2[i - 30 + 1], gamma0 = Gamma0(xh, xl), gamma0l = Gamma0l(xl, xh);\n        xh = W2[i - 4], xl = W2[i - 4 + 1];\n        var gamma1 = Gamma1(xh, xl), gamma1l = Gamma1l(xl, xh), Wi7h = W2[i - 14], Wi7l = W2[i - 14 + 1], Wi16h = W2[i - 32], Wi16l = W2[i - 32 + 1], Wil = gamma0l + Wi7l | 0, Wih = gamma0 + Wi7h + getCarry(Wil, gamma0l) | 0;\n        Wil = Wil + gamma1l | 0, Wih = Wih + gamma1 + getCarry(Wil, gamma1l) | 0, Wil = Wil + Wi16l | 0, Wih = Wih + Wi16h + getCarry(Wil, Wi16l) | 0, W2[i] = Wih, W2[i + 1] = Wil;\n      }\n      for (var j = 0;j < 160; j += 2) {\n        Wih = W2[j], Wil = W2[j + 1];\n        var majh = maj(ah, bh, ch), majl = maj(al, bl, cl), sigma0h = sigma0(ah, al), sigma0l = sigma0(al, ah), sigma1h = sigma1(eh, el), sigma1l = sigma1(el, eh), Kih = K[j], Kil = K[j + 1], chh = Ch(eh, fh, gh), chl = Ch(el, fl, gl), t1l = hl + sigma1l | 0, t1h = hh + sigma1h + getCarry(t1l, hl) | 0;\n        t1l = t1l + chl | 0, t1h = t1h + chh + getCarry(t1l, chl) | 0, t1l = t1l + Kil | 0, t1h = t1h + Kih + getCarry(t1l, Kil) | 0, t1l = t1l + Wil | 0, t1h = t1h + Wih + getCarry(t1l, Wil) | 0;\n        var t2l = sigma0l + majl | 0, t2h = sigma0h + majh + getCarry(t2l, sigma0l) | 0;\n        hh = gh, hl = gl, gh = fh, gl = fl, fh = eh, fl = el, el = dl + t1l | 0, eh = dh + t1h + getCarry(el, dl) | 0, dh = ch, dl = cl, ch = bh, cl = bl, bh = ah, bl = al, al = t1l + t2l | 0, ah = t1h + t2h + getCarry(al, t1l) | 0;\n      }\n      this._al = this._al + al | 0, this._bl = this._bl + bl | 0, this._cl = this._cl + cl | 0, this._dl = this._dl + dl | 0, this._el = this._el + el | 0, this._fl = this._fl + fl | 0, this._gl = this._gl + gl | 0, this._hl = this._hl + hl | 0, this._ah = this._ah + ah + getCarry(this._al, al) | 0, this._bh = this._bh + bh + getCarry(this._bl, bl) | 0, this._ch = this._ch + ch + getCarry(this._cl, cl) | 0, this._dh = this._dh + dh + getCarry(this._dl, dl) | 0, this._eh = this._eh + eh + getCarry(this._el, el) | 0, this._fh = this._fh + fh + getCarry(this._fl, fl) | 0, this._gh = this._gh + gh + getCarry(this._gl, gl) | 0, this._hh = this._hh + hh + getCarry(this._hl, hl) | 0;\n    }, Sha512.prototype._hash = function() {\n      var H = Buffer2.allocUnsafe(64);\n      function writeInt64BE(h, l, offset) {\n        H.writeInt32BE(h, offset), H.writeInt32BE(l, offset + 4);\n      }\n      return writeInt64BE(this._ah, this._al, 0), writeInt64BE(this._bh, this._bl, 8), writeInt64BE(this._ch, this._cl, 16), writeInt64BE(this._dh, this._dl, 24), writeInt64BE(this._eh, this._el, 32), writeInt64BE(this._fh, this._fl, 40), writeInt64BE(this._gh, this._gl, 48), writeInt64BE(this._hh, this._hl, 56), H;\n    }, module.exports = Sha512;\n  }\n}), require_sha384 = __commonJS({\n  \"node_modules/sha.js/sha384.js\"(exports, module) {\n    var inherits = require_inherits_browser(), SHA512 = require_sha512(), Hash = require_hash(), Buffer2 = require_safe_buffer().Buffer, W = new Array(160);\n    function Sha384() {\n      this.init(), this._w = W, Hash.call(this, 128, 112);\n    }\n    inherits(Sha384, SHA512), Sha384.prototype.init = function() {\n      return this._ah = 3418070365, this._bh = 1654270250, this._ch = 2438529370, this._dh = 355462360, this._eh = 1731405415, this._fh = 2394180231, this._gh = 3675008525, this._hh = 1203062813, this._al = 3238371032, this._bl = 914150663, this._cl = 812702999, this._dl = 4144912697, this._el = 4290775857, this._fl = 1750603025, this._gl = 1694076839, this._hl = 3204075428, this;\n    }, Sha384.prototype._hash = function() {\n      var H = Buffer2.allocUnsafe(48);\n      function writeInt64BE(h, l, offset) {\n        H.writeInt32BE(h, offset), H.writeInt32BE(l, offset + 4);\n      }\n      return writeInt64BE(this._ah, this._al, 0), writeInt64BE(this._bh, this._bl, 8), writeInt64BE(this._ch, this._cl, 16), writeInt64BE(this._dh, this._dl, 24), writeInt64BE(this._eh, this._el, 32), writeInt64BE(this._fh, this._fl, 40), H;\n    }, module.exports = Sha384;\n  }\n}), require_sha2 = __commonJS({\n  \"node_modules/sha.js/index.js\"(exports, module) {\n    var exports = module.exports = function(algorithm) {\n      algorithm = algorithm.toLowerCase();\n      var Algorithm = exports[algorithm];\n      if (!Algorithm)\n        throw new Error(algorithm + \" is not supported (we accept pull requests)\");\n      return new Algorithm;\n    };\n    exports.sha = require_sha(), exports.sha1 = require_sha1(), exports.sha224 = require_sha224(), exports.sha256 = require_sha256(), exports.sha384 = require_sha384(), exports.sha512 = require_sha512();\n  }\n}), require_cipher_base = __commonJS({\n  \"node_modules/cipher-base/index.js\"(exports, module) {\n    var Buffer2 = require_safe_buffer().Buffer, inherits = require_inherits_browser();\n    function CipherBase(hashMode) {\n      StreamModule.Transform.call(this), this.hashMode = typeof hashMode == \"string\", this.hashMode \? this[hashMode] = this._finalOrDigest : this.final = this._finalOrDigest, this._final && (this.__final = this._final, this._final = null), this._decoder = null, this._encoding = null;\n    }\n    inherits(CipherBase, StreamModule.Transform), CipherBase.prototype.update = function(data, inputEnc, outputEnc) {\n      typeof data == \"string\" && (data = Buffer2.from(data, inputEnc));\n      var outData = this._update(data);\n      return this.hashMode \? this : (outputEnc && (outData = this._toString(outData, outputEnc)), outData);\n    }, CipherBase.prototype.setAutoPadding = function() {\n    }, CipherBase.prototype.getAuthTag = function() {\n      throw new Error(\"trying to get auth tag in unsupported state\");\n    }, CipherBase.prototype.setAuthTag = function() {\n      throw new Error(\"trying to set auth tag in unsupported state\");\n    }, CipherBase.prototype.setAAD = function() {\n      throw new Error(\"trying to set aad in unsupported state\");\n    }, CipherBase.prototype._transform = function(data, _, next) {\n      var err;\n      try {\n        this.hashMode \? this._update(data) : this.push(this._update(data));\n      } catch (e) {\n        err = e;\n      } finally {\n        next(err);\n      }\n    }, CipherBase.prototype._flush = function(done) {\n      var err;\n      try {\n        this.push(this.__final());\n      } catch (e) {\n        err = e;\n      }\n      done(err);\n    }, CipherBase.prototype._finalOrDigest = function(outputEnc) {\n      var outData = this.__final() || Buffer2.alloc(0);\n      return outputEnc && (outData = this._toString(outData, outputEnc, !0)), outData;\n    }, CipherBase.prototype._toString = function(value, enc, fin) {\n      if (this._decoder || (this._decoder = new StringDecoder(enc), this._encoding = enc), this._encoding !== enc)\n        throw new Error(\"can't switch encodings\");\n      var out = this._decoder.write(value);\n      return fin && (out += this._decoder.end()), out;\n    }, module.exports = CipherBase;\n  }\n}), require_browser2 = __commonJS({\n  \"node_modules/create-hash/browser.js\"(exports, module) {\n    const LazyHash = function Hash(algorithm, options) {\n      this._options = options, this._hasher = new CryptoHasher(algorithm, options), this._finalized = !1;\n    };\n    LazyHash.prototype = Object.create(StreamModule.Transform.prototype), LazyHash.prototype.update = function update(data, encoding) {\n      return this._checkFinalized(), this._hasher.update(data, encoding), this;\n    }, LazyHash.prototype.digest = function update(data, encoding) {\n      return this._checkFinalized(), this._finalized = !0, this._hasher.digest(data, encoding);\n    }, LazyHash.prototype._checkFinalized = function _checkFinalized() {\n      if (this._finalized) {\n        var err = new Error(\"Digest already called\");\n        throw err.code = \"ERR_CRYPTO_HASH_FINALIZED\", err;\n      }\n    }, LazyHash.prototype.copy = function copy() {\n      const copy = Object.create(LazyHash.prototype);\n      return copy._options = this._options, copy._hasher = this._hasher.copy(), copy._finalized = this._finalized, copy;\n    };\n    const lazyHashFullInitProto = {\n      __proto__: StreamModule.Transform.prototype,\n      ...LazyHash.prototype,\n      _transform(data, encoding, callback) {\n        this.update(data, encoding), callback && callback();\n      },\n      _flush(callback) {\n        this.push(this.digest()), callback();\n      }\n    }, triggerMethods = [\n      \"_events\",\n      \"_eventsCount\",\n      \"_final\",\n      \"_maxListeners\",\n      \"_maxListeners\",\n      \"_read\",\n      \"_undestroy\",\n      \"_writableState\",\n      \"_write\",\n      \"_writev\",\n      \"addListener\",\n      \"asIndexedPairs\",\n      \"closed\",\n      \"compose\",\n      \"constructor\",\n      \"cork\",\n      \"destroy\",\n      \"destroyed\",\n      \"drop\",\n      \"emit\",\n      \"end\",\n      \"errored\",\n      \"eventNames\",\n      \"every\",\n      \"filter\",\n      \"find\",\n      \"flatMap\",\n      \"forEach\",\n      \"getMaxListeners\",\n      \"hasOwnProperty\",\n      \"isPaused\",\n      \"isPrototypeOf\",\n      \"iterator\",\n      \"listenerCount\",\n      \"listeners\",\n      \"map\",\n      \"off\",\n      \"on\",\n      \"once\",\n      \"pause\",\n      \"pipe\",\n      \"prependListener\",\n      \"prependOnceListener\",\n      \"propertyIsEnumerable\",\n      \"push\",\n      \"rawListeners\",\n      \"read\",\n      \"readable\",\n      \"readableAborted\",\n      \"readableBuffer\",\n      \"readableDidRead\",\n      \"readableEncoding\",\n      \"readableEnded\",\n      \"readableFlowing\",\n      \"readableHighWaterMark\",\n      \"readableLength\",\n      \"readableObjectMode\",\n      \"reduce\",\n      \"removeAllListeners\",\n      \"removeListener\",\n      \"resume\",\n      \"setDefaultEncoding\",\n      \"setEncoding\",\n      \"setMaxListeners\",\n      \"some\",\n      \"take\",\n      \"toArray\",\n      \"toLocaleString\",\n      \"toString\",\n      \"uncork\",\n      \"unpipe\",\n      \"unshift\",\n      \"valueOf\",\n      \"wrap\",\n      \"writable\",\n      \"writableBuffer\",\n      \"writableCorked\",\n      \"writableEnded\",\n      \"writableFinished\",\n      \"writableHighWaterMark\",\n      \"writableLength\",\n      \"writableNeedDrain\",\n      \"writableObjectMode\",\n      \"write\"\n    ];\n    for (let method of triggerMethods)\n      Object.defineProperty(LazyHash.prototype, method, {\n        get() {\n          return Object.setPrototypeOf(this, lazyHashFullInitProto), StreamModule.Transform.call(this, this._options), this[method];\n        },\n        enumerable: !1,\n        configurable: !0\n      });\n    module.exports = function createHash(algorithm) {\n      return new LazyHash(algorithm);\n    }, module.exports.createHash = module.exports, module.exports.Hash = LazyHash;\n  }\n}), require_legacy = __commonJS({\n  \"node_modules/create-hmac/legacy.js\"(exports, module) {\n    var inherits = require_inherits_browser(), Buffer2 = require_safe_buffer().Buffer, Base = require_cipher_base(), ZEROS = Buffer2.alloc(128), blocksize = 64;\n    function Hmac(alg, key) {\n      Base.call(this, \"digest\"), typeof key == \"string\" && (key = Buffer2.from(key)), this._alg = alg, this._key = key, key.length > blocksize \? key = alg(key) : key.length < blocksize && (key = Buffer2.concat([key, ZEROS], blocksize));\n      for (var ipad = this._ipad = Buffer2.allocUnsafe(blocksize), opad = this._opad = Buffer2.allocUnsafe(blocksize), i = 0;i < blocksize; i++)\n        ipad[i] = key[i] ^ 54, opad[i] = key[i] ^ 92;\n      this._hash = [ipad];\n    }\n    Hmac.prototype = {}, inherits(Hmac, Base), Hmac.prototype._update = function(data) {\n      this._hash.push(data);\n    }, Hmac.prototype._final = function() {\n      var h = this._alg(Buffer2.concat(this._hash));\n      return this._alg(Buffer2.concat([this._opad, h]));\n    }, module.exports = Hmac;\n  }\n}), require_md52 = __commonJS({\n  \"node_modules/create-hash/md5.js\"(exports, module) {\n    var MD5 = require_md5();\n    module.exports = function(buffer) {\n      return new MD5().update(buffer).digest();\n    };\n  }\n}), require_browser3 = __commonJS({\n  \"node_modules/create-hmac/browser.js\"(exports, module) {\n    var inherits = require_inherits_browser(), Legacy = require_legacy(), Base = require_cipher_base(), Buffer2 = require_safe_buffer().Buffer, md5 = require_md52(), RIPEMD160 = require_ripemd160(), sha = require_sha2(), ZEROS = Buffer2.alloc(128);\n    function Hmac(alg, key) {\n      Base.call(this, \"digest\"), typeof key == \"string\" && (key = Buffer2.from(key));\n      var blocksize = alg === \"sha512\" || alg === \"sha384\" \? 128 : 64;\n      if (this._alg = alg, this._key = key, key.length > blocksize) {\n        var hash = alg === \"rmd160\" \? new RIPEMD160 : sha(alg);\n        key = hash.update(key).digest();\n      } else\n        key.length < blocksize && (key = Buffer2.concat([key, ZEROS], blocksize));\n      for (var ipad = this._ipad = Buffer2.allocUnsafe(blocksize), opad = this._opad = Buffer2.allocUnsafe(blocksize), i = 0;i < blocksize; i++)\n        ipad[i] = key[i] ^ 54, opad[i] = key[i] ^ 92;\n      this._hash = alg === \"rmd160\" \? new RIPEMD160 : sha(alg), this._hash.update(ipad);\n    }\n    inherits(Hmac, Base), Hmac.prototype._update = function(data) {\n      this._hash.update(data);\n    }, Hmac.prototype._final = function() {\n      var h = this._hash.digest(), hash = this._alg === \"rmd160\" \? new RIPEMD160 : sha(this._alg);\n      return hash.update(this._opad).update(h).digest();\n    }, module.exports = function(alg, key) {\n      return alg = alg.toLowerCase(), alg === \"rmd160\" || alg === \"ripemd160\" \? new Hmac(\"rmd160\", key) : alg === \"md5\" \? new Legacy(md5, key) : new Hmac(alg, key);\n    };\n  }\n}), require_algorithms = __commonJS({\n  \"node_modules/browserify-sign/browser/algorithms.json\"(exports, module) {\n    module.exports = {\n      sha224WithRSAEncryption: {\n        sign: \"rsa\",\n        hash: \"sha224\",\n        id: \"302d300d06096086480165030402040500041c\"\n      },\n      \"RSA-SHA224\": {\n        sign: \"ecdsa/rsa\",\n        hash: \"sha224\",\n        id: \"302d300d06096086480165030402040500041c\"\n      },\n      sha256WithRSAEncryption: {\n        sign: \"rsa\",\n        hash: \"sha256\",\n        id: \"3031300d060960864801650304020105000420\"\n      },\n      \"RSA-SHA256\": {\n        sign: \"ecdsa/rsa\",\n        hash: \"sha256\",\n        id: \"3031300d060960864801650304020105000420\"\n      },\n      sha384WithRSAEncryption: {\n        sign: \"rsa\",\n        hash: \"sha384\",\n        id: \"3041300d060960864801650304020205000430\"\n      },\n      \"RSA-SHA384\": {\n        sign: \"ecdsa/rsa\",\n        hash: \"sha384\",\n        id: \"3041300d060960864801650304020205000430\"\n      },\n      sha512WithRSAEncryption: {\n        sign: \"rsa\",\n        hash: \"sha512\",\n        id: \"3051300d060960864801650304020305000440\"\n      },\n      \"RSA-SHA512\": {\n        sign: \"ecdsa/rsa\",\n        hash: \"sha512\",\n        id: \"3051300d060960864801650304020305000440\"\n      },\n      \"RSA-SHA1\": {\n        sign: \"rsa\",\n        hash: \"sha1\",\n        id: \"3021300906052b0e03021a05000414\"\n      },\n      \"ecdsa-with-SHA1\": {\n        sign: \"ecdsa\",\n        hash: \"sha1\",\n        id: \"\"\n      },\n      sha256: {\n        sign: \"ecdsa\",\n        hash: \"sha256\",\n        id: \"\"\n      },\n      sha224: {\n        sign: \"ecdsa\",\n        hash: \"sha224\",\n        id: \"\"\n      },\n      sha384: {\n        sign: \"ecdsa\",\n        hash: \"sha384\",\n        id: \"\"\n      },\n      sha512: {\n        sign: \"ecdsa\",\n        hash: \"sha512\",\n        id: \"\"\n      },\n      \"DSA-SHA\": {\n        sign: \"dsa\",\n        hash: \"sha1\",\n        id: \"\"\n      },\n      \"DSA-SHA1\": {\n        sign: \"dsa\",\n        hash: \"sha1\",\n        id: \"\"\n      },\n      DSA: {\n        sign: \"dsa\",\n        hash: \"sha1\",\n        id: \"\"\n      },\n      \"DSA-WITH-SHA224\": {\n        sign: \"dsa\",\n        hash: \"sha224\",\n        id: \"\"\n      },\n      \"DSA-SHA224\": {\n        sign: \"dsa\",\n        hash: \"sha224\",\n        id: \"\"\n      },\n      \"DSA-WITH-SHA256\": {\n        sign: \"dsa\",\n        hash: \"sha256\",\n        id: \"\"\n      },\n      \"DSA-SHA256\": {\n        sign: \"dsa\",\n        hash: \"sha256\",\n        id: \"\"\n      },\n      \"DSA-WITH-SHA384\": {\n        sign: \"dsa\",\n        hash: \"sha384\",\n        id: \"\"\n      },\n      \"DSA-SHA384\": {\n        sign: \"dsa\",\n        hash: \"sha384\",\n        id: \"\"\n      },\n      \"DSA-WITH-SHA512\": {\n        sign: \"dsa\",\n        hash: \"sha512\",\n        id: \"\"\n      },\n      \"DSA-SHA512\": {\n        sign: \"dsa\",\n        hash: \"sha512\",\n        id: \"\"\n      },\n      \"DSA-RIPEMD160\": {\n        sign: \"dsa\",\n        hash: \"rmd160\",\n        id: \"\"\n      },\n      ripemd160WithRSA: {\n        sign: \"rsa\",\n        hash: \"rmd160\",\n        id: \"3021300906052b2403020105000414\"\n      },\n      \"RSA-RIPEMD160\": {\n        sign: \"rsa\",\n        hash: \"rmd160\",\n        id: \"3021300906052b2403020105000414\"\n      },\n      md5WithRSAEncryption: {\n        sign: \"rsa\",\n        hash: \"md5\",\n        id: \"3020300c06082a864886f70d020505000410\"\n      },\n      \"RSA-MD5\": {\n        sign: \"rsa\",\n        hash: \"md5\",\n        id: \"3020300c06082a864886f70d020505000410\"\n      }\n    };\n  }\n}), require_algos = __commonJS({\n  \"node_modules/browserify-sign/algos.js\"(exports, module) {\n    module.exports = require_algorithms();\n  }\n}), require_precondition = __commonJS({\n  \"node_modules/pbkdf2/lib/precondition.js\"(exports, module) {\n    var MAX_ALLOC = Math.pow(2, 30) - 1;\n    module.exports = function(iterations, keylen) {\n      if (typeof iterations != \"number\")\n        @throwTypeError(\"Iterations not a number\");\n      if (iterations < 0)\n        @throwTypeError(\"Bad iterations\");\n      if (typeof keylen != \"number\")\n        @throwTypeError(\"Key length not a number\");\n      if (keylen < 0 || keylen > MAX_ALLOC || keylen !== keylen)\n        @throwTypeError(\"Bad key length\");\n    };\n  }\n}), require_default_encoding = __commonJS({\n  \"node_modules/pbkdf2/lib/default-encoding.js\"(exports, module) {\n    var defaultEncoding;\n    global.process && global.process.browser \? defaultEncoding = \"utf-8\" : global.process && global.process.version \? (pVersionMajor = parseInt(process.version.split(\".\")[0].slice(1), 10), defaultEncoding = pVersionMajor >= 6 \? \"utf-8\" : \"binary\") : defaultEncoding = \"utf-8\";\n    var pVersionMajor;\n    module.exports = defaultEncoding;\n  }\n}), require_to_buffer = __commonJS({\n  \"node_modules/pbkdf2/lib/to-buffer.js\"(exports, module) {\n    var Buffer2 = require_safe_buffer().Buffer;\n    module.exports = function(thing, encoding, name) {\n      if (Buffer2.isBuffer(thing))\n        return thing;\n      if (typeof thing == \"string\")\n        return Buffer2.from(thing, encoding);\n      if (ArrayBuffer.isView(thing))\n        return Buffer2.from(thing.buffer);\n      @throwTypeError(name + \" must be a string, a Buffer, a typed array or a DataView\");\n    };\n  }\n}), require_sync_browser = __commonJS({\n  \"node_modules/pbkdf2/lib/sync-browser.js\"(exports, module) {\n    var md5 = require_md52(), RIPEMD160 = require_ripemd160(), sha = require_sha2(), Buffer2 = require_safe_buffer().Buffer, checkParameters = require_precondition(), defaultEncoding = require_default_encoding(), toBuffer = require_to_buffer(), ZEROS = Buffer2.alloc(128), sizes = {\n      md5: 16,\n      sha1: 20,\n      sha224: 28,\n      sha256: 32,\n      sha384: 48,\n      sha512: 64,\n      rmd160: 20,\n      ripemd160: 20\n    };\n    function Hmac(alg, key, saltLen) {\n      var hash = getDigest(alg), blocksize = alg === \"sha512\" || alg === \"sha384\" \? 128 : 64;\n      key.length > blocksize \? key = hash(key) : key.length < blocksize && (key = Buffer2.concat([key, ZEROS], blocksize));\n      for (var ipad = Buffer2.allocUnsafe(blocksize + sizes[alg]), opad = Buffer2.allocUnsafe(blocksize + sizes[alg]), i = 0;i < blocksize; i++)\n        ipad[i] = key[i] ^ 54, opad[i] = key[i] ^ 92;\n      var ipad1 = Buffer2.allocUnsafe(blocksize + saltLen + 4);\n      ipad.copy(ipad1, 0, 0, blocksize), this.ipad1 = ipad1, this.ipad2 = ipad, this.opad = opad, this.alg = alg, this.blocksize = blocksize, this.hash = hash, this.size = sizes[alg];\n    }\n    Hmac.prototype = {}, Hmac.prototype.run = function(data, ipad) {\n      data.copy(ipad, this.blocksize);\n      var h = this.hash(ipad);\n      return h.copy(this.opad, this.blocksize), this.hash(this.opad);\n    };\n    function getDigest(alg) {\n      function shaFunc(data) {\n        return sha(alg).update(data).digest();\n      }\n      function rmd160Func(data) {\n        return new RIPEMD160().update(data).digest();\n      }\n      return alg === \"rmd160\" || alg === \"ripemd160\" \? rmd160Func : alg === \"md5\" \? md5 : shaFunc;\n    }\n    function pbkdf2(password, salt, iterations, keylen, digest) {\n      checkParameters(iterations, keylen), password = toBuffer(password, defaultEncoding, \"Password\"), salt = toBuffer(salt, defaultEncoding, \"Salt\"), digest = digest || \"sha1\";\n      var hmac = new Hmac(digest, password, salt.length), DK = Buffer2.allocUnsafe(keylen), block1 = Buffer2.allocUnsafe(salt.length + 4);\n      salt.copy(block1, 0, 0, salt.length);\n      for (var destPos = 0, hLen = sizes[digest], l = Math.ceil(keylen / hLen), i = 1;i <= l; i++) {\n        block1.writeUInt32BE(i, salt.length);\n        for (var T = hmac.run(block1, hmac.ipad1), U = T, j = 1;j < iterations; j++) {\n          U = hmac.run(U, hmac.ipad2);\n          for (var k = 0;k < hLen; k++)\n            T[k] ^= U[k];\n        }\n        T.copy(DK, destPos), destPos += hLen;\n      }\n      return DK;\n    }\n    module.exports = pbkdf2;\n  }\n}), require_async = __commonJS({\n  \"node_modules/pbkdf2/lib/async.js\"(exports, module) {\n    var Buffer2 = require_safe_buffer().Buffer, checkParameters = require_precondition(), defaultEncoding = require_default_encoding(), sync = require_sync_browser(), toBuffer = require_to_buffer(), ZERO_BUF, subtle = globalCrypto.subtle, toBrowser = {\n      sha: \"SHA-1\",\n      \"sha-1\": \"SHA-1\",\n      sha1: \"SHA-1\",\n      sha256: \"SHA-256\",\n      \"sha-256\": \"SHA-256\",\n      sha384: \"SHA-384\",\n      \"sha-384\": \"SHA-384\",\n      \"sha-512\": \"SHA-512\",\n      sha512: \"SHA-512\"\n    }, checks = [];\n    function checkNative(algo) {\n      if (global.process && !global.process.browser || !subtle || !subtle.importKey || !subtle.deriveBits)\n        return Promise.resolve(!1);\n      if (checks[algo] !== void 0)\n        return checks[algo];\n      ZERO_BUF = ZERO_BUF || Buffer2.alloc(8);\n      var prom = browserPbkdf2(ZERO_BUF, ZERO_BUF, 10, 128, algo).then(function() {\n        return !0;\n      }).catch(function() {\n        return !1;\n      });\n      return checks[algo] = prom, prom;\n    }\n    var nextTick;\n    function getNextTick() {\n      return nextTick || (global.process && global.process.nextTick \? nextTick = global.process.nextTick : global.queueMicrotask \? nextTick = global.queueMicrotask : global.setImmediate \? nextTick = global.setImmediate : nextTick = global.setTimeout, nextTick);\n    }\n    function browserPbkdf2(password, salt, iterations, length, algo) {\n      return subtle.importKey(\"raw\", password, { name: \"PBKDF2\" }, !1, [\"deriveBits\"]).then(function(key) {\n        return subtle.deriveBits({\n          name: \"PBKDF2\",\n          salt,\n          iterations,\n          hash: {\n            name: algo\n          }\n        }, key, length << 3);\n      }).then(function(res) {\n        return Buffer2.from(res);\n      });\n    }\n    function resolvePromise(promise, callback) {\n      promise.then(function(out) {\n        getNextTick()(function() {\n          callback(null, out);\n        });\n      }, function(e) {\n        getNextTick()(function() {\n          callback(e);\n        });\n      });\n    }\n    module.exports = function(password, salt, iterations, keylen, digest, callback) {\n      typeof digest == \"function\" && (callback = digest, digest = void 0), digest = digest || \"sha1\";\n      var algo = toBrowser[digest.toLowerCase()];\n      if (!algo || typeof global.Promise != \"function\") {\n        getNextTick()(function() {\n          var out;\n          try {\n            out = sync(password, salt, iterations, keylen, digest);\n          } catch (e) {\n            return callback(e);\n          }\n          callback(null, out);\n        });\n        return;\n      }\n      if (checkParameters(iterations, keylen), password = toBuffer(password, defaultEncoding, \"Password\"), salt = toBuffer(salt, defaultEncoding, \"Salt\"), typeof callback != \"function\")\n        throw new Error(\"No callback provided to pbkdf2\");\n      resolvePromise(checkNative(algo).then(function(resp) {\n        return resp \? browserPbkdf2(password, salt, iterations, keylen, algo) : sync(password, salt, iterations, keylen, digest);\n      }), callback);\n    };\n  }\n}), require_browser4 = __commonJS({\n  \"node_modules/pbkdf2/browser.js\"(exports) {\n    exports.pbkdf2 = require_async(), exports.pbkdf2Sync = require_sync_browser();\n  }\n}), require_utils = __commonJS({\n  \"node_modules/des.js/lib/des/utils.js\"(exports) {\n    exports.readUInt32BE = function(bytes, off) {\n      var res = bytes[0 + off] << 24 | bytes[1 + off] << 16 | bytes[2 + off] << 8 | bytes[3 + off];\n      return res >>> 0;\n    }, exports.writeUInt32BE = function(bytes, value, off) {\n      bytes[0 + off] = value >>> 24, bytes[1 + off] = value >>> 16 & 255, bytes[2 + off] = value >>> 8 & 255, bytes[3 + off] = value & 255;\n    }, exports.ip = function(inL, inR, out, off) {\n      for (var outL = 0, outR = 0, i = 6;i >= 0; i -= 2) {\n        for (var j = 0;j <= 24; j += 8)\n          outL <<= 1, outL |= inR >>> j + i & 1;\n        for (var j = 0;j <= 24; j += 8)\n          outL <<= 1, outL |= inL >>> j + i & 1;\n      }\n      for (var i = 6;i >= 0; i -= 2) {\n        for (var j = 1;j <= 25; j += 8)\n          outR <<= 1, outR |= inR >>> j + i & 1;\n        for (var j = 1;j <= 25; j += 8)\n          outR <<= 1, outR |= inL >>> j + i & 1;\n      }\n      out[off + 0] = outL >>> 0, out[off + 1] = outR >>> 0;\n    }, exports.rip = function(inL, inR, out, off) {\n      for (var outL = 0, outR = 0, i = 0;i < 4; i++)\n        for (var j = 24;j >= 0; j -= 8)\n          outL <<= 1, outL |= inR >>> j + i & 1, outL <<= 1, outL |= inL >>> j + i & 1;\n      for (var i = 4;i < 8; i++)\n        for (var j = 24;j >= 0; j -= 8)\n          outR <<= 1, outR |= inR >>> j + i & 1, outR <<= 1, outR |= inL >>> j + i & 1;\n      out[off + 0] = outL >>> 0, out[off + 1] = outR >>> 0;\n    }, exports.pc1 = function(inL, inR, out, off) {\n      for (var outL = 0, outR = 0, i = 7;i >= 5; i--) {\n        for (var j = 0;j <= 24; j += 8)\n          outL <<= 1, outL |= inR >> j + i & 1;\n        for (var j = 0;j <= 24; j += 8)\n          outL <<= 1, outL |= inL >> j + i & 1;\n      }\n      for (var j = 0;j <= 24; j += 8)\n        outL <<= 1, outL |= inR >> j + i & 1;\n      for (var i = 1;i <= 3; i++) {\n        for (var j = 0;j <= 24; j += 8)\n          outR <<= 1, outR |= inR >> j + i & 1;\n        for (var j = 0;j <= 24; j += 8)\n          outR <<= 1, outR |= inL >> j + i & 1;\n      }\n      for (var j = 0;j <= 24; j += 8)\n        outR <<= 1, outR |= inL >> j + i & 1;\n      out[off + 0] = outL >>> 0, out[off + 1] = outR >>> 0;\n    }, exports.r28shl = function(num, shift) {\n      return num << shift & 268435455 | num >>> 28 - shift;\n    };\n    var pc2table = [\n      14,\n      11,\n      17,\n      4,\n      27,\n      23,\n      25,\n      0,\n      13,\n      22,\n      7,\n      18,\n      5,\n      9,\n      16,\n      24,\n      2,\n      20,\n      12,\n      21,\n      1,\n      8,\n      15,\n      26,\n      15,\n      4,\n      25,\n      19,\n      9,\n      1,\n      26,\n      16,\n      5,\n      11,\n      23,\n      8,\n      12,\n      7,\n      17,\n      0,\n      22,\n      3,\n      10,\n      14,\n      6,\n      20,\n      27,\n      24\n    ];\n    exports.pc2 = function(inL, inR, out, off) {\n      for (var outL = 0, outR = 0, len = pc2table.length >>> 1, i = 0;i < len; i++)\n        outL <<= 1, outL |= inL >>> pc2table[i] & 1;\n      for (var i = len;i < pc2table.length; i++)\n        outR <<= 1, outR |= inR >>> pc2table[i] & 1;\n      out[off + 0] = outL >>> 0, out[off + 1] = outR >>> 0;\n    }, exports.expand = function(r, out, off) {\n      var outL = 0, outR = 0;\n      outL = (r & 1) << 5 | r >>> 27;\n      for (var i = 23;i >= 15; i -= 4)\n        outL <<= 6, outL |= r >>> i & 63;\n      for (var i = 11;i >= 3; i -= 4)\n        outR |= r >>> i & 63, outR <<= 6;\n      outR |= (r & 31) << 1 | r >>> 31, out[off + 0] = outL >>> 0, out[off + 1] = outR >>> 0;\n    };\n    var sTable = [\n      14,\n      0,\n      4,\n      15,\n      13,\n      7,\n      1,\n      4,\n      2,\n      14,\n      15,\n      2,\n      11,\n      13,\n      8,\n      1,\n      3,\n      10,\n      10,\n      6,\n      6,\n      12,\n      12,\n      11,\n      5,\n      9,\n      9,\n      5,\n      0,\n      3,\n      7,\n      8,\n      4,\n      15,\n      1,\n      12,\n      14,\n      8,\n      8,\n      2,\n      13,\n      4,\n      6,\n      9,\n      2,\n      1,\n      11,\n      7,\n      15,\n      5,\n      12,\n      11,\n      9,\n      3,\n      7,\n      14,\n      3,\n      10,\n      10,\n      0,\n      5,\n      6,\n      0,\n      13,\n      15,\n      3,\n      1,\n      13,\n      8,\n      4,\n      14,\n      7,\n      6,\n      15,\n      11,\n      2,\n      3,\n      8,\n      4,\n      14,\n      9,\n      12,\n      7,\n      0,\n      2,\n      1,\n      13,\n      10,\n      12,\n      6,\n      0,\n      9,\n      5,\n      11,\n      10,\n      5,\n      0,\n      13,\n      14,\n      8,\n      7,\n      10,\n      11,\n      1,\n      10,\n      3,\n      4,\n      15,\n      13,\n      4,\n      1,\n      2,\n      5,\n      11,\n      8,\n      6,\n      12,\n      7,\n      6,\n      12,\n      9,\n      0,\n      3,\n      5,\n      2,\n      14,\n      15,\n      9,\n      10,\n      13,\n      0,\n      7,\n      9,\n      0,\n      14,\n      9,\n      6,\n      3,\n      3,\n      4,\n      15,\n      6,\n      5,\n      10,\n      1,\n      2,\n      13,\n      8,\n      12,\n      5,\n      7,\n      14,\n      11,\n      12,\n      4,\n      11,\n      2,\n      15,\n      8,\n      1,\n      13,\n      1,\n      6,\n      10,\n      4,\n      13,\n      9,\n      0,\n      8,\n      6,\n      15,\n      9,\n      3,\n      8,\n      0,\n      7,\n      11,\n      4,\n      1,\n      15,\n      2,\n      14,\n      12,\n      3,\n      5,\n      11,\n      10,\n      5,\n      14,\n      2,\n      7,\n      12,\n      7,\n      13,\n      13,\n      8,\n      14,\n      11,\n      3,\n      5,\n      0,\n      6,\n      6,\n      15,\n      9,\n      0,\n      10,\n      3,\n      1,\n      4,\n      2,\n      7,\n      8,\n      2,\n      5,\n      12,\n      11,\n      1,\n      12,\n      10,\n      4,\n      14,\n      15,\n      9,\n      10,\n      3,\n      6,\n      15,\n      9,\n      0,\n      0,\n      6,\n      12,\n      10,\n      11,\n      1,\n      7,\n      13,\n      13,\n      8,\n      15,\n      9,\n      1,\n      4,\n      3,\n      5,\n      14,\n      11,\n      5,\n      12,\n      2,\n      7,\n      8,\n      2,\n      4,\n      14,\n      2,\n      14,\n      12,\n      11,\n      4,\n      2,\n      1,\n      12,\n      7,\n      4,\n      10,\n      7,\n      11,\n      13,\n      6,\n      1,\n      8,\n      5,\n      5,\n      0,\n      3,\n      15,\n      15,\n      10,\n      13,\n      3,\n      0,\n      9,\n      14,\n      8,\n      9,\n      6,\n      4,\n      11,\n      2,\n      8,\n      1,\n      12,\n      11,\n      7,\n      10,\n      1,\n      13,\n      14,\n      7,\n      2,\n      8,\n      13,\n      15,\n      6,\n      9,\n      15,\n      12,\n      0,\n      5,\n      9,\n      6,\n      10,\n      3,\n      4,\n      0,\n      5,\n      14,\n      3,\n      12,\n      10,\n      1,\n      15,\n      10,\n      4,\n      15,\n      2,\n      9,\n      7,\n      2,\n      12,\n      6,\n      9,\n      8,\n      5,\n      0,\n      6,\n      13,\n      1,\n      3,\n      13,\n      4,\n      14,\n      14,\n      0,\n      7,\n      11,\n      5,\n      3,\n      11,\n      8,\n      9,\n      4,\n      14,\n      3,\n      15,\n      2,\n      5,\n      12,\n      2,\n      9,\n      8,\n      5,\n      12,\n      15,\n      3,\n      10,\n      7,\n      11,\n      0,\n      14,\n      4,\n      1,\n      10,\n      7,\n      1,\n      6,\n      13,\n      0,\n      11,\n      8,\n      6,\n      13,\n      4,\n      13,\n      11,\n      0,\n      2,\n      11,\n      14,\n      7,\n      15,\n      4,\n      0,\n      9,\n      8,\n      1,\n      13,\n      10,\n      3,\n      14,\n      12,\n      3,\n      9,\n      5,\n      7,\n      12,\n      5,\n      2,\n      10,\n      15,\n      6,\n      8,\n      1,\n      6,\n      1,\n      6,\n      4,\n      11,\n      11,\n      13,\n      13,\n      8,\n      12,\n      1,\n      3,\n      4,\n      7,\n      10,\n      14,\n      7,\n      10,\n      9,\n      15,\n      5,\n      6,\n      0,\n      8,\n      15,\n      0,\n      14,\n      5,\n      2,\n      9,\n      3,\n      2,\n      12,\n      13,\n      1,\n      2,\n      15,\n      8,\n      13,\n      4,\n      8,\n      6,\n      10,\n      15,\n      3,\n      11,\n      7,\n      1,\n      4,\n      10,\n      12,\n      9,\n      5,\n      3,\n      6,\n      14,\n      11,\n      5,\n      0,\n      0,\n      14,\n      12,\n      9,\n      7,\n      2,\n      7,\n      2,\n      11,\n      1,\n      4,\n      14,\n      1,\n      7,\n      9,\n      4,\n      12,\n      10,\n      14,\n      8,\n      2,\n      13,\n      0,\n      15,\n      6,\n      12,\n      10,\n      9,\n      13,\n      0,\n      15,\n      3,\n      3,\n      5,\n      5,\n      6,\n      8,\n      11\n    ];\n    exports.substitute = function(inL, inR) {\n      for (var out = 0, i = 0;i < 4; i++) {\n        var b = inL >>> 18 - i * 6 & 63, sb = sTable[i * 64 + b];\n        out <<= 4, out |= sb;\n      }\n      for (var i = 0;i < 4; i++) {\n        var b = inR >>> 18 - i * 6 & 63, sb = sTable[256 + i * 64 + b];\n        out <<= 4, out |= sb;\n      }\n      return out >>> 0;\n    };\n    var permuteTable = [\n      16,\n      25,\n      12,\n      11,\n      3,\n      20,\n      4,\n      15,\n      31,\n      17,\n      9,\n      6,\n      27,\n      14,\n      1,\n      22,\n      30,\n      24,\n      8,\n      18,\n      0,\n      5,\n      29,\n      23,\n      13,\n      19,\n      2,\n      26,\n      10,\n      21,\n      28,\n      7\n    ];\n    exports.permute = function(num) {\n      for (var out = 0, i = 0;i < permuteTable.length; i++)\n        out <<= 1, out |= num >>> permuteTable[i] & 1;\n      return out >>> 0;\n    }, exports.padSplit = function(num, size, group) {\n      for (var str = num.toString(2);str.length < size; )\n        str = \"0\" + str;\n      for (var out = [], i = 0;i < size; i += group)\n        out.push(str.slice(i, i + group));\n      return out.join(\" \");\n    };\n  }\n}), require_minimalistic_assert = __commonJS({\n  \"node_modules/minimalistic-assert/index.js\"(exports, module) {\n    module.exports = assert;\n    function assert(val, msg) {\n      if (!val)\n        throw new Error(msg || \"Assertion failed\");\n    }\n    assert.equal = function(l, r, msg) {\n      if (l != r)\n        throw new Error(msg || \"Assertion failed: \" + l + \" != \" + r);\n    };\n  }\n}), require_cipher = __commonJS({\n  \"node_modules/des.js/lib/des/cipher.js\"(exports, module) {\n    var assert = require_minimalistic_assert();\n    function Cipher(options) {\n      this.options = options, this.type = this.options.type, this.blockSize = 8, this._init(), this.buffer = new Array(this.blockSize), this.bufferOff = 0;\n    }\n    Cipher.prototype = {}, module.exports = Cipher, Cipher.prototype._init = function() {\n    }, Cipher.prototype.update = function(data) {\n      return data.length === 0 \? [] : this.type === \"decrypt\" \? this._updateDecrypt(data) : this._updateEncrypt(data);\n    }, Cipher.prototype._buffer = function(data, off) {\n      for (var min = Math.min(this.buffer.length - this.bufferOff, data.length - off), i = 0;i < min; i++)\n        this.buffer[this.bufferOff + i] = data[off + i];\n      return this.bufferOff += min, min;\n    }, Cipher.prototype._flushBuffer = function(out, off) {\n      return this._update(this.buffer, 0, out, off), this.bufferOff = 0, this.blockSize;\n    }, Cipher.prototype._updateEncrypt = function(data) {\n      var inputOff = 0, outputOff = 0, count = (this.bufferOff + data.length) / this.blockSize | 0, out = new Array(count * this.blockSize);\n      this.bufferOff !== 0 && (inputOff += this._buffer(data, inputOff), this.bufferOff === this.buffer.length && (outputOff += this._flushBuffer(out, outputOff)));\n      for (var max = data.length - (data.length - inputOff) % this.blockSize;inputOff < max; inputOff += this.blockSize)\n        this._update(data, inputOff, out, outputOff), outputOff += this.blockSize;\n      for (;inputOff < data.length; inputOff++, this.bufferOff++)\n        this.buffer[this.bufferOff] = data[inputOff];\n      return out;\n    }, Cipher.prototype._updateDecrypt = function(data) {\n      for (var inputOff = 0, outputOff = 0, count = Math.ceil((this.bufferOff + data.length) / this.blockSize) - 1, out = new Array(count * this.blockSize);count > 0; count--)\n        inputOff += this._buffer(data, inputOff), outputOff += this._flushBuffer(out, outputOff);\n      return inputOff += this._buffer(data, inputOff), out;\n    }, Cipher.prototype.final = function(buffer) {\n      var first;\n      buffer && (first = this.update(buffer));\n      var last;\n      return this.type === \"encrypt\" \? last = this._finalEncrypt() : last = this._finalDecrypt(), first \? first.concat(last) : last;\n    }, Cipher.prototype._pad = function(buffer, off) {\n      if (off === 0)\n        return !1;\n      for (;off < buffer.length; )\n        buffer[off++] = 0;\n      return !0;\n    }, Cipher.prototype._finalEncrypt = function() {\n      if (!this._pad(this.buffer, this.bufferOff))\n        return [];\n      var out = new Array(this.blockSize);\n      return this._update(this.buffer, 0, out, 0), out;\n    }, Cipher.prototype._unpad = function(buffer) {\n      return buffer;\n    }, Cipher.prototype._finalDecrypt = function() {\n      assert.equal(this.bufferOff, this.blockSize, \"Not enough data to decrypt\");\n      var out = new Array(this.blockSize);\n      return this._flushBuffer(out, 0), this._unpad(out);\n    };\n  }\n}), require_des = __commonJS({\n  \"node_modules/des.js/lib/des/des.js\"(exports, module) {\n    var assert = require_minimalistic_assert(), inherits = require_inherits_browser(), utils = require_utils(), Cipher = require_cipher();\n    function DESState() {\n      this.tmp = new Array(2), this.keys = null;\n    }\n    function DES(options) {\n      Cipher.call(this, options);\n      var state = new DESState;\n      this._desState = state, this.deriveKeys(state, options.key);\n    }\n    inherits(DES, Cipher), module.exports = DES, DES.create = function(options) {\n      return new DES(options);\n    };\n    var shiftTable = [1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1];\n    DES.prototype.deriveKeys = function(state, key) {\n      state.keys = new Array(32), assert.equal(key.length, this.blockSize, \"Invalid key length\");\n      var kL = utils.readUInt32BE(key, 0), kR = utils.readUInt32BE(key, 4);\n      utils.pc1(kL, kR, state.tmp, 0), kL = state.tmp[0], kR = state.tmp[1];\n      for (var i = 0;i < state.keys.length; i += 2) {\n        var shift = shiftTable[i >>> 1];\n        kL = utils.r28shl(kL, shift), kR = utils.r28shl(kR, shift), utils.pc2(kL, kR, state.keys, i);\n      }\n    }, DES.prototype._update = function(inp, inOff, out, outOff) {\n      var state = this._desState, l = utils.readUInt32BE(inp, inOff), r = utils.readUInt32BE(inp, inOff + 4);\n      utils.ip(l, r, state.tmp, 0), l = state.tmp[0], r = state.tmp[1], this.type === \"encrypt\" \? this._encrypt(state, l, r, state.tmp, 0) : this._decrypt(state, l, r, state.tmp, 0), l = state.tmp[0], r = state.tmp[1], utils.writeUInt32BE(out, l, outOff), utils.writeUInt32BE(out, r, outOff + 4);\n    }, DES.prototype._pad = function(buffer, off) {\n      for (var value = buffer.length - off, i = off;i < buffer.length; i++)\n        buffer[i] = value;\n      return !0;\n    }, DES.prototype._unpad = function(buffer) {\n      for (var pad = buffer[buffer.length - 1], i = buffer.length - pad;i < buffer.length; i++)\n        assert.equal(buffer[i], pad);\n      return buffer.slice(0, buffer.length - pad);\n    }, DES.prototype._encrypt = function(state, lStart, rStart, out, off) {\n      for (var l = lStart, r = rStart, i = 0;i < state.keys.length; i += 2) {\n        var keyL = state.keys[i], keyR = state.keys[i + 1];\n        utils.expand(r, state.tmp, 0), keyL ^= state.tmp[0], keyR ^= state.tmp[1];\n        var s = utils.substitute(keyL, keyR), f = utils.permute(s), t = r;\n        r = (l ^ f) >>> 0, l = t;\n      }\n      utils.rip(r, l, out, off);\n    }, DES.prototype._decrypt = function(state, lStart, rStart, out, off) {\n      for (var l = rStart, r = lStart, i = state.keys.length - 2;i >= 0; i -= 2) {\n        var keyL = state.keys[i], keyR = state.keys[i + 1];\n        utils.expand(l, state.tmp, 0), keyL ^= state.tmp[0], keyR ^= state.tmp[1];\n        var s = utils.substitute(keyL, keyR), f = utils.permute(s), t = l;\n        l = (r ^ f) >>> 0, r = t;\n      }\n      utils.rip(l, r, out, off);\n    };\n  }\n}), require_cbc = __commonJS({\n  \"node_modules/des.js/lib/des/cbc.js\"(exports) {\n    var assert = require_minimalistic_assert(), inherits = require_inherits_browser(), proto = {};\n    function CBCState(iv) {\n      assert.equal(iv.length, 8, \"Invalid IV length\"), this.iv = new Array(8);\n      for (var i = 0;i < this.iv.length; i++)\n        this.iv[i] = iv[i];\n    }\n    function instantiate(Base) {\n      function CBC(options) {\n        Base.call(this, options), this._cbcInit();\n      }\n      inherits(CBC, Base);\n      for (var keys = Object.keys(proto), i = 0;i < keys.length; i++) {\n        var key = keys[i];\n        CBC.prototype[key] = proto[key];\n      }\n      return CBC.create = function(options) {\n        return new CBC(options);\n      }, CBC;\n    }\n    exports.instantiate = instantiate, proto._cbcInit = function() {\n      var state = new CBCState(this.options.iv);\n      this._cbcState = state;\n    }, proto._update = function(inp, inOff, out, outOff) {\n      var state = this._cbcState, superProto = this.constructor.super_.prototype, iv = state.iv;\n      if (this.type === \"encrypt\") {\n        for (var i = 0;i < this.blockSize; i++)\n          iv[i] ^= inp[inOff + i];\n        superProto._update.call(this, iv, 0, out, outOff);\n        for (var i = 0;i < this.blockSize; i++)\n          iv[i] = out[outOff + i];\n      } else {\n        superProto._update.call(this, inp, inOff, out, outOff);\n        for (var i = 0;i < this.blockSize; i++)\n          out[outOff + i] ^= iv[i];\n        for (var i = 0;i < this.blockSize; i++)\n          iv[i] = inp[inOff + i];\n      }\n    };\n  }\n}), require_ede = __commonJS({\n  \"node_modules/des.js/lib/des/ede.js\"(exports, module) {\n    var assert = require_minimalistic_assert(), inherits = require_inherits_browser(), Cipher = require_cipher(), DES = require_des();\n    function EDEState(type, key) {\n      assert.equal(key.length, 24, \"Invalid key length\");\n      var k1 = key.slice(0, 8), k2 = key.slice(8, 16), k3 = key.slice(16, 24);\n      type === \"encrypt\" \? this.ciphers = [\n        DES.create({ type: \"encrypt\", key: k1 }),\n        DES.create({ type: \"decrypt\", key: k2 }),\n        DES.create({ type: \"encrypt\", key: k3 })\n      ] : this.ciphers = [\n        DES.create({ type: \"decrypt\", key: k3 }),\n        DES.create({ type: \"encrypt\", key: k2 }),\n        DES.create({ type: \"decrypt\", key: k1 })\n      ];\n    }\n    function EDE(options) {\n      Cipher.call(this, options);\n      var state = new EDEState(this.type, this.options.key);\n      this._edeState = state;\n    }\n    inherits(EDE, Cipher), module.exports = EDE, EDE.create = function(options) {\n      return new EDE(options);\n    }, EDE.prototype._update = function(inp, inOff, out, outOff) {\n      var state = this._edeState;\n      state.ciphers[0]._update(inp, inOff, out, outOff), state.ciphers[1]._update(out, outOff, out, outOff), state.ciphers[2]._update(out, outOff, out, outOff);\n    }, EDE.prototype._pad = DES.prototype._pad, EDE.prototype._unpad = DES.prototype._unpad;\n  }\n}), require_des2 = __commonJS({\n  \"node_modules/des.js/lib/des.js\"(exports) {\n    exports.utils = require_utils(), exports.Cipher = require_cipher(), exports.DES = require_des(), exports.CBC = require_cbc(), exports.EDE = require_ede();\n  }\n}), require_browserify_des = __commonJS({\n  \"node_modules/browserify-des/index.js\"(exports, module) {\n    var CipherBase = require_cipher_base(), des = require_des2(), inherits = require_inherits_browser(), Buffer2 = require_safe_buffer().Buffer, modes = {\n      \"des-ede3-cbc\": des.CBC.instantiate(des.EDE),\n      \"des-ede3\": des.EDE,\n      \"des-ede-cbc\": des.CBC.instantiate(des.EDE),\n      \"des-ede\": des.EDE,\n      \"des-cbc\": des.CBC.instantiate(des.DES),\n      \"des-ecb\": des.DES\n    };\n    modes.des = modes[\"des-cbc\"], modes.des3 = modes[\"des-ede3-cbc\"], module.exports = DES, inherits(DES, CipherBase);\n    function DES(opts) {\n      CipherBase.call(this);\n      var modeName = opts.mode.toLowerCase(), mode = modes[modeName], type;\n      opts.decrypt \? type = \"decrypt\" : type = \"encrypt\";\n      var key = opts.key;\n      Buffer2.isBuffer(key) || (key = Buffer2.from(key)), (modeName === \"des-ede\" || modeName === \"des-ede-cbc\") && (key = Buffer2.concat([key, key.slice(0, 8)]));\n      var iv = opts.iv;\n      Buffer2.isBuffer(iv) || (iv = Buffer2.from(iv)), this._des = mode.create({\n        key,\n        iv,\n        type\n      });\n    }\n    DES.prototype._update = function(data) {\n      return Buffer2.from(this._des.update(data));\n    }, DES.prototype._final = function() {\n      return Buffer2.from(this._des.final());\n    };\n  }\n}), require_ecb = __commonJS({\n  \"node_modules/browserify-aes/modes/ecb.js\"(exports) {\n    exports.encrypt = function(self2, block) {\n      return self2._cipher.encryptBlock(block);\n    }, exports.decrypt = function(self2, block) {\n      return self2._cipher.decryptBlock(block);\n    };\n  }\n}), require_buffer_xor = __commonJS({\n  \"node_modules/buffer-xor/index.js\"(exports, module) {\n    module.exports = function(a, b) {\n      for (var length = Math.min(a.length, b.length), buffer = new Buffer(length), i = 0;i < length; ++i)\n        buffer[i] = a[i] ^ b[i];\n      return buffer;\n    };\n  }\n}), require_cbc2 = __commonJS({\n  \"node_modules/browserify-aes/modes/cbc.js\"(exports) {\n    var xor = require_buffer_xor();\n    exports.encrypt = function(self2, block) {\n      var data = xor(block, self2._prev);\n      return self2._prev = self2._cipher.encryptBlock(data), self2._prev;\n    }, exports.decrypt = function(self2, block) {\n      var pad = self2._prev;\n      self2._prev = block;\n      var out = self2._cipher.decryptBlock(block);\n      return xor(out, pad);\n    };\n  }\n}), require_cfb = __commonJS({\n  \"node_modules/browserify-aes/modes/cfb.js\"(exports) {\n    var Buffer2 = require_safe_buffer().Buffer, xor = require_buffer_xor();\n    function encryptStart(self2, data, decrypt) {\n      var len = data.length, out = xor(data, self2._cache);\n      return self2._cache = self2._cache.slice(len), self2._prev = Buffer2.concat([self2._prev, decrypt \? data : out]), out;\n    }\n    exports.encrypt = function(self2, data, decrypt) {\n      for (var out = Buffer2.allocUnsafe(0), len;data.length; )\n        if (self2._cache.length === 0 && (self2._cache = self2._cipher.encryptBlock(self2._prev), self2._prev = Buffer2.allocUnsafe(0)), self2._cache.length <= data.length)\n          len = self2._cache.length, out = Buffer2.concat([out, encryptStart(self2, data.slice(0, len), decrypt)]), data = data.slice(len);\n        else {\n          out = Buffer2.concat([out, encryptStart(self2, data, decrypt)]);\n          break;\n        }\n      return out;\n    };\n  }\n}), require_cfb8 = __commonJS({\n  \"node_modules/browserify-aes/modes/cfb8.js\"(exports) {\n    var Buffer2 = require_safe_buffer().Buffer;\n    function encryptByte(self2, byteParam, decrypt) {\n      var pad = self2._cipher.encryptBlock(self2._prev), out = pad[0] ^ byteParam;\n      return self2._prev = Buffer2.concat([self2._prev.slice(1), Buffer2.from([decrypt \? byteParam : out])]), out;\n    }\n    exports.encrypt = function(self2, chunk, decrypt) {\n      for (var len = chunk.length, out = Buffer2.allocUnsafe(len), i = -1;++i < len; )\n        out[i] = encryptByte(self2, chunk[i], decrypt);\n      return out;\n    };\n  }\n}), require_cfb1 = __commonJS({\n  \"node_modules/browserify-aes/modes/cfb1.js\"(exports) {\n    var Buffer2 = require_safe_buffer().Buffer;\n    function encryptByte(self2, byteParam, decrypt) {\n      for (var pad, i = -1, len = 8, out = 0, bit, value;++i < len; )\n        pad = self2._cipher.encryptBlock(self2._prev), bit = byteParam & 1 << 7 - i \? 128 : 0, value = pad[0] ^ bit, out += (value & 128) >> i % 8, self2._prev = shiftIn(self2._prev, decrypt \? bit : value);\n      return out;\n    }\n    function shiftIn(buffer, value) {\n      var len = buffer.length, i = -1, out = Buffer2.allocUnsafe(buffer.length);\n      for (buffer = Buffer2.concat([buffer, Buffer2.from([value])]);++i < len; )\n        out[i] = buffer[i] << 1 | buffer[i + 1] >> 7;\n      return out;\n    }\n    exports.encrypt = function(self2, chunk, decrypt) {\n      for (var len = chunk.length, out = Buffer2.allocUnsafe(len), i = -1;++i < len; )\n        out[i] = encryptByte(self2, chunk[i], decrypt);\n      return out;\n    };\n  }\n}), require_ofb = __commonJS({\n  \"node_modules/browserify-aes/modes/ofb.js\"(exports) {\n    var xor = require_buffer_xor();\n    function getBlock(self2) {\n      return self2._prev = self2._cipher.encryptBlock(self2._prev), self2._prev;\n    }\n    exports.encrypt = function(self2, chunk) {\n      for (;self2._cache.length < chunk.length; )\n        self2._cache = Buffer.concat([self2._cache, getBlock(self2)]);\n      var pad = self2._cache.slice(0, chunk.length);\n      return self2._cache = self2._cache.slice(chunk.length), xor(chunk, pad);\n    };\n  }\n}), require_incr32 = __commonJS({\n  \"node_modules/browserify-aes/incr32.js\"(exports, module) {\n    function incr32(iv) {\n      for (var len = iv.length, item;len--; )\n        if (item = iv.readUInt8(len), item === 255)\n          iv.writeUInt8(0, len);\n        else {\n          item++, iv.writeUInt8(item, len);\n          break;\n        }\n    }\n    module.exports = incr32;\n  }\n}), require_ctr = __commonJS({\n  \"node_modules/browserify-aes/modes/ctr.js\"(exports) {\n    var xor = require_buffer_xor(), Buffer2 = require_safe_buffer().Buffer, incr32 = require_incr32();\n    function getBlock(self2) {\n      var out = self2._cipher.encryptBlockRaw(self2._prev);\n      return incr32(self2._prev), out;\n    }\n    var blockSize = 16;\n    exports.encrypt = function(self2, chunk) {\n      var chunkNum = Math.ceil(chunk.length / blockSize), start = self2._cache.length;\n      self2._cache = Buffer2.concat([self2._cache, Buffer2.allocUnsafe(chunkNum * blockSize)]);\n      for (var i = 0;i < chunkNum; i++) {\n        var out = getBlock(self2), offset = start + i * blockSize;\n        self2._cache.writeUInt32BE(out[0], offset + 0), self2._cache.writeUInt32BE(out[1], offset + 4), self2._cache.writeUInt32BE(out[2], offset + 8), self2._cache.writeUInt32BE(out[3], offset + 12);\n      }\n      var pad = self2._cache.slice(0, chunk.length);\n      return self2._cache = self2._cache.slice(chunk.length), xor(chunk, pad);\n    };\n  }\n}), require_list = __commonJS({\n  \"node_modules/browserify-aes/modes/list.json\"(exports, module) {\n    module.exports = {\n      \"aes-128-ecb\": {\n        cipher: \"AES\",\n        key: 128,\n        iv: 0,\n        mode: \"ECB\",\n        type: \"block\"\n      },\n      \"aes-192-ecb\": {\n        cipher: \"AES\",\n        key: 192,\n        iv: 0,\n        mode: \"ECB\",\n        type: \"block\"\n      },\n      \"aes-256-ecb\": {\n        cipher: \"AES\",\n        key: 256,\n        iv: 0,\n        mode: \"ECB\",\n        type: \"block\"\n      },\n      \"aes-128-cbc\": {\n        cipher: \"AES\",\n        key: 128,\n        iv: 16,\n        mode: \"CBC\",\n        type: \"block\"\n      },\n      \"aes-192-cbc\": {\n        cipher: \"AES\",\n        key: 192,\n        iv: 16,\n        mode: \"CBC\",\n        type: \"block\"\n      },\n      \"aes-256-cbc\": {\n        cipher: \"AES\",\n        key: 256,\n        iv: 16,\n        mode: \"CBC\",\n        type: \"block\"\n      },\n      aes128: {\n        cipher: \"AES\",\n        key: 128,\n        iv: 16,\n        mode: \"CBC\",\n        type: \"block\"\n      },\n      aes192: {\n        cipher: \"AES\",\n        key: 192,\n        iv: 16,\n        mode: \"CBC\",\n        type: \"block\"\n      },\n      aes256: {\n        cipher: \"AES\",\n        key: 256,\n        iv: 16,\n        mode: \"CBC\",\n        type: \"block\"\n      },\n      \"aes-128-cfb\": {\n        cipher: \"AES\",\n        key: 128,\n        iv: 16,\n        mode: \"CFB\",\n        type: \"stream\"\n      },\n      \"aes-192-cfb\": {\n        cipher: \"AES\",\n        key: 192,\n        iv: 16,\n        mode: \"CFB\",\n        type: \"stream\"\n      },\n      \"aes-256-cfb\": {\n        cipher: \"AES\",\n        key: 256,\n        iv: 16,\n        mode: \"CFB\",\n        type: \"stream\"\n      },\n      \"aes-128-cfb8\": {\n        cipher: \"AES\",\n        key: 128,\n        iv: 16,\n        mode: \"CFB8\",\n        type: \"stream\"\n      },\n      \"aes-192-cfb8\": {\n        cipher: \"AES\",\n        key: 192,\n        iv: 16,\n        mode: \"CFB8\",\n        type: \"stream\"\n      },\n      \"aes-256-cfb8\": {\n        cipher: \"AES\",\n        key: 256,\n        iv: 16,\n        mode: \"CFB8\",\n        type: \"stream\"\n      },\n      \"aes-128-cfb1\": {\n        cipher: \"AES\",\n        key: 128,\n        iv: 16,\n        mode: \"CFB1\",\n        type: \"stream\"\n      },\n      \"aes-192-cfb1\": {\n        cipher: \"AES\",\n        key: 192,\n        iv: 16,\n        mode: \"CFB1\",\n        type: \"stream\"\n      },\n      \"aes-256-cfb1\": {\n        cipher: \"AES\",\n        key: 256,\n        iv: 16,\n        mode: \"CFB1\",\n        type: \"stream\"\n      },\n      \"aes-128-ofb\": {\n        cipher: \"AES\",\n        key: 128,\n        iv: 16,\n        mode: \"OFB\",\n        type: \"stream\"\n      },\n      \"aes-192-ofb\": {\n        cipher: \"AES\",\n        key: 192,\n        iv: 16,\n        mode: \"OFB\",\n        type: \"stream\"\n      },\n      \"aes-256-ofb\": {\n        cipher: \"AES\",\n        key: 256,\n        iv: 16,\n        mode: \"OFB\",\n        type: \"stream\"\n      },\n      \"aes-128-ctr\": {\n        cipher: \"AES\",\n        key: 128,\n        iv: 16,\n        mode: \"CTR\",\n        type: \"stream\"\n      },\n      \"aes-192-ctr\": {\n        cipher: \"AES\",\n        key: 192,\n        iv: 16,\n        mode: \"CTR\",\n        type: \"stream\"\n      },\n      \"aes-256-ctr\": {\n        cipher: \"AES\",\n        key: 256,\n        iv: 16,\n        mode: \"CTR\",\n        type: \"stream\"\n      },\n      \"aes-128-gcm\": {\n        cipher: \"AES\",\n        key: 128,\n        iv: 12,\n        mode: \"GCM\",\n        type: \"auth\"\n      },\n      \"aes-192-gcm\": {\n        cipher: \"AES\",\n        key: 192,\n        iv: 12,\n        mode: \"GCM\",\n        type: \"auth\"\n      },\n      \"aes-256-gcm\": {\n        cipher: \"AES\",\n        key: 256,\n        iv: 12,\n        mode: \"GCM\",\n        type: \"auth\"\n      }\n    };\n  }\n}), require_modes = __commonJS({\n  \"node_modules/browserify-aes/modes/index.js\"(exports, module) {\n    var modeModules = {\n      ECB: require_ecb(),\n      CBC: require_cbc2(),\n      CFB: require_cfb(),\n      CFB8: require_cfb8(),\n      CFB1: require_cfb1(),\n      OFB: require_ofb(),\n      CTR: require_ctr(),\n      GCM: require_ctr()\n    }, modes = require_list();\n    for (key in modes)\n      modes[key].module = modeModules[modes[key].mode];\n    var key;\n    module.exports = modes;\n  }\n}), require_aes = __commonJS({\n  \"node_modules/browserify-aes/aes.js\"(exports, module) {\n    var Buffer2 = require_safe_buffer().Buffer;\n    function asUInt32Array(buf) {\n      Buffer2.isBuffer(buf) || (buf = Buffer2.from(buf));\n      for (var len = buf.length / 4 | 0, out = new Array(len), i = 0;i < len; i++)\n        out[i] = buf.readUInt32BE(i * 4);\n      return out;\n    }\n    function scrubVec(v) {\n      for (var i = 0;i < v.length; v++)\n        v[i] = 0;\n    }\n    function cryptBlock(M, keySchedule, SUB_MIX, SBOX, nRounds) {\n      for (var SUB_MIX0 = SUB_MIX[0], SUB_MIX1 = SUB_MIX[1], SUB_MIX2 = SUB_MIX[2], SUB_MIX3 = SUB_MIX[3], s0 = M[0] ^ keySchedule[0], s1 = M[1] ^ keySchedule[1], s2 = M[2] ^ keySchedule[2], s3 = M[3] ^ keySchedule[3], t0, t1, t2, t3, ksRow = 4, round = 1;round < nRounds; round++)\n        t0 = SUB_MIX0[s0 >>> 24] ^ SUB_MIX1[s1 >>> 16 & 255] ^ SUB_MIX2[s2 >>> 8 & 255] ^ SUB_MIX3[s3 & 255] ^ keySchedule[ksRow++], t1 = SUB_MIX0[s1 >>> 24] ^ SUB_MIX1[s2 >>> 16 & 255] ^ SUB_MIX2[s3 >>> 8 & 255] ^ SUB_MIX3[s0 & 255] ^ keySchedule[ksRow++], t2 = SUB_MIX0[s2 >>> 24] ^ SUB_MIX1[s3 >>> 16 & 255] ^ SUB_MIX2[s0 >>> 8 & 255] ^ SUB_MIX3[s1 & 255] ^ keySchedule[ksRow++], t3 = SUB_MIX0[s3 >>> 24] ^ SUB_MIX1[s0 >>> 16 & 255] ^ SUB_MIX2[s1 >>> 8 & 255] ^ SUB_MIX3[s2 & 255] ^ keySchedule[ksRow++], s0 = t0, s1 = t1, s2 = t2, s3 = t3;\n      return t0 = (SBOX[s0 >>> 24] << 24 | SBOX[s1 >>> 16 & 255] << 16 | SBOX[s2 >>> 8 & 255] << 8 | SBOX[s3 & 255]) ^ keySchedule[ksRow++], t1 = (SBOX[s1 >>> 24] << 24 | SBOX[s2 >>> 16 & 255] << 16 | SBOX[s3 >>> 8 & 255] << 8 | SBOX[s0 & 255]) ^ keySchedule[ksRow++], t2 = (SBOX[s2 >>> 24] << 24 | SBOX[s3 >>> 16 & 255] << 16 | SBOX[s0 >>> 8 & 255] << 8 | SBOX[s1 & 255]) ^ keySchedule[ksRow++], t3 = (SBOX[s3 >>> 24] << 24 | SBOX[s0 >>> 16 & 255] << 16 | SBOX[s1 >>> 8 & 255] << 8 | SBOX[s2 & 255]) ^ keySchedule[ksRow++], t0 = t0 >>> 0, t1 = t1 >>> 0, t2 = t2 >>> 0, t3 = t3 >>> 0, [t0, t1, t2, t3];\n    }\n    var RCON = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54], G = function() {\n      for (var d = new Array(256), j = 0;j < 256; j++)\n        j < 128 \? d[j] = j << 1 : d[j] = j << 1 ^ 283;\n      for (var SBOX = [], INV_SBOX = [], SUB_MIX = [[], [], [], []], INV_SUB_MIX = [[], [], [], []], x = 0, xi = 0, i = 0;i < 256; ++i) {\n        var sx = xi ^ xi << 1 ^ xi << 2 ^ xi << 3 ^ xi << 4;\n        sx = sx >>> 8 ^ sx & 255 ^ 99, SBOX[x] = sx, INV_SBOX[sx] = x;\n        var x2 = d[x], x4 = d[x2], x8 = d[x4], t = d[sx] * 257 ^ sx * 16843008;\n        SUB_MIX[0][x] = t << 24 | t >>> 8, SUB_MIX[1][x] = t << 16 | t >>> 16, SUB_MIX[2][x] = t << 8 | t >>> 24, SUB_MIX[3][x] = t, t = x8 * 16843009 ^ x4 * 65537 ^ x2 * 257 ^ x * 16843008, INV_SUB_MIX[0][sx] = t << 24 | t >>> 8, INV_SUB_MIX[1][sx] = t << 16 | t >>> 16, INV_SUB_MIX[2][sx] = t << 8 | t >>> 24, INV_SUB_MIX[3][sx] = t, x === 0 \? x = xi = 1 : (x = x2 ^ d[d[d[x8 ^ x2]]], xi ^= d[d[xi]]);\n      }\n      return {\n        SBOX,\n        INV_SBOX,\n        SUB_MIX,\n        INV_SUB_MIX\n      };\n    }();\n    function AES(key) {\n      this._key = asUInt32Array(key), this._reset();\n    }\n    AES.prototype = {}, AES.blockSize = 16, AES.keySize = 32, AES.prototype.blockSize = AES.blockSize, AES.prototype.keySize = AES.keySize, AES.prototype._reset = function() {\n      for (var keyWords = this._key, keySize = keyWords.length, nRounds = keySize + 6, ksRows = (nRounds + 1) * 4, keySchedule = [], k = 0;k < keySize; k++)\n        keySchedule[k] = keyWords[k];\n      for (k = keySize;k < ksRows; k++) {\n        var t = keySchedule[k - 1];\n        k % keySize === 0 \? (t = t << 8 | t >>> 24, t = G.SBOX[t >>> 24] << 24 | G.SBOX[t >>> 16 & 255] << 16 | G.SBOX[t >>> 8 & 255] << 8 | G.SBOX[t & 255], t ^= RCON[k / keySize | 0] << 24) : keySize > 6 && k % keySize === 4 && (t = G.SBOX[t >>> 24] << 24 | G.SBOX[t >>> 16 & 255] << 16 | G.SBOX[t >>> 8 & 255] << 8 | G.SBOX[t & 255]), keySchedule[k] = keySchedule[k - keySize] ^ t;\n      }\n      for (var invKeySchedule = [], ik = 0;ik < ksRows; ik++) {\n        var ksR = ksRows - ik, tt = keySchedule[ksR - (ik % 4 \? 0 : 4)];\n        ik < 4 || ksR <= 4 \? invKeySchedule[ik] = tt : invKeySchedule[ik] = G.INV_SUB_MIX[0][G.SBOX[tt >>> 24]] ^ G.INV_SUB_MIX[1][G.SBOX[tt >>> 16 & 255]] ^ G.INV_SUB_MIX[2][G.SBOX[tt >>> 8 & 255]] ^ G.INV_SUB_MIX[3][G.SBOX[tt & 255]];\n      }\n      this._nRounds = nRounds, this._keySchedule = keySchedule, this._invKeySchedule = invKeySchedule;\n    }, AES.prototype.encryptBlockRaw = function(M) {\n      return M = asUInt32Array(M), cryptBlock(M, this._keySchedule, G.SUB_MIX, G.SBOX, this._nRounds);\n    }, AES.prototype.encryptBlock = function(M) {\n      var out = this.encryptBlockRaw(M), buf = Buffer2.allocUnsafe(16);\n      return buf.writeUInt32BE(out[0], 0), buf.writeUInt32BE(out[1], 4), buf.writeUInt32BE(out[2], 8), buf.writeUInt32BE(out[3], 12), buf;\n    }, AES.prototype.decryptBlock = function(M) {\n      M = asUInt32Array(M);\n      var m1 = M[1];\n      M[1] = M[3], M[3] = m1;\n      var out = cryptBlock(M, this._invKeySchedule, G.INV_SUB_MIX, G.INV_SBOX, this._nRounds), buf = Buffer2.allocUnsafe(16);\n      return buf.writeUInt32BE(out[0], 0), buf.writeUInt32BE(out[3], 4), buf.writeUInt32BE(out[2], 8), buf.writeUInt32BE(out[1], 12), buf;\n    }, AES.prototype.scrub = function() {\n      scrubVec(this._keySchedule), scrubVec(this._invKeySchedule), scrubVec(this._key);\n    }, module.exports.AES = AES;\n  }\n}), require_ghash = __commonJS({\n  \"node_modules/browserify-aes/ghash.js\"(exports, module) {\n    var Buffer2 = require_safe_buffer().Buffer, ZEROES = Buffer2.alloc(16, 0);\n    function toArray(buf) {\n      return [buf.readUInt32BE(0), buf.readUInt32BE(4), buf.readUInt32BE(8), buf.readUInt32BE(12)];\n    }\n    function fromArray(out) {\n      var buf = Buffer2.allocUnsafe(16);\n      return buf.writeUInt32BE(out[0] >>> 0, 0), buf.writeUInt32BE(out[1] >>> 0, 4), buf.writeUInt32BE(out[2] >>> 0, 8), buf.writeUInt32BE(out[3] >>> 0, 12), buf;\n    }\n    function GHASH(key) {\n      this.h = key, this.state = Buffer2.alloc(16, 0), this.cache = Buffer2.allocUnsafe(0);\n    }\n    GHASH.prototype = {}, GHASH.prototype.ghash = function(block) {\n      for (var i = -1;++i < block.length; )\n        this.state[i] ^= block[i];\n      this._multiply();\n    }, GHASH.prototype._multiply = function() {\n      for (var Vi = toArray(this.h), Zi = [0, 0, 0, 0], j, xi, lsbVi, i = -1;++i < 128; ) {\n        for (xi = (this.state[~~(i / 8)] & 1 << 7 - i % 8) !== 0, xi && (Zi[0] ^= Vi[0], Zi[1] ^= Vi[1], Zi[2] ^= Vi[2], Zi[3] ^= Vi[3]), lsbVi = (Vi[3] & 1) !== 0, j = 3;j > 0; j--)\n          Vi[j] = Vi[j] >>> 1 | (Vi[j - 1] & 1) << 31;\n        Vi[0] = Vi[0] >>> 1, lsbVi && (Vi[0] = Vi[0] ^ 225 << 24);\n      }\n      this.state = fromArray(Zi);\n    }, GHASH.prototype.update = function(buf) {\n      this.cache = Buffer2.concat([this.cache, buf]);\n      for (var chunk;this.cache.length >= 16; )\n        chunk = this.cache.slice(0, 16), this.cache = this.cache.slice(16), this.ghash(chunk);\n    }, GHASH.prototype.final = function(abl, bl) {\n      return this.cache.length && this.ghash(Buffer2.concat([this.cache, ZEROES], 16)), this.ghash(fromArray([0, abl, 0, bl])), this.state;\n    }, module.exports = GHASH;\n  }\n}), require_authCipher = __commonJS({\n  \"node_modules/browserify-aes/authCipher.js\"(exports, module) {\n    var aes = require_aes(), Buffer2 = require_safe_buffer().Buffer, Transform = require_cipher_base(), inherits = require_inherits_browser(), GHASH = require_ghash(), xor = require_buffer_xor(), incr32 = require_incr32();\n    function xorTest(a, b) {\n      var out = 0;\n      a.length !== b.length && out++;\n      for (var len = Math.min(a.length, b.length), i = 0;i < len; ++i)\n        out += a[i] ^ b[i];\n      return out;\n    }\n    function calcIv(self2, iv, ck) {\n      if (iv.length === 12)\n        return self2._finID = Buffer2.concat([iv, Buffer2.from([0, 0, 0, 1])]), Buffer2.concat([iv, Buffer2.from([0, 0, 0, 2])]);\n      var ghash = new GHASH(ck), len = iv.length, toPad = len % 16;\n      ghash.update(iv), toPad && (toPad = 16 - toPad, ghash.update(Buffer2.alloc(toPad, 0))), ghash.update(Buffer2.alloc(8, 0));\n      var ivBits = len * 8, tail = Buffer2.alloc(8);\n      tail.writeUIntBE(ivBits, 0, 8), ghash.update(tail), self2._finID = ghash.state;\n      var out = Buffer2.from(self2._finID);\n      return incr32(out), out;\n    }\n    function StreamCipher(mode, key, iv, decrypt) {\n      Transform.call(this);\n      var h = Buffer2.alloc(4, 0);\n      this._cipher = new aes.AES(key);\n      var ck = this._cipher.encryptBlock(h);\n      this._ghash = new GHASH(ck), iv = calcIv(this, iv, ck), this._prev = Buffer2.from(iv), this._cache = Buffer2.allocUnsafe(0), this._secCache = Buffer2.allocUnsafe(0), this._decrypt = decrypt, this._alen = 0, this._len = 0, this._mode = mode, this._authTag = null, this._called = !1;\n    }\n    inherits(StreamCipher, Transform), StreamCipher.prototype._update = function(chunk) {\n      if (!this._called && this._alen) {\n        var rump = 16 - this._alen % 16;\n        rump < 16 && (rump = Buffer2.alloc(rump, 0), this._ghash.update(rump));\n      }\n      this._called = !0;\n      var out = this._mode.encrypt(this, chunk);\n      return this._decrypt \? this._ghash.update(chunk) : this._ghash.update(out), this._len += chunk.length, out;\n    }, StreamCipher.prototype._final = function() {\n      if (this._decrypt && !this._authTag)\n        throw new Error(\"Unsupported state or unable to authenticate data\");\n      var tag = xor(this._ghash.final(this._alen * 8, this._len * 8), this._cipher.encryptBlock(this._finID));\n      if (this._decrypt && xorTest(tag, this._authTag))\n        throw new Error(\"Unsupported state or unable to authenticate data\");\n      this._authTag = tag, this._cipher.scrub();\n    }, StreamCipher.prototype.getAuthTag = function() {\n      if (this._decrypt || !Buffer2.isBuffer(this._authTag))\n        throw new Error(\"Attempting to get auth tag in unsupported state\");\n      return this._authTag;\n    }, StreamCipher.prototype.setAuthTag = function(tag) {\n      if (!this._decrypt)\n        throw new Error(\"Attempting to set auth tag in unsupported state\");\n      this._authTag = tag;\n    }, StreamCipher.prototype.setAAD = function(buf) {\n      if (this._called)\n        throw new Error(\"Attempting to set AAD in unsupported state\");\n      this._ghash.update(buf), this._alen += buf.length;\n    }, module.exports = StreamCipher;\n  }\n}), require_streamCipher = __commonJS({\n  \"node_modules/browserify-aes/streamCipher.js\"(exports, module) {\n    var aes = require_aes(), Buffer2 = require_safe_buffer().Buffer, Transform = require_cipher_base(), inherits = require_inherits_browser();\n    function StreamCipher(mode, key, iv, decrypt) {\n      Transform.call(this), this._cipher = new aes.AES(key), this._prev = Buffer2.from(iv), this._cache = Buffer2.allocUnsafe(0), this._secCache = Buffer2.allocUnsafe(0), this._decrypt = decrypt, this._mode = mode;\n    }\n    inherits(StreamCipher, Transform), StreamCipher.prototype._update = function(chunk) {\n      return this._mode.encrypt(this, chunk, this._decrypt);\n    }, StreamCipher.prototype._final = function() {\n      this._cipher.scrub();\n    }, module.exports = StreamCipher;\n  }\n}), require_evp_bytestokey = __commonJS({\n  \"node_modules/evp_bytestokey/index.js\"(exports, module) {\n    var Buffer2 = require_safe_buffer().Buffer, MD5 = require_md5();\n    function EVP_BytesToKey(password, salt, keyBits, ivLen) {\n      if (Buffer2.isBuffer(password) || (password = Buffer2.from(password, \"binary\")), salt && (Buffer2.isBuffer(salt) || (salt = Buffer2.from(salt, \"binary\")), salt.length !== 8))\n        @throwRangeError(\"salt should be Buffer with 8 byte length\");\n      for (var keyLen = keyBits / 8, key = Buffer2.alloc(keyLen), iv = Buffer2.alloc(ivLen || 0), tmp = Buffer2.alloc(0);keyLen > 0 || ivLen > 0; ) {\n        var hash = new MD5;\n        hash.update(tmp), hash.update(password), salt && hash.update(salt), tmp = hash.digest();\n        var used = 0;\n        if (keyLen > 0) {\n          var keyStart = key.length - keyLen;\n          used = Math.min(keyLen, tmp.length), tmp.copy(key, keyStart, 0, used), keyLen -= used;\n        }\n        if (used < tmp.length && ivLen > 0) {\n          var ivStart = iv.length - ivLen, length = Math.min(ivLen, tmp.length - used);\n          tmp.copy(iv, ivStart, used, used + length), ivLen -= length;\n        }\n      }\n      return tmp.fill(0), { key, iv };\n    }\n    module.exports = EVP_BytesToKey;\n  }\n}), require_encrypter = __commonJS({\n  \"node_modules/browserify-aes/encrypter.js\"(exports) {\n    var MODES = require_modes(), AuthCipher = require_authCipher(), Buffer2 = require_safe_buffer().Buffer, StreamCipher = require_streamCipher(), Transform = require_cipher_base(), aes = require_aes(), ebtk = require_evp_bytestokey(), inherits = require_inherits_browser();\n    function Cipher(mode, key, iv) {\n      Transform.call(this), this._cache = new Splitter, this._cipher = new aes.AES(key), this._prev = Buffer2.from(iv), this._mode = mode, this._autopadding = !0;\n    }\n    inherits(Cipher, Transform), Cipher.prototype._update = function(data) {\n      this._cache.add(data);\n      for (var chunk, thing, out = [];chunk = this._cache.get(); )\n        thing = this._mode.encrypt(this, chunk), out.push(thing);\n      return Buffer2.concat(out);\n    };\n    var PADDING = Buffer2.alloc(16, 16);\n    Cipher.prototype._final = function() {\n      var chunk = this._cache.flush();\n      if (this._autopadding)\n        return chunk = this._mode.encrypt(this, chunk), this._cipher.scrub(), chunk;\n      if (!chunk.equals(PADDING))\n        throw this._cipher.scrub(), new Error(\"data not multiple of block length\");\n    }, Cipher.prototype.setAutoPadding = function(setTo) {\n      return this._autopadding = !!setTo, this;\n    };\n    function Splitter() {\n      this.cache = Buffer2.allocUnsafe(0);\n    }\n    Splitter.prototype = {}, Splitter.prototype.add = function(data) {\n      this.cache = Buffer2.concat([this.cache, data]);\n    }, Splitter.prototype.get = function() {\n      if (this.cache.length > 15) {\n        var out = this.cache.slice(0, 16);\n        return this.cache = this.cache.slice(16), out;\n      }\n      return null;\n    }, Splitter.prototype.flush = function() {\n      for (var len = 16 - this.cache.length, padBuff = Buffer2.allocUnsafe(len), i = -1;++i < len; )\n        padBuff.writeUInt8(len, i);\n      return Buffer2.concat([this.cache, padBuff]);\n    };\n    function createCipheriv(suite, password, iv) {\n      var config = MODES[suite.toLowerCase()];\n      if (!config)\n        @throwTypeError(\"invalid suite type\");\n      password = getArrayBufferOrView(password, \"password\");\n      const iv_length = iv\?.length || 0, required_iv_length = config.iv || 0;\n      if (iv = iv === null \? EMPTY_BUFFER : getArrayBufferOrView(iv, \"iv\"), password\?.length !== config.key / 8) {\n        var error = new RangeError(\"Invalid key length\");\n        throw error.code = \"ERR_CRYPTO_INVALID_KEYLEN\", error;\n      }\n      if (config.mode !== \"GCM\" && iv_length !== required_iv_length) {\n        var error = new RangeError(\"Invalid key length\");\n        throw error.code = \"ERR_CRYPTO_INVALID_KEYLEN\", error;\n      }\n      return config.type === \"stream\" \? new StreamCipher(config.module, password, iv) : config.type === \"auth\" \? new AuthCipher(config.module, password, iv) : new Cipher(config.module, password, iv);\n    }\n    function createCipher(suite, password) {\n      var config = MODES[suite.toLowerCase()];\n      if (!config)\n        @throwTypeError(\"invalid suite type\");\n      var keys = ebtk(password, !1, config.key, config.iv);\n      return createCipheriv(suite, keys.key, keys.iv);\n    }\n    exports.createCipheriv = createCipheriv, exports.createCipher = createCipher;\n  }\n}), require_decrypter = __commonJS({\n  \"node_modules/browserify-aes/decrypter.js\"(exports) {\n    var AuthCipher = require_authCipher(), Buffer2 = require_safe_buffer().Buffer, MODES = require_modes(), StreamCipher = require_streamCipher(), Transform = require_cipher_base(), aes = require_aes(), ebtk = require_evp_bytestokey(), inherits = require_inherits_browser();\n    function Decipher(mode, key, iv) {\n      Transform.call(this), this._cache = new Splitter, this._last = void 0, this._cipher = new aes.AES(key), this._prev = Buffer2.from(iv), this._mode = mode, this._autopadding = !0;\n    }\n    inherits(Decipher, Transform), Decipher.prototype._update = function(data) {\n      this._cache.add(data);\n      for (var chunk, thing, out = [];chunk = this._cache.get(this._autopadding); )\n        thing = this._mode.decrypt(this, chunk), out.push(thing);\n      return Buffer2.concat(out);\n    }, Decipher.prototype._final = function() {\n      var chunk = this._cache.flush();\n      if (this._autopadding)\n        return unpad(this._mode.decrypt(this, chunk));\n      if (chunk)\n        throw new Error(\"data not multiple of block length\");\n    }, Decipher.prototype.setAutoPadding = function(setTo) {\n      return this._autopadding = !!setTo, this;\n    };\n    function Splitter() {\n      this.cache = Buffer2.allocUnsafe(0);\n    }\n    Splitter.prototype = {}, Splitter.prototype.add = function(data) {\n      this.cache = Buffer2.concat([this.cache, data]);\n    }, Splitter.prototype.get = function(autoPadding) {\n      var out;\n      if (autoPadding) {\n        if (this.cache.length > 16)\n          return out = this.cache.slice(0, 16), this.cache = this.cache.slice(16), out;\n      } else if (this.cache.length >= 16)\n        return out = this.cache.slice(0, 16), this.cache = this.cache.slice(16), out;\n      return null;\n    }, Splitter.prototype.flush = function() {\n      if (this.cache.length)\n        return this.cache;\n    };\n    function unpad(last) {\n      var padded = last[15];\n      if (padded < 1 || padded > 16)\n        throw new Error(\"unable to decrypt data\");\n      for (var i = -1;++i < padded; )\n        if (last[i + (16 - padded)] !== padded)\n          throw new Error(\"unable to decrypt data\");\n      if (padded !== 16)\n        return last.slice(0, 16 - padded);\n    }\n    function createDecipheriv(suite, password, iv) {\n      var config = MODES[suite.toLowerCase()];\n      if (!config)\n        @throwTypeError(\"invalid suite type\");\n      password = getArrayBufferOrView(password, \"password\");\n      const iv_length = iv\?.length || 0, required_iv_length = config.iv || 0;\n      if (iv = iv === null \? EMPTY_BUFFER : getArrayBufferOrView(iv, \"iv\"), config.mode !== \"GCM\" && iv_length !== required_iv_length) {\n        var error = new RangeError(\"Invalid key length\");\n        throw error.code = \"ERR_CRYPTO_INVALID_KEYLEN\", error;\n      }\n      if (password.length !== config.key / 8) {\n        var error = new RangeError(\"Invalid key length\");\n        throw error.code = \"ERR_CRYPTO_INVALID_KEYLEN\", error;\n      }\n      return config.type === \"stream\" \? new StreamCipher(config.module, password, iv, !0) : config.type === \"auth\" \? new AuthCipher(config.module, password, iv, !0) : new Decipher(config.module, password, iv);\n    }\n    function createDecipher(suite, password) {\n      var config = MODES[suite.toLowerCase()];\n      if (!config)\n        @throwTypeError(\"invalid suite type\");\n      var keys = ebtk(password, !1, config.key, config.iv);\n      return createDecipheriv(suite, keys.key, keys.iv);\n    }\n    exports.createDecipher = createDecipher, exports.createDecipheriv = createDecipheriv;\n  }\n}), require_browser5 = __commonJS({\n  \"node_modules/browserify-aes/browser.js\"(exports) {\n    var ciphers = require_encrypter(), deciphers = require_decrypter(), modes = require_list();\n    function getCiphers() {\n      return Object.keys(modes);\n    }\n    exports.createCipher = exports.Cipher = ciphers.createCipher, exports.createCipheriv = exports.Cipheriv = ciphers.createCipheriv, exports.createDecipher = exports.Decipher = deciphers.createDecipher, exports.createDecipheriv = exports.Decipheriv = deciphers.createDecipheriv, exports.listCiphers = exports.getCiphers = getCiphers;\n  }\n}), require_modes2 = __commonJS({\n  \"node_modules/browserify-des/modes.js\"(exports) {\n    exports[\"des-ecb\"] = {\n      key: 8,\n      iv: 0\n    }, exports[\"des-cbc\"] = exports.des = {\n      key: 8,\n      iv: 8\n    }, exports[\"des-ede3-cbc\"] = exports.des3 = {\n      key: 24,\n      iv: 8\n    }, exports[\"des-ede3\"] = {\n      key: 24,\n      iv: 0\n    }, exports[\"des-ede-cbc\"] = {\n      key: 16,\n      iv: 8\n    }, exports[\"des-ede\"] = {\n      key: 16,\n      iv: 0\n    };\n  }\n}), require_browser6 = __commonJS({\n  \"node_modules/browserify-cipher/browser.js\"(exports) {\n    var DES = require_browserify_des(), aes = require_browser5(), aesModes = require_modes(), desModes = require_modes2(), ebtk = require_evp_bytestokey();\n    function createCipher(suite, password) {\n      suite = suite.toLowerCase();\n      var keyLen, ivLen;\n      if (aesModes[suite])\n        keyLen = aesModes[suite].key, ivLen = aesModes[suite].iv;\n      else if (desModes[suite])\n        keyLen = desModes[suite].key * 8, ivLen = desModes[suite].iv;\n      else\n        @throwTypeError(\"invalid suite type\");\n      var keys = ebtk(password, !1, keyLen, ivLen);\n      return createCipheriv(suite, keys.key, keys.iv);\n    }\n    function createDecipher(suite, password) {\n      suite = suite.toLowerCase();\n      var keyLen, ivLen;\n      if (aesModes[suite])\n        keyLen = aesModes[suite].key, ivLen = aesModes[suite].iv;\n      else if (desModes[suite])\n        keyLen = desModes[suite].key * 8, ivLen = desModes[suite].iv;\n      else\n        @throwTypeError(\"invalid suite type\");\n      var keys = ebtk(password, !1, keyLen, ivLen);\n      return createDecipheriv(suite, keys.key, keys.iv);\n    }\n    function createCipheriv(suite, key, iv) {\n      if (suite = suite.toLowerCase(), aesModes[suite])\n        return aes.createCipheriv(suite, key, iv);\n      if (desModes[suite])\n        return new DES({ key, iv, mode: suite });\n      @throwTypeError(\"invalid suite type\");\n    }\n    function createDecipheriv(suite, key, iv) {\n      if (suite = suite.toLowerCase(), aesModes[suite])\n        return aes.createDecipheriv(suite, key, iv);\n      if (desModes[suite])\n        return new DES({ key, iv, mode: suite, decrypt: !0 });\n      @throwTypeError(\"invalid suite type\");\n    }\n    function getCiphers() {\n      return Object.keys(desModes).concat(aes.getCiphers());\n    }\n    exports.createCipher = exports.Cipher = createCipher, exports.createCipheriv = exports.Cipheriv = createCipheriv, exports.createDecipher = exports.Decipher = createDecipher, exports.createDecipheriv = exports.Decipheriv = createDecipheriv, exports.listCiphers = exports.getCiphers = getCiphers;\n  }\n}), require_bn = __commonJS({\n  \"node_modules/diffie-hellman/node_modules/bn.js/lib/bn.js\"(exports, module) {\n    (function(module2, exports2) {\n      function assert(val, msg) {\n        if (!val)\n          throw new Error(msg || \"Assertion failed\");\n      }\n      function inherits(ctor, superCtor) {\n        ctor.super_ = superCtor;\n        var TempCtor = function() {\n        };\n        TempCtor.prototype = superCtor.prototype, ctor.prototype = new TempCtor, ctor.prototype.constructor = ctor;\n      }\n      function BN(number, base, endian) {\n        if (BN.isBN(number))\n          return number;\n        this.negative = 0, this.words = null, this.length = 0, this.red = null, number !== null && ((base === \"le\" || base === \"be\") && (endian = base, base = 10), this._init(number || 0, base || 10, endian || \"be\"));\n      }\n      BN.prototype = {}, typeof module2 == \"object\" \? module2.exports = BN : exports2.BN = BN, BN.BN = BN, BN.wordSize = 26;\n      var Buffer2 = Buffer;\n      BN.isBN = function(num) {\n        return num instanceof BN \? !0 : num !== null && typeof num == \"object\" && num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);\n      }, BN.max = function(left, right) {\n        return left.cmp(right) > 0 \? left : right;\n      }, BN.min = function(left, right) {\n        return left.cmp(right) < 0 \? left : right;\n      }, BN.prototype._init = function(number, base, endian) {\n        if (typeof number == \"number\")\n          return this._initNumber(number, base, endian);\n        if (typeof number == \"object\")\n          return this._initArray(number, base, endian);\n        base === \"hex\" && (base = 16), assert(base === (base | 0) && base >= 2 && base <= 36), number = number.toString().replace(/\\s+/g, \"\");\n        var start = 0;\n        number[0] === \"-\" && (start++, this.negative = 1), start < number.length && (base === 16 \? this._parseHex(number, start, endian) : (this._parseBase(number, base, start), endian === \"le\" && this._initArray(this.toArray(), base, endian)));\n      }, BN.prototype._initNumber = function(number, base, endian) {\n        number < 0 && (this.negative = 1, number = -number), number < 67108864 \? (this.words = [number & 67108863], this.length = 1) : number < 4503599627370496 \? (this.words = [number & 67108863, number / 67108864 & 67108863], this.length = 2) : (assert(number < 9007199254740992), this.words = [number & 67108863, number / 67108864 & 67108863, 1], this.length = 3), endian === \"le\" && this._initArray(this.toArray(), base, endian);\n      }, BN.prototype._initArray = function(number, base, endian) {\n        if (assert(typeof number.length == \"number\"), number.length <= 0)\n          return this.words = [0], this.length = 1, this;\n        this.length = Math.ceil(number.length / 3), this.words = new Array(this.length);\n        for (var i = 0;i < this.length; i++)\n          this.words[i] = 0;\n        var j, w, off = 0;\n        if (endian === \"be\")\n          for (i = number.length - 1, j = 0;i >= 0; i -= 3)\n            w = number[i] | number[i - 1] << 8 | number[i - 2] << 16, this.words[j] |= w << off & 67108863, this.words[j + 1] = w >>> 26 - off & 67108863, off += 24, off >= 26 && (off -= 26, j++);\n        else if (endian === \"le\")\n          for (i = 0, j = 0;i < number.length; i += 3)\n            w = number[i] | number[i + 1] << 8 | number[i + 2] << 16, this.words[j] |= w << off & 67108863, this.words[j + 1] = w >>> 26 - off & 67108863, off += 24, off >= 26 && (off -= 26, j++);\n        return this.strip();\n      };\n      function parseHex4Bits(string, index) {\n        var c = string.charCodeAt(index);\n        return c >= 65 && c <= 70 \? c - 55 : c >= 97 && c <= 102 \? c - 87 : c - 48 & 15;\n      }\n      function parseHexByte(string, lowerBound, index) {\n        var r = parseHex4Bits(string, index);\n        return index - 1 >= lowerBound && (r |= parseHex4Bits(string, index - 1) << 4), r;\n      }\n      BN.prototype._parseHex = function(number, start, endian) {\n        this.length = Math.ceil((number.length - start) / 6), this.words = new Array(this.length);\n        for (var i = 0;i < this.length; i++)\n          this.words[i] = 0;\n        var off = 0, j = 0, w;\n        if (endian === \"be\")\n          for (i = number.length - 1;i >= start; i -= 2)\n            w = parseHexByte(number, start, i) << off, this.words[j] |= w & 67108863, off >= 18 \? (off -= 18, j += 1, this.words[j] |= w >>> 26) : off += 8;\n        else {\n          var parseLength = number.length - start;\n          for (i = parseLength % 2 === 0 \? start + 1 : start;i < number.length; i += 2)\n            w = parseHexByte(number, start, i) << off, this.words[j] |= w & 67108863, off >= 18 \? (off -= 18, j += 1, this.words[j] |= w >>> 26) : off += 8;\n        }\n        this.strip();\n      };\n      function parseBase(str, start, end, mul) {\n        for (var r = 0, len = Math.min(str.length, end), i = start;i < len; i++) {\n          var c = str.charCodeAt(i) - 48;\n          r *= mul, c >= 49 \? r += c - 49 + 10 : c >= 17 \? r += c - 17 + 10 : r += c;\n        }\n        return r;\n      }\n      BN.prototype._parseBase = function(number, base, start) {\n        this.words = [0], this.length = 1;\n        for (var limbLen = 0, limbPow = 1;limbPow <= 67108863; limbPow *= base)\n          limbLen++;\n        limbLen--, limbPow = limbPow / base | 0;\n        for (var total = number.length - start, mod = total % limbLen, end = Math.min(total, total - mod) + start, word = 0, i = start;i < end; i += limbLen)\n          word = parseBase(number, i, i + limbLen, base), this.imuln(limbPow), this.words[0] + word < 67108864 \? this.words[0] += word : this._iaddn(word);\n        if (mod !== 0) {\n          var pow = 1;\n          for (word = parseBase(number, i, number.length, base), i = 0;i < mod; i++)\n            pow *= base;\n          this.imuln(pow), this.words[0] + word < 67108864 \? this.words[0] += word : this._iaddn(word);\n        }\n        this.strip();\n      }, BN.prototype.copy = function(dest) {\n        dest.words = new Array(this.length);\n        for (var i = 0;i < this.length; i++)\n          dest.words[i] = this.words[i];\n        dest.length = this.length, dest.negative = this.negative, dest.red = this.red;\n      }, BN.prototype.clone = function() {\n        var r = new BN(null);\n        return this.copy(r), r;\n      }, BN.prototype._expand = function(size) {\n        for (;this.length < size; )\n          this.words[this.length++] = 0;\n        return this;\n      }, BN.prototype.strip = function() {\n        for (;this.length > 1 && this.words[this.length - 1] === 0; )\n          this.length--;\n        return this._normSign();\n      }, BN.prototype._normSign = function() {\n        return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;\n      }, BN.prototype.inspect = function() {\n        return (this.red \? \"<BN-R: \" : \"<BN: \") + this.toString(16) + \">\";\n      };\n      var zeros = [\n        \"\",\n        \"0\",\n        \"00\",\n        \"000\",\n        \"0000\",\n        \"00000\",\n        \"000000\",\n        \"0000000\",\n        \"00000000\",\n        \"000000000\",\n        \"0000000000\",\n        \"00000000000\",\n        \"000000000000\",\n        \"0000000000000\",\n        \"00000000000000\",\n        \"000000000000000\",\n        \"0000000000000000\",\n        \"00000000000000000\",\n        \"000000000000000000\",\n        \"0000000000000000000\",\n        \"00000000000000000000\",\n        \"000000000000000000000\",\n        \"0000000000000000000000\",\n        \"00000000000000000000000\",\n        \"000000000000000000000000\",\n        \"0000000000000000000000000\"\n      ], groupSizes = [\n        0,\n        0,\n        25,\n        16,\n        12,\n        11,\n        10,\n        9,\n        8,\n        8,\n        7,\n        7,\n        7,\n        7,\n        6,\n        6,\n        6,\n        6,\n        6,\n        6,\n        6,\n        5,\n        5,\n        5,\n        5,\n        5,\n        5,\n        5,\n        5,\n        5,\n        5,\n        5,\n        5,\n        5,\n        5,\n        5,\n        5\n      ], groupBases = [\n        0,\n        0,\n        33554432,\n        43046721,\n        16777216,\n        48828125,\n        60466176,\n        40353607,\n        16777216,\n        43046721,\n        1e7,\n        19487171,\n        35831808,\n        62748517,\n        7529536,\n        11390625,\n        16777216,\n        24137569,\n        34012224,\n        47045881,\n        64000000,\n        4084101,\n        5153632,\n        6436343,\n        7962624,\n        9765625,\n        11881376,\n        14348907,\n        17210368,\n        20511149,\n        24300000,\n        28629151,\n        33554432,\n        39135393,\n        45435424,\n        52521875,\n        60466176\n      ];\n      BN.prototype.toString = function(base, padding) {\n        base = base || 10, padding = padding | 0 || 1;\n        var out;\n        if (base === 16 || base === \"hex\") {\n          out = \"\";\n          for (var off = 0, carry = 0, i = 0;i < this.length; i++) {\n            var w = this.words[i], word = ((w << off | carry) & 16777215).toString(16);\n            carry = w >>> 24 - off & 16777215, carry !== 0 || i !== this.length - 1 \? out = zeros[6 - word.length] + word + out : out = word + out, off += 2, off >= 26 && (off -= 26, i--);\n          }\n          for (carry !== 0 && (out = carry.toString(16) + out);out.length % padding !== 0; )\n            out = \"0\" + out;\n          return this.negative !== 0 && (out = \"-\" + out), out;\n        }\n        if (base === (base | 0) && base >= 2 && base <= 36) {\n          var groupSize = groupSizes[base], groupBase = groupBases[base];\n          out = \"\";\n          var c = this.clone();\n          for (c.negative = 0;!c.isZero(); ) {\n            var r = c.modn(groupBase).toString(base);\n            c = c.idivn(groupBase), c.isZero() \? out = r + out : out = zeros[groupSize - r.length] + r + out;\n          }\n          for (this.isZero() && (out = \"0\" + out);out.length % padding !== 0; )\n            out = \"0\" + out;\n          return this.negative !== 0 && (out = \"-\" + out), out;\n        }\n        assert(!1, \"Base should be between 2 and 36\");\n      }, BN.prototype.toNumber = function() {\n        var ret = this.words[0];\n        return this.length === 2 \? ret += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 \? ret += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && assert(!1, \"Number can only safely store up to 53 bits\"), this.negative !== 0 \? -ret : ret;\n      }, BN.prototype.toJSON = function() {\n        return this.toString(16);\n      }, BN.prototype.toBuffer = function(endian, length) {\n        return assert(typeof Buffer2 < \"u\"), this.toArrayLike(Buffer2, endian, length);\n      }, BN.prototype.toArray = function(endian, length) {\n        return this.toArrayLike(Array, endian, length);\n      }, BN.prototype.toArrayLike = function(ArrayType, endian, length) {\n        var byteLength = this.byteLength(), reqLength = length || Math.max(1, byteLength);\n        assert(byteLength <= reqLength, \"byte array longer than desired length\"), assert(reqLength > 0, \"Requested array length <= 0\"), this.strip();\n        var littleEndian = endian === \"le\", res = new ArrayType(reqLength), b, i, q = this.clone();\n        if (littleEndian) {\n          for (i = 0;!q.isZero(); i++)\n            b = q.andln(255), q.iushrn(8), res[i] = b;\n          for (;i < reqLength; i++)\n            res[i] = 0;\n        } else {\n          for (i = 0;i < reqLength - byteLength; i++)\n            res[i] = 0;\n          for (i = 0;!q.isZero(); i++)\n            b = q.andln(255), q.iushrn(8), res[reqLength - i - 1] = b;\n        }\n        return res;\n      }, Math.clz32 \? BN.prototype._countBits = function(w) {\n        return 32 - Math.clz32(w);\n      } : BN.prototype._countBits = function(w) {\n        var t = w, r = 0;\n        return t >= 4096 && (r += 13, t >>>= 13), t >= 64 && (r += 7, t >>>= 7), t >= 8 && (r += 4, t >>>= 4), t >= 2 && (r += 2, t >>>= 2), r + t;\n      }, BN.prototype._zeroBits = function(w) {\n        if (w === 0)\n          return 26;\n        var t = w, r = 0;\n        return (t & 8191) === 0 && (r += 13, t >>>= 13), (t & 127) === 0 && (r += 7, t >>>= 7), (t & 15) === 0 && (r += 4, t >>>= 4), (t & 3) === 0 && (r += 2, t >>>= 2), (t & 1) === 0 && r++, r;\n      }, BN.prototype.bitLength = function() {\n        var w = this.words[this.length - 1], hi = this._countBits(w);\n        return (this.length - 1) * 26 + hi;\n      };\n      function toBitArray(num) {\n        for (var w = new Array(num.bitLength()), bit = 0;bit < w.length; bit++) {\n          var off = bit / 26 | 0, wbit = bit % 26;\n          w[bit] = (num.words[off] & 1 << wbit) >>> wbit;\n        }\n        return w;\n      }\n      BN.prototype.zeroBits = function() {\n        if (this.isZero())\n          return 0;\n        for (var r = 0, i = 0;i < this.length; i++) {\n          var b = this._zeroBits(this.words[i]);\n          if (r += b, b !== 26)\n            break;\n        }\n        return r;\n      }, BN.prototype.byteLength = function() {\n        return Math.ceil(this.bitLength() / 8);\n      }, BN.prototype.toTwos = function(width) {\n        return this.negative !== 0 \? this.abs().inotn(width).iaddn(1) : this.clone();\n      }, BN.prototype.fromTwos = function(width) {\n        return this.testn(width - 1) \? this.notn(width).iaddn(1).ineg() : this.clone();\n      }, BN.prototype.isNeg = function() {\n        return this.negative !== 0;\n      }, BN.prototype.neg = function() {\n        return this.clone().ineg();\n      }, BN.prototype.ineg = function() {\n        return this.isZero() || (this.negative ^= 1), this;\n      }, BN.prototype.iuor = function(num) {\n        for (;this.length < num.length; )\n          this.words[this.length++] = 0;\n        for (var i = 0;i < num.length; i++)\n          this.words[i] = this.words[i] | num.words[i];\n        return this.strip();\n      }, BN.prototype.ior = function(num) {\n        return assert((this.negative | num.negative) === 0), this.iuor(num);\n      }, BN.prototype.or = function(num) {\n        return this.length > num.length \? this.clone().ior(num) : num.clone().ior(this);\n      }, BN.prototype.uor = function(num) {\n        return this.length > num.length \? this.clone().iuor(num) : num.clone().iuor(this);\n      }, BN.prototype.iuand = function(num) {\n        var b;\n        this.length > num.length \? b = num : b = this;\n        for (var i = 0;i < b.length; i++)\n          this.words[i] = this.words[i] & num.words[i];\n        return this.length = b.length, this.strip();\n      }, BN.prototype.iand = function(num) {\n        return assert((this.negative | num.negative) === 0), this.iuand(num);\n      }, BN.prototype.and = function(num) {\n        return this.length > num.length \? this.clone().iand(num) : num.clone().iand(this);\n      }, BN.prototype.uand = function(num) {\n        return this.length > num.length \? this.clone().iuand(num) : num.clone().iuand(this);\n      }, BN.prototype.iuxor = function(num) {\n        var a, b;\n        this.length > num.length \? (a = this, b = num) : (a = num, b = this);\n        for (var i = 0;i < b.length; i++)\n          this.words[i] = a.words[i] ^ b.words[i];\n        if (this !== a)\n          for (;i < a.length; i++)\n            this.words[i] = a.words[i];\n        return this.length = a.length, this.strip();\n      }, BN.prototype.ixor = function(num) {\n        return assert((this.negative | num.negative) === 0), this.iuxor(num);\n      }, BN.prototype.xor = function(num) {\n        return this.length > num.length \? this.clone().ixor(num) : num.clone().ixor(this);\n      }, BN.prototype.uxor = function(num) {\n        return this.length > num.length \? this.clone().iuxor(num) : num.clone().iuxor(this);\n      }, BN.prototype.inotn = function(width) {\n        assert(typeof width == \"number\" && width >= 0);\n        var bytesNeeded = Math.ceil(width / 26) | 0, bitsLeft = width % 26;\n        this._expand(bytesNeeded), bitsLeft > 0 && bytesNeeded--;\n        for (var i = 0;i < bytesNeeded; i++)\n          this.words[i] = ~this.words[i] & 67108863;\n        return bitsLeft > 0 && (this.words[i] = ~this.words[i] & 67108863 >> 26 - bitsLeft), this.strip();\n      }, BN.prototype.notn = function(width) {\n        return this.clone().inotn(width);\n      }, BN.prototype.setn = function(bit, val) {\n        assert(typeof bit == \"number\" && bit >= 0);\n        var off = bit / 26 | 0, wbit = bit % 26;\n        return this._expand(off + 1), val \? this.words[off] = this.words[off] | 1 << wbit : this.words[off] = this.words[off] & ~(1 << wbit), this.strip();\n      }, BN.prototype.iadd = function(num) {\n        var r;\n        if (this.negative !== 0 && num.negative === 0)\n          return this.negative = 0, r = this.isub(num), this.negative ^= 1, this._normSign();\n        if (this.negative === 0 && num.negative !== 0)\n          return num.negative = 0, r = this.isub(num), num.negative = 1, r._normSign();\n        var a, b;\n        this.length > num.length \? (a = this, b = num) : (a = num, b = this);\n        for (var carry = 0, i = 0;i < b.length; i++)\n          r = (a.words[i] | 0) + (b.words[i] | 0) + carry, this.words[i] = r & 67108863, carry = r >>> 26;\n        for (;carry !== 0 && i < a.length; i++)\n          r = (a.words[i] | 0) + carry, this.words[i] = r & 67108863, carry = r >>> 26;\n        if (this.length = a.length, carry !== 0)\n          this.words[this.length] = carry, this.length++;\n        else if (a !== this)\n          for (;i < a.length; i++)\n            this.words[i] = a.words[i];\n        return this;\n      }, BN.prototype.add = function(num) {\n        var res;\n        return num.negative !== 0 && this.negative === 0 \? (num.negative = 0, res = this.sub(num), num.negative ^= 1, res) : num.negative === 0 && this.negative !== 0 \? (this.negative = 0, res = num.sub(this), this.negative = 1, res) : this.length > num.length \? this.clone().iadd(num) : num.clone().iadd(this);\n      }, BN.prototype.isub = function(num) {\n        if (num.negative !== 0) {\n          num.negative = 0;\n          var r = this.iadd(num);\n          return num.negative = 1, r._normSign();\n        } else if (this.negative !== 0)\n          return this.negative = 0, this.iadd(num), this.negative = 1, this._normSign();\n        var cmp = this.cmp(num);\n        if (cmp === 0)\n          return this.negative = 0, this.length = 1, this.words[0] = 0, this;\n        var a, b;\n        cmp > 0 \? (a = this, b = num) : (a = num, b = this);\n        for (var carry = 0, i = 0;i < b.length; i++)\n          r = (a.words[i] | 0) - (b.words[i] | 0) + carry, carry = r >> 26, this.words[i] = r & 67108863;\n        for (;carry !== 0 && i < a.length; i++)\n          r = (a.words[i] | 0) + carry, carry = r >> 26, this.words[i] = r & 67108863;\n        if (carry === 0 && i < a.length && a !== this)\n          for (;i < a.length; i++)\n            this.words[i] = a.words[i];\n        return this.length = Math.max(this.length, i), a !== this && (this.negative = 1), this.strip();\n      }, BN.prototype.sub = function(num) {\n        return this.clone().isub(num);\n      };\n      function smallMulTo(self2, num, out) {\n        out.negative = num.negative ^ self2.negative;\n        var len = self2.length + num.length | 0;\n        out.length = len, len = len - 1 | 0;\n        var a = self2.words[0] | 0, b = num.words[0] | 0, r = a * b, lo = r & 67108863, carry = r / 67108864 | 0;\n        out.words[0] = lo;\n        for (var k = 1;k < len; k++) {\n          for (var ncarry = carry >>> 26, rword = carry & 67108863, maxJ = Math.min(k, num.length - 1), j = Math.max(0, k - self2.length + 1);j <= maxJ; j++) {\n            var i = k - j | 0;\n            a = self2.words[i] | 0, b = num.words[j] | 0, r = a * b + rword, ncarry += r / 67108864 | 0, rword = r & 67108863;\n          }\n          out.words[k] = rword | 0, carry = ncarry | 0;\n        }\n        return carry !== 0 \? out.words[k] = carry | 0 : out.length--, out.strip();\n      }\n      var comb10MulTo = function(self2, num, out) {\n        var a = self2.words, b = num.words, o = out.words, c = 0, lo, mid, hi, a0 = a[0] | 0, al0 = a0 & 8191, ah0 = a0 >>> 13, a1 = a[1] | 0, al1 = a1 & 8191, ah1 = a1 >>> 13, a2 = a[2] | 0, al2 = a2 & 8191, ah2 = a2 >>> 13, a3 = a[3] | 0, al3 = a3 & 8191, ah3 = a3 >>> 13, a4 = a[4] | 0, al4 = a4 & 8191, ah4 = a4 >>> 13, a5 = a[5] | 0, al5 = a5 & 8191, ah5 = a5 >>> 13, a6 = a[6] | 0, al6 = a6 & 8191, ah6 = a6 >>> 13, a7 = a[7] | 0, al7 = a7 & 8191, ah7 = a7 >>> 13, a8 = a[8] | 0, al8 = a8 & 8191, ah8 = a8 >>> 13, a9 = a[9] | 0, al9 = a9 & 8191, ah9 = a9 >>> 13, b0 = b[0] | 0, bl0 = b0 & 8191, bh0 = b0 >>> 13, b1 = b[1] | 0, bl1 = b1 & 8191, bh1 = b1 >>> 13, b2 = b[2] | 0, bl2 = b2 & 8191, bh2 = b2 >>> 13, b3 = b[3] | 0, bl3 = b3 & 8191, bh3 = b3 >>> 13, b4 = b[4] | 0, bl4 = b4 & 8191, bh4 = b4 >>> 13, b5 = b[5] | 0, bl5 = b5 & 8191, bh5 = b5 >>> 13, b6 = b[6] | 0, bl6 = b6 & 8191, bh6 = b6 >>> 13, b7 = b[7] | 0, bl7 = b7 & 8191, bh7 = b7 >>> 13, b8 = b[8] | 0, bl8 = b8 & 8191, bh8 = b8 >>> 13, b9 = b[9] | 0, bl9 = b9 & 8191, bh9 = b9 >>> 13;\n        out.negative = self2.negative ^ num.negative, out.length = 19, lo = Math.imul(al0, bl0), mid = Math.imul(al0, bh0), mid = mid + Math.imul(ah0, bl0) | 0, hi = Math.imul(ah0, bh0);\n        var w0 = (c + lo | 0) + ((mid & 8191) << 13) | 0;\n        c = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0, w0 &= 67108863, lo = Math.imul(al1, bl0), mid = Math.imul(al1, bh0), mid = mid + Math.imul(ah1, bl0) | 0, hi = Math.imul(ah1, bh0), lo = lo + Math.imul(al0, bl1) | 0, mid = mid + Math.imul(al0, bh1) | 0, mid = mid + Math.imul(ah0, bl1) | 0, hi = hi + Math.imul(ah0, bh1) | 0;\n        var w1 = (c + lo | 0) + ((mid & 8191) << 13) | 0;\n        c = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0, w1 &= 67108863, lo = Math.imul(al2, bl0), mid = Math.imul(al2, bh0), mid = mid + Math.imul(ah2, bl0) | 0, hi = Math.imul(ah2, bh0), lo = lo + Math.imul(al1, bl1) | 0, mid = mid + Math.imul(al1, bh1) | 0, mid = mid + Math.imul(ah1, bl1) | 0, hi = hi + Math.imul(ah1, bh1) | 0, lo = lo + Math.imul(al0, bl2) | 0, mid = mid + Math.imul(al0, bh2) | 0, mid = mid + Math.imul(ah0, bl2) | 0, hi = hi + Math.imul(ah0, bh2) | 0;\n        var w2 = (c + lo | 0) + ((mid & 8191) << 13) | 0;\n        c = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0, w2 &= 67108863, lo = Math.imul(al3, bl0), mid = Math.imul(al3, bh0), mid = mid + Math.imul(ah3, bl0) | 0, hi = Math.imul(ah3, bh0), lo = lo + Math.imul(al2, bl1) | 0, mid = mid + Math.imul(al2, bh1) | 0, mid = mid + Math.imul(ah2, bl1) | 0, hi = hi + Math.imul(ah2, bh1) | 0, lo = lo + Math.imul(al1, bl2) | 0, mid = mid + Math.imul(al1, bh2) | 0, mid = mid + Math.imul(ah1, bl2) | 0, hi = hi + Math.imul(ah1, bh2) | 0, lo = lo + Math.imul(al0, bl3) | 0, mid = mid + Math.imul(al0, bh3) | 0, mid = mid + Math.imul(ah0, bl3) | 0, hi = hi + Math.imul(ah0, bh3) | 0;\n        var w3 = (c + lo | 0) + ((mid & 8191) << 13) | 0;\n        c = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0, w3 &= 67108863, lo = Math.imul(al4, bl0), mid = Math.imul(al4, bh0), mid = mid + Math.imul(ah4, bl0) | 0, hi = Math.imul(ah4, bh0), lo = lo + Math.imul(al3, bl1) | 0, mid = mid + Math.imul(al3, bh1) | 0, mid = mid + Math.imul(ah3, bl1) | 0, hi = hi + Math.imul(ah3, bh1) | 0, lo = lo + Math.imul(al2, bl2) | 0, mid = mid + Math.imul(al2, bh2) | 0, mid = mid + Math.imul(ah2, bl2) | 0, hi = hi + Math.imul(ah2, bh2) | 0, lo = lo + Math.imul(al1, bl3) | 0, mid = mid + Math.imul(al1, bh3) | 0, mid = mid + Math.imul(ah1, bl3) | 0, hi = hi + Math.imul(ah1, bh3) | 0, lo = lo + Math.imul(al0, bl4) | 0, mid = mid + Math.imul(al0, bh4) | 0, mid = mid + Math.imul(ah0, bl4) | 0, hi = hi + Math.imul(ah0, bh4) | 0;\n        var w4 = (c + lo | 0) + ((mid & 8191) << 13) | 0;\n        c = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0, w4 &= 67108863, lo = Math.imul(al5, bl0), mid = Math.imul(al5, bh0), mid = mid + Math.imul(ah5, bl0) | 0, hi = Math.imul(ah5, bh0), lo = lo + Math.imul(al4, bl1) | 0, mid = mid + Math.imul(al4, bh1) | 0, mid = mid + Math.imul(ah4, bl1) | 0, hi = hi + Math.imul(ah4, bh1) | 0, lo = lo + Math.imul(al3, bl2) | 0, mid = mid + Math.imul(al3, bh2) | 0, mid = mid + Math.imul(ah3, bl2) | 0, hi = hi + Math.imul(ah3, bh2) | 0, lo = lo + Math.imul(al2, bl3) | 0, mid = mid + Math.imul(al2, bh3) | 0, mid = mid + Math.imul(ah2, bl3) | 0, hi = hi + Math.imul(ah2, bh3) | 0, lo = lo + Math.imul(al1, bl4) | 0, mid = mid + Math.imul(al1, bh4) | 0, mid = mid + Math.imul(ah1, bl4) | 0, hi = hi + Math.imul(ah1, bh4) | 0, lo = lo + Math.imul(al0, bl5) | 0, mid = mid + Math.imul(al0, bh5) | 0, mid = mid + Math.imul(ah0, bl5) | 0, hi = hi + Math.imul(ah0, bh5) | 0;\n        var w5 = (c + lo | 0) + ((mid & 8191) << 13) | 0;\n        c = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0, w5 &= 67108863, lo = Math.imul(al6, bl0), mid = Math.imul(al6, bh0), mid = mid + Math.imul(ah6, bl0) | 0, hi = Math.imul(ah6, bh0), lo = lo + Math.imul(al5, bl1) | 0, mid = mid + Math.imul(al5, bh1) | 0, mid = mid + Math.imul(ah5, bl1) | 0, hi = hi + Math.imul(ah5, bh1) | 0, lo = lo + Math.imul(al4, bl2) | 0, mid = mid + Math.imul(al4, bh2) | 0, mid = mid + Math.imul(ah4, bl2) | 0, hi = hi + Math.imul(ah4, bh2) | 0, lo = lo + Math.imul(al3, bl3) | 0, mid = mid + Math.imul(al3, bh3) | 0, mid = mid + Math.imul(ah3, bl3) | 0, hi = hi + Math.imul(ah3, bh3) | 0, lo = lo + Math.imul(al2, bl4) | 0, mid = mid + Math.imul(al2, bh4) | 0, mid = mid + Math.imul(ah2, bl4) | 0, hi = hi + Math.imul(ah2, bh4) | 0, lo = lo + Math.imul(al1, bl5) | 0, mid = mid + Math.imul(al1, bh5) | 0, mid = mid + Math.imul(ah1, bl5) | 0, hi = hi + Math.imul(ah1, bh5) | 0, lo = lo + Math.imul(al0, bl6) | 0, mid = mid + Math.imul(al0, bh6) | 0, mid = mid + Math.imul(ah0, bl6) | 0, hi = hi + Math.imul(ah0, bh6) | 0;\n        var w6 = (c + lo | 0) + ((mid & 8191) << 13) | 0;\n        c = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0, w6 &= 67108863, lo = Math.imul(al7, bl0), mid = Math.imul(al7, bh0), mid = mid + Math.imul(ah7, bl0) | 0, hi = Math.imul(ah7, bh0), lo = lo + Math.imul(al6, bl1) | 0, mid = mid + Math.imul(al6, bh1) | 0, mid = mid + Math.imul(ah6, bl1) | 0, hi = hi + Math.imul(ah6, bh1) | 0, lo = lo + Math.imul(al5, bl2) | 0, mid = mid + Math.imul(al5, bh2) | 0, mid = mid + Math.imul(ah5, bl2) | 0, hi = hi + Math.imul(ah5, bh2) | 0, lo = lo + Math.imul(al4, bl3) | 0, mid = mid + Math.imul(al4, bh3) | 0, mid = mid + Math.imul(ah4, bl3) | 0, hi = hi + Math.imul(ah4, bh3) | 0, lo = lo + Math.imul(al3, bl4) | 0, mid = mid + Math.imul(al3, bh4) | 0, mid = mid + Math.imul(ah3, bl4) | 0, hi = hi + Math.imul(ah3, bh4) | 0, lo = lo + Math.imul(al2, bl5) | 0, mid = mid + Math.imul(al2, bh5) | 0, mid = mid + Math.imul(ah2, bl5) | 0, hi = hi + Math.imul(ah2, bh5) | 0, lo = lo + Math.imul(al1, bl6) | 0, mid = mid + Math.imul(al1, bh6) | 0, mid = mid + Math.imul(ah1, bl6) | 0, hi = hi + Math.imul(ah1, bh6) | 0, lo = lo + Math.imul(al0, bl7) | 0, mid = mid + Math.imul(al0, bh7) | 0, mid = mid + Math.imul(ah0, bl7) | 0, hi = hi + Math.imul(ah0, bh7) | 0;\n        var w7 = (c + lo | 0) + ((mid & 8191) << 13) | 0;\n        c = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0, w7 &= 67108863, lo = Math.imul(al8, bl0), mid = Math.imul(al8, bh0), mid = mid + Math.imul(ah8, bl0) | 0, hi = Math.imul(ah8, bh0), lo = lo + Math.imul(al7, bl1) | 0, mid = mid + Math.imul(al7, bh1) | 0, mid = mid + Math.imul(ah7, bl1) | 0, hi = hi + Math.imul(ah7, bh1) | 0, lo = lo + Math.imul(al6, bl2) | 0, mid = mid + Math.imul(al6, bh2) | 0, mid = mid + Math.imul(ah6, bl2) | 0, hi = hi + Math.imul(ah6, bh2) | 0, lo = lo + Math.imul(al5, bl3) | 0, mid = mid + Math.imul(al5, bh3) | 0, mid = mid + Math.imul(ah5, bl3) | 0, hi = hi + Math.imul(ah5, bh3) | 0, lo = lo + Math.imul(al4, bl4) | 0, mid = mid + Math.imul(al4, bh4) | 0, mid = mid + Math.imul(ah4, bl4) | 0, hi = hi + Math.imul(ah4, bh4) | 0, lo = lo + Math.imul(al3, bl5) | 0, mid = mid + Math.imul(al3, bh5) | 0, mid = mid + Math.imul(ah3, bl5) | 0, hi = hi + Math.imul(ah3, bh5) | 0, lo = lo + Math.imul(al2, bl6) | 0, mid = mid + Math.imul(al2, bh6) | 0, mid = mid + Math.imul(ah2, bl6) | 0, hi = hi + Math.imul(ah2, bh6) | 0, lo = lo + Math.imul(al1, bl7) | 0, mid = mid + Math.imul(al1, bh7) | 0, mid = mid + Math.imul(ah1, bl7) | 0, hi = hi + Math.imul(ah1, bh7) | 0, lo = lo + Math.imul(al0, bl8) | 0, mid = mid + Math.imul(al0, bh8) | 0, mid = mid + Math.imul(ah0, bl8) | 0, hi = hi + Math.imul(ah0, bh8) | 0;\n        var w8 = (c + lo | 0) + ((mid & 8191) << 13) | 0;\n        c = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0, w8 &= 67108863, lo = Math.imul(al9, bl0), mid = Math.imul(al9, bh0), mid = mid + Math.imul(ah9, bl0) | 0, hi = Math.imul(ah9, bh0), lo = lo + Math.imul(al8, bl1) | 0, mid = mid + Math.imul(al8, bh1) | 0, mid = mid + Math.imul(ah8, bl1) | 0, hi = hi + Math.imul(ah8, bh1) | 0, lo = lo + Math.imul(al7, bl2) | 0, mid = mid + Math.imul(al7, bh2) | 0, mid = mid + Math.imul(ah7, bl2) | 0, hi = hi + Math.imul(ah7, bh2) | 0, lo = lo + Math.imul(al6, bl3) | 0, mid = mid + Math.imul(al6, bh3) | 0, mid = mid + Math.imul(ah6, bl3) | 0, hi = hi + Math.imul(ah6, bh3) | 0, lo = lo + Math.imul(al5, bl4) | 0, mid = mid + Math.imul(al5, bh4) | 0, mid = mid + Math.imul(ah5, bl4) | 0, hi = hi + Math.imul(ah5, bh4) | 0, lo = lo + Math.imul(al4, bl5) | 0, mid = mid + Math.imul(al4, bh5) | 0, mid = mid + Math.imul(ah4, bl5) | 0, hi = hi + Math.imul(ah4, bh5) | 0, lo = lo + Math.imul(al3, bl6) | 0, mid = mid + Math.imul(al3, bh6) | 0, mid = mid + Math.imul(ah3, bl6) | 0, hi = hi + Math.imul(ah3, bh6) | 0, lo = lo + Math.imul(al2, bl7) | 0, mid = mid + Math.imul(al2, bh7) | 0, mid = mid + Math.imul(ah2, bl7) | 0, hi = hi + Math.imul(ah2, bh7) | 0, lo = lo + Math.imul(al1, bl8) | 0, mid = mid + Math.imul(al1, bh8) | 0, mid = mid + Math.imul(ah1, bl8) | 0, hi = hi + Math.imul(ah1, bh8) | 0, lo = lo + Math.imul(al0, bl9) | 0, mid = mid + Math.imul(al0, bh9) | 0, mid = mid + Math.imul(ah0, bl9) | 0, hi = hi + Math.imul(ah0, bh9) | 0;\n        var w9 = (c + lo | 0) + ((mid & 8191) << 13) | 0;\n        c = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0, w9 &= 67108863, lo = Math.imul(al9, bl1), mid = Math.imul(al9, bh1), mid = mid + Math.imul(ah9, bl1) | 0, hi = Math.imul(ah9, bh1), lo = lo + Math.imul(al8, bl2) | 0, mid = mid + Math.imul(al8, bh2) | 0, mid = mid + Math.imul(ah8, bl2) | 0, hi = hi + Math.imul(ah8, bh2) | 0, lo = lo + Math.imul(al7, bl3) | 0, mid = mid + Math.imul(al7, bh3) | 0, mid = mid + Math.imul(ah7, bl3) | 0, hi = hi + Math.imul(ah7, bh3) | 0, lo = lo + Math.imul(al6, bl4) | 0, mid = mid + Math.imul(al6, bh4) | 0, mid = mid + Math.imul(ah6, bl4) | 0, hi = hi + Math.imul(ah6, bh4) | 0, lo = lo + Math.imul(al5, bl5) | 0, mid = mid + Math.imul(al5, bh5) | 0, mid = mid + Math.imul(ah5, bl5) | 0, hi = hi + Math.imul(ah5, bh5) | 0, lo = lo + Math.imul(al4, bl6) | 0, mid = mid + Math.imul(al4, bh6) | 0, mid = mid + Math.imul(ah4, bl6) | 0, hi = hi + Math.imul(ah4, bh6) | 0, lo = lo + Math.imul(al3, bl7) | 0, mid = mid + Math.imul(al3, bh7) | 0, mid = mid + Math.imul(ah3, bl7) | 0, hi = hi + Math.imul(ah3, bh7) | 0, lo = lo + Math.imul(al2, bl8) | 0, mid = mid + Math.imul(al2, bh8) | 0, mid = mid + Math.imul(ah2, bl8) | 0, hi = hi + Math.imul(ah2, bh8) | 0, lo = lo + Math.imul(al1, bl9) | 0, mid = mid + Math.imul(al1, bh9) | 0, mid = mid + Math.imul(ah1, bl9) | 0, hi = hi + Math.imul(ah1, bh9) | 0;\n        var w10 = (c + lo | 0) + ((mid & 8191) << 13) | 0;\n        c = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0, w10 &= 67108863, lo = Math.imul(al9, bl2), mid = Math.imul(al9, bh2), mid = mid + Math.imul(ah9, bl2) | 0, hi = Math.imul(ah9, bh2), lo = lo + Math.imul(al8, bl3) | 0, mid = mid + Math.imul(al8, bh3) | 0, mid = mid + Math.imul(ah8, bl3) | 0, hi = hi + Math.imul(ah8, bh3) | 0, lo = lo + Math.imul(al7, bl4) | 0, mid = mid + Math.imul(al7, bh4) | 0, mid = mid + Math.imul(ah7, bl4) | 0, hi = hi + Math.imul(ah7, bh4) | 0, lo = lo + Math.imul(al6, bl5) | 0, mid = mid + Math.imul(al6, bh5) | 0, mid = mid + Math.imul(ah6, bl5) | 0, hi = hi + Math.imul(ah6, bh5) | 0, lo = lo + Math.imul(al5, bl6) | 0, mid = mid + Math.imul(al5, bh6) | 0, mid = mid + Math.imul(ah5, bl6) | 0, hi = hi + Math.imul(ah5, bh6) | 0, lo = lo + Math.imul(al4, bl7) | 0, mid = mid + Math.imul(al4, bh7) | 0, mid = mid + Math.imul(ah4, bl7) | 0, hi = hi + Math.imul(ah4, bh7) | 0, lo = lo + Math.imul(al3, bl8) | 0, mid = mid + Math.imul(al3, bh8) | 0, mid = mid + Math.imul(ah3, bl8) | 0, hi = hi + Math.imul(ah3, bh8) | 0, lo = lo + Math.imul(al2, bl9) | 0, mid = mid + Math.imul(al2, bh9) | 0, mid = mid + Math.imul(ah2, bl9) | 0, hi = hi + Math.imul(ah2, bh9) | 0;\n        var w11 = (c + lo | 0) + ((mid & 8191) << 13) | 0;\n        c = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0, w11 &= 67108863, lo = Math.imul(al9, bl3), mid = Math.imul(al9, bh3), mid = mid + Math.imul(ah9, bl3) | 0, hi = Math.imul(ah9, bh3), lo = lo + Math.imul(al8, bl4) | 0, mid = mid + Math.imul(al8, bh4) | 0, mid = mid + Math.imul(ah8, bl4) | 0, hi = hi + Math.imul(ah8, bh4) | 0, lo = lo + Math.imul(al7, bl5) | 0, mid = mid + Math.imul(al7, bh5) | 0, mid = mid + Math.imul(ah7, bl5) | 0, hi = hi + Math.imul(ah7, bh5) | 0, lo = lo + Math.imul(al6, bl6) | 0, mid = mid + Math.imul(al6, bh6) | 0, mid = mid + Math.imul(ah6, bl6) | 0, hi = hi + Math.imul(ah6, bh6) | 0, lo = lo + Math.imul(al5, bl7) | 0, mid = mid + Math.imul(al5, bh7) | 0, mid = mid + Math.imul(ah5, bl7) | 0, hi = hi + Math.imul(ah5, bh7) | 0, lo = lo + Math.imul(al4, bl8) | 0, mid = mid + Math.imul(al4, bh8) | 0, mid = mid + Math.imul(ah4, bl8) | 0, hi = hi + Math.imul(ah4, bh8) | 0, lo = lo + Math.imul(al3, bl9) | 0, mid = mid + Math.imul(al3, bh9) | 0, mid = mid + Math.imul(ah3, bl9) | 0, hi = hi + Math.imul(ah3, bh9) | 0;\n        var w12 = (c + lo | 0) + ((mid & 8191) << 13) | 0;\n        c = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0, w12 &= 67108863, lo = Math.imul(al9, bl4), mid = Math.imul(al9, bh4), mid = mid + Math.imul(ah9, bl4) | 0, hi = Math.imul(ah9, bh4), lo = lo + Math.imul(al8, bl5) | 0, mid = mid + Math.imul(al8, bh5) | 0, mid = mid + Math.imul(ah8, bl5) | 0, hi = hi + Math.imul(ah8, bh5) | 0, lo = lo + Math.imul(al7, bl6) | 0, mid = mid + Math.imul(al7, bh6) | 0, mid = mid + Math.imul(ah7, bl6) | 0, hi = hi + Math.imul(ah7, bh6) | 0, lo = lo + Math.imul(al6, bl7) | 0, mid = mid + Math.imul(al6, bh7) | 0, mid = mid + Math.imul(ah6, bl7) | 0, hi = hi + Math.imul(ah6, bh7) | 0, lo = lo + Math.imul(al5, bl8) | 0, mid = mid + Math.imul(al5, bh8) | 0, mid = mid + Math.imul(ah5, bl8) | 0, hi = hi + Math.imul(ah5, bh8) | 0, lo = lo + Math.imul(al4, bl9) | 0, mid = mid + Math.imul(al4, bh9) | 0, mid = mid + Math.imul(ah4, bl9) | 0, hi = hi + Math.imul(ah4, bh9) | 0;\n        var w13 = (c + lo | 0) + ((mid & 8191) << 13) | 0;\n        c = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0, w13 &= 67108863, lo = Math.imul(al9, bl5), mid = Math.imul(al9, bh5), mid = mid + Math.imul(ah9, bl5) | 0, hi = Math.imul(ah9, bh5), lo = lo + Math.imul(al8, bl6) | 0, mid = mid + Math.imul(al8, bh6) | 0, mid = mid + Math.imul(ah8, bl6) | 0, hi = hi + Math.imul(ah8, bh6) | 0, lo = lo + Math.imul(al7, bl7) | 0, mid = mid + Math.imul(al7, bh7) | 0, mid = mid + Math.imul(ah7, bl7) | 0, hi = hi + Math.imul(ah7, bh7) | 0, lo = lo + Math.imul(al6, bl8) | 0, mid = mid + Math.imul(al6, bh8) | 0, mid = mid + Math.imul(ah6, bl8) | 0, hi = hi + Math.imul(ah6, bh8) | 0, lo = lo + Math.imul(al5, bl9) | 0, mid = mid + Math.imul(al5, bh9) | 0, mid = mid + Math.imul(ah5, bl9) | 0, hi = hi + Math.imul(ah5, bh9) | 0;\n        var w14 = (c + lo | 0) + ((mid & 8191) << 13) | 0;\n        c = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0, w14 &= 67108863, lo = Math.imul(al9, bl6), mid = Math.imul(al9, bh6), mid = mid + Math.imul(ah9, bl6) | 0, hi = Math.imul(ah9, bh6), lo = lo + Math.imul(al8, bl7) | 0, mid = mid + Math.imul(al8, bh7) | 0, mid = mid + Math.imul(ah8, bl7) | 0, hi = hi + Math.imul(ah8, bh7) | 0, lo = lo + Math.imul(al7, bl8) | 0, mid = mid + Math.imul(al7, bh8) | 0, mid = mid + Math.imul(ah7, bl8) | 0, hi = hi + Math.imul(ah7, bh8) | 0, lo = lo + Math.imul(al6, bl9) | 0, mid = mid + Math.imul(al6, bh9) | 0, mid = mid + Math.imul(ah6, bl9) | 0, hi = hi + Math.imul(ah6, bh9) | 0;\n        var w15 = (c + lo | 0) + ((mid & 8191) << 13) | 0;\n        c = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0, w15 &= 67108863, lo = Math.imul(al9, bl7), mid = Math.imul(al9, bh7), mid = mid + Math.imul(ah9, bl7) | 0, hi = Math.imul(ah9, bh7), lo = lo + Math.imul(al8, bl8) | 0, mid = mid + Math.imul(al8, bh8) | 0, mid = mid + Math.imul(ah8, bl8) | 0, hi = hi + Math.imul(ah8, bh8) | 0, lo = lo + Math.imul(al7, bl9) | 0, mid = mid + Math.imul(al7, bh9) | 0, mid = mid + Math.imul(ah7, bl9) | 0, hi = hi + Math.imul(ah7, bh9) | 0;\n        var w16 = (c + lo | 0) + ((mid & 8191) << 13) | 0;\n        c = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0, w16 &= 67108863, lo = Math.imul(al9, bl8), mid = Math.imul(al9, bh8), mid = mid + Math.imul(ah9, bl8) | 0, hi = Math.imul(ah9, bh8), lo = lo + Math.imul(al8, bl9) | 0, mid = mid + Math.imul(al8, bh9) | 0, mid = mid + Math.imul(ah8, bl9) | 0, hi = hi + Math.imul(ah8, bh9) | 0;\n        var w17 = (c + lo | 0) + ((mid & 8191) << 13) | 0;\n        c = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0, w17 &= 67108863, lo = Math.imul(al9, bl9), mid = Math.imul(al9, bh9), mid = mid + Math.imul(ah9, bl9) | 0, hi = Math.imul(ah9, bh9);\n        var w18 = (c + lo | 0) + ((mid & 8191) << 13) | 0;\n        return c = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0, w18 &= 67108863, o[0] = w0, o[1] = w1, o[2] = w2, o[3] = w3, o[4] = w4, o[5] = w5, o[6] = w6, o[7] = w7, o[8] = w8, o[9] = w9, o[10] = w10, o[11] = w11, o[12] = w12, o[13] = w13, o[14] = w14, o[15] = w15, o[16] = w16, o[17] = w17, o[18] = w18, c !== 0 && (o[19] = c, out.length++), out;\n      };\n      Math.imul || (comb10MulTo = smallMulTo);\n      function bigMulTo(self2, num, out) {\n        out.negative = num.negative ^ self2.negative, out.length = self2.length + num.length;\n        for (var carry = 0, hncarry = 0, k = 0;k < out.length - 1; k++) {\n          var ncarry = hncarry;\n          hncarry = 0;\n          for (var rword = carry & 67108863, maxJ = Math.min(k, num.length - 1), j = Math.max(0, k - self2.length + 1);j <= maxJ; j++) {\n            var i = k - j, a = self2.words[i] | 0, b = num.words[j] | 0, r = a * b, lo = r & 67108863;\n            ncarry = ncarry + (r / 67108864 | 0) | 0, lo = lo + rword | 0, rword = lo & 67108863, ncarry = ncarry + (lo >>> 26) | 0, hncarry += ncarry >>> 26, ncarry &= 67108863;\n          }\n          out.words[k] = rword, carry = ncarry, ncarry = hncarry;\n        }\n        return carry !== 0 \? out.words[k] = carry : out.length--, out.strip();\n      }\n      function jumboMulTo(self2, num, out) {\n        var fftm = new FFTM;\n        return fftm.mulp(self2, num, out);\n      }\n      BN.prototype.mulTo = function(num, out) {\n        var res, len = this.length + num.length;\n        return this.length === 10 && num.length === 10 \? res = comb10MulTo(this, num, out) : len < 63 \? res = smallMulTo(this, num, out) : len < 1024 \? res = bigMulTo(this, num, out) : res = jumboMulTo(this, num, out), res;\n      };\n      function FFTM(x, y) {\n        this.x = x, this.y = y;\n      }\n      FFTM.prototype = {}, FFTM.prototype.makeRBT = function(N) {\n        for (var t = new Array(N), l = BN.prototype._countBits(N) - 1, i = 0;i < N; i++)\n          t[i] = this.revBin(i, l, N);\n        return t;\n      }, FFTM.prototype.revBin = function(x, l, N) {\n        if (x === 0 || x === N - 1)\n          return x;\n        for (var rb = 0, i = 0;i < l; i++)\n          rb |= (x & 1) << l - i - 1, x >>= 1;\n        return rb;\n      }, FFTM.prototype.permute = function(rbt, rws, iws, rtws, itws, N) {\n        for (var i = 0;i < N; i++)\n          rtws[i] = rws[rbt[i]], itws[i] = iws[rbt[i]];\n      }, FFTM.prototype.transform = function(rws, iws, rtws, itws, N, rbt) {\n        this.permute(rbt, rws, iws, rtws, itws, N);\n        for (var s = 1;s < N; s <<= 1)\n          for (var l = s << 1, rtwdf = Math.cos(2 * Math.PI / l), itwdf = Math.sin(2 * Math.PI / l), p = 0;p < N; p += l)\n            for (var rtwdf_ = rtwdf, itwdf_ = itwdf, j = 0;j < s; j++) {\n              var re = rtws[p + j], ie = itws[p + j], ro = rtws[p + j + s], io = itws[p + j + s], rx = rtwdf_ * ro - itwdf_ * io;\n              io = rtwdf_ * io + itwdf_ * ro, ro = rx, rtws[p + j] = re + ro, itws[p + j] = ie + io, rtws[p + j + s] = re - ro, itws[p + j + s] = ie - io, j !== l && (rx = rtwdf * rtwdf_ - itwdf * itwdf_, itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_, rtwdf_ = rx);\n            }\n      }, FFTM.prototype.guessLen13b = function(n, m) {\n        var N = Math.max(m, n) | 1, odd = N & 1, i = 0;\n        for (N = N / 2 | 0;N; N = N >>> 1)\n          i++;\n        return 1 << i + 1 + odd;\n      }, FFTM.prototype.conjugate = function(rws, iws, N) {\n        if (!(N <= 1))\n          for (var i = 0;i < N / 2; i++) {\n            var t = rws[i];\n            rws[i] = rws[N - i - 1], rws[N - i - 1] = t, t = iws[i], iws[i] = -iws[N - i - 1], iws[N - i - 1] = -t;\n          }\n      }, FFTM.prototype.normalize13b = function(ws, N) {\n        for (var carry = 0, i = 0;i < N / 2; i++) {\n          var w = Math.round(ws[2 * i + 1] / N) * 8192 + Math.round(ws[2 * i] / N) + carry;\n          ws[i] = w & 67108863, w < 67108864 \? carry = 0 : carry = w / 67108864 | 0;\n        }\n        return ws;\n      }, FFTM.prototype.convert13b = function(ws, len, rws, N) {\n        for (var carry = 0, i = 0;i < len; i++)\n          carry = carry + (ws[i] | 0), rws[2 * i] = carry & 8191, carry = carry >>> 13, rws[2 * i + 1] = carry & 8191, carry = carry >>> 13;\n        for (i = 2 * len;i < N; ++i)\n          rws[i] = 0;\n        assert(carry === 0), assert((carry & -8192) === 0);\n      }, FFTM.prototype.stub = function(N) {\n        for (var ph = new Array(N), i = 0;i < N; i++)\n          ph[i] = 0;\n        return ph;\n      }, FFTM.prototype.mulp = function(x, y, out) {\n        var N = 2 * this.guessLen13b(x.length, y.length), rbt = this.makeRBT(N), _ = this.stub(N), rws = new Array(N), rwst = new Array(N), iwst = new Array(N), nrws = new Array(N), nrwst = new Array(N), niwst = new Array(N), rmws = out.words;\n        rmws.length = N, this.convert13b(x.words, x.length, rws, N), this.convert13b(y.words, y.length, nrws, N), this.transform(rws, _, rwst, iwst, N, rbt), this.transform(nrws, _, nrwst, niwst, N, rbt);\n        for (var i = 0;i < N; i++) {\n          var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];\n          iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i], rwst[i] = rx;\n        }\n        return this.conjugate(rwst, iwst, N), this.transform(rwst, iwst, rmws, _, N, rbt), this.conjugate(rmws, _, N), this.normalize13b(rmws, N), out.negative = x.negative ^ y.negative, out.length = x.length + y.length, out.strip();\n      }, BN.prototype.mul = function(num) {\n        var out = new BN(null);\n        return out.words = new Array(this.length + num.length), this.mulTo(num, out);\n      }, BN.prototype.mulf = function(num) {\n        var out = new BN(null);\n        return out.words = new Array(this.length + num.length), jumboMulTo(this, num, out);\n      }, BN.prototype.imul = function(num) {\n        return this.clone().mulTo(num, this);\n      }, BN.prototype.imuln = function(num) {\n        assert(typeof num == \"number\"), assert(num < 67108864);\n        for (var carry = 0, i = 0;i < this.length; i++) {\n          var w = (this.words[i] | 0) * num, lo = (w & 67108863) + (carry & 67108863);\n          carry >>= 26, carry += w / 67108864 | 0, carry += lo >>> 26, this.words[i] = lo & 67108863;\n        }\n        return carry !== 0 && (this.words[i] = carry, this.length++), this;\n      }, BN.prototype.muln = function(num) {\n        return this.clone().imuln(num);\n      }, BN.prototype.sqr = function() {\n        return this.mul(this);\n      }, BN.prototype.isqr = function() {\n        return this.imul(this.clone());\n      }, BN.prototype.pow = function(num) {\n        var w = toBitArray(num);\n        if (w.length === 0)\n          return new BN(1);\n        for (var res = this, i = 0;i < w.length && w[i] === 0; i++, res = res.sqr())\n          ;\n        if (++i < w.length)\n          for (var q = res.sqr();i < w.length; i++, q = q.sqr())\n            w[i] !== 0 && (res = res.mul(q));\n        return res;\n      }, BN.prototype.iushln = function(bits) {\n        assert(typeof bits == \"number\" && bits >= 0);\n        var r = bits % 26, s = (bits - r) / 26, carryMask = 67108863 >>> 26 - r << 26 - r, i;\n        if (r !== 0) {\n          var carry = 0;\n          for (i = 0;i < this.length; i++) {\n            var newCarry = this.words[i] & carryMask, c = (this.words[i] | 0) - newCarry << r;\n            this.words[i] = c | carry, carry = newCarry >>> 26 - r;\n          }\n          carry && (this.words[i] = carry, this.length++);\n        }\n        if (s !== 0) {\n          for (i = this.length - 1;i >= 0; i--)\n            this.words[i + s] = this.words[i];\n          for (i = 0;i < s; i++)\n            this.words[i] = 0;\n          this.length += s;\n        }\n        return this.strip();\n      }, BN.prototype.ishln = function(bits) {\n        return assert(this.negative === 0), this.iushln(bits);\n      }, BN.prototype.iushrn = function(bits, hint, extended) {\n        assert(typeof bits == \"number\" && bits >= 0);\n        var h;\n        hint \? h = (hint - hint % 26) / 26 : h = 0;\n        var r = bits % 26, s = Math.min((bits - r) / 26, this.length), mask = 67108863 ^ 67108863 >>> r << r, maskedWords = extended;\n        if (h -= s, h = Math.max(0, h), maskedWords) {\n          for (var i = 0;i < s; i++)\n            maskedWords.words[i] = this.words[i];\n          maskedWords.length = s;\n        }\n        if (s !== 0)\n          if (this.length > s)\n            for (this.length -= s, i = 0;i < this.length; i++)\n              this.words[i] = this.words[i + s];\n          else\n            this.words[0] = 0, this.length = 1;\n        var carry = 0;\n        for (i = this.length - 1;i >= 0 && (carry !== 0 || i >= h); i--) {\n          var word = this.words[i] | 0;\n          this.words[i] = carry << 26 - r | word >>> r, carry = word & mask;\n        }\n        return maskedWords && carry !== 0 && (maskedWords.words[maskedWords.length++] = carry), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip();\n      }, BN.prototype.ishrn = function(bits, hint, extended) {\n        return assert(this.negative === 0), this.iushrn(bits, hint, extended);\n      }, BN.prototype.shln = function(bits) {\n        return this.clone().ishln(bits);\n      }, BN.prototype.ushln = function(bits) {\n        return this.clone().iushln(bits);\n      }, BN.prototype.shrn = function(bits) {\n        return this.clone().ishrn(bits);\n      }, BN.prototype.ushrn = function(bits) {\n        return this.clone().iushrn(bits);\n      }, BN.prototype.testn = function(bit) {\n        assert(typeof bit == \"number\" && bit >= 0);\n        var r = bit % 26, s = (bit - r) / 26, q = 1 << r;\n        if (this.length <= s)\n          return !1;\n        var w = this.words[s];\n        return !!(w & q);\n      }, BN.prototype.imaskn = function(bits) {\n        assert(typeof bits == \"number\" && bits >= 0);\n        var r = bits % 26, s = (bits - r) / 26;\n        if (assert(this.negative === 0, \"imaskn works only with positive numbers\"), this.length <= s)\n          return this;\n        if (r !== 0 && s++, this.length = Math.min(s, this.length), r !== 0) {\n          var mask = 67108863 ^ 67108863 >>> r << r;\n          this.words[this.length - 1] &= mask;\n        }\n        return this.strip();\n      }, BN.prototype.maskn = function(bits) {\n        return this.clone().imaskn(bits);\n      }, BN.prototype.iaddn = function(num) {\n        return assert(typeof num == \"number\"), assert(num < 67108864), num < 0 \? this.isubn(-num) : this.negative !== 0 \? this.length === 1 && (this.words[0] | 0) < num \? (this.words[0] = num - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(num), this.negative = 1, this) : this._iaddn(num);\n      }, BN.prototype._iaddn = function(num) {\n        this.words[0] += num;\n        for (var i = 0;i < this.length && this.words[i] >= 67108864; i++)\n          this.words[i] -= 67108864, i === this.length - 1 \? this.words[i + 1] = 1 : this.words[i + 1]++;\n        return this.length = Math.max(this.length, i + 1), this;\n      }, BN.prototype.isubn = function(num) {\n        if (assert(typeof num == \"number\"), assert(num < 67108864), num < 0)\n          return this.iaddn(-num);\n        if (this.negative !== 0)\n          return this.negative = 0, this.iaddn(num), this.negative = 1, this;\n        if (this.words[0] -= num, this.length === 1 && this.words[0] < 0)\n          this.words[0] = -this.words[0], this.negative = 1;\n        else\n          for (var i = 0;i < this.length && this.words[i] < 0; i++)\n            this.words[i] += 67108864, this.words[i + 1] -= 1;\n        return this.strip();\n      }, BN.prototype.addn = function(num) {\n        return this.clone().iaddn(num);\n      }, BN.prototype.subn = function(num) {\n        return this.clone().isubn(num);\n      }, BN.prototype.iabs = function() {\n        return this.negative = 0, this;\n      }, BN.prototype.abs = function() {\n        return this.clone().iabs();\n      }, BN.prototype._ishlnsubmul = function(num, mul, shift) {\n        var len = num.length + shift, i;\n        this._expand(len);\n        var w, carry = 0;\n        for (i = 0;i < num.length; i++) {\n          w = (this.words[i + shift] | 0) + carry;\n          var right = (num.words[i] | 0) * mul;\n          w -= right & 67108863, carry = (w >> 26) - (right / 67108864 | 0), this.words[i + shift] = w & 67108863;\n        }\n        for (;i < this.length - shift; i++)\n          w = (this.words[i + shift] | 0) + carry, carry = w >> 26, this.words[i + shift] = w & 67108863;\n        if (carry === 0)\n          return this.strip();\n        for (assert(carry === -1), carry = 0, i = 0;i < this.length; i++)\n          w = -(this.words[i] | 0) + carry, carry = w >> 26, this.words[i] = w & 67108863;\n        return this.negative = 1, this.strip();\n      }, BN.prototype._wordDiv = function(num, mode) {\n        var shift = this.length - num.length, a = this.clone(), b = num, bhi = b.words[b.length - 1] | 0, bhiBits = this._countBits(bhi);\n        shift = 26 - bhiBits, shift !== 0 && (b = b.ushln(shift), a.iushln(shift), bhi = b.words[b.length - 1] | 0);\n        var m = a.length - b.length, q;\n        if (mode !== \"mod\") {\n          q = new BN(null), q.length = m + 1, q.words = new Array(q.length);\n          for (var i = 0;i < q.length; i++)\n            q.words[i] = 0;\n        }\n        var diff = a.clone()._ishlnsubmul(b, 1, m);\n        diff.negative === 0 && (a = diff, q && (q.words[m] = 1));\n        for (var j = m - 1;j >= 0; j--) {\n          var qj = (a.words[b.length + j] | 0) * 67108864 + (a.words[b.length + j - 1] | 0);\n          for (qj = Math.min(qj / bhi | 0, 67108863), a._ishlnsubmul(b, qj, j);a.negative !== 0; )\n            qj--, a.negative = 0, a._ishlnsubmul(b, 1, j), a.isZero() || (a.negative ^= 1);\n          q && (q.words[j] = qj);\n        }\n        return q && q.strip(), a.strip(), mode !== \"div\" && shift !== 0 && a.iushrn(shift), {\n          div: q || null,\n          mod: a\n        };\n      }, BN.prototype.divmod = function(num, mode, positive) {\n        if (assert(!num.isZero()), this.isZero())\n          return {\n            div: new BN(0),\n            mod: new BN(0)\n          };\n        var div, mod, res;\n        return this.negative !== 0 && num.negative === 0 \? (res = this.neg().divmod(num, mode), mode !== \"mod\" && (div = res.div.neg()), mode !== \"div\" && (mod = res.mod.neg(), positive && mod.negative !== 0 && mod.iadd(num)), {\n          div,\n          mod\n        }) : this.negative === 0 && num.negative !== 0 \? (res = this.divmod(num.neg(), mode), mode !== \"mod\" && (div = res.div.neg()), {\n          div,\n          mod: res.mod\n        }) : (this.negative & num.negative) !== 0 \? (res = this.neg().divmod(num.neg(), mode), mode !== \"div\" && (mod = res.mod.neg(), positive && mod.negative !== 0 && mod.isub(num)), {\n          div: res.div,\n          mod\n        }) : num.length > this.length || this.cmp(num) < 0 \? {\n          div: new BN(0),\n          mod: this\n        } : num.length === 1 \? mode === \"div\" \? {\n          div: this.divn(num.words[0]),\n          mod: null\n        } : mode === \"mod\" \? {\n          div: null,\n          mod: new BN(this.modn(num.words[0]))\n        } : {\n          div: this.divn(num.words[0]),\n          mod: new BN(this.modn(num.words[0]))\n        } : this._wordDiv(num, mode);\n      }, BN.prototype.div = function(num) {\n        return this.divmod(num, \"div\", !1).div;\n      }, BN.prototype.mod = function(num) {\n        return this.divmod(num, \"mod\", !1).mod;\n      }, BN.prototype.umod = function(num) {\n        return this.divmod(num, \"mod\", !0).mod;\n      }, BN.prototype.divRound = function(num) {\n        var dm = this.divmod(num);\n        if (dm.mod.isZero())\n          return dm.div;\n        var mod = dm.div.negative !== 0 \? dm.mod.isub(num) : dm.mod, half = num.ushrn(1), r2 = num.andln(1), cmp = mod.cmp(half);\n        return cmp < 0 || r2 === 1 && cmp === 0 \? dm.div : dm.div.negative !== 0 \? dm.div.isubn(1) : dm.div.iaddn(1);\n      }, BN.prototype.modn = function(num) {\n        assert(num <= 67108863);\n        for (var p = (1 << 26) % num, acc = 0, i = this.length - 1;i >= 0; i--)\n          acc = (p * acc + (this.words[i] | 0)) % num;\n        return acc;\n      }, BN.prototype.idivn = function(num) {\n        assert(num <= 67108863);\n        for (var carry = 0, i = this.length - 1;i >= 0; i--) {\n          var w = (this.words[i] | 0) + carry * 67108864;\n          this.words[i] = w / num | 0, carry = w % num;\n        }\n        return this.strip();\n      }, BN.prototype.divn = function(num) {\n        return this.clone().idivn(num);\n      }, BN.prototype.egcd = function(p) {\n        assert(p.negative === 0), assert(!p.isZero());\n        var x = this, y = p.clone();\n        x.negative !== 0 \? x = x.umod(p) : x = x.clone();\n        for (var A = new BN(1), B = new BN(0), C = new BN(0), D = new BN(1), g = 0;x.isEven() && y.isEven(); )\n          x.iushrn(1), y.iushrn(1), ++g;\n        for (var yp = y.clone(), xp = x.clone();!x.isZero(); ) {\n          for (var i = 0, im = 1;(x.words[0] & im) === 0 && i < 26; ++i, im <<= 1)\n            ;\n          if (i > 0)\n            for (x.iushrn(i);i-- > 0; )\n              (A.isOdd() || B.isOdd()) && (A.iadd(yp), B.isub(xp)), A.iushrn(1), B.iushrn(1);\n          for (var j = 0, jm = 1;(y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)\n            ;\n          if (j > 0)\n            for (y.iushrn(j);j-- > 0; )\n              (C.isOdd() || D.isOdd()) && (C.iadd(yp), D.isub(xp)), C.iushrn(1), D.iushrn(1);\n          x.cmp(y) >= 0 \? (x.isub(y), A.isub(C), B.isub(D)) : (y.isub(x), C.isub(A), D.isub(B));\n        }\n        return {\n          a: C,\n          b: D,\n          gcd: y.iushln(g)\n        };\n      }, BN.prototype._invmp = function(p) {\n        assert(p.negative === 0), assert(!p.isZero());\n        var a = this, b = p.clone();\n        a.negative !== 0 \? a = a.umod(p) : a = a.clone();\n        for (var x1 = new BN(1), x2 = new BN(0), delta = b.clone();a.cmpn(1) > 0 && b.cmpn(1) > 0; ) {\n          for (var i = 0, im = 1;(a.words[0] & im) === 0 && i < 26; ++i, im <<= 1)\n            ;\n          if (i > 0)\n            for (a.iushrn(i);i-- > 0; )\n              x1.isOdd() && x1.iadd(delta), x1.iushrn(1);\n          for (var j = 0, jm = 1;(b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)\n            ;\n          if (j > 0)\n            for (b.iushrn(j);j-- > 0; )\n              x2.isOdd() && x2.iadd(delta), x2.iushrn(1);\n          a.cmp(b) >= 0 \? (a.isub(b), x1.isub(x2)) : (b.isub(a), x2.isub(x1));\n        }\n        var res;\n        return a.cmpn(1) === 0 \? res = x1 : res = x2, res.cmpn(0) < 0 && res.iadd(p), res;\n      }, BN.prototype.gcd = function(num) {\n        if (this.isZero())\n          return num.abs();\n        if (num.isZero())\n          return this.abs();\n        var a = this.clone(), b = num.clone();\n        a.negative = 0, b.negative = 0;\n        for (var shift = 0;a.isEven() && b.isEven(); shift++)\n          a.iushrn(1), b.iushrn(1);\n        do {\n          for (;a.isEven(); )\n            a.iushrn(1);\n          for (;b.isEven(); )\n            b.iushrn(1);\n          var r = a.cmp(b);\n          if (r < 0) {\n            var t = a;\n            a = b, b = t;\n          } else if (r === 0 || b.cmpn(1) === 0)\n            break;\n          a.isub(b);\n        } while (!0);\n        return b.iushln(shift);\n      }, BN.prototype.invm = function(num) {\n        return this.egcd(num).a.umod(num);\n      }, BN.prototype.isEven = function() {\n        return (this.words[0] & 1) === 0;\n      }, BN.prototype.isOdd = function() {\n        return (this.words[0] & 1) === 1;\n      }, BN.prototype.andln = function(num) {\n        return this.words[0] & num;\n      }, BN.prototype.bincn = function(bit) {\n        assert(typeof bit == \"number\");\n        var r = bit % 26, s = (bit - r) / 26, q = 1 << r;\n        if (this.length <= s)\n          return this._expand(s + 1), this.words[s] |= q, this;\n        for (var carry = q, i = s;carry !== 0 && i < this.length; i++) {\n          var w = this.words[i] | 0;\n          w += carry, carry = w >>> 26, w &= 67108863, this.words[i] = w;\n        }\n        return carry !== 0 && (this.words[i] = carry, this.length++), this;\n      }, BN.prototype.isZero = function() {\n        return this.length === 1 && this.words[0] === 0;\n      }, BN.prototype.cmpn = function(num) {\n        var negative = num < 0;\n        if (this.negative !== 0 && !negative)\n          return -1;\n        if (this.negative === 0 && negative)\n          return 1;\n        this.strip();\n        var res;\n        if (this.length > 1)\n          res = 1;\n        else {\n          negative && (num = -num), assert(num <= 67108863, \"Number is too big\");\n          var w = this.words[0] | 0;\n          res = w === num \? 0 : w < num \? -1 : 1;\n        }\n        return this.negative !== 0 \? -res | 0 : res;\n      }, BN.prototype.cmp = function(num) {\n        if (this.negative !== 0 && num.negative === 0)\n          return -1;\n        if (this.negative === 0 && num.negative !== 0)\n          return 1;\n        var res = this.ucmp(num);\n        return this.negative !== 0 \? -res | 0 : res;\n      }, BN.prototype.ucmp = function(num) {\n        if (this.length > num.length)\n          return 1;\n        if (this.length < num.length)\n          return -1;\n        for (var res = 0, i = this.length - 1;i >= 0; i--) {\n          var a = this.words[i] | 0, b = num.words[i] | 0;\n          if (a !== b) {\n            a < b \? res = -1 : a > b && (res = 1);\n            break;\n          }\n        }\n        return res;\n      }, BN.prototype.gtn = function(num) {\n        return this.cmpn(num) === 1;\n      }, BN.prototype.gt = function(num) {\n        return this.cmp(num) === 1;\n      }, BN.prototype.gten = function(num) {\n        return this.cmpn(num) >= 0;\n      }, BN.prototype.gte = function(num) {\n        return this.cmp(num) >= 0;\n      }, BN.prototype.ltn = function(num) {\n        return this.cmpn(num) === -1;\n      }, BN.prototype.lt = function(num) {\n        return this.cmp(num) === -1;\n      }, BN.prototype.lten = function(num) {\n        return this.cmpn(num) <= 0;\n      }, BN.prototype.lte = function(num) {\n        return this.cmp(num) <= 0;\n      }, BN.prototype.eqn = function(num) {\n        return this.cmpn(num) === 0;\n      }, BN.prototype.eq = function(num) {\n        return this.cmp(num) === 0;\n      }, BN.red = function(num) {\n        return new Red(num);\n      }, BN.prototype.toRed = function(ctx) {\n        return assert(!this.red, \"Already a number in reduction context\"), assert(this.negative === 0, \"red works only with positives\"), ctx.convertTo(this)._forceRed(ctx);\n      }, BN.prototype.fromRed = function() {\n        return assert(this.red, \"fromRed works only with numbers in reduction context\"), this.red.convertFrom(this);\n      }, BN.prototype._forceRed = function(ctx) {\n        return this.red = ctx, this;\n      }, BN.prototype.forceRed = function(ctx) {\n        return assert(!this.red, \"Already a number in reduction context\"), this._forceRed(ctx);\n      }, BN.prototype.redAdd = function(num) {\n        return assert(this.red, \"redAdd works only with red numbers\"), this.red.add(this, num);\n      }, BN.prototype.redIAdd = function(num) {\n        return assert(this.red, \"redIAdd works only with red numbers\"), this.red.iadd(this, num);\n      }, BN.prototype.redSub = function(num) {\n        return assert(this.red, \"redSub works only with red numbers\"), this.red.sub(this, num);\n      }, BN.prototype.redISub = function(num) {\n        return assert(this.red, \"redISub works only with red numbers\"), this.red.isub(this, num);\n      }, BN.prototype.redShl = function(num) {\n        return assert(this.red, \"redShl works only with red numbers\"), this.red.shl(this, num);\n      }, BN.prototype.redMul = function(num) {\n        return assert(this.red, \"redMul works only with red numbers\"), this.red._verify2(this, num), this.red.mul(this, num);\n      }, BN.prototype.redIMul = function(num) {\n        return assert(this.red, \"redMul works only with red numbers\"), this.red._verify2(this, num), this.red.imul(this, num);\n      }, BN.prototype.redSqr = function() {\n        return assert(this.red, \"redSqr works only with red numbers\"), this.red._verify1(this), this.red.sqr(this);\n      }, BN.prototype.redISqr = function() {\n        return assert(this.red, \"redISqr works only with red numbers\"), this.red._verify1(this), this.red.isqr(this);\n      }, BN.prototype.redSqrt = function() {\n        return assert(this.red, \"redSqrt works only with red numbers\"), this.red._verify1(this), this.red.sqrt(this);\n      }, BN.prototype.redInvm = function() {\n        return assert(this.red, \"redInvm works only with red numbers\"), this.red._verify1(this), this.red.invm(this);\n      }, BN.prototype.redNeg = function() {\n        return assert(this.red, \"redNeg works only with red numbers\"), this.red._verify1(this), this.red.neg(this);\n      }, BN.prototype.redPow = function(num) {\n        return assert(this.red && !num.red, \"redPow(normalNum)\"), this.red._verify1(this), this.red.pow(this, num);\n      };\n      var primes = {\n        k256: null,\n        p224: null,\n        p192: null,\n        p25519: null\n      };\n      function MPrime(name, p) {\n        this.name = name, this.p = new BN(p, 16), this.n = this.p.bitLength(), this.k = new BN(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();\n      }\n      MPrime.prototype = {}, MPrime.prototype._tmp = function() {\n        var tmp = new BN(null);\n        return tmp.words = new Array(Math.ceil(this.n / 13)), tmp;\n      }, MPrime.prototype.ireduce = function(num) {\n        var r = num, rlen;\n        do\n          this.split(r, this.tmp), r = this.imulK(r), r = r.iadd(this.tmp), rlen = r.bitLength();\n        while (rlen > this.n);\n        var cmp = rlen < this.n \? -1 : r.ucmp(this.p);\n        return cmp === 0 \? (r.words[0] = 0, r.length = 1) : cmp > 0 \? r.isub(this.p) : r.strip !== void 0 \? r.strip() : r._strip(), r;\n      }, MPrime.prototype.split = function(input, out) {\n        input.iushrn(this.n, 0, out);\n      }, MPrime.prototype.imulK = function(num) {\n        return num.imul(this.k);\n      };\n      function K256() {\n        MPrime.call(this, \"k256\", \"ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f\");\n      }\n      inherits(K256, MPrime), K256.prototype.split = function(input, output) {\n        for (var mask = 4194303, outLen = Math.min(input.length, 9), i = 0;i < outLen; i++)\n          output.words[i] = input.words[i];\n        if (output.length = outLen, input.length <= 9) {\n          input.words[0] = 0, input.length = 1;\n          return;\n        }\n        var prev = input.words[9];\n        for (output.words[output.length++] = prev & mask, i = 10;i < input.length; i++) {\n          var next = input.words[i] | 0;\n          input.words[i - 10] = (next & mask) << 4 | prev >>> 22, prev = next;\n        }\n        prev >>>= 22, input.words[i - 10] = prev, prev === 0 && input.length > 10 \? input.length -= 10 : input.length -= 9;\n      }, K256.prototype.imulK = function(num) {\n        num.words[num.length] = 0, num.words[num.length + 1] = 0, num.length += 2;\n        for (var lo = 0, i = 0;i < num.length; i++) {\n          var w = num.words[i] | 0;\n          lo += w * 977, num.words[i] = lo & 67108863, lo = w * 64 + (lo / 67108864 | 0);\n        }\n        return num.words[num.length - 1] === 0 && (num.length--, num.words[num.length - 1] === 0 && num.length--), num;\n      };\n      function P224() {\n        MPrime.call(this, \"p224\", \"ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001\");\n      }\n      inherits(P224, MPrime);\n      function P192() {\n        MPrime.call(this, \"p192\", \"ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff\");\n      }\n      inherits(P192, MPrime);\n      function P25519() {\n        MPrime.call(this, \"25519\", \"7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed\");\n      }\n      inherits(P25519, MPrime), P25519.prototype.imulK = function(num) {\n        for (var carry = 0, i = 0;i < num.length; i++) {\n          var hi = (num.words[i] | 0) * 19 + carry, lo = hi & 67108863;\n          hi >>>= 26, num.words[i] = lo, carry = hi;\n        }\n        return carry !== 0 && (num.words[num.length++] = carry), num;\n      }, BN._prime = function(name) {\n        if (primes[name])\n          return primes[name];\n        var prime2;\n        if (name === \"k256\")\n          prime2 = new K256;\n        else if (name === \"p224\")\n          prime2 = new P224;\n        else if (name === \"p192\")\n          prime2 = new P192;\n        else if (name === \"p25519\")\n          prime2 = new P25519;\n        else\n          throw new Error(\"Unknown prime \" + name);\n        return primes[name] = prime2, prime2;\n      };\n      function Red(m) {\n        if (typeof m == \"string\") {\n          var prime = BN._prime(m);\n          this.m = prime.p, this.prime = prime;\n        } else\n          assert(m.gtn(1), \"modulus must be greater than 1\"), this.m = m, this.prime = null;\n      }\n      Red.prototype = {}, Red.prototype._verify1 = function(a) {\n        assert(a.negative === 0, \"red works only with positives\"), assert(a.red, \"red works only with red numbers\");\n      }, Red.prototype._verify2 = function(a, b) {\n        assert((a.negative | b.negative) === 0, \"red works only with positives\"), assert(a.red && a.red === b.red, \"red works only with red numbers\");\n      }, Red.prototype.imod = function(a) {\n        return this.prime \? this.prime.ireduce(a)._forceRed(this) : a.umod(this.m)._forceRed(this);\n      }, Red.prototype.neg = function(a) {\n        return a.isZero() \? a.clone() : this.m.sub(a)._forceRed(this);\n      }, Red.prototype.add = function(a, b) {\n        this._verify2(a, b);\n        var res = a.add(b);\n        return res.cmp(this.m) >= 0 && res.isub(this.m), res._forceRed(this);\n      }, Red.prototype.iadd = function(a, b) {\n        this._verify2(a, b);\n        var res = a.iadd(b);\n        return res.cmp(this.m) >= 0 && res.isub(this.m), res;\n      }, Red.prototype.sub = function(a, b) {\n        this._verify2(a, b);\n        var res = a.sub(b);\n        return res.cmpn(0) < 0 && res.iadd(this.m), res._forceRed(this);\n      }, Red.prototype.isub = function(a, b) {\n        this._verify2(a, b);\n        var res = a.isub(b);\n        return res.cmpn(0) < 0 && res.iadd(this.m), res;\n      }, Red.prototype.shl = function(a, num) {\n        return this._verify1(a), this.imod(a.ushln(num));\n      }, Red.prototype.imul = function(a, b) {\n        return this._verify2(a, b), this.imod(a.imul(b));\n      }, Red.prototype.mul = function(a, b) {\n        return this._verify2(a, b), this.imod(a.mul(b));\n      }, Red.prototype.isqr = function(a) {\n        return this.imul(a, a.clone());\n      }, Red.prototype.sqr = function(a) {\n        return this.mul(a, a);\n      }, Red.prototype.sqrt = function(a) {\n        if (a.isZero())\n          return a.clone();\n        var mod3 = this.m.andln(3);\n        if (assert(mod3 % 2 === 1), mod3 === 3) {\n          var pow = this.m.add(new BN(1)).iushrn(2);\n          return this.pow(a, pow);\n        }\n        for (var q = this.m.subn(1), s = 0;!q.isZero() && q.andln(1) === 0; )\n          s++, q.iushrn(1);\n        assert(!q.isZero());\n        var one = new BN(1).toRed(this), nOne = one.redNeg(), lpow = this.m.subn(1).iushrn(1), z = this.m.bitLength();\n        for (z = new BN(2 * z * z).toRed(this);this.pow(z, lpow).cmp(nOne) !== 0; )\n          z.redIAdd(nOne);\n        for (var c = this.pow(z, q), r = this.pow(a, q.addn(1).iushrn(1)), t = this.pow(a, q), m = s;t.cmp(one) !== 0; ) {\n          for (var tmp = t, i = 0;tmp.cmp(one) !== 0; i++)\n            tmp = tmp.redSqr();\n          assert(i < m);\n          var b = this.pow(c, new BN(1).iushln(m - i - 1));\n          r = r.redMul(b), c = b.redSqr(), t = t.redMul(c), m = i;\n        }\n        return r;\n      }, Red.prototype.invm = function(a) {\n        var inv = a._invmp(this.m);\n        return inv.negative !== 0 \? (inv.negative = 0, this.imod(inv).redNeg()) : this.imod(inv);\n      }, Red.prototype.pow = function(a, num) {\n        if (num.isZero())\n          return new BN(1).toRed(this);\n        if (num.cmpn(1) === 0)\n          return a.clone();\n        var windowSize = 4, wnd = new Array(1 << windowSize);\n        wnd[0] = new BN(1).toRed(this), wnd[1] = a;\n        for (var i = 2;i < wnd.length; i++)\n          wnd[i] = this.mul(wnd[i - 1], a);\n        var res = wnd[0], current = 0, currentLen = 0, start = num.bitLength() % 26;\n        for (start === 0 && (start = 26), i = num.length - 1;i >= 0; i--) {\n          for (var word = num.words[i], j = start - 1;j >= 0; j--) {\n            var bit = word >> j & 1;\n            if (res !== wnd[0] && (res = this.sqr(res)), bit === 0 && current === 0) {\n              currentLen = 0;\n              continue;\n            }\n            current <<= 1, current |= bit, currentLen++, !(currentLen !== windowSize && (i !== 0 || j !== 0)) && (res = this.mul(res, wnd[current]), currentLen = 0, current = 0);\n          }\n          start = 26;\n        }\n        return res;\n      }, Red.prototype.convertTo = function(num) {\n        var r = num.umod(this.m);\n        return r === num \? r.clone() : r;\n      }, Red.prototype.convertFrom = function(num) {\n        var res = num.clone();\n        return res.red = null, res;\n      }, BN.mont = function(num) {\n        return new Mont(num);\n      };\n      function Mont(m) {\n        Red.call(this, m), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new BN(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);\n      }\n      inherits(Mont, Red), Mont.prototype.convertTo = function(num) {\n        return this.imod(num.ushln(this.shift));\n      }, Mont.prototype.convertFrom = function(num) {\n        var r = this.imod(num.mul(this.rinv));\n        return r.red = null, r;\n      }, Mont.prototype.imul = function(a, b) {\n        if (a.isZero() || b.isZero())\n          return a.words[0] = 0, a.length = 1, a;\n        var t = a.imul(b), c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), u = t.isub(c).iushrn(this.shift), res = u;\n        return u.cmp(this.m) >= 0 \? res = u.isub(this.m) : u.cmpn(0) < 0 && (res = u.iadd(this.m)), res._forceRed(this);\n      }, Mont.prototype.mul = function(a, b) {\n        if (a.isZero() || b.isZero())\n          return new BN(0)._forceRed(this);\n        var t = a.mul(b), c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), u = t.isub(c).iushrn(this.shift), res = u;\n        return u.cmp(this.m) >= 0 \? res = u.isub(this.m) : u.cmpn(0) < 0 && (res = u.iadd(this.m)), res._forceRed(this);\n      }, Mont.prototype.invm = function(a) {\n        var res = this.imod(a._invmp(this.m).mul(this.r2));\n        return res._forceRed(this);\n      };\n    })(typeof module > \"u\" || module, exports);\n  }\n}), require_bn2 = require_bn, require_brorand = __commonJS({\n  \"node_modules/brorand/index.js\"(exports, module) {\n    var r;\n    module.exports = function(len) {\n      return r || (r = new Rand(null)), r.generate(len);\n    };\n    function Rand(rand) {\n      this.rand = rand;\n    }\n    Rand.prototype = {}, module.exports.Rand = Rand, Rand.prototype.generate = function(len) {\n      return this._rand(len);\n    }, Rand.prototype._rand = function(n) {\n      var out = new Buffer(n);\n      return crypto.getRandomValues(out), out;\n    };\n  }\n}), require_mr = __commonJS({\n  \"node_modules/miller-rabin/lib/mr.js\"(exports, module) {\n    var bn = require_bn2(), brorand = require_brorand();\n    function MillerRabin(rand) {\n      this.rand = rand || new brorand.Rand;\n    }\n    module.exports = MillerRabin, MillerRabin.create = function(rand) {\n      return new MillerRabin(rand);\n    }, MillerRabin.prototype = {}, MillerRabin.prototype._randbelow = function(n) {\n      var len = n.bitLength(), min_bytes = Math.ceil(len / 8);\n      do\n        var a = new bn(this.rand.generate(min_bytes));\n      while (a.cmp(n) >= 0);\n      return a;\n    }, MillerRabin.prototype._randrange = function(start, stop) {\n      var size = stop.sub(start);\n      return start.add(this._randbelow(size));\n    }, MillerRabin.prototype.test = function(n, k, cb) {\n      var len = n.bitLength(), red = bn.mont(n), rone = new bn(1).toRed(red);\n      k || (k = Math.max(1, len / 48 | 0));\n      for (var n1 = n.subn(1), s = 0;!n1.testn(s); s++)\n        ;\n      for (var d = n.shrn(s), rn1 = n1.toRed(red), prime = !0;k > 0; k--) {\n        var a = this._randrange(new bn(2), n1);\n        cb && cb(a);\n        var x = a.toRed(red).redPow(d);\n        if (!(x.cmp(rone) === 0 || x.cmp(rn1) === 0)) {\n          for (var i = 1;i < s; i++) {\n            if (x = x.redSqr(), x.cmp(rone) === 0)\n              return !1;\n            if (x.cmp(rn1) === 0)\n              break;\n          }\n          if (i === s)\n            return !1;\n        }\n      }\n      return prime;\n    }, MillerRabin.prototype.getDivisor = function(n, k) {\n      var len = n.bitLength(), red = bn.mont(n), rone = new bn(1).toRed(red);\n      k || (k = Math.max(1, len / 48 | 0));\n      for (var n1 = n.subn(1), s = 0;!n1.testn(s); s++)\n        ;\n      for (var d = n.shrn(s), rn1 = n1.toRed(red);k > 0; k--) {\n        var a = this._randrange(new bn(2), n1), g = n.gcd(a);\n        if (g.cmpn(1) !== 0)\n          return g;\n        var x = a.toRed(red).redPow(d);\n        if (!(x.cmp(rone) === 0 || x.cmp(rn1) === 0)) {\n          for (var i = 1;i < s; i++) {\n            if (x = x.redSqr(), x.cmp(rone) === 0)\n              return x.fromRed().subn(1).gcd(n);\n            if (x.cmp(rn1) === 0)\n              break;\n          }\n          if (i === s)\n            return x = x.redSqr(), x.fromRed().subn(1).gcd(n);\n        }\n      }\n      return !1;\n    };\n  }\n}), require_generatePrime = __commonJS({\n  \"node_modules/diffie-hellman/lib/generatePrime.js\"(exports, module) {\n    var randomBytes = require_browser();\n    module.exports = findPrime, findPrime.simpleSieve = simpleSieve, findPrime.fermatTest = fermatTest;\n    var BN = require_bn(), TWENTYFOUR = new BN(24), MillerRabin = require_mr(), millerRabin = new MillerRabin, ONE = new BN(1), TWO = new BN(2), FIVE = new BN(5), SIXTEEN = new BN(16), EIGHT = new BN(8), TEN = new BN(10), THREE = new BN(3), SEVEN = new BN(7), ELEVEN = new BN(11), FOUR = new BN(4), TWELVE = new BN(12), primes = null;\n    function _getPrimes() {\n      if (primes !== null)\n        return primes;\n      var limit = 1048576, res = [];\n      res[0] = 2;\n      for (var i = 1, k = 3;k < limit; k += 2) {\n        for (var sqrt = Math.ceil(Math.sqrt(k)), j = 0;j < i && res[j] <= sqrt && k % res[j] !== 0; j++)\n          ;\n        i !== j && res[j] <= sqrt || (res[i++] = k);\n      }\n      return primes = res, res;\n    }\n    function simpleSieve(p) {\n      for (var primes2 = _getPrimes(), i = 0;i < primes2.length; i++)\n        if (p.modn(primes2[i]) === 0)\n          return p.cmpn(primes2[i]) === 0;\n      return !0;\n    }\n    function fermatTest(p) {\n      var red = BN.mont(p);\n      return TWO.toRed(red).redPow(p.subn(1)).fromRed().cmpn(1) === 0;\n    }\n    function findPrime(bits, gen) {\n      if (bits < 16)\n        return gen === 2 || gen === 5 \? new BN([140, 123]) : new BN([140, 39]);\n      gen = new BN(gen);\n      for (var num, n2;; ) {\n        for (num = new BN(randomBytes(Math.ceil(bits / 8)));num.bitLength() > bits; )\n          num.ishrn(1);\n        if (num.isEven() && num.iadd(ONE), num.testn(1) || num.iadd(TWO), gen.cmp(TWO)) {\n          if (!gen.cmp(FIVE))\n            for (;num.mod(TEN).cmp(THREE); )\n              num.iadd(FOUR);\n        } else\n          for (;num.mod(TWENTYFOUR).cmp(ELEVEN); )\n            num.iadd(FOUR);\n        if (n2 = num.shrn(1), simpleSieve(n2) && simpleSieve(num) && fermatTest(n2) && fermatTest(num) && millerRabin.test(n2) && millerRabin.test(num))\n          return num;\n      }\n    }\n  }\n}), require_primes = __commonJS({\n  \"node_modules/diffie-hellman/lib/primes.json\"(exports, module) {\n    module.exports = {\n      modp1: {\n        gen: \"02\",\n        prime: \"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a63a3620ffffffffffffffff\"\n      },\n      modp2: {\n        gen: \"02\",\n        prime: \"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece65381ffffffffffffffff\"\n      },\n      modp5: {\n        gen: \"02\",\n        prime: \"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca237327ffffffffffffffff\"\n      },\n      modp14: {\n        gen: \"02\",\n        prime: \"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aacaa68ffffffffffffffff\"\n      },\n      modp15: {\n        gen: \"02\",\n        prime: \"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a93ad2caffffffffffffffff\"\n      },\n      modp16: {\n        gen: \"02\",\n        prime: \"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c934063199ffffffffffffffff\"\n      },\n      modp17: {\n        gen: \"02\",\n        prime: \"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dcc4024ffffffffffffffff\"\n      },\n      modp18: {\n        gen: \"02\",\n        prime: \"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dbe115974a3926f12fee5e438777cb6a932df8cd8bec4d073b931ba3bc832b68d9dd300741fa7bf8afc47ed2576f6936ba424663aab639c5ae4f5683423b4742bf1c978238f16cbe39d652de3fdb8befc848ad922222e04a4037c0713eb57a81a23f0c73473fc646cea306b4bcbc8862f8385ddfa9d4b7fa2c087e879683303ed5bdd3a062b3cf5b3a278a66d2a13f83f44f82ddf310ee074ab6a364597e899a0255dc164f31cc50846851df9ab48195ded7ea1b1d510bd7ee74d73faf36bc31ecfa268359046f4eb879f924009438b481c6cd7889a002ed5ee382bc9190da6fc026e479558e4475677e9aa9e3050e2765694dfc81f56e880b96e7160c980dd98edd3dfffffffffffffffff\"\n      }\n    };\n  }\n}), require_dh = __commonJS({\n  \"node_modules/diffie-hellman/lib/dh.js\"(exports, module) {\n    var BN = require_bn(), MillerRabin = require_mr(), millerRabin = new MillerRabin, TWENTYFOUR = new BN(24), ELEVEN = new BN(11), TEN = new BN(10), THREE = new BN(3), SEVEN = new BN(7), primes = require_generatePrime(), randomBytes = require_browser();\n    module.exports = DH;\n    function setPublicKey(pub, enc) {\n      return enc = enc || \"utf8\", Buffer.isBuffer(pub) || (pub = new Buffer(pub, enc)), this._pub = new BN(pub), this;\n    }\n    function setPrivateKey(priv, enc) {\n      return enc = enc || \"utf8\", Buffer.isBuffer(priv) || (priv = new Buffer(priv, enc)), this._priv = new BN(priv), this;\n    }\n    var primeCache = {};\n    function checkPrime(prime, generator) {\n      var gen = generator.toString(\"hex\"), hex = [gen, prime.toString(16)].join(\"_\");\n      if (hex in primeCache)\n        return primeCache[hex];\n      var error = 0;\n      if (prime.isEven() || !primes.simpleSieve || !primes.fermatTest(prime) || !millerRabin.test(prime))\n        return error += 1, gen === \"02\" || gen === \"05\" \? error += 8 : error += 4, primeCache[hex] = error, error;\n      millerRabin.test(prime.shrn(1)) || (error += 2);\n      var rem;\n      switch (gen) {\n        case \"02\":\n          prime.mod(TWENTYFOUR).cmp(ELEVEN) && (error += 8);\n          break;\n        case \"05\":\n          rem = prime.mod(TEN), rem.cmp(THREE) && rem.cmp(SEVEN) && (error += 8);\n          break;\n        default:\n          error += 4;\n      }\n      return primeCache[hex] = error, error;\n    }\n    function DH(prime, generator, malleable) {\n      this.setGenerator(generator), this.__prime = new BN(prime), this._prime = BN.mont(this.__prime), this._primeLen = prime.length, this._pub = void 0, this._priv = void 0, this._primeCode = void 0, malleable \? (this.setPublicKey = setPublicKey, this.setPrivateKey = setPrivateKey) : this._primeCode = 8;\n    }\n    DH.prototype = {}, Object.defineProperty(DH.prototype, \"verifyError\", {\n      enumerable: !0,\n      get: function() {\n        return typeof this._primeCode != \"number\" && (this._primeCode = checkPrime(this.__prime, this.__gen)), this._primeCode;\n      }\n    }), DH.prototype.generateKeys = function() {\n      return this._priv || (this._priv = new BN(randomBytes(this._primeLen))), this._pub = this._gen.toRed(this._prime).redPow(this._priv).fromRed(), this.getPublicKey();\n    }, DH.prototype.computeSecret = function(other) {\n      other = new BN(other), other = other.toRed(this._prime);\n      var secret = other.redPow(this._priv).fromRed(), out = new Buffer(secret.toArray()), prime = this.getPrime();\n      if (out.length < prime.length) {\n        var front = new Buffer(prime.length - out.length);\n        front.fill(0), out = Buffer.concat([front, out]);\n      }\n      return out;\n    }, DH.prototype.getPublicKey = function(enc) {\n      return formatReturnValue(this._pub, enc);\n    }, DH.prototype.getPrivateKey = function(enc) {\n      return formatReturnValue(this._priv, enc);\n    }, DH.prototype.getPrime = function(enc) {\n      return formatReturnValue(this.__prime, enc);\n    }, DH.prototype.getGenerator = function(enc) {\n      return formatReturnValue(this._gen, enc);\n    }, DH.prototype.setGenerator = function(gen, enc) {\n      return enc = enc || \"utf8\", Buffer.isBuffer(gen) || (gen = new Buffer(gen, enc)), this.__gen = gen, this._gen = new BN(gen), this;\n    };\n    function formatReturnValue(bn, enc) {\n      var buf = new Buffer(bn.toArray());\n      return enc \? buf.toString(enc) : buf;\n    }\n  }\n}), require_browser7 = __commonJS({\n  \"node_modules/diffie-hellman/browser.js\"(exports) {\n    var generatePrime = require_generatePrime(), primes = require_primes(), DH = require_dh();\n    function getDiffieHellman(mod) {\n      var prime = new Buffer(primes[mod].prime, \"hex\"), gen = new Buffer(primes[mod].gen, \"hex\");\n      return new DH(prime, gen);\n    }\n    var ENCODINGS = {\n      binary: !0,\n      hex: !0,\n      base64: !0\n    };\n    function createDiffieHellman(prime, enc, generator, genc) {\n      return Buffer.isBuffer(enc) || ENCODINGS[enc] === void 0 \? createDiffieHellman(prime, \"binary\", enc, generator) : (enc = enc || \"binary\", genc = genc || \"binary\", generator = generator || new Buffer([2]), Buffer.isBuffer(generator) || (generator = new Buffer(generator, genc)), typeof prime == \"number\" \? new DH(generatePrime(prime, generator), generator, !0) : (Buffer.isBuffer(prime) || (prime = new Buffer(prime, enc)), new DH(prime, generator, !0)));\n    }\n    exports.DiffieHellmanGroup = exports.createDiffieHellmanGroup = exports.getDiffieHellman = getDiffieHellman, exports.createDiffieHellman = exports.DiffieHellman = createDiffieHellman;\n  }\n}), require_bn3 = require_bn, require_browserify_rsa = __commonJS({\n  \"node_modules/browserify-rsa/index.js\"(exports, module) {\n    var BN = require_bn3(), randomBytes = require_browser();\n    function blind(priv) {\n      var r = getr(priv), blinder = r.toRed(BN.mont(priv.modulus)).redPow(new BN(priv.publicExponent)).fromRed();\n      return { blinder, unblinder: r.invm(priv.modulus) };\n    }\n    function getr(priv) {\n      var len = priv.modulus.byteLength(), r;\n      do\n        r = new BN(randomBytes(len));\n      while (r.cmp(priv.modulus) >= 0 || !r.umod(priv.prime1) || !r.umod(priv.prime2));\n      return r;\n    }\n    function crt(msg, priv) {\n      var blinds = blind(priv), len = priv.modulus.byteLength(), blinded = new BN(msg).mul(blinds.blinder).umod(priv.modulus), c1 = blinded.toRed(BN.mont(priv.prime1)), c2 = blinded.toRed(BN.mont(priv.prime2)), qinv = priv.coefficient, p = priv.prime1, q = priv.prime2, m1 = c1.redPow(priv.exponent1).fromRed(), m2 = c2.redPow(priv.exponent2).fromRed(), h = m1.isub(m2).imul(qinv).umod(p).imul(q);\n      return m2.iadd(h).imul(blinds.unblinder).umod(priv.modulus).toArrayLike(Buffer, \"be\", len);\n    }\n    crt.getr = getr, module.exports = crt;\n  }\n}), require_package = __commonJS({\n  \"node_modules/elliptic/package.json\"(exports, module) {\n    module.exports = {\n      name: \"elliptic\",\n      version: \"6.5.4\",\n      description: \"EC cryptography\",\n      main: \"lib/elliptic.js\",\n      files: [\"lib\"],\n      scripts: {\n        lint: \"eslint lib test\",\n        \"lint:fix\": \"npm run lint -- --fix\",\n        unit: \"istanbul test _mocha --reporter=spec test/index.js\",\n        test: \"npm run lint && npm run unit\",\n        version: \"grunt dist && git add dist/\"\n      },\n      repository: {\n        type: \"git\",\n        url: \"git@github.com:indutny/elliptic\"\n      },\n      keywords: [\"EC\", \"Elliptic\", \"curve\", \"Cryptography\"],\n      author: \"Fedor Indutny <fedor@indutny.com>\",\n      license: \"MIT\",\n      bugs: {\n        url: \"https://github.com/indutny/elliptic/issues\"\n      },\n      homepage: \"https://github.com/indutny/elliptic\",\n      devDependencies: {\n        brfs: \"^2.0.2\",\n        coveralls: \"^3.1.0\",\n        eslint: \"^7.6.0\",\n        grunt: \"^1.2.1\",\n        \"grunt-browserify\": \"^5.3.0\",\n        \"grunt-cli\": \"^1.3.2\",\n        \"grunt-contrib-connect\": \"^3.0.0\",\n        \"grunt-contrib-copy\": \"^1.0.0\",\n        \"grunt-contrib-uglify\": \"^5.0.0\",\n        \"grunt-mocha-istanbul\": \"^5.0.2\",\n        \"grunt-saucelabs\": \"^9.0.1\",\n        istanbul: \"^0.4.5\",\n        mocha: \"^8.0.1\"\n      },\n      dependencies: {\n        \"bn.js\": \"^4.11.9\",\n        brorand: \"^1.1.0\",\n        \"hash.js\": \"^1.0.0\",\n        \"hmac-drbg\": \"^1.0.1\",\n        inherits: \"^2.0.4\",\n        \"minimalistic-assert\": \"^1.0.1\",\n        \"minimalistic-crypto-utils\": \"^1.0.1\"\n      }\n    };\n  }\n}), require_bn4 = require_bn, require_utils2 = __commonJS({\n  \"node_modules/minimalistic-crypto-utils/lib/utils.js\"(exports) {\n    var utils = exports;\n    function toArray(msg, enc) {\n      if (Array.isArray(msg))\n        return msg.slice();\n      if (!msg)\n        return [];\n      var res = [];\n      if (typeof msg != \"string\") {\n        for (var i = 0;i < msg.length; i++)\n          res[i] = msg[i] | 0;\n        return res;\n      }\n      if (enc === \"hex\") {\n        msg = msg.replace(/[^a-z0-9]+/gi, \"\"), msg.length % 2 !== 0 && (msg = \"0\" + msg);\n        for (var i = 0;i < msg.length; i += 2)\n          res.push(parseInt(msg[i] + msg[i + 1], 16));\n      } else\n        for (var i = 0;i < msg.length; i++) {\n          var c = msg.charCodeAt(i), hi = c >> 8, lo = c & 255;\n          hi \? res.push(hi, lo) : res.push(lo);\n        }\n      return res;\n    }\n    utils.toArray = toArray;\n    function zero2(word) {\n      return word.length === 1 \? \"0\" + word : word;\n    }\n    utils.zero2 = zero2;\n    function toHex(msg) {\n      for (var res = \"\", i = 0;i < msg.length; i++)\n        res += zero2(msg[i].toString(16));\n      return res;\n    }\n    utils.toHex = toHex, utils.encode = function(arr, enc) {\n      return enc === \"hex\" \? toHex(arr) : arr;\n    };\n  }\n}), require_utils3 = __commonJS({\n  \"node_modules/elliptic/lib/elliptic/utils.js\"(exports) {\n    var utils = exports, BN = require_bn4(), minAssert = require_minimalistic_assert(), minUtils = require_utils2();\n    utils.assert = minAssert, utils.toArray = minUtils.toArray, utils.zero2 = minUtils.zero2, utils.toHex = minUtils.toHex, utils.encode = minUtils.encode;\n    function getNAF(num, w, bits) {\n      var naf = new Array(Math.max(num.bitLength(), bits) + 1);\n      naf.fill(0);\n      for (var ws = 1 << w + 1, k = num.clone(), i = 0;i < naf.length; i++) {\n        var z, mod = k.andln(ws - 1);\n        k.isOdd() \? (mod > (ws >> 1) - 1 \? z = (ws >> 1) - mod : z = mod, k.isubn(z)) : z = 0, naf[i] = z, k.iushrn(1);\n      }\n      return naf;\n    }\n    utils.getNAF = getNAF;\n    function getJSF(k1, k2) {\n      var jsf = [[], []];\n      k1 = k1.clone(), k2 = k2.clone();\n      for (var d1 = 0, d2 = 0, m8;k1.cmpn(-d1) > 0 || k2.cmpn(-d2) > 0; ) {\n        var m14 = k1.andln(3) + d1 & 3, m24 = k2.andln(3) + d2 & 3;\n        m14 === 3 && (m14 = -1), m24 === 3 && (m24 = -1);\n        var u1;\n        (m14 & 1) === 0 \? u1 = 0 : (m8 = k1.andln(7) + d1 & 7, (m8 === 3 || m8 === 5) && m24 === 2 \? u1 = -m14 : u1 = m14), jsf[0].push(u1);\n        var u2;\n        (m24 & 1) === 0 \? u2 = 0 : (m8 = k2.andln(7) + d2 & 7, (m8 === 3 || m8 === 5) && m14 === 2 \? u2 = -m24 : u2 = m24), jsf[1].push(u2), 2 * d1 === u1 + 1 && (d1 = 1 - d1), 2 * d2 === u2 + 1 && (d2 = 1 - d2), k1.iushrn(1), k2.iushrn(1);\n      }\n      return jsf;\n    }\n    utils.getJSF = getJSF;\n    function cachedProperty(obj, name, computer) {\n      var key = \"_\" + name;\n      obj.prototype[name] = function() {\n        return this[key] !== void 0 \? this[key] : this[key] = computer.call(this);\n      };\n    }\n    utils.cachedProperty = cachedProperty;\n    function parseBytes(bytes) {\n      return typeof bytes == \"string\" \? utils.toArray(bytes, \"hex\") : bytes;\n    }\n    utils.parseBytes = parseBytes;\n    function intFromLE(bytes) {\n      return new BN(bytes, \"hex\", \"le\");\n    }\n    utils.intFromLE = intFromLE;\n  }\n}), require_base = __commonJS({\n  \"node_modules/elliptic/lib/elliptic/curve/base.js\"(exports, module) {\n    var BN = require_bn4(), utils = require_utils3(), getNAF = utils.getNAF, getJSF = utils.getJSF, assert = utils.assert;\n    function BaseCurve(type, conf) {\n      this.type = type, this.p = new BN(conf.p, 16), this.red = conf.prime \? BN.red(conf.prime) : BN.mont(this.p), this.zero = new BN(0).toRed(this.red), this.one = new BN(1).toRed(this.red), this.two = new BN(2).toRed(this.red), this.n = conf.n && new BN(conf.n, 16), this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed), this._wnafT1 = new Array(4), this._wnafT2 = new Array(4), this._wnafT3 = new Array(4), this._wnafT4 = new Array(4), this._bitLength = this.n \? this.n.bitLength() : 0;\n      var adjustCount = this.n && this.p.div(this.n);\n      !adjustCount || adjustCount.cmpn(100) > 0 \? this.redN = null : (this._maxwellTrick = !0, this.redN = this.n.toRed(this.red));\n    }\n    module.exports = BaseCurve, BaseCurve.prototype = {}, BaseCurve.prototype.point = function() {\n      throw new Error(\"Not implemented\");\n    }, BaseCurve.prototype.validate = function() {\n      throw new Error(\"Not implemented\");\n    }, BaseCurve.prototype._fixedNafMul = function(p, k) {\n      assert(p.precomputed);\n      var doubles = p._getDoubles(), naf = getNAF(k, 1, this._bitLength), I = (1 << doubles.step + 1) - (doubles.step % 2 === 0 \? 2 : 1);\n      I /= 3;\n      var repr = [], j, nafW;\n      for (j = 0;j < naf.length; j += doubles.step) {\n        nafW = 0;\n        for (var l = j + doubles.step - 1;l >= j; l--)\n          nafW = (nafW << 1) + naf[l];\n        repr.push(nafW);\n      }\n      for (var a = this.jpoint(null, null, null), b = this.jpoint(null, null, null), i = I;i > 0; i--) {\n        for (j = 0;j < repr.length; j++)\n          nafW = repr[j], nafW === i \? b = b.mixedAdd(doubles.points[j]) : nafW === -i && (b = b.mixedAdd(doubles.points[j].neg()));\n        a = a.add(b);\n      }\n      return a.toP();\n    }, BaseCurve.prototype._wnafMul = function(p, k) {\n      var w = 4, nafPoints = p._getNAFPoints(w);\n      w = nafPoints.wnd;\n      for (var wnd = nafPoints.points, naf = getNAF(k, w, this._bitLength), acc = this.jpoint(null, null, null), i = naf.length - 1;i >= 0; i--) {\n        for (var l = 0;i >= 0 && naf[i] === 0; i--)\n          l++;\n        if (i >= 0 && l++, acc = acc.dblp(l), i < 0)\n          break;\n        var z = naf[i];\n        assert(z !== 0), p.type === \"affine\" \? z > 0 \? acc = acc.mixedAdd(wnd[z - 1 >> 1]) : acc = acc.mixedAdd(wnd[-z - 1 >> 1].neg()) : z > 0 \? acc = acc.add(wnd[z - 1 >> 1]) : acc = acc.add(wnd[-z - 1 >> 1].neg());\n      }\n      return p.type === \"affine\" \? acc.toP() : acc;\n    }, BaseCurve.prototype._wnafMulAdd = function(defW, points, coeffs, len, jacobianResult) {\n      var wndWidth = this._wnafT1, wnd = this._wnafT2, naf = this._wnafT3, max = 0, i, j, p;\n      for (i = 0;i < len; i++) {\n        p = points[i];\n        var nafPoints = p._getNAFPoints(defW);\n        wndWidth[i] = nafPoints.wnd, wnd[i] = nafPoints.points;\n      }\n      for (i = len - 1;i >= 1; i -= 2) {\n        var a = i - 1, b = i;\n        if (wndWidth[a] !== 1 || wndWidth[b] !== 1) {\n          naf[a] = getNAF(coeffs[a], wndWidth[a], this._bitLength), naf[b] = getNAF(coeffs[b], wndWidth[b], this._bitLength), max = Math.max(naf[a].length, max), max = Math.max(naf[b].length, max);\n          continue;\n        }\n        var comb = [points[a], null, null, points[b]];\n        points[a].y.cmp(points[b].y) === 0 \? (comb[1] = points[a].add(points[b]), comb[2] = points[a].toJ().mixedAdd(points[b].neg())) : points[a].y.cmp(points[b].y.redNeg()) === 0 \? (comb[1] = points[a].toJ().mixedAdd(points[b]), comb[2] = points[a].add(points[b].neg())) : (comb[1] = points[a].toJ().mixedAdd(points[b]), comb[2] = points[a].toJ().mixedAdd(points[b].neg()));\n        var index = [-3, -1, -5, -7, 0, 7, 5, 1, 3], jsf = getJSF(coeffs[a], coeffs[b]);\n        for (max = Math.max(jsf[0].length, max), naf[a] = new Array(max), naf[b] = new Array(max), j = 0;j < max; j++) {\n          var ja = jsf[0][j] | 0, jb = jsf[1][j] | 0;\n          naf[a][j] = index[(ja + 1) * 3 + (jb + 1)], naf[b][j] = 0, wnd[a] = comb;\n        }\n      }\n      var acc = this.jpoint(null, null, null), tmp = this._wnafT4;\n      for (i = max;i >= 0; i--) {\n        for (var k = 0;i >= 0; ) {\n          var zero = !0;\n          for (j = 0;j < len; j++)\n            tmp[j] = naf[j][i] | 0, tmp[j] !== 0 && (zero = !1);\n          if (!zero)\n            break;\n          k++, i--;\n        }\n        if (i >= 0 && k++, acc = acc.dblp(k), i < 0)\n          break;\n        for (j = 0;j < len; j++) {\n          var z = tmp[j];\n          z !== 0 && (z > 0 \? p = wnd[j][z - 1 >> 1] : z < 0 && (p = wnd[j][-z - 1 >> 1].neg()), p.type === \"affine\" \? acc = acc.mixedAdd(p) : acc = acc.add(p));\n        }\n      }\n      for (i = 0;i < len; i++)\n        wnd[i] = null;\n      return jacobianResult \? acc : acc.toP();\n    };\n    function BasePoint(curve, type) {\n      this.curve = curve, this.type = type, this.precomputed = null;\n    }\n    BasePoint.prototype = {}, BaseCurve.BasePoint = BasePoint, BasePoint.prototype.eq = function() {\n      throw new Error(\"Not implemented\");\n    }, BasePoint.prototype.validate = function() {\n      return this.curve.validate(this);\n    }, BaseCurve.prototype.decodePoint = function(bytes, enc) {\n      bytes = utils.toArray(bytes, enc);\n      var len = this.p.byteLength();\n      if ((bytes[0] === 4 || bytes[0] === 6 || bytes[0] === 7) && bytes.length - 1 === 2 * len) {\n        bytes[0] === 6 \? assert(bytes[bytes.length - 1] % 2 === 0) : bytes[0] === 7 && assert(bytes[bytes.length - 1] % 2 === 1);\n        var res = this.point(bytes.slice(1, 1 + len), bytes.slice(1 + len, 1 + 2 * len));\n        return res;\n      } else if ((bytes[0] === 2 || bytes[0] === 3) && bytes.length - 1 === len)\n        return this.pointFromX(bytes.slice(1, 1 + len), bytes[0] === 3);\n      throw new Error(\"Unknown point format\");\n    }, BasePoint.prototype.encodeCompressed = function(enc) {\n      return this.encode(enc, !0);\n    }, BasePoint.prototype._encode = function(compact) {\n      var len = this.curve.p.byteLength(), x = this.getX().toArray(\"be\", len);\n      return compact \? [this.getY().isEven() \? 2 : 3].concat(x) : [4].concat(x, this.getY().toArray(\"be\", len));\n    }, BasePoint.prototype.encode = function(enc, compact) {\n      return utils.encode(this._encode(compact), enc);\n    }, BasePoint.prototype.precompute = function(power) {\n      if (this.precomputed)\n        return this;\n      var precomputed = {\n        doubles: null,\n        naf: null,\n        beta: null\n      };\n      return precomputed.naf = this._getNAFPoints(8), precomputed.doubles = this._getDoubles(4, power), precomputed.beta = this._getBeta(), this.precomputed = precomputed, this;\n    }, BasePoint.prototype._hasDoubles = function(k) {\n      if (!this.precomputed)\n        return !1;\n      var doubles = this.precomputed.doubles;\n      return doubles \? doubles.points.length >= Math.ceil((k.bitLength() + 1) / doubles.step) : !1;\n    }, BasePoint.prototype._getDoubles = function(step, power) {\n      if (this.precomputed && this.precomputed.doubles)\n        return this.precomputed.doubles;\n      for (var doubles = [this], acc = this, i = 0;i < power; i += step) {\n        for (var j = 0;j < step; j++)\n          acc = acc.dbl();\n        doubles.push(acc);\n      }\n      return {\n        step,\n        points: doubles\n      };\n    }, BasePoint.prototype._getNAFPoints = function(wnd) {\n      if (this.precomputed && this.precomputed.naf)\n        return this.precomputed.naf;\n      for (var res = [this], max = (1 << wnd) - 1, dbl = max === 1 \? null : this.dbl(), i = 1;i < max; i++)\n        res[i] = res[i - 1].add(dbl);\n      return {\n        wnd,\n        points: res\n      };\n    }, BasePoint.prototype._getBeta = function() {\n      return null;\n    }, BasePoint.prototype.dblp = function(k) {\n      for (var r = this, i = 0;i < k; i++)\n        r = r.dbl();\n      return r;\n    };\n  }\n}), require_short = __commonJS({\n  \"node_modules/elliptic/lib/elliptic/curve/short.js\"(exports, module) {\n    var utils = require_utils3(), BN = require_bn4(), inherits = require_inherits_browser(), Base = require_base(), assert = utils.assert;\n    function ShortCurve(conf) {\n      Base.call(this, \"short\", conf), this.a = new BN(conf.a, 16).toRed(this.red), this.b = new BN(conf.b, 16).toRed(this.red), this.tinv = this.two.redInvm(), this.zeroA = this.a.fromRed().cmpn(0) === 0, this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0, this.endo = this._getEndomorphism(conf), this._endoWnafT1 = new Array(4), this._endoWnafT2 = new Array(4);\n    }\n    inherits(ShortCurve, Base), module.exports = ShortCurve, ShortCurve.prototype._getEndomorphism = function(conf) {\n      if (!(!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)) {\n        var beta, lambda;\n        if (conf.beta)\n          beta = new BN(conf.beta, 16).toRed(this.red);\n        else {\n          var betas = this._getEndoRoots(this.p);\n          beta = betas[0].cmp(betas[1]) < 0 \? betas[0] : betas[1], beta = beta.toRed(this.red);\n        }\n        if (conf.lambda)\n          lambda = new BN(conf.lambda, 16);\n        else {\n          var lambdas = this._getEndoRoots(this.n);\n          this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0 \? lambda = lambdas[0] : (lambda = lambdas[1], assert(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0));\n        }\n        var basis;\n        return conf.basis \? basis = conf.basis.map(function(vec) {\n          return {\n            a: new BN(vec.a, 16),\n            b: new BN(vec.b, 16)\n          };\n        }) : basis = this._getEndoBasis(lambda), {\n          beta,\n          lambda,\n          basis\n        };\n      }\n    }, ShortCurve.prototype._getEndoRoots = function(num) {\n      var red = num === this.p \? this.red : BN.mont(num), tinv = new BN(2).toRed(red).redInvm(), ntinv = tinv.redNeg(), s = new BN(3).toRed(red).redNeg().redSqrt().redMul(tinv), l1 = ntinv.redAdd(s).fromRed(), l2 = ntinv.redSub(s).fromRed();\n      return [l1, l2];\n    }, ShortCurve.prototype._getEndoBasis = function(lambda) {\n      for (var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2)), u = lambda, v = this.n.clone(), x1 = new BN(1), y1 = new BN(0), x2 = new BN(0), y2 = new BN(1), a0, b0, a1, b1, a2, b2, prevR, i = 0, r, x;u.cmpn(0) !== 0; ) {\n        var q = v.div(u);\n        r = v.sub(q.mul(u)), x = x2.sub(q.mul(x1));\n        var y = y2.sub(q.mul(y1));\n        if (!a1 && r.cmp(aprxSqrt) < 0)\n          a0 = prevR.neg(), b0 = x1, a1 = r.neg(), b1 = x;\n        else if (a1 && ++i === 2)\n          break;\n        prevR = r, v = u, u = r, x2 = x1, x1 = x, y2 = y1, y1 = y;\n      }\n      a2 = r.neg(), b2 = x;\n      var len1 = a1.sqr().add(b1.sqr()), len2 = a2.sqr().add(b2.sqr());\n      return len2.cmp(len1) >= 0 && (a2 = a0, b2 = b0), a1.negative && (a1 = a1.neg(), b1 = b1.neg()), a2.negative && (a2 = a2.neg(), b2 = b2.neg()), [\n        { a: a1, b: b1 },\n        { a: a2, b: b2 }\n      ];\n    }, ShortCurve.prototype._endoSplit = function(k) {\n      var basis = this.endo.basis, v1 = basis[0], v2 = basis[1], c1 = v2.b.mul(k).divRound(this.n), c2 = v1.b.neg().mul(k).divRound(this.n), p1 = c1.mul(v1.a), p2 = c2.mul(v2.a), q1 = c1.mul(v1.b), q2 = c2.mul(v2.b), k1 = k.sub(p1).sub(p2), k2 = q1.add(q2).neg();\n      return { k1, k2 };\n    }, ShortCurve.prototype.pointFromX = function(x, odd) {\n      x = new BN(x, 16), x.red || (x = x.toRed(this.red));\n      var y2 = x.redSqr().redMul(x).redIAdd(x.redMul(this.a)).redIAdd(this.b), y = y2.redSqrt();\n      if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)\n        throw new Error(\"invalid point\");\n      var isOdd = y.fromRed().isOdd();\n      return (odd && !isOdd || !odd && isOdd) && (y = y.redNeg()), this.point(x, y);\n    }, ShortCurve.prototype.validate = function(point) {\n      if (point.inf)\n        return !0;\n      var { x, y } = point, ax = this.a.redMul(x), rhs = x.redSqr().redMul(x).redIAdd(ax).redIAdd(this.b);\n      return y.redSqr().redISub(rhs).cmpn(0) === 0;\n    }, ShortCurve.prototype._endoWnafMulAdd = function(points, coeffs, jacobianResult) {\n      for (var npoints = this._endoWnafT1, ncoeffs = this._endoWnafT2, i = 0;i < points.length; i++) {\n        var split = this._endoSplit(coeffs[i]), p = points[i], beta = p._getBeta();\n        split.k1.negative && (split.k1.ineg(), p = p.neg(!0)), split.k2.negative && (split.k2.ineg(), beta = beta.neg(!0)), npoints[i * 2] = p, npoints[i * 2 + 1] = beta, ncoeffs[i * 2] = split.k1, ncoeffs[i * 2 + 1] = split.k2;\n      }\n      for (var res = this._wnafMulAdd(1, npoints, ncoeffs, i * 2, jacobianResult), j = 0;j < i * 2; j++)\n        npoints[j] = null, ncoeffs[j] = null;\n      return res;\n    };\n    function Point(curve, x, y, isRed) {\n      Base.BasePoint.call(this, curve, \"affine\"), x === null && y === null \? (this.x = null, this.y = null, this.inf = !0) : (this.x = new BN(x, 16), this.y = new BN(y, 16), isRed && (this.x.forceRed(this.curve.red), this.y.forceRed(this.curve.red)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.inf = !1);\n    }\n    inherits(Point, Base.BasePoint), ShortCurve.prototype.point = function(x, y, isRed) {\n      return new Point(this, x, y, isRed);\n    }, ShortCurve.prototype.pointFromJSON = function(obj, red) {\n      return Point.fromJSON(this, obj, red);\n    }, Point.prototype._getBeta = function() {\n      if (this.curve.endo) {\n        var pre = this.precomputed;\n        if (pre && pre.beta)\n          return pre.beta;\n        var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);\n        if (pre) {\n          var curve = this.curve, endoMul = function(p) {\n            return curve.point(p.x.redMul(curve.endo.beta), p.y);\n          };\n          pre.beta = beta, beta.precomputed = {\n            beta: null,\n            naf: pre.naf && {\n              wnd: pre.naf.wnd,\n              points: pre.naf.points.map(endoMul)\n            },\n            doubles: pre.doubles && {\n              step: pre.doubles.step,\n              points: pre.doubles.points.map(endoMul)\n            }\n          };\n        }\n        return beta;\n      }\n    }, Point.prototype.toJSON = function() {\n      return this.precomputed \? [\n        this.x,\n        this.y,\n        this.precomputed && {\n          doubles: this.precomputed.doubles && {\n            step: this.precomputed.doubles.step,\n            points: this.precomputed.doubles.points.slice(1)\n          },\n          naf: this.precomputed.naf && {\n            wnd: this.precomputed.naf.wnd,\n            points: this.precomputed.naf.points.slice(1)\n          }\n        }\n      ] : [this.x, this.y];\n    }, Point.fromJSON = function(curve, obj, red) {\n      typeof obj == \"string\" && (obj = JSON.parse(obj));\n      var res = curve.point(obj[0], obj[1], red);\n      if (!obj[2])\n        return res;\n      function obj2point(obj2) {\n        return curve.point(obj2[0], obj2[1], red);\n      }\n      var pre = obj[2];\n      return res.precomputed = {\n        beta: null,\n        doubles: pre.doubles && {\n          step: pre.doubles.step,\n          points: [res].concat(pre.doubles.points.map(obj2point))\n        },\n        naf: pre.naf && {\n          wnd: pre.naf.wnd,\n          points: [res].concat(pre.naf.points.map(obj2point))\n        }\n      }, res;\n    }, Point.prototype.inspect = function() {\n      return this.isInfinity() \? \"<EC Point Infinity>\" : \"<EC Point x: \" + this.x.fromRed().toString(16, 2) + \" y: \" + this.y.fromRed().toString(16, 2) + \">\";\n    }, Point.prototype.isInfinity = function() {\n      return this.inf;\n    }, Point.prototype.add = function(p) {\n      if (this.inf)\n        return p;\n      if (p.inf)\n        return this;\n      if (this.eq(p))\n        return this.dbl();\n      if (this.neg().eq(p))\n        return this.curve.point(null, null);\n      if (this.x.cmp(p.x) === 0)\n        return this.curve.point(null, null);\n      var c = this.y.redSub(p.y);\n      c.cmpn(0) !== 0 && (c = c.redMul(this.x.redSub(p.x).redInvm()));\n      var nx = c.redSqr().redISub(this.x).redISub(p.x), ny = c.redMul(this.x.redSub(nx)).redISub(this.y);\n      return this.curve.point(nx, ny);\n    }, Point.prototype.dbl = function() {\n      if (this.inf)\n        return this;\n      var ys1 = this.y.redAdd(this.y);\n      if (ys1.cmpn(0) === 0)\n        return this.curve.point(null, null);\n      var a = this.curve.a, x2 = this.x.redSqr(), dyinv = ys1.redInvm(), c = x2.redAdd(x2).redIAdd(x2).redIAdd(a).redMul(dyinv), nx = c.redSqr().redISub(this.x.redAdd(this.x)), ny = c.redMul(this.x.redSub(nx)).redISub(this.y);\n      return this.curve.point(nx, ny);\n    }, Point.prototype.getX = function() {\n      return this.x.fromRed();\n    }, Point.prototype.getY = function() {\n      return this.y.fromRed();\n    }, Point.prototype.mul = function(k) {\n      return k = new BN(k, 16), this.isInfinity() \? this : this._hasDoubles(k) \? this.curve._fixedNafMul(this, k) : this.curve.endo \? this.curve._endoWnafMulAdd([this], [k]) : this.curve._wnafMul(this, k);\n    }, Point.prototype.mulAdd = function(k1, p2, k2) {\n      var points = [this, p2], coeffs = [k1, k2];\n      return this.curve.endo \? this.curve._endoWnafMulAdd(points, coeffs) : this.curve._wnafMulAdd(1, points, coeffs, 2);\n    }, Point.prototype.jmulAdd = function(k1, p2, k2) {\n      var points = [this, p2], coeffs = [k1, k2];\n      return this.curve.endo \? this.curve._endoWnafMulAdd(points, coeffs, !0) : this.curve._wnafMulAdd(1, points, coeffs, 2, !0);\n    }, Point.prototype.eq = function(p) {\n      return this === p || this.inf === p.inf && (this.inf || this.x.cmp(p.x) === 0 && this.y.cmp(p.y) === 0);\n    }, Point.prototype.neg = function(_precompute) {\n      if (this.inf)\n        return this;\n      var res = this.curve.point(this.x, this.y.redNeg());\n      if (_precompute && this.precomputed) {\n        var pre = this.precomputed, negate = function(p) {\n          return p.neg();\n        };\n        res.precomputed = {\n          naf: pre.naf && {\n            wnd: pre.naf.wnd,\n            points: pre.naf.points.map(negate)\n          },\n          doubles: pre.doubles && {\n            step: pre.doubles.step,\n            points: pre.doubles.points.map(negate)\n          }\n        };\n      }\n      return res;\n    }, Point.prototype.toJ = function() {\n      if (this.inf)\n        return this.curve.jpoint(null, null, null);\n      var res = this.curve.jpoint(this.x, this.y, this.curve.one);\n      return res;\n    };\n    function JPoint(curve, x, y, z) {\n      Base.BasePoint.call(this, curve, \"jacobian\"), x === null && y === null && z === null \? (this.x = this.curve.one, this.y = this.curve.one, this.z = new BN(0)) : (this.x = new BN(x, 16), this.y = new BN(y, 16), this.z = new BN(z, 16)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.zOne = this.z === this.curve.one;\n    }\n    inherits(JPoint, Base.BasePoint), ShortCurve.prototype.jpoint = function(x, y, z) {\n      return new JPoint(this, x, y, z);\n    }, JPoint.prototype.toP = function() {\n      if (this.isInfinity())\n        return this.curve.point(null, null);\n      var zinv = this.z.redInvm(), zinv2 = zinv.redSqr(), ax = this.x.redMul(zinv2), ay = this.y.redMul(zinv2).redMul(zinv);\n      return this.curve.point(ax, ay);\n    }, JPoint.prototype.neg = function() {\n      return this.curve.jpoint(this.x, this.y.redNeg(), this.z);\n    }, JPoint.prototype.add = function(p) {\n      if (this.isInfinity())\n        return p;\n      if (p.isInfinity())\n        return this;\n      var pz2 = p.z.redSqr(), z2 = this.z.redSqr(), u1 = this.x.redMul(pz2), u2 = p.x.redMul(z2), s1 = this.y.redMul(pz2.redMul(p.z)), s2 = p.y.redMul(z2.redMul(this.z)), h = u1.redSub(u2), r = s1.redSub(s2);\n      if (h.cmpn(0) === 0)\n        return r.cmpn(0) !== 0 \? this.curve.jpoint(null, null, null) : this.dbl();\n      var h2 = h.redSqr(), h3 = h2.redMul(h), v = u1.redMul(h2), nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v), ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3)), nz = this.z.redMul(p.z).redMul(h);\n      return this.curve.jpoint(nx, ny, nz);\n    }, JPoint.prototype.mixedAdd = function(p) {\n      if (this.isInfinity())\n        return p.toJ();\n      if (p.isInfinity())\n        return this;\n      var z2 = this.z.redSqr(), u1 = this.x, u2 = p.x.redMul(z2), s1 = this.y, s2 = p.y.redMul(z2).redMul(this.z), h = u1.redSub(u2), r = s1.redSub(s2);\n      if (h.cmpn(0) === 0)\n        return r.cmpn(0) !== 0 \? this.curve.jpoint(null, null, null) : this.dbl();\n      var h2 = h.redSqr(), h3 = h2.redMul(h), v = u1.redMul(h2), nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v), ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3)), nz = this.z.redMul(h);\n      return this.curve.jpoint(nx, ny, nz);\n    }, JPoint.prototype.dblp = function(pow) {\n      if (pow === 0)\n        return this;\n      if (this.isInfinity())\n        return this;\n      if (!pow)\n        return this.dbl();\n      var i;\n      if (this.curve.zeroA || this.curve.threeA) {\n        var r = this;\n        for (i = 0;i < pow; i++)\n          r = r.dbl();\n        return r;\n      }\n      var a = this.curve.a, tinv = this.curve.tinv, jx = this.x, jy = this.y, jz = this.z, jz4 = jz.redSqr().redSqr(), jyd = jy.redAdd(jy);\n      for (i = 0;i < pow; i++) {\n        var jx2 = jx.redSqr(), jyd2 = jyd.redSqr(), jyd4 = jyd2.redSqr(), c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4)), t1 = jx.redMul(jyd2), nx = c.redSqr().redISub(t1.redAdd(t1)), t2 = t1.redISub(nx), dny = c.redMul(t2);\n        dny = dny.redIAdd(dny).redISub(jyd4);\n        var nz = jyd.redMul(jz);\n        i + 1 < pow && (jz4 = jz4.redMul(jyd4)), jx = nx, jz = nz, jyd = dny;\n      }\n      return this.curve.jpoint(jx, jyd.redMul(tinv), jz);\n    }, JPoint.prototype.dbl = function() {\n      return this.isInfinity() \? this : this.curve.zeroA \? this._zeroDbl() : this.curve.threeA \? this._threeDbl() : this._dbl();\n    }, JPoint.prototype._zeroDbl = function() {\n      var nx, ny, nz;\n      if (this.zOne) {\n        var xx = this.x.redSqr(), yy = this.y.redSqr(), yyyy = yy.redSqr(), s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);\n        s = s.redIAdd(s);\n        var m = xx.redAdd(xx).redIAdd(xx), t = m.redSqr().redISub(s).redISub(s), yyyy8 = yyyy.redIAdd(yyyy);\n        yyyy8 = yyyy8.redIAdd(yyyy8), yyyy8 = yyyy8.redIAdd(yyyy8), nx = t, ny = m.redMul(s.redISub(t)).redISub(yyyy8), nz = this.y.redAdd(this.y);\n      } else {\n        var a = this.x.redSqr(), b = this.y.redSqr(), c = b.redSqr(), d = this.x.redAdd(b).redSqr().redISub(a).redISub(c);\n        d = d.redIAdd(d);\n        var e = a.redAdd(a).redIAdd(a), f = e.redSqr(), c8 = c.redIAdd(c);\n        c8 = c8.redIAdd(c8), c8 = c8.redIAdd(c8), nx = f.redISub(d).redISub(d), ny = e.redMul(d.redISub(nx)).redISub(c8), nz = this.y.redMul(this.z), nz = nz.redIAdd(nz);\n      }\n      return this.curve.jpoint(nx, ny, nz);\n    }, JPoint.prototype._threeDbl = function() {\n      var nx, ny, nz;\n      if (this.zOne) {\n        var xx = this.x.redSqr(), yy = this.y.redSqr(), yyyy = yy.redSqr(), s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);\n        s = s.redIAdd(s);\n        var m = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a), t = m.redSqr().redISub(s).redISub(s);\n        nx = t;\n        var yyyy8 = yyyy.redIAdd(yyyy);\n        yyyy8 = yyyy8.redIAdd(yyyy8), yyyy8 = yyyy8.redIAdd(yyyy8), ny = m.redMul(s.redISub(t)).redISub(yyyy8), nz = this.y.redAdd(this.y);\n      } else {\n        var delta = this.z.redSqr(), gamma = this.y.redSqr(), beta = this.x.redMul(gamma), alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));\n        alpha = alpha.redAdd(alpha).redIAdd(alpha);\n        var beta4 = beta.redIAdd(beta);\n        beta4 = beta4.redIAdd(beta4);\n        var beta8 = beta4.redAdd(beta4);\n        nx = alpha.redSqr().redISub(beta8), nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);\n        var ggamma8 = gamma.redSqr();\n        ggamma8 = ggamma8.redIAdd(ggamma8), ggamma8 = ggamma8.redIAdd(ggamma8), ggamma8 = ggamma8.redIAdd(ggamma8), ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);\n      }\n      return this.curve.jpoint(nx, ny, nz);\n    }, JPoint.prototype._dbl = function() {\n      var a = this.curve.a, jx = this.x, jy = this.y, jz = this.z, jz4 = jz.redSqr().redSqr(), jx2 = jx.redSqr(), jy2 = jy.redSqr(), c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4)), jxd4 = jx.redAdd(jx);\n      jxd4 = jxd4.redIAdd(jxd4);\n      var t1 = jxd4.redMul(jy2), nx = c.redSqr().redISub(t1.redAdd(t1)), t2 = t1.redISub(nx), jyd8 = jy2.redSqr();\n      jyd8 = jyd8.redIAdd(jyd8), jyd8 = jyd8.redIAdd(jyd8), jyd8 = jyd8.redIAdd(jyd8);\n      var ny = c.redMul(t2).redISub(jyd8), nz = jy.redAdd(jy).redMul(jz);\n      return this.curve.jpoint(nx, ny, nz);\n    }, JPoint.prototype.trpl = function() {\n      if (!this.curve.zeroA)\n        return this.dbl().add(this);\n      var xx = this.x.redSqr(), yy = this.y.redSqr(), zz = this.z.redSqr(), yyyy = yy.redSqr(), m = xx.redAdd(xx).redIAdd(xx), mm = m.redSqr(), e = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);\n      e = e.redIAdd(e), e = e.redAdd(e).redIAdd(e), e = e.redISub(mm);\n      var ee = e.redSqr(), t = yyyy.redIAdd(yyyy);\n      t = t.redIAdd(t), t = t.redIAdd(t), t = t.redIAdd(t);\n      var u = m.redIAdd(e).redSqr().redISub(mm).redISub(ee).redISub(t), yyu4 = yy.redMul(u);\n      yyu4 = yyu4.redIAdd(yyu4), yyu4 = yyu4.redIAdd(yyu4);\n      var nx = this.x.redMul(ee).redISub(yyu4);\n      nx = nx.redIAdd(nx), nx = nx.redIAdd(nx);\n      var ny = this.y.redMul(u.redMul(t.redISub(u)).redISub(e.redMul(ee)));\n      ny = ny.redIAdd(ny), ny = ny.redIAdd(ny), ny = ny.redIAdd(ny);\n      var nz = this.z.redAdd(e).redSqr().redISub(zz).redISub(ee);\n      return this.curve.jpoint(nx, ny, nz);\n    }, JPoint.prototype.mul = function(k, kbase) {\n      return k = new BN(k, kbase), this.curve._wnafMul(this, k);\n    }, JPoint.prototype.eq = function(p) {\n      if (p.type === \"affine\")\n        return this.eq(p.toJ());\n      if (this === p)\n        return !0;\n      var z2 = this.z.redSqr(), pz2 = p.z.redSqr();\n      if (this.x.redMul(pz2).redISub(p.x.redMul(z2)).cmpn(0) !== 0)\n        return !1;\n      var z3 = z2.redMul(this.z), pz3 = pz2.redMul(p.z);\n      return this.y.redMul(pz3).redISub(p.y.redMul(z3)).cmpn(0) === 0;\n    }, JPoint.prototype.eqXToP = function(x) {\n      var zs = this.z.redSqr(), rx = x.toRed(this.curve.red).redMul(zs);\n      if (this.x.cmp(rx) === 0)\n        return !0;\n      for (var xc = x.clone(), t = this.curve.redN.redMul(zs);; ) {\n        if (xc.iadd(this.curve.n), xc.cmp(this.curve.p) >= 0)\n          return !1;\n        if (rx.redIAdd(t), this.x.cmp(rx) === 0)\n          return !0;\n      }\n    }, JPoint.prototype.inspect = function() {\n      return this.isInfinity() \? \"<EC JPoint Infinity>\" : \"<EC JPoint x: \" + this.x.toString(16, 2) + \" y: \" + this.y.toString(16, 2) + \" z: \" + this.z.toString(16, 2) + \">\";\n    }, JPoint.prototype.isInfinity = function() {\n      return this.z.cmpn(0) === 0;\n    };\n  }\n}), require_mont = __commonJS({\n  \"node_modules/elliptic/lib/elliptic/curve/mont.js\"(exports, module) {\n    var BN = require_bn4(), inherits = require_inherits_browser(), Base = require_base(), utils = require_utils3();\n    function MontCurve(conf) {\n      Base.call(this, \"mont\", conf), this.a = new BN(conf.a, 16).toRed(this.red), this.b = new BN(conf.b, 16).toRed(this.red), this.i4 = new BN(4).toRed(this.red).redInvm(), this.two = new BN(2).toRed(this.red), this.a24 = this.i4.redMul(this.a.redAdd(this.two));\n    }\n    inherits(MontCurve, Base), module.exports = MontCurve, MontCurve.prototype.validate = function(point) {\n      var x = point.normalize().x, x2 = x.redSqr(), rhs = x2.redMul(x).redAdd(x2.redMul(this.a)).redAdd(x), y = rhs.redSqrt();\n      return y.redSqr().cmp(rhs) === 0;\n    };\n    function Point(curve, x, z) {\n      Base.BasePoint.call(this, curve, \"projective\"), x === null && z === null \? (this.x = this.curve.one, this.z = this.curve.zero) : (this.x = new BN(x, 16), this.z = new BN(z, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)));\n    }\n    inherits(Point, Base.BasePoint), MontCurve.prototype.decodePoint = function(bytes, enc) {\n      return this.point(utils.toArray(bytes, enc), 1);\n    }, MontCurve.prototype.point = function(x, z) {\n      return new Point(this, x, z);\n    }, MontCurve.prototype.pointFromJSON = function(obj) {\n      return Point.fromJSON(this, obj);\n    }, Point.prototype.precompute = function() {\n    }, Point.prototype._encode = function() {\n      return this.getX().toArray(\"be\", this.curve.p.byteLength());\n    }, Point.fromJSON = function(curve, obj) {\n      return new Point(curve, obj[0], obj[1] || curve.one);\n    }, Point.prototype.inspect = function() {\n      return this.isInfinity() \? \"<EC Point Infinity>\" : \"<EC Point x: \" + this.x.fromRed().toString(16, 2) + \" z: \" + this.z.fromRed().toString(16, 2) + \">\";\n    }, Point.prototype.isInfinity = function() {\n      return this.z.cmpn(0) === 0;\n    }, Point.prototype.dbl = function() {\n      var a = this.x.redAdd(this.z), aa = a.redSqr(), b = this.x.redSub(this.z), bb = b.redSqr(), c = aa.redSub(bb), nx = aa.redMul(bb), nz = c.redMul(bb.redAdd(this.curve.a24.redMul(c)));\n      return this.curve.point(nx, nz);\n    }, Point.prototype.add = function() {\n      throw new Error(\"Not supported on Montgomery curve\");\n    }, Point.prototype.diffAdd = function(p, diff) {\n      var a = this.x.redAdd(this.z), b = this.x.redSub(this.z), c = p.x.redAdd(p.z), d = p.x.redSub(p.z), da = d.redMul(a), cb = c.redMul(b), nx = diff.z.redMul(da.redAdd(cb).redSqr()), nz = diff.x.redMul(da.redISub(cb).redSqr());\n      return this.curve.point(nx, nz);\n    }, Point.prototype.mul = function(k) {\n      for (var t = k.clone(), a = this, b = this.curve.point(null, null), c = this, bits = [];t.cmpn(0) !== 0; t.iushrn(1))\n        bits.push(t.andln(1));\n      for (var i = bits.length - 1;i >= 0; i--)\n        bits[i] === 0 \? (a = a.diffAdd(b, c), b = b.dbl()) : (b = a.diffAdd(b, c), a = a.dbl());\n      return b;\n    }, Point.prototype.mulAdd = function() {\n      throw new Error(\"Not supported on Montgomery curve\");\n    }, Point.prototype.jumlAdd = function() {\n      throw new Error(\"Not supported on Montgomery curve\");\n    }, Point.prototype.eq = function(other) {\n      return this.getX().cmp(other.getX()) === 0;\n    }, Point.prototype.normalize = function() {\n      return this.x = this.x.redMul(this.z.redInvm()), this.z = this.curve.one, this;\n    }, Point.prototype.getX = function() {\n      return this.normalize(), this.x.fromRed();\n    };\n  }\n}), require_edwards = __commonJS({\n  \"node_modules/elliptic/lib/elliptic/curve/edwards.js\"(exports, module) {\n    var utils = require_utils3(), BN = require_bn4(), inherits = require_inherits_browser(), Base = require_base(), assert = utils.assert;\n    function EdwardsCurve(conf) {\n      this.twisted = (conf.a | 0) !== 1, this.mOneA = this.twisted && (conf.a | 0) === -1, this.extended = this.mOneA, Base.call(this, \"edwards\", conf), this.a = new BN(conf.a, 16).umod(this.red.m), this.a = this.a.toRed(this.red), this.c = new BN(conf.c, 16).toRed(this.red), this.c2 = this.c.redSqr(), this.d = new BN(conf.d, 16).toRed(this.red), this.dd = this.d.redAdd(this.d), assert(!this.twisted || this.c.fromRed().cmpn(1) === 0), this.oneC = (conf.c | 0) === 1;\n    }\n    inherits(EdwardsCurve, Base), module.exports = EdwardsCurve, EdwardsCurve.prototype._mulA = function(num) {\n      return this.mOneA \? num.redNeg() : this.a.redMul(num);\n    }, EdwardsCurve.prototype._mulC = function(num) {\n      return this.oneC \? num : this.c.redMul(num);\n    }, EdwardsCurve.prototype.jpoint = function(x, y, z, t) {\n      return this.point(x, y, z, t);\n    }, EdwardsCurve.prototype.pointFromX = function(x, odd) {\n      x = new BN(x, 16), x.red || (x = x.toRed(this.red));\n      var x2 = x.redSqr(), rhs = this.c2.redSub(this.a.redMul(x2)), lhs = this.one.redSub(this.c2.redMul(this.d).redMul(x2)), y2 = rhs.redMul(lhs.redInvm()), y = y2.redSqrt();\n      if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)\n        throw new Error(\"invalid point\");\n      var isOdd = y.fromRed().isOdd();\n      return (odd && !isOdd || !odd && isOdd) && (y = y.redNeg()), this.point(x, y);\n    }, EdwardsCurve.prototype.pointFromY = function(y, odd) {\n      y = new BN(y, 16), y.red || (y = y.toRed(this.red));\n      var y2 = y.redSqr(), lhs = y2.redSub(this.c2), rhs = y2.redMul(this.d).redMul(this.c2).redSub(this.a), x2 = lhs.redMul(rhs.redInvm());\n      if (x2.cmp(this.zero) === 0) {\n        if (odd)\n          throw new Error(\"invalid point\");\n        return this.point(this.zero, y);\n      }\n      var x = x2.redSqrt();\n      if (x.redSqr().redSub(x2).cmp(this.zero) !== 0)\n        throw new Error(\"invalid point\");\n      return x.fromRed().isOdd() !== odd && (x = x.redNeg()), this.point(x, y);\n    }, EdwardsCurve.prototype.validate = function(point) {\n      if (point.isInfinity())\n        return !0;\n      point.normalize();\n      var x2 = point.x.redSqr(), y2 = point.y.redSqr(), lhs = x2.redMul(this.a).redAdd(y2), rhs = this.c2.redMul(this.one.redAdd(this.d.redMul(x2).redMul(y2)));\n      return lhs.cmp(rhs) === 0;\n    };\n    function Point(curve, x, y, z, t) {\n      Base.BasePoint.call(this, curve, \"projective\"), x === null && y === null && z === null \? (this.x = this.curve.zero, this.y = this.curve.one, this.z = this.curve.one, this.t = this.curve.zero, this.zOne = !0) : (this.x = new BN(x, 16), this.y = new BN(y, 16), this.z = z \? new BN(z, 16) : this.curve.one, this.t = t && new BN(t, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.t && !this.t.red && (this.t = this.t.toRed(this.curve.red)), this.zOne = this.z === this.curve.one, this.curve.extended && !this.t && (this.t = this.x.redMul(this.y), this.zOne || (this.t = this.t.redMul(this.z.redInvm()))));\n    }\n    inherits(Point, Base.BasePoint), EdwardsCurve.prototype.pointFromJSON = function(obj) {\n      return Point.fromJSON(this, obj);\n    }, EdwardsCurve.prototype.point = function(x, y, z, t) {\n      return new Point(this, x, y, z, t);\n    }, Point.fromJSON = function(curve, obj) {\n      return new Point(curve, obj[0], obj[1], obj[2]);\n    }, Point.prototype.inspect = function() {\n      return this.isInfinity() \? \"<EC Point Infinity>\" : \"<EC Point x: \" + this.x.fromRed().toString(16, 2) + \" y: \" + this.y.fromRed().toString(16, 2) + \" z: \" + this.z.fromRed().toString(16, 2) + \">\";\n    }, Point.prototype.isInfinity = function() {\n      return this.x.cmpn(0) === 0 && (this.y.cmp(this.z) === 0 || this.zOne && this.y.cmp(this.curve.c) === 0);\n    }, Point.prototype._extDbl = function() {\n      var a = this.x.redSqr(), b = this.y.redSqr(), c = this.z.redSqr();\n      c = c.redIAdd(c);\n      var d = this.curve._mulA(a), e = this.x.redAdd(this.y).redSqr().redISub(a).redISub(b), g = d.redAdd(b), f = g.redSub(c), h = d.redSub(b), nx = e.redMul(f), ny = g.redMul(h), nt = e.redMul(h), nz = f.redMul(g);\n      return this.curve.point(nx, ny, nz, nt);\n    }, Point.prototype._projDbl = function() {\n      var b = this.x.redAdd(this.y).redSqr(), c = this.x.redSqr(), d = this.y.redSqr(), nx, ny, nz, e, h, j;\n      if (this.curve.twisted) {\n        e = this.curve._mulA(c);\n        var f = e.redAdd(d);\n        this.zOne \? (nx = b.redSub(c).redSub(d).redMul(f.redSub(this.curve.two)), ny = f.redMul(e.redSub(d)), nz = f.redSqr().redSub(f).redSub(f)) : (h = this.z.redSqr(), j = f.redSub(h).redISub(h), nx = b.redSub(c).redISub(d).redMul(j), ny = f.redMul(e.redSub(d)), nz = f.redMul(j));\n      } else\n        e = c.redAdd(d), h = this.curve._mulC(this.z).redSqr(), j = e.redSub(h).redSub(h), nx = this.curve._mulC(b.redISub(e)).redMul(j), ny = this.curve._mulC(e).redMul(c.redISub(d)), nz = e.redMul(j);\n      return this.curve.point(nx, ny, nz);\n    }, Point.prototype.dbl = function() {\n      return this.isInfinity() \? this : this.curve.extended \? this._extDbl() : this._projDbl();\n    }, Point.prototype._extAdd = function(p) {\n      var a = this.y.redSub(this.x).redMul(p.y.redSub(p.x)), b = this.y.redAdd(this.x).redMul(p.y.redAdd(p.x)), c = this.t.redMul(this.curve.dd).redMul(p.t), d = this.z.redMul(p.z.redAdd(p.z)), e = b.redSub(a), f = d.redSub(c), g = d.redAdd(c), h = b.redAdd(a), nx = e.redMul(f), ny = g.redMul(h), nt = e.redMul(h), nz = f.redMul(g);\n      return this.curve.point(nx, ny, nz, nt);\n    }, Point.prototype._projAdd = function(p) {\n      var a = this.z.redMul(p.z), b = a.redSqr(), c = this.x.redMul(p.x), d = this.y.redMul(p.y), e = this.curve.d.redMul(c).redMul(d), f = b.redSub(e), g = b.redAdd(e), tmp = this.x.redAdd(this.y).redMul(p.x.redAdd(p.y)).redISub(c).redISub(d), nx = a.redMul(f).redMul(tmp), ny, nz;\n      return this.curve.twisted \? (ny = a.redMul(g).redMul(d.redSub(this.curve._mulA(c))), nz = f.redMul(g)) : (ny = a.redMul(g).redMul(d.redSub(c)), nz = this.curve._mulC(f).redMul(g)), this.curve.point(nx, ny, nz);\n    }, Point.prototype.add = function(p) {\n      return this.isInfinity() \? p : p.isInfinity() \? this : this.curve.extended \? this._extAdd(p) : this._projAdd(p);\n    }, Point.prototype.mul = function(k) {\n      return this._hasDoubles(k) \? this.curve._fixedNafMul(this, k) : this.curve._wnafMul(this, k);\n    }, Point.prototype.mulAdd = function(k1, p, k2) {\n      return this.curve._wnafMulAdd(1, [this, p], [k1, k2], 2, !1);\n    }, Point.prototype.jmulAdd = function(k1, p, k2) {\n      return this.curve._wnafMulAdd(1, [this, p], [k1, k2], 2, !0);\n    }, Point.prototype.normalize = function() {\n      if (this.zOne)\n        return this;\n      var zi = this.z.redInvm();\n      return this.x = this.x.redMul(zi), this.y = this.y.redMul(zi), this.t && (this.t = this.t.redMul(zi)), this.z = this.curve.one, this.zOne = !0, this;\n    }, Point.prototype.neg = function() {\n      return this.curve.point(this.x.redNeg(), this.y, this.z, this.t && this.t.redNeg());\n    }, Point.prototype.getX = function() {\n      return this.normalize(), this.x.fromRed();\n    }, Point.prototype.getY = function() {\n      return this.normalize(), this.y.fromRed();\n    }, Point.prototype.eq = function(other) {\n      return this === other || this.getX().cmp(other.getX()) === 0 && this.getY().cmp(other.getY()) === 0;\n    }, Point.prototype.eqXToP = function(x) {\n      var rx = x.toRed(this.curve.red).redMul(this.z);\n      if (this.x.cmp(rx) === 0)\n        return !0;\n      for (var xc = x.clone(), t = this.curve.redN.redMul(this.z);; ) {\n        if (xc.iadd(this.curve.n), xc.cmp(this.curve.p) >= 0)\n          return !1;\n        if (rx.redIAdd(t), this.x.cmp(rx) === 0)\n          return !0;\n      }\n    }, Point.prototype.toP = Point.prototype.normalize, Point.prototype.mixedAdd = Point.prototype.add;\n  }\n}), require_curve = __commonJS({\n  \"node_modules/elliptic/lib/elliptic/curve/index.js\"(exports) {\n    var curve = exports;\n    curve.base = require_base(), curve.short = require_short(), curve.mont = require_mont(), curve.edwards = require_edwards();\n  }\n}), require_utils4 = __commonJS({\n  \"node_modules/hash.js/lib/hash/utils.js\"(exports) {\n    var assert = require_minimalistic_assert(), inherits = require_inherits_browser();\n    exports.inherits = inherits;\n    function isSurrogatePair(msg, i) {\n      return (msg.charCodeAt(i) & 64512) !== 55296 || i < 0 || i + 1 >= msg.length \? !1 : (msg.charCodeAt(i + 1) & 64512) === 56320;\n    }\n    function toArray(msg, enc) {\n      if (Array.isArray(msg))\n        return msg.slice();\n      if (!msg)\n        return [];\n      var res = [];\n      if (typeof msg == \"string\")\n        if (enc) {\n          if (enc === \"hex\")\n            for (msg = msg.replace(/[^a-z0-9]+/gi, \"\"), msg.length % 2 !== 0 && (msg = \"0\" + msg), i = 0;i < msg.length; i += 2)\n              res.push(parseInt(msg[i] + msg[i + 1], 16));\n        } else\n          for (var p = 0, i = 0;i < msg.length; i++) {\n            var c = msg.charCodeAt(i);\n            c < 128 \? res[p++] = c : c < 2048 \? (res[p++] = c >> 6 | 192, res[p++] = c & 63 | 128) : isSurrogatePair(msg, i) \? (c = 65536 + ((c & 1023) << 10) + (msg.charCodeAt(++i) & 1023), res[p++] = c >> 18 | 240, res[p++] = c >> 12 & 63 | 128, res[p++] = c >> 6 & 63 | 128, res[p++] = c & 63 | 128) : (res[p++] = c >> 12 | 224, res[p++] = c >> 6 & 63 | 128, res[p++] = c & 63 | 128);\n          }\n      else\n        for (i = 0;i < msg.length; i++)\n          res[i] = msg[i] | 0;\n      return res;\n    }\n    exports.toArray = toArray;\n    function toHex(msg) {\n      for (var res = \"\", i = 0;i < msg.length; i++)\n        res += zero2(msg[i].toString(16));\n      return res;\n    }\n    exports.toHex = toHex;\n    function htonl(w) {\n      var res = w >>> 24 | w >>> 8 & 65280 | w << 8 & 16711680 | (w & 255) << 24;\n      return res >>> 0;\n    }\n    exports.htonl = htonl;\n    function toHex32(msg, endian) {\n      for (var res = \"\", i = 0;i < msg.length; i++) {\n        var w = msg[i];\n        endian === \"little\" && (w = htonl(w)), res += zero8(w.toString(16));\n      }\n      return res;\n    }\n    exports.toHex32 = toHex32;\n    function zero2(word) {\n      return word.length === 1 \? \"0\" + word : word;\n    }\n    exports.zero2 = zero2;\n    function zero8(word) {\n      return word.length === 7 \? \"0\" + word : word.length === 6 \? \"00\" + word : word.length === 5 \? \"000\" + word : word.length === 4 \? \"0000\" + word : word.length === 3 \? \"00000\" + word : word.length === 2 \? \"000000\" + word : word.length === 1 \? \"0000000\" + word : word;\n    }\n    exports.zero8 = zero8;\n    function join32(msg, start, end, endian) {\n      var len = end - start;\n      assert(len % 4 === 0);\n      for (var res = new Array(len / 4), i = 0, k = start;i < res.length; i++, k += 4) {\n        var w;\n        endian === \"big\" \? w = msg[k] << 24 | msg[k + 1] << 16 | msg[k + 2] << 8 | msg[k + 3] : w = msg[k + 3] << 24 | msg[k + 2] << 16 | msg[k + 1] << 8 | msg[k], res[i] = w >>> 0;\n      }\n      return res;\n    }\n    exports.join32 = join32;\n    function split32(msg, endian) {\n      for (var res = new Array(msg.length * 4), i = 0, k = 0;i < msg.length; i++, k += 4) {\n        var m = msg[i];\n        endian === \"big\" \? (res[k] = m >>> 24, res[k + 1] = m >>> 16 & 255, res[k + 2] = m >>> 8 & 255, res[k + 3] = m & 255) : (res[k + 3] = m >>> 24, res[k + 2] = m >>> 16 & 255, res[k + 1] = m >>> 8 & 255, res[k] = m & 255);\n      }\n      return res;\n    }\n    exports.split32 = split32;\n    function rotr32(w, b) {\n      return w >>> b | w << 32 - b;\n    }\n    exports.rotr32 = rotr32;\n    function rotl32(w, b) {\n      return w << b | w >>> 32 - b;\n    }\n    exports.rotl32 = rotl32;\n    function sum32(a, b) {\n      return a + b >>> 0;\n    }\n    exports.sum32 = sum32;\n    function sum32_3(a, b, c) {\n      return a + b + c >>> 0;\n    }\n    exports.sum32_3 = sum32_3;\n    function sum32_4(a, b, c, d) {\n      return a + b + c + d >>> 0;\n    }\n    exports.sum32_4 = sum32_4;\n    function sum32_5(a, b, c, d, e) {\n      return a + b + c + d + e >>> 0;\n    }\n    exports.sum32_5 = sum32_5;\n    function sum64(buf, pos, ah, al) {\n      var bh = buf[pos], bl = buf[pos + 1], lo = al + bl >>> 0, hi = (lo < al \? 1 : 0) + ah + bh;\n      buf[pos] = hi >>> 0, buf[pos + 1] = lo;\n    }\n    exports.sum64 = sum64;\n    function sum64_hi(ah, al, bh, bl) {\n      var lo = al + bl >>> 0, hi = (lo < al \? 1 : 0) + ah + bh;\n      return hi >>> 0;\n    }\n    exports.sum64_hi = sum64_hi;\n    function sum64_lo(ah, al, bh, bl) {\n      var lo = al + bl;\n      return lo >>> 0;\n    }\n    exports.sum64_lo = sum64_lo;\n    function sum64_4_hi(ah, al, bh, bl, ch, cl, dh, dl) {\n      var carry = 0, lo = al;\n      lo = lo + bl >>> 0, carry += lo < al \? 1 : 0, lo = lo + cl >>> 0, carry += lo < cl \? 1 : 0, lo = lo + dl >>> 0, carry += lo < dl \? 1 : 0;\n      var hi = ah + bh + ch + dh + carry;\n      return hi >>> 0;\n    }\n    exports.sum64_4_hi = sum64_4_hi;\n    function sum64_4_lo(ah, al, bh, bl, ch, cl, dh, dl) {\n      var lo = al + bl + cl + dl;\n      return lo >>> 0;\n    }\n    exports.sum64_4_lo = sum64_4_lo;\n    function sum64_5_hi(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {\n      var carry = 0, lo = al;\n      lo = lo + bl >>> 0, carry += lo < al \? 1 : 0, lo = lo + cl >>> 0, carry += lo < cl \? 1 : 0, lo = lo + dl >>> 0, carry += lo < dl \? 1 : 0, lo = lo + el >>> 0, carry += lo < el \? 1 : 0;\n      var hi = ah + bh + ch + dh + eh + carry;\n      return hi >>> 0;\n    }\n    exports.sum64_5_hi = sum64_5_hi;\n    function sum64_5_lo(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {\n      var lo = al + bl + cl + dl + el;\n      return lo >>> 0;\n    }\n    exports.sum64_5_lo = sum64_5_lo;\n    function rotr64_hi(ah, al, num) {\n      var r = al << 32 - num | ah >>> num;\n      return r >>> 0;\n    }\n    exports.rotr64_hi = rotr64_hi;\n    function rotr64_lo(ah, al, num) {\n      var r = ah << 32 - num | al >>> num;\n      return r >>> 0;\n    }\n    exports.rotr64_lo = rotr64_lo;\n    function shr64_hi(ah, al, num) {\n      return ah >>> num;\n    }\n    exports.shr64_hi = shr64_hi;\n    function shr64_lo(ah, al, num) {\n      var r = ah << 32 - num | al >>> num;\n      return r >>> 0;\n    }\n    exports.shr64_lo = shr64_lo;\n  }\n}), require_common = __commonJS({\n  \"node_modules/hash.js/lib/hash/common.js\"(exports) {\n    var utils = require_utils4(), assert = require_minimalistic_assert();\n    function BlockHash() {\n      this.pending = null, this.pendingTotal = 0, this.blockSize = this.constructor.blockSize, this.outSize = this.constructor.outSize, this.hmacStrength = this.constructor.hmacStrength, this.padLength = this.constructor.padLength / 8, this.endian = \"big\", this._delta8 = this.blockSize / 8, this._delta32 = this.blockSize / 32;\n    }\n    BlockHash.prototype = {}, exports.BlockHash = BlockHash, BlockHash.prototype.update = function(msg, enc) {\n      if (msg = utils.toArray(msg, enc), this.pending \? this.pending = this.pending.concat(msg) : this.pending = msg, this.pendingTotal += msg.length, this.pending.length >= this._delta8) {\n        msg = this.pending;\n        var r = msg.length % this._delta8;\n        this.pending = msg.slice(msg.length - r, msg.length), this.pending.length === 0 && (this.pending = null), msg = utils.join32(msg, 0, msg.length - r, this.endian);\n        for (var i = 0;i < msg.length; i += this._delta32)\n          this._update(msg, i, i + this._delta32);\n      }\n      return this;\n    }, BlockHash.prototype.digest = function(enc) {\n      return this.update(this._pad()), assert(this.pending === null), this._digest(enc);\n    }, BlockHash.prototype._pad = function() {\n      var len = this.pendingTotal, bytes = this._delta8, k = bytes - (len + this.padLength) % bytes, res = new Array(k + this.padLength);\n      res[0] = 128;\n      for (var i = 1;i < k; i++)\n        res[i] = 0;\n      if (len <<= 3, this.endian === \"big\") {\n        for (var t = 8;t < this.padLength; t++)\n          res[i++] = 0;\n        res[i++] = 0, res[i++] = 0, res[i++] = 0, res[i++] = 0, res[i++] = len >>> 24 & 255, res[i++] = len >>> 16 & 255, res[i++] = len >>> 8 & 255, res[i++] = len & 255;\n      } else\n        for (res[i++] = len & 255, res[i++] = len >>> 8 & 255, res[i++] = len >>> 16 & 255, res[i++] = len >>> 24 & 255, res[i++] = 0, res[i++] = 0, res[i++] = 0, res[i++] = 0, t = 8;t < this.padLength; t++)\n          res[i++] = 0;\n      return res;\n    };\n  }\n}), require_common2 = __commonJS({\n  \"node_modules/hash.js/lib/hash/sha/common.js\"(exports) {\n    var utils = require_utils4(), rotr32 = utils.rotr32;\n    function ft_1(s, x, y, z) {\n      if (s === 0)\n        return ch32(x, y, z);\n      if (s === 1 || s === 3)\n        return p32(x, y, z);\n      if (s === 2)\n        return maj32(x, y, z);\n    }\n    exports.ft_1 = ft_1;\n    function ch32(x, y, z) {\n      return x & y ^ ~x & z;\n    }\n    exports.ch32 = ch32;\n    function maj32(x, y, z) {\n      return x & y ^ x & z ^ y & z;\n    }\n    exports.maj32 = maj32;\n    function p32(x, y, z) {\n      return x ^ y ^ z;\n    }\n    exports.p32 = p32;\n    function s0_256(x) {\n      return rotr32(x, 2) ^ rotr32(x, 13) ^ rotr32(x, 22);\n    }\n    exports.s0_256 = s0_256;\n    function s1_256(x) {\n      return rotr32(x, 6) ^ rotr32(x, 11) ^ rotr32(x, 25);\n    }\n    exports.s1_256 = s1_256;\n    function g0_256(x) {\n      return rotr32(x, 7) ^ rotr32(x, 18) ^ x >>> 3;\n    }\n    exports.g0_256 = g0_256;\n    function g1_256(x) {\n      return rotr32(x, 17) ^ rotr32(x, 19) ^ x >>> 10;\n    }\n    exports.g1_256 = g1_256;\n  }\n}), require__ = __commonJS({\n  \"node_modules/hash.js/lib/hash/sha/1.js\"(exports, module) {\n    var utils = require_utils4(), common = require_common(), shaCommon = require_common2(), rotl32 = utils.rotl32, sum32 = utils.sum32, sum32_5 = utils.sum32_5, ft_1 = shaCommon.ft_1, BlockHash = common.BlockHash, sha1_K = [1518500249, 1859775393, 2400959708, 3395469782];\n    function SHA1() {\n      if (!(this instanceof SHA1))\n        return new SHA1;\n      BlockHash.call(this), this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.W = new Array(80);\n    }\n    utils.inherits(SHA1, BlockHash), module.exports = SHA1, SHA1.blockSize = 512, SHA1.outSize = 160, SHA1.hmacStrength = 80, SHA1.padLength = 64, SHA1.prototype._update = function(msg, start) {\n      for (var W = this.W, i = 0;i < 16; i++)\n        W[i] = msg[start + i];\n      for (;i < W.length; i++)\n        W[i] = rotl32(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16], 1);\n      var a = this.h[0], b = this.h[1], c = this.h[2], d = this.h[3], e = this.h[4];\n      for (i = 0;i < W.length; i++) {\n        var s = ~~(i / 20), t = sum32_5(rotl32(a, 5), ft_1(s, b, c, d), e, W[i], sha1_K[s]);\n        e = d, d = c, c = rotl32(b, 30), b = a, a = t;\n      }\n      this.h[0] = sum32(this.h[0], a), this.h[1] = sum32(this.h[1], b), this.h[2] = sum32(this.h[2], c), this.h[3] = sum32(this.h[3], d), this.h[4] = sum32(this.h[4], e);\n    }, SHA1.prototype._digest = function(enc) {\n      return enc === \"hex\" \? utils.toHex32(this.h, \"big\") : utils.split32(this.h, \"big\");\n    };\n  }\n}), require__2 = __commonJS({\n  \"node_modules/hash.js/lib/hash/sha/256.js\"(exports, module) {\n    var utils = require_utils4(), common = require_common(), shaCommon = require_common2(), assert = require_minimalistic_assert(), sum32 = utils.sum32, sum32_4 = utils.sum32_4, sum32_5 = utils.sum32_5, ch32 = shaCommon.ch32, maj32 = shaCommon.maj32, s0_256 = shaCommon.s0_256, s1_256 = shaCommon.s1_256, g0_256 = shaCommon.g0_256, g1_256 = shaCommon.g1_256, BlockHash = common.BlockHash, sha256_K = [\n      1116352408,\n      1899447441,\n      3049323471,\n      3921009573,\n      961987163,\n      1508970993,\n      2453635748,\n      2870763221,\n      3624381080,\n      310598401,\n      607225278,\n      1426881987,\n      1925078388,\n      2162078206,\n      2614888103,\n      3248222580,\n      3835390401,\n      4022224774,\n      264347078,\n      604807628,\n      770255983,\n      1249150122,\n      1555081692,\n      1996064986,\n      2554220882,\n      2821834349,\n      2952996808,\n      3210313671,\n      3336571891,\n      3584528711,\n      113926993,\n      338241895,\n      666307205,\n      773529912,\n      1294757372,\n      1396182291,\n      1695183700,\n      1986661051,\n      2177026350,\n      2456956037,\n      2730485921,\n      2820302411,\n      3259730800,\n      3345764771,\n      3516065817,\n      3600352804,\n      4094571909,\n      275423344,\n      430227734,\n      506948616,\n      659060556,\n      883997877,\n      958139571,\n      1322822218,\n      1537002063,\n      1747873779,\n      1955562222,\n      2024104815,\n      2227730452,\n      2361852424,\n      2428436474,\n      2756734187,\n      3204031479,\n      3329325298\n    ];\n    function SHA256() {\n      if (!(this instanceof SHA256))\n        return new SHA256;\n      BlockHash.call(this), this.h = [1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225], this.k = sha256_K, this.W = new Array(64);\n    }\n    utils.inherits(SHA256, BlockHash), module.exports = SHA256, SHA256.blockSize = 512, SHA256.outSize = 256, SHA256.hmacStrength = 192, SHA256.padLength = 64, SHA256.prototype._update = function(msg, start) {\n      for (var W = this.W, i = 0;i < 16; i++)\n        W[i] = msg[start + i];\n      for (;i < W.length; i++)\n        W[i] = sum32_4(g1_256(W[i - 2]), W[i - 7], g0_256(W[i - 15]), W[i - 16]);\n      var a = this.h[0], b = this.h[1], c = this.h[2], d = this.h[3], e = this.h[4], f = this.h[5], g = this.h[6], h = this.h[7];\n      for (assert(this.k.length === W.length), i = 0;i < W.length; i++) {\n        var T1 = sum32_5(h, s1_256(e), ch32(e, f, g), this.k[i], W[i]), T2 = sum32(s0_256(a), maj32(a, b, c));\n        h = g, g = f, f = e, e = sum32(d, T1), d = c, c = b, b = a, a = sum32(T1, T2);\n      }\n      this.h[0] = sum32(this.h[0], a), this.h[1] = sum32(this.h[1], b), this.h[2] = sum32(this.h[2], c), this.h[3] = sum32(this.h[3], d), this.h[4] = sum32(this.h[4], e), this.h[5] = sum32(this.h[5], f), this.h[6] = sum32(this.h[6], g), this.h[7] = sum32(this.h[7], h);\n    }, SHA256.prototype._digest = function(enc) {\n      return enc === \"hex\" \? utils.toHex32(this.h, \"big\") : utils.split32(this.h, \"big\");\n    };\n  }\n}), require__3 = __commonJS({\n  \"node_modules/hash.js/lib/hash/sha/224.js\"(exports, module) {\n    var utils = require_utils4(), SHA256 = require__2();\n    function SHA224() {\n      if (!(this instanceof SHA224))\n        return new SHA224;\n      SHA256.call(this), this.h = [3238371032, 914150663, 812702999, 4144912697, 4290775857, 1750603025, 1694076839, 3204075428];\n    }\n    utils.inherits(SHA224, SHA256), module.exports = SHA224, SHA224.blockSize = 512, SHA224.outSize = 224, SHA224.hmacStrength = 192, SHA224.padLength = 64, SHA224.prototype._digest = function(enc) {\n      return enc === \"hex\" \? utils.toHex32(this.h.slice(0, 7), \"big\") : utils.split32(this.h.slice(0, 7), \"big\");\n    };\n  }\n}), require__4 = __commonJS({\n  \"node_modules/hash.js/lib/hash/sha/512.js\"(exports, module) {\n    var utils = require_utils4(), common = require_common(), assert = require_minimalistic_assert(), rotr64_hi = utils.rotr64_hi, rotr64_lo = utils.rotr64_lo, shr64_hi = utils.shr64_hi, shr64_lo = utils.shr64_lo, sum64 = utils.sum64, sum64_hi = utils.sum64_hi, sum64_lo = utils.sum64_lo, sum64_4_hi = utils.sum64_4_hi, sum64_4_lo = utils.sum64_4_lo, sum64_5_hi = utils.sum64_5_hi, sum64_5_lo = utils.sum64_5_lo, BlockHash = common.BlockHash, sha512_K = [\n      1116352408,\n      3609767458,\n      1899447441,\n      602891725,\n      3049323471,\n      3964484399,\n      3921009573,\n      2173295548,\n      961987163,\n      4081628472,\n      1508970993,\n      3053834265,\n      2453635748,\n      2937671579,\n      2870763221,\n      3664609560,\n      3624381080,\n      2734883394,\n      310598401,\n      1164996542,\n      607225278,\n      1323610764,\n      1426881987,\n      3590304994,\n      1925078388,\n      4068182383,\n      2162078206,\n      991336113,\n      2614888103,\n      633803317,\n      3248222580,\n      3479774868,\n      3835390401,\n      2666613458,\n      4022224774,\n      944711139,\n      264347078,\n      2341262773,\n      604807628,\n      2007800933,\n      770255983,\n      1495990901,\n      1249150122,\n      1856431235,\n      1555081692,\n      3175218132,\n      1996064986,\n      2198950837,\n      2554220882,\n      3999719339,\n      2821834349,\n      766784016,\n      2952996808,\n      2566594879,\n      3210313671,\n      3203337956,\n      3336571891,\n      1034457026,\n      3584528711,\n      2466948901,\n      113926993,\n      3758326383,\n      338241895,\n      168717936,\n      666307205,\n      1188179964,\n      773529912,\n      1546045734,\n      1294757372,\n      1522805485,\n      1396182291,\n      2643833823,\n      1695183700,\n      2343527390,\n      1986661051,\n      1014477480,\n      2177026350,\n      1206759142,\n      2456956037,\n      344077627,\n      2730485921,\n      1290863460,\n      2820302411,\n      3158454273,\n      3259730800,\n      3505952657,\n      3345764771,\n      106217008,\n      3516065817,\n      3606008344,\n      3600352804,\n      1432725776,\n      4094571909,\n      1467031594,\n      275423344,\n      851169720,\n      430227734,\n      3100823752,\n      506948616,\n      1363258195,\n      659060556,\n      3750685593,\n      883997877,\n      3785050280,\n      958139571,\n      3318307427,\n      1322822218,\n      3812723403,\n      1537002063,\n      2003034995,\n      1747873779,\n      3602036899,\n      1955562222,\n      1575990012,\n      2024104815,\n      1125592928,\n      2227730452,\n      2716904306,\n      2361852424,\n      442776044,\n      2428436474,\n      593698344,\n      2756734187,\n      3733110249,\n      3204031479,\n      2999351573,\n      3329325298,\n      3815920427,\n      3391569614,\n      3928383900,\n      3515267271,\n      566280711,\n      3940187606,\n      3454069534,\n      4118630271,\n      4000239992,\n      116418474,\n      1914138554,\n      174292421,\n      2731055270,\n      289380356,\n      3203993006,\n      460393269,\n      320620315,\n      685471733,\n      587496836,\n      852142971,\n      1086792851,\n      1017036298,\n      365543100,\n      1126000580,\n      2618297676,\n      1288033470,\n      3409855158,\n      1501505948,\n      4234509866,\n      1607167915,\n      987167468,\n      1816402316,\n      1246189591\n    ];\n    function SHA512() {\n      if (!(this instanceof SHA512))\n        return new SHA512;\n      BlockHash.call(this), this.h = [\n        1779033703,\n        4089235720,\n        3144134277,\n        2227873595,\n        1013904242,\n        4271175723,\n        2773480762,\n        1595750129,\n        1359893119,\n        2917565137,\n        2600822924,\n        725511199,\n        528734635,\n        4215389547,\n        1541459225,\n        327033209\n      ], this.k = sha512_K, this.W = new Array(160);\n    }\n    utils.inherits(SHA512, BlockHash), module.exports = SHA512, SHA512.blockSize = 1024, SHA512.outSize = 512, SHA512.hmacStrength = 192, SHA512.padLength = 128, SHA512.prototype._prepareBlock = function(msg, start) {\n      for (var W = this.W, i = 0;i < 32; i++)\n        W[i] = msg[start + i];\n      for (;i < W.length; i += 2) {\n        var c0_hi = g1_512_hi(W[i - 4], W[i - 3]), c0_lo = g1_512_lo(W[i - 4], W[i - 3]), c1_hi = W[i - 14], c1_lo = W[i - 13], c2_hi = g0_512_hi(W[i - 30], W[i - 29]), c2_lo = g0_512_lo(W[i - 30], W[i - 29]), c3_hi = W[i - 32], c3_lo = W[i - 31];\n        W[i] = sum64_4_hi(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo), W[i + 1] = sum64_4_lo(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo);\n      }\n    }, SHA512.prototype._update = function(msg, start) {\n      this._prepareBlock(msg, start);\n      var W = this.W, ah = this.h[0], al = this.h[1], bh = this.h[2], bl = this.h[3], ch = this.h[4], cl = this.h[5], dh = this.h[6], dl = this.h[7], eh = this.h[8], el = this.h[9], fh = this.h[10], fl = this.h[11], gh = this.h[12], gl = this.h[13], hh = this.h[14], hl = this.h[15];\n      assert(this.k.length === W.length);\n      for (var i = 0;i < W.length; i += 2) {\n        var c0_hi = hh, c0_lo = hl, c1_hi = s1_512_hi(eh, el), c1_lo = s1_512_lo(eh, el), c2_hi = ch64_hi(eh, el, fh, fl, gh, gl), c2_lo = ch64_lo(eh, el, fh, fl, gh, gl), c3_hi = this.k[i], c3_lo = this.k[i + 1], c4_hi = W[i], c4_lo = W[i + 1], T1_hi = sum64_5_hi(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo, c4_hi, c4_lo), T1_lo = sum64_5_lo(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo, c4_hi, c4_lo);\n        c0_hi = s0_512_hi(ah, al), c0_lo = s0_512_lo(ah, al), c1_hi = maj64_hi(ah, al, bh, bl, ch, cl), c1_lo = maj64_lo(ah, al, bh, bl, ch, cl);\n        var T2_hi = sum64_hi(c0_hi, c0_lo, c1_hi, c1_lo), T2_lo = sum64_lo(c0_hi, c0_lo, c1_hi, c1_lo);\n        hh = gh, hl = gl, gh = fh, gl = fl, fh = eh, fl = el, eh = sum64_hi(dh, dl, T1_hi, T1_lo), el = sum64_lo(dl, dl, T1_hi, T1_lo), dh = ch, dl = cl, ch = bh, cl = bl, bh = ah, bl = al, ah = sum64_hi(T1_hi, T1_lo, T2_hi, T2_lo), al = sum64_lo(T1_hi, T1_lo, T2_hi, T2_lo);\n      }\n      sum64(this.h, 0, ah, al), sum64(this.h, 2, bh, bl), sum64(this.h, 4, ch, cl), sum64(this.h, 6, dh, dl), sum64(this.h, 8, eh, el), sum64(this.h, 10, fh, fl), sum64(this.h, 12, gh, gl), sum64(this.h, 14, hh, hl);\n    }, SHA512.prototype._digest = function(enc) {\n      return enc === \"hex\" \? utils.toHex32(this.h, \"big\") : utils.split32(this.h, \"big\");\n    };\n    function ch64_hi(xh, xl, yh, yl, zh) {\n      var r = xh & yh ^ ~xh & zh;\n      return r < 0 && (r += 4294967296), r;\n    }\n    function ch64_lo(xh, xl, yh, yl, zh, zl) {\n      var r = xl & yl ^ ~xl & zl;\n      return r < 0 && (r += 4294967296), r;\n    }\n    function maj64_hi(xh, xl, yh, yl, zh) {\n      var r = xh & yh ^ xh & zh ^ yh & zh;\n      return r < 0 && (r += 4294967296), r;\n    }\n    function maj64_lo(xh, xl, yh, yl, zh, zl) {\n      var r = xl & yl ^ xl & zl ^ yl & zl;\n      return r < 0 && (r += 4294967296), r;\n    }\n    function s0_512_hi(xh, xl) {\n      var c0_hi = rotr64_hi(xh, xl, 28), c1_hi = rotr64_hi(xl, xh, 2), c2_hi = rotr64_hi(xl, xh, 7), r = c0_hi ^ c1_hi ^ c2_hi;\n      return r < 0 && (r += 4294967296), r;\n    }\n    function s0_512_lo(xh, xl) {\n      var c0_lo = rotr64_lo(xh, xl, 28), c1_lo = rotr64_lo(xl, xh, 2), c2_lo = rotr64_lo(xl, xh, 7), r = c0_lo ^ c1_lo ^ c2_lo;\n      return r < 0 && (r += 4294967296), r;\n    }\n    function s1_512_hi(xh, xl) {\n      var c0_hi = rotr64_hi(xh, xl, 14), c1_hi = rotr64_hi(xh, xl, 18), c2_hi = rotr64_hi(xl, xh, 9), r = c0_hi ^ c1_hi ^ c2_hi;\n      return r < 0 && (r += 4294967296), r;\n    }\n    function s1_512_lo(xh, xl) {\n      var c0_lo = rotr64_lo(xh, xl, 14), c1_lo = rotr64_lo(xh, xl, 18), c2_lo = rotr64_lo(xl, xh, 9), r = c0_lo ^ c1_lo ^ c2_lo;\n      return r < 0 && (r += 4294967296), r;\n    }\n    function g0_512_hi(xh, xl) {\n      var c0_hi = rotr64_hi(xh, xl, 1), c1_hi = rotr64_hi(xh, xl, 8), c2_hi = shr64_hi(xh, xl, 7), r = c0_hi ^ c1_hi ^ c2_hi;\n      return r < 0 && (r += 4294967296), r;\n    }\n    function g0_512_lo(xh, xl) {\n      var c0_lo = rotr64_lo(xh, xl, 1), c1_lo = rotr64_lo(xh, xl, 8), c2_lo = shr64_lo(xh, xl, 7), r = c0_lo ^ c1_lo ^ c2_lo;\n      return r < 0 && (r += 4294967296), r;\n    }\n    function g1_512_hi(xh, xl) {\n      var c0_hi = rotr64_hi(xh, xl, 19), c1_hi = rotr64_hi(xl, xh, 29), c2_hi = shr64_hi(xh, xl, 6), r = c0_hi ^ c1_hi ^ c2_hi;\n      return r < 0 && (r += 4294967296), r;\n    }\n    function g1_512_lo(xh, xl) {\n      var c0_lo = rotr64_lo(xh, xl, 19), c1_lo = rotr64_lo(xl, xh, 29), c2_lo = shr64_lo(xh, xl, 6), r = c0_lo ^ c1_lo ^ c2_lo;\n      return r < 0 && (r += 4294967296), r;\n    }\n  }\n}), require__5 = __commonJS({\n  \"node_modules/hash.js/lib/hash/sha/384.js\"(exports, module) {\n    var utils = require_utils4(), SHA512 = require__4();\n    function SHA384() {\n      if (!(this instanceof SHA384))\n        return new SHA384;\n      SHA512.call(this), this.h = [\n        3418070365,\n        3238371032,\n        1654270250,\n        914150663,\n        2438529370,\n        812702999,\n        355462360,\n        4144912697,\n        1731405415,\n        4290775857,\n        2394180231,\n        1750603025,\n        3675008525,\n        1694076839,\n        1203062813,\n        3204075428\n      ];\n    }\n    utils.inherits(SHA384, SHA512), module.exports = SHA384, SHA384.blockSize = 1024, SHA384.outSize = 384, SHA384.hmacStrength = 192, SHA384.padLength = 128, SHA384.prototype._digest = function(enc) {\n      return enc === \"hex\" \? utils.toHex32(this.h.slice(0, 12), \"big\") : utils.split32(this.h.slice(0, 12), \"big\");\n    };\n  }\n}), require_sha3 = __commonJS({\n  \"node_modules/hash.js/lib/hash/sha.js\"(exports) {\n    exports.sha1 = require__(), exports.sha224 = require__3(), exports.sha256 = require__2(), exports.sha384 = require__5(), exports.sha512 = require__4();\n  }\n}), require_ripemd = __commonJS({\n  \"node_modules/hash.js/lib/hash/ripemd.js\"(exports) {\n    var utils = require_utils4(), common = require_common(), rotl32 = utils.rotl32, sum32 = utils.sum32, sum32_3 = utils.sum32_3, sum32_4 = utils.sum32_4, BlockHash = common.BlockHash;\n    function RIPEMD160() {\n      if (!(this instanceof RIPEMD160))\n        return new RIPEMD160;\n      BlockHash.call(this), this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.endian = \"little\";\n    }\n    utils.inherits(RIPEMD160, BlockHash), exports.ripemd160 = RIPEMD160, RIPEMD160.blockSize = 512, RIPEMD160.outSize = 160, RIPEMD160.hmacStrength = 192, RIPEMD160.padLength = 64, RIPEMD160.prototype._update = function(msg, start) {\n      for (var A = this.h[0], B = this.h[1], C = this.h[2], D = this.h[3], E = this.h[4], Ah = A, Bh = B, Ch = C, Dh = D, Eh = E, j = 0;j < 80; j++) {\n        var T = sum32(rotl32(sum32_4(A, f(j, B, C, D), msg[r[j] + start], K(j)), s[j]), E);\n        A = E, E = D, D = rotl32(C, 10), C = B, B = T, T = sum32(rotl32(sum32_4(Ah, f(79 - j, Bh, Ch, Dh), msg[rh[j] + start], Kh(j)), sh[j]), Eh), Ah = Eh, Eh = Dh, Dh = rotl32(Ch, 10), Ch = Bh, Bh = T;\n      }\n      T = sum32_3(this.h[1], C, Dh), this.h[1] = sum32_3(this.h[2], D, Eh), this.h[2] = sum32_3(this.h[3], E, Ah), this.h[3] = sum32_3(this.h[4], A, Bh), this.h[4] = sum32_3(this.h[0], B, Ch), this.h[0] = T;\n    }, RIPEMD160.prototype._digest = function(enc) {\n      return enc === \"hex\" \? utils.toHex32(this.h, \"little\") : utils.split32(this.h, \"little\");\n    };\n    function f(j, x, y, z) {\n      return j <= 15 \? x ^ y ^ z : j <= 31 \? x & y | ~x & z : j <= 47 \? (x | ~y) ^ z : j <= 63 \? x & z | y & ~z : x ^ (y | ~z);\n    }\n    function K(j) {\n      return j <= 15 \? 0 : j <= 31 \? 1518500249 : j <= 47 \? 1859775393 : j <= 63 \? 2400959708 : 2840853838;\n    }\n    function Kh(j) {\n      return j <= 15 \? 1352829926 : j <= 31 \? 1548603684 : j <= 47 \? 1836072691 : j <= 63 \? 2053994217 : 0;\n    }\n    var r = [\n      0,\n      1,\n      2,\n      3,\n      4,\n      5,\n      6,\n      7,\n      8,\n      9,\n      10,\n      11,\n      12,\n      13,\n      14,\n      15,\n      7,\n      4,\n      13,\n      1,\n      10,\n      6,\n      15,\n      3,\n      12,\n      0,\n      9,\n      5,\n      2,\n      14,\n      11,\n      8,\n      3,\n      10,\n      14,\n      4,\n      9,\n      15,\n      8,\n      1,\n      2,\n      7,\n      0,\n      6,\n      13,\n      11,\n      5,\n      12,\n      1,\n      9,\n      11,\n      10,\n      0,\n      8,\n      12,\n      4,\n      13,\n      3,\n      7,\n      15,\n      14,\n      5,\n      6,\n      2,\n      4,\n      0,\n      5,\n      9,\n      7,\n      12,\n      2,\n      10,\n      14,\n      1,\n      3,\n      8,\n      11,\n      6,\n      15,\n      13\n    ], rh = [\n      5,\n      14,\n      7,\n      0,\n      9,\n      2,\n      11,\n      4,\n      13,\n      6,\n      15,\n      8,\n      1,\n      10,\n      3,\n      12,\n      6,\n      11,\n      3,\n      7,\n      0,\n      13,\n      5,\n      10,\n      14,\n      15,\n      8,\n      12,\n      4,\n      9,\n      1,\n      2,\n      15,\n      5,\n      1,\n      3,\n      7,\n      14,\n      6,\n      9,\n      11,\n      8,\n      12,\n      2,\n      10,\n      0,\n      4,\n      13,\n      8,\n      6,\n      4,\n      1,\n      3,\n      11,\n      15,\n      0,\n      5,\n      12,\n      2,\n      13,\n      9,\n      7,\n      10,\n      14,\n      12,\n      15,\n      10,\n      4,\n      1,\n      5,\n      8,\n      7,\n      6,\n      2,\n      13,\n      14,\n      0,\n      3,\n      9,\n      11\n    ], s = [\n      11,\n      14,\n      15,\n      12,\n      5,\n      8,\n      7,\n      9,\n      11,\n      13,\n      14,\n      15,\n      6,\n      7,\n      9,\n      8,\n      7,\n      6,\n      8,\n      13,\n      11,\n      9,\n      7,\n      15,\n      7,\n      12,\n      15,\n      9,\n      11,\n      7,\n      13,\n      12,\n      11,\n      13,\n      6,\n      7,\n      14,\n      9,\n      13,\n      15,\n      14,\n      8,\n      13,\n      6,\n      5,\n      12,\n      7,\n      5,\n      11,\n      12,\n      14,\n      15,\n      14,\n      15,\n      9,\n      8,\n      9,\n      14,\n      5,\n      6,\n      8,\n      6,\n      5,\n      12,\n      9,\n      15,\n      5,\n      11,\n      6,\n      8,\n      13,\n      12,\n      5,\n      12,\n      13,\n      14,\n      11,\n      8,\n      5,\n      6\n    ], sh = [\n      8,\n      9,\n      9,\n      11,\n      13,\n      15,\n      15,\n      5,\n      7,\n      7,\n      8,\n      11,\n      14,\n      14,\n      12,\n      6,\n      9,\n      13,\n      15,\n      7,\n      12,\n      8,\n      9,\n      11,\n      7,\n      7,\n      12,\n      7,\n      6,\n      15,\n      13,\n      11,\n      9,\n      7,\n      15,\n      11,\n      8,\n      6,\n      6,\n      14,\n      12,\n      13,\n      5,\n      14,\n      13,\n      13,\n      7,\n      5,\n      15,\n      5,\n      8,\n      11,\n      14,\n      14,\n      6,\n      14,\n      6,\n      9,\n      12,\n      9,\n      12,\n      5,\n      15,\n      8,\n      8,\n      5,\n      12,\n      9,\n      12,\n      5,\n      14,\n      6,\n      8,\n      13,\n      6,\n      5,\n      15,\n      13,\n      11,\n      11\n    ];\n  }\n}), require_hmac = __commonJS({\n  \"node_modules/hash.js/lib/hash/hmac.js\"(exports, module) {\n    var utils = require_utils4(), assert = require_minimalistic_assert();\n    function Hmac(hash, key, enc) {\n      if (!(this instanceof Hmac))\n        return new Hmac(hash, key, enc);\n      this.Hash = hash, this.blockSize = hash.blockSize / 8, this.outSize = hash.outSize / 8, this.inner = null, this.outer = null, this._init(utils.toArray(key, enc));\n    }\n    Hmac.prototype = {}, module.exports = Hmac, Hmac.prototype._init = function(key) {\n      key.length > this.blockSize && (key = new this.Hash().update(key).digest()), assert(key.length <= this.blockSize);\n      for (var i = key.length;i < this.blockSize; i++)\n        key.push(0);\n      for (i = 0;i < key.length; i++)\n        key[i] ^= 54;\n      for (this.inner = new this.Hash().update(key), i = 0;i < key.length; i++)\n        key[i] ^= 106;\n      this.outer = new this.Hash().update(key);\n    }, Hmac.prototype.update = function(msg, enc) {\n      return this.inner.update(msg, enc), this;\n    }, Hmac.prototype.digest = function(enc) {\n      return this.outer.update(this.inner.digest()), this.outer.digest(enc);\n    };\n  }\n}), require_hash2 = __commonJS({\n  \"node_modules/hash.js/lib/hash.js\"(exports) {\n    var hash = exports;\n    hash.utils = require_utils4(), hash.common = require_common(), hash.sha = require_sha3(), hash.ripemd = require_ripemd(), hash.hmac = require_hmac(), hash.sha1 = hash.sha.sha1, hash.sha256 = hash.sha.sha256, hash.sha224 = hash.sha.sha224, hash.sha384 = hash.sha.sha384, hash.sha512 = hash.sha.sha512, hash.ripemd160 = hash.ripemd.ripemd160;\n  }\n}), require_secp256k1 = __commonJS({\n  \"node_modules/elliptic/lib/elliptic/precomputed/secp256k1.js\"(exports, module) {\n    module.exports = {\n      doubles: {\n        step: 4,\n        points: [\n          [\n            \"e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a\",\n            \"f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821\"\n          ],\n          [\n            \"8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508\",\n            \"11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf\"\n          ],\n          [\n            \"175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739\",\n            \"d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695\"\n          ],\n          [\n            \"363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640\",\n            \"4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9\"\n          ],\n          [\n            \"8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c\",\n            \"4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36\"\n          ],\n          [\n            \"723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda\",\n            \"96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f\"\n          ],\n          [\n            \"eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa\",\n            \"5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999\"\n          ],\n          [\n            \"100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0\",\n            \"cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09\"\n          ],\n          [\n            \"e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d\",\n            \"9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d\"\n          ],\n          [\n            \"feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d\",\n            \"e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088\"\n          ],\n          [\n            \"da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1\",\n            \"9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d\"\n          ],\n          [\n            \"53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0\",\n            \"5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8\"\n          ],\n          [\n            \"8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047\",\n            \"10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a\"\n          ],\n          [\n            \"385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862\",\n            \"283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453\"\n          ],\n          [\n            \"6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7\",\n            \"7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160\"\n          ],\n          [\n            \"3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd\",\n            \"56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0\"\n          ],\n          [\n            \"85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83\",\n            \"7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6\"\n          ],\n          [\n            \"948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a\",\n            \"53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589\"\n          ],\n          [\n            \"6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8\",\n            \"bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17\"\n          ],\n          [\n            \"e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d\",\n            \"4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda\"\n          ],\n          [\n            \"e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725\",\n            \"7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd\"\n          ],\n          [\n            \"213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754\",\n            \"4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2\"\n          ],\n          [\n            \"4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c\",\n            \"17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6\"\n          ],\n          [\n            \"fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6\",\n            \"6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f\"\n          ],\n          [\n            \"76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39\",\n            \"c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01\"\n          ],\n          [\n            \"c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891\",\n            \"893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3\"\n          ],\n          [\n            \"d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b\",\n            \"febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f\"\n          ],\n          [\n            \"b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03\",\n            \"2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7\"\n          ],\n          [\n            \"e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d\",\n            \"eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78\"\n          ],\n          [\n            \"a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070\",\n            \"7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1\"\n          ],\n          [\n            \"90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4\",\n            \"e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150\"\n          ],\n          [\n            \"8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da\",\n            \"662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82\"\n          ],\n          [\n            \"e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11\",\n            \"1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc\"\n          ],\n          [\n            \"8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e\",\n            \"efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b\"\n          ],\n          [\n            \"e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41\",\n            \"2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51\"\n          ],\n          [\n            \"b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef\",\n            \"67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45\"\n          ],\n          [\n            \"d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8\",\n            \"db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120\"\n          ],\n          [\n            \"324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d\",\n            \"648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84\"\n          ],\n          [\n            \"4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96\",\n            \"35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d\"\n          ],\n          [\n            \"9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd\",\n            \"ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d\"\n          ],\n          [\n            \"6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5\",\n            \"9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8\"\n          ],\n          [\n            \"a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266\",\n            \"40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8\"\n          ],\n          [\n            \"7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71\",\n            \"34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac\"\n          ],\n          [\n            \"928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac\",\n            \"c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f\"\n          ],\n          [\n            \"85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751\",\n            \"1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962\"\n          ],\n          [\n            \"ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e\",\n            \"493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907\"\n          ],\n          [\n            \"827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241\",\n            \"c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec\"\n          ],\n          [\n            \"eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3\",\n            \"be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d\"\n          ],\n          [\n            \"e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f\",\n            \"4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414\"\n          ],\n          [\n            \"1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19\",\n            \"aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd\"\n          ],\n          [\n            \"146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be\",\n            \"b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0\"\n          ],\n          [\n            \"fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9\",\n            \"6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811\"\n          ],\n          [\n            \"da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2\",\n            \"8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1\"\n          ],\n          [\n            \"a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13\",\n            \"7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c\"\n          ],\n          [\n            \"174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c\",\n            \"ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73\"\n          ],\n          [\n            \"959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba\",\n            \"2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd\"\n          ],\n          [\n            \"d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151\",\n            \"e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405\"\n          ],\n          [\n            \"64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073\",\n            \"d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589\"\n          ],\n          [\n            \"8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458\",\n            \"38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e\"\n          ],\n          [\n            \"13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b\",\n            \"69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27\"\n          ],\n          [\n            \"bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366\",\n            \"d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1\"\n          ],\n          [\n            \"8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa\",\n            \"40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482\"\n          ],\n          [\n            \"8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0\",\n            \"620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945\"\n          ],\n          [\n            \"dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787\",\n            \"7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573\"\n          ],\n          [\n            \"f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e\",\n            \"ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82\"\n          ]\n        ]\n      },\n      naf: {\n        wnd: 7,\n        points: [\n          [\n            \"f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9\",\n            \"388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672\"\n          ],\n          [\n            \"2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4\",\n            \"d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6\"\n          ],\n          [\n            \"5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc\",\n            \"6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da\"\n          ],\n          [\n            \"acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe\",\n            \"cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37\"\n          ],\n          [\n            \"774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb\",\n            \"d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b\"\n          ],\n          [\n            \"f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8\",\n            \"ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81\"\n          ],\n          [\n            \"d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e\",\n            \"581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58\"\n          ],\n          [\n            \"defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34\",\n            \"4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77\"\n          ],\n          [\n            \"2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c\",\n            \"85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a\"\n          ],\n          [\n            \"352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5\",\n            \"321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c\"\n          ],\n          [\n            \"2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f\",\n            \"2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67\"\n          ],\n          [\n            \"9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714\",\n            \"73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402\"\n          ],\n          [\n            \"daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729\",\n            \"a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55\"\n          ],\n          [\n            \"c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db\",\n            \"2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482\"\n          ],\n          [\n            \"6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4\",\n            \"e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82\"\n          ],\n          [\n            \"1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5\",\n            \"b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396\"\n          ],\n          [\n            \"605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479\",\n            \"2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49\"\n          ],\n          [\n            \"62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d\",\n            \"80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf\"\n          ],\n          [\n            \"80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f\",\n            \"1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a\"\n          ],\n          [\n            \"7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb\",\n            \"d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7\"\n          ],\n          [\n            \"d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9\",\n            \"eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933\"\n          ],\n          [\n            \"49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963\",\n            \"758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a\"\n          ],\n          [\n            \"77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74\",\n            \"958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6\"\n          ],\n          [\n            \"f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530\",\n            \"e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37\"\n          ],\n          [\n            \"463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b\",\n            \"5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e\"\n          ],\n          [\n            \"f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247\",\n            \"cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6\"\n          ],\n          [\n            \"caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1\",\n            \"cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476\"\n          ],\n          [\n            \"2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120\",\n            \"4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40\"\n          ],\n          [\n            \"7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435\",\n            \"91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61\"\n          ],\n          [\n            \"754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18\",\n            \"673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683\"\n          ],\n          [\n            \"e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8\",\n            \"59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5\"\n          ],\n          [\n            \"186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb\",\n            \"3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b\"\n          ],\n          [\n            \"df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f\",\n            \"55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417\"\n          ],\n          [\n            \"5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143\",\n            \"efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868\"\n          ],\n          [\n            \"290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba\",\n            \"e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a\"\n          ],\n          [\n            \"af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45\",\n            \"f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6\"\n          ],\n          [\n            \"766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a\",\n            \"744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996\"\n          ],\n          [\n            \"59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e\",\n            \"c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e\"\n          ],\n          [\n            \"f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8\",\n            \"e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d\"\n          ],\n          [\n            \"7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c\",\n            \"30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2\"\n          ],\n          [\n            \"948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519\",\n            \"e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e\"\n          ],\n          [\n            \"7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab\",\n            \"100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437\"\n          ],\n          [\n            \"3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca\",\n            \"ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311\"\n          ],\n          [\n            \"d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf\",\n            \"8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4\"\n          ],\n          [\n            \"1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610\",\n            \"68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575\"\n          ],\n          [\n            \"733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4\",\n            \"f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d\"\n          ],\n          [\n            \"15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c\",\n            \"d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d\"\n          ],\n          [\n            \"a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940\",\n            \"edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629\"\n          ],\n          [\n            \"e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980\",\n            \"a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06\"\n          ],\n          [\n            \"311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3\",\n            \"66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374\"\n          ],\n          [\n            \"34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf\",\n            \"9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee\"\n          ],\n          [\n            \"f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63\",\n            \"4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1\"\n          ],\n          [\n            \"d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448\",\n            \"fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b\"\n          ],\n          [\n            \"32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf\",\n            \"5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661\"\n          ],\n          [\n            \"7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5\",\n            \"8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6\"\n          ],\n          [\n            \"ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6\",\n            \"8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e\"\n          ],\n          [\n            \"16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5\",\n            \"5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d\"\n          ],\n          [\n            \"eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99\",\n            \"f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc\"\n          ],\n          [\n            \"78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51\",\n            \"f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4\"\n          ],\n          [\n            \"494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5\",\n            \"42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c\"\n          ],\n          [\n            \"a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5\",\n            \"204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b\"\n          ],\n          [\n            \"c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997\",\n            \"4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913\"\n          ],\n          [\n            \"841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881\",\n            \"73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154\"\n          ],\n          [\n            \"5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5\",\n            \"39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865\"\n          ],\n          [\n            \"36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66\",\n            \"d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc\"\n          ],\n          [\n            \"336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726\",\n            \"ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224\"\n          ],\n          [\n            \"8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede\",\n            \"6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e\"\n          ],\n          [\n            \"1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94\",\n            \"60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6\"\n          ],\n          [\n            \"85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31\",\n            \"3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511\"\n          ],\n          [\n            \"29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51\",\n            \"b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b\"\n          ],\n          [\n            \"a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252\",\n            \"ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2\"\n          ],\n          [\n            \"4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5\",\n            \"cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c\"\n          ],\n          [\n            \"d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b\",\n            \"6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3\"\n          ],\n          [\n            \"ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4\",\n            \"322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d\"\n          ],\n          [\n            \"af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f\",\n            \"6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700\"\n          ],\n          [\n            \"e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889\",\n            \"2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4\"\n          ],\n          [\n            \"591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246\",\n            \"b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196\"\n          ],\n          [\n            \"11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984\",\n            \"998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4\"\n          ],\n          [\n            \"3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a\",\n            \"b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257\"\n          ],\n          [\n            \"cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030\",\n            \"bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13\"\n          ],\n          [\n            \"c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197\",\n            \"6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096\"\n          ],\n          [\n            \"c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593\",\n            \"c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38\"\n          ],\n          [\n            \"a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef\",\n            \"21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f\"\n          ],\n          [\n            \"347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38\",\n            \"60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448\"\n          ],\n          [\n            \"da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a\",\n            \"49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a\"\n          ],\n          [\n            \"c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111\",\n            \"5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4\"\n          ],\n          [\n            \"4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502\",\n            \"7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437\"\n          ],\n          [\n            \"3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea\",\n            \"be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7\"\n          ],\n          [\n            \"cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26\",\n            \"8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d\"\n          ],\n          [\n            \"b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986\",\n            \"39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a\"\n          ],\n          [\n            \"d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e\",\n            \"62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54\"\n          ],\n          [\n            \"48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4\",\n            \"25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77\"\n          ],\n          [\n            \"dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda\",\n            \"ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517\"\n          ],\n          [\n            \"6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859\",\n            \"cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10\"\n          ],\n          [\n            \"e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f\",\n            \"f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125\"\n          ],\n          [\n            \"eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c\",\n            \"6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e\"\n          ],\n          [\n            \"13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942\",\n            \"fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1\"\n          ],\n          [\n            \"ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a\",\n            \"1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2\"\n          ],\n          [\n            \"b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80\",\n            \"5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423\"\n          ],\n          [\n            \"ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d\",\n            \"438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8\"\n          ],\n          [\n            \"8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1\",\n            \"cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758\"\n          ],\n          [\n            \"52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63\",\n            \"c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375\"\n          ],\n          [\n            \"e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352\",\n            \"6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d\"\n          ],\n          [\n            \"7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193\",\n            \"ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec\"\n          ],\n          [\n            \"5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00\",\n            \"9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0\"\n          ],\n          [\n            \"32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58\",\n            \"ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c\"\n          ],\n          [\n            \"e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7\",\n            \"d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4\"\n          ],\n          [\n            \"8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8\",\n            \"c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f\"\n          ],\n          [\n            \"4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e\",\n            \"67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649\"\n          ],\n          [\n            \"3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d\",\n            \"cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826\"\n          ],\n          [\n            \"674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b\",\n            \"299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5\"\n          ],\n          [\n            \"d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f\",\n            \"f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87\"\n          ],\n          [\n            \"30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6\",\n            \"462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b\"\n          ],\n          [\n            \"be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297\",\n            \"62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc\"\n          ],\n          [\n            \"93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a\",\n            \"7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c\"\n          ],\n          [\n            \"b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c\",\n            \"ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f\"\n          ],\n          [\n            \"d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52\",\n            \"4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a\"\n          ],\n          [\n            \"d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb\",\n            \"bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46\"\n          ],\n          [\n            \"463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065\",\n            \"bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f\"\n          ],\n          [\n            \"7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917\",\n            \"603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03\"\n          ],\n          [\n            \"74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9\",\n            \"cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08\"\n          ],\n          [\n            \"30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3\",\n            \"553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8\"\n          ],\n          [\n            \"9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57\",\n            \"712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373\"\n          ],\n          [\n            \"176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66\",\n            \"ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3\"\n          ],\n          [\n            \"75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8\",\n            \"9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8\"\n          ],\n          [\n            \"809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721\",\n            \"9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1\"\n          ],\n          [\n            \"1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180\",\n            \"4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9\"\n          ]\n        ]\n      }\n    };\n  }\n}), require_curves = __commonJS({\n  \"node_modules/elliptic/lib/elliptic/curves.js\"(exports) {\n    var curves = exports, hash = require_hash2(), curve = require_curve(), utils = require_utils3(), assert = utils.assert;\n    function PresetCurve(options) {\n      options.type === \"short\" \? this.curve = new curve.short(options) : options.type === \"edwards\" \? this.curve = new curve.edwards(options) : this.curve = new curve.mont(options), this.g = this.curve.g, this.n = this.curve.n, this.hash = options.hash, assert(this.g.validate(), \"Invalid curve\"), assert(this.g.mul(this.n).isInfinity(), \"Invalid curve, G*N != O\");\n    }\n    curves.PresetCurve = PresetCurve;\n    function defineCurve(name, options) {\n      Object.defineProperty(curves, name, {\n        configurable: !0,\n        enumerable: !0,\n        get: function() {\n          var curve2 = new PresetCurve(options);\n          return Object.defineProperty(curves, name, {\n            configurable: !0,\n            enumerable: !0,\n            value: curve2\n          }), curve2;\n        }\n      });\n    }\n    defineCurve(\"p192\", {\n      type: \"short\",\n      prime: \"p192\",\n      p: \"ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff\",\n      a: \"ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc\",\n      b: \"64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1\",\n      n: \"ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831\",\n      hash: hash.sha256,\n      gRed: !1,\n      g: [\n        \"188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012\",\n        \"07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811\"\n      ]\n    }), defineCurve(\"p224\", {\n      type: \"short\",\n      prime: \"p224\",\n      p: \"ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001\",\n      a: \"ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe\",\n      b: \"b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4\",\n      n: \"ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d\",\n      hash: hash.sha256,\n      gRed: !1,\n      g: [\n        \"b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21\",\n        \"bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34\"\n      ]\n    }), defineCurve(\"p256\", {\n      type: \"short\",\n      prime: null,\n      p: \"ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff\",\n      a: \"ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc\",\n      b: \"5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b\",\n      n: \"ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551\",\n      hash: hash.sha256,\n      gRed: !1,\n      g: [\n        \"6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296\",\n        \"4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5\"\n      ]\n    }), defineCurve(\"p384\", {\n      type: \"short\",\n      prime: null,\n      p: \"ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff\",\n      a: \"ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc\",\n      b: \"b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef\",\n      n: \"ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973\",\n      hash: hash.sha384,\n      gRed: !1,\n      g: [\n        \"aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7\",\n        \"3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f\"\n      ]\n    }), defineCurve(\"p521\", {\n      type: \"short\",\n      prime: null,\n      p: \"000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff\",\n      a: \"000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc\",\n      b: \"00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00\",\n      n: \"000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409\",\n      hash: hash.sha512,\n      gRed: !1,\n      g: [\n        \"000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66\",\n        \"00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650\"\n      ]\n    }), defineCurve(\"curve25519\", {\n      type: \"mont\",\n      prime: \"p25519\",\n      p: \"7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed\",\n      a: \"76d06\",\n      b: \"1\",\n      n: \"1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed\",\n      hash: hash.sha256,\n      gRed: !1,\n      g: [\"9\"]\n    }), defineCurve(\"ed25519\", {\n      type: \"edwards\",\n      prime: \"p25519\",\n      p: \"7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed\",\n      a: \"-1\",\n      c: \"1\",\n      d: \"52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3\",\n      n: \"1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed\",\n      hash: hash.sha256,\n      gRed: !1,\n      g: [\n        \"216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a\",\n        \"6666666666666666666666666666666666666666666666666666666666666658\"\n      ]\n    });\n    var pre;\n    try {\n      pre = require_secp256k1();\n    } catch {\n      pre = void 0;\n    }\n    defineCurve(\"secp256k1\", {\n      type: \"short\",\n      prime: \"k256\",\n      p: \"ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f\",\n      a: \"0\",\n      b: \"7\",\n      n: \"ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141\",\n      h: \"1\",\n      hash: hash.sha256,\n      beta: \"7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\",\n      lambda: \"5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72\",\n      basis: [\n        {\n          a: \"3086d221a7d46bcde86c90e49284eb15\",\n          b: \"-e4437ed6010e88286f547fa90abfe4c3\"\n        },\n        {\n          a: \"114ca50f7a8e2f3f657c1108d9d44cfd8\",\n          b: \"3086d221a7d46bcde86c90e49284eb15\"\n        }\n      ],\n      gRed: !1,\n      g: [\n        \"79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798\",\n        \"483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8\",\n        pre\n      ]\n    });\n  }\n}), require_hmac_drbg = __commonJS({\n  \"node_modules/hmac-drbg/lib/hmac-drbg.js\"(exports, module) {\n    var hash = require_hash2(), utils = require_utils2(), assert = require_minimalistic_assert();\n    function HmacDRBG(options) {\n      if (!(this instanceof HmacDRBG))\n        return new HmacDRBG(options);\n      this.hash = options.hash, this.predResist = !!options.predResist, this.outLen = this.hash.outSize, this.minEntropy = options.minEntropy || this.hash.hmacStrength, this._reseed = null, this.reseedInterval = null, this.K = null, this.V = null;\n      var entropy = utils.toArray(options.entropy, options.entropyEnc || \"hex\"), nonce = utils.toArray(options.nonce, options.nonceEnc || \"hex\"), pers = utils.toArray(options.pers, options.persEnc || \"hex\");\n      assert(entropy.length >= this.minEntropy / 8, \"Not enough entropy. Minimum is: \" + this.minEntropy + \" bits\"), this._init(entropy, nonce, pers);\n    }\n    HmacDRBG.prototype = {}, module.exports = HmacDRBG, HmacDRBG.prototype._init = function(entropy, nonce, pers) {\n      var seed = entropy.concat(nonce).concat(pers);\n      this.K = new Array(this.outLen / 8), this.V = new Array(this.outLen / 8);\n      for (var i = 0;i < this.V.length; i++)\n        this.K[i] = 0, this.V[i] = 1;\n      this._update(seed), this._reseed = 1, this.reseedInterval = 281474976710656;\n    }, HmacDRBG.prototype._hmac = function() {\n      return new hash.hmac(this.hash, this.K);\n    }, HmacDRBG.prototype._update = function(seed) {\n      var kmac = this._hmac().update(this.V).update([0]);\n      seed && (kmac = kmac.update(seed)), this.K = kmac.digest(), this.V = this._hmac().update(this.V).digest(), seed && (this.K = this._hmac().update(this.V).update([1]).update(seed).digest(), this.V = this._hmac().update(this.V).digest());\n    }, HmacDRBG.prototype.reseed = function(entropy, entropyEnc, add, addEnc) {\n      typeof entropyEnc != \"string\" && (addEnc = add, add = entropyEnc, entropyEnc = null), entropy = utils.toArray(entropy, entropyEnc), add = utils.toArray(add, addEnc), assert(entropy.length >= this.minEntropy / 8, \"Not enough entropy. Minimum is: \" + this.minEntropy + \" bits\"), this._update(entropy.concat(add || [])), this._reseed = 1;\n    }, HmacDRBG.prototype.generate = function(len, enc, add, addEnc) {\n      if (this._reseed > this.reseedInterval)\n        throw new Error(\"Reseed is required\");\n      typeof enc != \"string\" && (addEnc = add, add = enc, enc = null), add && (add = utils.toArray(add, addEnc || \"hex\"), this._update(add));\n      for (var temp = [];temp.length < len; )\n        this.V = this._hmac().update(this.V).digest(), temp = temp.concat(this.V);\n      var res = temp.slice(0, len);\n      return this._update(add), this._reseed++, utils.encode(res, enc);\n    };\n  }\n}), require_key = __commonJS({\n  \"node_modules/elliptic/lib/elliptic/ec/key.js\"(exports, module) {\n    var BN = require_bn4(), utils = require_utils3(), assert = utils.assert;\n    function KeyPair(ec, options) {\n      this.ec = ec, this.priv = null, this.pub = null, options.priv && this._importPrivate(options.priv, options.privEnc), options.pub && this._importPublic(options.pub, options.pubEnc);\n    }\n    KeyPair.prototype = {}, module.exports = KeyPair, KeyPair.fromPublic = function(ec, pub, enc) {\n      return pub instanceof KeyPair \? pub : new KeyPair(ec, {\n        pub,\n        pubEnc: enc\n      });\n    }, KeyPair.fromPrivate = function(ec, priv, enc) {\n      return priv instanceof KeyPair \? priv : new KeyPair(ec, {\n        priv,\n        privEnc: enc\n      });\n    }, KeyPair.prototype.validate = function() {\n      var pub = this.getPublic();\n      return pub.isInfinity() \? { result: !1, reason: \"Invalid public key\" } : pub.validate() \? pub.mul(this.ec.curve.n).isInfinity() \? { result: !0, reason: null } : { result: !1, reason: \"Public key * N != O\" } : { result: !1, reason: \"Public key is not a point\" };\n    }, KeyPair.prototype.getPublic = function(compact, enc) {\n      return typeof compact == \"string\" && (enc = compact, compact = null), this.pub || (this.pub = this.ec.g.mul(this.priv)), enc \? this.pub.encode(enc, compact) : this.pub;\n    }, KeyPair.prototype.getPrivate = function(enc) {\n      return enc === \"hex\" \? this.priv.toString(16, 2) : this.priv;\n    }, KeyPair.prototype._importPrivate = function(key, enc) {\n      this.priv = new BN(key, enc || 16), this.priv = this.priv.umod(this.ec.curve.n);\n    }, KeyPair.prototype._importPublic = function(key, enc) {\n      if (key.x || key.y) {\n        this.ec.curve.type === \"mont\" \? assert(key.x, \"Need x coordinate\") : (this.ec.curve.type === \"short\" || this.ec.curve.type === \"edwards\") && assert(key.x && key.y, \"Need both x and y coordinate\"), this.pub = this.ec.curve.point(key.x, key.y);\n        return;\n      }\n      this.pub = this.ec.curve.decodePoint(key, enc);\n    }, KeyPair.prototype.derive = function(pub) {\n      return pub.validate() || assert(pub.validate(), \"public point not validated\"), pub.mul(this.priv).getX();\n    }, KeyPair.prototype.sign = function(msg, enc, options) {\n      return this.ec.sign(msg, this, enc, options);\n    }, KeyPair.prototype.verify = function(msg, signature) {\n      return this.ec.verify(msg, signature, this);\n    }, KeyPair.prototype.inspect = function() {\n      return \"<Key priv: \" + (this.priv && this.priv.toString(16, 2)) + \" pub: \" + (this.pub && this.pub.inspect()) + \" >\";\n    };\n  }\n}), require_signature = __commonJS({\n  \"node_modules/elliptic/lib/elliptic/ec/signature.js\"(exports, module) {\n    var BN = require_bn4(), utils = require_utils3(), assert = utils.assert;\n    function Signature(options, enc) {\n      if (options instanceof Signature)\n        return options;\n      this._importDER(options, enc) || (assert(options.r && options.s, \"Signature without r or s\"), this.r = new BN(options.r, 16), this.s = new BN(options.s, 16), options.recoveryParam === void 0 \? this.recoveryParam = null : this.recoveryParam = options.recoveryParam);\n    }\n    Signature.prototype = {}, module.exports = Signature;\n    function Position() {\n      this.place = 0;\n    }\n    function getLength(buf, p) {\n      var initial = buf[p.place++];\n      if (!(initial & 128))\n        return initial;\n      var octetLen = initial & 15;\n      if (octetLen === 0 || octetLen > 4)\n        return !1;\n      for (var val = 0, i = 0, off = p.place;i < octetLen; i++, off++)\n        val <<= 8, val |= buf[off], val >>>= 0;\n      return val <= 127 \? !1 : (p.place = off, val);\n    }\n    function rmPadding(buf) {\n      for (var i = 0, len = buf.length - 1;!buf[i] && !(buf[i + 1] & 128) && i < len; )\n        i++;\n      return i === 0 \? buf : buf.slice(i);\n    }\n    Signature.prototype._importDER = function(data, enc) {\n      data = utils.toArray(data, enc);\n      var p = new Position;\n      if (data[p.place++] !== 48)\n        return !1;\n      var len = getLength(data, p);\n      if (len === !1 || len + p.place !== data.length || data[p.place++] !== 2)\n        return !1;\n      var rlen = getLength(data, p);\n      if (rlen === !1)\n        return !1;\n      var r = data.slice(p.place, rlen + p.place);\n      if (p.place += rlen, data[p.place++] !== 2)\n        return !1;\n      var slen = getLength(data, p);\n      if (slen === !1 || data.length !== slen + p.place)\n        return !1;\n      var s = data.slice(p.place, slen + p.place);\n      if (r[0] === 0)\n        if (r[1] & 128)\n          r = r.slice(1);\n        else\n          return !1;\n      if (s[0] === 0)\n        if (s[1] & 128)\n          s = s.slice(1);\n        else\n          return !1;\n      return this.r = new BN(r), this.s = new BN(s), this.recoveryParam = null, !0;\n    };\n    function constructLength(arr, len) {\n      if (len < 128) {\n        arr.push(len);\n        return;\n      }\n      var octets = 1 + (Math.log(len) / Math.LN2 >>> 3);\n      for (arr.push(octets | 128);--octets; )\n        arr.push(len >>> (octets << 3) & 255);\n      arr.push(len);\n    }\n    Signature.prototype.toDER = function(enc) {\n      var r = this.r.toArray(), s = this.s.toArray();\n      for (r[0] & 128 && (r = [0].concat(r)), s[0] & 128 && (s = [0].concat(s)), r = rmPadding(r), s = rmPadding(s);!s[0] && !(s[1] & 128); )\n        s = s.slice(1);\n      var arr = [2];\n      constructLength(arr, r.length), arr = arr.concat(r), arr.push(2), constructLength(arr, s.length);\n      var backHalf = arr.concat(s), res = [48];\n      return constructLength(res, backHalf.length), res = res.concat(backHalf), utils.encode(res, enc);\n    };\n  }\n}), require_ec = __commonJS({\n  \"node_modules/elliptic/lib/elliptic/ec/index.js\"(exports, module) {\n    var BN = require_bn4(), HmacDRBG = require_hmac_drbg(), utils = require_utils3(), curves = require_curves(), rand = require_brorand(), assert = utils.assert, KeyPair = require_key(), Signature = require_signature();\n    function EC(options) {\n      if (!(this instanceof EC))\n        return new EC(options);\n      typeof options == \"string\" && (assert(Object.prototype.hasOwnProperty.call(curves, options), \"Unknown curve \" + options), options = curves[options]), options instanceof curves.PresetCurve && (options = { curve: options }), this.curve = options.curve.curve, this.n = this.curve.n, this.nh = this.n.ushrn(1), this.g = this.curve.g, this.g = options.curve.g, this.g.precompute(options.curve.n.bitLength() + 1), this.hash = options.hash || options.curve.hash;\n    }\n    EC.prototype = {}, module.exports = EC, EC.prototype.keyPair = function(options) {\n      return new KeyPair(this, options);\n    }, EC.prototype.keyFromPrivate = function(priv, enc) {\n      return KeyPair.fromPrivate(this, priv, enc);\n    }, EC.prototype.keyFromPublic = function(pub, enc) {\n      return KeyPair.fromPublic(this, pub, enc);\n    }, EC.prototype.genKeyPair = function(options) {\n      options || (options = {});\n      for (var drbg = new HmacDRBG({\n        hash: this.hash,\n        pers: options.pers,\n        persEnc: options.persEnc || \"utf8\",\n        entropy: options.entropy || rand(this.hash.hmacStrength),\n        entropyEnc: options.entropy && options.entropyEnc || \"utf8\",\n        nonce: this.n.toArray()\n      }), bytes = this.n.byteLength(), ns2 = this.n.sub(new BN(2));; ) {\n        var priv = new BN(drbg.generate(bytes));\n        if (!(priv.cmp(ns2) > 0))\n          return priv.iaddn(1), this.keyFromPrivate(priv);\n      }\n    }, EC.prototype._truncateToN = function(msg, truncOnly) {\n      var delta = msg.byteLength() * 8 - this.n.bitLength();\n      return delta > 0 && (msg = msg.ushrn(delta)), !truncOnly && msg.cmp(this.n) >= 0 \? msg.sub(this.n) : msg;\n    }, EC.prototype.sign = function(msg, key, enc, options) {\n      typeof enc == \"object\" && (options = enc, enc = null), options || (options = {}), key = this.keyFromPrivate(key, enc), msg = this._truncateToN(new BN(msg, 16));\n      for (var bytes = this.n.byteLength(), bkey = key.getPrivate().toArray(\"be\", bytes), nonce = msg.toArray(\"be\", bytes), drbg = new HmacDRBG({\n        hash: this.hash,\n        entropy: bkey,\n        nonce,\n        pers: options.pers,\n        persEnc: options.persEnc || \"utf8\"\n      }), ns1 = this.n.sub(new BN(1)), iter = 0;; iter++) {\n        var k = options.k \? options.k(iter) : new BN(drbg.generate(this.n.byteLength()));\n        if (k = this._truncateToN(k, !0), !(k.cmpn(1) <= 0 || k.cmp(ns1) >= 0)) {\n          var kp = this.g.mul(k);\n          if (!kp.isInfinity()) {\n            var kpX = kp.getX(), r = kpX.umod(this.n);\n            if (r.cmpn(0) !== 0) {\n              var s = k.invm(this.n).mul(r.mul(key.getPrivate()).iadd(msg));\n              if (s = s.umod(this.n), s.cmpn(0) !== 0) {\n                var recoveryParam = (kp.getY().isOdd() \? 1 : 0) | (kpX.cmp(r) !== 0 \? 2 : 0);\n                return options.canonical && s.cmp(this.nh) > 0 && (s = this.n.sub(s), recoveryParam ^= 1), new Signature({ r, s, recoveryParam });\n              }\n            }\n          }\n        }\n      }\n    }, EC.prototype.verify = function(msg, signature, key, enc) {\n      msg = this._truncateToN(new BN(msg, 16)), key = this.keyFromPublic(key, enc), signature = new Signature(signature, \"hex\");\n      var { r, s } = signature;\n      if (r.cmpn(1) < 0 || r.cmp(this.n) >= 0 || s.cmpn(1) < 0 || s.cmp(this.n) >= 0)\n        return !1;\n      var sinv = s.invm(this.n), u1 = sinv.mul(msg).umod(this.n), u2 = sinv.mul(r).umod(this.n), p;\n      return this.curve._maxwellTrick \? (p = this.g.jmulAdd(u1, key.getPublic(), u2), p.isInfinity() \? !1 : p.eqXToP(r)) : (p = this.g.mulAdd(u1, key.getPublic(), u2), p.isInfinity() \? !1 : p.getX().umod(this.n).cmp(r) === 0);\n    }, EC.prototype.recoverPubKey = function(msg, signature, j, enc) {\n      assert((3 & j) === j, \"The recovery param is more than two bits\"), signature = new Signature(signature, enc);\n      var n = this.n, e = new BN(msg), r = signature.r, s = signature.s, isYOdd = j & 1, isSecondKey = j >> 1;\n      if (r.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey)\n        throw new Error(\"Unable to find sencond key candinate\");\n      isSecondKey \? r = this.curve.pointFromX(r.add(this.curve.n), isYOdd) : r = this.curve.pointFromX(r, isYOdd);\n      var rInv = signature.r.invm(n), s1 = n.sub(e).mul(rInv).umod(n), s2 = s.mul(rInv).umod(n);\n      return this.g.mulAdd(s1, r, s2);\n    }, EC.prototype.getKeyRecoveryParam = function(e, signature, Q, enc) {\n      if (signature = new Signature(signature, enc), signature.recoveryParam !== null)\n        return signature.recoveryParam;\n      for (var i = 0;i < 4; i++) {\n        var Qprime;\n        try {\n          Qprime = this.recoverPubKey(e, signature, i);\n        } catch {\n          continue;\n        }\n        if (Qprime.eq(Q))\n          return i;\n      }\n      throw new Error(\"Unable to find valid recovery factor\");\n    };\n  }\n}), require_key2 = __commonJS({\n  \"node_modules/elliptic/lib/elliptic/eddsa/key.js\"(exports, module) {\n    var utils = require_utils3(), assert = utils.assert, parseBytes = utils.parseBytes, cachedProperty = utils.cachedProperty;\n    function KeyPair(eddsa, params) {\n      this.eddsa = eddsa, this._secret = parseBytes(params.secret), eddsa.isPoint(params.pub) \? this._pub = params.pub : this._pubBytes = parseBytes(params.pub);\n    }\n    KeyPair.prototype = {}, KeyPair.fromPublic = function(eddsa, pub) {\n      return pub instanceof KeyPair \? pub : new KeyPair(eddsa, { pub });\n    }, KeyPair.fromSecret = function(eddsa, secret) {\n      return secret instanceof KeyPair \? secret : new KeyPair(eddsa, { secret });\n    }, KeyPair.prototype.secret = function() {\n      return this._secret;\n    }, cachedProperty(KeyPair, \"pubBytes\", function() {\n      return this.eddsa.encodePoint(this.pub());\n    }), cachedProperty(KeyPair, \"pub\", function() {\n      return this._pubBytes \? this.eddsa.decodePoint(this._pubBytes) : this.eddsa.g.mul(this.priv());\n    }), cachedProperty(KeyPair, \"privBytes\", function() {\n      var eddsa = this.eddsa, hash = this.hash(), lastIx = eddsa.encodingLength - 1, a = hash.slice(0, eddsa.encodingLength);\n      return a[0] &= 248, a[lastIx] &= 127, a[lastIx] |= 64, a;\n    }), cachedProperty(KeyPair, \"priv\", function() {\n      return this.eddsa.decodeInt(this.privBytes());\n    }), cachedProperty(KeyPair, \"hash\", function() {\n      return this.eddsa.hash().update(this.secret()).digest();\n    }), cachedProperty(KeyPair, \"messagePrefix\", function() {\n      return this.hash().slice(this.eddsa.encodingLength);\n    }), KeyPair.prototype.sign = function(message) {\n      return assert(this._secret, \"KeyPair can only verify\"), this.eddsa.sign(message, this);\n    }, KeyPair.prototype.verify = function(message, sig) {\n      return this.eddsa.verify(message, sig, this);\n    }, KeyPair.prototype.getSecret = function(enc) {\n      return assert(this._secret, \"KeyPair is public only\"), utils.encode(this.secret(), enc);\n    }, KeyPair.prototype.getPublic = function(enc) {\n      return utils.encode(this.pubBytes(), enc);\n    }, module.exports = KeyPair;\n  }\n}), require_signature2 = __commonJS({\n  \"node_modules/elliptic/lib/elliptic/eddsa/signature.js\"(exports, module) {\n    var BN = require_bn4(), utils = require_utils3(), assert = utils.assert, cachedProperty = utils.cachedProperty, parseBytes = utils.parseBytes;\n    function Signature(eddsa, sig) {\n      this.eddsa = eddsa, typeof sig != \"object\" && (sig = parseBytes(sig)), Array.isArray(sig) && (sig = {\n        R: sig.slice(0, eddsa.encodingLength),\n        S: sig.slice(eddsa.encodingLength)\n      }), assert(sig.R && sig.S, \"Signature without R or S\"), eddsa.isPoint(sig.R) && (this._R = sig.R), sig.S instanceof BN && (this._S = sig.S), this._Rencoded = Array.isArray(sig.R) \? sig.R : sig.Rencoded, this._Sencoded = Array.isArray(sig.S) \? sig.S : sig.Sencoded;\n    }\n    Signature.prototype = {}, cachedProperty(Signature, \"S\", function() {\n      return this.eddsa.decodeInt(this.Sencoded());\n    }), cachedProperty(Signature, \"R\", function() {\n      return this.eddsa.decodePoint(this.Rencoded());\n    }), cachedProperty(Signature, \"Rencoded\", function() {\n      return this.eddsa.encodePoint(this.R());\n    }), cachedProperty(Signature, \"Sencoded\", function() {\n      return this.eddsa.encodeInt(this.S());\n    }), Signature.prototype.toBytes = function() {\n      return this.Rencoded().concat(this.Sencoded());\n    }, Signature.prototype.toHex = function() {\n      return utils.encode(this.toBytes(), \"hex\").toUpperCase();\n    }, module.exports = Signature;\n  }\n}), require_eddsa = __commonJS({\n  \"node_modules/elliptic/lib/elliptic/eddsa/index.js\"(exports, module) {\n    var hash = require_hash2(), curves = require_curves(), utils = require_utils3(), assert = utils.assert, parseBytes = utils.parseBytes, KeyPair = require_key2(), Signature = require_signature2();\n    function EDDSA(curve) {\n      if (assert(curve === \"ed25519\", \"only tested with ed25519 so far\"), !(this instanceof EDDSA))\n        return new EDDSA(curve);\n      curve = curves[curve].curve, this.curve = curve, this.g = curve.g, this.g.precompute(curve.n.bitLength() + 1), this.pointClass = curve.point().constructor, this.encodingLength = Math.ceil(curve.n.bitLength() / 8), this.hash = hash.sha512;\n    }\n    EDDSA.prototype = {}, module.exports = EDDSA, EDDSA.prototype.sign = function(message, secret) {\n      message = parseBytes(message);\n      var key = this.keyFromSecret(secret), r = this.hashInt(key.messagePrefix(), message), R = this.g.mul(r), Rencoded = this.encodePoint(R), s_ = this.hashInt(Rencoded, key.pubBytes(), message).mul(key.priv()), S = r.add(s_).umod(this.curve.n);\n      return this.makeSignature({ R, S, Rencoded });\n    }, EDDSA.prototype.verify = function(message, sig, pub) {\n      message = parseBytes(message), sig = this.makeSignature(sig);\n      var key = this.keyFromPublic(pub), h = this.hashInt(sig.Rencoded(), key.pubBytes(), message), SG = this.g.mul(sig.S()), RplusAh = sig.R().add(key.pub().mul(h));\n      return RplusAh.eq(SG);\n    }, EDDSA.prototype.hashInt = function() {\n      for (var hash2 = this.hash(), i = 0;i < arguments.length; i++)\n        hash2.update(arguments[i]);\n      return utils.intFromLE(hash2.digest()).umod(this.curve.n);\n    }, EDDSA.prototype.keyFromPublic = function(pub) {\n      return KeyPair.fromPublic(this, pub);\n    }, EDDSA.prototype.keyFromSecret = function(secret) {\n      return KeyPair.fromSecret(this, secret);\n    }, EDDSA.prototype.makeSignature = function(sig) {\n      return sig instanceof Signature \? sig : new Signature(this, sig);\n    }, EDDSA.prototype.encodePoint = function(point) {\n      var enc = point.getY().toArray(\"le\", this.encodingLength);\n      return enc[this.encodingLength - 1] |= point.getX().isOdd() \? 128 : 0, enc;\n    }, EDDSA.prototype.decodePoint = function(bytes) {\n      bytes = utils.parseBytes(bytes);\n      var lastIx = bytes.length - 1, normed = bytes.slice(0, lastIx).concat(bytes[lastIx] & -129), xIsOdd = (bytes[lastIx] & 128) !== 0, y = utils.intFromLE(normed);\n      return this.curve.pointFromY(y, xIsOdd);\n    }, EDDSA.prototype.encodeInt = function(num) {\n      return num.toArray(\"le\", this.encodingLength);\n    }, EDDSA.prototype.decodeInt = function(bytes) {\n      return utils.intFromLE(bytes);\n    }, EDDSA.prototype.isPoint = function(val) {\n      return val instanceof this.pointClass;\n    };\n  }\n}), require_elliptic = __commonJS({\n  \"node_modules/elliptic/lib/elliptic.js\"(exports) {\n    var elliptic = exports;\n    elliptic.version = require_package().version, elliptic.utils = require_utils3(), elliptic.rand = require_brorand(), elliptic.curve = require_curve(), elliptic.curves = require_curves(), elliptic.ec = require_ec(), elliptic.eddsa = require_eddsa();\n  }\n}), require_bn5 = require_bn, require_safer = __commonJS({\n  \"node_modules/safer-buffer/safer.js\"(exports, module) {\n    var buffer = BufferModule, Buffer2 = Buffer, safer = {}, key;\n    for (key in buffer)\n      !buffer.hasOwnProperty(key) || key === \"SlowBuffer\" || key === \"Buffer\" || (safer[key] = buffer[key]);\n    var Safer = safer.Buffer = {};\n    for (key in Buffer2)\n      !Buffer2.hasOwnProperty(key) || key === \"allocUnsafe\" || key === \"allocUnsafeSlow\" || (Safer[key] = Buffer2[key]);\n    if (safer.Buffer.prototype = Buffer2.prototype, (!Safer.from || Safer.from === Uint8Array.from) && (Safer.from = function(value, encodingOrOffset, length) {\n      if (typeof value == \"number\")\n        @throwTypeError('The \"value\" argument must not be of type number. Received type ' + typeof value);\n      if (value && typeof value.length > \"u\")\n        @throwTypeError(\"The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type \" + typeof value);\n      return Buffer2(value, encodingOrOffset, length);\n    }), Safer.alloc || (Safer.alloc = function(size, fill, encoding) {\n      if (typeof size != \"number\")\n        @throwTypeError('The \"size\" argument must be of type number. Received type ' + typeof size);\n      if (size < 0 || size >= 2 * (1 << 30))\n        @throwRangeError('The value \"' + size + '\" is invalid for option \"size\"');\n      var buf = Buffer2(size);\n      return !fill || fill.length === 0 \? buf.fill(0) : typeof encoding == \"string\" \? buf.fill(fill, encoding) : buf.fill(fill), buf;\n    }), !safer.kStringMaxLength)\n      try {\n        safer.kStringMaxLength = MAX_STRING_LENGTH;\n      } catch {\n      }\n    safer.constants || (safer.constants = {\n      MAX_LENGTH: safer.kMaxLength\n    }, safer.kStringMaxLength && (safer.constants.MAX_STRING_LENGTH = safer.kStringMaxLength)), module.exports = safer;\n  }\n}), require_reporter = __commonJS({\n  \"node_modules/asn1.js/lib/asn1/base/reporter.js\"(exports) {\n    var inherits = require_inherits_browser();\n    function Reporter(options) {\n      this._reporterState = {\n        obj: null,\n        path: [],\n        options: options || {},\n        errors: []\n      };\n    }\n    Reporter.prototype = {}, exports.Reporter = Reporter, Reporter.prototype.isError = function(obj) {\n      return obj instanceof ReporterError;\n    }, Reporter.prototype.save = function() {\n      let state = this._reporterState;\n      return { obj: state.obj, pathLen: state.path.length };\n    }, Reporter.prototype.restore = function(data) {\n      let state = this._reporterState;\n      state.obj = data.obj, state.path = state.path.slice(0, data.pathLen);\n    }, Reporter.prototype.enterKey = function(key) {\n      return this._reporterState.path.push(key);\n    }, Reporter.prototype.exitKey = function(index) {\n      let state = this._reporterState;\n      state.path = state.path.slice(0, index - 1);\n    }, Reporter.prototype.leaveKey = function(index, key, value) {\n      let state = this._reporterState;\n      this.exitKey(index), state.obj !== null && (state.obj[key] = value);\n    }, Reporter.prototype.path = function() {\n      return this._reporterState.path.join(\"/\");\n    }, Reporter.prototype.enterObject = function() {\n      let state = this._reporterState, prev = state.obj;\n      return state.obj = {}, prev;\n    }, Reporter.prototype.leaveObject = function(prev) {\n      let state = this._reporterState, now = state.obj;\n      return state.obj = prev, now;\n    }, Reporter.prototype.error = function(msg) {\n      let err, state = this._reporterState, inherited = msg instanceof ReporterError;\n      if (inherited \? err = msg : err = new ReporterError(state.path.map(function(elem) {\n        return \"[\" + JSON.stringify(elem) + \"]\";\n      }).join(\"\"), msg.message || msg, msg.stack), !state.options.partial)\n        throw err;\n      return inherited || state.errors.push(err), err;\n    }, Reporter.prototype.wrapResult = function(result) {\n      let state = this._reporterState;\n      return state.options.partial \? {\n        result: this.isError(result) \? null : result,\n        errors: state.errors\n      } : result;\n    };\n    function ReporterError(path, msg) {\n      this.path = path, this.rethrow(msg);\n    }\n    inherits(ReporterError, Error), ReporterError.prototype.rethrow = function(msg) {\n      if (this.message = msg + \" at: \" + (this.path || \"(shallow)\"), Error.captureStackTrace && Error.captureStackTrace(this, ReporterError), !this.stack)\n        try {\n          throw new Error(this.message);\n        } catch (e) {\n          this.stack = e.stack;\n        }\n      return this;\n    };\n  }\n}), require_buffer = __commonJS({\n  \"node_modules/asn1.js/lib/asn1/base/buffer.js\"(exports) {\n    var inherits = require_inherits_browser(), Reporter = require_reporter().Reporter, Buffer2 = require_safer().Buffer;\n    function DecoderBuffer(base, options) {\n      if (Reporter.call(this, options), !Buffer2.isBuffer(base)) {\n        this.error(\"Input not Buffer\");\n        return;\n      }\n      this.base = base, this.offset = 0, this.length = base.length;\n    }\n    inherits(DecoderBuffer, Reporter), exports.DecoderBuffer = DecoderBuffer, DecoderBuffer.isDecoderBuffer = function(data) {\n      return data instanceof DecoderBuffer \? !0 : typeof data == \"object\" && Buffer2.isBuffer(data.base) && data.constructor.name === \"DecoderBuffer\" && typeof data.offset == \"number\" && typeof data.length == \"number\" && typeof data.save == \"function\" && typeof data.restore == \"function\" && typeof data.isEmpty == \"function\" && typeof data.readUInt8 == \"function\" && typeof data.skip == \"function\" && typeof data.raw == \"function\";\n    }, DecoderBuffer.prototype.save = function() {\n      return {\n        offset: this.offset,\n        reporter: Reporter.prototype.save.call(this)\n      };\n    }, DecoderBuffer.prototype.restore = function(save) {\n      let res = new DecoderBuffer(this.base);\n      return res.offset = save.offset, res.length = this.offset, this.offset = save.offset, Reporter.prototype.restore.call(this, save.reporter), res;\n    }, DecoderBuffer.prototype.isEmpty = function() {\n      return this.offset === this.length;\n    }, DecoderBuffer.prototype.readUInt8 = function(fail) {\n      return this.offset + 1 <= this.length \? this.base.readUInt8(this.offset++, !0) : this.error(fail || \"DecoderBuffer overrun\");\n    }, DecoderBuffer.prototype.skip = function(bytes, fail) {\n      if (!(this.offset + bytes <= this.length))\n        return this.error(fail || \"DecoderBuffer overrun\");\n      let res = new DecoderBuffer(this.base);\n      return res._reporterState = this._reporterState, res.offset = this.offset, res.length = this.offset + bytes, this.offset += bytes, res;\n    }, DecoderBuffer.prototype.raw = function(save) {\n      return this.base.slice(save \? save.offset : this.offset, this.length);\n    };\n    function EncoderBuffer(value, reporter) {\n      if (Array.isArray(value))\n        this.length = 0, this.value = value.map(function(item) {\n          return EncoderBuffer.isEncoderBuffer(item) || (item = new EncoderBuffer(item, reporter)), this.length += item.length, item;\n        }, this);\n      else if (typeof value == \"number\") {\n        if (!(0 <= value && value <= 255))\n          return reporter.error(\"non-byte EncoderBuffer value\");\n        this.value = value, this.length = 1;\n      } else if (typeof value == \"string\")\n        this.value = value, this.length = Buffer2.byteLength(value);\n      else if (Buffer2.isBuffer(value))\n        this.value = value, this.length = value.length;\n      else\n        return reporter.error(\"Unsupported type: \" + typeof value);\n    }\n    EncoderBuffer.prototype = {}, exports.EncoderBuffer = EncoderBuffer, EncoderBuffer.isEncoderBuffer = function(data) {\n      return data instanceof EncoderBuffer \? !0 : typeof data == \"object\" && data.constructor.name === \"EncoderBuffer\" && typeof data.length == \"number\" && typeof data.join == \"function\";\n    }, EncoderBuffer.prototype.join = function(out, offset) {\n      return out || (out = Buffer2.alloc(this.length)), offset || (offset = 0), this.length === 0 || (Array.isArray(this.value) \? this.value.forEach(function(item) {\n        item.join(out, offset), offset += item.length;\n      }) : (typeof this.value == \"number\" \? out[offset] = this.value : typeof this.value == \"string\" \? out.write(this.value, offset) : Buffer2.isBuffer(this.value) && this.value.copy(out, offset), offset += this.length)), out;\n    };\n  }\n}), require_node = __commonJS({\n  \"node_modules/asn1.js/lib/asn1/base/node.js\"(exports, module) {\n    var Reporter = require_reporter().Reporter, EncoderBuffer = require_buffer().EncoderBuffer, DecoderBuffer = require_buffer().DecoderBuffer, assert = require_minimalistic_assert(), tags = [\n      \"seq\",\n      \"seqof\",\n      \"set\",\n      \"setof\",\n      \"objid\",\n      \"bool\",\n      \"gentime\",\n      \"utctime\",\n      \"null_\",\n      \"enum\",\n      \"int\",\n      \"objDesc\",\n      \"bitstr\",\n      \"bmpstr\",\n      \"charstr\",\n      \"genstr\",\n      \"graphstr\",\n      \"ia5str\",\n      \"iso646str\",\n      \"numstr\",\n      \"octstr\",\n      \"printstr\",\n      \"t61str\",\n      \"unistr\",\n      \"utf8str\",\n      \"videostr\"\n    ], methods = [\"key\", \"obj\", \"use\", \"optional\", \"explicit\", \"implicit\", \"def\", \"choice\", \"any\", \"contains\"].concat(tags), overrided = [\n      \"_peekTag\",\n      \"_decodeTag\",\n      \"_use\",\n      \"_decodeStr\",\n      \"_decodeObjid\",\n      \"_decodeTime\",\n      \"_decodeNull\",\n      \"_decodeInt\",\n      \"_decodeBool\",\n      \"_decodeList\",\n      \"_encodeComposite\",\n      \"_encodeStr\",\n      \"_encodeObjid\",\n      \"_encodeTime\",\n      \"_encodeNull\",\n      \"_encodeInt\",\n      \"_encodeBool\"\n    ];\n    function Node(enc, parent, name) {\n      let state = {};\n      this._baseState = state, state.name = name, state.enc = enc, state.parent = parent || null, state.children = null, state.tag = null, state.args = null, state.reverseArgs = null, state.choice = null, state.optional = !1, state.any = !1, state.obj = !1, state.use = null, state.useDecoder = null, state.key = null, state.default = null, state.explicit = null, state.implicit = null, state.contains = null, state.parent || (state.children = [], this._wrap());\n    }\n    Node.prototype = {}, module.exports = Node;\n    var stateProps = [\n      \"enc\",\n      \"parent\",\n      \"children\",\n      \"tag\",\n      \"args\",\n      \"reverseArgs\",\n      \"choice\",\n      \"optional\",\n      \"any\",\n      \"obj\",\n      \"use\",\n      \"alteredUse\",\n      \"key\",\n      \"default\",\n      \"explicit\",\n      \"implicit\",\n      \"contains\"\n    ];\n    Node.prototype.clone = function() {\n      let state = this._baseState, cstate = {};\n      stateProps.forEach(function(prop) {\n        cstate[prop] = state[prop];\n      });\n      let res = new this.constructor(cstate.parent);\n      return res._baseState = cstate, res;\n    }, Node.prototype._wrap = function() {\n      let state = this._baseState;\n      methods.forEach(function(method) {\n        this[method] = function() {\n          let clone = new this.constructor(this);\n          return state.children.push(clone), clone[method].apply(clone, arguments);\n        };\n      }, this);\n    }, Node.prototype._init = function(body) {\n      let state = this._baseState;\n      assert(state.parent === null), body.call(this), state.children = state.children.filter(function(child) {\n        return child._baseState.parent === this;\n      }, this), assert.equal(state.children.length, 1, \"Root node can have only one child\");\n    }, Node.prototype._useArgs = function(args) {\n      let state = this._baseState, children = args.filter(function(arg) {\n        return arg instanceof this.constructor;\n      }, this);\n      args = args.filter(function(arg) {\n        return !(arg instanceof this.constructor);\n      }, this), children.length !== 0 && (assert(state.children === null), state.children = children, children.forEach(function(child) {\n        child._baseState.parent = this;\n      }, this)), args.length !== 0 && (assert(state.args === null), state.args = args, state.reverseArgs = args.map(function(arg) {\n        if (typeof arg != \"object\" || arg.constructor !== Object)\n          return arg;\n        let res = {};\n        return Object.keys(arg).forEach(function(key) {\n          key == (key | 0) && (key |= 0);\n          let value = arg[key];\n          res[value] = key;\n        }), res;\n      }));\n    }, overrided.forEach(function(method) {\n      Node.prototype[method] = function() {\n        let state = this._baseState;\n        throw new Error(method + \" not implemented for encoding: \" + state.enc);\n      };\n    }), tags.forEach(function(tag) {\n      Node.prototype[tag] = function() {\n        let state = this._baseState, args = Array.prototype.slice.call(arguments);\n        return assert(state.tag === null), state.tag = tag, this._useArgs(args), this;\n      };\n    }), Node.prototype.use = function(item) {\n      assert(item);\n      let state = this._baseState;\n      return assert(state.use === null), state.use = item, this;\n    }, Node.prototype.optional = function() {\n      let state = this._baseState;\n      return state.optional = !0, this;\n    }, Node.prototype.def = function(val) {\n      let state = this._baseState;\n      return assert(state.default === null), state.default = val, state.optional = !0, this;\n    }, Node.prototype.explicit = function(num) {\n      let state = this._baseState;\n      return assert(state.explicit === null && state.implicit === null), state.explicit = num, this;\n    }, Node.prototype.implicit = function(num) {\n      let state = this._baseState;\n      return assert(state.explicit === null && state.implicit === null), state.implicit = num, this;\n    }, Node.prototype.obj = function() {\n      let state = this._baseState, args = Array.prototype.slice.call(arguments);\n      return state.obj = !0, args.length !== 0 && this._useArgs(args), this;\n    }, Node.prototype.key = function(newKey) {\n      let state = this._baseState;\n      return assert(state.key === null), state.key = newKey, this;\n    }, Node.prototype.any = function() {\n      let state = this._baseState;\n      return state.any = !0, this;\n    }, Node.prototype.choice = function(obj) {\n      let state = this._baseState;\n      return assert(state.choice === null), state.choice = obj, this._useArgs(Object.keys(obj).map(function(key) {\n        return obj[key];\n      })), this;\n    }, Node.prototype.contains = function(item) {\n      let state = this._baseState;\n      return assert(state.use === null), state.contains = item, this;\n    }, Node.prototype._decode = function(input, options) {\n      let state = this._baseState;\n      if (state.parent === null)\n        return input.wrapResult(state.children[0]._decode(input, options));\n      let result = state.default, present = !0, prevKey = null;\n      if (state.key !== null && (prevKey = input.enterKey(state.key)), state.optional) {\n        let tag = null;\n        if (state.explicit !== null \? tag = state.explicit : state.implicit !== null \? tag = state.implicit : state.tag !== null && (tag = state.tag), tag === null && !state.any) {\n          let save = input.save();\n          try {\n            state.choice === null \? this._decodeGeneric(state.tag, input, options) : this._decodeChoice(input, options), present = !0;\n          } catch {\n            present = !1;\n          }\n          input.restore(save);\n        } else if (present = this._peekTag(input, tag, state.any), input.isError(present))\n          return present;\n      }\n      let prevObj;\n      if (state.obj && present && (prevObj = input.enterObject()), present) {\n        if (state.explicit !== null) {\n          let explicit = this._decodeTag(input, state.explicit);\n          if (input.isError(explicit))\n            return explicit;\n          input = explicit;\n        }\n        let start = input.offset;\n        if (state.use === null && state.choice === null) {\n          let save;\n          state.any && (save = input.save());\n          let body = this._decodeTag(input, state.implicit !== null \? state.implicit : state.tag, state.any);\n          if (input.isError(body))\n            return body;\n          state.any \? result = input.raw(save) : input = body;\n        }\n        if (options && options.track && state.tag !== null && options.track(input.path(), start, input.length, \"tagged\"), options && options.track && state.tag !== null && options.track(input.path(), input.offset, input.length, \"content\"), state.any || (state.choice === null \? result = this._decodeGeneric(state.tag, input, options) : result = this._decodeChoice(input, options)), input.isError(result))\n          return result;\n        if (!state.any && state.choice === null && state.children !== null && state.children.forEach(function(child) {\n          child._decode(input, options);\n        }), state.contains && (state.tag === \"octstr\" || state.tag === \"bitstr\")) {\n          let data = new DecoderBuffer(result);\n          result = this._getUse(state.contains, input._reporterState.obj)._decode(data, options);\n        }\n      }\n      return state.obj && present && (result = input.leaveObject(prevObj)), state.key !== null && (result !== null || present === !0) \? input.leaveKey(prevKey, state.key, result) : prevKey !== null && input.exitKey(prevKey), result;\n    }, Node.prototype._decodeGeneric = function(tag, input, options) {\n      let state = this._baseState;\n      return tag === \"seq\" || tag === \"set\" \? null : tag === \"seqof\" || tag === \"setof\" \? this._decodeList(input, tag, state.args[0], options) : /str$/.test(tag) \? this._decodeStr(input, tag, options) : tag === \"objid\" && state.args \? this._decodeObjid(input, state.args[0], state.args[1], options) : tag === \"objid\" \? this._decodeObjid(input, null, null, options) : tag === \"gentime\" || tag === \"utctime\" \? this._decodeTime(input, tag, options) : tag === \"null_\" \? this._decodeNull(input, options) : tag === \"bool\" \? this._decodeBool(input, options) : tag === \"objDesc\" \? this._decodeStr(input, tag, options) : tag === \"int\" || tag === \"enum\" \? this._decodeInt(input, state.args && state.args[0], options) : state.use !== null \? this._getUse(state.use, input._reporterState.obj)._decode(input, options) : input.error(\"unknown tag: \" + tag);\n    }, Node.prototype._getUse = function(entity, obj) {\n      let state = this._baseState;\n      return state.useDecoder = this._use(entity, obj), assert(state.useDecoder._baseState.parent === null), state.useDecoder = state.useDecoder._baseState.children[0], state.implicit !== state.useDecoder._baseState.implicit && (state.useDecoder = state.useDecoder.clone(), state.useDecoder._baseState.implicit = state.implicit), state.useDecoder;\n    }, Node.prototype._decodeChoice = function(input, options) {\n      let state = this._baseState, result = null, match = !1;\n      return Object.keys(state.choice).some(function(key) {\n        let save = input.save(), node = state.choice[key];\n        try {\n          let value = node._decode(input, options);\n          if (input.isError(value))\n            return !1;\n          result = { type: key, value }, match = !0;\n        } catch {\n          return input.restore(save), !1;\n        }\n        return !0;\n      }, this), match \? result : input.error(\"Choice not matched\");\n    }, Node.prototype._createEncoderBuffer = function(data) {\n      return new EncoderBuffer(data, this.reporter);\n    }, Node.prototype._encode = function(data, reporter, parent) {\n      let state = this._baseState;\n      if (state.default !== null && state.default === data)\n        return;\n      let result = this._encodeValue(data, reporter, parent);\n      if (result !== void 0 && !this._skipDefault(result, reporter, parent))\n        return result;\n    }, Node.prototype._encodeValue = function(data, reporter, parent) {\n      let state = this._baseState;\n      if (state.parent === null)\n        return state.children[0]._encode(data, reporter || new Reporter);\n      let result = null;\n      if (this.reporter = reporter, state.optional && data === void 0)\n        if (state.default !== null)\n          data = state.default;\n        else\n          return;\n      let content = null, primitive = !1;\n      if (state.any)\n        result = this._createEncoderBuffer(data);\n      else if (state.choice)\n        result = this._encodeChoice(data, reporter);\n      else if (state.contains)\n        content = this._getUse(state.contains, parent)._encode(data, reporter), primitive = !0;\n      else if (state.children)\n        content = state.children.map(function(child) {\n          if (child._baseState.tag === \"null_\")\n            return child._encode(null, reporter, data);\n          if (child._baseState.key === null)\n            return reporter.error(\"Child should have a key\");\n          let prevKey = reporter.enterKey(child._baseState.key);\n          if (typeof data != \"object\")\n            return reporter.error(\"Child expected, but input is not object\");\n          let res = child._encode(data[child._baseState.key], reporter, data);\n          return reporter.leaveKey(prevKey), res;\n        }, this).filter(function(child) {\n          return child;\n        }), content = this._createEncoderBuffer(content);\n      else if (state.tag === \"seqof\" || state.tag === \"setof\") {\n        if (!(state.args && state.args.length === 1))\n          return reporter.error(\"Too many args for : \" + state.tag);\n        if (!Array.isArray(data))\n          return reporter.error(\"seqof/setof, but data is not Array\");\n        let child = this.clone();\n        child._baseState.implicit = null, content = this._createEncoderBuffer(data.map(function(item) {\n          let state2 = this._baseState;\n          return this._getUse(state2.args[0], data)._encode(item, reporter);\n        }, child));\n      } else\n        state.use !== null \? result = this._getUse(state.use, parent)._encode(data, reporter) : (content = this._encodePrimitive(state.tag, data), primitive = !0);\n      if (!state.any && state.choice === null) {\n        let tag = state.implicit !== null \? state.implicit : state.tag, cls = state.implicit === null \? \"universal\" : \"context\";\n        tag === null \? state.use === null && reporter.error(\"Tag could be omitted only for .use()\") : state.use === null && (result = this._encodeComposite(tag, primitive, cls, content));\n      }\n      return state.explicit !== null && (result = this._encodeComposite(state.explicit, !1, \"context\", result)), result;\n    }, Node.prototype._encodeChoice = function(data, reporter) {\n      let state = this._baseState, node = state.choice[data.type];\n      return node || assert(!1, data.type + \" not found in \" + JSON.stringify(Object.keys(state.choice))), node._encode(data.value, reporter);\n    }, Node.prototype._encodePrimitive = function(tag, data) {\n      let state = this._baseState;\n      if (/str$/.test(tag))\n        return this._encodeStr(data, tag);\n      if (tag === \"objid\" && state.args)\n        return this._encodeObjid(data, state.reverseArgs[0], state.args[1]);\n      if (tag === \"objid\")\n        return this._encodeObjid(data, null, null);\n      if (tag === \"gentime\" || tag === \"utctime\")\n        return this._encodeTime(data, tag);\n      if (tag === \"null_\")\n        return this._encodeNull();\n      if (tag === \"int\" || tag === \"enum\")\n        return this._encodeInt(data, state.args && state.reverseArgs[0]);\n      if (tag === \"bool\")\n        return this._encodeBool(data);\n      if (tag === \"objDesc\")\n        return this._encodeStr(data, tag);\n      throw new Error(\"Unsupported tag: \" + tag);\n    }, Node.prototype._isNumstr = function(str) {\n      return /^[0-9 ]*$/.test(str);\n    }, Node.prototype._isPrintstr = function(str) {\n      return /^[A-Za-z0-9 '()+,-./:=\?]*$/.test(str);\n    };\n  }\n}), require_der = __commonJS({\n  \"node_modules/asn1.js/lib/asn1/constants/der.js\"(exports) {\n    function reverse(map) {\n      let res = {};\n      return Object.keys(map).forEach(function(key) {\n        (key | 0) == key && (key = key | 0);\n        let value = map[key];\n        res[value] = key;\n      }), res;\n    }\n    exports.tagClass = {\n      0: \"universal\",\n      1: \"application\",\n      2: \"context\",\n      3: \"private\"\n    }, exports.tagClassByName = reverse(exports.tagClass), exports.tag = {\n      0: \"end\",\n      1: \"bool\",\n      2: \"int\",\n      3: \"bitstr\",\n      4: \"octstr\",\n      5: \"null_\",\n      6: \"objid\",\n      7: \"objDesc\",\n      8: \"external\",\n      9: \"real\",\n      10: \"enum\",\n      11: \"embed\",\n      12: \"utf8str\",\n      13: \"relativeOid\",\n      16: \"seq\",\n      17: \"set\",\n      18: \"numstr\",\n      19: \"printstr\",\n      20: \"t61str\",\n      21: \"videostr\",\n      22: \"ia5str\",\n      23: \"utctime\",\n      24: \"gentime\",\n      25: \"graphstr\",\n      26: \"iso646str\",\n      27: \"genstr\",\n      28: \"unistr\",\n      29: \"charstr\",\n      30: \"bmpstr\"\n    }, exports.tagByName = reverse(exports.tag);\n  }\n}), require_der2 = __commonJS({\n  \"node_modules/asn1.js/lib/asn1/encoders/der.js\"(exports, module) {\n    var inherits = require_inherits_browser(), Buffer2 = require_safer().Buffer, Node = require_node(), der = require_der();\n    function DEREncoder(entity) {\n      this.enc = \"der\", this.name = entity.name, this.entity = entity, this.tree = new DERNode, this.tree._init(entity.body);\n    }\n    DEREncoder.prototype = {}, module.exports = DEREncoder, DEREncoder.prototype.encode = function(data, reporter) {\n      return this.tree._encode(data, reporter).join();\n    };\n    function DERNode(parent) {\n      Node.call(this, \"der\", parent);\n    }\n    inherits(DERNode, Node), DERNode.prototype._encodeComposite = function(tag, primitive, cls, content) {\n      let encodedTag = encodeTag(tag, primitive, cls, this.reporter);\n      if (content.length < 128) {\n        let header2 = Buffer2.alloc(2);\n        return header2[0] = encodedTag, header2[1] = content.length, this._createEncoderBuffer([header2, content]);\n      }\n      let lenOctets = 1;\n      for (let i = content.length;i >= 256; i >>= 8)\n        lenOctets++;\n      let header = Buffer2.alloc(2 + lenOctets);\n      header[0] = encodedTag, header[1] = 128 | lenOctets;\n      for (let i = 1 + lenOctets, j = content.length;j > 0; i--, j >>= 8)\n        header[i] = j & 255;\n      return this._createEncoderBuffer([header, content]);\n    }, DERNode.prototype._encodeStr = function(str, tag) {\n      if (tag === \"bitstr\")\n        return this._createEncoderBuffer([str.unused | 0, str.data]);\n      if (tag === \"bmpstr\") {\n        let buf = Buffer2.alloc(str.length * 2);\n        for (let i = 0;i < str.length; i++)\n          buf.writeUInt16BE(str.charCodeAt(i), i * 2);\n        return this._createEncoderBuffer(buf);\n      } else\n        return tag === \"numstr\" \? this._isNumstr(str) \? this._createEncoderBuffer(str) : this.reporter.error(\"Encoding of string type: numstr supports only digits and space\") : tag === \"printstr\" \? this._isPrintstr(str) \? this._createEncoderBuffer(str) : this.reporter.error(\"Encoding of string type: printstr supports only latin upper and lower case letters, digits, space, apostrophe, left and rigth parenthesis, plus sign, comma, hyphen, dot, slash, colon, equal sign, question mark\") : /str$/.test(tag) \? this._createEncoderBuffer(str) : tag === \"objDesc\" \? this._createEncoderBuffer(str) : this.reporter.error(\"Encoding of string type: \" + tag + \" unsupported\");\n    }, DERNode.prototype._encodeObjid = function(id, values, relative) {\n      if (typeof id == \"string\") {\n        if (!values)\n          return this.reporter.error(\"string objid given, but no values map found\");\n        if (!values.hasOwnProperty(id))\n          return this.reporter.error(\"objid not found in values map\");\n        id = values[id].split(/[\\s.]+/g);\n        for (let i = 0;i < id.length; i++)\n          id[i] |= 0;\n      } else if (Array.isArray(id)) {\n        id = id.slice();\n        for (let i = 0;i < id.length; i++)\n          id[i] |= 0;\n      }\n      if (!Array.isArray(id))\n        return this.reporter.error(\"objid() should be either array or string, got: \" + JSON.stringify(id));\n      if (!relative) {\n        if (id[1] >= 40)\n          return this.reporter.error(\"Second objid identifier OOB\");\n        id.splice(0, 2, id[0] * 40 + id[1]);\n      }\n      let size = 0;\n      for (let i = 0;i < id.length; i++) {\n        let ident = id[i];\n        for (size++;ident >= 128; ident >>= 7)\n          size++;\n      }\n      let objid = Buffer2.alloc(size), offset = objid.length - 1;\n      for (let i = id.length - 1;i >= 0; i--) {\n        let ident = id[i];\n        for (objid[offset--] = ident & 127;(ident >>= 7) > 0; )\n          objid[offset--] = 128 | ident & 127;\n      }\n      return this._createEncoderBuffer(objid);\n    };\n    function two(num) {\n      return num < 10 \? \"0\" + num : num;\n    }\n    DERNode.prototype._encodeTime = function(time, tag) {\n      let str, date = new Date(time);\n      return tag === \"gentime\" \? str = [\n        two(date.getUTCFullYear()),\n        two(date.getUTCMonth() + 1),\n        two(date.getUTCDate()),\n        two(date.getUTCHours()),\n        two(date.getUTCMinutes()),\n        two(date.getUTCSeconds()),\n        \"Z\"\n      ].join(\"\") : tag === \"utctime\" \? str = [\n        two(date.getUTCFullYear() % 100),\n        two(date.getUTCMonth() + 1),\n        two(date.getUTCDate()),\n        two(date.getUTCHours()),\n        two(date.getUTCMinutes()),\n        two(date.getUTCSeconds()),\n        \"Z\"\n      ].join(\"\") : this.reporter.error(\"Encoding \" + tag + \" time is not supported yet\"), this._encodeStr(str, \"octstr\");\n    }, DERNode.prototype._encodeNull = function() {\n      return this._createEncoderBuffer(\"\");\n    }, DERNode.prototype._encodeInt = function(num, values) {\n      if (typeof num == \"string\") {\n        if (!values)\n          return this.reporter.error(\"String int or enum given, but no values map\");\n        if (!values.hasOwnProperty(num))\n          return this.reporter.error(\"Values map doesn't contain: \" + JSON.stringify(num));\n        num = values[num];\n      }\n      if (typeof num != \"number\" && !Buffer2.isBuffer(num)) {\n        let numArray = num.toArray();\n        !num.sign && numArray[0] & 128 && numArray.unshift(0), num = Buffer2.from(numArray);\n      }\n      if (Buffer2.isBuffer(num)) {\n        let size2 = num.length;\n        num.length === 0 && size2++;\n        let out2 = Buffer2.alloc(size2);\n        return num.copy(out2), num.length === 0 && (out2[0] = 0), this._createEncoderBuffer(out2);\n      }\n      if (num < 128)\n        return this._createEncoderBuffer(num);\n      if (num < 256)\n        return this._createEncoderBuffer([0, num]);\n      let size = 1;\n      for (let i = num;i >= 256; i >>= 8)\n        size++;\n      let out = new Array(size);\n      for (let i = out.length - 1;i >= 0; i--)\n        out[i] = num & 255, num >>= 8;\n      return out[0] & 128 && out.unshift(0), this._createEncoderBuffer(Buffer2.from(out));\n    }, DERNode.prototype._encodeBool = function(value) {\n      return this._createEncoderBuffer(value \? 255 : 0);\n    }, DERNode.prototype._use = function(entity, obj) {\n      return typeof entity == \"function\" && (entity = entity(obj)), entity._getEncoder(\"der\").tree;\n    }, DERNode.prototype._skipDefault = function(dataBuffer, reporter, parent) {\n      let state = this._baseState, i;\n      if (state.default === null)\n        return !1;\n      let data = dataBuffer.join();\n      if (state.defaultBuffer === void 0 && (state.defaultBuffer = this._encodeValue(state.default, reporter, parent).join()), data.length !== state.defaultBuffer.length)\n        return !1;\n      for (i = 0;i < data.length; i++)\n        if (data[i] !== state.defaultBuffer[i])\n          return !1;\n      return !0;\n    };\n    function encodeTag(tag, primitive, cls, reporter) {\n      let res;\n      if (tag === \"seqof\" \? tag = \"seq\" : tag === \"setof\" && (tag = \"set\"), der.tagByName.hasOwnProperty(tag))\n        res = der.tagByName[tag];\n      else if (typeof tag == \"number\" && (tag | 0) === tag)\n        res = tag;\n      else\n        return reporter.error(\"Unknown tag: \" + tag);\n      return res >= 31 \? reporter.error(\"Multi-octet tag encoding unsupported\") : (primitive || (res |= 32), res |= der.tagClassByName[cls || \"universal\"] << 6, res);\n    }\n  }\n}), require_pem = __commonJS({\n  \"node_modules/asn1.js/lib/asn1/encoders/pem.js\"(exports, module) {\n    var inherits = require_inherits_browser(), DEREncoder = require_der2();\n    function PEMEncoder(entity) {\n      DEREncoder.call(this, entity), this.enc = \"pem\";\n    }\n    inherits(PEMEncoder, DEREncoder), module.exports = PEMEncoder, PEMEncoder.prototype.encode = function(data, options) {\n      let p = DEREncoder.prototype.encode.call(this, data).toString(\"base64\"), out = [\"-----BEGIN \" + options.label + \"-----\"];\n      for (let i = 0;i < p.length; i += 64)\n        out.push(p.slice(i, i + 64));\n      return out.push(\"-----END \" + options.label + \"-----\"), out.join(`\n`);\n    };\n  }\n}), require_encoders = __commonJS({\n  \"node_modules/asn1.js/lib/asn1/encoders/index.js\"(exports) {\n    var encoders = exports;\n    encoders.der = require_der2(), encoders.pem = require_pem();\n  }\n}), require_der3 = __commonJS({\n  \"node_modules/asn1.js/lib/asn1/decoders/der.js\"(exports, module) {\n    var inherits = require_inherits_browser(), bignum = require_bn5(), DecoderBuffer = require_buffer().DecoderBuffer, Node = require_node(), der = require_der();\n    function DERDecoder(entity) {\n      this.enc = \"der\", this.name = entity.name, this.entity = entity, this.tree = new DERNode, this.tree._init(entity.body);\n    }\n    DERDecoder.prototype = {}, module.exports = DERDecoder, DERDecoder.prototype.decode = function(data, options) {\n      return DecoderBuffer.isDecoderBuffer(data) || (data = new DecoderBuffer(data, options)), this.tree._decode(data, options);\n    };\n    function DERNode(parent) {\n      Node.call(this, \"der\", parent);\n    }\n    inherits(DERNode, Node), DERNode.prototype._peekTag = function(buffer, tag, any) {\n      if (buffer.isEmpty())\n        return !1;\n      let state = buffer.save(), decodedTag = derDecodeTag(buffer, 'Failed to peek tag: \"' + tag + '\"');\n      return buffer.isError(decodedTag) \? decodedTag : (buffer.restore(state), decodedTag.tag === tag || decodedTag.tagStr === tag || decodedTag.tagStr + \"of\" === tag || any);\n    }, DERNode.prototype._decodeTag = function(buffer, tag, any) {\n      let decodedTag = derDecodeTag(buffer, 'Failed to decode tag of \"' + tag + '\"');\n      if (buffer.isError(decodedTag))\n        return decodedTag;\n      let len = derDecodeLen(buffer, decodedTag.primitive, 'Failed to get length of \"' + tag + '\"');\n      if (buffer.isError(len))\n        return len;\n      if (!any && decodedTag.tag !== tag && decodedTag.tagStr !== tag && decodedTag.tagStr + \"of\" !== tag)\n        return buffer.error('Failed to match tag: \"' + tag + '\"');\n      if (decodedTag.primitive || len !== null)\n        return buffer.skip(len, 'Failed to match body of: \"' + tag + '\"');\n      let state = buffer.save(), res = this._skipUntilEnd(buffer, 'Failed to skip indefinite length body: \"' + this.tag + '\"');\n      return buffer.isError(res) \? res : (len = buffer.offset - state.offset, buffer.restore(state), buffer.skip(len, 'Failed to match body of: \"' + tag + '\"'));\n    }, DERNode.prototype._skipUntilEnd = function(buffer, fail) {\n      for (;; ) {\n        let tag = derDecodeTag(buffer, fail);\n        if (buffer.isError(tag))\n          return tag;\n        let len = derDecodeLen(buffer, tag.primitive, fail);\n        if (buffer.isError(len))\n          return len;\n        let res;\n        if (tag.primitive || len !== null \? res = buffer.skip(len) : res = this._skipUntilEnd(buffer, fail), buffer.isError(res))\n          return res;\n        if (tag.tagStr === \"end\")\n          break;\n      }\n    }, DERNode.prototype._decodeList = function(buffer, tag, decoder, options) {\n      let result = [];\n      for (;!buffer.isEmpty(); ) {\n        let possibleEnd = this._peekTag(buffer, \"end\");\n        if (buffer.isError(possibleEnd))\n          return possibleEnd;\n        let res = decoder.decode(buffer, \"der\", options);\n        if (buffer.isError(res) && possibleEnd)\n          break;\n        result.push(res);\n      }\n      return result;\n    }, DERNode.prototype._decodeStr = function(buffer, tag) {\n      if (tag === \"bitstr\") {\n        let unused = buffer.readUInt8();\n        return buffer.isError(unused) \? unused : { unused, data: buffer.raw() };\n      } else if (tag === \"bmpstr\") {\n        let raw = buffer.raw();\n        if (raw.length % 2 === 1)\n          return buffer.error(\"Decoding of string type: bmpstr length mismatch\");\n        let str = \"\";\n        for (let i = 0;i < raw.length / 2; i++)\n          str += String.fromCharCode(raw.readUInt16BE(i * 2));\n        return str;\n      } else if (tag === \"numstr\") {\n        let numstr = buffer.raw().toString(\"ascii\");\n        return this._isNumstr(numstr) \? numstr : buffer.error(\"Decoding of string type: numstr unsupported characters\");\n      } else {\n        if (tag === \"octstr\")\n          return buffer.raw();\n        if (tag === \"objDesc\")\n          return buffer.raw();\n        if (tag === \"printstr\") {\n          let printstr = buffer.raw().toString(\"ascii\");\n          return this._isPrintstr(printstr) \? printstr : buffer.error(\"Decoding of string type: printstr unsupported characters\");\n        } else\n          return /str$/.test(tag) \? buffer.raw().toString() : buffer.error(\"Decoding of string type: \" + tag + \" unsupported\");\n      }\n    }, DERNode.prototype._decodeObjid = function(buffer, values, relative) {\n      let result, identifiers = [], ident = 0, subident = 0;\n      for (;!buffer.isEmpty(); )\n        subident = buffer.readUInt8(), ident <<= 7, ident |= subident & 127, (subident & 128) === 0 && (identifiers.push(ident), ident = 0);\n      subident & 128 && identifiers.push(ident);\n      let first = identifiers[0] / 40 | 0, second = identifiers[0] % 40;\n      if (relative \? result = identifiers : result = [first, second].concat(identifiers.slice(1)), values) {\n        let tmp = values[result.join(\" \")];\n        tmp === void 0 && (tmp = values[result.join(\".\")]), tmp !== void 0 && (result = tmp);\n      }\n      return result;\n    }, DERNode.prototype._decodeTime = function(buffer, tag) {\n      let str = buffer.raw().toString(), year, mon, day, hour, min, sec;\n      if (tag === \"gentime\")\n        year = str.slice(0, 4) | 0, mon = str.slice(4, 6) | 0, day = str.slice(6, 8) | 0, hour = str.slice(8, 10) | 0, min = str.slice(10, 12) | 0, sec = str.slice(12, 14) | 0;\n      else if (tag === \"utctime\")\n        year = str.slice(0, 2) | 0, mon = str.slice(2, 4) | 0, day = str.slice(4, 6) | 0, hour = str.slice(6, 8) | 0, min = str.slice(8, 10) | 0, sec = str.slice(10, 12) | 0, year < 70 \? year = 2000 + year : year = 1900 + year;\n      else\n        return buffer.error(\"Decoding \" + tag + \" time is not supported yet\");\n      return Date.UTC(year, mon - 1, day, hour, min, sec, 0);\n    }, DERNode.prototype._decodeNull = function() {\n      return null;\n    }, DERNode.prototype._decodeBool = function(buffer) {\n      let res = buffer.readUInt8();\n      return buffer.isError(res) \? res : res !== 0;\n    }, DERNode.prototype._decodeInt = function(buffer, values) {\n      let raw = buffer.raw(), res = new bignum(raw);\n      return values && (res = values[res.toString(10)] || res), res;\n    }, DERNode.prototype._use = function(entity, obj) {\n      return typeof entity == \"function\" && (entity = entity(obj)), entity._getDecoder(\"der\").tree;\n    };\n    function derDecodeTag(buf, fail) {\n      let tag = buf.readUInt8(fail);\n      if (buf.isError(tag))\n        return tag;\n      let cls = der.tagClass[tag >> 6], primitive = (tag & 32) === 0;\n      if ((tag & 31) === 31) {\n        let oct = tag;\n        for (tag = 0;(oct & 128) === 128; ) {\n          if (oct = buf.readUInt8(fail), buf.isError(oct))\n            return oct;\n          tag <<= 7, tag |= oct & 127;\n        }\n      } else\n        tag &= 31;\n      let tagStr = der.tag[tag];\n      return {\n        cls,\n        primitive,\n        tag,\n        tagStr\n      };\n    }\n    function derDecodeLen(buf, primitive, fail) {\n      let len = buf.readUInt8(fail);\n      if (buf.isError(len))\n        return len;\n      if (!primitive && len === 128)\n        return null;\n      if ((len & 128) === 0)\n        return len;\n      let num = len & 127;\n      if (num > 4)\n        return buf.error(\"length octect is too long\");\n      len = 0;\n      for (let i = 0;i < num; i++) {\n        len <<= 8;\n        let j = buf.readUInt8(fail);\n        if (buf.isError(j))\n          return j;\n        len |= j;\n      }\n      return len;\n    }\n  }\n}), require_pem2 = __commonJS({\n  \"node_modules/asn1.js/lib/asn1/decoders/pem.js\"(exports, module) {\n    var inherits = require_inherits_browser(), Buffer2 = require_safer().Buffer, DERDecoder = require_der3();\n    function PEMDecoder(entity) {\n      DERDecoder.call(this, entity), this.enc = \"pem\";\n    }\n    inherits(PEMDecoder, DERDecoder), module.exports = PEMDecoder, PEMDecoder.prototype.decode = function(data, options) {\n      let lines = data.toString().split(/[\\r\\n]+/g), label = options.label.toUpperCase(), re = /^-----(BEGIN|END) ([^-]+)-----$/, start = -1, end = -1;\n      for (let i = 0;i < lines.length; i++) {\n        let match = lines[i].match(re);\n        if (match !== null && match[2] === label)\n          if (start === -1) {\n            if (match[1] !== \"BEGIN\")\n              break;\n            start = i;\n          } else {\n            if (match[1] !== \"END\")\n              break;\n            end = i;\n            break;\n          }\n      }\n      if (start === -1 || end === -1)\n        throw new Error(\"PEM section not found for: \" + label);\n      let base64 = lines.slice(start + 1, end).join(\"\");\n      base64.replace(/[^a-z0-9+/=]+/gi, \"\");\n      let input = Buffer2.from(base64, \"base64\");\n      return DERDecoder.prototype.decode.call(this, input, options);\n    };\n  }\n}), require_decoders = __commonJS({\n  \"node_modules/asn1.js/lib/asn1/decoders/index.js\"(exports) {\n    var decoders = exports;\n    decoders.der = require_der3(), decoders.pem = require_pem2();\n  }\n}), require_api = __commonJS({\n  \"node_modules/asn1.js/lib/asn1/api.js\"(exports) {\n    var encoders = require_encoders(), decoders = require_decoders(), inherits = require_inherits_browser(), api = exports;\n    api.define = function(name, body) {\n      return new Entity(name, body);\n    };\n    function Entity(name, body) {\n      this.name = name, this.body = body, this.decoders = {}, this.encoders = {};\n    }\n    Entity.prototype = {}, Entity.prototype._createNamed = function(Base) {\n      let name = this.name;\n      function Generated(entity) {\n        this._initNamed(entity, name);\n      }\n      return inherits(Generated, Base), Generated.prototype._initNamed = function(entity, name2) {\n        Base.call(this, entity, name2);\n      }, new Generated(this);\n    }, Entity.prototype._getDecoder = function(enc) {\n      return enc = enc || \"der\", this.decoders.hasOwnProperty(enc) || (this.decoders[enc] = this._createNamed(decoders[enc])), this.decoders[enc];\n    }, Entity.prototype.decode = function(data, enc, options) {\n      return this._getDecoder(enc).decode(data, options);\n    }, Entity.prototype._getEncoder = function(enc) {\n      return enc = enc || \"der\", this.encoders.hasOwnProperty(enc) || (this.encoders[enc] = this._createNamed(encoders[enc])), this.encoders[enc];\n    }, Entity.prototype.encode = function(data, enc, reporter) {\n      return this._getEncoder(enc).encode(data, reporter);\n    };\n  }\n}), require_base2 = __commonJS({\n  \"node_modules/asn1.js/lib/asn1/base/index.js\"(exports) {\n    var base = exports;\n    base.Reporter = require_reporter().Reporter, base.DecoderBuffer = require_buffer().DecoderBuffer, base.EncoderBuffer = require_buffer().EncoderBuffer, base.Node = require_node();\n  }\n}), require_constants = __commonJS({\n  \"node_modules/asn1.js/lib/asn1/constants/index.js\"(exports) {\n    var constants = exports;\n    constants._reverse = function(map) {\n      let res = {};\n      return Object.keys(map).forEach(function(key) {\n        (key | 0) == key && (key = key | 0);\n        let value = map[key];\n        res[value] = key;\n      }), res;\n    }, constants.der = require_der();\n  }\n}), require_asn1 = __commonJS({\n  \"node_modules/asn1.js/lib/asn1.js\"(exports) {\n    var asn1 = exports;\n    asn1.bignum = require_bn5(), asn1.define = require_api().define, asn1.base = require_base2(), asn1.constants = require_constants(), asn1.decoders = require_decoders(), asn1.encoders = require_encoders();\n  }\n}), require_certificate = __commonJS({\n  \"node_modules/parse-asn1/certificate.js\"(exports, module) {\n    var asn = require_asn1(), Time = asn.define(\"Time\", function() {\n      this.choice({\n        utcTime: this.utctime(),\n        generalTime: this.gentime()\n      });\n    }), AttributeTypeValue = asn.define(\"AttributeTypeValue\", function() {\n      this.seq().obj(this.key(\"type\").objid(), this.key(\"value\").any());\n    }), AlgorithmIdentifier = asn.define(\"AlgorithmIdentifier\", function() {\n      this.seq().obj(this.key(\"algorithm\").objid(), this.key(\"parameters\").optional(), this.key(\"curve\").objid().optional());\n    }), SubjectPublicKeyInfo = asn.define(\"SubjectPublicKeyInfo\", function() {\n      this.seq().obj(this.key(\"algorithm\").use(AlgorithmIdentifier), this.key(\"subjectPublicKey\").bitstr());\n    }), RelativeDistinguishedName = asn.define(\"RelativeDistinguishedName\", function() {\n      this.setof(AttributeTypeValue);\n    }), RDNSequence = asn.define(\"RDNSequence\", function() {\n      this.seqof(RelativeDistinguishedName);\n    }), Name = asn.define(\"Name\", function() {\n      this.choice({\n        rdnSequence: this.use(RDNSequence)\n      });\n    }), Validity = asn.define(\"Validity\", function() {\n      this.seq().obj(this.key(\"notBefore\").use(Time), this.key(\"notAfter\").use(Time));\n    }), Extension = asn.define(\"Extension\", function() {\n      this.seq().obj(this.key(\"extnID\").objid(), this.key(\"critical\").bool().def(!1), this.key(\"extnValue\").octstr());\n    }), TBSCertificate = asn.define(\"TBSCertificate\", function() {\n      this.seq().obj(this.key(\"version\").explicit(0).int().optional(), this.key(\"serialNumber\").int(), this.key(\"signature\").use(AlgorithmIdentifier), this.key(\"issuer\").use(Name), this.key(\"validity\").use(Validity), this.key(\"subject\").use(Name), this.key(\"subjectPublicKeyInfo\").use(SubjectPublicKeyInfo), this.key(\"issuerUniqueID\").implicit(1).bitstr().optional(), this.key(\"subjectUniqueID\").implicit(2).bitstr().optional(), this.key(\"extensions\").explicit(3).seqof(Extension).optional());\n    }), X509Certificate = asn.define(\"X509Certificate\", function() {\n      this.seq().obj(this.key(\"tbsCertificate\").use(TBSCertificate), this.key(\"signatureAlgorithm\").use(AlgorithmIdentifier), this.key(\"signatureValue\").bitstr());\n    });\n    module.exports = X509Certificate;\n  }\n}), require_asn12 = __commonJS({\n  \"node_modules/parse-asn1/asn1.js\"(exports) {\n    var asn1 = require_asn1();\n    exports.certificate = require_certificate();\n    var RSAPrivateKey = asn1.define(\"RSAPrivateKey\", function() {\n      this.seq().obj(this.key(\"version\").int(), this.key(\"modulus\").int(), this.key(\"publicExponent\").int(), this.key(\"privateExponent\").int(), this.key(\"prime1\").int(), this.key(\"prime2\").int(), this.key(\"exponent1\").int(), this.key(\"exponent2\").int(), this.key(\"coefficient\").int());\n    });\n    exports.RSAPrivateKey = RSAPrivateKey;\n    var RSAPublicKey = asn1.define(\"RSAPublicKey\", function() {\n      this.seq().obj(this.key(\"modulus\").int(), this.key(\"publicExponent\").int());\n    });\n    exports.RSAPublicKey = RSAPublicKey;\n    var PublicKey = asn1.define(\"SubjectPublicKeyInfo\", function() {\n      this.seq().obj(this.key(\"algorithm\").use(AlgorithmIdentifier), this.key(\"subjectPublicKey\").bitstr());\n    });\n    exports.PublicKey = PublicKey;\n    var AlgorithmIdentifier = asn1.define(\"AlgorithmIdentifier\", function() {\n      this.seq().obj(this.key(\"algorithm\").objid(), this.key(\"none\").null_().optional(), this.key(\"curve\").objid().optional(), this.key(\"params\").seq().obj(this.key(\"p\").int(), this.key(\"q\").int(), this.key(\"g\").int()).optional());\n    }), PrivateKeyInfo = asn1.define(\"PrivateKeyInfo\", function() {\n      this.seq().obj(this.key(\"version\").int(), this.key(\"algorithm\").use(AlgorithmIdentifier), this.key(\"subjectPrivateKey\").octstr());\n    });\n    exports.PrivateKey = PrivateKeyInfo;\n    var EncryptedPrivateKeyInfo = asn1.define(\"EncryptedPrivateKeyInfo\", function() {\n      this.seq().obj(this.key(\"algorithm\").seq().obj(this.key(\"id\").objid(), this.key(\"decrypt\").seq().obj(this.key(\"kde\").seq().obj(this.key(\"id\").objid(), this.key(\"kdeparams\").seq().obj(this.key(\"salt\").octstr(), this.key(\"iters\").int())), this.key(\"cipher\").seq().obj(this.key(\"algo\").objid(), this.key(\"iv\").octstr()))), this.key(\"subjectPrivateKey\").octstr());\n    });\n    exports.EncryptedPrivateKey = EncryptedPrivateKeyInfo;\n    var DSAPrivateKey = asn1.define(\"DSAPrivateKey\", function() {\n      this.seq().obj(this.key(\"version\").int(), this.key(\"p\").int(), this.key(\"q\").int(), this.key(\"g\").int(), this.key(\"pub_key\").int(), this.key(\"priv_key\").int());\n    });\n    exports.DSAPrivateKey = DSAPrivateKey, exports.DSAparam = asn1.define(\"DSAparam\", function() {\n      this.int();\n    });\n    var ECPrivateKey = asn1.define(\"ECPrivateKey\", function() {\n      this.seq().obj(this.key(\"version\").int(), this.key(\"privateKey\").octstr(), this.key(\"parameters\").optional().explicit(0).use(ECParameters), this.key(\"publicKey\").optional().explicit(1).bitstr());\n    });\n    exports.ECPrivateKey = ECPrivateKey;\n    var ECParameters = asn1.define(\"ECParameters\", function() {\n      this.choice({\n        namedCurve: this.objid()\n      });\n    });\n    exports.signature = asn1.define(\"signature\", function() {\n      this.seq().obj(this.key(\"r\").int(), this.key(\"s\").int());\n    });\n  }\n}), require_aesid = __commonJS({\n  \"node_modules/parse-asn1/aesid.json\"(exports, module) {\n    module.exports = {\n      \"2.16.840.1.101.3.4.1.1\": \"aes-128-ecb\",\n      \"2.16.840.1.101.3.4.1.2\": \"aes-128-cbc\",\n      \"2.16.840.1.101.3.4.1.3\": \"aes-128-ofb\",\n      \"2.16.840.1.101.3.4.1.4\": \"aes-128-cfb\",\n      \"2.16.840.1.101.3.4.1.21\": \"aes-192-ecb\",\n      \"2.16.840.1.101.3.4.1.22\": \"aes-192-cbc\",\n      \"2.16.840.1.101.3.4.1.23\": \"aes-192-ofb\",\n      \"2.16.840.1.101.3.4.1.24\": \"aes-192-cfb\",\n      \"2.16.840.1.101.3.4.1.41\": \"aes-256-ecb\",\n      \"2.16.840.1.101.3.4.1.42\": \"aes-256-cbc\",\n      \"2.16.840.1.101.3.4.1.43\": \"aes-256-ofb\",\n      \"2.16.840.1.101.3.4.1.44\": \"aes-256-cfb\"\n    };\n  }\n}), require_fixProc = __commonJS({\n  \"node_modules/parse-asn1/fixProc.js\"(exports, module) {\n    var findProc = /Proc-Type: 4,ENCRYPTED[\\n\\r]+DEK-Info: AES-((\?:128)|(\?:192)|(\?:256))-CBC,([0-9A-H]+)[\\n\\r]+([0-9A-z\\n\\r+/=]+)[\\n\\r]+/m, startRegex = /^-----BEGIN ((\?:.*\? KEY)|CERTIFICATE)-----/m, fullRegex = /^-----BEGIN ((\?:.*\? KEY)|CERTIFICATE)-----([0-9A-z\\n\\r+/=]+)-----END \\1-----$/m, evp = require_evp_bytestokey(), ciphers = require_browser5(), Buffer2 = require_safe_buffer().Buffer;\n    module.exports = function(okey, password) {\n      var key = okey.toString(), match = key.match(findProc), decrypted;\n      if (match) {\n        var suite = \"aes\" + match[1], iv = Buffer2.from(match[2], \"hex\"), cipherText = Buffer2.from(match[3].replace(/[\\r\\n]/g, \"\"), \"base64\"), cipherKey = evp(password, iv.slice(0, 8), parseInt(match[1], 10)).key, out = [], cipher = ciphers.createDecipheriv(suite, cipherKey, iv);\n        out.push(cipher.update(cipherText)), out.push(cipher.final()), decrypted = Buffer2.concat(out);\n      } else {\n        var match2 = key.match(fullRegex);\n        decrypted = Buffer2.from(match2[2].replace(/[\\r\\n]/g, \"\"), \"base64\");\n      }\n      var tag = key.match(startRegex)[1];\n      return {\n        tag,\n        data: decrypted\n      };\n    };\n  }\n}), require_parse_asn1 = __commonJS({\n  \"node_modules/parse-asn1/index.js\"(exports, module) {\n    var asn1 = require_asn12(), aesid = require_aesid(), fixProc = require_fixProc(), ciphers = require_browser5(), compat = require_browser4(), Buffer2 = require_safe_buffer().Buffer;\n    module.exports = parseKeys;\n    function parseKeys(buffer) {\n      var password;\n      typeof buffer == \"object\" && !Buffer2.isBuffer(buffer) && (password = buffer.passphrase, buffer = buffer.key), typeof buffer == \"string\" && (buffer = Buffer2.from(buffer));\n      var stripped = fixProc(buffer, password), type = stripped.tag, data = stripped.data, subtype, ndata;\n      switch (type) {\n        case \"CERTIFICATE\":\n          ndata = asn1.certificate.decode(data, \"der\").tbsCertificate.subjectPublicKeyInfo;\n        case \"PUBLIC KEY\":\n          switch (ndata || (ndata = asn1.PublicKey.decode(data, \"der\")), subtype = ndata.algorithm.algorithm.join(\".\"), subtype) {\n            case \"1.2.840.113549.1.1.1\":\n              return asn1.RSAPublicKey.decode(ndata.subjectPublicKey.data, \"der\");\n            case \"1.2.840.10045.2.1\":\n              return ndata.subjectPrivateKey = ndata.subjectPublicKey, {\n                type: \"ec\",\n                data: ndata\n              };\n            case \"1.2.840.10040.4.1\":\n              return ndata.algorithm.params.pub_key = asn1.DSAparam.decode(ndata.subjectPublicKey.data, \"der\"), {\n                type: \"dsa\",\n                data: ndata.algorithm.params\n              };\n            default:\n              throw new Error(\"unknown key id \" + subtype);\n          }\n        case \"ENCRYPTED PRIVATE KEY\":\n          data = asn1.EncryptedPrivateKey.decode(data, \"der\"), data = decrypt(data, password);\n        case \"PRIVATE KEY\":\n          switch (ndata = asn1.PrivateKey.decode(data, \"der\"), subtype = ndata.algorithm.algorithm.join(\".\"), subtype) {\n            case \"1.2.840.113549.1.1.1\":\n              return asn1.RSAPrivateKey.decode(ndata.subjectPrivateKey, \"der\");\n            case \"1.2.840.10045.2.1\":\n              return {\n                curve: ndata.algorithm.curve,\n                privateKey: asn1.ECPrivateKey.decode(ndata.subjectPrivateKey, \"der\").privateKey\n              };\n            case \"1.2.840.10040.4.1\":\n              return ndata.algorithm.params.priv_key = asn1.DSAparam.decode(ndata.subjectPrivateKey, \"der\"), {\n                type: \"dsa\",\n                params: ndata.algorithm.params\n              };\n            default:\n              throw new Error(\"unknown key id \" + subtype);\n          }\n        case \"RSA PUBLIC KEY\":\n          return asn1.RSAPublicKey.decode(data, \"der\");\n        case \"RSA PRIVATE KEY\":\n          return asn1.RSAPrivateKey.decode(data, \"der\");\n        case \"DSA PRIVATE KEY\":\n          return {\n            type: \"dsa\",\n            params: asn1.DSAPrivateKey.decode(data, \"der\")\n          };\n        case \"EC PRIVATE KEY\":\n          return data = asn1.ECPrivateKey.decode(data, \"der\"), {\n            curve: data.parameters.value,\n            privateKey: data.privateKey\n          };\n        default:\n          throw new Error(\"unknown key type \" + type);\n      }\n    }\n    parseKeys.signature = asn1.signature;\n    function decrypt(data, password) {\n      var salt = data.algorithm.decrypt.kde.kdeparams.salt, iters = parseInt(data.algorithm.decrypt.kde.kdeparams.iters.toString(), 10), algo = aesid[data.algorithm.decrypt.cipher.algo.join(\".\")], iv = data.algorithm.decrypt.cipher.iv, cipherText = data.subjectPrivateKey, keylen = parseInt(algo.split(\"-\")[1], 10) / 8, key = compat.pbkdf2Sync(password, salt, iters, keylen, \"sha1\"), cipher = ciphers.createDecipheriv(algo, key, iv), out = [];\n      return out.push(cipher.update(cipherText)), out.push(cipher.final()), Buffer2.concat(out);\n    }\n  }\n}), require_curves2 = __commonJS({\n  \"node_modules/browserify-sign/browser/curves.json\"(exports, module) {\n    module.exports = {\n      \"1.3.132.0.10\": \"secp256k1\",\n      \"1.3.132.0.33\": \"p224\",\n      \"1.2.840.10045.3.1.1\": \"p192\",\n      \"1.2.840.10045.3.1.7\": \"p256\",\n      \"1.3.132.0.34\": \"p384\",\n      \"1.3.132.0.35\": \"p521\"\n    };\n  }\n}), require_sign = __commonJS({\n  \"node_modules/browserify-sign/browser/sign.js\"(exports, module) {\n    var Buffer2 = require_safe_buffer().Buffer, createHmac = require_browser3(), crt = require_browserify_rsa(), EC = require_elliptic().ec, BN = require_bn3(), parseKeys = require_parse_asn1(), curves = require_curves2();\n    function sign(hash, key, hashType, signType, tag) {\n      var priv = parseKeys(key);\n      if (priv.curve) {\n        if (signType !== \"ecdsa\" && signType !== \"ecdsa/rsa\")\n          throw new Error(\"wrong private key type\");\n        return ecSign(hash, priv);\n      } else if (priv.type === \"dsa\") {\n        if (signType !== \"dsa\")\n          throw new Error(\"wrong private key type\");\n        return dsaSign(hash, priv, hashType);\n      } else if (signType !== \"rsa\" && signType !== \"ecdsa/rsa\")\n        throw new Error(\"wrong private key type\");\n      hash = Buffer2.concat([tag, hash]);\n      for (var len = priv.modulus.byteLength(), pad = [0, 1];hash.length + pad.length + 1 < len; )\n        pad.push(255);\n      pad.push(0);\n      for (var i = -1;++i < hash.length; )\n        pad.push(hash[i]);\n      var out = crt(pad, priv);\n      return out;\n    }\n    function ecSign(hash, priv) {\n      var curveId = curves[priv.curve.join(\".\")];\n      if (!curveId)\n        throw new Error(\"unknown curve \" + priv.curve.join(\".\"));\n      var curve = new EC(curveId), key = curve.keyFromPrivate(priv.privateKey), out = key.sign(hash);\n      return Buffer2.from(out.toDER());\n    }\n    function dsaSign(hash, priv, algo) {\n      for (var x = priv.params.priv_key, p = priv.params.p, q = priv.params.q, g = priv.params.g, r = new BN(0), k, H = bits2int(hash, q).mod(q), s = !1, kv = getKey(x, q, hash, algo);s === !1; )\n        k = makeKey(q, kv, algo), r = makeR(g, k, p, q), s = k.invm(q).imul(H.add(x.mul(r))).mod(q), s.cmpn(0) === 0 && (s = !1, r = new BN(0));\n      return toDER(r, s);\n    }\n    function toDER(r, s) {\n      r = r.toArray(), s = s.toArray(), r[0] & 128 && (r = [0].concat(r)), s[0] & 128 && (s = [0].concat(s));\n      var total = r.length + s.length + 4, res = [48, total, 2, r.length];\n      return res = res.concat(r, [2, s.length], s), Buffer2.from(res);\n    }\n    function getKey(x, q, hash, algo) {\n      if (x = Buffer2.from(x.toArray()), x.length < q.byteLength()) {\n        var zeros = Buffer2.alloc(q.byteLength() - x.length);\n        x = Buffer2.concat([zeros, x]);\n      }\n      var hlen = hash.length, hbits = bits2octets(hash, q), v = Buffer2.alloc(hlen);\n      v.fill(1);\n      var k = Buffer2.alloc(hlen);\n      return k = createHmac(algo, k).update(v).update(Buffer2.from([0])).update(x).update(hbits).digest(), v = createHmac(algo, k).update(v).digest(), k = createHmac(algo, k).update(v).update(Buffer2.from([1])).update(x).update(hbits).digest(), v = createHmac(algo, k).update(v).digest(), { k, v };\n    }\n    function bits2int(obits, q) {\n      var bits = new BN(obits), shift = (obits.length << 3) - q.bitLength();\n      return shift > 0 && bits.ishrn(shift), bits;\n    }\n    function bits2octets(bits, q) {\n      bits = bits2int(bits, q), bits = bits.mod(q);\n      var out = Buffer2.from(bits.toArray());\n      if (out.length < q.byteLength()) {\n        var zeros = Buffer2.alloc(q.byteLength() - out.length);\n        out = Buffer2.concat([zeros, out]);\n      }\n      return out;\n    }\n    function makeKey(q, kv, algo) {\n      var t, k;\n      do {\n        for (t = Buffer2.alloc(0);t.length * 8 < q.bitLength(); )\n          kv.v = createHmac(algo, kv.k).update(kv.v).digest(), t = Buffer2.concat([t, kv.v]);\n        k = bits2int(t, q), kv.k = createHmac(algo, kv.k).update(kv.v).update(Buffer2.from([0])).digest(), kv.v = createHmac(algo, kv.k).update(kv.v).digest();\n      } while (k.cmp(q) !== -1);\n      return k;\n    }\n    function makeR(g, k, p, q) {\n      return g.toRed(BN.mont(p)).redPow(k).fromRed().mod(q);\n    }\n    module.exports = sign, module.exports.getKey = getKey, module.exports.makeKey = makeKey;\n  }\n}), require_verify = __commonJS({\n  \"node_modules/browserify-sign/browser/verify.js\"(exports, module) {\n    var Buffer2 = require_safe_buffer().Buffer, BN = require_bn3(), EC = require_elliptic().ec, parseKeys = require_parse_asn1(), curves = require_curves2();\n    function verify(sig, hash, key, signType, tag) {\n      var pub = parseKeys(key);\n      if (pub.type === \"ec\") {\n        if (signType !== \"ecdsa\" && signType !== \"ecdsa/rsa\")\n          throw new Error(\"wrong public key type\");\n        return ecVerify(sig, hash, pub);\n      } else if (pub.type === \"dsa\") {\n        if (signType !== \"dsa\")\n          throw new Error(\"wrong public key type\");\n        return dsaVerify(sig, hash, pub);\n      } else if (signType !== \"rsa\" && signType !== \"ecdsa/rsa\")\n        throw new Error(\"wrong public key type\");\n      hash = Buffer2.concat([tag, hash]);\n      for (var len = pub.modulus.byteLength(), pad = [1], padNum = 0;hash.length + pad.length + 2 < len; )\n        pad.push(255), padNum++;\n      pad.push(0);\n      for (var i = -1;++i < hash.length; )\n        pad.push(hash[i]);\n      pad = Buffer2.from(pad);\n      var red = BN.mont(pub.modulus);\n      sig = new BN(sig).toRed(red), sig = sig.redPow(new BN(pub.publicExponent)), sig = Buffer2.from(sig.fromRed().toArray());\n      var out = padNum < 8 \? 1 : 0;\n      for (len = Math.min(sig.length, pad.length), sig.length !== pad.length && (out = 1), i = -1;++i < len; )\n        out |= sig[i] ^ pad[i];\n      return out === 0;\n    }\n    function ecVerify(sig, hash, pub) {\n      var curveId = curves[pub.data.algorithm.curve.join(\".\")];\n      if (!curveId)\n        throw new Error(\"unknown curve \" + pub.data.algorithm.curve.join(\".\"));\n      var curve = new EC(curveId), pubkey = pub.data.subjectPrivateKey.data;\n      return curve.verify(hash, sig, pubkey);\n    }\n    function dsaVerify(sig, hash, pub) {\n      var p = pub.data.p, q = pub.data.q, g = pub.data.g, y = pub.data.pub_key, unpacked = parseKeys.signature.decode(sig, \"der\"), s = unpacked.s, r = unpacked.r;\n      checkValue(s, q), checkValue(r, q);\n      var montp = BN.mont(p), w = s.invm(q), v = g.toRed(montp).redPow(new BN(hash).mul(w).mod(q)).fromRed().mul(y.toRed(montp).redPow(r.mul(w).mod(q)).fromRed()).mod(p).mod(q);\n      return v.cmp(r) === 0;\n    }\n    function checkValue(b, q) {\n      if (b.cmpn(0) <= 0)\n        throw new Error(\"invalid sig\");\n      if (b.cmp(q) >= q)\n        throw new Error(\"invalid sig\");\n    }\n    module.exports = verify;\n  }\n}), require_browser8 = __commonJS({\n  \"node_modules/browserify-sign/browser/index.js\"(exports, module) {\n    var Buffer2 = require_safe_buffer().Buffer, createHash = require_browser2(), inherits = require_inherits_browser(), sign = require_sign(), verify = require_verify(), algorithms = require_algorithms();\n    Object.keys(algorithms).forEach(function(key) {\n      algorithms[key].id = Buffer2.from(algorithms[key].id, \"hex\"), algorithms[key.toLowerCase()] = algorithms[key];\n    });\n    function Sign(algorithm) {\n      StreamModule.Writable.call(this);\n      var data = algorithms[algorithm];\n      if (!data)\n        throw new Error(\"Unknown message digest\");\n      this._hashType = data.hash, this._hash = createHash(data.hash), this._tag = data.id, this._signType = data.sign;\n    }\n    inherits(Sign, StreamModule.Writable), Sign.prototype._write = function(data, _, done) {\n      this._hash.update(data), done();\n    }, Sign.prototype.update = function(data, enc) {\n      return typeof data == \"string\" && (data = Buffer2.from(data, enc)), this._hash.update(data), this;\n    }, Sign.prototype.sign = function(key, enc) {\n      this.end();\n      var hash = this._hash.digest(), sig = sign(hash, key, this._hashType, this._signType, this._tag);\n      return enc \? sig.toString(enc) : sig;\n    };\n    function Verify(algorithm) {\n      StreamModule.Writable.call(this);\n      var data = algorithms[algorithm];\n      if (!data)\n        throw new Error(\"Unknown message digest\");\n      this._hash = createHash(data.hash), this._tag = data.id, this._signType = data.sign;\n    }\n    inherits(Verify, StreamModule.Writable), Verify.prototype._write = function(data, _, done) {\n      this._hash.update(data), done();\n    }, Verify.prototype.update = function(data, enc) {\n      return typeof data == \"string\" && (data = Buffer2.from(data, enc)), this._hash.update(data), this;\n    }, Verify.prototype.verify = function(key, sig, enc) {\n      typeof sig == \"string\" && (sig = Buffer2.from(sig, enc)), this.end();\n      var hash = this._hash.digest();\n      return verify(sig, hash, key, this._signType, this._tag);\n    };\n    function createSign(algorithm) {\n      return new Sign(algorithm);\n    }\n    function createVerify(algorithm) {\n      return new Verify(algorithm);\n    }\n    module.exports = {\n      Sign: createSign,\n      Verify: createVerify,\n      createSign,\n      createVerify\n    };\n  }\n}), require_bn6 = require_bn, require_browser9 = __commonJS({\n  \"node_modules/create-ecdh/browser.js\"(exports, module) {\n    var elliptic = require_elliptic(), BN = require_bn6();\n    module.exports = function(curve) {\n      return new ECDH(curve);\n    };\n    var aliases = {\n      secp256k1: {\n        name: \"secp256k1\",\n        byteLength: 32\n      },\n      secp224r1: {\n        name: \"p224\",\n        byteLength: 28\n      },\n      prime256v1: {\n        name: \"p256\",\n        byteLength: 32\n      },\n      prime192v1: {\n        name: \"p192\",\n        byteLength: 24\n      },\n      ed25519: {\n        name: \"ed25519\",\n        byteLength: 32\n      },\n      secp384r1: {\n        name: \"p384\",\n        byteLength: 48\n      },\n      secp521r1: {\n        name: \"p521\",\n        byteLength: 66\n      }\n    };\n    aliases.p224 = aliases.secp224r1, aliases.p256 = aliases.secp256r1 = aliases.prime256v1, aliases.p192 = aliases.secp192r1 = aliases.prime192v1, aliases.p384 = aliases.secp384r1, aliases.p521 = aliases.secp521r1;\n    function ECDH(curve) {\n      this.curveType = aliases[curve], this.curveType || (this.curveType = {\n        name: curve\n      }), this.curve = new elliptic.ec(this.curveType.name), this.keys = void 0;\n    }\n    ECDH.prototype = {}, ECDH.prototype.generateKeys = function(enc, format) {\n      return this.keys = this.curve.genKeyPair(), this.getPublicKey(enc, format);\n    }, ECDH.prototype.computeSecret = function(other, inenc, enc) {\n      inenc = inenc || \"utf8\", Buffer.isBuffer(other) || (other = new Buffer(other, inenc));\n      var otherPub = this.curve.keyFromPublic(other).getPublic(), out = otherPub.mul(this.keys.getPrivate()).getX();\n      return formatReturnValue(out, enc, this.curveType.byteLength);\n    }, ECDH.prototype.getPublicKey = function(enc, format) {\n      var key = this.keys.getPublic(format === \"compressed\", !0);\n      return format === \"hybrid\" && (key[key.length - 1] % 2 \? key[0] = 7 : key[0] = 6), formatReturnValue(key, enc);\n    }, ECDH.prototype.getPrivateKey = function(enc) {\n      return formatReturnValue(this.keys.getPrivate(), enc);\n    }, ECDH.prototype.setPublicKey = function(pub, enc) {\n      return enc = enc || \"utf8\", Buffer.isBuffer(pub) || (pub = new Buffer(pub, enc)), this.keys._importPublic(pub), this;\n    }, ECDH.prototype.setPrivateKey = function(priv, enc) {\n      enc = enc || \"utf8\", Buffer.isBuffer(priv) || (priv = new Buffer(priv, enc));\n      var _priv = new BN(priv);\n      return _priv = _priv.toString(16), this.keys = this.curve.genKeyPair(), this.keys._importPrivate(_priv), this;\n    };\n    function formatReturnValue(bn, enc, len) {\n      Array.isArray(bn) || (bn = bn.toArray());\n      var buf = new Buffer(bn);\n      if (len && buf.length < len) {\n        var zeros = new Buffer(len - buf.length);\n        zeros.fill(0), buf = Buffer.concat([zeros, buf]);\n      }\n      return enc \? buf.toString(enc) : buf;\n    }\n  }\n}), require_mgf = __commonJS({\n  \"node_modules/public-encrypt/mgf.js\"(exports, module) {\n    var createHash = require_browser2(), Buffer2 = require_safe_buffer().Buffer;\n    module.exports = function(seed, len) {\n      for (var t = Buffer2.alloc(0), i = 0, c;t.length < len; )\n        c = i2ops(i++), t = Buffer2.concat([t, createHash(\"sha1\").update(seed).update(c).digest()]);\n      return t.slice(0, len);\n    };\n    function i2ops(c) {\n      var out = Buffer2.allocUnsafe(4);\n      return out.writeUInt32BE(c, 0), out;\n    }\n  }\n}), require_xor = __commonJS({\n  \"node_modules/public-encrypt/xor.js\"(exports, module) {\n    module.exports = function(a, b) {\n      for (var len = a.length, i = -1;++i < len; )\n        a[i] ^= b[i];\n      return a;\n    };\n  }\n}), require_bn7 = require_bn, { CryptoHasher } = globalThis.Bun, require_withPublic = __commonJS({\n  \"node_modules/public-encrypt/withPublic.js\"(exports, module) {\n    var BN = require_bn7(), Buffer2 = require_safe_buffer().Buffer;\n    function withPublic(paddedMsg, key) {\n      return Buffer2.from(paddedMsg.toRed(BN.mont(key.modulus)).redPow(new BN(key.publicExponent)).fromRed().toArray());\n    }\n    module.exports = withPublic;\n  }\n}), require_publicEncrypt = __commonJS({\n  \"node_modules/public-encrypt/publicEncrypt.js\"(exports, module) {\n    var parseKeys = require_parse_asn1(), randomBytes = require_browser(), createHash = require_browser2(), mgf = require_mgf(), xor = require_xor(), BN = require_bn7(), withPublic = require_withPublic(), crt = require_browserify_rsa(), Buffer2 = require_safe_buffer().Buffer;\n    module.exports = function(publicKey, msg, reverse) {\n      var padding;\n      publicKey.padding \? padding = publicKey.padding : reverse \? padding = 1 : padding = 4;\n      var key = parseKeys(publicKey), paddedMsg;\n      if (padding === 4)\n        paddedMsg = oaep(key, msg);\n      else if (padding === 1)\n        paddedMsg = pkcs1(key, msg, reverse);\n      else if (padding === 3) {\n        if (paddedMsg = new BN(msg), paddedMsg.cmp(key.modulus) >= 0)\n          throw new Error(\"data too long for modulus\");\n      } else\n        throw new Error(\"unknown padding\");\n      return reverse \? crt(paddedMsg, key) : withPublic(paddedMsg, key);\n    };\n    function oaep(key, msg) {\n      var k = key.modulus.byteLength(), mLen = msg.length, iHash = createHash(\"sha1\").update(Buffer2.alloc(0)).digest(), hLen = iHash.length, hLen2 = 2 * hLen;\n      if (mLen > k - hLen2 - 2)\n        throw new Error(\"message too long\");\n      var ps = Buffer2.alloc(k - mLen - hLen2 - 2), dblen = k - hLen - 1, seed = randomBytes(hLen), maskedDb = xor(Buffer2.concat([iHash, ps, Buffer2.alloc(1, 1), msg], dblen), mgf(seed, dblen)), maskedSeed = xor(seed, mgf(maskedDb, hLen));\n      return new BN(Buffer2.concat([Buffer2.alloc(1), maskedSeed, maskedDb], k));\n    }\n    function pkcs1(key, msg, reverse) {\n      var mLen = msg.length, k = key.modulus.byteLength();\n      if (mLen > k - 11)\n        throw new Error(\"message too long\");\n      var ps;\n      return reverse \? ps = Buffer2.alloc(k - mLen - 3, 255) : ps = nonZero(k - mLen - 3), new BN(Buffer2.concat([Buffer2.from([0, reverse \? 1 : 2]), ps, Buffer2.alloc(1), msg], k));\n    }\n    function nonZero(len) {\n      for (var out = Buffer2.allocUnsafe(len), i = 0, cache = randomBytes(len * 2), cur = 0, num;i < len; )\n        cur === cache.length && (cache = randomBytes(len * 2), cur = 0), num = cache[cur++], num && (out[i++] = num);\n      return out;\n    }\n  }\n}), require_privateDecrypt = __commonJS({\n  \"node_modules/public-encrypt/privateDecrypt.js\"(exports, module) {\n    var parseKeys = require_parse_asn1(), mgf = require_mgf(), xor = require_xor(), BN = require_bn7(), crt = require_browserify_rsa(), createHash = require_browser2(), withPublic = require_withPublic(), Buffer2 = require_safe_buffer().Buffer;\n    module.exports = function(privateKey, enc, reverse) {\n      var padding;\n      privateKey.padding \? padding = privateKey.padding : reverse \? padding = 1 : padding = 4;\n      var key = parseKeys(privateKey), k = key.modulus.byteLength();\n      if (enc.length > k || new BN(enc).cmp(key.modulus) >= 0)\n        throw new Error(\"decryption error\");\n      var msg;\n      reverse \? msg = withPublic(new BN(enc), key) : msg = crt(enc, key);\n      var zBuffer = Buffer2.alloc(k - msg.length);\n      if (msg = Buffer2.concat([zBuffer, msg], k), padding === 4)\n        return oaep(key, msg);\n      if (padding === 1)\n        return pkcs1(key, msg, reverse);\n      if (padding === 3)\n        return msg;\n      throw new Error(\"unknown padding\");\n    };\n    function oaep(key, msg) {\n      var k = key.modulus.byteLength(), iHash = createHash(\"sha1\").update(Buffer2.alloc(0)).digest(), hLen = iHash.length;\n      if (msg[0] !== 0)\n        throw new Error(\"decryption error\");\n      var maskedSeed = msg.slice(1, hLen + 1), maskedDb = msg.slice(hLen + 1), seed = xor(maskedSeed, mgf(maskedDb, hLen)), db = xor(maskedDb, mgf(seed, k - hLen - 1));\n      if (compare(iHash, db.slice(0, hLen)))\n        throw new Error(\"decryption error\");\n      for (var i = hLen;db[i] === 0; )\n        i++;\n      if (db[i++] !== 1)\n        throw new Error(\"decryption error\");\n      return db.slice(i);\n    }\n    function pkcs1(key, msg, reverse) {\n      for (var p1 = msg.slice(0, 2), i = 2, status = 0;msg[i++] !== 0; )\n        if (i >= msg.length) {\n          status++;\n          break;\n        }\n      var ps = msg.slice(2, i - 1);\n      if ((p1.toString(\"hex\") !== \"0002\" && !reverse || p1.toString(\"hex\") !== \"0001\" && reverse) && status++, ps.length < 8 && status++, status)\n        throw new Error(\"decryption error\");\n      return msg.slice(i);\n    }\n    function compare(a, b) {\n      a = Buffer2.from(a), b = Buffer2.from(b);\n      var dif = 0, len = a.length;\n      a.length !== b.length && (dif++, len = Math.min(a.length, b.length));\n      for (var i = -1;++i < len; )\n        dif += a[i] ^ b[i];\n      return dif;\n    }\n  }\n}), require_browser10 = __commonJS({\n  \"node_modules/public-encrypt/browser.js\"(exports) {\n    exports.publicEncrypt = require_publicEncrypt(), exports.privateDecrypt = require_privateDecrypt(), exports.privateEncrypt = function(key, buf) {\n      return exports.publicEncrypt(key, buf, !0);\n    }, exports.publicDecrypt = function(key, buf) {\n      return exports.privateDecrypt(key, buf, !0);\n    };\n  }\n}), require_browser11 = __commonJS({\n  \"node_modules/randomfill/browser.js\"(exports) {\n    var safeBuffer = require_safe_buffer(), randombytes = require_browser(), Buffer2 = safeBuffer.Buffer, kBufferMaxLength = safeBuffer.kMaxLength, kMaxUint32 = Math.pow(2, 32) - 1;\n    function assertOffset(offset, length) {\n      if (typeof offset != \"number\" || offset !== offset)\n        @throwTypeError(\"offset must be a number\");\n      if (offset > kMaxUint32 || offset < 0)\n        @throwTypeError(\"offset must be a uint32\");\n      if (offset > kBufferMaxLength || offset > length)\n        @throwRangeError(\"offset out of range\");\n    }\n    function assertSize(size, offset, length) {\n      if (typeof size != \"number\" || size !== size)\n        @throwTypeError(\"size must be a number\");\n      if (size > kMaxUint32 || size < 0)\n        @throwTypeError(\"size must be a uint32\");\n      if (size + offset > length || size > kBufferMaxLength)\n        @throwRangeError(\"buffer too small\");\n    }\n    exports.randomFill = randomFill, exports.randomFillSync = randomFillSync;\n    function randomFill(buf, offset, size, cb) {\n      if (!Buffer2.isBuffer(buf) && !(buf instanceof global.Uint8Array))\n        @throwTypeError('\"buf\" argument must be a Buffer or Uint8Array');\n      if (typeof offset == \"function\")\n        cb = offset, offset = 0, size = buf.length;\n      else if (typeof size == \"function\")\n        cb = size, size = buf.length - offset;\n      else if (typeof cb != \"function\")\n        @throwTypeError('\"cb\" argument must be a function');\n      return assertOffset(offset, buf.length), assertSize(size, offset, buf.length), actualFill(buf, offset, size, cb);\n    }\n    function actualFill(buf, offset, size, cb) {\n      if (cb) {\n        randombytes(size, function(err, bytes2) {\n          if (err)\n            return cb(err);\n          bytes2.copy(buf, offset), cb(null, buf);\n        });\n        return;\n      }\n      var bytes = randombytes(size);\n      return bytes.copy(buf, offset), buf;\n    }\n    function randomFillSync(buf, offset, size) {\n      if (typeof offset > \"u\" && (offset = 0), !Buffer2.isBuffer(buf) && !(buf instanceof global.Uint8Array))\n        @throwTypeError('\"buf\" argument must be a Buffer or Uint8Array');\n      return assertOffset(offset, buf.length), size === void 0 && (size = buf.length - offset), assertSize(size, offset, buf.length), actualFill(buf, offset, size);\n    }\n  }\n}), require_crypto_browserify2 = __commonJS({\n  \"node_modules/crypto-browserify/index.js\"(exports) {\n    exports.randomBytes = exports.rng = exports.pseudoRandomBytes = exports.prng = require_browser(), exports.createHash = require_browser2(), exports.Hash = exports.createHash.Hash, exports.createHmac = exports.Hmac = require_browser3();\n    var algos = require_algos(), algoKeys = Object.keys(algos), hashes = [\"sha1\", \"sha224\", \"sha256\", \"sha384\", \"sha512\", \"md5\", \"rmd160\"].concat(algoKeys);\n    exports.getHashes = function() {\n      return hashes;\n    };\n    var p = require_browser4();\n    exports.pbkdf2 = p.pbkdf2, exports.pbkdf2Sync = p.pbkdf2Sync;\n    var aes = require_browser6();\n    exports.Cipher = aes.Cipher, exports.createCipher = aes.createCipher, exports.Cipheriv = aes.Cipheriv, exports.createCipheriv = aes.createCipheriv, exports.Decipher = aes.Decipher, exports.createDecipher = aes.createDecipher, exports.Decipheriv = aes.Decipheriv, exports.createDecipheriv = aes.createDecipheriv, exports.getCiphers = aes.getCiphers, exports.listCiphers = aes.listCiphers;\n    var dh = require_browser7();\n    exports.DiffieHellmanGroup = dh.DiffieHellmanGroup, exports.createDiffieHellmanGroup = dh.createDiffieHellmanGroup, exports.getDiffieHellman = dh.getDiffieHellman, exports.createDiffieHellman = dh.createDiffieHellman, exports.DiffieHellman = dh.DiffieHellman;\n    var sign = require_browser8();\n    exports.createSign = sign.createSign, exports.Sign = sign.Sign, exports.createVerify = sign.createVerify, exports.Verify = sign.Verify, exports.createECDH = require_browser9();\n    var publicEncrypt = require_browser10();\n    exports.publicEncrypt = publicEncrypt.publicEncrypt, exports.privateEncrypt = publicEncrypt.privateEncrypt, exports.publicDecrypt = publicEncrypt.publicDecrypt, exports.privateDecrypt = publicEncrypt.privateDecrypt, exports.getRandomValues = (values) => crypto.getRandomValues(values);\n    var rf = require_browser11();\n    exports.randomFill = rf.randomFill, exports.randomFillSync = rf.randomFillSync, exports.createCredentials = function() {\n      throw new Error([\n        \"sorry, createCredentials is not implemented yet\",\n        \"we accept pull requests\",\n        \"https://github.com/crypto-browserify/crypto-browserify\"\n      ].join(`\n`));\n    }, exports.constants = @processBindingConstants.crypto;\n  }\n}), crypto_exports = require_crypto_browserify2(), DEFAULT_ENCODING = \"buffer\", getRandomValues = (array) => crypto.getRandomValues(array), randomUUID = () => crypto.randomUUID(), randomInt = (...args) => crypto.randomInt(...args), timingSafeEqual = \"timingSafeEqual\" in crypto \? (a, b) => {\n  let { byteLength: byteLengthA } = a, { byteLength: byteLengthB } = b;\n  if (typeof byteLengthA != \"number\" || typeof byteLengthB != \"number\")\n    @throwTypeError(\"Input must be an array buffer view\");\n  if (byteLengthA !== byteLengthB)\n    @throwRangeError(\"Input buffers must have the same length\");\n  return crypto.timingSafeEqual(a, b);\n} : void 0, scryptSync = \"scryptSync\" in crypto \? (password, salt, keylen, options) => {\n  let res = crypto.scryptSync(password, salt, keylen, options);\n  return DEFAULT_ENCODING !== \"buffer\" \? new Buffer(res).toString(DEFAULT_ENCODING) : new Buffer(res);\n} : void 0, scrypt = \"scryptSync\" in crypto \? function(password, salt, keylen, options, callback) {\n  if (typeof options == \"function\" && (callback = options, options = void 0), typeof callback != \"function\") {\n    var err = @makeTypeError(\"callback must be a function\");\n    throw err.code = \"ERR_INVALID_CALLBACK\", err;\n  }\n  try {\n    let result = crypto.scryptSync(password, salt, keylen, options);\n    process.nextTick(callback, null, DEFAULT_ENCODING !== \"buffer\" \? new Buffer(result).toString(DEFAULT_ENCODING) : new Buffer(result));\n  } catch (err2) {\n    throw err2;\n  }\n} : void 0;\ntimingSafeEqual && (Object.defineProperty(timingSafeEqual, \"name\", {\n  value: \"::bunternal::\"\n}), Object.defineProperty(scrypt, \"name\", {\n  value: \"::bunternal::\"\n}), Object.defineProperty(scryptSync, \"name\", {\n  value: \"::bunternal::\"\n}));\nvar harcoded_curves = [\n  \"p192\",\n  \"p224\",\n  \"p256\",\n  \"p384\",\n  \"p521\",\n  \"curve25519\",\n  \"ed25519\",\n  \"secp256k1\",\n  \"secp224r1\",\n  \"prime256v1\",\n  \"prime192v1\",\n  \"ed25519\",\n  \"secp384r1\",\n  \"secp521r1\"\n], webcrypto = crypto;\n__export(crypto_exports, {\n  DEFAULT_ENCODING: () => DEFAULT_ENCODING,\n  getRandomValues: () => getRandomValues,\n  randomUUID: () => randomUUID,\n  randomInt: () => randomInt,\n  getCurves: () => getCurves,\n  scrypt: () => scrypt,\n  scryptSync: () => scryptSync,\n  timingSafeEqual: () => timingSafeEqual,\n  webcrypto: () => webcrypto,\n  subtle: () => webcrypto.subtle\n});\n$ = crypto_exports;\n/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */\nreturn $})\n"_s;
//

//
static constexpr ASCIILiteral NodeDgramCode = "(function (){\"use strict\";// src/js/out/tmp/node/dgram.ts\nvar createSocket = function() {\n  throwNotImplemented(\"node:dgram createSocket\", 1630);\n}, Socket = function() {\n  throwNotImplemented(\"node:dgram Socket\", 1630);\n}, _createSocketHandle = function() {\n  throwNotImplemented(\"node:dgram _createSocketHandle\", 1630);\n}, $, { hideFromStack, throwNotImplemented } = @getInternalField(@internalModuleRegistry, 3) || @createInternalModuleById(3);\n$ = {\n  createSocket,\n  Socket,\n  _createSocketHandle\n};\nhideFromStack(createSocket, Socket, _createSocketHandle);\nreturn $})\n"_s;
//

//
static constexpr ASCIILiteral NodeDiagnosticsChannelCode = "(function (){\"use strict\";// src/js/out/tmp/node/diagnostics_channel.ts\nvar markActive = function(channel) {\n  ObjectSetPrototypeOf(channel, ActiveChannel.prototype), channel._subscribers = [], channel._stores = new SafeMap;\n}, maybeMarkInactive = function(channel) {\n  if (!channel._subscribers.length && !channel._stores.size)\n    ObjectSetPrototypeOf(channel, Channel.prototype), channel._subscribers = void 0, channel._stores = void 0;\n}, defaultTransform = function(data) {\n  return data;\n}, wrapStoreRun = function(store, data, next, transform = defaultTransform) {\n  return () => {\n    let context;\n    try {\n      context = transform(data);\n    } catch (err) {\n      return process.nextTick(() => reportError(err)), next();\n    }\n    return store.run(context, next);\n  };\n}, channel = function(name) {\n  const channel2 = channels.get(name);\n  if (channel2)\n    return channel2;\n  if (typeof name !== \"string\" && typeof name !== \"symbol\")\n    throw new ERR_INVALID_ARG_TYPE(\"channel\", [\"string\", \"symbol\"], name);\n  return new Channel(name);\n}, subscribe = function(name, subscription) {\n  return channel(name).subscribe(subscription);\n}, unsubscribe = function(name, subscription) {\n  return channel(name).unsubscribe(subscription);\n}, hasSubscribers = function(name) {\n  const channel2 = channels.get(name);\n  if (!channel2)\n    return !1;\n  return channel2.hasSubscribers;\n}, assertChannel = function(value, name) {\n  if (!(value instanceof Channel))\n    throw new ERR_INVALID_ARG_TYPE(name, [\"Channel\"], value);\n}, tracingChannel = function(nameOrChannels) {\n  return new TracingChannel(nameOrChannels);\n}, validateFunction = function(callable, field) {\n  if (typeof callable !== \"function\")\n    throw new ERR_INVALID_ARG_TYPE(field, \"Function\", callable);\n  return callable;\n}, $, SafeMap = Map, SafeFinalizationRegistry = FinalizationRegistry, ArrayPrototypeAt = (array, index) => array[index], ArrayPrototypeIndexOf = (array, value) => array.indexOf(value), ArrayPrototypePush = (array, value) => array.push(value), ArrayPrototypeSplice = (array, start, deleteCount) => array.splice(start, deleteCount), ObjectGetPrototypeOf = Object.getPrototypeOf, ObjectSetPrototypeOf = Object.setPrototypeOf, SymbolHasInstance = Symbol.hasInstance, ReflectApply = Reflect.apply, PromiseResolve = Promise.resolve, PromiseReject = Promise.reject, PromisePrototypeThen = (promise, onFulfilled, onRejected) => promise.then(onFulfilled, onRejected);\n\nclass WeakReference extends WeakRef {\n  constructor() {\n    super(...arguments);\n  }\n  #refs = 0;\n  get() {\n    return this.deref();\n  }\n  incRef() {\n    return ++this.#refs;\n  }\n  decRef() {\n    return --this.#refs;\n  }\n}\n\nclass WeakRefMap extends SafeMap {\n  constructor() {\n    super(...arguments);\n  }\n  #finalizers = new SafeFinalizationRegistry((key) => {\n    this.delete(key);\n  });\n  set(key, value) {\n    return this.#finalizers.register(value, key), super.set(key, new WeakReference(value));\n  }\n  get(key) {\n    return super.get(key)\?.get();\n  }\n  incRef(key) {\n    return super.get(key)\?.incRef();\n  }\n  decRef(key) {\n    return super.get(key)\?.decRef();\n  }\n}\n\nclass ActiveChannel {\n  subscribe(subscription) {\n    validateFunction(subscription, \"subscription\"), ArrayPrototypePush(this._subscribers, subscription), channels.incRef(this.name);\n  }\n  unsubscribe(subscription) {\n    const index = ArrayPrototypeIndexOf(this._subscribers, subscription);\n    if (index === -1)\n      return !1;\n    return ArrayPrototypeSplice(this._subscribers, index, 1), channels.decRef(this.name), maybeMarkInactive(this), !0;\n  }\n  bindStore(store, transform) {\n    if (!this._stores.has(store))\n      channels.incRef(this.name);\n    this._stores.set(store, transform);\n  }\n  unbindStore(store) {\n    if (!this._stores.has(store))\n      return !1;\n    return this._stores.delete(store), channels.decRef(this.name), maybeMarkInactive(this), !0;\n  }\n  get hasSubscribers() {\n    return !0;\n  }\n  publish(data) {\n    for (let i = 0;i < (this._subscribers\?.length || 0); i++)\n      try {\n        const onMessage = this._subscribers[i];\n        onMessage(data, this.name);\n      } catch (err) {\n        process.nextTick(() => reportError(err));\n      }\n  }\n  runStores(data, fn, thisArg, ...args) {\n    let run = () => {\n      return this.publish(data), ReflectApply(fn, thisArg, args);\n    };\n    for (let entry of this._stores.entries()) {\n      const store = entry[0], transform = entry[1];\n      run = wrapStoreRun(store, data, run, transform);\n    }\n    return run();\n  }\n}\n\nclass Channel {\n  constructor(name) {\n    this._subscribers = void 0, this._stores = void 0, this.name = name, channels.set(name, this);\n  }\n  static [SymbolHasInstance](instance) {\n    const prototype = ObjectGetPrototypeOf(instance);\n    return prototype === Channel.prototype || prototype === ActiveChannel.prototype;\n  }\n  subscribe(subscription) {\n    markActive(this), this.subscribe(subscription);\n  }\n  unsubscribe() {\n    return !1;\n  }\n  bindStore(store, transform) {\n    markActive(this), this.bindStore(store, transform);\n  }\n  unbindStore() {\n    return !1;\n  }\n  get hasSubscribers() {\n    return !1;\n  }\n  publish() {\n  }\n  runStores(data, fn, thisArg, ...args) {\n    return ReflectApply(fn, thisArg, args);\n  }\n}\nvar channels = new WeakRefMap, traceEvents = [\"start\", \"end\", \"asyncStart\", \"asyncEnd\", \"error\"];\n\nclass TracingChannel {\n  constructor(nameOrChannels) {\n    if (typeof nameOrChannels === \"string\")\n      this.start = channel(`tracing:${nameOrChannels}:start`), this.end = channel(`tracing:${nameOrChannels}:end`), this.asyncStart = channel(`tracing:${nameOrChannels}:asyncStart`), this.asyncEnd = channel(`tracing:${nameOrChannels}:asyncEnd`), this.error = channel(`tracing:${nameOrChannels}:error`);\n    else if (typeof nameOrChannels === \"object\") {\n      const { start, end, asyncStart, asyncEnd, error } = nameOrChannels;\n      assertChannel(start, \"nameOrChannels.start\"), assertChannel(end, \"nameOrChannels.end\"), assertChannel(asyncStart, \"nameOrChannels.asyncStart\"), assertChannel(asyncEnd, \"nameOrChannels.asyncEnd\"), assertChannel(error, \"nameOrChannels.error\"), this.start = start, this.end = end, this.asyncStart = asyncStart, this.asyncEnd = asyncEnd, this.error = error;\n    } else\n      throw new ERR_INVALID_ARG_TYPE(\"nameOrChannels\", [\"string\", \"object\", \"Channel\"], nameOrChannels);\n  }\n  subscribe(handlers) {\n    for (let name of traceEvents) {\n      if (!handlers[name])\n        continue;\n      this[name]\?.subscribe(handlers[name]);\n    }\n  }\n  unsubscribe(handlers) {\n    let done = !0;\n    for (let name of traceEvents) {\n      if (!handlers[name])\n        continue;\n      if (!this[name]\?.unsubscribe(handlers[name]))\n        done = !1;\n    }\n    return done;\n  }\n  traceSync(fn, context = {}, thisArg, ...args) {\n    const { start, end, error } = this;\n    return start.runStores(context, () => {\n      try {\n        const result = ReflectApply(fn, thisArg, args);\n        return context.result = result, result;\n      } catch (err) {\n        throw context.error = err, error.publish(context), err;\n      } finally {\n        end.publish(context);\n      }\n    });\n  }\n  tracePromise(fn, context = {}, thisArg, ...args) {\n    const { start, end, asyncStart, asyncEnd, error } = this;\n    function reject(err) {\n      return context.error = err, error.publish(context), asyncStart.publish(context), asyncEnd.publish(context), PromiseReject(err);\n    }\n    function resolve(result) {\n      return context.result = result, asyncStart.publish(context), asyncEnd.publish(context), result;\n    }\n    return start.runStores(context, () => {\n      try {\n        let promise = ReflectApply(fn, thisArg, args);\n        if (!(promise instanceof Promise))\n          promise = PromiseResolve(promise);\n        return PromisePrototypeThen(promise, resolve, reject);\n      } catch (err) {\n        throw context.error = err, error.publish(context), err;\n      } finally {\n        end.publish(context);\n      }\n    });\n  }\n  traceCallback(fn, position = -1, context = {}, thisArg, ...args) {\n    const { start, end, asyncStart, asyncEnd, error } = this;\n    function wrappedCallback(err, res) {\n      if (err)\n        context.error = err, error.publish(context);\n      else\n        context.result = res;\n      asyncStart.runStores(context, () => {\n        try {\n          if (callback)\n            return ReflectApply(callback, this, arguments);\n        } finally {\n          asyncEnd.publish(context);\n        }\n      });\n    }\n    const callback = ArrayPrototypeAt(args, position);\n    if (typeof callback !== \"function\")\n      throw new ERR_INVALID_ARG_TYPE(\"callback\", [\"function\"], callback);\n    return ArrayPrototypeSplice(args, position, 1, wrappedCallback), start.runStores(context, () => {\n      try {\n        return ReflectApply(fn, thisArg, args);\n      } catch (err) {\n        throw context.error = err, error.publish(context), err;\n      } finally {\n        end.publish(context);\n      }\n    });\n  }\n}\n\nclass ERR_INVALID_ARG_TYPE extends TypeError {\n  constructor(name, expected, actual) {\n    super(`The ${name} argument must be of type ${expected}. Received type ${typeof actual}`);\n    this.code = \"ERR_INVALID_ARG_TYPE\";\n  }\n}\n$ = {\n  channel,\n  hasSubscribers,\n  subscribe,\n  tracingChannel,\n  unsubscribe,\n  Channel\n};\nreturn $})\n"_s;
//

//
static constexpr ASCIILiteral NodeDNSCode = "(function (){\"use strict\";// src/js/out/tmp/node/dns.ts\nvar getServers = function() {\n  return dns.getServers();\n}, lookup = function(domain, options, callback) {\n  if (typeof options == \"function\")\n    callback = options;\n  if (typeof callback != \"function\")\n    @throwTypeError(\"callback must be a function\");\n  if (typeof options == \"number\")\n    options = { family: options };\n  dns.lookup(domain, options).then((res) => {\n    if (res.sort((a, b) => a.family - b.family), options\?.all)\n      callback(null, res.map(mapLookupAll));\n    else {\n      const [{ address, family }] = res;\n      callback(null, address, family);\n    }\n  }, (error) => {\n    callback(error);\n  });\n}, resolveSrv = function(hostname, callback) {\n  if (typeof callback != \"function\")\n    @throwTypeError(\"callback must be a function\");\n  dns.resolveSrv(hostname, callback).then((results) => {\n    callback(null, results);\n  }, (error) => {\n    callback(error);\n  });\n}, resolveTxt = function(hostname, callback) {\n  if (typeof callback != \"function\")\n    @throwTypeError(\"callback must be a function\");\n  dns.resolveTxt(hostname, callback).then((results) => {\n    callback(null, results);\n  }, (error) => {\n    callback(error);\n  });\n}, resolveSoa = function(hostname, callback) {\n  if (typeof callback != \"function\")\n    @throwTypeError(\"callback must be a function\");\n  dns.resolveSoa(hostname, callback).then((results) => {\n    callback(null, results);\n  }, (error) => {\n    callback(error);\n  });\n}, resolveNaptr = function(hostname, callback) {\n  if (typeof callback != \"function\")\n    @throwTypeError(\"callback must be a function\");\n  dns.resolveNaptr(hostname, callback).then((results) => {\n    callback(null, results);\n  }, (error) => {\n    callback(error);\n  });\n}, resolveMx = function(hostname, callback) {\n  if (typeof callback != \"function\")\n    @throwTypeError(\"callback must be a function\");\n  dns.resolveMx(hostname, callback).then((results) => {\n    callback(null, results);\n  }, (error) => {\n    callback(error);\n  });\n}, resolveCaa = function(hostname, callback) {\n  if (typeof callback != \"function\")\n    @throwTypeError(\"callback must be a function\");\n  dns.resolveCaa(hostname, callback).then((results) => {\n    callback(null, results);\n  }, (error) => {\n    callback(error);\n  });\n}, resolveNs = function(hostname, callback) {\n  if (typeof callback != \"function\")\n    @throwTypeError(\"callback must be a function\");\n  dns.resolveNs(hostname, callback).then((results) => {\n    callback(null, results);\n  }, (error) => {\n    callback(error);\n  });\n}, resolvePtr = function(hostname, callback) {\n  if (typeof callback != \"function\")\n    @throwTypeError(\"callback must be a function\");\n  dns.resolvePtr(hostname, callback).then((results) => {\n    callback(null, results);\n  }, (error) => {\n    callback(error);\n  });\n}, resolveCname = function(hostname, callback) {\n  if (typeof callback != \"function\")\n    @throwTypeError(\"callback must be a function\");\n  dns.resolveCname(hostname, callback).then((results) => {\n    callback(null, results);\n  }, (error) => {\n    callback(error);\n  });\n}, lookupService = function(address, port, callback) {\n  if (typeof callback != \"function\")\n    @throwTypeError(\"callback must be a function\");\n  callback(null, address, port);\n}, resolve = function(hostname, rrtype, callback) {\n  if (typeof rrtype == \"function\")\n    callback = rrtype;\n  if (typeof callback != \"function\")\n    @throwTypeError(\"callback must be a function\");\n  dns.resolve(hostname).then((results) => {\n    switch (rrtype\?.toLowerCase()) {\n      case \"a\":\n      case \"aaaa\":\n        callback(null, hostname, results.map(({ address }) => address));\n        break;\n      default:\n        callback(null, results);\n        break;\n    }\n  }, (error) => {\n    callback(error);\n  });\n}, Resolver = function(options) {\n  return new InternalResolver(options);\n}, setDefaultResultOrder = function() {\n}, setServers = function() {\n}, $, dns = Bun.dns, InternalResolver = class Resolver2 {\n  constructor(options) {\n  }\n  cancel() {\n  }\n  getServers() {\n    return [];\n  }\n  resolve(hostname, rrtype, callback) {\n    if (typeof rrtype == \"function\")\n      callback = rrtype, rrtype = null;\n    if (typeof callback != \"function\")\n      @throwTypeError(\"callback must be a function\");\n    dns.resolve(hostname).then((results) => {\n      switch (rrtype\?.toLowerCase()) {\n        case \"a\":\n        case \"aaaa\":\n          callback(null, hostname, results.map(mapResolveX));\n          break;\n        default:\n          callback(null, results);\n          break;\n      }\n    }, (error) => {\n      callback(error);\n    });\n  }\n  resolve4(hostname, options, callback) {\n    if (typeof options == \"function\")\n      callback = options, options = null;\n    if (typeof callback != \"function\")\n      @throwTypeError(\"callback must be a function\");\n    dns.lookup(hostname, { family: 4 }).then((addresses) => {\n      callback(null, options\?.ttl \? addresses : addresses.map(mapResolveX));\n    }, (error) => {\n      callback(error);\n    });\n  }\n  resolve6(hostname, options, callback) {\n    if (typeof options == \"function\")\n      callback = options, options = null;\n    if (typeof callback != \"function\")\n      @throwTypeError(\"callback must be a function\");\n    dns.lookup(hostname, { family: 6 }).then((addresses) => {\n      callback(null, options\?.ttl \? addresses : addresses.map(({ address }) => address));\n    }, (error) => {\n      callback(error);\n    });\n  }\n  resolveAny(hostname, callback) {\n    callback(null, []);\n  }\n  resolveCname(hostname, callback) {\n    if (typeof callback != \"function\")\n      @throwTypeError(\"callback must be a function\");\n    dns.resolveCname(hostname, callback).then((results) => {\n      callback(null, results);\n    }, (error) => {\n      callback(error);\n    });\n  }\n  resolveMx(hostname, callback) {\n    if (typeof callback != \"function\")\n      @throwTypeError(\"callback must be a function\");\n    dns.resolveMx(hostname, callback).then((results) => {\n      callback(null, results);\n    }, (error) => {\n      callback(error);\n    });\n  }\n  resolveNaptr(hostname, callback) {\n    if (typeof callback != \"function\")\n      @throwTypeError(\"callback must be a function\");\n    dns.resolveNaptr(hostname, callback).then((results) => {\n      callback(null, results);\n    }, (error) => {\n      callback(error);\n    });\n  }\n  resolveNs(hostname, callback) {\n    if (typeof callback != \"function\")\n      @throwTypeError(\"callback must be a function\");\n    dns.resolveNs(hostname, callback).then((results) => {\n      callback(null, results);\n    }, (error) => {\n      callback(error);\n    });\n  }\n  resolvePtr(hostname, callback) {\n    if (typeof callback != \"function\")\n      @throwTypeError(\"callback must be a function\");\n    dns.resolvePtr(hostname, callback).then((results) => {\n      callback(null, results);\n    }, (error) => {\n      callback(error);\n    });\n  }\n  resolveSrv(hostname, callback) {\n    if (typeof callback != \"function\")\n      @throwTypeError(\"callback must be a function\");\n    dns.resolveSrv(hostname, callback).then((results) => {\n      callback(null, results);\n    }, (error) => {\n      callback(error);\n    });\n  }\n  resolveCaa(hostname, callback) {\n    if (typeof callback != \"function\")\n      @throwTypeError(\"callback must be a function\");\n    dns.resolveCaa(hostname, callback).then((results) => {\n      callback(null, results);\n    }, (error) => {\n      callback(error);\n    });\n  }\n  resolveTxt(hostname, callback) {\n    if (typeof callback != \"function\")\n      @throwTypeError(\"callback must be a function\");\n    dns.resolveTxt(hostname, callback).then((results) => {\n      callback(null, results);\n    }, (error) => {\n      callback(error);\n    });\n  }\n  resolveSoa(hostname, callback) {\n    if (typeof callback != \"function\")\n      @throwTypeError(\"callback must be a function\");\n    dns.resolveSoa(hostname, callback).then((results) => {\n      callback(null, results);\n    }, (error) => {\n      callback(error);\n    });\n  }\n  reverse(ip, callback) {\n    callback(null, []);\n  }\n  setServers(servers) {\n  }\n};\nResolver.prototype = {};\nObject.setPrototypeOf(Resolver.prototype, InternalResolver.prototype);\nObject.setPrototypeOf(Resolver, InternalResolver);\nvar {\n  resolve,\n  resolve4,\n  resolve6,\n  resolveAny,\n  resolveCname,\n  resolveCaa,\n  resolveMx,\n  resolveNaptr,\n  resolveNs,\n  resolvePtr,\n  resolveSoa,\n  resolveSrv,\n  reverse,\n  resolveTxt\n} = InternalResolver.prototype, promisifyLookup = (res) => {\n  res.sort((a, b) => a.family - b.family);\n  const [{ address, family }] = res;\n  return { address, family };\n}, mapLookupAll = (res) => {\n  const { address, family } = res;\n  return { address, family };\n}, promisifyLookupAll = (res) => {\n  return res.sort((a, b) => a.family - b.family), res.map(mapLookupAll);\n}, mapResolveX = (a) => a.address, promisifyResolveX = (res) => {\n  return res\?.map(mapResolveX);\n}, promises = {\n  lookup(domain, options) {\n    if (options\?.all)\n      return dns.lookup(domain, options).then(promisifyLookupAll);\n    return dns.lookup(domain, options).then(promisifyLookup);\n  },\n  lookupService(address, port) {\n    return Promise.resolve([]);\n  },\n  resolve(hostname, rrtype) {\n    if (typeof rrtype !== \"string\")\n      rrtype = null;\n    switch (rrtype\?.toLowerCase()) {\n      case \"a\":\n      case \"aaaa\":\n        return dns.resolve(hostname, rrtype).then(promisifyLookup);\n      default:\n        return dns.resolve(hostname, rrtype);\n    }\n  },\n  resolve4(hostname, options) {\n    if (options\?.ttl)\n      return dns.lookup(hostname, { family: 4 });\n    return dns.lookup(hostname, { family: 4 }).then(promisifyResolveX);\n  },\n  resolve6(hostname, options) {\n    if (options\?.ttl)\n      return dns.lookup(hostname, { family: 6 });\n    return dns.lookup(hostname, { family: 6 }).then(promisifyResolveX);\n  },\n  resolveSrv(hostname) {\n    return dns.resolveSrv(hostname);\n  },\n  resolveTxt(hostname) {\n    return dns.resolveTxt(hostname);\n  },\n  resolveSoa(hostname) {\n    return dns.resolveSoa(hostname);\n  },\n  resolveNaptr(hostname) {\n    return dns.resolveNaptr(hostname);\n  },\n  resolveMx(hostname) {\n    return dns.resolveMx(hostname);\n  },\n  resolveCaa(hostname) {\n    return dns.resolveCaa(hostname);\n  },\n  resolveNs(hostname) {\n    return dns.resolveNs(hostname);\n  },\n  resolvePtr(hostname) {\n    return dns.resolvePtr(hostname);\n  },\n  resolveCname(hostname) {\n    return dns.resolveCname(hostname);\n  },\n  Resolver: class Resolver3 {\n    constructor(options) {\n    }\n    cancel() {\n    }\n    getServers() {\n      return [];\n    }\n    resolve(hostname, rrtype) {\n      if (typeof rrtype !== \"string\")\n        rrtype = null;\n      switch (rrtype\?.toLowerCase()) {\n        case \"a\":\n        case \"aaaa\":\n          return dns.resolve(hostname, rrtype).then(promisifyLookup);\n        default:\n          return dns.resolve(hostname, rrtype);\n      }\n    }\n    resolve4(hostname, options) {\n      if (options\?.ttl)\n        return dns.lookup(hostname, { family: 4 });\n      return dns.lookup(hostname, { family: 4 }).then(promisifyResolveX);\n    }\n    resolve6(hostname, options) {\n      if (options\?.ttl)\n        return dns.lookup(hostname, { family: 6 });\n      return dns.lookup(hostname, { family: 6 }).then(promisifyResolveX);\n    }\n    resolveAny(hostname) {\n      return Promise.resolve([]);\n    }\n    resolveCname(hostname) {\n      return dns.resolveCname(hostname);\n    }\n    resolveMx(hostname) {\n      return dns.resolveMx(hostname);\n    }\n    resolveNaptr(hostname) {\n      return dns.resolveNaptr(hostname);\n    }\n    resolveNs(hostname) {\n      return dns.resolveNs(hostname);\n    }\n    resolvePtr(hostname) {\n      return dns.resolvePtr(hostname);\n    }\n    resolveSoa(hostname) {\n      return dns.resolveSoa(hostname);\n    }\n    resolveSrv(hostname) {\n      return dns.resolveSrv(hostname);\n    }\n    resolveCaa(hostname) {\n      return dns.resolveCaa(hostname);\n    }\n    resolveTxt(hostname) {\n      return dns.resolveTxt(hostname);\n    }\n    reverse(ip) {\n      return Promise.resolve([]);\n    }\n    setServers(servers) {\n    }\n  }\n};\nfor (let key of [\"resolveAny\", \"reverse\"])\n  promises[key] = () => Promise.resolve(void 0);\n$ = {\n  ADDRCONFIG: 0,\n  ALL: 1,\n  V4MAPPED: 2,\n  NODATA: \"DNS_ENODATA\",\n  FORMERR: \"DNS_EFORMERR\",\n  SERVFAIL: \"DNS_ESERVFAIL\",\n  NOTFOUND: \"DNS_ENOTFOUND\",\n  NOTIMP: \"DNS_ENOTIMP\",\n  REFUSED: \"DNS_EREFUSED\",\n  BADQUERY: \"DNS_EBADQUERY\",\n  BADNAME: \"DNS_EBADNAME\",\n  BADFAMILY: \"DNS_EBADFAMILY\",\n  BADRESP: \"DNS_EBADRESP\",\n  CONNREFUSED: \"DNS_ECONNREFUSED\",\n  TIMEOUT: \"DNS_ETIMEOUT\",\n  EOF: \"DNS_EEOF\",\n  FILE: \"DNS_EFILE\",\n  NOMEM: \"DNS_ENOMEM\",\n  DESTRUCTION: \"DNS_EDESTRUCTION\",\n  BADSTR: \"DNS_EBADSTR\",\n  BADFLAGS: \"DNS_EBADFLAGS\",\n  NONAME: \"DNS_ENONAME\",\n  BADHINTS: \"DNS_EBADHINTS\",\n  NOTINITIALIZED: \"DNS_ENOTINITIALIZED\",\n  LOADIPHLPAPI: \"DNS_ELOADIPHLPAPI\",\n  ADDRGETNETWORKPARAMS: \"DNS_EADDRGETNETWORKPARAMS\",\n  CANCELLED: \"DNS_ECANCELLED\",\n  lookup,\n  lookupService,\n  Resolver,\n  setServers,\n  setDefaultResultOrder,\n  resolve,\n  reverse,\n  resolve4,\n  resolve6,\n  resolveAny,\n  resolveCname,\n  resolveCaa,\n  resolveMx,\n  resolveNs,\n  resolvePtr,\n  resolveSoa,\n  resolveSrv,\n  resolveTxt,\n  resolveNaptr,\n  promises,\n  getServers\n};\nreturn $})\n"_s;
//

//
static constexpr ASCIILiteral NodeDNSPromisesCode = "(function (){\"use strict\";// src/js/out/tmp/node/dns.promises.ts\nreturn (@getInternalField(@internalModuleRegistry, 13) || @createInternalModuleById(13)).promises})\n"_s;
//

//
static constexpr ASCIILiteral NodeDomainCode = "(function (){\"use strict\";// src/js/out/tmp/node/domain.ts\nvar EventEmitter = @getInternalField(@internalModuleRegistry, 16) || @createInternalModuleById(16), domain = {};\ndomain.createDomain = domain.create = function() {\n  var d = new EventEmitter;\n  function emitError(e) {\n    d.emit(\"error\", e);\n  }\n  return d.add = function(emitter) {\n    emitter.on(\"error\", emitError);\n  }, d.remove = function(emitter) {\n    emitter.removeListener(\"error\", emitError);\n  }, d.bind = function(fn) {\n    return function() {\n      var args = Array.prototype.slice.call(arguments);\n      try {\n        fn.apply(null, args);\n      } catch (err) {\n        emitError(err);\n      }\n    };\n  }, d.intercept = function(fn) {\n    return function(err) {\n      if (err)\n        emitError(err);\n      else {\n        var args = Array.prototype.slice.call(arguments, 1);\n        try {\n          fn.apply(null, args);\n        } catch (err2) {\n          emitError(err2);\n        }\n      }\n    };\n  }, d.run = function(fn) {\n    try {\n      fn();\n    } catch (err) {\n      emitError(err);\n    }\n    return this;\n  }, d.dispose = function() {\n    return this.removeAllListeners(), this;\n  }, d.enter = d.exit = function() {\n    return this;\n  }, d;\n};\nreturn domain})\n"_s;
//

//
static constexpr ASCIILiteral NodeEventsCode = "(function (){\"use strict\";// src/js/out/tmp/node/events.ts\nvar emitError = function(emitter, args) {\n  var { _events: events } = emitter;\n  if (args[0] \?\?= new Error(\"Unhandled error.\"), !events)\n    throw args[0];\n  var errorMonitor = events[kErrorMonitor];\n  if (errorMonitor)\n    for (var handler of ArrayPrototypeSlice.call(errorMonitor))\n      handler.apply(emitter, args);\n  var handlers = events.error;\n  if (!handlers)\n    throw args[0];\n  for (var handler of ArrayPrototypeSlice.call(handlers))\n    handler.apply(emitter, args);\n  return !0;\n}, addCatch = function(emitter, promise, type, args) {\n  promise.then(void 0, function(err) {\n    process.nextTick(emitUnhandledRejectionOrErr, emitter, err, type, args);\n  });\n}, emitUnhandledRejectionOrErr = function(emitter, err, type, args) {\n  if (typeof emitter[kRejection] === \"function\")\n    emitter[kRejection](err, type, ...args);\n  else\n    try {\n      emitter[kCapture] = !1, emitter.emit(\"error\", err);\n    } finally {\n      emitter[kCapture] = !0;\n    }\n}, overflowWarning = function(emitter, type, handlers) {\n  handlers.warned = !0;\n  const warn = new Error(`Possible EventEmitter memory leak detected. ${handlers.length} ${String(type)} listeners ` + `added to [${emitter.constructor.name}]. Use emitter.setMaxListeners() to increase limit`);\n  warn.name = \"MaxListenersExceededWarning\", warn.emitter = emitter, warn.type = type, warn.count = handlers.length, process.emitWarning(warn);\n}, onceWrapper = function(type, listener, ...args) {\n  this.removeListener(type, listener), listener.apply(this, args);\n}, once = function(emitter, type, options) {\n  var signal = options\?.signal;\n  if (validateAbortSignal(signal, \"options.signal\"), signal\?.aborted)\n    throw new AbortError(void 0, { cause: signal\?.reason });\n  return new Promise((resolve, reject) => {\n    const errorListener = (err) => {\n      if (emitter.removeListener(type, resolver), signal != null)\n        eventTargetAgnosticRemoveListener(signal, \"abort\", abortListener);\n      reject(err);\n    }, resolver = (...args) => {\n      if (typeof emitter.removeListener === \"function\")\n        emitter.removeListener(\"error\", errorListener);\n      if (signal != null)\n        eventTargetAgnosticRemoveListener(signal, \"abort\", abortListener);\n      resolve(args);\n    };\n    if (eventTargetAgnosticAddListener(emitter, type, resolver, { once: !0 }), type !== \"error\" && typeof emitter.once === \"function\")\n      emitter.once(\"error\", errorListener);\n    function abortListener() {\n      eventTargetAgnosticRemoveListener(emitter, type, resolver), eventTargetAgnosticRemoveListener(emitter, \"error\", errorListener), reject(new AbortError(void 0, { cause: signal\?.reason }));\n    }\n    if (signal != null)\n      eventTargetAgnosticAddListener(signal, \"abort\", abortListener, { once: !0 });\n  });\n}, on = function(emitter, type, options) {\n  var { signal, close, highWatermark = Number.MAX_SAFE_INTEGER, lowWatermark = 1 } = options || {};\n  throwNotImplemented(\"events.on\", 2679);\n}, getEventListeners = function(emitter, type) {\n  if (emitter instanceof EventTarget)\n    throwNotImplemented(\"getEventListeners with an EventTarget\", 2678);\n  return emitter.listeners(type);\n}, setMaxListeners = function(n, ...eventTargets) {\n  validateNumber(n, \"setMaxListeners\", 0);\n  var length;\n  if (eventTargets && (length = eventTargets.length))\n    for (let i = 0;i < length; i++)\n      eventTargets[i].setMaxListeners(n);\n  else\n    defaultMaxListeners = n;\n}, listenerCount = function(emitter, type) {\n  return emitter.listenerCount(type);\n}, eventTargetAgnosticRemoveListener = function(emitter, name, listener, flags) {\n  if (typeof emitter.removeListener === \"function\")\n    emitter.removeListener(name, listener);\n  else\n    emitter.removeEventListener(name, listener, flags);\n}, eventTargetAgnosticAddListener = function(emitter, name, listener, flags) {\n  if (typeof emitter.on === \"function\")\n    emitter.on(name, listener);\n  else\n    emitter.addEventListener(name, listener);\n}, ERR_INVALID_ARG_TYPE = function(name, type, value) {\n  const err = @makeTypeError(`The \"${name}\" argument must be of type ${type}. Received ${value}`);\n  return err.code = \"ERR_INVALID_ARG_TYPE\", err;\n}, ERR_OUT_OF_RANGE = function(name, range, value) {\n  const err = new RangeError(`The \"${name}\" argument is out of range. It must be ${range}. Received ${value}`);\n  return err.code = \"ERR_OUT_OF_RANGE\", err;\n}, validateAbortSignal = function(signal, name) {\n  if (signal !== void 0 && (signal === null || typeof signal !== \"object\" || !(\"aborted\" in signal)))\n    throw new ERR_INVALID_ARG_TYPE(name, \"AbortSignal\", signal);\n}, validateNumber = function(value, name, min = void 0, max) {\n  if (typeof value !== \"number\")\n    throw new ERR_INVALID_ARG_TYPE(name, \"number\", value);\n  if (min != null && value < min || max != null && value > max || (min != null || max != null) && Number.isNaN(value))\n    throw new ERR_OUT_OF_RANGE(name, `${min != null \? `>= ${min}` : \"\"}${min != null && max != null \? \" && \" : \"\"}${max != null \? `<= ${max}` : \"\"}`, value);\n}, checkListener = function(listener) {\n  if (typeof listener !== \"function\")\n    @throwTypeError(\"The listener must be a function\");\n}, { throwNotImplemented } = @getInternalField(@internalModuleRegistry, 3) || @createInternalModuleById(3), SymbolFor = Symbol.for, kCapture = Symbol(\"kCapture\"), kErrorMonitor = SymbolFor(\"events.errorMonitor\"), kMaxEventTargetListeners = Symbol(\"events.maxEventTargetListeners\"), kMaxEventTargetListenersWarned = Symbol(\"events.maxEventTargetListenersWarned\"), kWatermarkData = SymbolFor(\"nodejs.watermarkData\"), kRejection = SymbolFor(\"nodejs.rejection\"), captureRejectionSymbol = SymbolFor(\"nodejs.rejection\"), ArrayPrototypeSlice = Array.prototype.slice, defaultMaxListeners = 10, EventEmitter = function EventEmitter2(opts) {\n  if (this._events === void 0 || this._events === this.__proto__._events)\n    this._events = { __proto__: null }, this._eventsCount = 0;\n  if (this._maxListeners \?\?= void 0, this[kCapture] = opts\?.captureRejections \? Boolean(opts\?.captureRejections) : EventEmitterPrototype[kCapture])\n    this.emit = emitWithRejectionCapture;\n}, EventEmitterPrototype = EventEmitter.prototype = {};\nEventEmitterPrototype._events = void 0;\nEventEmitterPrototype._eventsCount = 0;\nEventEmitterPrototype._maxListeners = void 0;\nEventEmitterPrototype.setMaxListeners = function setMaxListeners2(n) {\n  return validateNumber(n, \"setMaxListeners\", 0), this._maxListeners = n, this;\n};\nEventEmitterPrototype.getMaxListeners = function getMaxListeners() {\n  return this._maxListeners \?\? defaultMaxListeners;\n};\nvar emitWithoutRejectionCapture = function emit(type, ...args) {\n  if (type === \"error\")\n    return emitError(this, args);\n  var { _events: events } = this;\n  if (events === void 0)\n    return !1;\n  var handlers = events[type];\n  if (handlers === void 0)\n    return !1;\n  for (var handler of [...handlers])\n    handler.apply(this, args);\n  return !0;\n}, emitWithRejectionCapture = function emit2(type, ...args) {\n  if (type === \"error\")\n    return emitError(this, args);\n  var { _events: events } = this;\n  if (events === void 0)\n    return !1;\n  var handlers = events[type];\n  if (handlers === void 0)\n    return !1;\n  for (var handler of [...handlers]) {\n    var result = handler.apply(this, args);\n    if (result !== void 0 && @isPromise(result))\n      addCatch(this, result, type, args);\n  }\n  return !0;\n};\nEventEmitterPrototype.emit = emitWithoutRejectionCapture;\nEventEmitterPrototype.addListener = function addListener(type, fn) {\n  checkListener(fn);\n  var events = this._events;\n  if (!events)\n    events = this._events = { __proto__: null }, this._eventsCount = 0;\n  else if (events.newListener)\n    this.emit(\"newListener\", type, fn.listener \?\? fn);\n  var handlers = events[type];\n  if (!handlers)\n    events[type] = [fn], this._eventsCount++;\n  else {\n    handlers.push(fn);\n    var m = this._maxListeners \?\? defaultMaxListeners;\n    if (m > 0 && handlers.length > m && !handlers.warned)\n      overflowWarning(this, type, handlers);\n  }\n  return this;\n};\nEventEmitterPrototype.on = EventEmitterPrototype.addListener;\nEventEmitterPrototype.prependListener = function prependListener(type, fn) {\n  checkListener(fn);\n  var events = this._events;\n  if (!events)\n    events = this._events = { __proto__: null }, this._eventsCount = 0;\n  else if (events.newListener)\n    this.emit(\"newListener\", type, fn.listener \?\? fn);\n  var handlers = events[type];\n  if (!handlers)\n    events[type] = [fn], this._eventsCount++;\n  else {\n    handlers.unshift(fn);\n    var m = this._maxListeners \?\? defaultMaxListeners;\n    if (m > 0 && handlers.length > m && !handlers.warned)\n      overflowWarning(this, type, handlers);\n  }\n  return this;\n};\nEventEmitterPrototype.once = function once2(type, fn) {\n  checkListener(fn);\n  const bound = onceWrapper.bind(this, type, fn);\n  return bound.listener = fn, this.addListener(type, bound), this;\n};\nEventEmitterPrototype.prependOnceListener = function prependOnceListener(type, fn) {\n  checkListener(fn);\n  const bound = onceWrapper.bind(this, type, fn);\n  return bound.listener = fn, this.prependListener(type, bound), this;\n};\nEventEmitterPrototype.removeListener = function removeListener(type, fn) {\n  checkListener(fn);\n  var { _events: events } = this;\n  if (!events)\n    return this;\n  var handlers = events[type];\n  if (!handlers)\n    return this;\n  var length = handlers.length;\n  let position = -1;\n  for (let i = length - 1;i >= 0; i--)\n    if (handlers[i] === fn || handlers[i].listener === fn) {\n      position = i;\n      break;\n    }\n  if (position < 0)\n    return this;\n  if (position === 0)\n    handlers.shift();\n  else\n    handlers.splice(position, 1);\n  if (handlers.length === 0)\n    delete events[type], this._eventsCount--;\n  return this;\n};\nEventEmitterPrototype.off = EventEmitterPrototype.removeListener;\nEventEmitterPrototype.removeAllListeners = function removeAllListeners(type) {\n  var { _events: events } = this;\n  if (type && events) {\n    if (events[type])\n      delete events[type], this._eventsCount--;\n  } else\n    this._events = { __proto__: null };\n  return this;\n};\nEventEmitterPrototype.listeners = function listeners(type) {\n  var { _events: events } = this;\n  if (!events)\n    return [];\n  var handlers = events[type];\n  if (!handlers)\n    return [];\n  return handlers.map((x) => x.listener \?\? x);\n};\nEventEmitterPrototype.rawListeners = function rawListeners(type) {\n  var { _events } = this;\n  if (!_events)\n    return [];\n  var handlers = _events[type];\n  if (!handlers)\n    return [];\n  return handlers.slice();\n};\nEventEmitterPrototype.listenerCount = function listenerCount2(type) {\n  var { _events: events } = this;\n  if (!events)\n    return 0;\n  return events[type]\?.length \?\? 0;\n};\nEventEmitterPrototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 \? Reflect.ownKeys(this._events) : [];\n};\nEventEmitterPrototype[kCapture] = !1;\n\nclass AbortError extends Error {\n  constructor(message = \"The operation was aborted\", options = void 0) {\n    if (options !== void 0 && typeof options !== \"object\")\n      throw new codes.ERR_INVALID_ARG_TYPE(\"options\", \"Object\", options);\n    super(message, options);\n    this.code = \"ABORT_ERR\", this.name = \"AbortError\";\n  }\n}\nvar AsyncResource = null;\n\nclass EventEmitterAsyncResource extends EventEmitter {\n  triggerAsyncId;\n  asyncResource;\n  constructor(options) {\n    if (!AsyncResource)\n      AsyncResource = (@getInternalField(@internalModuleRegistry, 6) || @createInternalModuleById(6)).AsyncResource;\n    var { captureRejections = !1, triggerAsyncId, name = new.target.name, requireManualDestroy } = options || {};\n    super({ captureRejections });\n    this.triggerAsyncId = triggerAsyncId \?\? 0, this.asyncResource = new AsyncResource(name, { triggerAsyncId, requireManualDestroy });\n  }\n  emit(...args) {\n    this.asyncResource.runInAsyncScope(() => super.emit(...args));\n  }\n  emitDestroy() {\n    this.asyncResource.emitDestroy();\n  }\n}\nObject.defineProperties(EventEmitter, {\n  captureRejections: {\n    get() {\n      return EventEmitterPrototype[kCapture];\n    },\n    set(value) {\n      validateBoolean(value, \"EventEmitter.captureRejections\"), EventEmitterPrototype[kCapture] = value;\n    },\n    enumerable: !0\n  },\n  defaultMaxListeners: {\n    enumerable: !0,\n    get: () => {\n      return defaultMaxListeners;\n    },\n    set: (arg) => {\n      validateNumber(arg, \"defaultMaxListeners\", 0), defaultMaxListeners = arg;\n    }\n  },\n  kMaxEventTargetListeners: {\n    value: kMaxEventTargetListeners,\n    enumerable: !1,\n    configurable: !1,\n    writable: !1\n  },\n  kMaxEventTargetListenersWarned: {\n    value: kMaxEventTargetListenersWarned,\n    enumerable: !1,\n    configurable: !1,\n    writable: !1\n  }\n});\nObject.assign(EventEmitter, {\n  once,\n  on,\n  getEventListeners,\n  setMaxListeners,\n  EventEmitter,\n  usingDomains: !1,\n  captureRejectionSymbol,\n  EventEmitterAsyncResource,\n  errorMonitor: kErrorMonitor,\n  setMaxListeners,\n  init: EventEmitter,\n  listenerCount\n});\nreturn EventEmitter})\n"_s;
//

//
static constexpr ASCIILiteral NodeFSCode = "(function (){\"use strict\";// src/js/out/tmp/node/fs.ts\nvar callbackify = function(fsFunction, args) {\n  try {\n    const result = fsFunction.apply(fs, args.slice(0, args.length - 1)), callback = args[args.length - 1];\n    if (typeof callback === \"function\")\n      queueMicrotask(() => callback(null, result));\n  } catch (e) {\n    const callback = args[args.length - 1];\n    if (typeof callback === \"function\")\n      queueMicrotask(() => callback(e));\n  }\n}, createReadStream = function(path, options) {\n  return new ReadStream(path, options);\n}, createWriteStream = function(path, options) {\n  return new WriteStream(path, options);\n}, $, ReadStream, WriteStream, EventEmitter = @getInternalField(@internalModuleRegistry, 16) || @createInternalModuleById(16), promises = @getInternalField(@internalModuleRegistry, 18) || @createInternalModuleById(18), Stream = @getInternalField(@internalModuleRegistry, 35) || @createInternalModuleById(35), { isArrayBufferView } = @requireNativeModule(\"node:util/types\"), fs = Bun.fs();\n\nclass FSWatcher extends EventEmitter {\n  #watcher;\n  #listener;\n  constructor(path, options, listener) {\n    super();\n    if (typeof options === \"function\")\n      listener = options, options = {};\n    else if (typeof options === \"string\")\n      options = { encoding: options };\n    if (typeof listener !== \"function\")\n      listener = () => {\n      };\n    this.#listener = listener;\n    try {\n      this.#watcher = fs.watch(path, options || {}, this.#onEvent.bind(this));\n    } catch (e) {\n      if (!e.message\?.startsWith(\"FileNotFound\"))\n        throw e;\n      const notFound = new Error(`ENOENT: no such file or directory, watch '${path}'`);\n      throw notFound.code = \"ENOENT\", notFound.errno = -2, notFound.path = path, notFound.syscall = \"watch\", notFound.filename = path, notFound;\n    }\n  }\n  #onEvent(eventType, filenameOrError) {\n    if (eventType === \"error\" || eventType === \"close\")\n      this.emit(eventType, filenameOrError);\n    else\n      this.emit(\"change\", eventType, filenameOrError), this.#listener(eventType, filenameOrError);\n  }\n  close() {\n    this.#watcher\?.close(), this.#watcher = null;\n  }\n  ref() {\n    this.#watcher\?.ref();\n  }\n  unref() {\n    this.#watcher\?.unref();\n  }\n}\nvar access = function access2(...args) {\n  callbackify(fs.accessSync, args);\n}, appendFile = function appendFile2(...args) {\n  callbackify(fs.appendFileSync, args);\n}, close = function close2(...args) {\n  callbackify(fs.closeSync, args);\n}, rm = function rm2(...args) {\n  callbackify(fs.rmSync, args);\n}, rmdir = function rmdir2(...args) {\n  callbackify(fs.rmdirSync, args);\n}, copyFile = function copyFile2(...args) {\n  callbackify(fs.copyFileSync, args);\n}, exists = function exists2(...args) {\n  callbackify(fs.existsSync, args);\n}, chown = function chown2(...args) {\n  callbackify(fs.chownSync, args);\n}, chmod = function chmod2(...args) {\n  callbackify(fs.chmodSync, args);\n}, fchmod = function fchmod2(...args) {\n  callbackify(fs.fchmodSync, args);\n}, fchown = function fchown2(...args) {\n  callbackify(fs.fchownSync, args);\n}, fstat = function fstat2(...args) {\n  callbackify(fs.fstatSync, args);\n}, fsync = function fsync2(...args) {\n  callbackify(fs.fsyncSync, args);\n}, ftruncate = function ftruncate2(...args) {\n  callbackify(fs.ftruncateSync, args);\n}, futimes = function futimes2(...args) {\n  callbackify(fs.futimesSync, args);\n}, lchmod = function lchmod2(...args) {\n  callbackify(fs.lchmodSync, args);\n}, lchown = function lchown2(...args) {\n  callbackify(fs.lchownSync, args);\n}, link = function link2(...args) {\n  callbackify(fs.linkSync, args);\n}, mkdir = function mkdir2(...args) {\n  callbackify(fs.mkdirSync, args);\n}, mkdtemp = function mkdtemp2(...args) {\n  callbackify(fs.mkdtempSync, args);\n}, open = function open2(...args) {\n  callbackify(fs.openSync, args);\n}, read = function read2(fd, buffer, offsetOrOptions, length, position, callback) {\n  let offset = offsetOrOptions, params = null;\n  if (arguments.length <= 4) {\n    if (arguments.length === 4)\n      callback = length, params = offsetOrOptions;\n    else if (arguments.length === 3) {\n      if (!isArrayBufferView(buffer))\n        params = buffer, { buffer = Buffer.alloc(16384) } = params \?\? {};\n      callback = offsetOrOptions;\n    } else\n      callback = buffer, buffer = Buffer.alloc(16384);\n    ({ offset = 0, length = buffer\?.byteLength - offset, position = null } = params \?\? {});\n  }\n  queueMicrotask(() => {\n    try {\n      var bytesRead = fs.readSync(fd, buffer, offset, length, position);\n    } catch (e) {\n      callback(e);\n    }\n    callback(null, bytesRead, buffer);\n  });\n}, write = function write2(...args) {\n  callbackify(fs.writeSync, args);\n}, readdir = function readdir2(...args) {\n  const callback = args[args.length - 1];\n  if (typeof callback !== \"function\")\n    @throwTypeError(\"Callback must be a function\");\n  fs.readdir(...args).then((result) => callback(null, result), callback);\n}, readFile = function readFile2(...args) {\n  const callback = args[args.length - 1];\n  if (typeof callback !== \"function\")\n    @throwTypeError(\"Callback must be a function\");\n  fs.readFile(...args).then((result) => callback(null, result), callback);\n}, writeFile = function writeFile2(...args) {\n  callbackify(fs.writeFileSync, args);\n}, readlink = function readlink2(...args) {\n  callbackify(fs.readlinkSync, args);\n}, realpath = function realpath2(...args) {\n  const callback = args[args.length - 1];\n  if (typeof callback !== \"function\")\n    @throwTypeError(\"Callback must be a function\");\n  fs.realpath(...args).then((result) => callback(null, result), callback);\n}, rename = function rename2(...args) {\n  callbackify(fs.renameSync, args);\n}, lstat = function lstat2(...args) {\n  const callback = args[args.length - 1];\n  if (typeof callback !== \"function\")\n    @throwTypeError(\"Callback must be a function\");\n  fs.lstat(...args).then((result) => callback(null, result), callback);\n}, stat = function stat2(...args) {\n  const callback = args[args.length - 1];\n  if (typeof callback !== \"function\")\n    @throwTypeError(\"Callback must be a function\");\n  fs.stat(...args).then((result) => callback(null, result), callback);\n}, symlink = function symlink2(...args) {\n  callbackify(fs.symlinkSync, args);\n}, truncate = function truncate2(...args) {\n  callbackify(fs.truncateSync, args);\n}, unlink = function unlink2(...args) {\n  callbackify(fs.unlinkSync, args);\n}, utimes = function utimes2(...args) {\n  callbackify(fs.utimesSync, args);\n}, lutimes = function lutimes2(...args) {\n  callbackify(fs.lutimesSync, args);\n}, accessSync = fs.accessSync.bind(fs), appendFileSync = fs.appendFileSync.bind(fs), closeSync = fs.closeSync.bind(fs), copyFileSync = fs.copyFileSync.bind(fs), existsSync = fs.existsSync.bind(fs), chownSync = fs.chownSync.bind(fs), chmodSync = fs.chmodSync.bind(fs), fchmodSync = fs.fchmodSync.bind(fs), fchownSync = fs.fchownSync.bind(fs), fstatSync = fs.fstatSync.bind(fs), fsyncSync = fs.fsyncSync.bind(fs), ftruncateSync = fs.ftruncateSync.bind(fs), futimesSync = fs.futimesSync.bind(fs), lchmodSync = fs.lchmodSync.bind(fs), lchownSync = fs.lchownSync.bind(fs), linkSync = fs.linkSync.bind(fs), lstatSync = fs.lstatSync.bind(fs), mkdirSync = fs.mkdirSync.bind(fs), mkdtempSync = fs.mkdtempSync.bind(fs), openSync = fs.openSync.bind(fs), readSync = fs.readSync.bind(fs), writeSync = fs.writeSync.bind(fs), readdirSync = fs.readdirSync.bind(fs), readFileSync = fs.readFileSync.bind(fs), writeFileSync = fs.writeFileSync.bind(fs), readlinkSync = fs.readlinkSync.bind(fs), realpathSync = fs.realpathSync.bind(fs), renameSync = fs.renameSync.bind(fs), statSync = fs.statSync.bind(fs), symlinkSync = fs.symlinkSync.bind(fs), truncateSync = fs.truncateSync.bind(fs), unlinkSync = fs.unlinkSync.bind(fs), utimesSync = fs.utimesSync.bind(fs), lutimesSync = fs.lutimesSync.bind(fs), rmSync = fs.rmSync.bind(fs), rmdirSync = fs.rmdirSync.bind(fs), writev = (fd, buffers, position, callback) => {\n  if (typeof position === \"function\")\n    callback = position, position = null;\n  queueMicrotask(() => {\n    try {\n      var written = fs.writevSync(fd, buffers, position);\n    } catch (e) {\n      callback(e);\n    }\n    callback(null, written, buffers);\n  });\n}, writevSync = fs.writevSync.bind(fs), readv = (fd, buffers, position, callback) => {\n  if (typeof position === \"function\")\n    callback = position, position = null;\n  queueMicrotask(() => {\n    try {\n      var written = fs.readvSync(fd, buffers, position);\n    } catch (e) {\n      callback(e);\n    }\n    callback(null, written, buffers);\n  });\n}, readvSync = fs.readvSync.bind(fs), Dirent = fs.Dirent, Stats = fs.Stats, watch = function watch2(path, options, listener) {\n  return new FSWatcher(path, options, listener);\n}, readStreamPathFastPathSymbol = Symbol.for(\"Bun.Node.readStreamPathFastPath\"), readStreamSymbol = Symbol.for(\"Bun.NodeReadStream\"), readStreamPathOrFdSymbol = Symbol.for(\"Bun.NodeReadStreamPathOrFd\"), writeStreamSymbol = Symbol.for(\"Bun.NodeWriteStream\"), writeStreamPathFastPathSymbol = Symbol.for(\"Bun.NodeWriteStreamFastPath\"), writeStreamPathFastPathCallSymbol = Symbol.for(\"Bun.NodeWriteStreamFastPathCall\"), kIoDone = Symbol.for(\"kIoDone\"), defaultReadStreamOptions = {\n  file: void 0,\n  fd: void 0,\n  flags: \"r\",\n  encoding: void 0,\n  mode: 438,\n  autoClose: !0,\n  emitClose: !0,\n  start: 0,\n  end: Infinity,\n  highWaterMark: 65536,\n  fs: {\n    read,\n    open: (path, flags, mode, cb) => {\n      var fd;\n      try {\n        fd = openSync(path, flags, mode);\n      } catch (e) {\n        cb(e);\n        return;\n      }\n      cb(null, fd);\n    },\n    openSync,\n    close\n  },\n  autoDestroy: !0\n}, ReadStreamClass;\nReadStream = function(InternalReadStream) {\n  ReadStreamClass = InternalReadStream, Object.defineProperty(ReadStreamClass.prototype, Symbol.toStringTag, {\n    value: \"ReadStream\",\n    enumerable: !1\n  });\n  function ReadStream3(path, options) {\n    return new InternalReadStream(path, options);\n  }\n  return ReadStream3.prototype = InternalReadStream.prototype, Object.defineProperty(ReadStream3, Symbol.hasInstance, {\n    value(instance) {\n      return instance instanceof InternalReadStream;\n    }\n  });\n}(class ReadStream2 extends Stream._getNativeReadableStreamPrototype(2, Stream.Readable) {\n  constructor(pathOrFd, options = defaultReadStreamOptions) {\n    if (typeof options !== \"object\" || !options)\n      @throwTypeError(\"Expected options to be an object\");\n    var {\n      flags = defaultReadStreamOptions.flags,\n      encoding = defaultReadStreamOptions.encoding,\n      mode = defaultReadStreamOptions.mode,\n      autoClose = defaultReadStreamOptions.autoClose,\n      emitClose = defaultReadStreamOptions.emitClose,\n      start = defaultReadStreamOptions.start,\n      end = defaultReadStreamOptions.end,\n      autoDestroy = defaultReadStreamOptions.autoClose,\n      fs: fs2 = defaultReadStreamOptions.fs,\n      highWaterMark = defaultReadStreamOptions.highWaterMark\n    } = options;\n    if (pathOrFd\?.constructor\?.name === \"URL\")\n      pathOrFd = Bun.fileURLToPath(pathOrFd);\n    var tempThis = {};\n    if (typeof pathOrFd === \"string\") {\n      if (pathOrFd.startsWith(\"file://\"))\n        pathOrFd = Bun.fileURLToPath(pathOrFd);\n      if (pathOrFd.length === 0)\n        @throwTypeError(\"Expected path to be a non-empty string\");\n      tempThis.path = tempThis.file = tempThis[readStreamPathOrFdSymbol] = pathOrFd;\n    } else if (typeof pathOrFd === \"number\") {\n      if (pathOrFd |= 0, pathOrFd < 0)\n        @throwTypeError(\"Expected fd to be a positive integer\");\n      tempThis.fd = tempThis[readStreamPathOrFdSymbol] = pathOrFd, tempThis.autoClose = !1;\n    } else\n      @throwTypeError(\"Expected a path or file descriptor\");\n    if (!tempThis.fd)\n      tempThis.fd = fs2.openSync(pathOrFd, flags, mode);\n    var fileRef = Bun.file(tempThis.fd), stream = fileRef.stream(), native = @direct(stream);\n    if (!native)\n      throw new Error(\"no native readable stream\");\n    var { stream: ptr } = native;\n    super(ptr, {\n      ...options,\n      encoding,\n      autoDestroy,\n      autoClose,\n      emitClose,\n      highWaterMark\n    });\n    if (Object.assign(this, tempThis), this.#fileRef = fileRef, this.end = end, this._read = this.#internalRead, this.start = start, this.flags = flags, this.mode = mode, this.emitClose = emitClose, this[readStreamPathFastPathSymbol] = start === 0 && end === Infinity && autoClose && fs2 === defaultReadStreamOptions.fs && (encoding === \"buffer\" || encoding === \"binary\" || encoding == null || encoding === \"utf-8\" || encoding === \"utf8\"), this._readableState.autoClose = autoDestroy = autoClose, this._readableState.highWaterMark = highWaterMark, start !== void 0)\n      this.pos = start;\n  }\n  #fileRef;\n  #fs;\n  file;\n  path;\n  fd = null;\n  flags;\n  mode;\n  start;\n  end;\n  pos;\n  bytesRead = 0;\n  #fileSize = -1;\n  _read;\n  [readStreamSymbol] = !0;\n  [readStreamPathOrFdSymbol];\n  [readStreamPathFastPathSymbol];\n  _construct(callback) {\n    if (super._construct)\n      super._construct(callback);\n    else\n      callback();\n    this.emit(\"open\", this.fd), this.emit(\"ready\");\n  }\n  _destroy(err, cb) {\n    super._destroy(err, cb);\n    try {\n      var fd = this.fd;\n      if (this[readStreamPathFastPathSymbol] = !1, !fd)\n        cb(err);\n      else\n        this.#fs.close(fd, (er) => {\n          cb(er || err);\n        }), this.fd = null;\n    } catch (e) {\n      throw e;\n    }\n  }\n  close(cb) {\n    if (typeof cb === \"function\")\n      eos_()(this, cb);\n    this.destroy();\n  }\n  push(chunk) {\n    var bytesRead = chunk\?.length \?\? 0;\n    if (bytesRead > 0) {\n      this.bytesRead += bytesRead;\n      var currPos = this.pos;\n      if (currPos !== void 0) {\n        if (this.bytesRead < currPos)\n          return !0;\n        if (currPos === this.start) {\n          var n = this.bytesRead - currPos;\n          chunk = chunk.slice(-n);\n          var [_, ...rest] = arguments;\n          if (this.pos = this.bytesRead, this.end !== void 0 && this.bytesRead > this.end)\n            chunk = chunk.slice(0, this.end - this.start + 1);\n          return super.push(chunk, ...rest);\n        }\n        var end = this.end;\n        if (end !== void 0 && this.bytesRead > end) {\n          chunk = chunk.slice(0, end - currPos + 1);\n          var [_, ...rest] = arguments;\n          return this.pos = this.bytesRead, super.push(chunk, ...rest);\n        }\n        this.pos = this.bytesRead;\n      }\n    }\n    return super.push(...arguments);\n  }\n  #internalRead(n) {\n    var { pos, end, bytesRead, fd, encoding } = this;\n    if (n = pos !== void 0 \? Math.min(end - pos + 1, n) : Math.min(end - bytesRead + 1, n), n <= 0) {\n      this.push(null);\n      return;\n    }\n    if (this.#fileSize === -1 && bytesRead === 0 && pos === void 0) {\n      var stat3 = fstatSync(fd);\n      if (this.#fileSize = stat3.size, this.#fileSize > 0 && n > this.#fileSize)\n        n = this.#fileSize + 1;\n    }\n    this[kIoDone] = !1;\n    var res = super._read(n);\n    if (@isPromise(res)) {\n      var then = res\?.then;\n      if (then && @isCallable(then))\n        res.then(() => {\n          if (this[kIoDone] = !0, this.destroyed)\n            this.emit(kIoDone);\n        }, (er) => {\n          this[kIoDone] = !0, this.#errorOrDestroy(er);\n        });\n    } else if (this[kIoDone] = !0, this.destroyed)\n      this.emit(kIoDone), this.#errorOrDestroy(new Error(\"ERR_STREAM_PREMATURE_CLOSE\"));\n  }\n  #errorOrDestroy(err, sync = null) {\n    var {\n      _readableState: r = { destroyed: !1, autoDestroy: !1 },\n      _writableState: w = { destroyed: !1, autoDestroy: !1 }\n    } = this;\n    if (w\?.destroyed || r\?.destroyed)\n      return this;\n    if (r\?.autoDestroy || w\?.autoDestroy)\n      this.destroy(err);\n    else if (err)\n      this.emit(\"error\", err);\n  }\n  pause() {\n    return this[readStreamPathFastPathSymbol] = !1, super.pause();\n  }\n  resume() {\n    return this[readStreamPathFastPathSymbol] = !1, super.resume();\n  }\n  unshift(...args) {\n    return this[readStreamPathFastPathSymbol] = !1, super.unshift(...args);\n  }\n  pipe(dest, pipeOpts) {\n    if (this[readStreamPathFastPathSymbol] && (pipeOpts\?.end \?\? !0) && this._readableState\?.pipes\?.length === 0) {\n      if ((writeStreamPathFastPathSymbol in dest) && dest[writeStreamPathFastPathSymbol]) {\n        if (dest[writeStreamPathFastPathCallSymbol](this, pipeOpts))\n          return this;\n      }\n    }\n    return this[readStreamPathFastPathSymbol] = !1, super.pipe(dest, pipeOpts);\n  }\n});\nvar defaultWriteStreamOptions = {\n  fd: null,\n  start: void 0,\n  pos: void 0,\n  encoding: void 0,\n  flags: \"w\",\n  mode: 438,\n  fs: {\n    write,\n    close,\n    open,\n    openSync\n  }\n}, WriteStreamClass;\nWriteStream = function(InternalWriteStream) {\n  WriteStreamClass = InternalWriteStream, Object.defineProperty(WriteStreamClass.prototype, Symbol.toStringTag, {\n    value: \"WritesStream\",\n    enumerable: !1\n  });\n  function WriteStream3(path, options) {\n    return new InternalWriteStream(path, options);\n  }\n  return WriteStream3.prototype = InternalWriteStream.prototype, Object.defineProperty(WriteStream3, Symbol.hasInstance, {\n    value(instance) {\n      return instance instanceof InternalWriteStream;\n    }\n  });\n}(class WriteStream2 extends Stream.NativeWritable {\n  constructor(path, options = defaultWriteStreamOptions) {\n    if (!options)\n      @throwTypeError(\"Expected options to be an object\");\n    var {\n      fs: fs2 = defaultWriteStreamOptions.fs,\n      start = defaultWriteStreamOptions.start,\n      flags = defaultWriteStreamOptions.flags,\n      mode = defaultWriteStreamOptions.mode,\n      autoClose = !0,\n      emitClose = !1,\n      autoDestroy = autoClose,\n      encoding = defaultWriteStreamOptions.encoding,\n      fd = defaultWriteStreamOptions.fd,\n      pos = defaultWriteStreamOptions.pos\n    } = options, tempThis = {};\n    if (typeof path === \"string\") {\n      if (path.length === 0)\n        @throwTypeError(\"Expected a non-empty path\");\n      if (path.startsWith(\"file:\"))\n        path = Bun.fileURLToPath(path);\n      tempThis.path = path, tempThis.fd = null, tempThis[writeStreamPathFastPathSymbol] = autoClose && (start === void 0 || start === 0) && fs2.write === defaultWriteStreamOptions.fs.write && fs2.close === defaultWriteStreamOptions.fs.close;\n    } else\n      tempThis.fd = fd, tempThis[writeStreamPathFastPathSymbol] = !1;\n    if (!tempThis.fd)\n      tempThis.fd = fs2.openSync(path, flags, mode);\n    super(tempThis.fd, {\n      ...options,\n      decodeStrings: !1,\n      autoDestroy,\n      emitClose,\n      fd: tempThis\n    });\n    if (Object.assign(this, tempThis), typeof fs2\?.write !== \"function\")\n      @throwTypeError(\"Expected fs.write to be a function\");\n    if (typeof fs2\?.close !== \"function\")\n      @throwTypeError(\"Expected fs.close to be a function\");\n    if (typeof fs2\?.open !== \"function\")\n      @throwTypeError(\"Expected fs.open to be a function\");\n    if (typeof path === \"object\" && path) {\n      if (path instanceof URL)\n        path = Bun.fileURLToPath(path);\n    }\n    if (typeof path !== \"string\" && typeof fd !== \"number\")\n      @throwTypeError(\"Expected a path or file descriptor\");\n    if (this.start = start, this.#fs = fs2, this.flags = flags, this.mode = mode, this.start !== void 0)\n      this.pos = this.start;\n    if (encoding !== defaultWriteStreamOptions.encoding) {\n      if (this.setDefaultEncoding(encoding), encoding !== \"buffer\" && encoding !== \"utf8\" && encoding !== \"utf-8\" && encoding !== \"binary\")\n        this[writeStreamPathFastPathSymbol] = !1;\n    }\n  }\n  get autoClose() {\n    return this._writableState.autoDestroy;\n  }\n  set autoClose(val) {\n    this._writableState.autoDestroy = val;\n  }\n  destroySoon = this.end;\n  open() {\n  }\n  path;\n  fd;\n  flags;\n  mode;\n  #fs;\n  bytesWritten = 0;\n  pos;\n  [writeStreamPathFastPathSymbol];\n  [writeStreamSymbol] = !0;\n  start;\n  [writeStreamPathFastPathCallSymbol](readStream, pipeOpts) {\n    if (!this[writeStreamPathFastPathSymbol])\n      return !1;\n    if (this.fd !== null)\n      return this[writeStreamPathFastPathSymbol] = !1, !1;\n    return this[kIoDone] = !1, readStream[kIoDone] = !1, Bun.write(this[writeStreamPathFastPathSymbol], readStream[readStreamPathOrFdSymbol]).then((bytesWritten) => {\n      readStream[kIoDone] = this[kIoDone] = !0, this.bytesWritten += bytesWritten, readStream.bytesRead += bytesWritten, this.end(), readStream.close();\n    }, (err) => {\n      readStream[kIoDone] = this[kIoDone] = !0, this.#errorOrDestroy(err), readStream.emit(\"error\", err);\n    });\n  }\n  isBunFastPathEnabled() {\n    return this[writeStreamPathFastPathSymbol];\n  }\n  disableBunFastPath() {\n    this[writeStreamPathFastPathSymbol] = !1;\n  }\n  #handleWrite(er, bytes) {\n    if (er)\n      return this.#errorOrDestroy(er);\n    this.bytesWritten += bytes;\n  }\n  #internalClose(err, cb) {\n    this[writeStreamPathFastPathSymbol] = !1;\n    var fd = this.fd;\n    this.#fs.close(fd, (er) => {\n      this.fd = null, cb(err || er);\n    });\n  }\n  _construct(callback) {\n    if (typeof this.fd === \"number\") {\n      callback();\n      return;\n    }\n    callback(), this.emit(\"open\", this.fd), this.emit(\"ready\");\n  }\n  _destroy(err, cb) {\n    if (this.fd === null)\n      return cb(err);\n    if (this[kIoDone]) {\n      this.once(kIoDone, () => this.#internalClose(err, cb));\n      return;\n    }\n    this.#internalClose(err, cb);\n  }\n  [kIoDone] = !1;\n  close(cb) {\n    if (cb) {\n      if (this.closed) {\n        process.nextTick(cb);\n        return;\n      }\n      this.on(\"close\", cb);\n    }\n    if (!this.autoClose)\n      this.on(\"finish\", this.destroy);\n    this.end();\n  }\n  write(chunk, encoding = this._writableState.defaultEncoding, cb) {\n    if (this[writeStreamPathFastPathSymbol] = !1, typeof chunk === \"string\")\n      chunk = Buffer.from(chunk, encoding);\n    var native = this.pos === void 0;\n    return this[kIoDone] = !0, super.write(chunk, encoding, native \? (err, bytes) => {\n      if (this[kIoDone] = !1, this.#handleWrite(err, bytes), this.emit(kIoDone), cb)\n        !err \? cb() : cb(err);\n    } : () => {\n    }, native);\n  }\n  #internalWriteSlow(chunk, encoding, cb) {\n    this.#fs.write(this.fd, chunk, 0, chunk.length, this.pos, (err, bytes) => {\n      this[kIoDone] = !1, this.#handleWrite(err, bytes), this.emit(kIoDone), !err \? cb() : cb(err);\n    });\n  }\n  end(chunk, encoding, cb) {\n    var native = this.pos === void 0;\n    return super.end(chunk, encoding, cb, native);\n  }\n  _write = this.#internalWriteSlow;\n  _writev = void 0;\n  get pending() {\n    return this.fd === null;\n  }\n  _destroy(err, cb) {\n    this.close(err, cb);\n  }\n  #errorOrDestroy(err) {\n    var {\n      _readableState: r = { destroyed: !1, autoDestroy: !1 },\n      _writableState: w = { destroyed: !1, autoDestroy: !1 }\n    } = this;\n    if (w\?.destroyed || r\?.destroyed)\n      return this;\n    if (r\?.autoDestroy || w\?.autoDestroy)\n      this.destroy(err);\n    else if (err)\n      this.emit(\"error\", err);\n  }\n});\nObject.defineProperties(fs, {\n  createReadStream: {\n    value: createReadStream\n  },\n  createWriteStream: {\n    value: createWriteStream\n  },\n  ReadStream: {\n    value: ReadStream\n  },\n  WriteStream: {\n    value: WriteStream\n  }\n});\nrealpath.native = realpath;\nrealpathSync.native = realpathSync;\n$ = {\n  access,\n  accessSync,\n  appendFile,\n  appendFileSync,\n  chmod,\n  chmodSync,\n  chown,\n  chownSync,\n  close,\n  closeSync,\n  constants: promises.constants,\n  copyFile,\n  copyFileSync,\n  createReadStream,\n  createWriteStream,\n  Dirent,\n  exists,\n  existsSync,\n  fchmod,\n  fchmodSync,\n  fchown,\n  fchownSync,\n  fstat,\n  fstatSync,\n  fsync,\n  fsyncSync,\n  ftruncate,\n  ftruncateSync,\n  futimes,\n  futimesSync,\n  lchmod,\n  lchmodSync,\n  lchown,\n  lchownSync,\n  link,\n  linkSync,\n  lstat,\n  lstatSync,\n  lutimes,\n  lutimesSync,\n  mkdir,\n  mkdirSync,\n  mkdtemp,\n  mkdtempSync,\n  open,\n  openSync,\n  promises,\n  read,\n  readFile,\n  readFileSync,\n  readSync,\n  readdir,\n  readdirSync,\n  readlink,\n  readlinkSync,\n  realpath,\n  realpathSync,\n  rename,\n  renameSync,\n  rm,\n  rmSync,\n  rmdir,\n  rmdirSync,\n  stat,\n  statSync,\n  Stats,\n  symlink,\n  symlinkSync,\n  truncate,\n  truncateSync,\n  unlink,\n  unlinkSync,\n  utimes,\n  utimesSync,\n  write,\n  writeFile,\n  writeFileSync,\n  writeSync,\n  WriteStream,\n  ReadStream,\n  watch,\n  FSWatcher,\n  writev,\n  writevSync,\n  readv,\n  readvSync,\n  [Symbol.for(\"::bunternal::\")]: {\n    ReadStreamClass,\n    WriteStreamClass\n  }\n};\nreturn $})\n"_s;
//

//
static constexpr ASCIILiteral NodeFSPromisesCode = "(function (){\"use strict\";// src/js/out/tmp/node/fs.promises.ts\nvar watch = function(filename, options = {}) {\n  if (filename instanceof URL)\n    @throwTypeError(\"Watch URLs are not supported yet\");\n  else if (Buffer.isBuffer(filename))\n    filename = filename.toString();\n  else if (typeof filename !== \"string\")\n    @throwTypeError(\"Expected path to be a string or Buffer\");\n  let nextEventResolve = null;\n  if (typeof options === \"string\")\n    options = { encoding: options };\n  const queue = @createFIFO(), watcher = fs.watch(filename, options || {}, (eventType, filename2) => {\n    if (queue.push({ eventType, filename: filename2 }), nextEventResolve) {\n      const resolve = nextEventResolve;\n      nextEventResolve = null, resolve();\n    }\n  });\n  return {\n    [Symbol.asyncIterator]() {\n      let closed = !1;\n      return {\n        async next() {\n          while (!closed) {\n            let event;\n            while (event = queue.shift()) {\n              if (event.eventType === \"close\")\n                return closed = !0, { value: void 0, done: !0 };\n              if (event.eventType === \"error\")\n                throw closed = !0, event.filename;\n              return { value: event, done: !1 };\n            }\n            const { promise, resolve } = Promise.withResolvers();\n            nextEventResolve = resolve, await promise;\n          }\n          return { value: void 0, done: !0 };\n        },\n        return() {\n          if (!closed) {\n            if (watcher.close(), closed = !0, nextEventResolve) {\n              const resolve = nextEventResolve;\n              nextEventResolve = null, resolve();\n            }\n          }\n          return { value: void 0, done: !0 };\n        }\n      };\n    }\n  };\n}, $, constants = @processBindingConstants.fs, fs = Bun.fs(), notrace = \"::bunternal::\", promisify = {\n  [notrace]: (fsFunction) => {\n    return async function(...args) {\n      return await 1, fsFunction.apply(fs, args);\n    };\n  }\n}[notrace];\n$ = {\n  access: promisify(fs.accessSync),\n  appendFile: promisify(fs.appendFileSync),\n  close: promisify(fs.closeSync),\n  copyFile: promisify(fs.copyFileSync),\n  exists: promisify(fs.existsSync),\n  chown: promisify(fs.chownSync),\n  chmod: promisify(fs.chmodSync),\n  fchmod: promisify(fs.fchmodSync),\n  fchown: promisify(fs.fchownSync),\n  fstat: promisify(fs.fstatSync),\n  fsync: promisify(fs.fsyncSync),\n  ftruncate: promisify(fs.ftruncateSync),\n  futimes: promisify(fs.futimesSync),\n  lchmod: promisify(fs.lchmodSync),\n  lchown: promisify(fs.lchownSync),\n  link: promisify(fs.linkSync),\n  lstat: fs.lstat.bind(fs),\n  mkdir: promisify(fs.mkdirSync),\n  mkdtemp: promisify(fs.mkdtempSync),\n  open: promisify(fs.openSync),\n  read: promisify(fs.readSync),\n  write: promisify(fs.writeSync),\n  readdir: fs.readdir.bind(fs),\n  readFile: fs.readFile.bind(fs),\n  writeFile: promisify(fs.writeFileSync),\n  readlink: promisify(fs.readlinkSync),\n  realpath: fs.realpath.bind(fs),\n  rename: promisify(fs.renameSync),\n  stat: fs.stat.bind(fs),\n  symlink: promisify(fs.symlinkSync),\n  truncate: promisify(fs.truncateSync),\n  unlink: promisify(fs.unlinkSync),\n  utimes: promisify(fs.utimesSync),\n  lutimes: promisify(fs.lutimesSync),\n  rm: promisify(fs.rmSync),\n  rmdir: promisify(fs.rmdirSync),\n  writev: (fd, buffers, position) => {\n    return new Promise((resolve, reject) => {\n      try {\n        var bytesWritten = fs.writevSync(fd, buffers, position);\n      } catch (err) {\n        reject(err);\n        return;\n      }\n      resolve({\n        bytesWritten,\n        buffers\n      });\n    });\n  },\n  readv: (fd, buffers, position) => {\n    return new Promise((resolve, reject) => {\n      try {\n        var bytesRead = fs.readvSync(fd, buffers, position);\n      } catch (err) {\n        reject(err);\n        return;\n      }\n      resolve({\n        bytesRead,\n        buffers\n      });\n    });\n  },\n  constants,\n  watch\n};\nreturn $})\n"_s;
//

//
static constexpr ASCIILiteral NodeHttpCode = "(function (){\"use strict\";// src/js/out/tmp/node/http.ts\nvar checkInvalidHeaderChar = function(val) {\n  return RegExpPrototypeExec.call(headerCharRegex, val) !== null;\n}, isIPv6 = function(input) {\n  return new RegExp(\"^((\?:(\?:[0-9a-fA-F]{1,4}):){7}(\?:(\?:[0-9a-fA-F]{1,4})|:)|(\?:(\?:[0-9a-fA-F]{1,4}):){6}(\?:((\?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])[.]){3}(\?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])|:(\?:[0-9a-fA-F]{1,4})|:)|(\?:(\?:[0-9a-fA-F]{1,4}):){5}(\?::((\?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])[.]){3}(\?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])|(:(\?:[0-9a-fA-F]{1,4})){1,2}|:)|(\?:(\?:[0-9a-fA-F]{1,4}):){4}(\?:(:(\?:[0-9a-fA-F]{1,4})){0,1}:((\?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])[.]){3}(\?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])|(:(\?:[0-9a-fA-F]{1,4})){1,3}|:)|(\?:(\?:[0-9a-fA-F]{1,4}):){3}(\?:(:(\?:[0-9a-fA-F]{1,4})){0,2}:((\?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])[.]){3}(\?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])|(:(\?:[0-9a-fA-F]{1,4})){1,4}|:)|(\?:(\?:[0-9a-fA-F]{1,4}):){2}(\?:(:(\?:[0-9a-fA-F]{1,4})){0,3}:((\?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])[.]){3}(\?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])|(:(\?:[0-9a-fA-F]{1,4})){1,5}|:)|(\?:(\?:[0-9a-fA-F]{1,4}):){1}(\?:(:(\?:[0-9a-fA-F]{1,4})){0,4}:((\?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])[.]){3}(\?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])|(:(\?:[0-9a-fA-F]{1,4})){1,6}|:)|(\?::((\?::(\?:[0-9a-fA-F]{1,4})){0,5}:((\?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])[.]){3}(\?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])|(\?::(\?:[0-9a-fA-F]{1,4})){1,7}|:)))(%[0-9a-zA-Z-.:]{1,})\?$\").test(input);\n}, isValidTLSArray = function(obj) {\n  if (typeof obj === \"string\" || isTypedArray(obj) || obj instanceof ArrayBuffer || obj instanceof Blob)\n    return !0;\n  if (Array.isArray(obj)) {\n    for (var i = 0;i < obj.length; i++)\n      if (typeof obj !== \"string\" && !isTypedArray(obj) && !(obj instanceof ArrayBuffer) && !(obj instanceof Blob))\n        return !1;\n    return !0;\n  }\n}, validateMsecs = function(numberlike, field) {\n  if (typeof numberlike !== \"number\" || numberlike < 0)\n    throw new ERR_INVALID_ARG_TYPE(field, \"number\", numberlike);\n  return numberlike;\n}, validateFunction = function(callable, field) {\n  if (typeof callable !== \"function\")\n    throw new ERR_INVALID_ARG_TYPE(field, \"Function\", callable);\n  return callable;\n}, getHeader = function(headers, name) {\n  if (!headers)\n    return;\n  const result = headers.get(name);\n  return result == null \? void 0 : result;\n}, createServer = function(options, callback) {\n  return new Server(options, callback);\n}, emitListeningNextTick = function(self, onListen, err, hostname, port) {\n  if (typeof onListen === \"function\")\n    try {\n      onListen(err, hostname, port);\n    } catch (err2) {\n      self.emit(\"error\", err2);\n    }\n  if (self.listening = !err, err)\n    self.emit(\"error\", err);\n  else\n    self.emit(\"listening\", hostname, port);\n}, assignHeaders = function(object, req) {\n  var headers = req.headers.toJSON();\n  const rawHeaders = @newArrayWithSize(req.headers.count * 2);\n  var i = 0;\n  for (let key in headers)\n    rawHeaders[i++] = key, rawHeaders[i++] = headers[key];\n  object.headers = headers, object.rawHeaders = rawHeaders;\n};\nvar getDefaultHTTPSAgent = function() {\n  return _defaultHTTPSAgent \?\?= new Agent({ defaultPort: 443, protocol: \"https:\" });\n};\nvar urlToHttpOptions = function(url) {\n  var { protocol, hostname, hash, search, pathname, href, port, username, password } = url;\n  return {\n    protocol,\n    hostname: typeof hostname === \"string\" && StringPrototypeStartsWith.call(hostname, \"[\") \? StringPrototypeSlice.call(hostname, 1, -1) : hostname,\n    hash,\n    search,\n    pathname,\n    path: `${pathname || \"\"}${search || \"\"}`,\n    href,\n    port: port \? Number(port) : protocol === \"https:\" \? 443 : protocol === \"http:\" \? 80 : void 0,\n    auth: username || password \? `${decodeURIComponent(username)}:${decodeURIComponent(password)}` : void 0\n  };\n}, validateHost = function(host, name) {\n  if (host !== null && host !== void 0 && typeof host !== \"string\")\n    throw new Error(\"Invalid arg type in options\");\n  return host;\n}, checkIsHttpToken = function(val) {\n  return RegExpPrototypeExec.call(tokenRegExp, val) !== null;\n};\nvar _writeHead = function(statusCode, reason, obj, response) {\n  if (statusCode |= 0, statusCode < 100 || statusCode > 999)\n    throw new Error(\"status code must be between 100 and 999\");\n  if (typeof reason === \"string\")\n    response.statusMessage = reason;\n  else {\n    if (!response.statusMessage)\n      response.statusMessage = STATUS_CODES[statusCode] || \"unknown\";\n    obj = reason;\n  }\n  response.statusCode = statusCode;\n  {\n    let k;\n    if (Array.isArray(obj)) {\n      if (obj.length % 2 !== 0)\n        throw new Error(\"raw headers must have an even number of elements\");\n      for (let n = 0;n < obj.length; n += 2)\n        if (k = obj[n + 0], k)\n          response.setHeader(k, obj[n + 1]);\n    } else if (obj) {\n      const keys = Object.keys(obj);\n      for (let i = 0;i < keys.length; i++)\n        if (k = keys[i], k)\n          response.setHeader(k, obj[k]);\n    }\n  }\n  if (statusCode === 204 || statusCode === 304 || statusCode >= 100 && statusCode <= 199)\n    response._hasBody = !1;\n}, request = function(url, options, cb) {\n  return new ClientRequest(url, options, cb);\n}, get = function(url, options, cb) {\n  const req = request(url, options, cb);\n  return req.end(), req;\n}, $, EventEmitter = @getInternalField(@internalModuleRegistry, 16) || @createInternalModuleById(16), { isTypedArray } = @requireNativeModule(\"node:util/types\"), { Duplex, Readable, Writable } = @getInternalField(@internalModuleRegistry, 35) || @createInternalModuleById(35), headerCharRegex = /[^\\t\\x20-\\x7e\\x80-\\xff]/, validateHeaderName = (name, label) => {\n  if (typeof name !== \"string\" || !name || !checkIsHttpToken(name))\n    throw new Error(\"ERR_INVALID_HTTP_TOKEN\");\n}, validateHeaderValue = (name, value) => {\n  if (value === void 0)\n    throw new Error(\"ERR_HTTP_INVALID_HEADER_VALUE\");\n  if (checkInvalidHeaderChar(value))\n    throw new Error(\"ERR_INVALID_CHAR\");\n}, { URL } = globalThis, globalReportError = globalThis.reportError, setTimeout = globalThis.setTimeout, fetch = Bun.fetch;\nvar kEmptyObject = Object.freeze(Object.create(null)), kOutHeaders = Symbol.for(\"kOutHeaders\"), kEndCalled = Symbol.for(\"kEndCalled\"), kAbortController = Symbol.for(\"kAbortController\"), kClearTimeout = Symbol(\"kClearTimeout\"), kCorked = Symbol.for(\"kCorked\"), searchParamsSymbol = Symbol.for(\"query\"), StringPrototypeSlice = String.prototype.slice, StringPrototypeStartsWith = String.prototype.startsWith, StringPrototypeToUpperCase = String.prototype.toUpperCase, StringPrototypeIncludes = String.prototype.includes, StringPrototypeCharCodeAt = String.prototype.charCodeAt, StringPrototypeIndexOf = String.prototype.indexOf, ArrayIsArray = Array.isArray, RegExpPrototypeExec = RegExp.prototype.exec, ObjectAssign = Object.assign;\nvar INVALID_PATH_REGEX = /[^\\u0021-\\u00ff]/;\nvar _defaultHTTPSAgent, kInternalRequest = Symbol(\"kInternalRequest\"), kInternalSocketData = Symbol.for(\"::bunternal::\"), kEmptyBuffer = Buffer.alloc(0);\n\nclass ERR_INVALID_ARG_TYPE extends TypeError {\n  constructor(name, expected, actual) {\n    super(`The ${name} argument must be of type ${expected}. Received type ${typeof actual}`);\n    this.code = \"ERR_INVALID_ARG_TYPE\";\n  }\n}\nvar FakeSocket = class Socket extends Duplex {\n  bytesRead = 0;\n  bytesWritten = 0;\n  connecting = !1;\n  remoteAddress = null;\n  remotePort;\n  timeout = 0;\n  isServer = !1;\n  address() {\n    return {\n      address: this.localAddress,\n      family: this.localFamily,\n      port: this.localPort\n    };\n  }\n  get bufferSize() {\n    return this.writableLength;\n  }\n  connect(port, host, connectListener) {\n    return this;\n  }\n  _destroy(err, callback) {\n  }\n  _final(callback) {\n  }\n  get localAddress() {\n    return \"127.0.0.1\";\n  }\n  get localFamily() {\n    return \"IPv4\";\n  }\n  get localPort() {\n    return 80;\n  }\n  get pending() {\n    return this.connecting;\n  }\n  _read(size) {\n  }\n  get readyState() {\n    if (this.connecting)\n      return \"opening\";\n    if (this.readable)\n      return this.writable \? \"open\" : \"readOnly\";\n    else\n      return this.writable \? \"writeOnly\" : \"closed\";\n  }\n  ref() {\n  }\n  get remoteFamily() {\n    return \"IPv4\";\n  }\n  resetAndDestroy() {\n  }\n  setKeepAlive(enable = !1, initialDelay = 0) {\n  }\n  setNoDelay(noDelay = !0) {\n    return this;\n  }\n  setTimeout(timeout, callback) {\n    return this;\n  }\n  unref() {\n  }\n  _write(chunk, encoding, callback) {\n  }\n};\n\nclass Agent extends EventEmitter {\n  defaultPort = 80;\n  protocol = \"http:\";\n  options;\n  requests;\n  sockets;\n  freeSockets;\n  keepAliveMsecs;\n  keepAlive;\n  maxSockets;\n  maxFreeSockets;\n  scheduling;\n  maxTotalSockets;\n  totalSocketCount;\n  #fakeSocket;\n  static get globalAgent() {\n    return globalAgent;\n  }\n  static get defaultMaxSockets() {\n    return Infinity;\n  }\n  constructor(options = kEmptyObject) {\n    super();\n    if (this.options = options = { ...options, path: null }, options.noDelay === void 0)\n      options.noDelay = !0;\n    this.requests = kEmptyObject, this.sockets = kEmptyObject, this.freeSockets = kEmptyObject, this.keepAliveMsecs = options.keepAliveMsecs || 1000, this.keepAlive = options.keepAlive || !1, this.maxSockets = options.maxSockets || Agent.defaultMaxSockets, this.maxFreeSockets = options.maxFreeSockets || 256, this.scheduling = options.scheduling || \"lifo\", this.maxTotalSockets = options.maxTotalSockets, this.totalSocketCount = 0, this.defaultPort = options.defaultPort || 80, this.protocol = options.protocol || \"http:\";\n  }\n  createConnection() {\n    return this.#fakeSocket \?\?= new FakeSocket;\n  }\n  getName(options = kEmptyObject) {\n    let name = `http:${options.host || \"localhost\"}:`;\n    if (options.port)\n      name += options.port;\n    if (name += \":\", options.localAddress)\n      name += options.localAddress;\n    if (options.family === 4 || options.family === 6)\n      name += `:${options.family}`;\n    if (options.socketPath)\n      name += `:${options.socketPath}`;\n    return name;\n  }\n  addRequest() {\n  }\n  createSocket(req, options, cb) {\n    cb(null, this.#fakeSocket \?\?= new FakeSocket);\n  }\n  removeSocket() {\n  }\n  keepSocketAlive() {\n    return !0;\n  }\n  reuseSocket() {\n  }\n  destroy() {\n  }\n}\n\nclass Server extends EventEmitter {\n  #server;\n  #options;\n  #tls;\n  #is_tls = !1;\n  listening = !1;\n  serverName;\n  constructor(options, callback) {\n    super();\n    if (typeof options === \"function\")\n      callback = options, options = {};\n    else if (options == null || typeof options === \"object\") {\n      options = { ...options }, this.#tls = null;\n      let key = options.key;\n      if (key) {\n        if (!isValidTLSArray(key))\n          @throwTypeError(\"key argument must be an string, Buffer, TypedArray, BunFile or an array containing string, Buffer, TypedArray or BunFile\");\n        this.#is_tls = !0;\n      }\n      let cert = options.cert;\n      if (cert) {\n        if (!isValidTLSArray(cert))\n          @throwTypeError(\"cert argument must be an string, Buffer, TypedArray, BunFile or an array containing string, Buffer, TypedArray or BunFile\");\n        this.#is_tls = !0;\n      }\n      let ca = options.ca;\n      if (ca) {\n        if (!isValidTLSArray(ca))\n          @throwTypeError(\"ca argument must be an string, Buffer, TypedArray, BunFile or an array containing string, Buffer, TypedArray or BunFile\");\n        this.#is_tls = !0;\n      }\n      let passphrase = options.passphrase;\n      if (passphrase && typeof passphrase !== \"string\")\n        @throwTypeError(\"passphrase argument must be an string\");\n      let serverName = options.servername;\n      if (serverName && typeof serverName !== \"string\")\n        @throwTypeError(\"servername argument must be an string\");\n      let secureOptions = options.secureOptions || 0;\n      if (secureOptions && typeof secureOptions !== \"number\")\n        @throwTypeError(\"secureOptions argument must be an number\");\n      if (this.#is_tls)\n        this.#tls = {\n          serverName,\n          key,\n          cert,\n          ca,\n          passphrase,\n          secureOptions\n        };\n      else\n        this.#tls = null;\n    } else\n      throw new Error(\"bun-http-polyfill: invalid arguments\");\n    if (this.#options = options, callback)\n      this.on(\"request\", callback);\n  }\n  closeAllConnections() {\n    const server = this.#server;\n    if (!server)\n      return;\n    this.#server = void 0, server.stop(!0), this.emit(\"close\");\n  }\n  closeIdleConnections() {\n  }\n  close(optionalCallback) {\n    const server = this.#server;\n    if (!server) {\n      if (typeof optionalCallback === \"function\")\n        process.nextTick(optionalCallback, new Error(\"Server is not running\"));\n      return;\n    }\n    if (this.#server = void 0, typeof optionalCallback === \"function\")\n      this.once(\"close\", optionalCallback);\n    server.stop(), this.emit(\"close\");\n  }\n  address() {\n    if (!this.#server)\n      return null;\n    const address = this.#server.hostname;\n    return {\n      address,\n      family: isIPv6(address) \? \"IPv6\" : \"IPv4\",\n      port: this.#server.port\n    };\n  }\n  listen(port, host, backlog, onListen) {\n    const server = this;\n    if (typeof host === \"function\")\n      onListen = host, host = void 0;\n    if (typeof port === \"function\")\n      onListen = port;\n    else if (typeof port === \"object\") {\n      if (port\?.signal\?.addEventListener(\"abort\", () => {\n        this.close();\n      }), host = port\?.host, port = port\?.port, typeof port\?.callback === \"function\")\n        onListen = port\?.callback;\n    }\n    if (typeof backlog === \"function\")\n      onListen = backlog;\n    const ResponseClass = this.#options.ServerResponse || ServerResponse, RequestClass = this.#options.IncomingMessage || IncomingMessage;\n    try {\n      const tls = this.#tls;\n      if (tls)\n        this.serverName = tls.serverName || host || \"localhost\";\n      this.#server = Bun.serve({\n        tls,\n        port,\n        hostname: host,\n        websocket: {\n          open(ws) {\n            ws.data.open(ws);\n          },\n          message(ws, message) {\n            ws.data.message(ws, message);\n          },\n          close(ws, code, reason) {\n            ws.data.close(ws, code, reason);\n          },\n          drain(ws) {\n            ws.data.drain(ws);\n          }\n        },\n        fetch(req, _server) {\n          var pendingResponse, pendingError, rejectFunction, resolveFunction, reject = (err) => {\n            if (pendingError)\n              return;\n            if (pendingError = err, rejectFunction)\n              rejectFunction(err);\n          }, reply = function(resp) {\n            if (pendingResponse)\n              return;\n            if (pendingResponse = resp, resolveFunction)\n              resolveFunction(resp);\n          };\n          const http_req = new RequestClass(req), http_res = new ResponseClass({ reply, req: http_req });\n          if (http_req.once(\"error\", (err) => reject(err)), http_res.once(\"error\", (err) => reject(err)), req.headers.get(\"upgrade\")) {\n            const socket = new FakeSocket;\n            socket[kInternalSocketData] = [_server, http_res, req], server.emit(\"upgrade\", http_req, socket, kEmptyBuffer);\n          } else\n            server.emit(\"request\", http_req, http_res);\n          if (pendingError)\n            throw pendingError;\n          if (pendingResponse)\n            return pendingResponse;\n          return new Promise((resolve, reject2) => {\n            resolveFunction = resolve, rejectFunction = reject2;\n          });\n        }\n      }), setTimeout(emitListeningNextTick, 1, this, onListen, null, this.#server.hostname, this.#server.port);\n    } catch (err) {\n      setTimeout(emitListeningNextTick, 1, this, onListen, err);\n    }\n    return this;\n  }\n  setTimeout(msecs, callback) {\n  }\n}\nclass IncomingMessage extends Readable {\n  method;\n  complete;\n  constructor(req, defaultIncomingOpts) {\n    const method = req.method;\n    super();\n    const url = new URL(req.url);\n    var { type = \"request\", [kInternalRequest]: nodeReq } = defaultIncomingOpts || {};\n    this.#noBody = type === \"request\" \? method === \"GET\" || method === \"HEAD\" || method === \"TRACE\" || method === \"CONNECT\" || method === \"OPTIONS\" || (parseInt(req.headers.get(\"Content-Length\") || \"\") || 0) === 0 : !1, this.#req = req, this.method = method, this.#type = type, this.complete = !!this.#noBody, this.#bodyStream = void 0;\n    const socket = new FakeSocket;\n    socket.remoteAddress = url.hostname, socket.remotePort = url.port, this.#fakeSocket = socket, this.url = url.pathname + url.search, this.#nodeReq = this.req = nodeReq, assignHeaders(this, req);\n  }\n  headers;\n  rawHeaders;\n  _consuming = !1;\n  _dumped = !1;\n  #bodyStream;\n  #fakeSocket;\n  #noBody = !1;\n  #aborted = !1;\n  #req;\n  url;\n  #type;\n  #nodeReq;\n  _construct(callback) {\n    if (this.#type === \"response\" || this.#noBody) {\n      callback();\n      return;\n    }\n    const contentLength = this.#req.headers.get(\"content-length\");\n    if ((contentLength \? parseInt(contentLength, 10) : 0) === 0) {\n      this.#noBody = !0, callback();\n      return;\n    }\n    callback();\n  }\n  async#consumeStream(reader) {\n    while (!0) {\n      var { done, value } = await reader.readMany();\n      if (this.#aborted)\n        return;\n      if (done) {\n        this.push(null), this.destroy();\n        break;\n      }\n      for (var v of value)\n        this.push(v);\n    }\n  }\n  _read(size) {\n    if (this.#noBody)\n      this.push(null), this.complete = !0;\n    else if (this.#bodyStream == null) {\n      const reader = this.#req.body\?.getReader();\n      if (!reader) {\n        this.push(null);\n        return;\n      }\n      this.#bodyStream = reader, this.#consumeStream(reader);\n    }\n  }\n  get aborted() {\n    return this.#aborted;\n  }\n  #abort() {\n    if (this.#aborted)\n      return;\n    this.#aborted = !0;\n    var bodyStream = this.#bodyStream;\n    if (!bodyStream)\n      return;\n    bodyStream.cancel(), this.complete = !0, this.#bodyStream = void 0, this.push(null);\n  }\n  get connection() {\n    return this.#fakeSocket;\n  }\n  get statusCode() {\n    return this.#req.status;\n  }\n  get statusMessage() {\n    return STATUS_CODES[this.#req.status];\n  }\n  get httpVersion() {\n    return \"1.1\";\n  }\n  get rawTrailers() {\n    return [];\n  }\n  get httpVersionMajor() {\n    return 1;\n  }\n  get httpVersionMinor() {\n    return 1;\n  }\n  get trailers() {\n    return kEmptyObject;\n  }\n  get socket() {\n    return this.#fakeSocket \?\?= new FakeSocket;\n  }\n  set socket(val) {\n    this.#fakeSocket = val;\n  }\n  setTimeout(msecs, callback) {\n    throw new Error(\"not implemented\");\n  }\n}\n\nclass OutgoingMessage extends Writable {\n  constructor() {\n    super(...arguments);\n  }\n  #headers;\n  headersSent = !1;\n  sendDate = !0;\n  req;\n  timeout;\n  #finished = !1;\n  [kEndCalled] = !1;\n  #fakeSocket;\n  #timeoutTimer;\n  [kAbortController] = null;\n  _implicitHeader() {\n  }\n  get headers() {\n    if (!this.#headers)\n      return kEmptyObject;\n    return this.#headers.toJSON();\n  }\n  get shouldKeepAlive() {\n    return !0;\n  }\n  get chunkedEncoding() {\n    return !1;\n  }\n  set chunkedEncoding(value) {\n  }\n  set shouldKeepAlive(value) {\n  }\n  get useChunkedEncodingByDefault() {\n    return !0;\n  }\n  set useChunkedEncodingByDefault(value) {\n  }\n  get socket() {\n    return this.#fakeSocket \?\?= new FakeSocket;\n  }\n  set socket(val) {\n    this.#fakeSocket = val;\n  }\n  get connection() {\n    return this.socket;\n  }\n  get finished() {\n    return this.#finished;\n  }\n  appendHeader(name, value) {\n    var headers = this.#headers \?\?= new Headers;\n    headers.append(name, value);\n  }\n  flushHeaders() {\n  }\n  getHeader(name) {\n    return getHeader(this.#headers, name);\n  }\n  getHeaders() {\n    if (!this.#headers)\n      return kEmptyObject;\n    return this.#headers.toJSON();\n  }\n  getHeaderNames() {\n    var headers = this.#headers;\n    if (!headers)\n      return [];\n    return Array.from(headers.keys());\n  }\n  removeHeader(name) {\n    if (!this.#headers)\n      return;\n    this.#headers.delete(name);\n  }\n  setHeader(name, value) {\n    var headers = this.#headers \?\?= new Headers;\n    return headers.set(name, value), this;\n  }\n  hasHeader(name) {\n    if (!this.#headers)\n      return !1;\n    return this.#headers.has(name);\n  }\n  addTrailers(headers) {\n    throw new Error(\"not implemented\");\n  }\n  [kClearTimeout]() {\n    if (this.#timeoutTimer)\n      clearTimeout(this.#timeoutTimer), this.removeAllListeners(\"timeout\"), this.#timeoutTimer = void 0;\n  }\n  #onTimeout() {\n    this.#timeoutTimer = void 0, this[kAbortController]\?.abort(), this.emit(\"timeout\");\n  }\n  setTimeout(msecs, callback) {\n    if (this.destroyed)\n      return this;\n    if (this.timeout = msecs = validateMsecs(msecs, \"msecs\"), clearTimeout(this.#timeoutTimer), msecs === 0) {\n      if (callback !== void 0)\n        validateFunction(callback, \"callback\"), this.removeListener(\"timeout\", callback);\n      this.#timeoutTimer = void 0;\n    } else if (this.#timeoutTimer = setTimeout(this.#onTimeout.bind(this), msecs).unref(), callback !== void 0)\n      validateFunction(callback, \"callback\"), this.once(\"timeout\", callback);\n    return this;\n  }\n}\nvar OriginalWriteHeadFn, OriginalImplicitHeadFn;\n\nclass ServerResponse extends Writable {\n  constructor({ req, reply }) {\n    super();\n    if (this.req = req, this._reply = reply, this.sendDate = !0, this.statusCode = 200, this.headersSent = !1, this.statusMessage = void 0, this.#controller = void 0, this.#firstWrite = void 0, this._writableState.decodeStrings = !1, this.#deferred = void 0, req.method === \"HEAD\")\n      this._hasBody = !1;\n  }\n  req;\n  _reply;\n  sendDate;\n  statusCode;\n  #headers;\n  headersSent = !1;\n  statusMessage;\n  #controller;\n  #firstWrite;\n  _sent100 = !1;\n  _defaultKeepAlive = !1;\n  _removedConnection = !1;\n  _removedContLen = !1;\n  _hasBody = !0;\n  #deferred = void 0;\n  #finished = !1;\n  _implicitHeader() {\n    this.writeHead(this.statusCode);\n  }\n  _write(chunk, encoding, callback) {\n    if (!this.#firstWrite && !this.headersSent) {\n      this.#firstWrite = chunk, callback();\n      return;\n    }\n    this.#ensureReadableStreamController((controller) => {\n      controller.write(chunk), callback();\n    });\n  }\n  _writev(chunks, callback) {\n    if (chunks.length === 1 && !this.headersSent && !this.#firstWrite) {\n      this.#firstWrite = chunks[0].chunk, callback();\n      return;\n    }\n    this.#ensureReadableStreamController((controller) => {\n      for (let chunk of chunks)\n        controller.write(chunk.chunk);\n      callback();\n    });\n  }\n  #ensureReadableStreamController(run) {\n    var thisController = this.#controller;\n    if (thisController)\n      return run(thisController);\n    this.headersSent = !0;\n    var firstWrite = this.#firstWrite;\n    this.#firstWrite = void 0, this._reply(new Response(new ReadableStream({\n      type: \"direct\",\n      pull: (controller) => {\n        if (this.#controller = controller, firstWrite)\n          controller.write(firstWrite);\n        if (firstWrite = void 0, run(controller), !this.#finished)\n          return new Promise((resolve) => {\n            this.#deferred = resolve;\n          });\n      }\n    }), {\n      headers: this.#headers,\n      status: this.statusCode,\n      statusText: this.statusMessage \?\? STATUS_CODES[this.statusCode]\n    }));\n  }\n  #drainHeadersIfObservable() {\n    if (this._implicitHeader === OriginalImplicitHeadFn && this.writeHead === OriginalWriteHeadFn)\n      return;\n    this._implicitHeader();\n  }\n  _final(callback) {\n    if (!this.headersSent) {\n      var data = this.#firstWrite || \"\";\n      this.#firstWrite = void 0, this.#finished = !0, this.#drainHeadersIfObservable(), this._reply(new Response(data, {\n        headers: this.#headers,\n        status: this.statusCode,\n        statusText: this.statusMessage \?\? STATUS_CODES[this.statusCode]\n      })), callback && callback();\n      return;\n    }\n    this.#finished = !0, this.#ensureReadableStreamController((controller) => {\n      controller.end(), callback();\n      var deferred = this.#deferred;\n      if (deferred)\n        this.#deferred = void 0, deferred();\n    });\n  }\n  writeProcessing() {\n    throw new Error(\"not implemented\");\n  }\n  addTrailers(headers) {\n    throw new Error(\"not implemented\");\n  }\n  assignSocket(socket) {\n    throw new Error(\"not implemented\");\n  }\n  detachSocket(socket) {\n    throw new Error(\"not implemented\");\n  }\n  writeContinue(callback) {\n    throw new Error(\"not implemented\");\n  }\n  setTimeout(msecs, callback) {\n    throw new Error(\"not implemented\");\n  }\n  get shouldKeepAlive() {\n    return !0;\n  }\n  get chunkedEncoding() {\n    return !1;\n  }\n  set chunkedEncoding(value) {\n  }\n  set shouldKeepAlive(value) {\n  }\n  get useChunkedEncodingByDefault() {\n    return !0;\n  }\n  set useChunkedEncodingByDefault(value) {\n  }\n  appendHeader(name, value) {\n    var headers = this.#headers \?\?= new Headers;\n    headers.append(name, value);\n  }\n  flushHeaders() {\n  }\n  getHeader(name) {\n    return getHeader(this.#headers, name);\n  }\n  getHeaders() {\n    var headers = this.#headers;\n    if (!headers)\n      return kEmptyObject;\n    return headers.toJSON();\n  }\n  getHeaderNames() {\n    var headers = this.#headers;\n    if (!headers)\n      return [];\n    return Array.from(headers.keys());\n  }\n  removeHeader(name) {\n    if (!this.#headers)\n      return;\n    this.#headers.delete(name);\n  }\n  setHeader(name, value) {\n    var headers = this.#headers \?\?= new Headers;\n    return headers.set(name, value), this;\n  }\n  hasHeader(name) {\n    if (!this.#headers)\n      return !1;\n    return this.#headers.has(name);\n  }\n  writeHead(statusCode, statusMessage, headers) {\n    return _writeHead(statusCode, statusMessage, headers, this), this;\n  }\n}\nOriginalWriteHeadFn = ServerResponse.prototype.writeHead;\nOriginalImplicitHeadFn = ServerResponse.prototype._implicitHeader;\n\nclass ClientRequest extends OutgoingMessage {\n  #timeout;\n  #res = null;\n  #upgradeOrConnect = !1;\n  #parser = null;\n  #maxHeadersCount = null;\n  #reusedSocket = !1;\n  #host;\n  #protocol;\n  #method;\n  #port;\n  #useDefaultPort;\n  #joinDuplicateHeaders;\n  #maxHeaderSize;\n  #agent = globalAgent;\n  #path;\n  #socketPath;\n  #bodyChunks = null;\n  #fetchRequest;\n  #signal = null;\n  [kAbortController] = null;\n  #timeoutTimer = void 0;\n  #options;\n  #finished;\n  get path() {\n    return this.#path;\n  }\n  get port() {\n    return this.#port;\n  }\n  get method() {\n    return this.#method;\n  }\n  get host() {\n    return this.#host;\n  }\n  get protocol() {\n    return this.#protocol;\n  }\n  _write(chunk, encoding, callback) {\n    if (!this.#bodyChunks) {\n      this.#bodyChunks = [chunk], callback();\n      return;\n    }\n    this.#bodyChunks.push(chunk), callback();\n  }\n  _writev(chunks, callback) {\n    if (!this.#bodyChunks) {\n      this.#bodyChunks = chunks, callback();\n      return;\n    }\n    this.#bodyChunks.push(...chunks), callback();\n  }\n  _final(callback) {\n    if (this.#finished = !0, this[kAbortController] = new AbortController, this[kAbortController].signal.addEventListener(\"abort\", () => {\n      this[kClearTimeout]();\n    }), this.#signal\?.aborted)\n      this[kAbortController].abort();\n    var method = this.#method, body = this.#bodyChunks\?.length === 1 \? this.#bodyChunks[0] : Buffer.concat(this.#bodyChunks || []);\n    try {\n      this.#fetchRequest = fetch(`${this.#protocol}//${this.#host}${this.#useDefaultPort \? \"\" : \":\" + this.#port}${this.#path}`, {\n        method,\n        headers: this.getHeaders(),\n        body: body && method !== \"GET\" && method !== \"HEAD\" && method !== \"OPTIONS\" \? body : void 0,\n        redirect: \"manual\",\n        verbose: !1,\n        signal: this[kAbortController].signal,\n        timeout: !1\n      }).then((response) => {\n        var res = this.#res = new IncomingMessage(response, {\n          type: \"response\",\n          [kInternalRequest]: this\n        });\n        this.emit(\"response\", res);\n      }).catch((err) => {\n        this.emit(\"error\", err);\n      }).finally(() => {\n        this.#fetchRequest = null, this[kClearTimeout]();\n      });\n    } catch (err) {\n      this.emit(\"error\", err);\n    } finally {\n      callback();\n    }\n  }\n  get aborted() {\n    return this.#signal\?.aborted || !!this[kAbortController]\?.signal.aborted;\n  }\n  abort() {\n    if (this.aborted)\n      return;\n    this[kAbortController].abort();\n  }\n  constructor(input, options, cb) {\n    super();\n    if (typeof input === \"string\") {\n      const urlStr = input;\n      try {\n        var urlObject = new URL(urlStr);\n      } catch (e) {\n        @throwTypeError(`Invalid URL: ${urlStr}`);\n      }\n      input = urlToHttpOptions(urlObject);\n    } else if (input && typeof input === \"object\" && input instanceof URL)\n      input = urlToHttpOptions(input);\n    else\n      cb = options, options = input, input = null;\n    if (typeof options === \"function\")\n      cb = options, options = input || kEmptyObject;\n    else\n      options = ObjectAssign(input || {}, options);\n    var defaultAgent = options._defaultAgent || Agent.globalAgent;\n    let protocol = options.protocol;\n    if (!protocol)\n      if (options.port === 443)\n        protocol = \"https:\";\n      else\n        protocol = defaultAgent.protocol || \"http:\";\n    switch (this.#protocol = protocol, this.#agent\?.protocol) {\n      case void 0:\n        break;\n      case \"http:\":\n        if (protocol === \"https:\") {\n          defaultAgent = this.#agent = getDefaultHTTPSAgent();\n          break;\n        }\n      case \"https:\":\n        if (protocol === \"https\") {\n          defaultAgent = this.#agent = Agent.globalAgent;\n          break;\n        }\n      default:\n        break;\n    }\n    if (options.path) {\n      const path = String(options.path);\n      if (RegExpPrototypeExec.call(INVALID_PATH_REGEX, path) !== null)\n        throw new Error(\"Path contains unescaped characters\");\n    }\n    if (protocol !== \"http:\" && protocol !== \"https:\" && protocol) {\n      const expectedProtocol = defaultAgent\?.protocol \?\? \"http:\";\n      throw new Error(`Protocol mismatch. Expected: ${expectedProtocol}. Got: ${protocol}`);\n    }\n    const defaultPort = protocol === \"https:\" \? 443 : 80;\n    this.#port = options.port || options.defaultPort || this.#agent\?.defaultPort || defaultPort, this.#useDefaultPort = this.#port === defaultPort;\n    const host = this.#host = options.host = validateHost(options.hostname, \"hostname\") || validateHost(options.host, \"host\") || \"localhost\";\n    this.#socketPath = options.socketPath;\n    const signal = options.signal;\n    if (signal)\n      signal.addEventListener(\"abort\", () => {\n        this[kAbortController]\?.abort();\n      }), this.#signal = signal;\n    let method = options.method;\n    const methodIsString = typeof method === \"string\";\n    if (method !== null && method !== void 0 && !methodIsString)\n      throw new Error(\"ERR_INVALID_ARG_TYPE: options.method\");\n    if (methodIsString && method) {\n      if (!checkIsHttpToken(method))\n        throw new Error(\"ERR_INVALID_HTTP_TOKEN: Method\");\n      method = this.#method = StringPrototypeToUpperCase.call(method);\n    } else\n      method = this.#method = \"GET\";\n    const _maxHeaderSize = options.maxHeaderSize;\n    this.#maxHeaderSize = _maxHeaderSize;\n    var _joinDuplicateHeaders = options.joinDuplicateHeaders;\n    if (this.#joinDuplicateHeaders = _joinDuplicateHeaders, this.#path = options.path || \"/\", cb)\n      this.once(\"response\", cb);\n    this.#finished = !1, this.#res = null, this.#upgradeOrConnect = !1, this.#parser = null, this.#maxHeadersCount = null, this.#reusedSocket = !1, this.#host = host, this.#protocol = protocol;\n    var timeout = options.timeout;\n    if (timeout !== void 0 && timeout !== 0)\n      this.setTimeout(timeout, void 0);\n    if (!ArrayIsArray(headers)) {\n      var headers = options.headers;\n      if (headers)\n        for (let key in headers)\n          this.setHeader(key, headers[key]);\n      var auth = options.auth;\n      if (auth && !this.getHeader(\"Authorization\"))\n        this.setHeader(\"Authorization\", \"Basic \" + Buffer.from(auth).toString(\"base64\"));\n    }\n    var { signal: _signal, ...optsWithoutSignal } = options;\n    this.#options = optsWithoutSignal;\n  }\n  setSocketKeepAlive(enable = !0, initialDelay = 0) {\n  }\n  setNoDelay(noDelay = !0) {\n  }\n  [kClearTimeout]() {\n    if (this.#timeoutTimer)\n      clearTimeout(this.#timeoutTimer), this.#timeoutTimer = void 0, this.removeAllListeners(\"timeout\");\n  }\n  #onTimeout() {\n    this.#timeoutTimer = void 0, this[kAbortController]\?.abort(), this.emit(\"timeout\");\n  }\n  setTimeout(msecs, callback) {\n    if (this.destroyed)\n      return this;\n    if (this.timeout = msecs = validateMsecs(msecs, \"msecs\"), clearTimeout(this.#timeoutTimer), msecs === 0) {\n      if (callback !== void 0)\n        validateFunction(callback, \"callback\"), this.removeListener(\"timeout\", callback);\n      this.#timeoutTimer = void 0;\n    } else if (this.#timeoutTimer = setTimeout(this.#onTimeout.bind(this), msecs).unref(), callback !== void 0)\n      validateFunction(callback, \"callback\"), this.once(\"timeout\", callback);\n    return this;\n  }\n}\nvar tokenRegExp = /^[\\^_`a-zA-Z\\-0-9!#$%&'*+.|~]+$/, METHODS = [\n  \"ACL\",\n  \"BIND\",\n  \"CHECKOUT\",\n  \"CONNECT\",\n  \"COPY\",\n  \"DELETE\",\n  \"GET\",\n  \"HEAD\",\n  \"LINK\",\n  \"LOCK\",\n  \"M-SEARCH\",\n  \"MERGE\",\n  \"MKACTIVITY\",\n  \"MKCALENDAR\",\n  \"MKCOL\",\n  \"MOVE\",\n  \"NOTIFY\",\n  \"OPTIONS\",\n  \"PATCH\",\n  \"POST\",\n  \"PROPFIND\",\n  \"PROPPATCH\",\n  \"PURGE\",\n  \"PUT\",\n  \"REBIND\",\n  \"REPORT\",\n  \"SEARCH\",\n  \"SOURCE\",\n  \"SUBSCRIBE\",\n  \"TRACE\",\n  \"UNBIND\",\n  \"UNLINK\",\n  \"UNLOCK\",\n  \"UNSUBSCRIBE\"\n], STATUS_CODES = {\n  100: \"Continue\",\n  101: \"Switching Protocols\",\n  102: \"Processing\",\n  103: \"Early Hints\",\n  200: \"OK\",\n  201: \"Created\",\n  202: \"Accepted\",\n  203: \"Non-Authoritative Information\",\n  204: \"No Content\",\n  205: \"Reset Content\",\n  206: \"Partial Content\",\n  207: \"Multi-Status\",\n  208: \"Already Reported\",\n  226: \"IM Used\",\n  300: \"Multiple Choices\",\n  301: \"Moved Permanently\",\n  302: \"Found\",\n  303: \"See Other\",\n  304: \"Not Modified\",\n  305: \"Use Proxy\",\n  307: \"Temporary Redirect\",\n  308: \"Permanent Redirect\",\n  400: \"Bad Request\",\n  401: \"Unauthorized\",\n  402: \"Payment Required\",\n  403: \"Forbidden\",\n  404: \"Not Found\",\n  405: \"Method Not Allowed\",\n  406: \"Not Acceptable\",\n  407: \"Proxy Authentication Required\",\n  408: \"Request Timeout\",\n  409: \"Conflict\",\n  410: \"Gone\",\n  411: \"Length Required\",\n  412: \"Precondition Failed\",\n  413: \"Payload Too Large\",\n  414: \"URI Too Long\",\n  415: \"Unsupported Media Type\",\n  416: \"Range Not Satisfiable\",\n  417: \"Expectation Failed\",\n  418: \"I'm a Teapot\",\n  421: \"Misdirected Request\",\n  422: \"Unprocessable Entity\",\n  423: \"Locked\",\n  424: \"Failed Dependency\",\n  425: \"Too Early\",\n  426: \"Upgrade Required\",\n  428: \"Precondition Required\",\n  429: \"Too Many Requests\",\n  431: \"Request Header Fields Too Large\",\n  451: \"Unavailable For Legal Reasons\",\n  500: \"Internal Server Error\",\n  501: \"Not Implemented\",\n  502: \"Bad Gateway\",\n  503: \"Service Unavailable\",\n  504: \"Gateway Timeout\",\n  505: \"HTTP Version Not Supported\",\n  506: \"Variant Also Negotiates\",\n  507: \"Insufficient Storage\",\n  508: \"Loop Detected\",\n  509: \"Bandwidth Limit Exceeded\",\n  510: \"Not Extended\",\n  511: \"Network Authentication Required\"\n}, globalAgent = new Agent;\n$ = {\n  Agent,\n  Server,\n  METHODS,\n  STATUS_CODES,\n  createServer,\n  ServerResponse,\n  IncomingMessage,\n  request,\n  get,\n  maxHeaderSize: 16384,\n  validateHeaderName,\n  validateHeaderValue,\n  setMaxIdleHTTPParsers(max) {\n  },\n  globalAgent,\n  ClientRequest,\n  OutgoingMessage\n};\nreturn $})\n"_s;
//

//
static constexpr ASCIILiteral NodeHttp2Code = "(function (){\"use strict\";// src/js/out/tmp/node/http2.ts\nvar connect = function() {\n  throwNotImplemented(\"node:http2 connect\", 887);\n}, createServer = function() {\n  throwNotImplemented(\"node:http2 createServer\", 887);\n}, createSecureServer = function() {\n  throwNotImplemented(\"node:http2 createSecureServer\", 887);\n}, getDefaultSettings = function() {\n  return {\n    headerTableSize: 4096,\n    enablePush: !0,\n    initialWindowSize: 65535,\n    maxFrameSize: 16384,\n    maxConcurrentStreams: 4294967295,\n    maxHeaderSize: 65535,\n    maxHeaderListSize: 65535,\n    enableConnectProtocol: !1\n  };\n}, getPackedSettings = function() {\n  return Buffer.alloc(0);\n}, getUnpackedSettings = function() {\n  return Buffer.alloc(0);\n}, Http2ServerRequest = function() {\n  throwNotImplemented(\"node:http2 Http2ServerRequest\", 887);\n}, Http2ServerResponse = function() {\n  throwNotImplemented(\"node:http2 Http2ServerResponse\", 887);\n}, $, { hideFromStack, throwNotImplemented } = @getInternalField(@internalModuleRegistry, 3) || @createInternalModuleById(3), constants = {\n  NGHTTP2_ERR_FRAME_SIZE_ERROR: -522,\n  NGHTTP2_SESSION_SERVER: 0,\n  NGHTTP2_SESSION_CLIENT: 1,\n  NGHTTP2_STREAM_STATE_IDLE: 1,\n  NGHTTP2_STREAM_STATE_OPEN: 2,\n  NGHTTP2_STREAM_STATE_RESERVED_LOCAL: 3,\n  NGHTTP2_STREAM_STATE_RESERVED_REMOTE: 4,\n  NGHTTP2_STREAM_STATE_HALF_CLOSED_LOCAL: 5,\n  NGHTTP2_STREAM_STATE_HALF_CLOSED_REMOTE: 6,\n  NGHTTP2_STREAM_STATE_CLOSED: 7,\n  NGHTTP2_FLAG_NONE: 0,\n  NGHTTP2_FLAG_END_STREAM: 1,\n  NGHTTP2_FLAG_END_HEADERS: 4,\n  NGHTTP2_FLAG_ACK: 1,\n  NGHTTP2_FLAG_PADDED: 8,\n  NGHTTP2_FLAG_PRIORITY: 32,\n  DEFAULT_SETTINGS_HEADER_TABLE_SIZE: 4096,\n  DEFAULT_SETTINGS_ENABLE_PUSH: 1,\n  DEFAULT_SETTINGS_MAX_CONCURRENT_STREAMS: 4294967295,\n  DEFAULT_SETTINGS_INITIAL_WINDOW_SIZE: 65535,\n  DEFAULT_SETTINGS_MAX_FRAME_SIZE: 16384,\n  DEFAULT_SETTINGS_MAX_HEADER_LIST_SIZE: 65535,\n  DEFAULT_SETTINGS_ENABLE_CONNECT_PROTOCOL: 0,\n  MAX_MAX_FRAME_SIZE: 16777215,\n  MIN_MAX_FRAME_SIZE: 16384,\n  MAX_INITIAL_WINDOW_SIZE: 2147483647,\n  NGHTTP2_SETTINGS_HEADER_TABLE_SIZE: 1,\n  NGHTTP2_SETTINGS_ENABLE_PUSH: 2,\n  NGHTTP2_SETTINGS_MAX_CONCURRENT_STREAMS: 3,\n  NGHTTP2_SETTINGS_INITIAL_WINDOW_SIZE: 4,\n  NGHTTP2_SETTINGS_MAX_FRAME_SIZE: 5,\n  NGHTTP2_SETTINGS_MAX_HEADER_LIST_SIZE: 6,\n  NGHTTP2_SETTINGS_ENABLE_CONNECT_PROTOCOL: 8,\n  PADDING_STRATEGY_NONE: 0,\n  PADDING_STRATEGY_ALIGNED: 1,\n  PADDING_STRATEGY_MAX: 2,\n  PADDING_STRATEGY_CALLBACK: 1,\n  NGHTTP2_NO_ERROR: 0,\n  NGHTTP2_PROTOCOL_ERROR: 1,\n  NGHTTP2_INTERNAL_ERROR: 2,\n  NGHTTP2_FLOW_CONTROL_ERROR: 3,\n  NGHTTP2_SETTINGS_TIMEOUT: 4,\n  NGHTTP2_STREAM_CLOSED: 5,\n  NGHTTP2_FRAME_SIZE_ERROR: 6,\n  NGHTTP2_REFUSED_STREAM: 7,\n  NGHTTP2_CANCEL: 8,\n  NGHTTP2_COMPRESSION_ERROR: 9,\n  NGHTTP2_CONNECT_ERROR: 10,\n  NGHTTP2_ENHANCE_YOUR_CALM: 11,\n  NGHTTP2_INADEQUATE_SECURITY: 12,\n  NGHTTP2_HTTP_1_1_REQUIRED: 13,\n  NGHTTP2_DEFAULT_WEIGHT: 16,\n  HTTP2_HEADER_STATUS: \":status\",\n  HTTP2_HEADER_METHOD: \":method\",\n  HTTP2_HEADER_AUTHORITY: \":authority\",\n  HTTP2_HEADER_SCHEME: \":scheme\",\n  HTTP2_HEADER_PATH: \":path\",\n  HTTP2_HEADER_PROTOCOL: \":protocol\",\n  HTTP2_HEADER_ACCEPT_ENCODING: \"accept-encoding\",\n  HTTP2_HEADER_ACCEPT_LANGUAGE: \"accept-language\",\n  HTTP2_HEADER_ACCEPT_RANGES: \"accept-ranges\",\n  HTTP2_HEADER_ACCEPT: \"accept\",\n  HTTP2_HEADER_ACCESS_CONTROL_ALLOW_CREDENTIALS: \"access-control-allow-credentials\",\n  HTTP2_HEADER_ACCESS_CONTROL_ALLOW_HEADERS: \"access-control-allow-headers\",\n  HTTP2_HEADER_ACCESS_CONTROL_ALLOW_METHODS: \"access-control-allow-methods\",\n  HTTP2_HEADER_ACCESS_CONTROL_ALLOW_ORIGIN: \"access-control-allow-origin\",\n  HTTP2_HEADER_ACCESS_CONTROL_EXPOSE_HEADERS: \"access-control-expose-headers\",\n  HTTP2_HEADER_ACCESS_CONTROL_REQUEST_HEADERS: \"access-control-request-headers\",\n  HTTP2_HEADER_ACCESS_CONTROL_REQUEST_METHOD: \"access-control-request-method\",\n  HTTP2_HEADER_AGE: \"age\",\n  HTTP2_HEADER_AUTHORIZATION: \"authorization\",\n  HTTP2_HEADER_CACHE_CONTROL: \"cache-control\",\n  HTTP2_HEADER_CONNECTION: \"connection\",\n  HTTP2_HEADER_CONTENT_DISPOSITION: \"content-disposition\",\n  HTTP2_HEADER_CONTENT_ENCODING: \"content-encoding\",\n  HTTP2_HEADER_CONTENT_LENGTH: \"content-length\",\n  HTTP2_HEADER_CONTENT_TYPE: \"content-type\",\n  HTTP2_HEADER_COOKIE: \"cookie\",\n  HTTP2_HEADER_DATE: \"date\",\n  HTTP2_HEADER_ETAG: \"etag\",\n  HTTP2_HEADER_FORWARDED: \"forwarded\",\n  HTTP2_HEADER_HOST: \"host\",\n  HTTP2_HEADER_IF_MODIFIED_SINCE: \"if-modified-since\",\n  HTTP2_HEADER_IF_NONE_MATCH: \"if-none-match\",\n  HTTP2_HEADER_IF_RANGE: \"if-range\",\n  HTTP2_HEADER_LAST_MODIFIED: \"last-modified\",\n  HTTP2_HEADER_LINK: \"link\",\n  HTTP2_HEADER_LOCATION: \"location\",\n  HTTP2_HEADER_RANGE: \"range\",\n  HTTP2_HEADER_REFERER: \"referer\",\n  HTTP2_HEADER_SERVER: \"server\",\n  HTTP2_HEADER_SET_COOKIE: \"set-cookie\",\n  HTTP2_HEADER_STRICT_TRANSPORT_SECURITY: \"strict-transport-security\",\n  HTTP2_HEADER_TRANSFER_ENCODING: \"transfer-encoding\",\n  HTTP2_HEADER_TE: \"te\",\n  HTTP2_HEADER_UPGRADE_INSECURE_REQUESTS: \"upgrade-insecure-requests\",\n  HTTP2_HEADER_UPGRADE: \"upgrade\",\n  HTTP2_HEADER_USER_AGENT: \"user-agent\",\n  HTTP2_HEADER_VARY: \"vary\",\n  HTTP2_HEADER_X_CONTENT_TYPE_OPTIONS: \"x-content-type-options\",\n  HTTP2_HEADER_X_FRAME_OPTIONS: \"x-frame-options\",\n  HTTP2_HEADER_KEEP_ALIVE: \"keep-alive\",\n  HTTP2_HEADER_PROXY_CONNECTION: \"proxy-connection\",\n  HTTP2_HEADER_X_XSS_PROTECTION: \"x-xss-protection\",\n  HTTP2_HEADER_ALT_SVC: \"alt-svc\",\n  HTTP2_HEADER_CONTENT_SECURITY_POLICY: \"content-security-policy\",\n  HTTP2_HEADER_EARLY_DATA: \"early-data\",\n  HTTP2_HEADER_EXPECT_CT: \"expect-ct\",\n  HTTP2_HEADER_ORIGIN: \"origin\",\n  HTTP2_HEADER_PURPOSE: \"purpose\",\n  HTTP2_HEADER_TIMING_ALLOW_ORIGIN: \"timing-allow-origin\",\n  HTTP2_HEADER_X_FORWARDED_FOR: \"x-forwarded-for\",\n  HTTP2_HEADER_PRIORITY: \"priority\",\n  HTTP2_HEADER_ACCEPT_CHARSET: \"accept-charset\",\n  HTTP2_HEADER_ACCESS_CONTROL_MAX_AGE: \"access-control-max-age\",\n  HTTP2_HEADER_ALLOW: \"allow\",\n  HTTP2_HEADER_CONTENT_LANGUAGE: \"content-language\",\n  HTTP2_HEADER_CONTENT_LOCATION: \"content-location\",\n  HTTP2_HEADER_CONTENT_MD5: \"content-md5\",\n  HTTP2_HEADER_CONTENT_RANGE: \"content-range\",\n  HTTP2_HEADER_DNT: \"dnt\",\n  HTTP2_HEADER_EXPECT: \"expect\",\n  HTTP2_HEADER_EXPIRES: \"expires\",\n  HTTP2_HEADER_FROM: \"from\",\n  HTTP2_HEADER_IF_MATCH: \"if-match\",\n  HTTP2_HEADER_IF_UNMODIFIED_SINCE: \"if-unmodified-since\",\n  HTTP2_HEADER_MAX_FORWARDS: \"max-forwards\",\n  HTTP2_HEADER_PREFER: \"prefer\",\n  HTTP2_HEADER_PROXY_AUTHENTICATE: \"proxy-authenticate\",\n  HTTP2_HEADER_PROXY_AUTHORIZATION: \"proxy-authorization\",\n  HTTP2_HEADER_REFRESH: \"refresh\",\n  HTTP2_HEADER_RETRY_AFTER: \"retry-after\",\n  HTTP2_HEADER_TRAILER: \"trailer\",\n  HTTP2_HEADER_TK: \"tk\",\n  HTTP2_HEADER_VIA: \"via\",\n  HTTP2_HEADER_WARNING: \"warning\",\n  HTTP2_HEADER_WWW_AUTHENTICATE: \"www-authenticate\",\n  HTTP2_HEADER_HTTP2_SETTINGS: \"http2-settings\",\n  HTTP2_METHOD_ACL: \"ACL\",\n  HTTP2_METHOD_BASELINE_CONTROL: \"BASELINE-CONTROL\",\n  HTTP2_METHOD_BIND: \"BIND\",\n  HTTP2_METHOD_CHECKIN: \"CHECKIN\",\n  HTTP2_METHOD_CHECKOUT: \"CHECKOUT\",\n  HTTP2_METHOD_CONNECT: \"CONNECT\",\n  HTTP2_METHOD_COPY: \"COPY\",\n  HTTP2_METHOD_DELETE: \"DELETE\",\n  HTTP2_METHOD_GET: \"GET\",\n  HTTP2_METHOD_HEAD: \"HEAD\",\n  HTTP2_METHOD_LABEL: \"LABEL\",\n  HTTP2_METHOD_LINK: \"LINK\",\n  HTTP2_METHOD_LOCK: \"LOCK\",\n  HTTP2_METHOD_MERGE: \"MERGE\",\n  HTTP2_METHOD_MKACTIVITY: \"MKACTIVITY\",\n  HTTP2_METHOD_MKCALENDAR: \"MKCALENDAR\",\n  HTTP2_METHOD_MKCOL: \"MKCOL\",\n  HTTP2_METHOD_MKREDIRECTREF: \"MKREDIRECTREF\",\n  HTTP2_METHOD_MKWORKSPACE: \"MKWORKSPACE\",\n  HTTP2_METHOD_MOVE: \"MOVE\",\n  HTTP2_METHOD_OPTIONS: \"OPTIONS\",\n  HTTP2_METHOD_ORDERPATCH: \"ORDERPATCH\",\n  HTTP2_METHOD_PATCH: \"PATCH\",\n  HTTP2_METHOD_POST: \"POST\",\n  HTTP2_METHOD_PRI: \"PRI\",\n  HTTP2_METHOD_PROPFIND: \"PROPFIND\",\n  HTTP2_METHOD_PROPPATCH: \"PROPPATCH\",\n  HTTP2_METHOD_PUT: \"PUT\",\n  HTTP2_METHOD_REBIND: \"REBIND\",\n  HTTP2_METHOD_REPORT: \"REPORT\",\n  HTTP2_METHOD_SEARCH: \"SEARCH\",\n  HTTP2_METHOD_TRACE: \"TRACE\",\n  HTTP2_METHOD_UNBIND: \"UNBIND\",\n  HTTP2_METHOD_UNCHECKOUT: \"UNCHECKOUT\",\n  HTTP2_METHOD_UNLINK: \"UNLINK\",\n  HTTP2_METHOD_UNLOCK: \"UNLOCK\",\n  HTTP2_METHOD_UPDATE: \"UPDATE\",\n  HTTP2_METHOD_UPDATEREDIRECTREF: \"UPDATEREDIRECTREF\",\n  HTTP2_METHOD_VERSION_CONTROL: \"VERSION-CONTROL\",\n  HTTP_STATUS_CONTINUE: 100,\n  HTTP_STATUS_SWITCHING_PROTOCOLS: 101,\n  HTTP_STATUS_PROCESSING: 102,\n  HTTP_STATUS_EARLY_HINTS: 103,\n  HTTP_STATUS_OK: 200,\n  HTTP_STATUS_CREATED: 201,\n  HTTP_STATUS_ACCEPTED: 202,\n  HTTP_STATUS_NON_AUTHORITATIVE_INFORMATION: 203,\n  HTTP_STATUS_NO_CONTENT: 204,\n  HTTP_STATUS_RESET_CONTENT: 205,\n  HTTP_STATUS_PARTIAL_CONTENT: 206,\n  HTTP_STATUS_MULTI_STATUS: 207,\n  HTTP_STATUS_ALREADY_REPORTED: 208,\n  HTTP_STATUS_IM_USED: 226,\n  HTTP_STATUS_MULTIPLE_CHOICES: 300,\n  HTTP_STATUS_MOVED_PERMANENTLY: 301,\n  HTTP_STATUS_FOUND: 302,\n  HTTP_STATUS_SEE_OTHER: 303,\n  HTTP_STATUS_NOT_MODIFIED: 304,\n  HTTP_STATUS_USE_PROXY: 305,\n  HTTP_STATUS_TEMPORARY_REDIRECT: 307,\n  HTTP_STATUS_PERMANENT_REDIRECT: 308,\n  HTTP_STATUS_BAD_REQUEST: 400,\n  HTTP_STATUS_UNAUTHORIZED: 401,\n  HTTP_STATUS_PAYMENT_REQUIRED: 402,\n  HTTP_STATUS_FORBIDDEN: 403,\n  HTTP_STATUS_NOT_FOUND: 404,\n  HTTP_STATUS_METHOD_NOT_ALLOWED: 405,\n  HTTP_STATUS_NOT_ACCEPTABLE: 406,\n  HTTP_STATUS_PROXY_AUTHENTICATION_REQUIRED: 407,\n  HTTP_STATUS_REQUEST_TIMEOUT: 408,\n  HTTP_STATUS_CONFLICT: 409,\n  HTTP_STATUS_GONE: 410,\n  HTTP_STATUS_LENGTH_REQUIRED: 411,\n  HTTP_STATUS_PRECONDITION_FAILED: 412,\n  HTTP_STATUS_PAYLOAD_TOO_LARGE: 413,\n  HTTP_STATUS_URI_TOO_LONG: 414,\n  HTTP_STATUS_UNSUPPORTED_MEDIA_TYPE: 415,\n  HTTP_STATUS_RANGE_NOT_SATISFIABLE: 416,\n  HTTP_STATUS_EXPECTATION_FAILED: 417,\n  HTTP_STATUS_TEAPOT: 418,\n  HTTP_STATUS_MISDIRECTED_REQUEST: 421,\n  HTTP_STATUS_UNPROCESSABLE_ENTITY: 422,\n  HTTP_STATUS_LOCKED: 423,\n  HTTP_STATUS_FAILED_DEPENDENCY: 424,\n  HTTP_STATUS_TOO_EARLY: 425,\n  HTTP_STATUS_UPGRADE_REQUIRED: 426,\n  HTTP_STATUS_PRECONDITION_REQUIRED: 428,\n  HTTP_STATUS_TOO_MANY_REQUESTS: 429,\n  HTTP_STATUS_REQUEST_HEADER_FIELDS_TOO_LARGE: 431,\n  HTTP_STATUS_UNAVAILABLE_FOR_LEGAL_REASONS: 451,\n  HTTP_STATUS_INTERNAL_SERVER_ERROR: 500,\n  HTTP_STATUS_NOT_IMPLEMENTED: 501,\n  HTTP_STATUS_BAD_GATEWAY: 502,\n  HTTP_STATUS_SERVICE_UNAVAILABLE: 503,\n  HTTP_STATUS_GATEWAY_TIMEOUT: 504,\n  HTTP_STATUS_HTTP_VERSION_NOT_SUPPORTED: 505,\n  HTTP_STATUS_VARIANT_ALSO_NEGOTIATES: 506,\n  HTTP_STATUS_INSUFFICIENT_STORAGE: 507,\n  HTTP_STATUS_LOOP_DETECTED: 508,\n  HTTP_STATUS_BANDWIDTH_LIMIT_EXCEEDED: 509,\n  HTTP_STATUS_NOT_EXTENDED: 510,\n  HTTP_STATUS_NETWORK_AUTHENTICATION_REQUIRED: 511\n}, sensitiveHeaders = Symbol.for(\"nodejs.http2.sensitiveHeaders\");\n$ = {\n  constants,\n  createServer,\n  createSecureServer,\n  getDefaultSettings,\n  getPackedSettings,\n  getUnpackedSettings,\n  sensitiveHeaders,\n  Http2ServerRequest,\n  Http2ServerResponse,\n  connect\n};\nhideFromStack([\n  Http2ServerRequest,\n  Http2ServerResponse,\n  connect,\n  createServer,\n  createSecureServer,\n  getDefaultSettings,\n  getPackedSettings,\n  getUnpackedSettings\n]);\nreturn $})\n"_s;
//

//
static constexpr ASCIILiteral NodeHttpsCode = "(function (){\"use strict\";// src/js/out/tmp/node/https.ts\nvar request = function(input, options, cb) {\n  if (input && typeof input === \"object\" && !(input instanceof URL))\n    input.protocol \?\?= \"https:\";\n  else if (typeof options === \"object\")\n    options.protocol \?\?= \"https:\";\n  return http.request(input, options, cb);\n}, get = function(input, options, cb) {\n  const req = request(input, options, cb);\n  return req.end(), req;\n}, $, http = @getInternalField(@internalModuleRegistry, 19) || @createInternalModuleById(19);\n$ = {\n  ...http,\n  get,\n  request\n};\nreturn $})\n"_s;
//

//
static constexpr ASCIILiteral NodeInspectorCode = "(function (){\"use strict\";// src/js/out/tmp/node/inspector.ts\nvar open = function() {\n  throwNotImplemented(\"node:inspector open\", 2445);\n}, close = function() {\n  throwNotImplemented(\"node:inspector close\", 2445);\n}, url = function() {\n  throwNotImplemented(\"node:inspector url\", 2445);\n}, waitForDebugger = function() {\n  throwNotImplemented(\"node:inspector waitForDebugger\", 2445);\n}, $, { hideFromStack, throwNotImplemented } = @getInternalField(@internalModuleRegistry, 3) || @createInternalModuleById(3), EventEmitter = @getInternalField(@internalModuleRegistry, 16) || @createInternalModuleById(16);\n\nclass Session extends EventEmitter {\n  constructor() {\n    super();\n    throwNotImplemented(\"node:inspector Session\", 2445);\n  }\n}\nvar console = {\n  ...globalThis.console,\n  context: {\n    console: globalThis.console\n  }\n};\n$ = {\n  console,\n  open,\n  close,\n  url,\n  waitForDebugger,\n  Session\n};\nhideFromStack(open, close, url, waitForDebugger, Session.prototype.constructor);\nreturn $})\n"_s;
//

//
static constexpr ASCIILiteral NodeNetCode = "(function (){\"use strict\";// src/js/out/tmp/node/net.ts\nvar isIPv4 = function(s) {\n  return IPv4Reg.test(s);\n}, isIPv6 = function(s) {\n  return IPv6Reg.test(s);\n}, isIP = function(s) {\n  if (isIPv4(s))\n    return 4;\n  if (isIPv6(s))\n    return 6;\n  return 0;\n}, createConnection = function(port, host, connectListener) {\n  if (typeof port === \"object\")\n    return new Socket(port).connect(port, host, connectListener);\n  return new Socket().connect(port, host, connectListener);\n}, emitErrorNextTick = function(self, error) {\n  self.emit(\"error\", error);\n}, emitListeningNextTick = function(self, onListen) {\n  if (typeof onListen === \"function\")\n    try {\n      onListen();\n    } catch (err) {\n      self.emit(\"error\", err);\n    }\n  self.emit(\"listening\");\n}, createServer = function(options, connectionListener) {\n  return new Server(options, connectionListener);\n}, $, { Duplex } = @getInternalField(@internalModuleRegistry, 35) || @createInternalModuleById(35), EventEmitter = @getInternalField(@internalModuleRegistry, 16) || @createInternalModuleById(16);\nvar IPv4Reg = new RegExp(\"^((\?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])[.]){3}(\?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])$\");\nvar IPv6Reg = new RegExp(\"^((\?:(\?:[0-9a-fA-F]{1,4}):){7}(\?:(\?:[0-9a-fA-F]{1,4})|:)|(\?:(\?:[0-9a-fA-F]{1,4}):){6}(\?:((\?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])[.]){3}(\?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])|:(\?:[0-9a-fA-F]{1,4})|:)|(\?:(\?:[0-9a-fA-F]{1,4}):){5}(\?::((\?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])[.]){3}(\?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])|(:(\?:[0-9a-fA-F]{1,4})){1,2}|:)|(\?:(\?:[0-9a-fA-F]{1,4}):){4}(\?:(:(\?:[0-9a-fA-F]{1,4})){0,1}:((\?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])[.]){3}(\?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])|(:(\?:[0-9a-fA-F]{1,4})){1,3}|:)|(\?:(\?:[0-9a-fA-F]{1,4}):){3}(\?:(:(\?:[0-9a-fA-F]{1,4})){0,2}:((\?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])[.]){3}(\?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])|(:(\?:[0-9a-fA-F]{1,4})){1,4}|:)|(\?:(\?:[0-9a-fA-F]{1,4}):){2}(\?:(:(\?:[0-9a-fA-F]{1,4})){0,3}:((\?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])[.]){3}(\?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])|(:(\?:[0-9a-fA-F]{1,4})){1,5}|:)|(\?:(\?:[0-9a-fA-F]{1,4}):){1}(\?:(:(\?:[0-9a-fA-F]{1,4})){0,4}:((\?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])[.]){3}(\?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])|(:(\?:[0-9a-fA-F]{1,4})){1,6}|:)|(\?::((\?::(\?:[0-9a-fA-F]{1,4})){0,5}:((\?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])[.]){3}(\?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])|(\?::(\?:[0-9a-fA-F]{1,4})){1,7}|:)))(%[0-9a-zA-Z-.:]{1,})\?$\"), { connect: bunConnect } = Bun, { setTimeout } = globalThis, bunTlsSymbol = Symbol.for(\"::buntls::\"), bunSocketServerHandlers = Symbol.for(\"::bunsocket_serverhandlers::\"), bunSocketServerConnections = Symbol.for(\"::bunnetserverconnections::\"), bunSocketServerOptions = Symbol.for(\"::bunnetserveroptions::\"), bunSocketInternal = Symbol.for(\"::bunnetsocketinternal::\"), bunTLSConnectOptions = Symbol.for(\"::buntlsconnectoptions::\"), SocketClass, Socket = function(InternalSocket) {\n  return SocketClass = InternalSocket, Object.defineProperty(SocketClass.prototype, Symbol.toStringTag, {\n    value: \"Socket\",\n    enumerable: !1\n  }), Object.defineProperty(function Socket(options) {\n    return new InternalSocket(options);\n  }, Symbol.hasInstance, {\n    value(instance) {\n      return instance instanceof InternalSocket;\n    }\n  });\n}(class Socket2 extends Duplex {\n  static #Handlers = {\n    close: Socket2.#Close,\n    connectError(socket, error) {\n      socket.data.emit(\"error\", error);\n    },\n    data({ data: self }, buffer) {\n      self.bytesRead += buffer.length;\n      const queue = self.#readQueue;\n      if (queue.isEmpty()) {\n        if (self.push(buffer))\n          return;\n      }\n      queue.push(buffer);\n    },\n    drain: Socket2.#Drain,\n    end: Socket2.#Close,\n    error(socket, error) {\n      const self = socket.data, callback = self.#writeCallback;\n      if (callback)\n        self.#writeCallback = null, callback(error);\n      self.emit(\"error\", error);\n    },\n    open(socket) {\n      const self = socket.data;\n      socket.timeout(self.timeout), socket.ref(), self[bunSocketInternal] = socket, self.connecting = !1;\n      const options = self[bunTLSConnectOptions];\n      if (options) {\n        const { session } = options;\n        if (session)\n          self.setSession(session);\n      }\n      if (!self.#upgraded)\n        self.emit(\"connect\", self);\n      Socket2.#Drain(socket);\n    },\n    handshake(socket, success, verifyError) {\n      const { data: self } = socket;\n      self._securePending = !1, self.secureConnecting = !1, self._secureEstablished = !!success, self.emit(\"secure\", self);\n      const { checkServerIdentity } = self[bunTLSConnectOptions];\n      if (!verifyError && typeof checkServerIdentity === \"function\" && self.servername) {\n        const cert = self.getPeerCertificate(!0);\n        verifyError = checkServerIdentity(self.servername, cert);\n      }\n      if (self._requestCert || self._rejectUnauthorized) {\n        if (verifyError) {\n          if (self.authorized = !1, self.authorizationError = verifyError.code || verifyError.message, self._rejectUnauthorized) {\n            self.destroy(verifyError);\n            return;\n          }\n        }\n      } else\n        self.authorized = !0;\n      self.emit(\"secureConnect\", verifyError);\n    },\n    timeout(socket) {\n      const self = socket.data;\n      self.emit(\"timeout\", self);\n    },\n    binaryType: \"buffer\"\n  };\n  static #Close(socket) {\n    const self = socket.data;\n    if (self.#closed)\n      return;\n    self.#closed = !0, self[bunSocketInternal] = null;\n    const queue = self.#readQueue;\n    if (queue.isEmpty()) {\n      if (self.push(null))\n        return;\n    }\n    queue.push(null);\n  }\n  static #Drain(socket) {\n    const self = socket.data, callback = self.#writeCallback;\n    if (callback) {\n      const chunk = self.#writeChunk, written = socket.write(chunk);\n      if (self.bytesWritten += written, written < chunk.length)\n        self.#writeChunk = chunk.slice(written);\n      else\n        self.#writeCallback = null, self.#writeChunk = null, callback(null);\n    }\n  }\n  static [bunSocketServerHandlers] = {\n    data: Socket2.#Handlers.data,\n    close(socket) {\n      Socket2.#Handlers.close(socket), this.data[bunSocketServerConnections]--;\n    },\n    end(socket) {\n      Socket2.#Handlers.end(socket), this.data[bunSocketServerConnections]--;\n    },\n    open(socket) {\n      const self = this.data, options = self[bunSocketServerOptions], { pauseOnConnect, connectionListener, InternalSocketClass, requestCert, rejectUnauthorized } = options, _socket = new InternalSocketClass({});\n      if (_socket.isServer = !0, _socket._requestCert = requestCert, _socket._rejectUnauthorized = rejectUnauthorized, _socket.#attach(this.localPort, socket), self.maxConnections && self[bunSocketServerConnections] >= self.maxConnections) {\n        const data = {\n          localAddress: _socket.localAddress,\n          localPort: _socket.localPort,\n          localFamily: _socket.localFamily,\n          remoteAddress: _socket.remoteAddress,\n          remotePort: _socket.remotePort,\n          remoteFamily: _socket.remoteFamily || \"IPv4\"\n        };\n        socket.end(), self.emit(\"drop\", data);\n        return;\n      }\n      if (!pauseOnConnect)\n        _socket.resume();\n      if (self[bunSocketServerConnections]++, typeof connectionListener == \"function\")\n        if (InternalSocketClass.name === \"TLSSocket\")\n          self.once(\"secureConnection\", () => connectionListener(_socket));\n        else\n          connectionListener(_socket);\n      self.emit(\"connection\", _socket);\n    },\n    handshake(socket, success, verifyError) {\n      const { data: self } = socket;\n      if (self.emit(\"secure\", self), self._securePending = !1, self.secureConnecting = !1, self._secureEstablished = !!success, self._requestCert || self._rejectUnauthorized) {\n        if (verifyError) {\n          if (self.authorized = !1, self.authorizationError = verifyError.code || verifyError.message, self._rejectUnauthorized) {\n            self.destroy(verifyError);\n            return;\n          }\n        }\n      } else\n        self.authorized = !0;\n      self.emit(\"secureConnection\", verifyError);\n    },\n    error(socket, error) {\n      Socket2.#Handlers.error(socket, error), this.data.emit(\"error\", error);\n    },\n    timeout: Socket2.#Handlers.timeout,\n    connectError: Socket2.#Handlers.connectError,\n    drain: Socket2.#Handlers.drain,\n    binaryType: \"buffer\"\n  };\n  bytesRead = 0;\n  bytesWritten = 0;\n  #closed = !1;\n  connecting = !1;\n  localAddress = \"127.0.0.1\";\n  #readQueue = @createFIFO();\n  remotePort;\n  [bunSocketInternal] = null;\n  [bunTLSConnectOptions] = null;\n  timeout = 0;\n  #writeCallback;\n  #writeChunk;\n  #pendingRead;\n  isServer = !1;\n  _handle;\n  _parent;\n  _parentWrap;\n  #socket;\n  #upgraded;\n  constructor(options) {\n    const { socket, signal, write, read, allowHalfOpen = !1, ...opts } = options || {};\n    super({\n      ...opts,\n      allowHalfOpen,\n      readable: !0,\n      writable: !0\n    });\n    if (this._handle = this, this._parent = this, this._parentWrap = this, this.#pendingRead = void 0, this.#upgraded = !1, socket instanceof Socket2)\n      this.#socket = socket;\n    signal\?.once(\"abort\", () => this.destroy()), this.once(\"connect\", () => this.emit(\"ready\"));\n  }\n  address() {\n    return {\n      address: this.localAddress,\n      family: this.localFamily,\n      port: this.localPort\n    };\n  }\n  get bufferSize() {\n    return this.writableLength;\n  }\n  #attach(port, socket) {\n    if (this.remotePort = port, socket.data = this, socket.timeout(this.timeout), socket.ref(), this[bunSocketInternal] = socket, this.connecting = !1, !this.#upgraded)\n      this.emit(\"connect\", this);\n    Socket2.#Drain(socket);\n  }\n  connect(port, host, connectListener) {\n    var path, connection = this.#socket, _checkServerIdentity = void 0;\n    if (typeof port === \"string\") {\n      if (path = port, port = void 0, typeof host === \"function\")\n        connectListener = host, host = void 0;\n    } else if (typeof host == \"function\") {\n      if (typeof port === \"string\")\n        path = port, port = void 0;\n      connectListener = host, host = void 0;\n    }\n    if (typeof port == \"object\") {\n      var {\n        port,\n        host,\n        path,\n        socket,\n        localAddress,\n        localPort,\n        family,\n        hints,\n        lookup,\n        noDelay,\n        keepAlive,\n        keepAliveInitialDelay,\n        requestCert,\n        rejectUnauthorized,\n        pauseOnConnect,\n        servername,\n        checkServerIdentity,\n        session\n      } = port;\n      if (_checkServerIdentity = checkServerIdentity, this.servername = servername, socket)\n        connection = socket;\n    }\n    if (!pauseOnConnect)\n      this.resume();\n    this.connecting = !0, this.remotePort = port;\n    const bunTLS = this[bunTlsSymbol];\n    var tls = void 0;\n    if (typeof bunTLS === \"function\") {\n      if (tls = bunTLS.call(this, port, host, !0), this._requestCert = !0, this._rejectUnauthorized = rejectUnauthorized, tls) {\n        if (tls.rejectUnauthorized = rejectUnauthorized, tls.requestCert = !0, tls.session = session || tls.session, this.servername = tls.servername, tls.checkServerIdentity = _checkServerIdentity || tls.checkServerIdentity, this[bunTLSConnectOptions] = tls, !connection && tls.socket)\n          connection = tls.socket;\n      }\n      if (connection) {\n        if (typeof connection !== \"object\" || !(connection instanceof Socket2) || typeof connection[bunTlsSymbol] === \"function\")\n          @throwTypeError(\"socket must be an instance of net.Socket\");\n      }\n      if (this.authorized = !1, this.secureConnecting = !0, this._secureEstablished = !1, this._securePending = !0, connectListener)\n        this.on(\"secureConnect\", connectListener);\n    } else if (connectListener)\n      this.on(\"connect\", connectListener);\n    if (connection) {\n      const socket2 = connection[bunSocketInternal];\n      if (socket2) {\n        this.connecting = !0, this.#upgraded = !0;\n        const result = socket2.upgradeTLS({\n          data: this,\n          tls,\n          socket: Socket2.#Handlers\n        });\n        if (result) {\n          const [raw, tls2] = result;\n          connection[bunSocketInternal] = raw, raw.timeout(raw.timeout), raw.connecting = !1, this[bunSocketInternal] = tls2;\n        } else\n          throw this[bunSocketInternal] = null, new Error(\"Invalid socket\");\n      } else\n        connection.once(\"connect\", () => {\n          const socket3 = connection[bunSocketInternal];\n          if (!socket3)\n            return;\n          this.connecting = !0, this.#upgraded = !0;\n          const result = socket3.upgradeTLS({\n            data: this,\n            tls,\n            socket: Socket2.#Handlers\n          });\n          if (result) {\n            const [raw, tls2] = result;\n            connection[bunSocketInternal] = raw, raw.timeout(raw.timeout), raw.connecting = !1, this[bunSocketInternal] = tls2;\n          } else\n            throw this[bunSocketInternal] = null, new Error(\"Invalid socket\");\n        });\n    } else if (path)\n      bunConnect({\n        data: this,\n        unix: path,\n        socket: Socket2.#Handlers,\n        tls\n      }).catch((error) => {\n        this.emit(\"error\", error);\n      });\n    else\n      bunConnect({\n        data: this,\n        hostname: host || \"localhost\",\n        port,\n        socket: Socket2.#Handlers,\n        tls\n      }).catch((error) => {\n        this.emit(\"error\", error);\n      });\n    return this;\n  }\n  _destroy(err, callback) {\n    this[bunSocketInternal]\?.end(), callback(err);\n  }\n  _final(callback) {\n    this[bunSocketInternal]\?.end(), callback();\n  }\n  get localAddress() {\n    return \"127.0.0.1\";\n  }\n  get localFamily() {\n    return \"IPv4\";\n  }\n  get localPort() {\n    return this[bunSocketInternal]\?.localPort;\n  }\n  get pending() {\n    return this.connecting;\n  }\n  _read(size) {\n    const queue = this.#readQueue;\n    let chunk;\n    while (chunk = queue.peek()) {\n      if (!this.push(chunk))\n        return;\n      queue.shift();\n    }\n  }\n  get readyState() {\n    if (this.connecting)\n      return \"opening\";\n    if (this.readable)\n      return this.writable \? \"open\" : \"readOnly\";\n    else\n      return this.writable \? \"writeOnly\" : \"closed\";\n  }\n  ref() {\n    this[bunSocketInternal]\?.ref();\n  }\n  get remoteAddress() {\n    return this[bunSocketInternal]\?.remoteAddress;\n  }\n  get remoteFamily() {\n    return \"IPv4\";\n  }\n  resetAndDestroy() {\n    this[bunSocketInternal]\?.end();\n  }\n  setKeepAlive(enable = !1, initialDelay = 0) {\n    return this;\n  }\n  setNoDelay(noDelay = !0) {\n    return this;\n  }\n  setTimeout(timeout, callback) {\n    if (this[bunSocketInternal]\?.timeout(timeout), this.timeout = timeout, callback)\n      this.once(\"timeout\", callback);\n    return this;\n  }\n  unref() {\n    this[bunSocketInternal]\?.unref();\n  }\n  _write(chunk, encoding, callback) {\n    if (typeof chunk == \"string\" && encoding !== \"ascii\")\n      chunk = Buffer.from(chunk, encoding);\n    var written = this[bunSocketInternal]\?.write(chunk);\n    if (written == chunk.length)\n      callback();\n    else if (this.#writeCallback)\n      callback(new Error(\"overlapping _write()\"));\n    else {\n      if (written > 0)\n        if (typeof chunk == \"string\")\n          chunk = chunk.slice(written);\n        else\n          chunk = chunk.subarray(written);\n      this.#writeCallback = callback, this.#writeChunk = chunk;\n    }\n  }\n}), connect = createConnection;\n\nclass Server extends EventEmitter {\n  #server;\n  #listening = !1;\n  [bunSocketServerConnections] = 0;\n  [bunSocketServerOptions];\n  maxConnections = 0;\n  constructor(options, connectionListener) {\n    super();\n    if (typeof options === \"function\")\n      connectionListener = options, options = {};\n    else if (options == null || typeof options === \"object\")\n      options = { ...options };\n    else\n      throw new Error(\"bun-net-polyfill: invalid arguments\");\n    const { maxConnections } = options;\n    this.maxConnections = Number.isSafeInteger(maxConnections) && maxConnections > 0 \? maxConnections : 0, options.connectionListener = connectionListener, this[bunSocketServerOptions] = options;\n  }\n  ref() {\n    return this.#server\?.ref(), this;\n  }\n  unref() {\n    return this.#server\?.unref(), this;\n  }\n  close(callback) {\n    if (this.#server) {\n      if (this.#server.stop(!0), this.#server = null, this.#listening = !1, this[bunSocketServerConnections] = 0, this.emit(\"close\"), typeof callback === \"function\")\n        callback();\n      return this;\n    }\n    if (typeof callback === \"function\") {\n      const error = new Error(\"Server is not running\");\n      error.code = \"ERR_SERVER_NOT_RUNNING\", callback(error);\n    }\n    return this;\n  }\n  address() {\n    const server = this.#server;\n    if (server) {\n      const unix = server.unix;\n      if (unix)\n        return unix;\n      let address = server.hostname;\n      const type = isIP(address), port = server.port;\n      if (typeof port === \"number\")\n        return {\n          port,\n          address,\n          family: type \? `IPv${type}` : void 0\n        };\n      if (type)\n        return {\n          address,\n          family: type \? `IPv${type}` : void 0\n        };\n      return address;\n    }\n    return null;\n  }\n  getConnections(callback) {\n    if (typeof callback === \"function\")\n      callback(null, this.#server \? this[bunSocketServerConnections] : 0);\n    return this;\n  }\n  listen(port, hostname, onListen) {\n    let backlog, path, exclusive = !1;\n    if (typeof port === \"string\") {\n      if (Number.isSafeInteger(hostname)) {\n        if (hostname > 0)\n          backlog = hostname;\n      } else if (typeof hostname === \"function\")\n        onListen = hostname;\n      path = port, hostname = void 0, port = void 0;\n    } else {\n      if (typeof hostname === \"function\")\n        onListen = hostname, hostname = void 0;\n      if (typeof port === \"function\")\n        onListen = port, port = 0;\n      else if (typeof port === \"object\") {\n        const options = port;\n        options.signal\?.addEventListener(\"abort\", () => this.close()), hostname = options.host, exclusive = options.exclusive === !0;\n        const path2 = options.path;\n        if (port = options.port, !Number.isSafeInteger(port) || port < 0)\n          if (path2)\n            hostname = path2, port = void 0;\n          else {\n            let message = 'The argument \\'options\\' must have the property \"port\" or \"path\"';\n            try {\n              message = `${message}. Received ${JSON.stringify(options)}`;\n            } catch {\n            }\n            const error = @makeTypeError(message);\n            throw error.code = \"ERR_INVALID_ARG_VALUE\", error;\n          }\n        else if (!Number.isSafeInteger(port) || port < 0)\n          port = 0;\n        if (typeof port.callback === \"function\")\n          onListen = port\?.callback;\n      } else if (!Number.isSafeInteger(port) || port < 0)\n        port = 0;\n      hostname = hostname || \"::\";\n    }\n    try {\n      var tls = void 0, TLSSocketClass = void 0;\n      const bunTLS = this[bunTlsSymbol], options = this[bunSocketServerOptions];\n      if (typeof bunTLS === \"function\")\n        [tls, TLSSocketClass] = bunTLS.call(this, port, hostname, !1), options.servername = tls.serverName, options.InternalSocketClass = TLSSocketClass;\n      else\n        options.InternalSocketClass = SocketClass;\n      this.#server = Bun.listen(path \? {\n        exclusive,\n        unix: path,\n        tls,\n        socket: SocketClass[bunSocketServerHandlers]\n      } : {\n        exclusive,\n        port,\n        hostname,\n        tls,\n        socket: SocketClass[bunSocketServerHandlers]\n      }), this.#server.data = this, this.#listening = !0, setTimeout(emitListeningNextTick, 1, this, onListen);\n    } catch (err) {\n      this.#listening = !1, setTimeout(emitErrorNextTick, 1, this, err);\n    }\n    return this;\n  }\n}\n$ = {\n  createServer,\n  Server,\n  createConnection,\n  connect,\n  isIP,\n  isIPv4,\n  isIPv6,\n  Socket,\n  [Symbol.for(\"::bunternal::\")]: SocketClass\n};\nreturn $})\n"_s;
//

//
static constexpr ASCIILiteral NodeOSCode = "(function (){\"use strict\";// src/js/out/tmp/node/os.ts\nvar lazyCpus = function({ cpus }) {\n  return () => {\n    const array = new Array(navigator.hardwareConcurrency);\n    function populate() {\n      const results = cpus(), length = results.length;\n      array.length = length;\n      for (let i = 0;i < length; i++)\n        array[i] = results[i];\n    }\n    for (let i = 0;i < array.length; i++) {\n      const instance = {\n        get model() {\n          if (array[i] === instance)\n            populate();\n          return array[i].model;\n        },\n        set model(value) {\n          if (array[i] === instance)\n            populate();\n          array[i].model = value;\n        },\n        get speed() {\n          if (array[i] === instance)\n            populate();\n          return array[i].speed;\n        },\n        set speed(value) {\n          if (array[i] === instance)\n            populate();\n          array[i].speed = value;\n        },\n        get times() {\n          if (array[i] === instance)\n            populate();\n          return array[i].times;\n        },\n        set times(value) {\n          if (array[i] === instance)\n            populate();\n          array[i].times = value;\n        },\n        toJSON() {\n          if (array[i] === instance)\n            populate();\n          return array[i];\n        }\n      };\n      array[i] = instance;\n    }\n    return array;\n  };\n}, bound = function(obj) {\n  return {\n    arch: obj.arch.bind(obj),\n    cpus: lazyCpus(obj),\n    endianness: obj.endianness.bind(obj),\n    freemem: obj.freemem.bind(obj),\n    getPriority: obj.getPriority.bind(obj),\n    homedir: obj.homedir.bind(obj),\n    hostname: obj.hostname.bind(obj),\n    loadavg: obj.loadavg.bind(obj),\n    networkInterfaces: obj.networkInterfaces.bind(obj),\n    platform: obj.platform.bind(obj),\n    release: obj.release.bind(obj),\n    setPriority: obj.setPriority.bind(obj),\n    get tmpdir() {\n      return tmpdir;\n    },\n    totalmem: obj.totalmem.bind(obj),\n    type: obj.type.bind(obj),\n    uptime: obj.uptime.bind(obj),\n    userInfo: obj.userInfo.bind(obj),\n    version: obj.version.bind(obj),\n    machine: obj.machine.bind(obj),\n    devNull: obj.devNull,\n    EOL: obj.EOL,\n    constants: @processBindingConstants.os\n  };\n}, tmpdir = function() {\n  var env = Bun.env;\n  return tmpdir = function() {\n    var path = env.TMPDIR || env.TMP || env.TEMP || \"/tmp\";\n    const length = path.length;\n    if (length > 1 && path[length - 1] === \"/\")\n      path = path.slice(0, -1);\n    return path;\n  }, tmpdir();\n};\nreturn bound(Bun._Os())})\n"_s;
//

//
static constexpr ASCIILiteral NodePathPosixCode = "(function (){\"use strict\";// src/js/out/tmp/node/path.posix.ts\nreturn (@getInternalField(@internalModuleRegistry, 26) || @createInternalModuleById(26)).posix})\n"_s;
//

//
static constexpr ASCIILiteral NodePathCode = "(function (){\"use strict\";// src/js/out/tmp/node/path.ts\nvar bound = function(obj) {\n  const toNamespacedPath = obj.toNamespacedPath.bind(obj);\n  return {\n    resolve: obj.resolve.bind(obj),\n    normalize: obj.normalize.bind(obj),\n    isAbsolute: obj.isAbsolute.bind(obj),\n    join: obj.join.bind(obj),\n    relative: obj.relative.bind(obj),\n    toNamespacedPath,\n    dirname: obj.dirname.bind(obj),\n    basename: obj.basename.bind(obj),\n    extname: obj.extname.bind(obj),\n    format: obj.format.bind(obj),\n    parse: obj.parse.bind(obj),\n    sep: obj.sep,\n    delimiter: obj.delimiter,\n    win32: void 0,\n    posix: void 0,\n    _makeLong: toNamespacedPath\n  };\n}, posix = bound(Bun._Path(!1)), win32 = bound(Bun._Path(!0));\nposix.win32 = win32.win32 = win32;\nposix.posix = win32.posix = posix;\nreturn win32})\n"_s;
//

//
static constexpr ASCIILiteral NodePathWin32Code = "(function (){\"use strict\";// src/js/out/tmp/node/path.win32.ts\nreturn (@getInternalField(@internalModuleRegistry, 26) || @createInternalModuleById(26)).win32})\n"_s;
//

//
static constexpr ASCIILiteral NodePerfHooksCode = "(function (){\"use strict\";// src/js/out/tmp/node/perf_hooks.ts\nvar $, { throwNotImplemented } = @getInternalField(@internalModuleRegistry, 3) || @createInternalModuleById(3), constants = {\n  NODE_PERFORMANCE_GC_MAJOR: 4,\n  NODE_PERFORMANCE_GC_MINOR: 1,\n  NODE_PERFORMANCE_GC_INCREMENTAL: 8,\n  NODE_PERFORMANCE_GC_WEAKCB: 16,\n  NODE_PERFORMANCE_GC_FLAGS_NO: 0,\n  NODE_PERFORMANCE_GC_FLAGS_CONSTRUCT_RETAINED: 2,\n  NODE_PERFORMANCE_GC_FLAGS_FORCED: 4,\n  NODE_PERFORMANCE_GC_FLAGS_SYNCHRONOUS_PHANTOM_PROCESSING: 8,\n  NODE_PERFORMANCE_GC_FLAGS_ALL_AVAILABLE_GARBAGE: 16,\n  NODE_PERFORMANCE_GC_FLAGS_ALL_EXTERNAL_MEMORY: 32,\n  NODE_PERFORMANCE_GC_FLAGS_SCHEDULE_IDLE: 64\n}, performance = globalThis.performance;\n\nclass PerformanceObserver {\n  constructor() {\n    throwNotImplemented(\"PerformanceObserver\");\n  }\n}\n\nclass PerformanceEntry {\n  constructor() {\n    throwNotImplemented(\"PerformanceEntry\");\n  }\n}\n$ = {\n  performance,\n  constants,\n  PerformanceEntry,\n  PerformanceObserver\n};\nreturn $})\n"_s;
//

//
static constexpr ASCIILiteral NodePunycodeCode = "(function (){\"use strict\";// src/js/out/tmp/node/punycode.ts\nvar error = function(type) {\n  @throwRangeError(errors[type]);\n}, map = function(array, callback) {\n  const result = [];\n  let length = array.length;\n  while (length--)\n    result[length] = callback(array[length]);\n  return result;\n}, mapDomain = function(domain, callback) {\n  const parts = domain.split(\"@\");\n  let result = \"\";\n  if (parts.length > 1)\n    result = parts[0] + \"@\", domain = parts[1];\n  domain = domain.replace(regexSeparators, \".\");\n  const labels = domain.split(\".\"), encoded = map(labels, callback).join(\".\");\n  return result + encoded;\n}, ucs2decode = function(string) {\n  const output = [];\n  let counter = 0;\n  const length = string.length;\n  while (counter < length) {\n    const value = string.charCodeAt(counter++);\n    if (value >= 55296 && value <= 56319 && counter < length) {\n      const extra = string.charCodeAt(counter++);\n      if ((extra & 64512) == 56320)\n        output.push(((value & 1023) << 10) + (extra & 1023) + 65536);\n      else\n        output.push(value), counter--;\n    } else\n      output.push(value);\n  }\n  return output;\n}, $, maxInt = 2147483647, base = 36, tMin = 1, tMax = 26, skew = 38, damp = 700, initialBias = 72, initialN = 128, delimiter = \"-\", regexPunycode = /^xn--/, regexNonASCII = /[^\\0-\\x7F]/, regexSeparators = /[\\x2E\\u3002\\uFF0E\\uFF61]/g, errors = {\n  overflow: \"Overflow: input needs wider integers to process\",\n  \"not-basic\": \"Illegal input >= 0x80 (not a basic code point)\",\n  \"invalid-input\": \"Invalid input\"\n}, baseMinusTMin = base - tMin, floor = Math.floor, stringFromCharCode = String.fromCharCode, ucs2encode = (codePoints) => String.fromCodePoint(...codePoints), basicToDigit = function(codePoint) {\n  if (codePoint >= 48 && codePoint < 58)\n    return 26 + (codePoint - 48);\n  if (codePoint >= 65 && codePoint < 91)\n    return codePoint - 65;\n  if (codePoint >= 97 && codePoint < 123)\n    return codePoint - 97;\n  return base;\n}, digitToBasic = function(digit, flag) {\n  return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);\n}, adapt = function(delta, numPoints, firstTime) {\n  let k = 0;\n  delta = firstTime \? floor(delta / damp) : delta >> 1, delta += floor(delta / numPoints);\n  for (;delta > baseMinusTMin * tMax >> 1; k += base)\n    delta = floor(delta / baseMinusTMin);\n  return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));\n}, decode = function(input) {\n  const output = [], inputLength = input.length;\n  let i = 0, n = initialN, bias = initialBias, basic = input.lastIndexOf(delimiter);\n  if (basic < 0)\n    basic = 0;\n  for (let j = 0;j < basic; ++j) {\n    if (input.charCodeAt(j) >= 128)\n      error(\"not-basic\");\n    output.push(input.charCodeAt(j));\n  }\n  for (let index = basic > 0 \? basic + 1 : 0;index < inputLength; ) {\n    const oldi = i;\n    for (let w = 1, k = base;; k += base) {\n      if (index >= inputLength)\n        error(\"invalid-input\");\n      const digit = basicToDigit(input.charCodeAt(index++));\n      if (digit >= base)\n        error(\"invalid-input\");\n      if (digit > floor((maxInt - i) / w))\n        error(\"overflow\");\n      i += digit * w;\n      const t = k <= bias \? tMin : k >= bias + tMax \? tMax : k - bias;\n      if (digit < t)\n        break;\n      const baseMinusT = base - t;\n      if (w > floor(maxInt / baseMinusT))\n        error(\"overflow\");\n      w *= baseMinusT;\n    }\n    const out = output.length + 1;\n    if (bias = adapt(i - oldi, out, oldi == 0), floor(i / out) > maxInt - n)\n      error(\"overflow\");\n    n += floor(i / out), i %= out, output.splice(i++, 0, n);\n  }\n  return String.fromCodePoint(...output);\n}, encode = function(input) {\n  const output = [];\n  input = ucs2decode(input);\n  const inputLength = input.length;\n  let n = initialN, delta = 0, bias = initialBias;\n  for (let currentValue of input)\n    if (currentValue < 128)\n      output.push(stringFromCharCode(currentValue));\n  const basicLength = output.length;\n  let handledCPCount = basicLength;\n  if (basicLength)\n    output.push(delimiter);\n  while (handledCPCount < inputLength) {\n    let m = maxInt;\n    for (let currentValue of input)\n      if (currentValue >= n && currentValue < m)\n        m = currentValue;\n    const handledCPCountPlusOne = handledCPCount + 1;\n    if (m - n > floor((maxInt - delta) / handledCPCountPlusOne))\n      error(\"overflow\");\n    delta += (m - n) * handledCPCountPlusOne, n = m;\n    for (let currentValue of input) {\n      if (currentValue < n && ++delta > maxInt)\n        error(\"overflow\");\n      if (currentValue === n) {\n        let q = delta;\n        for (let k = base;; k += base) {\n          const t = k <= bias \? tMin : k >= bias + tMax \? tMax : k - bias;\n          if (q < t)\n            break;\n          const qMinusT = q - t, baseMinusT = base - t;\n          output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))), q = floor(qMinusT / baseMinusT);\n        }\n        output.push(stringFromCharCode(digitToBasic(q, 0))), bias = adapt(delta, handledCPCountPlusOne, handledCPCount === basicLength), delta = 0, ++handledCPCount;\n      }\n    }\n    ++delta, ++n;\n  }\n  return output.join(\"\");\n}, toUnicode = function(input) {\n  return mapDomain(input, function(string) {\n    return regexPunycode.test(string) \? decode(string.slice(4).toLowerCase()) : string;\n  });\n}, toASCII = function(input) {\n  return mapDomain(input, function(string) {\n    return regexNonASCII.test(string) \? \"xn--\" + encode(string) : string;\n  });\n};\n$ = {\n  version: \"2.1.0\",\n  ucs2: {\n    decode: ucs2decode,\n    encode: ucs2encode\n  },\n  decode,\n  encode,\n  toASCII,\n  toUnicode\n};\nreturn $})\n"_s;
//

//
static constexpr ASCIILiteral NodeQuerystringCode = "(function (){\"use strict\";// src/js/out/tmp/node/querystring.ts\nvar __commonJS = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports), Buffer = @requireNativeModule(\"node:buffer\").Buffer, require_object_keys = __commonJS((exports, module) => {\n  var objectKeys = Object.keys || function() {\n    var hasOwnProperty = Object.prototype.hasOwnProperty, hasDontEnumBug = !{ toString: null }.propertyIsEnumerable(\"toString\"), dontEnums = [\n      \"toString\",\n      \"toLocaleString\",\n      \"valueOf\",\n      \"hasOwnProperty\",\n      \"isPrototypeOf\",\n      \"propertyIsEnumerable\",\n      \"constructor\"\n    ], dontEnumsLength = dontEnums.length;\n    return function(obj) {\n      if (typeof obj !== \"function\" && (typeof obj !== \"object\" || obj === null))\n        @throwTypeError(\"Object.keys called on non-object\");\n      var result = [], prop, i;\n      for (prop in obj)\n        if (hasOwnProperty.call(obj, prop))\n          result.push(prop);\n      if (hasDontEnumBug) {\n        for (i = 0;i < dontEnumsLength; i++)\n          if (hasOwnProperty.call(obj, dontEnums[i]))\n            result.push(dontEnums[i]);\n      }\n      return result;\n    };\n  }();\n  module.exports = objectKeys;\n}), require_src = __commonJS((exports, module) => {\n  var ParsedQueryString = function() {\n  }, unescapeBuffer = function(s, decodeSpaces) {\n    var out = Buffer.allocUnsafe(s.length), state = 0, n, m, hexchar, c;\n    for (var inIndex = 0, outIndex = 0;; inIndex++) {\n      if (inIndex < s.length)\n        c = s.charCodeAt(inIndex);\n      else {\n        if (state > 0) {\n          if (out[outIndex++] = 37, state === 2)\n            out[outIndex++] = hexchar;\n        }\n        break;\n      }\n      switch (state) {\n        case 0:\n          switch (c) {\n            case 37:\n              n = 0, m = 0, state = 1;\n              break;\n            case 43:\n              if (decodeSpaces)\n                c = 32;\n            default:\n              out[outIndex++] = c;\n              break;\n          }\n          break;\n        case 1:\n          if (hexchar = c, n = unhexTable[c], !(n >= 0)) {\n            out[outIndex++] = 37, out[outIndex++] = c, state = 0;\n            break;\n          }\n          state = 2;\n          break;\n        case 2:\n          if (state = 0, m = unhexTable[c], !(m >= 0)) {\n            out[outIndex++] = 37, out[outIndex++] = hexchar, out[outIndex++] = c;\n            break;\n          }\n          out[outIndex++] = 16 * n + m;\n          break;\n      }\n    }\n    return out.slice(0, outIndex);\n  }, qsUnescape = function(s, decodeSpaces) {\n    try {\n      return decodeURIComponent(s);\n    } catch (e) {\n      return QueryString.unescapeBuffer(s, decodeSpaces).toString();\n    }\n  }, qsEscape = function(str) {\n    if (typeof str !== \"string\")\n      if (typeof str === \"object\")\n        str = String(str);\n      else\n        str += \"\";\n    var out = \"\", lastPos = 0;\n    for (var i2 = 0;i2 < str.length; ++i2) {\n      var c = str.charCodeAt(i2);\n      if (c < 128) {\n        if (noEscape[c] === 1)\n          continue;\n        if (lastPos < i2)\n          out += str.slice(lastPos, i2);\n        lastPos = i2 + 1, out += hexTable[c];\n        continue;\n      }\n      if (lastPos < i2)\n        out += str.slice(lastPos, i2);\n      if (c < 2048) {\n        lastPos = i2 + 1, out += hexTable[192 | c >> 6] + hexTable[128 | c & 63];\n        continue;\n      }\n      if (c < 55296 || c >= 57344) {\n        lastPos = i2 + 1, out += hexTable[224 | c >> 12] + hexTable[128 | c >> 6 & 63] + hexTable[128 | c & 63];\n        continue;\n      }\n      ++i2;\n      var c2;\n      if (i2 < str.length)\n        c2 = str.charCodeAt(i2) & 1023;\n      else\n        throw new URIError(\"URI malformed\");\n      lastPos = i2 + 1, c = 65536 + ((c & 1023) << 10 | c2), out += hexTable[240 | c >> 18] + hexTable[128 | c >> 12 & 63] + hexTable[128 | c >> 6 & 63] + hexTable[128 | c & 63];\n    }\n    if (lastPos === 0)\n      return str;\n    if (lastPos < str.length)\n      return out + str.slice(lastPos);\n    return out;\n  }, stringifyPrimitive = function(v) {\n    if (typeof v === \"string\")\n      return v;\n    if (typeof v === \"number\" && isFinite(v))\n      return \"\" + v;\n    if (typeof v === \"boolean\")\n      return v \? \"true\" : \"false\";\n    return \"\";\n  }, stringify = function(obj, sep, eq, options) {\n    sep = sep || \"&\", eq = eq || \"=\";\n    var encode = QueryString.escape;\n    if (options && typeof options.encodeURIComponent === \"function\")\n      encode = options.encodeURIComponent;\n    if (obj !== null && typeof obj === \"object\") {\n      var keys = objectKeys(obj), len = keys.length, flast = len - 1, fields = \"\";\n      for (var i2 = 0;i2 < len; ++i2) {\n        var k = keys[i2], v = obj[k], ks = encode(stringifyPrimitive(k)) + eq;\n        if (isArray(v)) {\n          var vlen = v.length, vlast = vlen - 1;\n          for (var j = 0;j < vlen; ++j)\n            if (fields += ks + encode(stringifyPrimitive(v[j])), j < vlast)\n              fields += sep;\n          if (vlen && i2 < flast)\n            fields += sep;\n        } else if (fields += ks + encode(stringifyPrimitive(v)), i2 < flast)\n          fields += sep;\n      }\n      return fields;\n    }\n    return \"\";\n  }, charCodes = function(str) {\n    if (str.length === 0)\n      return [];\n    if (str.length === 1)\n      return [str.charCodeAt(0)];\n    const ret = [];\n    for (var i2 = 0;i2 < str.length; ++i2)\n      ret[ret.length] = str.charCodeAt(i2);\n    return ret;\n  }, parse = function(qs, sep, eq, options) {\n    const obj = new ParsedQueryString;\n    if (typeof qs !== \"string\" || qs.length === 0)\n      return obj;\n    var sepCodes = !sep \? defSepCodes : charCodes(sep + \"\"), eqCodes = !eq \? defEqCodes : charCodes(eq + \"\");\n    const sepLen = sepCodes.length, eqLen = eqCodes.length;\n    var pairs = 1000;\n    if (options && typeof options.maxKeys === \"number\")\n      pairs = options.maxKeys > 0 \? options.maxKeys : -1;\n    var decode = QueryString.unescape;\n    if (options && typeof options.decodeURIComponent === \"function\")\n      decode = options.decodeURIComponent;\n    const customDecode = decode !== qsUnescape, keys = [];\n    var posIdx = 0, lastPos = 0, sepIdx = 0, eqIdx = 0, key = \"\", value = \"\", keyEncoded = customDecode, valEncoded = customDecode, encodeCheck = 0;\n    for (var i2 = 0;i2 < qs.length; ++i2) {\n      const code = qs.charCodeAt(i2);\n      if (code === sepCodes[sepIdx]) {\n        if (++sepIdx === sepLen) {\n          const end = i2 - sepIdx + 1;\n          if (eqIdx < eqLen) {\n            if (lastPos < end)\n              key += qs.slice(lastPos, end);\n          } else if (lastPos < end)\n            value += qs.slice(lastPos, end);\n          if (keyEncoded)\n            key = decodeStr(key, decode);\n          if (valEncoded)\n            value = decodeStr(value, decode);\n          if (key || value || lastPos - posIdx > sepLen || i2 === 0)\n            if (indexOf(keys, key) === -1)\n              obj[key] = value, keys[keys.length] = key;\n            else {\n              const curValue = obj[key] || \"\";\n              if (curValue.pop)\n                curValue[curValue.length] = value;\n              else if (curValue)\n                obj[key] = [curValue, value];\n            }\n          else if (i2 === 1)\n            delete obj[key];\n          if (--pairs === 0)\n            break;\n          keyEncoded = valEncoded = customDecode, encodeCheck = 0, key = value = \"\", posIdx = lastPos, lastPos = i2 + 1, sepIdx = eqIdx = 0;\n        }\n        continue;\n      } else if (sepIdx = 0, !valEncoded)\n        if (code === 37)\n          encodeCheck = 1;\n        else if (encodeCheck > 0 && (code >= 48 && code <= 57 || code >= 65 && code <= 70 || code >= 97 && code <= 102)) {\n          if (++encodeCheck === 3)\n            valEncoded = !0;\n        } else\n          encodeCheck = 0;\n      if (eqIdx < eqLen) {\n        if (code === eqCodes[eqIdx]) {\n          if (++eqIdx === eqLen) {\n            const end = i2 - eqIdx + 1;\n            if (lastPos < end)\n              key += qs.slice(lastPos, end);\n            encodeCheck = 0, lastPos = i2 + 1;\n          }\n          continue;\n        } else if (eqIdx = 0, !keyEncoded)\n          if (code === 37)\n            encodeCheck = 1;\n          else if (encodeCheck > 0 && (code >= 48 && code <= 57 || code >= 65 && code <= 70 || code >= 97 && code <= 102)) {\n            if (++encodeCheck === 3)\n              keyEncoded = !0;\n          } else\n            encodeCheck = 0;\n      }\n      if (code === 43) {\n        if (eqIdx < eqLen) {\n          if (lastPos < i2)\n            key += qs.slice(lastPos, i2);\n          key += \"%20\", keyEncoded = !0;\n        } else {\n          if (lastPos < i2)\n            value += qs.slice(lastPos, i2);\n          value += \"%20\", valEncoded = !0;\n        }\n        lastPos = i2 + 1;\n      }\n    }\n    if (pairs !== 0 && (lastPos < qs.length || eqIdx > 0)) {\n      if (lastPos < qs.length) {\n        if (eqIdx < eqLen)\n          key += qs.slice(lastPos);\n        else if (sepIdx < sepLen)\n          value += qs.slice(lastPos);\n      }\n      if (keyEncoded)\n        key = decodeStr(key, decode);\n      if (valEncoded)\n        value = decodeStr(value, decode);\n      if (indexOf(keys, key) === -1)\n        obj[key] = value, keys[keys.length] = key;\n      else {\n        const curValue = obj[key];\n        if (curValue.pop)\n          curValue[curValue.length] = value;\n        else\n          obj[key] = [curValue, value];\n      }\n    }\n    return obj;\n  }, decodeStr = function(s, decoder) {\n    try {\n      return decoder(s);\n    } catch (e) {\n      return QueryString.unescape(s, !0);\n    }\n  }, QueryString = module.exports = {\n    unescapeBuffer,\n    unescape: qsUnescape,\n    escape: qsEscape,\n    stringify,\n    encode: stringify,\n    parse,\n    decode: parse\n  }, objectKeys = require_object_keys(), isArray = (arg) => Object.prototype.toString.call(arg) === \"[object Array]\", indexOf = (arr, searchElement, fromIndex) => {\n    var k;\n    if (arr == null)\n      @throwTypeError('\"arr\" is null or not defined');\n    var o = Object(arr), len = o.length >>> 0;\n    if (len === 0)\n      return -1;\n    var n = fromIndex | 0;\n    if (n >= len)\n      return -1;\n    k = Math.max(n >= 0 \? n : len - Math.abs(n), 0);\n    while (k < len) {\n      if ((k in o) && o[k] === searchElement)\n        return k;\n      k++;\n    }\n    return -1;\n  };\n  ParsedQueryString.prototype = Object.create \? Object.create(null) : {};\n  var unhexTable = [\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    0,\n    1,\n    2,\n    3,\n    4,\n    5,\n    6,\n    7,\n    8,\n    9,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    10,\n    11,\n    12,\n    13,\n    14,\n    15,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    10,\n    11,\n    12,\n    13,\n    14,\n    15,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1\n  ], hexTable = [];\n  for (i = 0;i < 256; ++i)\n    hexTable[i] = \"%\" + ((i < 16 \? \"0\" : \"\") + i.toString(16)).toUpperCase();\n  var i, noEscape = [\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    1,\n    0,\n    0,\n    0,\n    0,\n    0,\n    1,\n    1,\n    1,\n    1,\n    0,\n    0,\n    1,\n    1,\n    0,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    0,\n    0,\n    0,\n    0,\n    1,\n    0,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    0,\n    0,\n    0,\n    1,\n    0\n  ], defSepCodes = [38], defEqCodes = [61];\n});\nreturn require_src()})\n"_s;
//

//
static constexpr ASCIILiteral NodeReadlineCode = "(function (){\"use strict\";// src/js/out/tmp/node/readline.ts\nvar stripVTControlCharacters = function(str) {\n  return validateString(str, \"str\"), RegExpPrototypeSymbolReplace.call(ansi, str, \"\");\n}, promisify = function(original) {\n  if (validateFunction(original, \"original\"), original[kCustomPromisifiedSymbol]) {\n    var fn = original[kCustomPromisifiedSymbol];\n    return validateFunction(fn, \"util.promisify.custom\"), ObjectDefineProperty(fn, kCustomPromisifiedSymbol, {\n      __proto__: null,\n      value: fn,\n      enumerable: !1,\n      writable: !1,\n      configurable: !0\n    });\n  }\n  var argumentNames = original[kCustomPromisifyArgsSymbol];\n  function fn(...args) {\n    return new Promise((resolve, reject) => {\n      ArrayPrototypePush.call(args, (err, ...values) => {\n        if (err)\n          return reject(err);\n        if (argumentNames !== void 0 && values.length > 1) {\n          var obj = {};\n          for (var i2 = 0;i2 < argumentNames.length; i2++)\n            obj[argumentNames[i2]] = values[i2];\n          resolve(obj);\n        } else\n          resolve(values[0]);\n      }), ReflectApply(original, this, args);\n    });\n  }\n  ObjectSetPrototypeOf(fn, ObjectGetPrototypeOf(original)), ObjectDefineProperty(fn, kCustomPromisifiedSymbol, {\n    __proto__: null,\n    value: fn,\n    enumerable: !1,\n    writable: !1,\n    configurable: !0\n  });\n  var descriptors = ObjectGetOwnPropertyDescriptors(original), propertiesValues = ObjectValues(descriptors);\n  for (var i = 0;i < propertiesValues.length; i++)\n    ObjectSetPrototypeOf(propertiesValues[i], null);\n  return ObjectDefineProperties(fn, descriptors);\n}, getNodeErrorByName = function(typeName) {\n  var base = errorBases[typeName];\n  if (base)\n    return base;\n  if (!ObjectKeys(VALID_NODE_ERROR_BASES).includes(typeName))\n    throw new Error(\"Invalid NodeError type\");\n  var Base = VALID_NODE_ERROR_BASES[typeName];\n\n  class NodeError extends Base {\n    [kIsNodeError] = !0;\n    code;\n    constructor(msg, opts) {\n      super(msg, opts);\n      this.code = opts\?.code || \"ERR_GENERIC\";\n    }\n    toString() {\n      return `${this.name} [${this.code}]: ${this.message}`;\n    }\n  }\n  return errorBases[typeName] = NodeError, NodeError;\n}, validateFunction = function(value, name) {\n  if (typeof value !== \"function\")\n    throw new ERR_INVALID_ARG_TYPE(name, \"Function\", value);\n}, validateAbortSignal = function(signal, name) {\n  if (signal !== void 0 && (signal === null || typeof signal !== \"object\" || !(\"aborted\" in signal)))\n    throw new ERR_INVALID_ARG_TYPE(name, \"AbortSignal\", signal);\n}, validateArray = function(value, name, minLength = 0) {\n  if (!ArrayIsArray(value))\n    throw new ERR_INVALID_ARG_TYPE(name, \"Array\", value);\n  if (value.length < minLength) {\n    var reason = `must be longer than ${minLength}`;\n    throw new ERR_INVALID_ARG_VALUE(name, value, reason);\n  }\n}, validateString = function(value, name) {\n  if (typeof value !== \"string\")\n    throw new ERR_INVALID_ARG_TYPE(name, \"string\", value);\n}, validateBoolean = function(value, name) {\n  if (typeof value !== \"boolean\")\n    throw new ERR_INVALID_ARG_TYPE(name, \"boolean\", value);\n};\nvar validateInteger = function(value, name, min = NumberMIN_SAFE_INTEGER, max = NumberMAX_SAFE_INTEGER) {\n  if (typeof value !== \"number\")\n    throw new ERR_INVALID_ARG_TYPE(name, \"number\", value);\n  if (!NumberIsInteger(value))\n    throw new ERR_OUT_OF_RANGE(name, \"an integer\", value);\n  if (value < min || value > max)\n    throw new ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value);\n}, validateUint32 = function(value, name, positive = !1) {\n  if (typeof value !== \"number\")\n    throw new ERR_INVALID_ARG_TYPE(name, \"number\", value);\n  if (!NumberIsInteger(value))\n    throw new ERR_OUT_OF_RANGE(name, \"an integer\", value);\n  var min = positive \? 1 : 0, max = 4294967295;\n  if (value < min || value > max)\n    throw new ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value);\n}, CSI = function(strings, ...args) {\n  var ret = `${kEscape}[`;\n  for (var n = 0;n < strings.length; n++)\n    if (ret += strings[n], n < args.length)\n      ret += args[n];\n  return ret;\n}, charLengthLeft = function(str, i) {\n  if (i <= 0)\n    return 0;\n  if (i > 1 && StringPrototypeCodePointAt.call(str, i - 2) >= kUTF16SurrogateThreshold || StringPrototypeCodePointAt.call(str, i - 1) >= kUTF16SurrogateThreshold)\n    return 2;\n  return 1;\n}, charLengthAt = function(str, i) {\n  if (str.length <= i)\n    return 1;\n  return StringPrototypeCodePointAt.call(str, i) >= kUTF16SurrogateThreshold \? 2 : 1;\n};\nfunction* emitKeys(stream) {\n  while (!0) {\n    var ch = yield, s = ch, escaped = !1, keySeq = null, keyName, keyCtrl2 = !1, keyMeta = !1, keyShift = !1;\n    if (ch === kEscape) {\n      if (escaped = !0, s += ch = yield, ch === kEscape)\n        s += ch = yield;\n    }\n    if (escaped && (ch === \"O\" || ch === \"[\")) {\n      var code = ch, modifier = 0;\n      if (ch === \"O\") {\n        if (s += ch = yield, ch >= \"0\" && ch <= \"9\")\n          modifier = (ch >> 0) - 1, s += ch = yield;\n        code += ch;\n      } else if (ch === \"[\") {\n        if (s += ch = yield, ch === \"[\")\n          code += ch, s += ch = yield;\n        var cmdStart = s.length - 1;\n        if (ch >= \"0\" && ch <= \"9\") {\n          if (s += ch = yield, ch >= \"0\" && ch <= \"9\")\n            s += ch = yield;\n        }\n        if (ch === \";\") {\n          if (s += ch = yield, ch >= \"0\" && ch <= \"9\")\n            s += yield;\n        }\n        var cmd = StringPrototypeSlice.call(s, cmdStart), match;\n        if (match = RegExpPrototypeExec.call(/^(\\d\\d\?)(;(\\d))\?([~^$])$/, cmd))\n          code += match[1] + match[4], modifier = (match[3] || 1) - 1;\n        else if (match = RegExpPrototypeExec.call(/^((\\d;)\?(\\d))\?([A-Za-z])$/, cmd))\n          code += match[4], modifier = (match[3] || 1) - 1;\n        else\n          code += cmd;\n      }\n      switch (keyCtrl2 = !!(modifier & 4), keyMeta = !!(modifier & 10), keyShift = !!(modifier & 1), code) {\n        case \"[P\":\n          keyName = \"f1\";\n          break;\n        case \"[Q\":\n          keyName = \"f2\";\n          break;\n        case \"[R\":\n          keyName = \"f3\";\n          break;\n        case \"[S\":\n          keyName = \"f4\";\n          break;\n        case \"OP\":\n          keyName = \"f1\";\n          break;\n        case \"OQ\":\n          keyName = \"f2\";\n          break;\n        case \"OR\":\n          keyName = \"f3\";\n          break;\n        case \"OS\":\n          keyName = \"f4\";\n          break;\n        case \"[11~\":\n          keyName = \"f1\";\n          break;\n        case \"[12~\":\n          keyName = \"f2\";\n          break;\n        case \"[13~\":\n          keyName = \"f3\";\n          break;\n        case \"[14~\":\n          keyName = \"f4\";\n          break;\n        case \"[[A\":\n          keyName = \"f1\";\n          break;\n        case \"[[B\":\n          keyName = \"f2\";\n          break;\n        case \"[[C\":\n          keyName = \"f3\";\n          break;\n        case \"[[D\":\n          keyName = \"f4\";\n          break;\n        case \"[[E\":\n          keyName = \"f5\";\n          break;\n        case \"[15~\":\n          keyName = \"f5\";\n          break;\n        case \"[17~\":\n          keyName = \"f6\";\n          break;\n        case \"[18~\":\n          keyName = \"f7\";\n          break;\n        case \"[19~\":\n          keyName = \"f8\";\n          break;\n        case \"[20~\":\n          keyName = \"f9\";\n          break;\n        case \"[21~\":\n          keyName = \"f10\";\n          break;\n        case \"[23~\":\n          keyName = \"f11\";\n          break;\n        case \"[24~\":\n          keyName = \"f12\";\n          break;\n        case \"[A\":\n          keyName = \"up\";\n          break;\n        case \"[B\":\n          keyName = \"down\";\n          break;\n        case \"[C\":\n          keyName = \"right\";\n          break;\n        case \"[D\":\n          keyName = \"left\";\n          break;\n        case \"[E\":\n          keyName = \"clear\";\n          break;\n        case \"[F\":\n          keyName = \"end\";\n          break;\n        case \"[H\":\n          keyName = \"home\";\n          break;\n        case \"OA\":\n          keyName = \"up\";\n          break;\n        case \"OB\":\n          keyName = \"down\";\n          break;\n        case \"OC\":\n          keyName = \"right\";\n          break;\n        case \"OD\":\n          keyName = \"left\";\n          break;\n        case \"OE\":\n          keyName = \"clear\";\n          break;\n        case \"OF\":\n          keyName = \"end\";\n          break;\n        case \"OH\":\n          keyName = \"home\";\n          break;\n        case \"[1~\":\n          keyName = \"home\";\n          break;\n        case \"[2~\":\n          keyName = \"insert\";\n          break;\n        case \"[3~\":\n          keyName = \"delete\";\n          break;\n        case \"[4~\":\n          keyName = \"end\";\n          break;\n        case \"[5~\":\n          keyName = \"pageup\";\n          break;\n        case \"[6~\":\n          keyName = \"pagedown\";\n          break;\n        case \"[[5~\":\n          keyName = \"pageup\";\n          break;\n        case \"[[6~\":\n          keyName = \"pagedown\";\n          break;\n        case \"[7~\":\n          keyName = \"home\";\n          break;\n        case \"[8~\":\n          keyName = \"end\";\n          break;\n        case \"[a\":\n          keyName = \"up\", keyShift = !0;\n          break;\n        case \"[b\":\n          keyName = \"down\", keyShift = !0;\n          break;\n        case \"[c\":\n          keyName = \"right\", keyShift = !0;\n          break;\n        case \"[d\":\n          keyName = \"left\", keyShift = !0;\n          break;\n        case \"[e\":\n          keyName = \"clear\", keyShift = !0;\n          break;\n        case \"[2$\":\n          keyName = \"insert\", keyShift = !0;\n          break;\n        case \"[3$\":\n          keyName = \"delete\", keyShift = !0;\n          break;\n        case \"[5$\":\n          keyName = \"pageup\", keyShift = !0;\n          break;\n        case \"[6$\":\n          keyName = \"pagedown\", keyShift = !0;\n          break;\n        case \"[7$\":\n          keyName = \"home\", keyShift = !0;\n          break;\n        case \"[8$\":\n          keyName = \"end\", keyShift = !0;\n          break;\n        case \"Oa\":\n          keyName = \"up\", keyCtrl2 = !0;\n          break;\n        case \"Ob\":\n          keyName = \"down\", keyCtrl2 = !0;\n          break;\n        case \"Oc\":\n          keyName = \"right\", keyCtrl2 = !0;\n          break;\n        case \"Od\":\n          keyName = \"left\", keyCtrl2 = !0;\n          break;\n        case \"Oe\":\n          keyName = \"clear\", keyCtrl2 = !0;\n          break;\n        case \"[2^\":\n          keyName = \"insert\", keyCtrl2 = !0;\n          break;\n        case \"[3^\":\n          keyName = \"delete\", keyCtrl2 = !0;\n          break;\n        case \"[5^\":\n          keyName = \"pageup\", keyCtrl2 = !0;\n          break;\n        case \"[6^\":\n          keyName = \"pagedown\", keyCtrl2 = !0;\n          break;\n        case \"[7^\":\n          keyName = \"home\", keyCtrl2 = !0;\n          break;\n        case \"[8^\":\n          keyName = \"end\", keyCtrl2 = !0;\n          break;\n        case \"[Z\":\n          keyName = \"tab\", keyShift = !0;\n          break;\n        default:\n          keyName = \"undefined\";\n          break;\n      }\n    } else if (ch === \"\\r\")\n      keyName = \"return\", keyMeta = escaped;\n    else if (ch === \"\\n\")\n      keyName = \"enter\", keyMeta = escaped;\n    else if (ch === \"\\t\")\n      keyName = \"tab\", keyMeta = escaped;\n    else if (ch === \"\\b\" || ch === \"\\x7F\")\n      keyName = \"backspace\", keyMeta = escaped;\n    else if (ch === kEscape)\n      keyName = \"escape\", keyMeta = escaped;\n    else if (ch === \" \")\n      keyName = \"space\", keyMeta = escaped;\n    else if (!escaped && ch <= \"\\x1A\")\n      keyName = StringFromCharCode(StringPrototypeCharCodeAt.call(ch) + StringPrototypeCharCodeAt.call(\"a\") - 1), keyCtrl2 = !0;\n    else if (RegExpPrototypeExec.call(/^[0-9A-Za-z]$/, ch) !== null)\n      keyName = StringPrototypeToLowerCase.call(ch), keyShift = RegExpPrototypeExec.call(/^[A-Z]$/, ch) !== null, keyMeta = escaped;\n    else if (escaped)\n      keyName = ch.length \? void 0 : \"escape\", keyMeta = !0;\n    if (keySeq = s, s.length !== 0 && (keyName !== void 0 || escaped))\n      stream.emit(\"keypress\", escaped \? void 0 : s, {\n        sequence: keySeq,\n        name: keyName,\n        ctrl: keyCtrl2,\n        meta: keyMeta,\n        shift: keyShift\n      });\n    else if (charLengthAt(s, 0) === s.length)\n      stream.emit(\"keypress\", s, {\n        sequence: keySeq,\n        name: keyName,\n        ctrl: keyCtrl2,\n        meta: keyMeta,\n        shift: keyShift\n      });\n  }\n}\nvar commonPrefix = function(strings) {\n  if (strings.length === 0)\n    return \"\";\n  if (strings.length === 1)\n    return strings[0];\n  var sorted = ArrayPrototypeSort.call(ArrayPrototypeSlice.call(strings)), min = sorted[0], max = sorted[sorted.length - 1];\n  for (var i = 0;i < min.length; i++)\n    if (min[i] !== max[i])\n      return StringPrototypeSlice.call(min, 0, i);\n  return min;\n}, cursorTo = function(stream, x, y, callback) {\n  if (callback !== void 0)\n    validateFunction(callback, \"callback\");\n  if (typeof y === \"function\")\n    callback = y, y = void 0;\n  if (NumberIsNaN(x))\n    throw new ERR_INVALID_ARG_VALUE(\"x\", x);\n  if (NumberIsNaN(y))\n    throw new ERR_INVALID_ARG_VALUE(\"y\", y);\n  if (stream == null || typeof x !== \"number\" && typeof y !== \"number\") {\n    if (typeof callback === \"function\")\n      process.nextTick(callback, null);\n    return !0;\n  }\n  if (typeof x !== \"number\")\n    throw new ERR_INVALID_CURSOR_POS;\n  var data = typeof y !== \"number\" \? CSI`${x + 1}G` : CSI`${y + 1};${x + 1}H`;\n  return stream.write(data, callback);\n}, moveCursor = function(stream, dx, dy, callback) {\n  if (callback !== void 0)\n    validateFunction(callback, \"callback\");\n  if (stream == null || !(dx || dy)) {\n    if (typeof callback === \"function\")\n      process.nextTick(callback, null);\n    return !0;\n  }\n  var data = \"\";\n  if (dx < 0)\n    data += CSI`${-dx}D`;\n  else if (dx > 0)\n    data += CSI`${dx}C`;\n  if (dy < 0)\n    data += CSI`${-dy}A`;\n  else if (dy > 0)\n    data += CSI`${dy}B`;\n  return stream.write(data, callback);\n}, clearLine = function(stream, dir, callback) {\n  if (callback !== void 0)\n    validateFunction(callback, \"callback\");\n  if (stream === null || stream === void 0) {\n    if (typeof callback === \"function\")\n      process.nextTick(callback, null);\n    return !0;\n  }\n  var type = dir < 0 \? kClearToLineBeginning : dir > 0 \? kClearToLineEnd : kClearLine;\n  return stream.write(type, callback);\n}, clearScreenDown = function(stream, callback) {\n  if (callback !== void 0)\n    validateFunction(callback, \"callback\");\n  if (stream === null || stream === void 0) {\n    if (typeof callback === \"function\")\n      process.nextTick(callback, null);\n    return !0;\n  }\n  return stream.write(kClearScreenDown, callback);\n}, emitKeypressEvents = function(stream, iface = {}) {\n  if (stream[KEYPRESS_DECODER])\n    return;\n  stream[KEYPRESS_DECODER] = new StringDecoder(\"utf8\"), stream[ESCAPE_DECODER] = emitKeys(stream), stream[ESCAPE_DECODER].next();\n  var triggerEscape = () => stream[ESCAPE_DECODER].next(\"\"), { escapeCodeTimeout = ESCAPE_CODE_TIMEOUT } = iface, timeoutId;\n  function onData(input) {\n    if (stream.listenerCount(\"keypress\") > 0) {\n      var string = stream[KEYPRESS_DECODER].write(input);\n      if (string) {\n        clearTimeout(timeoutId), iface[kSawKeyPress] = charLengthAt(string, 0) === string.length, iface.isCompletionEnabled = !1;\n        var length = 0;\n        for (var character of new SafeStringIterator(string)) {\n          if (length += character.length, length === string.length)\n            iface.isCompletionEnabled = !0;\n          try {\n            if (stream[ESCAPE_DECODER].next(character), length === string.length && character === kEscape)\n              timeoutId = setTimeout(triggerEscape, escapeCodeTimeout);\n          } catch (err) {\n            throw stream[ESCAPE_DECODER] = emitKeys(stream), stream[ESCAPE_DECODER].next(), err;\n          }\n        }\n      }\n    } else\n      stream.removeListener(\"data\", onData), stream.on(\"newListener\", onNewListener);\n  }\n  function onNewListener(event) {\n    if (event === \"keypress\")\n      stream.on(\"data\", onData), stream.removeListener(\"newListener\", onNewListener);\n  }\n  if (stream.listenerCount(\"keypress\") > 0)\n    stream.on(\"data\", onData);\n  else\n    stream.on(\"newListener\", onNewListener);\n}, onSelfCloseWithTerminal = function() {\n  var input = this.input, output = this.output;\n  if (!input)\n    throw new Error(\"Input not set, invalid state for readline!\");\n  if (input.removeListener(\"keypress\", this[kOnKeyPress]), input.removeListener(\"error\", this[kOnError]), input.removeListener(\"end\", this[kOnTermEnd]), output !== null && output !== void 0)\n    output.removeListener(\"resize\", this[kOnResize]);\n}, onSelfCloseWithoutTerminal = function() {\n  var input = this.input;\n  if (!input)\n    throw new Error(\"Input not set, invalid state for readline!\");\n  input.removeListener(\"data\", this[kOnData]), input.removeListener(\"error\", this[kOnError]), input.removeListener(\"end\", this[kOnEnd]);\n}, onError = function(err) {\n  this.emit(\"error\", err);\n}, onData = function(data) {\n  debug(\"onData\"), this[kNormalWrite](data);\n}, onEnd = function() {\n  if (debug(\"onEnd\"), typeof this[kLine_buffer] === \"string\" && this[kLine_buffer].length > 0)\n    this.emit(\"line\", this[kLine_buffer]);\n  this.close();\n}, onTermEnd = function() {\n  if (debug(\"onTermEnd\"), typeof this.line === \"string\" && this.line.length > 0)\n    this.emit(\"line\", this.line);\n  this.close();\n}, onKeyPress = function(s, key) {\n  if (this[kTtyWrite](s, key), key && key.sequence) {\n    var ch = StringPrototypeCodePointAt.call(key.sequence, 0);\n    if (ch >= 55296 && ch <= 57343)\n      this[kRefreshLine]();\n  }\n}, onResize = function() {\n  this[kRefreshLine]();\n}, InterfaceConstructor = function(input, output, completer, terminal) {\n  if (!(this instanceof InterfaceConstructor))\n    return new InterfaceConstructor(input, output, completer, terminal);\n  EventEmitter.call(this), this[kOnSelfCloseWithoutTerminal] = onSelfCloseWithoutTerminal.bind(this), this[kOnSelfCloseWithTerminal] = onSelfCloseWithTerminal.bind(this), this[kOnError] = onError.bind(this), this[kOnData] = onData.bind(this), this[kOnEnd] = onEnd.bind(this), this[kOnTermEnd] = onTermEnd.bind(this), this[kOnKeyPress] = onKeyPress.bind(this), this[kOnResize] = onResize.bind(this), this[kSawReturnAt] = 0, this.isCompletionEnabled = !0, this[kSawKeyPress] = !1, this[kPreviousKey] = null, this.escapeCodeTimeout = ESCAPE_CODE_TIMEOUT, this.tabSize = 8;\n  var history, historySize, removeHistoryDuplicates = !1, crlfDelay, prompt = \"> \", signal;\n  if (input\?.input) {\n    output = input.output, completer = input.completer, terminal = input.terminal, history = input.history, historySize = input.historySize, signal = input.signal;\n    var tabSize = input.tabSize;\n    if (tabSize !== void 0)\n      validateUint32(tabSize, \"tabSize\", !0), this.tabSize = tabSize;\n    removeHistoryDuplicates = input.removeHistoryDuplicates;\n    var inputPrompt = input.prompt;\n    if (inputPrompt !== void 0)\n      prompt = inputPrompt;\n    var inputEscapeCodeTimeout = input.escapeCodeTimeout;\n    if (inputEscapeCodeTimeout !== void 0)\n      if (NumberIsFinite(inputEscapeCodeTimeout))\n        this.escapeCodeTimeout = inputEscapeCodeTimeout;\n      else\n        throw new ERR_INVALID_ARG_VALUE(\"input.escapeCodeTimeout\", this.escapeCodeTimeout);\n    if (signal)\n      validateAbortSignal(signal, \"options.signal\");\n    crlfDelay = input.crlfDelay, input = input.input;\n  }\n  if (completer !== void 0 && typeof completer !== \"function\")\n    throw new ERR_INVALID_ARG_VALUE(\"completer\", completer);\n  if (history === void 0)\n    history = [];\n  else\n    validateArray(history, \"history\");\n  if (historySize === void 0)\n    historySize = kHistorySize;\n  if (typeof historySize !== \"number\" || NumberIsNaN(historySize) || historySize < 0)\n    throw new ERR_INVALID_ARG_VALUE(\"historySize\", historySize);\n  if (terminal === void 0 && !(output === null || output === void 0))\n    terminal = !!output.isTTY;\n  if (this.line = \"\", this[kSubstringSearch] = null, this.output = output, this.input = input, this[kUndoStack] = [], this[kRedoStack] = [], this.history = history, this.historySize = historySize, this[kKillRing] = [], this[kKillRingCursor] = 0, this.removeHistoryDuplicates = !!removeHistoryDuplicates, this.crlfDelay = crlfDelay \? MathMax(kMincrlfDelay, crlfDelay) : kMincrlfDelay, this.completer = completer, this.setPrompt(prompt), this.terminal = !!terminal, this[kLineObjectStream] = void 0, input.on(\"error\", this[kOnError]), !this.terminal)\n    input.on(\"data\", this[kOnData]), input.on(\"end\", this[kOnEnd]), this.once(\"close\", this[kOnSelfCloseWithoutTerminal]), this[kDecoder] = new StringDecoder(\"utf8\");\n  else {\n    if (emitKeypressEvents(input, this), input.on(\"keypress\", this[kOnKeyPress]), input.on(\"end\", this[kOnTermEnd]), this[kSetRawMode](!0), this.terminal = !0, this.cursor = 0, this.historyIndex = -1, output !== null && output !== void 0)\n      output.on(\"resize\", this[kOnResize]);\n    this.once(\"close\", this[kOnSelfCloseWithTerminal]);\n  }\n  if (signal) {\n    var onAborted = (() => this.close()).bind(this);\n    if (signal.aborted)\n      process.nextTick(onAborted);\n    else\n      signal.addEventListener(\"abort\", onAborted, { once: !0 }), this.once(\"close\", () => signal.removeEventListener(\"abort\", onAborted));\n  }\n  this.line = \"\", input.resume();\n}, Interface = function(input, output, completer, terminal) {\n  if (!(this instanceof Interface))\n    return new Interface(input, output, completer, terminal);\n  if (input\?.input && typeof input.completer === \"function\" && input.completer.length !== 2) {\n    var { completer } = input;\n    input.completer = (v, cb) => cb(null, completer(v));\n  } else if (typeof completer === \"function\" && completer.length !== 2) {\n    var realCompleter = completer;\n    completer = (v, cb) => cb(null, realCompleter(v));\n  }\n  InterfaceConstructor.call(this, input, output, completer, terminal);\n}, createInterface = function(input, output, completer, terminal) {\n  return new Interface(input, output, completer, terminal);\n};\nvar $, EventEmitter = @getInternalField(@internalModuleRegistry, 16) || @createInternalModuleById(16), { StringDecoder } = @requireNativeModule(\"node:string_decoder\"), isWritable, { inspect } = Bun, debug = process.env.BUN_JS_DEBUG \? console.log : () => {\n}, SymbolAsyncIterator = Symbol.asyncIterator, SymbolIterator = Symbol.iterator, SymbolFor = Symbol.for, SymbolReplace = Symbol.replace, ArrayFrom = Array.from, ArrayIsArray = Array.isArray, ArrayPrototypeFilter = Array.prototype.filter, ArrayPrototypeSort = Array.prototype.sort, ArrayPrototypeIndexOf = Array.prototype.indexOf, ArrayPrototypeJoin = Array.prototype.join, ArrayPrototypeMap = Array.prototype.map, ArrayPrototypePop = Array.prototype.pop, ArrayPrototypePush = Array.prototype.push, ArrayPrototypeSlice = Array.prototype.slice, ArrayPrototypeSplice = Array.prototype.splice, ArrayPrototypeReverse = Array.prototype.reverse, ArrayPrototypeShift = Array.prototype.shift, ArrayPrototypeUnshift = Array.prototype.unshift, RegExpPrototypeExec = RegExp.prototype.exec, RegExpPrototypeSymbolReplace = RegExp.prototype[SymbolReplace], StringFromCharCode = String.fromCharCode, StringPrototypeCharCodeAt = String.prototype.charCodeAt, StringPrototypeCodePointAt = String.prototype.codePointAt, StringPrototypeSlice = String.prototype.slice, StringPrototypeToLowerCase = String.prototype.toLowerCase, StringPrototypeEndsWith = String.prototype.endsWith, StringPrototypeRepeat = String.prototype.repeat, StringPrototypeStartsWith = String.prototype.startsWith, StringPrototypeTrim = String.prototype.trim, StringPrototypeNormalize = String.prototype.normalize, NumberIsNaN = Number.isNaN, NumberIsFinite = Number.isFinite, NumberIsInteger = Number.isInteger, NumberMAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER, NumberMIN_SAFE_INTEGER = Number.MIN_SAFE_INTEGER, MathCeil = Math.ceil, MathFloor = Math.floor, MathMax = Math.max, MathMaxApply = Math.max.apply, DateNow = Date.now, FunctionPrototype = Function.prototype, StringPrototype = String.prototype, StringPrototypeSymbolIterator = StringPrototype[SymbolIterator], StringIteratorPrototypeNext = StringPrototypeSymbolIterator.call(\"\").next, ObjectSetPrototypeOf = Object.setPrototypeOf, ObjectDefineProperty = Object.defineProperty, ObjectDefineProperties = Object.defineProperties, ObjectFreeze = Object.freeze;\nvar { create: ObjectCreate, keys: ObjectKeys } = Object;\nvar createSafeIterator = (factory, next) => {\n  class SafeIterator {\n    #iterator;\n    constructor(iterable) {\n      this.#iterator = factory.call(iterable);\n    }\n    next() {\n      return next.call(this.#iterator);\n    }\n    [SymbolIterator]() {\n      return this;\n    }\n  }\n  return ObjectSetPrototypeOf(SafeIterator.prototype, null), ObjectFreeze(SafeIterator.prototype), ObjectFreeze(SafeIterator), SafeIterator;\n}, SafeStringIterator = createSafeIterator(StringPrototypeSymbolIterator, StringIteratorPrototypeNext), isFullWidthCodePoint = (code) => {\n  return code >= 4352 && (code <= 4447 || code === 9001 || code === 9002 || code >= 11904 && code <= 12871 && code !== 12351 || code >= 12880 && code <= 19903 || code >= 19968 && code <= 42182 || code >= 43360 && code <= 43388 || code >= 44032 && code <= 55203 || code >= 63744 && code <= 64255 || code >= 65040 && code <= 65049 || code >= 65072 && code <= 65131 || code >= 65281 && code <= 65376 || code >= 65504 && code <= 65510 || code >= 110592 && code <= 110593 || code >= 127488 && code <= 127569 || code >= 127744 && code <= 128591 || code >= 131072 && code <= 262141);\n}, isZeroWidthCodePoint = (code) => {\n  return code <= 31 || code >= 127 && code <= 159 || code >= 768 && code <= 879 || code >= 8203 && code <= 8207 || code >= 8400 && code <= 8447 || code >= 65024 && code <= 65039 || code >= 65056 && code <= 65071 || code >= 917760 && code <= 917999;\n}, getStringWidth = function getStringWidth2(str, removeControlChars = !0) {\n  var width = 0;\n  if (removeControlChars)\n    str = stripVTControlCharacters(str);\n  str = StringPrototypeNormalize.call(str, \"NFC\");\n  for (var char of new SafeStringIterator(str)) {\n    var code = StringPrototypeCodePointAt.call(char, 0);\n    if (isFullWidthCodePoint(code))\n      width += 2;\n    else if (!isZeroWidthCodePoint(code))\n      width++;\n  }\n  return width;\n}, ansiPattern = \"[\\\\u001B\\\\u009B][[\\\\]()#;\?]*(\?:(\?:(\?:(\?:;[-a-zA-Z\\\\d\\\\/#&.:=\?%@~_]+)*|[a-zA-Z\\\\d]+(\?:;[-a-zA-Z\\\\d\\\\/#&.:=\?%@~_]*)*)\?\\\\u0007)|(\?:(\?:\\\\d{1,4}(\?:;\\\\d{0,4})*)\?[\\\\dA-PR-TZcf-ntqry=><~]))\", ansi = new RegExp(ansiPattern, \"g\"), kCustomPromisifiedSymbol = SymbolFor(\"nodejs.util.promisify.custom\"), kCustomPromisifyArgsSymbol = Symbol(\"customPromisifyArgs\");\npromisify.custom = kCustomPromisifiedSymbol;\nvar kUTF16SurrogateThreshold = 65536, kEscape = \"\\x1B\", kSubstringSearch = Symbol(\"kSubstringSearch\"), kIsNodeError = Symbol(\"kIsNodeError\"), errorBases = {}, VALID_NODE_ERROR_BASES = {\n  TypeError,\n  RangeError,\n  Error\n}, NodeError = getNodeErrorByName(\"Error\"), NodeTypeError = getNodeErrorByName(\"TypeError\"), NodeRangeError = getNodeErrorByName(\"RangeError\");\n\nclass ERR_INVALID_ARG_TYPE extends NodeTypeError {\n  constructor(name, type, value) {\n    super(`The \"${name}\" argument must be of type ${type}. Received type ${typeof value}`, {\n      code: \"ERR_INVALID_ARG_TYPE\"\n    });\n  }\n}\n\nclass ERR_INVALID_ARG_VALUE extends NodeTypeError {\n  constructor(name, value, reason = \"not specified\") {\n    super(`The value \"${String(value)}\" is invalid for argument '${name}'. Reason: ${reason}`, {\n      code: \"ERR_INVALID_ARG_VALUE\"\n    });\n  }\n}\n\nclass ERR_INVALID_CURSOR_POS extends NodeTypeError {\n  constructor() {\n    super(\"Cannot set cursor row without setting its column\", {\n      code: \"ERR_INVALID_CURSOR_POS\"\n    });\n  }\n}\n\nclass ERR_OUT_OF_RANGE extends NodeRangeError {\n  constructor(name, range, received) {\n    super(`The value of \"${name}\" is out of range. It must be ${range}. Received ${received}`, {\n      code: \"ERR_OUT_OF_RANGE\"\n    });\n  }\n}\n\nclass ERR_USE_AFTER_CLOSE extends NodeError {\n  constructor() {\n    super(\"This socket has been ended by the other party\", {\n      code: \"ERR_USE_AFTER_CLOSE\"\n    });\n  }\n}\n\nclass AbortError extends Error {\n  code;\n  constructor() {\n    super(\"The operation was aborted\");\n    this.code = \"ABORT_ERR\";\n  }\n}\nvar kClearLine, kClearScreenDown, kClearToLineBeginning, kClearToLineEnd;\nCSI.kEscape = kEscape;\nCSI.kClearLine = kClearLine = CSI`2K`;\nCSI.kClearScreenDown = kClearScreenDown = CSI`0J`;\nCSI.kClearToLineBeginning = kClearToLineBeginning = CSI`1K`;\nCSI.kClearToLineEnd = kClearToLineEnd = CSI`0K`;\nvar KEYPRESS_DECODER = Symbol(\"keypress-decoder\"), ESCAPE_DECODER = Symbol(\"escape-decoder\"), ESCAPE_CODE_TIMEOUT = 500, kEmptyObject = ObjectFreeze(ObjectCreate(null)), kHistorySize = 30, kMaxUndoRedoStackSize = 2048, kMincrlfDelay = 100, lineEnding = /\\r\?\\n|\\r(\?!\\n)/g, kMaxLengthOfKillRing = 32, kLineObjectStream = Symbol(\"line object stream\"), kQuestionCancel = Symbol(\"kQuestionCancel\"), kQuestion = Symbol(\"kQuestion\"), kAddHistory = Symbol(\"_addHistory\"), kBeforeEdit = Symbol(\"_beforeEdit\"), kDecoder = Symbol(\"_decoder\"), kDeleteLeft = Symbol(\"_deleteLeft\"), kDeleteLineLeft = Symbol(\"_deleteLineLeft\"), kDeleteLineRight = Symbol(\"_deleteLineRight\"), kDeleteRight = Symbol(\"_deleteRight\"), kDeleteWordLeft = Symbol(\"_deleteWordLeft\"), kDeleteWordRight = Symbol(\"_deleteWordRight\"), kGetDisplayPos = Symbol(\"_getDisplayPos\"), kHistoryNext = Symbol(\"_historyNext\"), kHistoryPrev = Symbol(\"_historyPrev\"), kInsertString = Symbol(\"_insertString\"), kLine = Symbol(\"_line\"), kLine_buffer = Symbol(\"_line_buffer\"), kKillRing = Symbol(\"_killRing\"), kKillRingCursor = Symbol(\"_killRingCursor\"), kMoveCursor = Symbol(\"_moveCursor\"), kNormalWrite = Symbol(\"_normalWrite\"), kOldPrompt = Symbol(\"_oldPrompt\"), kOnLine = Symbol(\"_onLine\"), kPreviousKey = Symbol(\"_previousKey\"), kPrompt = Symbol(\"_prompt\"), kPushToKillRing = Symbol(\"_pushToKillRing\"), kPushToUndoStack = Symbol(\"_pushToUndoStack\"), kQuestionCallback = Symbol(\"_questionCallback\"), kRedo = Symbol(\"_redo\"), kRedoStack = Symbol(\"_redoStack\"), kRefreshLine = Symbol(\"_refreshLine\"), kSawKeyPress = Symbol(\"_sawKeyPress\"), kSawReturnAt = Symbol(\"_sawReturnAt\"), kSetRawMode = Symbol(\"_setRawMode\"), kTabComplete = Symbol(\"_tabComplete\"), kTabCompleter = Symbol(\"_tabCompleter\"), kTtyWrite = Symbol(\"_ttyWrite\"), kUndo = Symbol(\"_undo\"), kUndoStack = Symbol(\"_undoStack\"), kWordLeft = Symbol(\"_wordLeft\"), kWordRight = Symbol(\"_wordRight\"), kWriteToOutput = Symbol(\"_writeToOutput\"), kYank = Symbol(\"_yank\"), kYanking = Symbol(\"_yanking\"), kYankPop = Symbol(\"_yankPop\"), kFirstEventParam = Symbol(\"nodejs.kFirstEventParam\"), kOnSelfCloseWithTerminal = Symbol(\"_onSelfCloseWithTerminal\"), kOnSelfCloseWithoutTerminal = Symbol(\"_onSelfCloseWithoutTerminal\"), kOnKeyPress = Symbol(\"_onKeyPress\"), kOnError = Symbol(\"_onError\"), kOnData = Symbol(\"_onData\"), kOnEnd = Symbol(\"_onEnd\"), kOnTermEnd = Symbol(\"_onTermEnd\"), kOnResize = Symbol(\"_onResize\");\nInterfaceConstructor.prototype = {};\nObjectSetPrototypeOf(InterfaceConstructor.prototype, EventEmitter.prototype);\nvar _Interface = class Interface2 extends InterfaceConstructor {\n  constructor(input, output, completer, terminal) {\n    super(input, output, completer, terminal);\n  }\n  get columns() {\n    var output = this.output;\n    if (output && output.columns)\n      return output.columns;\n    return Infinity;\n  }\n  setPrompt(prompt) {\n    this[kPrompt] = prompt;\n  }\n  getPrompt() {\n    return this[kPrompt];\n  }\n  [kSetRawMode](mode) {\n    var input = this.input, { setRawMode, wasInRawMode } = input;\n    return debug(\"setRawMode\", mode, \"set!\"), wasInRawMode;\n  }\n  prompt(preserveCursor) {\n    if (this.paused)\n      this.resume();\n    if (this.terminal) {\n      if (!preserveCursor)\n        this.cursor = 0;\n      this[kRefreshLine]();\n    } else\n      this[kWriteToOutput](this[kPrompt]);\n  }\n  [kQuestion](query, cb) {\n    if (this.closed)\n      throw new ERR_USE_AFTER_CLOSE(\"readline\");\n    if (this[kQuestionCallback])\n      this.prompt();\n    else\n      this[kOldPrompt] = this[kPrompt], this.setPrompt(query), this[kQuestionCallback] = cb, this.prompt();\n  }\n  [kOnLine](line) {\n    if (this[kQuestionCallback]) {\n      var cb = this[kQuestionCallback];\n      this[kQuestionCallback] = null, this.setPrompt(this[kOldPrompt]), cb(line);\n    } else\n      this.emit(\"line\", line);\n  }\n  [kBeforeEdit](oldText, oldCursor) {\n    this[kPushToUndoStack](oldText, oldCursor);\n  }\n  [kQuestionCancel]() {\n    if (this[kQuestionCallback])\n      this[kQuestionCallback] = null, this.setPrompt(this[kOldPrompt]), this.clearLine();\n  }\n  [kWriteToOutput](stringToWrite) {\n    if (validateString(stringToWrite, \"stringToWrite\"), this.output !== null && this.output !== void 0)\n      this.output.write(stringToWrite);\n  }\n  [kAddHistory]() {\n    if (this.line.length === 0)\n      return \"\";\n    if (this.historySize === 0)\n      return this.line;\n    if (StringPrototypeTrim.call(this.line).length === 0)\n      return this.line;\n    if (this.history.length === 0 || this.history[0] !== this.line) {\n      if (this.removeHistoryDuplicates) {\n        var dupIndex = ArrayPrototypeIndexOf.call(this.history, this.line);\n        if (dupIndex !== -1)\n          ArrayPrototypeSplice.call(this.history, dupIndex, 1);\n      }\n      if (ArrayPrototypeUnshift.call(this.history, this.line), this.history.length > this.historySize)\n        ArrayPrototypePop.call(this.history);\n    }\n    this.historyIndex = -1;\n    var line = this.history[0];\n    return this.emit(\"history\", this.history), line;\n  }\n  [kRefreshLine]() {\n    var line = this[kPrompt] + this.line, dispPos = this[kGetDisplayPos](line), lineCols = dispPos.cols, lineRows = dispPos.rows, cursorPos = this.getCursorPos(), prevRows = this.prevRows || 0;\n    if (prevRows > 0)\n      moveCursor(this.output, 0, -prevRows);\n    if (cursorTo(this.output, 0), clearScreenDown(this.output), this[kWriteToOutput](line), lineCols === 0)\n      this[kWriteToOutput](\" \");\n    cursorTo(this.output, cursorPos.cols);\n    var diff = lineRows - cursorPos.rows;\n    if (diff > 0)\n      moveCursor(this.output, 0, -diff);\n    this.prevRows = cursorPos.rows;\n  }\n  close() {\n    if (this.closed)\n      return;\n    if (this.pause(), this.terminal)\n      this[kSetRawMode](!1);\n    this.closed = !0, this.emit(\"close\");\n  }\n  pause() {\n    if (this.paused)\n      return;\n    return this.input.pause(), this.paused = !0, this.emit(\"pause\"), this;\n  }\n  resume() {\n    if (!this.paused)\n      return;\n    return this.input.resume(), this.paused = !1, this.emit(\"resume\"), this;\n  }\n  write(d, key) {\n    if (this.paused)\n      this.resume();\n    if (this.terminal)\n      this[kTtyWrite](d, key);\n    else\n      this[kNormalWrite](d);\n  }\n  [kNormalWrite](b) {\n    if (b === void 0)\n      return;\n    var string = this[kDecoder].write(b);\n    if (this[kSawReturnAt] && DateNow() - this[kSawReturnAt] <= this.crlfDelay) {\n      if (StringPrototypeCodePointAt.call(string) === 10)\n        string = StringPrototypeSlice.call(string, 1);\n      this[kSawReturnAt] = 0;\n    }\n    var newPartContainsEnding = RegExpPrototypeExec.call(lineEnding, string);\n    if (newPartContainsEnding !== null) {\n      if (this[kLine_buffer])\n        string = this[kLine_buffer] + string, this[kLine_buffer] = null, newPartContainsEnding = RegExpPrototypeExec.call(lineEnding, string);\n      this[kSawReturnAt] = StringPrototypeEndsWith.call(string, \"\\r\") \? DateNow() : 0;\n      var indexes = [0, newPartContainsEnding.index, lineEnding.lastIndex], nextMatch;\n      while ((nextMatch = RegExpPrototypeExec.call(lineEnding, string)) !== null)\n        ArrayPrototypePush.call(indexes, nextMatch.index, lineEnding.lastIndex);\n      var lastIndex = indexes.length - 1;\n      this[kLine_buffer] = StringPrototypeSlice.call(string, indexes[lastIndex]);\n      for (var i = 1;i < lastIndex; i += 2)\n        this[kOnLine](StringPrototypeSlice.call(string, indexes[i - 1], indexes[i]));\n    } else if (string)\n      if (this[kLine_buffer])\n        this[kLine_buffer] += string;\n      else\n        this[kLine_buffer] = string;\n  }\n  [kInsertString](c) {\n    if (this[kBeforeEdit](this.line, this.cursor), this.cursor < this.line.length) {\n      var beg = StringPrototypeSlice.call(this.line, 0, this.cursor), end = StringPrototypeSlice.call(this.line, this.cursor, this.line.length);\n      this.line = beg + c + end, this.cursor += c.length, this[kRefreshLine]();\n    } else {\n      var oldPos = this.getCursorPos();\n      this.line += c, this.cursor += c.length;\n      var newPos = this.getCursorPos();\n      if (oldPos.rows < newPos.rows)\n        this[kRefreshLine]();\n      else\n        this[kWriteToOutput](c);\n    }\n  }\n  async[kTabComplete](lastKeypressWasTab) {\n    this.pause();\n    var string = StringPrototypeSlice.call(this.line, 0, this.cursor), value;\n    try {\n      value = await this.completer(string);\n    } catch (err) {\n      this[kWriteToOutput](`Tab completion error: ${inspect(err)}`);\n      return;\n    } finally {\n      this.resume();\n    }\n    this[kTabCompleter](lastKeypressWasTab, value);\n  }\n  [kTabCompleter](lastKeypressWasTab, { 0: completions, 1: completeOn }) {\n    if (!completions || completions.length === 0)\n      return;\n    var prefix = commonPrefix(ArrayPrototypeFilter.call(completions, (e) => e !== \"\"));\n    if (StringPrototypeStartsWith.call(prefix, completeOn) && prefix.length > completeOn.length) {\n      this[kInsertString](StringPrototypeSlice.call(prefix, completeOn.length));\n      return;\n    } else if (!StringPrototypeStartsWith.call(completeOn, prefix)) {\n      this.line = StringPrototypeSlice.call(this.line, 0, this.cursor - completeOn.length) + prefix + StringPrototypeSlice.call(this.line, this.cursor, this.line.length), this.cursor = this.cursor - completeOn.length + prefix.length, this._refreshLine();\n      return;\n    }\n    if (!lastKeypressWasTab)\n      return;\n    this[kBeforeEdit](this.line, this.cursor);\n    var completionsWidth = ArrayPrototypeMap.call(completions, (e) => getStringWidth(e)), width = MathMaxApply(completionsWidth) + 2, maxColumns = MathFloor(this.columns / width) || 1;\n    if (maxColumns === Infinity)\n      maxColumns = 1;\n    var output = \"\\r\\n\", lineIndex = 0, whitespace = 0;\n    for (var i = 0;i < completions.length; i++) {\n      var completion = completions[i];\n      if (completion === \"\" || lineIndex === maxColumns)\n        output += \"\\r\\n\", lineIndex = 0, whitespace = 0;\n      else\n        output += StringPrototypeRepeat.call(\" \", whitespace);\n      if (completion !== \"\")\n        output += completion, whitespace = width - completionsWidth[i], lineIndex++;\n      else\n        output += \"\\r\\n\";\n    }\n    if (lineIndex !== 0)\n      output += \"\\r\\n\\r\\n\";\n    this[kWriteToOutput](output), this[kRefreshLine]();\n  }\n  [kWordLeft]() {\n    if (this.cursor > 0) {\n      var leading = StringPrototypeSlice.call(this.line, 0, this.cursor), reversed = ArrayPrototypeJoin.call(ArrayPrototypeReverse.call(ArrayFrom(leading)), \"\"), match = RegExpPrototypeExec.call(/^\\s*(\?:[^\\w\\s]+|\\w+)\?/, reversed);\n      this[kMoveCursor](-match[0].length);\n    }\n  }\n  [kWordRight]() {\n    if (this.cursor < this.line.length) {\n      var trailing = StringPrototypeSlice.call(this.line, this.cursor), match = RegExpPrototypeExec.call(/^(\?:\\s+|[^\\w\\s]+|\\w+)\\s*/, trailing);\n      this[kMoveCursor](match[0].length);\n    }\n  }\n  [kDeleteLeft]() {\n    if (this.cursor > 0 && this.line.length > 0) {\n      this[kBeforeEdit](this.line, this.cursor);\n      var charSize = charLengthLeft(this.line, this.cursor);\n      this.line = StringPrototypeSlice.call(this.line, 0, this.cursor - charSize) + StringPrototypeSlice.call(this.line, this.cursor, this.line.length), this.cursor -= charSize, this[kRefreshLine]();\n    }\n  }\n  [kDeleteRight]() {\n    if (this.cursor < this.line.length) {\n      this[kBeforeEdit](this.line, this.cursor);\n      var charSize = charLengthAt(this.line, this.cursor);\n      this.line = StringPrototypeSlice.call(this.line, 0, this.cursor) + StringPrototypeSlice.call(this.line, this.cursor + charSize, this.line.length), this[kRefreshLine]();\n    }\n  }\n  [kDeleteWordLeft]() {\n    if (this.cursor > 0) {\n      this[kBeforeEdit](this.line, this.cursor);\n      var leading = StringPrototypeSlice.call(this.line, 0, this.cursor), reversed = ArrayPrototypeJoin.call(ArrayPrototypeReverse.call(ArrayFrom(leading)), \"\"), match = RegExpPrototypeExec.call(/^\\s*(\?:[^\\w\\s]+|\\w+)\?/, reversed);\n      leading = StringPrototypeSlice.call(leading, 0, leading.length - match[0].length), this.line = leading + StringPrototypeSlice.call(this.line, this.cursor, this.line.length), this.cursor = leading.length, this[kRefreshLine]();\n    }\n  }\n  [kDeleteWordRight]() {\n    if (this.cursor < this.line.length) {\n      this[kBeforeEdit](this.line, this.cursor);\n      var trailing = StringPrototypeSlice.call(this.line, this.cursor), match = RegExpPrototypeExec.call(/^(\?:\\s+|\\W+|\\w+)\\s*/, trailing);\n      this.line = StringPrototypeSlice.call(this.line, 0, this.cursor) + StringPrototypeSlice.call(trailing, match[0].length), this[kRefreshLine]();\n    }\n  }\n  [kDeleteLineLeft]() {\n    this[kBeforeEdit](this.line, this.cursor);\n    var del = StringPrototypeSlice.call(this.line, 0, this.cursor);\n    this.line = StringPrototypeSlice.call(this.line, this.cursor), this.cursor = 0, this[kPushToKillRing](del), this[kRefreshLine]();\n  }\n  [kDeleteLineRight]() {\n    this[kBeforeEdit](this.line, this.cursor);\n    var del = StringPrototypeSlice.call(this.line, this.cursor);\n    this.line = StringPrototypeSlice.call(this.line, 0, this.cursor), this[kPushToKillRing](del), this[kRefreshLine]();\n  }\n  [kPushToKillRing](del) {\n    if (!del || del === this[kKillRing][0])\n      return;\n    ArrayPrototypeUnshift.call(this[kKillRing], del), this[kKillRingCursor] = 0;\n    while (this[kKillRing].length > kMaxLengthOfKillRing)\n      ArrayPrototypePop.call(this[kKillRing]);\n  }\n  [kYank]() {\n    if (this[kKillRing].length > 0)\n      this[kYanking] = !0, this[kInsertString](this[kKillRing][this[kKillRingCursor]]);\n  }\n  [kYankPop]() {\n    if (!this[kYanking])\n      return;\n    if (this[kKillRing].length > 1) {\n      var lastYank = this[kKillRing][this[kKillRingCursor]];\n      if (this[kKillRingCursor]++, this[kKillRingCursor] >= this[kKillRing].length)\n        this[kKillRingCursor] = 0;\n      var currentYank = this[kKillRing][this[kKillRingCursor]], head = StringPrototypeSlice.call(this.line, 0, this.cursor - lastYank.length), tail = StringPrototypeSlice.call(this.line, this.cursor);\n      this.line = head + currentYank + tail, this.cursor = head.length + currentYank.length, this[kRefreshLine]();\n    }\n  }\n  clearLine() {\n    this[kMoveCursor](Infinity), this[kWriteToOutput](\"\\r\\n\"), this.line = \"\", this.cursor = 0, this.prevRows = 0;\n  }\n  [kLine]() {\n    var line = this[kAddHistory]();\n    this[kUndoStack] = [], this[kRedoStack] = [], this.clearLine(), this[kOnLine](line);\n  }\n  [kPushToUndoStack](text, cursor) {\n    if (ArrayPrototypePush.call(this[kUndoStack], { text, cursor }) > kMaxUndoRedoStackSize)\n      ArrayPrototypeShift.call(this[kUndoStack]);\n  }\n  [kUndo]() {\n    if (this[kUndoStack].length <= 0)\n      return;\n    ArrayPrototypePush.call(this[kRedoStack], {\n      text: this.line,\n      cursor: this.cursor\n    });\n    var entry = ArrayPrototypePop.call(this[kUndoStack]);\n    this.line = entry.text, this.cursor = entry.cursor, this[kRefreshLine]();\n  }\n  [kRedo]() {\n    if (this[kRedoStack].length <= 0)\n      return;\n    ArrayPrototypePush.call(this[kUndoStack], {\n      text: this.line,\n      cursor: this.cursor\n    });\n    var entry = ArrayPrototypePop.call(this[kRedoStack]);\n    this.line = entry.text, this.cursor = entry.cursor, this[kRefreshLine]();\n  }\n  [kHistoryNext]() {\n    if (this.historyIndex >= 0) {\n      this[kBeforeEdit](this.line, this.cursor);\n      var search = this[kSubstringSearch] || \"\", index = this.historyIndex - 1;\n      while (index >= 0 && (!StringPrototypeStartsWith.call(this.history[index], search) || this.line === this.history[index]))\n        index--;\n      if (index === -1)\n        this.line = search;\n      else\n        this.line = this.history[index];\n      this.historyIndex = index, this.cursor = this.line.length, this[kRefreshLine]();\n    }\n  }\n  [kHistoryPrev]() {\n    if (this.historyIndex < this.history.length && this.history.length) {\n      this[kBeforeEdit](this.line, this.cursor);\n      var search = this[kSubstringSearch] || \"\", index = this.historyIndex + 1;\n      while (index < this.history.length && (!StringPrototypeStartsWith.call(this.history[index], search) || this.line === this.history[index]))\n        index++;\n      if (index === this.history.length)\n        this.line = search;\n      else\n        this.line = this.history[index];\n      this.historyIndex = index, this.cursor = this.line.length, this[kRefreshLine]();\n    }\n  }\n  [kGetDisplayPos](str) {\n    var offset = 0, col = this.columns, rows = 0;\n    str = stripVTControlCharacters(str);\n    for (var char of new SafeStringIterator(str)) {\n      if (char === \"\\n\") {\n        rows += MathCeil(offset / col) || 1, offset = 0;\n        continue;\n      }\n      if (char === \"\\t\") {\n        offset += this.tabSize - offset % this.tabSize;\n        continue;\n      }\n      var width = getStringWidth(char, !1);\n      if (width === 0 || width === 1)\n        offset += width;\n      else {\n        if ((offset + 1) % col === 0)\n          offset++;\n        offset += 2;\n      }\n    }\n    var cols = offset % col;\n    return rows += (offset - cols) / col, { cols, rows };\n  }\n  getCursorPos() {\n    var strBeforeCursor = this[kPrompt] + StringPrototypeSlice.call(this.line, 0, this.cursor);\n    return this[kGetDisplayPos](strBeforeCursor);\n  }\n  [kMoveCursor](dx) {\n    if (dx === 0)\n      return;\n    var oldPos = this.getCursorPos();\n    if (this.cursor += dx, this.cursor < 0)\n      this.cursor = 0;\n    else if (this.cursor > this.line.length)\n      this.cursor = this.line.length;\n    var newPos = this.getCursorPos();\n    if (oldPos.rows === newPos.rows) {\n      var diffWidth = newPos.cols - oldPos.cols;\n      moveCursor(this.output, diffWidth, 0);\n    } else\n      this[kRefreshLine]();\n  }\n  [kTtyWrite](s, key) {\n    var previousKey = this[kPreviousKey];\n    key = key || kEmptyObject, this[kPreviousKey] = key;\n    var { name: keyName, meta: keyMeta, ctrl: keyCtrl2, shift: keyShift, sequence: keySeq } = key;\n    if (!keyMeta || keyName !== \"y\")\n      this[kYanking] = !1;\n    if ((keyName === \"up\" || keyName === \"down\") && !keyCtrl2 && !keyMeta && !keyShift) {\n      if (this[kSubstringSearch] === null)\n        this[kSubstringSearch] = StringPrototypeSlice.call(this.line, 0, this.cursor);\n    } else if (this[kSubstringSearch] !== null) {\n      if (this[kSubstringSearch] = null, this.history.length === this.historyIndex)\n        this.historyIndex = -1;\n    }\n    if (typeof keySeq === \"string\")\n      switch (StringPrototypeCodePointAt.call(keySeq, 0)) {\n        case 31:\n          this[kUndo]();\n          return;\n        case 30:\n          this[kRedo]();\n          return;\n        default:\n          break;\n      }\n    if (keyName === \"escape\")\n      return;\n    if (keyCtrl2 && keyShift)\n      switch (keyName) {\n        case \"backspace\":\n          this[kDeleteLineLeft]();\n          break;\n        case \"delete\":\n          this[kDeleteLineRight]();\n          break;\n      }\n    else if (keyCtrl2)\n      switch (keyName) {\n        case \"c\":\n          if (this.listenerCount(\"SIGINT\") > 0)\n            this.emit(\"SIGINT\");\n          else\n            this.close();\n          break;\n        case \"h\":\n          this[kDeleteLeft]();\n          break;\n        case \"d\":\n          if (this.cursor === 0 && this.line.length === 0)\n            this.close();\n          else if (this.cursor < this.line.length)\n            this[kDeleteRight]();\n          break;\n        case \"u\":\n          this[kDeleteLineLeft]();\n          break;\n        case \"k\":\n          this[kDeleteLineRight]();\n          break;\n        case \"a\":\n          this[kMoveCursor]((-Infinity));\n          break;\n        case \"e\":\n          this[kMoveCursor](Infinity);\n          break;\n        case \"b\":\n          this[kMoveCursor](-charLengthLeft(this.line, this.cursor));\n          break;\n        case \"f\":\n          this[kMoveCursor](+charLengthAt(this.line, this.cursor));\n          break;\n        case \"l\":\n          cursorTo(this.output, 0, 0), clearScreenDown(this.output), this[kRefreshLine]();\n          break;\n        case \"n\":\n          this[kHistoryNext]();\n          break;\n        case \"p\":\n          this[kHistoryPrev]();\n          break;\n        case \"y\":\n          this[kYank]();\n          break;\n        case \"z\":\n          break;\n        case \"w\":\n        case \"backspace\":\n          this[kDeleteWordLeft]();\n          break;\n        case \"delete\":\n          this[kDeleteWordRight]();\n          break;\n        case \"left\":\n          this[kWordLeft]();\n          break;\n        case \"right\":\n          this[kWordRight]();\n          break;\n      }\n    else if (keyMeta)\n      switch (keyName) {\n        case \"b\":\n          this[kWordLeft]();\n          break;\n        case \"f\":\n          this[kWordRight]();\n          break;\n        case \"d\":\n        case \"delete\":\n          this[kDeleteWordRight]();\n          break;\n        case \"backspace\":\n          this[kDeleteWordLeft]();\n          break;\n        case \"y\":\n          this[kYankPop]();\n          break;\n      }\n    else {\n      if (this[kSawReturnAt] && keyName !== \"enter\")\n        this[kSawReturnAt] = 0;\n      switch (keyName) {\n        case \"return\":\n          this[kSawReturnAt] = DateNow(), this[kLine]();\n          break;\n        case \"enter\":\n          if (this[kSawReturnAt] === 0 || DateNow() - this[kSawReturnAt] > this.crlfDelay)\n            this[kLine]();\n          this[kSawReturnAt] = 0;\n          break;\n        case \"backspace\":\n          this[kDeleteLeft]();\n          break;\n        case \"delete\":\n          this[kDeleteRight]();\n          break;\n        case \"left\":\n          this[kMoveCursor](-charLengthLeft(this.line, this.cursor));\n          break;\n        case \"right\":\n          this[kMoveCursor](+charLengthAt(this.line, this.cursor));\n          break;\n        case \"home\":\n          this[kMoveCursor]((-Infinity));\n          break;\n        case \"end\":\n          this[kMoveCursor](Infinity);\n          break;\n        case \"up\":\n          this[kHistoryPrev]();\n          break;\n        case \"down\":\n          this[kHistoryNext]();\n          break;\n        case \"tab\":\n          if (typeof this.completer === \"function\" && this.isCompletionEnabled) {\n            var lastKeypressWasTab = previousKey && previousKey.name === \"tab\";\n            this[kTabComplete](lastKeypressWasTab);\n            break;\n          }\n        default:\n          if (typeof s === \"string\" && s) {\n            var nextMatch = RegExpPrototypeExec.call(lineEnding, s);\n            if (nextMatch !== null) {\n              this[kInsertString](StringPrototypeSlice.call(s, 0, nextMatch.index));\n              var { lastIndex } = lineEnding;\n              while ((nextMatch = RegExpPrototypeExec.call(lineEnding, s)) !== null)\n                this[kLine](), this[kInsertString](StringPrototypeSlice.call(s, lastIndex, nextMatch.index)), { lastIndex } = lineEnding;\n              if (lastIndex === s.length)\n                this[kLine]();\n            } else\n              this[kInsertString](s);\n          }\n      }\n    }\n  }\n  [SymbolAsyncIterator]() {\n    if (this[kLineObjectStream] === void 0)\n      this[kLineObjectStream] = EventEmitter.on(this, \"line\", {\n        close: [\"close\"],\n        highWatermark: 1024,\n        [kFirstEventParam]: !0\n      });\n    return this[kLineObjectStream];\n  }\n};\nInterface.prototype = {};\nObjectSetPrototypeOf(Interface.prototype, _Interface.prototype);\nObjectSetPrototypeOf(Interface, _Interface);\nInterface.prototype.question = function question(query, options, cb) {\n  if (cb = typeof options === \"function\" \? options : cb, options === null || typeof options !== \"object\")\n    options = kEmptyObject;\n  var signal = options\?.signal;\n  if (signal) {\n    if (validateAbortSignal(signal, \"options.signal\"), signal.aborted)\n      return;\n    var onAbort = () => {\n      this[kQuestionCancel]();\n    };\n    signal.addEventListener(\"abort\", onAbort, { once: !0 });\n    var cleanup = () => {\n      signal.removeEventListener(\"abort\", onAbort);\n    }, originalCb = cb;\n    cb = typeof cb === \"function\" \? (answer) => {\n      return cleanup(), originalCb(answer);\n    } : cleanup;\n  }\n  if (typeof cb === \"function\")\n    this[kQuestion](query, cb);\n};\nInterface.prototype.question[promisify.custom] = function question2(query, options) {\n  if (options === null || typeof options !== \"object\")\n    options = kEmptyObject;\n  var signal = options\?.signal;\n  if (signal && signal.aborted)\n    return PromiseReject(new AbortError(void 0, { cause: signal.reason }));\n  return new Promise((resolve, reject) => {\n    var cb = resolve;\n    if (signal) {\n      var onAbort = () => {\n        reject(new AbortError(void 0, { cause: signal.reason }));\n      };\n      signal.addEventListener(\"abort\", onAbort, { once: !0 }), cb = (answer) => {\n        signal.removeEventListener(\"abort\", onAbort), resolve(answer);\n      };\n    }\n    this.question(query, options, cb);\n  });\n};\nObjectDefineProperties(Interface.prototype, {\n  [kSetRawMode]: {\n    __proto__: null,\n    get() {\n      return this._setRawMode;\n    }\n  },\n  [kOnLine]: {\n    __proto__: null,\n    get() {\n      return this._onLine;\n    }\n  },\n  [kWriteToOutput]: {\n    __proto__: null,\n    get() {\n      return this._writeToOutput;\n    }\n  },\n  [kAddHistory]: {\n    __proto__: null,\n    get() {\n      return this._addHistory;\n    }\n  },\n  [kRefreshLine]: {\n    __proto__: null,\n    get() {\n      return this._refreshLine;\n    }\n  },\n  [kNormalWrite]: {\n    __proto__: null,\n    get() {\n      return this._normalWrite;\n    }\n  },\n  [kInsertString]: {\n    __proto__: null,\n    get() {\n      return this._insertString;\n    }\n  },\n  [kTabComplete]: {\n    __proto__: null,\n    get() {\n      return this._tabComplete;\n    }\n  },\n  [kWordLeft]: {\n    __proto__: null,\n    get() {\n      return this._wordLeft;\n    }\n  },\n  [kWordRight]: {\n    __proto__: null,\n    get() {\n      return this._wordRight;\n    }\n  },\n  [kDeleteLeft]: {\n    __proto__: null,\n    get() {\n      return this._deleteLeft;\n    }\n  },\n  [kDeleteRight]: {\n    __proto__: null,\n    get() {\n      return this._deleteRight;\n    }\n  },\n  [kDeleteWordLeft]: {\n    __proto__: null,\n    get() {\n      return this._deleteWordLeft;\n    }\n  },\n  [kDeleteWordRight]: {\n    __proto__: null,\n    get() {\n      return this._deleteWordRight;\n    }\n  },\n  [kDeleteLineLeft]: {\n    __proto__: null,\n    get() {\n      return this._deleteLineLeft;\n    }\n  },\n  [kDeleteLineRight]: {\n    __proto__: null,\n    get() {\n      return this._deleteLineRight;\n    }\n  },\n  [kLine]: {\n    __proto__: null,\n    get() {\n      return this._line;\n    }\n  },\n  [kHistoryNext]: {\n    __proto__: null,\n    get() {\n      return this._historyNext;\n    }\n  },\n  [kHistoryPrev]: {\n    __proto__: null,\n    get() {\n      return this._historyPrev;\n    }\n  },\n  [kGetDisplayPos]: {\n    __proto__: null,\n    get() {\n      return this._getDisplayPos;\n    }\n  },\n  [kMoveCursor]: {\n    __proto__: null,\n    get() {\n      return this._moveCursor;\n    }\n  },\n  [kTtyWrite]: {\n    __proto__: null,\n    get() {\n      return this._ttyWrite;\n    }\n  },\n  _decoder: {\n    __proto__: null,\n    get() {\n      return this[kDecoder];\n    },\n    set(value) {\n      this[kDecoder] = value;\n    }\n  },\n  _line_buffer: {\n    __proto__: null,\n    get() {\n      return this[kLine_buffer];\n    },\n    set(value) {\n      this[kLine_buffer] = value;\n    }\n  },\n  _oldPrompt: {\n    __proto__: null,\n    get() {\n      return this[kOldPrompt];\n    },\n    set(value) {\n      this[kOldPrompt] = value;\n    }\n  },\n  _previousKey: {\n    __proto__: null,\n    get() {\n      return this[kPreviousKey];\n    },\n    set(value) {\n      this[kPreviousKey] = value;\n    }\n  },\n  _prompt: {\n    __proto__: null,\n    get() {\n      return this[kPrompt];\n    },\n    set(value) {\n      this[kPrompt] = value;\n    }\n  },\n  _questionCallback: {\n    __proto__: null,\n    get() {\n      return this[kQuestionCallback];\n    },\n    set(value) {\n      this[kQuestionCallback] = value;\n    }\n  },\n  _sawKeyPress: {\n    __proto__: null,\n    get() {\n      return this[kSawKeyPress];\n    },\n    set(value) {\n      this[kSawKeyPress] = value;\n    }\n  },\n  _sawReturnAt: {\n    __proto__: null,\n    get() {\n      return this[kSawReturnAt];\n    },\n    set(value) {\n      this[kSawReturnAt] = value;\n    }\n  }\n});\nInterface.prototype._setRawMode = _Interface.prototype[kSetRawMode];\nInterface.prototype._onLine = _Interface.prototype[kOnLine];\nInterface.prototype._writeToOutput = _Interface.prototype[kWriteToOutput];\nInterface.prototype._addHistory = _Interface.prototype[kAddHistory];\nInterface.prototype._refreshLine = _Interface.prototype[kRefreshLine];\nInterface.prototype._normalWrite = _Interface.prototype[kNormalWrite];\nInterface.prototype._insertString = _Interface.prototype[kInsertString];\nInterface.prototype._tabComplete = function(lastKeypressWasTab) {\n  this.pause();\n  var string = StringPrototypeSlice.call(this.line, 0, this.cursor);\n  this.completer(string, (err, value) => {\n    if (this.resume(), err) {\n      this._writeToOutput(`Tab completion error: ${inspect(err)}`);\n      return;\n    }\n    this[kTabCompleter](lastKeypressWasTab, value);\n  });\n};\nInterface.prototype._wordLeft = _Interface.prototype[kWordLeft];\nInterface.prototype._wordRight = _Interface.prototype[kWordRight];\nInterface.prototype._deleteLeft = _Interface.prototype[kDeleteLeft];\nInterface.prototype._deleteRight = _Interface.prototype[kDeleteRight];\nInterface.prototype._deleteWordLeft = _Interface.prototype[kDeleteWordLeft];\nInterface.prototype._deleteWordRight = _Interface.prototype[kDeleteWordRight];\nInterface.prototype._deleteLineLeft = _Interface.prototype[kDeleteLineLeft];\nInterface.prototype._deleteLineRight = _Interface.prototype[kDeleteLineRight];\nInterface.prototype._line = _Interface.prototype[kLine];\nInterface.prototype._historyNext = _Interface.prototype[kHistoryNext];\nInterface.prototype._historyPrev = _Interface.prototype[kHistoryPrev];\nInterface.prototype._getDisplayPos = _Interface.prototype[kGetDisplayPos];\nInterface.prototype._getCursorPos = _Interface.prototype.getCursorPos;\nInterface.prototype._moveCursor = _Interface.prototype[kMoveCursor];\nInterface.prototype._ttyWrite = _Interface.prototype[kTtyWrite];\n\nclass Readline {\n  #autoCommit = !1;\n  #stream;\n  #todo = [];\n  constructor(stream, options = void 0) {\n    if (isWritable \?\?= (@getInternalField(@internalModuleRegistry, 35) || @createInternalModuleById(35)).isWritable, !isWritable(stream))\n      throw new ERR_INVALID_ARG_TYPE(\"stream\", \"Writable\", stream);\n    if (this.#stream = stream, options\?.autoCommit != null)\n      validateBoolean(options.autoCommit, \"options.autoCommit\"), this.#autoCommit = options.autoCommit;\n  }\n  cursorTo(x, y = void 0) {\n    if (validateInteger(x, \"x\"), y != null)\n      validateInteger(y, \"y\");\n    var data = y == null \? CSI`${x + 1}G` : CSI`${y + 1};${x + 1}H`;\n    if (this.#autoCommit)\n      process.nextTick(() => this.#stream.write(data));\n    else\n      ArrayPrototypePush.call(this.#todo, data);\n    return this;\n  }\n  moveCursor(dx, dy) {\n    if (dx || dy) {\n      validateInteger(dx, \"dx\"), validateInteger(dy, \"dy\");\n      var data = \"\";\n      if (dx < 0)\n        data += CSI`${-dx}D`;\n      else if (dx > 0)\n        data += CSI`${dx}C`;\n      if (dy < 0)\n        data += CSI`${-dy}A`;\n      else if (dy > 0)\n        data += CSI`${dy}B`;\n      if (this.#autoCommit)\n        process.nextTick(() => this.#stream.write(data));\n      else\n        ArrayPrototypePush.call(this.#todo, data);\n    }\n    return this;\n  }\n  clearLine(dir) {\n    validateInteger(dir, \"dir\", -1, 1);\n    var data = dir < 0 \? kClearToLineBeginning : dir > 0 \? kClearToLineEnd : kClearLine;\n    if (this.#autoCommit)\n      process.nextTick(() => this.#stream.write(data));\n    else\n      ArrayPrototypePush.call(this.#todo, data);\n    return this;\n  }\n  clearScreenDown() {\n    if (this.#autoCommit)\n      process.nextTick(() => this.#stream.write(kClearScreenDown));\n    else\n      ArrayPrototypePush.call(this.#todo, kClearScreenDown);\n    return this;\n  }\n  commit() {\n    return new Promise((resolve) => {\n      this.#stream.write(ArrayPrototypeJoin.call(this.#todo, \"\"), resolve), this.#todo = [];\n    });\n  }\n  rollback() {\n    return this.#todo = [], this;\n  }\n}\nvar PromisesInterface = class Interface3 extends _Interface {\n  constructor(input, output, completer, terminal) {\n    super(input, output, completer, terminal);\n  }\n  question(query, options = kEmptyObject) {\n    var signal = options\?.signal;\n    if (signal) {\n      if (validateAbortSignal(signal, \"options.signal\"), signal.aborted)\n        return PromiseReject(new AbortError(void 0, { cause: signal.reason }));\n    }\n    return new Promise((resolve, reject) => {\n      var cb = resolve;\n      if (options\?.signal) {\n        var onAbort = () => {\n          this[kQuestionCancel](), reject(new AbortError(void 0, { cause: signal.reason }));\n        };\n        signal.addEventListener(\"abort\", onAbort, { once: !0 }), cb = (answer) => {\n          signal.removeEventListener(\"abort\", onAbort), resolve(answer);\n        };\n      }\n      this[kQuestion](query, cb);\n    });\n  }\n};\n$ = {\n  Interface,\n  clearLine,\n  clearScreenDown,\n  createInterface,\n  cursorTo,\n  emitKeypressEvents,\n  moveCursor,\n  promises: {\n    Readline,\n    Interface: PromisesInterface,\n    createInterface(input, output, completer, terminal) {\n      return new PromisesInterface(input, output, completer, terminal);\n    }\n  },\n  [SymbolFor(\"__BUN_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED__\")]: {\n    CSI,\n    utils: {\n      getStringWidth,\n      stripVTControlCharacters\n    }\n  }\n};\nreturn $})\n"_s;
//

//
static constexpr ASCIILiteral NodeReadlinePromisesCode = "(function (){\"use strict\";// src/js/out/tmp/node/readline.promises.ts\nreturn (@getInternalField(@internalModuleRegistry, 31) || @createInternalModuleById(31)).promises})\n"_s;
//

//
static constexpr ASCIILiteral NodeReplCode = "(function (){\"use strict\";// src/js/out/tmp/node/repl.ts\nvar $, { throwNotImplemented } = @getInternalField(@internalModuleRegistry, 3) || @createInternalModuleById(3);\n$ = {\n  lines: [],\n  context: globalThis,\n  historyIndex: -1,\n  cursor: 0,\n  historySize: 1000,\n  removeHistoryDuplicates: !1,\n  crlfDelay: 100,\n  completer: () => {\n    throwNotImplemented(\"node:repl\");\n  },\n  history: [],\n  _initialPrompt: \"> \",\n  terminal: !0,\n  input: new Proxy({}, {\n    get() {\n      throwNotImplemented(\"node:repl\");\n    },\n    has: () => !1,\n    ownKeys: () => [],\n    getOwnPropertyDescriptor: () => {\n      return;\n    },\n    set() {\n      throwNotImplemented(\"node:repl\");\n    }\n  }),\n  line: \"\",\n  eval: () => {\n    throwNotImplemented(\"node:repl\");\n  },\n  isCompletionEnabled: !0,\n  escapeCodeTimeout: 500,\n  tabSize: 8,\n  breakEvalOnSigint: !0,\n  useGlobal: !0,\n  underscoreAssigned: !1,\n  last: void 0,\n  _domain: void 0,\n  allowBlockingCompletions: !1,\n  useColors: !0,\n  output: new Proxy({}, {\n    get() {\n      throwNotImplemented(\"node:repl\");\n    },\n    has: () => !1,\n    ownKeys: () => [],\n    getOwnPropertyDescriptor: () => {\n      return;\n    },\n    set() {\n      throwNotImplemented(\"node:repl\");\n    }\n  }),\n  _builtinLibs: [\n    \"bun\",\n    \"ffi\",\n    \"assert\",\n    \"assert/strict\",\n    \"async_hooks\",\n    \"buffer\",\n    \"child_process\",\n    \"cluster\",\n    \"console\",\n    \"constants\",\n    \"crypto\",\n    \"dgram\",\n    \"diagnostics_channel\",\n    \"dns\",\n    \"dns/promises\",\n    \"domain\",\n    \"events\",\n    \"fs\",\n    \"fs/promises\",\n    \"http\",\n    \"http2\",\n    \"https\",\n    \"inspector\",\n    \"inspector/promises\",\n    \"module\",\n    \"net\",\n    \"os\",\n    \"path\",\n    \"path/posix\",\n    \"path/win32\",\n    \"perf_hooks\",\n    \"process\",\n    \"punycode\",\n    \"querystring\",\n    \"readline\",\n    \"readline/promises\",\n    \"repl\",\n    \"stream\",\n    \"stream/consumers\",\n    \"stream/promises\",\n    \"stream/web\",\n    \"string_decoder\",\n    \"sys\",\n    \"timers\",\n    \"timers/promises\",\n    \"tls\",\n    \"trace_events\",\n    \"tty\",\n    \"url\",\n    \"util\",\n    \"util/types\",\n    \"v8\",\n    \"vm\",\n    \"wasi\",\n    \"worker_threads\",\n    \"zlib\"\n  ]\n};\nreturn $})\n"_s;
//

//
static constexpr ASCIILiteral NodeStreamConsumersCode = "(function (){\"use strict\";// src/js/out/tmp/node/stream.consumers.ts\nvar $, arrayBuffer = Bun.readableStreamToArrayBuffer, text = Bun.readableStreamToText, json = (stream) => Bun.readableStreamToText(stream).then(JSON.parse), buffer = async (readableStream) => {\n  return new Buffer(await arrayBuffer(readableStream));\n}, blob = Bun.readableStreamToBlob;\n$ = {\n  arrayBuffer,\n  text,\n  json,\n  buffer,\n  blob\n};\nreturn $})\n"_s;
//

//
static constexpr ASCIILiteral NodeStreamCode = "(function (){\"use strict\";// src/js/out/tmp/node/stream.ts\nvar isReadableStream = function(value) {\n  return typeof value === \"object\" && value !== null && value instanceof ReadableStream;\n}, validateBoolean = function(value, name) {\n  if (typeof value !== \"boolean\")\n    throw new ERR_INVALID_ARG_TYPE(name, \"boolean\", value);\n};\nvar ERR_INVALID_ARG_TYPE = function(name, type, value) {\n  return new Error(`The argument '${name}' is invalid. Received '${value}' for type '${type}'`);\n}, ERR_INVALID_ARG_VALUE = function(name, value, reason) {\n  return new Error(`The value '${value}' is invalid for argument '${name}'. Reason: ${reason}`);\n}, createNativeStreamReadable = function(nativeType, Readable) {\n  var [pull, start, cancel, setClose, deinit, updateRef, drainFn] = globalThis[globalThis.Symbol.for('Bun.lazy')](nativeType), closer = [!1], handleNumberResult = function(nativeReadable, result, view, isClosed) {\n    if (result > 0) {\n      const slice = view.subarray(0, result), remainder = view.subarray(result);\n      if (slice.byteLength > 0)\n        nativeReadable.push(slice);\n      if (isClosed)\n        nativeReadable.push(null);\n      return remainder.byteLength > 0 \? remainder : void 0;\n    }\n    if (isClosed)\n      nativeReadable.push(null);\n    return view;\n  }, handleArrayBufferViewResult = function(nativeReadable, result, view, isClosed) {\n    if (result.byteLength > 0)\n      nativeReadable.push(result);\n    if (isClosed)\n      nativeReadable.push(null);\n    return view;\n  }, DYNAMICALLY_ADJUST_CHUNK_SIZE = process.env.BUN_DISABLE_DYNAMIC_CHUNK_SIZE !== \"1\";\n  const finalizer = new FinalizationRegistry((ptr) => ptr && deinit(ptr)), MIN_BUFFER_SIZE = 512;\n  var NativeReadable = class NativeReadable2 extends Readable {\n    #bunNativePtr;\n    #refCount = 1;\n    #constructed = !1;\n    #remainingChunk = void 0;\n    #highWaterMark;\n    #pendingRead = !1;\n    #hasResized = !DYNAMICALLY_ADJUST_CHUNK_SIZE;\n    #unregisterToken;\n    constructor(ptr, options = {}) {\n      super(options);\n      if (typeof options.highWaterMark === \"number\")\n        this.#highWaterMark = options.highWaterMark;\n      else\n        this.#highWaterMark = 262144;\n      this.#bunNativePtr = ptr, this.#constructed = !1, this.#remainingChunk = void 0, this.#pendingRead = !1, this.#unregisterToken = {}, finalizer.register(this, this.#bunNativePtr, this.#unregisterToken);\n    }\n    _read(maxToRead) {\n      if (this.#pendingRead)\n        return;\n      var ptr = this.#bunNativePtr;\n      if (ptr === 0) {\n        this.push(null);\n        return;\n      }\n      if (!this.#constructed)\n        this.#internalConstruct(ptr);\n      return this.#internalRead(this.#getRemainingChunk(maxToRead), ptr);\n    }\n    #internalConstruct(ptr) {\n      this.#constructed = !0;\n      const result = start(ptr, this.#highWaterMark);\n      if (typeof result === \"number\" && result > 1)\n        this.#hasResized = !0, this.#highWaterMark = Math.min(this.#highWaterMark, result);\n      if (drainFn) {\n        const drainResult = drainFn(ptr);\n        if ((drainResult\?.byteLength \?\? 0) > 0)\n          this.push(drainResult);\n      }\n    }\n    #getRemainingChunk(maxToRead = this.#highWaterMark) {\n      var chunk = this.#remainingChunk;\n      if (chunk\?.byteLength \?\? 0 < MIN_BUFFER_SIZE) {\n        var size = maxToRead > MIN_BUFFER_SIZE \? maxToRead : MIN_BUFFER_SIZE;\n        this.#remainingChunk = chunk = new Buffer(size);\n      }\n      return chunk;\n    }\n    #handleResult(result, view, isClosed) {\n      if (typeof result === \"number\") {\n        if (result >= this.#highWaterMark && !this.#hasResized && !isClosed)\n          this.#highWaterMark *= 2, this.#hasResized = !0;\n        return handleNumberResult(this, result, view, isClosed);\n      } else if (typeof result === \"boolean\")\n        return process.nextTick(() => {\n          this.push(null);\n        }), view\?.byteLength \?\? 0 > 0 \? view : void 0;\n      else if (ArrayBuffer.isView(result)) {\n        if (result.byteLength >= this.#highWaterMark && !this.#hasResized && !isClosed)\n          this.#highWaterMark *= 2, this.#hasResized = !0;\n        return handleArrayBufferViewResult(this, result, view, isClosed);\n      } else\n        throw new Error(\"Invalid result from pull\");\n    }\n    #internalRead(view, ptr) {\n      closer[0] = !1;\n      var result = pull(ptr, view, closer);\n      if (@isPromise(result))\n        return this.#pendingRead = !0, result.then((result2) => {\n          this.#pendingRead = !1, this.#remainingChunk = this.#handleResult(result2, view, closer[0]);\n        }, (reason) => {\n          errorOrDestroy(this, reason);\n        });\n      else\n        this.#remainingChunk = this.#handleResult(result, view, closer[0]);\n    }\n    _destroy(error, callback) {\n      var ptr = this.#bunNativePtr;\n      if (ptr === 0) {\n        callback(error);\n        return;\n      }\n      if (finalizer.unregister(this.#unregisterToken), this.#bunNativePtr = 0, updateRef)\n        updateRef(ptr, !1);\n      cancel(ptr, error), callback(error);\n    }\n    ref() {\n      var ptr = this.#bunNativePtr;\n      if (ptr === 0)\n        return;\n      if (this.#refCount++ === 0)\n        updateRef(ptr, !0);\n    }\n    unref() {\n      var ptr = this.#bunNativePtr;\n      if (ptr === 0)\n        return;\n      if (this.#refCount-- === 1)\n        updateRef(ptr, !1);\n    }\n  };\n  if (!updateRef)\n    NativeReadable.prototype.ref = void 0, NativeReadable.prototype.unref = void 0;\n  return NativeReadable;\n}, getNativeReadableStreamPrototype = function(nativeType, Readable) {\n  return nativeReadableStreamPrototypes[nativeType] ||= createNativeStreamReadable(nativeType, Readable);\n}, getNativeReadableStream = function(Readable, stream, options) {\n  if (!(stream && typeof stream === \"object\" && stream instanceof ReadableStream))\n    return;\n  const native = @direct(stream);\n  if (!native)\n    return;\n  const { stream: ptr, data: type } = native;\n  return new (getNativeReadableStreamPrototype(type, Readable))(ptr, options);\n}, EE = globalThis[globalThis.Symbol.for('Bun.lazy')](\"events\"), StringDecoder = @requireNativeModule(\"node:string_decoder\").StringDecoder, __getOwnPropNames = Object.getOwnPropertyNames, __commonJS = (cb, mod) => function __require2() {\n  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;\n}, runOnNextTick = process.nextTick;\nvar ArrayIsArray = Array.isArray, require_primordials = __commonJS({\n  \"node_modules/readable-stream/lib/ours/primordials.js\"(exports, module) {\n    module.exports = {\n      ArrayIsArray(self) {\n        return Array.isArray(self);\n      },\n      ArrayPrototypeIncludes(self, el) {\n        return self.includes(el);\n      },\n      ArrayPrototypeIndexOf(self, el) {\n        return self.indexOf(el);\n      },\n      ArrayPrototypeJoin(self, sep) {\n        return self.join(sep);\n      },\n      ArrayPrototypeMap(self, fn) {\n        return self.map(fn);\n      },\n      ArrayPrototypePop(self, el) {\n        return self.pop(el);\n      },\n      ArrayPrototypePush(self, el) {\n        return self.push(el);\n      },\n      ArrayPrototypeSlice(self, start, end) {\n        return self.slice(start, end);\n      },\n      Error,\n      FunctionPrototypeCall(fn, thisArgs, ...args) {\n        return fn.call(thisArgs, ...args);\n      },\n      FunctionPrototypeSymbolHasInstance(self, instance) {\n        return Function.prototype[Symbol.hasInstance].call(self, instance);\n      },\n      MathFloor: Math.floor,\n      Number,\n      NumberIsInteger: Number.isInteger,\n      NumberIsNaN: Number.isNaN,\n      NumberMAX_SAFE_INTEGER: Number.MAX_SAFE_INTEGER,\n      NumberMIN_SAFE_INTEGER: Number.MIN_SAFE_INTEGER,\n      NumberParseInt: Number.parseInt,\n      ObjectDefineProperties(self, props) {\n        return Object.defineProperties(self, props);\n      },\n      ObjectDefineProperty(self, name, prop) {\n        return Object.defineProperty(self, name, prop);\n      },\n      ObjectGetOwnPropertyDescriptor(self, name) {\n        return Object.getOwnPropertyDescriptor(self, name);\n      },\n      ObjectKeys(obj) {\n        return Object.keys(obj);\n      },\n      ObjectSetPrototypeOf(target, proto) {\n        return Object.setPrototypeOf(target, proto);\n      },\n      Promise,\n      PromisePrototypeCatch(self, fn) {\n        return self.catch(fn);\n      },\n      PromisePrototypeThen(self, thenFn, catchFn) {\n        return self.then(thenFn, catchFn);\n      },\n      PromiseReject(err) {\n        return Promise.reject(err);\n      },\n      ReflectApply: Reflect.apply,\n      RegExpPrototypeTest(self, value) {\n        return self.test(value);\n      },\n      SafeSet: Set,\n      String,\n      StringPrototypeSlice(self, start, end) {\n        return self.slice(start, end);\n      },\n      StringPrototypeToLowerCase(self) {\n        return self.toLowerCase();\n      },\n      StringPrototypeToUpperCase(self) {\n        return self.toUpperCase();\n      },\n      StringPrototypeTrim(self) {\n        return self.trim();\n      },\n      Symbol,\n      SymbolAsyncIterator: Symbol.asyncIterator,\n      SymbolHasInstance: Symbol.hasInstance,\n      SymbolIterator: Symbol.iterator,\n      TypedArrayPrototypeSet(self, buf, len) {\n        return self.set(buf, len);\n      },\n      Uint8Array\n    };\n  }\n}), require_util = __commonJS({\n  \"node_modules/readable-stream/lib/ours/util.js\"(exports, module) {\n    var AsyncFunction = Object.getPrototypeOf(async function() {\n    }).constructor, isBlob = typeof Blob !== \"undefined\" \? function isBlob2(b) {\n      return b instanceof Blob;\n    } : function isBlob2(b) {\n      return !1;\n    }, AggregateError = class extends Error {\n      constructor(errors) {\n        if (!Array.isArray(errors))\n          @throwTypeError(`Expected input to be an Array, got ${typeof errors}`);\n        let message = \"\";\n        for (let i = 0;i < errors.length; i++)\n          message += `    ${errors[i].stack}\n`;\n        super(message);\n        this.name = \"AggregateError\", this.errors = errors;\n      }\n    };\n    module.exports = {\n      AggregateError,\n      once(callback) {\n        let called = !1;\n        return function(...args) {\n          if (called)\n            return;\n          called = !0, callback.apply(this, args);\n        };\n      },\n      createDeferredPromise: function() {\n        let resolve, reject;\n        return {\n          promise: new Promise((res, rej) => {\n            resolve = res, reject = rej;\n          }),\n          resolve,\n          reject\n        };\n      },\n      promisify(fn) {\n        return new Promise((resolve, reject) => {\n          fn((err, ...args) => {\n            if (err)\n              return reject(err);\n            return resolve(...args);\n          });\n        });\n      },\n      debuglog() {\n        return function() {\n        };\n      },\n      format(format, ...args) {\n        return format.replace(/%([sdifj])/g, function(...[_unused, type]) {\n          const replacement = args.shift();\n          if (type === \"f\")\n            return replacement.toFixed(6);\n          else if (type === \"j\")\n            return JSON.stringify(replacement);\n          else if (type === \"s\" && typeof replacement === \"object\")\n            return `${replacement.constructor !== Object \? replacement.constructor.name : \"\"} {}`.trim();\n          else\n            return replacement.toString();\n        });\n      },\n      inspect(value) {\n        switch (typeof value) {\n          case \"string\":\n            if (value.includes(\"'\")) {\n              if (!value.includes('\"'))\n                return `\"${value}\"`;\n              else if (!value.includes(\"`\") && !value.includes(\"${\"))\n                return `\\`${value}\\``;\n            }\n            return `'${value}'`;\n          case \"number\":\n            if (isNaN(value))\n              return \"NaN\";\n            else if (Object.is(value, -0))\n              return String(value);\n            return value;\n          case \"bigint\":\n            return `${String(value)}n`;\n          case \"boolean\":\n          case \"undefined\":\n            return String(value);\n          case \"object\":\n            return \"{}\";\n        }\n      },\n      types: {\n        isAsyncFunction(fn) {\n          return fn instanceof AsyncFunction;\n        },\n        isArrayBufferView(arr) {\n          return ArrayBuffer.isView(arr);\n        }\n      },\n      isBlob\n    }, module.exports.promisify.custom = Symbol.for(\"nodejs.util.promisify.custom\");\n  }\n}), require_errors = __commonJS({\n  \"node_modules/readable-stream/lib/ours/errors.js\"(exports, module) {\n    var { format, inspect, AggregateError: CustomAggregateError } = require_util(), AggregateError = globalThis.AggregateError || CustomAggregateError, kIsNodeError = Symbol(\"kIsNodeError\"), kTypes = [\"string\", \"function\", \"number\", \"object\", \"Function\", \"Object\", \"boolean\", \"bigint\", \"symbol\"], classRegExp = /^([A-Z][a-z0-9]*)+$/, nodeInternalPrefix = \"__node_internal_\", codes = {};\n    function assert(value, message) {\n      if (!value)\n        throw new codes.ERR_INTERNAL_ASSERTION(message);\n    }\n    function addNumericalSeparator(val) {\n      let res = \"\", i = val.length;\n      const start = val[0] === \"-\" \? 1 : 0;\n      for (;i >= start + 4; i -= 3)\n        res = `_${val.slice(i - 3, i)}${res}`;\n      return `${val.slice(0, i)}${res}`;\n    }\n    function getMessage(key, msg, args) {\n      if (typeof msg === \"function\")\n        return assert(msg.length <= args.length, `Code: ${key}; The provided arguments length (${args.length}) does not match the required ones (${msg.length}).`), msg(...args);\n      const expectedLength = (msg.match(/%[dfijoOs]/g) || []).length;\n      if (assert(expectedLength === args.length, `Code: ${key}; The provided arguments length (${args.length}) does not match the required ones (${expectedLength}).`), args.length === 0)\n        return msg;\n      return format(msg, ...args);\n    }\n    function E(code, message, Base) {\n      if (!Base)\n        Base = Error;\n\n      class NodeError extends Base {\n        constructor(...args) {\n          super(getMessage(code, message, args));\n        }\n        toString() {\n          return `${this.name} [${code}]: ${this.message}`;\n        }\n      }\n      Object.defineProperties(NodeError.prototype, {\n        name: {\n          value: Base.name,\n          writable: !0,\n          enumerable: !1,\n          configurable: !0\n        },\n        toString: {\n          value() {\n            return `${this.name} [${code}]: ${this.message}`;\n          },\n          writable: !0,\n          enumerable: !1,\n          configurable: !0\n        }\n      }), NodeError.prototype.code = code, NodeError.prototype[kIsNodeError] = !0, codes[code] = NodeError;\n    }\n    function hideStackFrames(fn) {\n      const hidden = nodeInternalPrefix + fn.name;\n      return Object.defineProperty(fn, \"name\", {\n        value: hidden\n      }), fn;\n    }\n    function aggregateTwoErrors(innerError, outerError) {\n      if (innerError && outerError && innerError !== outerError) {\n        if (Array.isArray(outerError.errors))\n          return outerError.errors.push(innerError), outerError;\n        const err = new AggregateError([outerError, innerError], outerError.message);\n        return err.code = outerError.code, err;\n      }\n      return innerError || outerError;\n    }\n    var AbortError2 = class extends Error {\n      constructor(message = \"The operation was aborted\", options = void 0) {\n        if (options !== void 0 && typeof options !== \"object\")\n          throw new codes.ERR_INVALID_ARG_TYPE(\"options\", \"Object\", options);\n        super(message, options);\n        this.code = \"ABORT_ERR\", this.name = \"AbortError\";\n      }\n    };\n    E(\"ERR_ASSERTION\", \"%s\", Error), E(\"ERR_INVALID_ARG_TYPE\", (name, expected, actual) => {\n      if (assert(typeof name === \"string\", \"'name' must be a string\"), !Array.isArray(expected))\n        expected = [expected];\n      let msg = \"The \";\n      if (name.endsWith(\" argument\"))\n        msg += `${name} `;\n      else\n        msg += `\"${name}\" ${name.includes(\".\") \? \"property\" : \"argument\"} `;\n      msg += \"must be \";\n      const types = [], instances = [], other = [];\n      for (let value of expected)\n        if (assert(typeof value === \"string\", \"All expected entries have to be of type string\"), kTypes.includes(value))\n          types.push(value.toLowerCase());\n        else if (classRegExp.test(value))\n          instances.push(value);\n        else\n          assert(value !== \"object\", 'The value \"object\" should be written as \"Object\"'), other.push(value);\n      if (instances.length > 0) {\n        const pos = types.indexOf(\"object\");\n        if (pos !== -1)\n          types.splice(types, pos, 1), instances.push(\"Object\");\n      }\n      if (types.length > 0) {\n        switch (types.length) {\n          case 1:\n            msg += `of type ${types[0]}`;\n            break;\n          case 2:\n            msg += `one of type ${types[0]} or ${types[1]}`;\n            break;\n          default: {\n            const last = types.pop();\n            msg += `one of type ${types.join(\", \")}, or ${last}`;\n          }\n        }\n        if (instances.length > 0 || other.length > 0)\n          msg += \" or \";\n      }\n      if (instances.length > 0) {\n        switch (instances.length) {\n          case 1:\n            msg += `an instance of ${instances[0]}`;\n            break;\n          case 2:\n            msg += `an instance of ${instances[0]} or ${instances[1]}`;\n            break;\n          default: {\n            const last = instances.pop();\n            msg += `an instance of ${instances.join(\", \")}, or ${last}`;\n          }\n        }\n        if (other.length > 0)\n          msg += \" or \";\n      }\n      switch (other.length) {\n        case 0:\n          break;\n        case 1:\n          if (other[0].toLowerCase() !== other[0])\n            msg += \"an \";\n          msg += `${other[0]}`;\n          break;\n        case 2:\n          msg += `one of ${other[0]} or ${other[1]}`;\n          break;\n        default: {\n          const last = other.pop();\n          msg += `one of ${other.join(\", \")}, or ${last}`;\n        }\n      }\n      if (actual == null)\n        msg += `. Received ${actual}`;\n      else if (typeof actual === \"function\" && actual.name)\n        msg += `. Received function ${actual.name}`;\n      else if (typeof actual === \"object\") {\n        var _actual$constructor;\n        if ((_actual$constructor = actual.constructor) !== null && _actual$constructor !== void 0 && _actual$constructor.name)\n          msg += `. Received an instance of ${actual.constructor.name}`;\n        else {\n          const inspected = inspect(actual, {\n            depth: -1\n          });\n          msg += `. Received ${inspected}`;\n        }\n      } else {\n        let inspected = inspect(actual, {\n          colors: !1\n        });\n        if (inspected.length > 25)\n          inspected = `${inspected.slice(0, 25)}...`;\n        msg += `. Received type ${typeof actual} (${inspected})`;\n      }\n      return msg;\n    }, TypeError), E(\"ERR_INVALID_ARG_VALUE\", (name, value, reason = \"is invalid\") => {\n      let inspected = inspect(value);\n      if (inspected.length > 128)\n        inspected = inspected.slice(0, 128) + \"...\";\n      return `The ${name.includes(\".\") \? \"property\" : \"argument\"} '${name}' ${reason}. Received ${inspected}`;\n    }, TypeError), E(\"ERR_INVALID_RETURN_VALUE\", (input, name, value) => {\n      var _value$constructor;\n      const type = value !== null && value !== void 0 && (_value$constructor = value.constructor) !== null && _value$constructor !== void 0 && _value$constructor.name \? `instance of ${value.constructor.name}` : `type ${typeof value}`;\n      return `Expected ${input} to be returned from the \"${name}\" function but got ${type}.`;\n    }, TypeError), E(\"ERR_MISSING_ARGS\", (...args) => {\n      assert(args.length > 0, \"At least one arg needs to be specified\");\n      let msg;\n      const len = args.length;\n      switch (args = (Array.isArray(args) \? args : [args]).map((a) => `\"${a}\"`).join(\" or \"), len) {\n        case 1:\n          msg += `The ${args[0]} argument`;\n          break;\n        case 2:\n          msg += `The ${args[0]} and ${args[1]} arguments`;\n          break;\n        default:\n          {\n            const last = args.pop();\n            msg += `The ${args.join(\", \")}, and ${last} arguments`;\n          }\n          break;\n      }\n      return `${msg} must be specified`;\n    }, TypeError), E(\"ERR_OUT_OF_RANGE\", (str, range, input) => {\n      assert(range, 'Missing \"range\" argument');\n      let received;\n      if (Number.isInteger(input) && Math.abs(input) > 4294967296)\n        received = addNumericalSeparator(String(input));\n      else if (typeof input === \"bigint\") {\n        if (received = String(input), input > 2n ** 32n || input < -(2n ** 32n))\n          received = addNumericalSeparator(received);\n        received += \"n\";\n      } else\n        received = inspect(input);\n      return `The value of \"${str}\" is out of range. It must be ${range}. Received ${received}`;\n    }, RangeError), E(\"ERR_MULTIPLE_CALLBACK\", \"Callback called multiple times\", Error), E(\"ERR_METHOD_NOT_IMPLEMENTED\", \"The %s method is not implemented\", Error), E(\"ERR_STREAM_ALREADY_FINISHED\", \"Cannot call %s after a stream was finished\", Error), E(\"ERR_STREAM_CANNOT_PIPE\", \"Cannot pipe, not readable\", Error), E(\"ERR_STREAM_DESTROYED\", \"Cannot call %s after a stream was destroyed\", Error), E(\"ERR_STREAM_NULL_VALUES\", \"May not write null values to stream\", TypeError), E(\"ERR_STREAM_PREMATURE_CLOSE\", \"Premature close\", Error), E(\"ERR_STREAM_PUSH_AFTER_EOF\", \"stream.push() after EOF\", Error), E(\"ERR_STREAM_UNSHIFT_AFTER_END_EVENT\", \"stream.unshift() after end event\", Error), E(\"ERR_STREAM_WRITE_AFTER_END\", \"write after end\", Error), E(\"ERR_UNKNOWN_ENCODING\", \"Unknown encoding: %s\", TypeError), module.exports = {\n      AbortError: AbortError2,\n      aggregateTwoErrors: hideStackFrames(aggregateTwoErrors),\n      hideStackFrames,\n      codes\n    };\n  }\n}), require_validators = __commonJS({\n  \"node_modules/readable-stream/lib/internal/validators.js\"(exports, module) {\n    var {\n      ArrayIsArray: ArrayIsArray2,\n      ArrayPrototypeIncludes,\n      ArrayPrototypeJoin,\n      ArrayPrototypeMap,\n      NumberIsInteger,\n      NumberMAX_SAFE_INTEGER,\n      NumberMIN_SAFE_INTEGER,\n      NumberParseInt,\n      RegExpPrototypeTest,\n      String: String2,\n      StringPrototypeToUpperCase,\n      StringPrototypeTrim\n    } = require_primordials(), {\n      hideStackFrames,\n      codes: { ERR_SOCKET_BAD_PORT, ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE2, ERR_INVALID_ARG_VALUE: ERR_INVALID_ARG_VALUE2, ERR_OUT_OF_RANGE, ERR_UNKNOWN_SIGNAL }\n    } = require_errors(), { normalizeEncoding } = require_util(), { isAsyncFunction, isArrayBufferView } = require_util().types, signals = {};\n    function isInt32(value) {\n      return value === (value | 0);\n    }\n    function isUint32(value) {\n      return value === value >>> 0;\n    }\n    var octalReg = /^[0-7]+$/, modeDesc = \"must be a 32-bit unsigned integer or an octal string\";\n    function parseFileMode(value, name, def) {\n      if (typeof value === \"undefined\")\n        value = def;\n      if (typeof value === \"string\") {\n        if (!RegExpPrototypeTest(octalReg, value))\n          throw new ERR_INVALID_ARG_VALUE2(name, value, modeDesc);\n        value = NumberParseInt(value, 8);\n      }\n      return validateInt32(value, name, 0, 4294967295), value;\n    }\n    var validateInteger = hideStackFrames((value, name, min = NumberMIN_SAFE_INTEGER, max = NumberMAX_SAFE_INTEGER) => {\n      if (typeof value !== \"number\")\n        throw new ERR_INVALID_ARG_TYPE2(name, \"number\", value);\n      if (!NumberIsInteger(value))\n        throw new ERR_OUT_OF_RANGE(name, \"an integer\", value);\n      if (value < min || value > max)\n        throw new ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value);\n    }), validateInt32 = hideStackFrames((value, name, min = -2147483648, max = 2147483647) => {\n      if (typeof value !== \"number\")\n        throw new ERR_INVALID_ARG_TYPE2(name, \"number\", value);\n      if (!isInt32(value)) {\n        if (!NumberIsInteger(value))\n          throw new ERR_OUT_OF_RANGE(name, \"an integer\", value);\n        throw new ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value);\n      }\n      if (value < min || value > max)\n        throw new ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value);\n    }), validateUint32 = hideStackFrames((value, name, positive) => {\n      if (typeof value !== \"number\")\n        throw new ERR_INVALID_ARG_TYPE2(name, \"number\", value);\n      if (!isUint32(value)) {\n        if (!NumberIsInteger(value))\n          throw new ERR_OUT_OF_RANGE(name, \"an integer\", value);\n        throw new ERR_OUT_OF_RANGE(name, `>= ${positive \? 1 : 0} && < 4294967296`, value);\n      }\n      if (positive && value === 0)\n        throw new ERR_OUT_OF_RANGE(name, \">= 1 && < 4294967296\", value);\n    });\n    function validateString(value, name) {\n      if (typeof value !== \"string\")\n        throw new ERR_INVALID_ARG_TYPE2(name, \"string\", value);\n    }\n    function validateNumber(value, name) {\n      if (typeof value !== \"number\")\n        throw new ERR_INVALID_ARG_TYPE2(name, \"number\", value);\n    }\n    var validateOneOf = hideStackFrames((value, name, oneOf) => {\n      if (!ArrayPrototypeIncludes(oneOf, value)) {\n        const reason = \"must be one of: \" + ArrayPrototypeJoin(ArrayPrototypeMap(oneOf, (v) => typeof v === \"string\" \? `'${v}'` : String2(v)), \", \");\n        throw new ERR_INVALID_ARG_VALUE2(name, value, reason);\n      }\n    });\n    function validateBoolean2(value, name) {\n      if (typeof value !== \"boolean\")\n        throw new ERR_INVALID_ARG_TYPE2(name, \"boolean\", value);\n    }\n    var validateObject = hideStackFrames((value, name, options) => {\n      const useDefaultOptions = options == null, allowArray = useDefaultOptions \? !1 : options.allowArray, allowFunction = useDefaultOptions \? !1 : options.allowFunction;\n      if (!(useDefaultOptions \? !1 : options.nullable) && value === null || !allowArray && ArrayIsArray2(value) || typeof value !== \"object\" && (!allowFunction || typeof value !== \"function\"))\n        throw new ERR_INVALID_ARG_TYPE2(name, \"Object\", value);\n    }), validateArray = hideStackFrames((value, name, minLength = 0) => {\n      if (!ArrayIsArray2(value))\n        throw new ERR_INVALID_ARG_TYPE2(name, \"Array\", value);\n      if (value.length < minLength) {\n        const reason = `must be longer than ${minLength}`;\n        throw new ERR_INVALID_ARG_VALUE2(name, value, reason);\n      }\n    });\n    function validateSignalName(signal, name = \"signal\") {\n      if (validateString(signal, name), signals[signal] === void 0) {\n        if (signals[StringPrototypeToUpperCase(signal)] !== void 0)\n          throw new ERR_UNKNOWN_SIGNAL(signal + \" (signals must use all capital letters)\");\n        throw new ERR_UNKNOWN_SIGNAL(signal);\n      }\n    }\n    var validateBuffer = hideStackFrames((buffer, name = \"buffer\") => {\n      if (!isArrayBufferView(buffer))\n        throw new ERR_INVALID_ARG_TYPE2(name, [\"Buffer\", \"TypedArray\", \"DataView\"], buffer);\n    });\n    function validateEncoding(data, encoding) {\n      const normalizedEncoding = normalizeEncoding(encoding), length = data.length;\n      if (normalizedEncoding === \"hex\" && length % 2 !== 0)\n        throw new ERR_INVALID_ARG_VALUE2(\"encoding\", encoding, `is invalid for data of length ${length}`);\n    }\n    function validatePort(port, name = \"Port\", allowZero = !0) {\n      if (typeof port !== \"number\" && typeof port !== \"string\" || typeof port === \"string\" && StringPrototypeTrim(port).length === 0 || +port !== +port >>> 0 || port > 65535 || port === 0 && !allowZero)\n        throw new ERR_SOCKET_BAD_PORT(name, port, allowZero);\n      return port | 0;\n    }\n    var validateAbortSignal = hideStackFrames((signal, name) => {\n      if (signal !== void 0 && (signal === null || typeof signal !== \"object\" || !(\"aborted\" in signal)))\n        throw new ERR_INVALID_ARG_TYPE2(name, \"AbortSignal\", signal);\n    }), validateFunction = hideStackFrames((value, name) => {\n      if (typeof value !== \"function\")\n        throw new ERR_INVALID_ARG_TYPE2(name, \"Function\", value);\n    }), validatePlainFunction = hideStackFrames((value, name) => {\n      if (typeof value !== \"function\" || isAsyncFunction(value))\n        throw new ERR_INVALID_ARG_TYPE2(name, \"Function\", value);\n    }), validateUndefined = hideStackFrames((value, name) => {\n      if (value !== void 0)\n        throw new ERR_INVALID_ARG_TYPE2(name, \"undefined\", value);\n    });\n    module.exports = {\n      isInt32,\n      isUint32,\n      parseFileMode,\n      validateArray,\n      validateBoolean: validateBoolean2,\n      validateBuffer,\n      validateEncoding,\n      validateFunction,\n      validateInt32,\n      validateInteger,\n      validateNumber,\n      validateObject,\n      validateOneOf,\n      validatePlainFunction,\n      validatePort,\n      validateSignalName,\n      validateString,\n      validateUint32,\n      validateUndefined,\n      validateAbortSignal\n    };\n  }\n}), require_utils = __commonJS({\n  \"node_modules/readable-stream/lib/internal/streams/utils.js\"(exports, module) {\n    var { Symbol: Symbol2, SymbolAsyncIterator, SymbolIterator } = require_primordials(), kDestroyed = Symbol2(\"kDestroyed\"), kIsErrored = Symbol2(\"kIsErrored\"), kIsReadable = Symbol2(\"kIsReadable\"), kIsDisturbed = Symbol2(\"kIsDisturbed\");\n    function isReadableNodeStream(obj, strict = !1) {\n      var _obj$_readableState;\n      return !!(obj && typeof obj.pipe === \"function\" && typeof obj.on === \"function\" && (!strict || typeof obj.pause === \"function\" && typeof obj.resume === \"function\") && (!obj._writableState || ((_obj$_readableState = obj._readableState) === null || _obj$_readableState === void 0 \? void 0 : _obj$_readableState.readable) !== !1) && (!obj._writableState || obj._readableState));\n    }\n    function isWritableNodeStream(obj) {\n      var _obj$_writableState;\n      return !!(obj && typeof obj.write === \"function\" && typeof obj.on === \"function\" && (!obj._readableState || ((_obj$_writableState = obj._writableState) === null || _obj$_writableState === void 0 \? void 0 : _obj$_writableState.writable) !== !1));\n    }\n    function isDuplexNodeStream(obj) {\n      return !!(obj && typeof obj.pipe === \"function\" && obj._readableState && typeof obj.on === \"function\" && typeof obj.write === \"function\");\n    }\n    function isNodeStream(obj) {\n      return obj && (obj._readableState || obj._writableState || typeof obj.write === \"function\" && typeof obj.on === \"function\" || typeof obj.pipe === \"function\" && typeof obj.on === \"function\");\n    }\n    function isIterable(obj, isAsync) {\n      if (obj == null)\n        return !1;\n      if (isAsync === !0)\n        return typeof obj[SymbolAsyncIterator] === \"function\";\n      if (isAsync === !1)\n        return typeof obj[SymbolIterator] === \"function\";\n      return typeof obj[SymbolAsyncIterator] === \"function\" || typeof obj[SymbolIterator] === \"function\";\n    }\n    function isDestroyed(stream) {\n      if (!isNodeStream(stream))\n        return null;\n      const { _writableState: wState, _readableState: rState } = stream, state = wState || rState;\n      return !!(stream.destroyed || stream[kDestroyed] || state !== null && state !== void 0 && state.destroyed);\n    }\n    function isWritableEnded(stream) {\n      if (!isWritableNodeStream(stream))\n        return null;\n      if (stream.writableEnded === !0)\n        return !0;\n      const wState = stream._writableState;\n      if (wState !== null && wState !== void 0 && wState.errored)\n        return !1;\n      if (typeof (wState === null || wState === void 0 \? void 0 : wState.ended) !== \"boolean\")\n        return null;\n      return wState.ended;\n    }\n    function isWritableFinished(stream, strict) {\n      if (!isWritableNodeStream(stream))\n        return null;\n      if (stream.writableFinished === !0)\n        return !0;\n      const wState = stream._writableState;\n      if (wState !== null && wState !== void 0 && wState.errored)\n        return !1;\n      if (typeof (wState === null || wState === void 0 \? void 0 : wState.finished) !== \"boolean\")\n        return null;\n      return !!(wState.finished || strict === !1 && wState.ended === !0 && wState.length === 0);\n    }\n    function isReadableEnded(stream) {\n      if (!isReadableNodeStream(stream))\n        return null;\n      if (stream.readableEnded === !0)\n        return !0;\n      const rState = stream._readableState;\n      if (!rState || rState.errored)\n        return !1;\n      if (typeof (rState === null || rState === void 0 \? void 0 : rState.ended) !== \"boolean\")\n        return null;\n      return rState.ended;\n    }\n    function isReadableFinished(stream, strict) {\n      if (!isReadableNodeStream(stream))\n        return null;\n      const rState = stream._readableState;\n      if (rState !== null && rState !== void 0 && rState.errored)\n        return !1;\n      if (typeof (rState === null || rState === void 0 \? void 0 : rState.endEmitted) !== \"boolean\")\n        return null;\n      return !!(rState.endEmitted || strict === !1 && rState.ended === !0 && rState.length === 0);\n    }\n    function isReadable(stream) {\n      if (stream && stream[kIsReadable] != null)\n        return stream[kIsReadable];\n      if (typeof (stream === null || stream === void 0 \? void 0 : stream.readable) !== \"boolean\")\n        return null;\n      if (isDestroyed(stream))\n        return !1;\n      return isReadableNodeStream(stream) && stream.readable && !isReadableFinished(stream);\n    }\n    function isWritable(stream) {\n      if (typeof (stream === null || stream === void 0 \? void 0 : stream.writable) !== \"boolean\")\n        return null;\n      if (isDestroyed(stream))\n        return !1;\n      return isWritableNodeStream(stream) && stream.writable && !isWritableEnded(stream);\n    }\n    function isFinished(stream, opts) {\n      if (!isNodeStream(stream))\n        return null;\n      if (isDestroyed(stream))\n        return !0;\n      if ((opts === null || opts === void 0 \? void 0 : opts.readable) !== !1 && isReadable(stream))\n        return !1;\n      if ((opts === null || opts === void 0 \? void 0 : opts.writable) !== !1 && isWritable(stream))\n        return !1;\n      return !0;\n    }\n    function isWritableErrored(stream) {\n      var _stream$_writableStat, _stream$_writableStat2;\n      if (!isNodeStream(stream))\n        return null;\n      if (stream.writableErrored)\n        return stream.writableErrored;\n      return (_stream$_writableStat = (_stream$_writableStat2 = stream._writableState) === null || _stream$_writableStat2 === void 0 \? void 0 : _stream$_writableStat2.errored) !== null && _stream$_writableStat !== void 0 \? _stream$_writableStat : null;\n    }\n    function isReadableErrored(stream) {\n      var _stream$_readableStat, _stream$_readableStat2;\n      if (!isNodeStream(stream))\n        return null;\n      if (stream.readableErrored)\n        return stream.readableErrored;\n      return (_stream$_readableStat = (_stream$_readableStat2 = stream._readableState) === null || _stream$_readableStat2 === void 0 \? void 0 : _stream$_readableStat2.errored) !== null && _stream$_readableStat !== void 0 \? _stream$_readableStat : null;\n    }\n    function isClosed(stream) {\n      if (!isNodeStream(stream))\n        return null;\n      if (typeof stream.closed === \"boolean\")\n        return stream.closed;\n      const { _writableState: wState, _readableState: rState } = stream;\n      if (typeof (wState === null || wState === void 0 \? void 0 : wState.closed) === \"boolean\" || typeof (rState === null || rState === void 0 \? void 0 : rState.closed) === \"boolean\")\n        return (wState === null || wState === void 0 \? void 0 : wState.closed) || (rState === null || rState === void 0 \? void 0 : rState.closed);\n      if (typeof stream._closed === \"boolean\" && isOutgoingMessage(stream))\n        return stream._closed;\n      return null;\n    }\n    function isOutgoingMessage(stream) {\n      return typeof stream._closed === \"boolean\" && typeof stream._defaultKeepAlive === \"boolean\" && typeof stream._removedConnection === \"boolean\" && typeof stream._removedContLen === \"boolean\";\n    }\n    function isServerResponse(stream) {\n      return typeof stream._sent100 === \"boolean\" && isOutgoingMessage(stream);\n    }\n    function isServerRequest(stream) {\n      var _stream$req;\n      return typeof stream._consuming === \"boolean\" && typeof stream._dumped === \"boolean\" && ((_stream$req = stream.req) === null || _stream$req === void 0 \? void 0 : _stream$req.upgradeOrConnect) === void 0;\n    }\n    function willEmitClose(stream) {\n      if (!isNodeStream(stream))\n        return null;\n      const { _writableState: wState, _readableState: rState } = stream, state = wState || rState;\n      return !state && isServerResponse(stream) || !!(state && state.autoDestroy && state.emitClose && state.closed === !1);\n    }\n    function isDisturbed(stream) {\n      var _stream$kIsDisturbed;\n      return !!(stream && ((_stream$kIsDisturbed = stream[kIsDisturbed]) !== null && _stream$kIsDisturbed !== void 0 \? _stream$kIsDisturbed : stream.readableDidRead || stream.readableAborted));\n    }\n    function isErrored(stream) {\n      var _ref, _ref2, _ref3, _ref4, _ref5, _stream$kIsErrored, _stream$_readableStat3, _stream$_writableStat3, _stream$_readableStat4, _stream$_writableStat4;\n      return !!(stream && ((_ref = (_ref2 = (_ref3 = (_ref4 = (_ref5 = (_stream$kIsErrored = stream[kIsErrored]) !== null && _stream$kIsErrored !== void 0 \? _stream$kIsErrored : stream.readableErrored) !== null && _ref5 !== void 0 \? _ref5 : stream.writableErrored) !== null && _ref4 !== void 0 \? _ref4 : (_stream$_readableStat3 = stream._readableState) === null || _stream$_readableStat3 === void 0 \? void 0 : _stream$_readableStat3.errorEmitted) !== null && _ref3 !== void 0 \? _ref3 : (_stream$_writableStat3 = stream._writableState) === null || _stream$_writableStat3 === void 0 \? void 0 : _stream$_writableStat3.errorEmitted) !== null && _ref2 !== void 0 \? _ref2 : (_stream$_readableStat4 = stream._readableState) === null || _stream$_readableStat4 === void 0 \? void 0 : _stream$_readableStat4.errored) !== null && _ref !== void 0 \? _ref : (_stream$_writableStat4 = stream._writableState) === null || _stream$_writableStat4 === void 0 \? void 0 : _stream$_writableStat4.errored));\n    }\n    module.exports = {\n      kDestroyed,\n      isDisturbed,\n      kIsDisturbed,\n      isErrored,\n      kIsErrored,\n      isReadable,\n      kIsReadable,\n      isClosed,\n      isDestroyed,\n      isDuplexNodeStream,\n      isFinished,\n      isIterable,\n      isReadableNodeStream,\n      isReadableEnded,\n      isReadableFinished,\n      isReadableErrored,\n      isNodeStream,\n      isWritable,\n      isWritableNodeStream,\n      isWritableEnded,\n      isWritableFinished,\n      isWritableErrored,\n      isServerRequest,\n      isServerResponse,\n      willEmitClose\n    };\n  }\n}), require_end_of_stream = __commonJS({\n  \"node_modules/readable-stream/lib/internal/streams/end-of-stream.js\"(exports, module) {\n    var { AbortError: AbortError2, codes } = require_errors(), { ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE2, ERR_STREAM_PREMATURE_CLOSE } = codes, { once } = require_util(), { validateAbortSignal, validateFunction, validateObject } = require_validators(), { Promise: Promise2 } = require_primordials(), {\n      isClosed,\n      isReadable,\n      isReadableNodeStream,\n      isReadableFinished,\n      isReadableErrored,\n      isWritable,\n      isWritableNodeStream,\n      isWritableFinished,\n      isWritableErrored,\n      isNodeStream,\n      willEmitClose: _willEmitClose\n    } = require_utils();\n    function isRequest(stream) {\n      return stream.setHeader && typeof stream.abort === \"function\";\n    }\n    var nop = () => {\n    };\n    function eos(stream, options, callback) {\n      var _options$readable, _options$writable;\n      if (arguments.length === 2)\n        callback = options, options = {};\n      else if (options == null)\n        options = {};\n      else\n        validateObject(options, \"options\");\n      validateFunction(callback, \"callback\"), validateAbortSignal(options.signal, \"options.signal\"), callback = once(callback);\n      const readable = (_options$readable = options.readable) !== null && _options$readable !== void 0 \? _options$readable : isReadableNodeStream(stream), writable = (_options$writable = options.writable) !== null && _options$writable !== void 0 \? _options$writable : isWritableNodeStream(stream);\n      if (!isNodeStream(stream))\n        throw new ERR_INVALID_ARG_TYPE2(\"stream\", \"Stream\", stream);\n      const { _writableState: wState, _readableState: rState } = stream, onlegacyfinish = () => {\n        if (!stream.writable)\n          onfinish();\n      };\n      let willEmitClose = _willEmitClose(stream) && isReadableNodeStream(stream) === readable && isWritableNodeStream(stream) === writable, writableFinished = isWritableFinished(stream, !1);\n      const onfinish = () => {\n        if (writableFinished = !0, stream.destroyed)\n          willEmitClose = !1;\n        if (willEmitClose && (!stream.readable || readable))\n          return;\n        if (!readable || readableFinished)\n          callback.call(stream);\n      };\n      let readableFinished = isReadableFinished(stream, !1);\n      const onend = () => {\n        if (readableFinished = !0, stream.destroyed)\n          willEmitClose = !1;\n        if (willEmitClose && (!stream.writable || writable))\n          return;\n        if (!writable || writableFinished)\n          callback.call(stream);\n      }, onerror = (err) => {\n        callback.call(stream, err);\n      };\n      let closed = isClosed(stream);\n      const onclose = () => {\n        closed = !0;\n        const errored = isWritableErrored(stream) || isReadableErrored(stream);\n        if (errored && typeof errored !== \"boolean\")\n          return callback.call(stream, errored);\n        if (readable && !readableFinished && isReadableNodeStream(stream, !0)) {\n          if (!isReadableFinished(stream, !1))\n            return callback.call(stream, new ERR_STREAM_PREMATURE_CLOSE);\n        }\n        if (writable && !writableFinished) {\n          if (!isWritableFinished(stream, !1))\n            return callback.call(stream, new ERR_STREAM_PREMATURE_CLOSE);\n        }\n        callback.call(stream);\n      }, onrequest = () => {\n        stream.req.on(\"finish\", onfinish);\n      };\n      if (isRequest(stream)) {\n        if (stream.on(\"complete\", onfinish), !willEmitClose)\n          stream.on(\"abort\", onclose);\n        if (stream.req)\n          onrequest();\n        else\n          stream.on(\"request\", onrequest);\n      } else if (writable && !wState)\n        stream.on(\"end\", onlegacyfinish), stream.on(\"close\", onlegacyfinish);\n      if (!willEmitClose && typeof stream.aborted === \"boolean\")\n        stream.on(\"aborted\", onclose);\n      if (stream.on(\"end\", onend), stream.on(\"finish\", onfinish), options.error !== !1)\n        stream.on(\"error\", onerror);\n      if (stream.on(\"close\", onclose), closed)\n        runOnNextTick(onclose);\n      else if (wState !== null && wState !== void 0 && wState.errorEmitted || rState !== null && rState !== void 0 && rState.errorEmitted) {\n        if (!willEmitClose)\n          runOnNextTick(onclose);\n      } else if (!readable && (!willEmitClose || isReadable(stream)) && (writableFinished || isWritable(stream) === !1))\n        runOnNextTick(onclose);\n      else if (!writable && (!willEmitClose || isWritable(stream)) && (readableFinished || isReadable(stream) === !1))\n        runOnNextTick(onclose);\n      else if (rState && stream.req && stream.aborted)\n        runOnNextTick(onclose);\n      const cleanup = () => {\n        if (callback = nop, stream.removeListener(\"aborted\", onclose), stream.removeListener(\"complete\", onfinish), stream.removeListener(\"abort\", onclose), stream.removeListener(\"request\", onrequest), stream.req)\n          stream.req.removeListener(\"finish\", onfinish);\n        stream.removeListener(\"end\", onlegacyfinish), stream.removeListener(\"close\", onlegacyfinish), stream.removeListener(\"finish\", onfinish), stream.removeListener(\"end\", onend), stream.removeListener(\"error\", onerror), stream.removeListener(\"close\", onclose);\n      };\n      if (options.signal && !closed) {\n        const abort = () => {\n          const endCallback = callback;\n          cleanup(), endCallback.call(stream, new AbortError2(void 0, {\n            cause: options.signal.reason\n          }));\n        };\n        if (options.signal.aborted)\n          runOnNextTick(abort);\n        else {\n          const originalCallback = callback;\n          callback = once((...args) => {\n            options.signal.removeEventListener(\"abort\", abort), originalCallback.apply(stream, args);\n          }), options.signal.addEventListener(\"abort\", abort);\n        }\n      }\n      return cleanup;\n    }\n    function finished2(stream, opts) {\n      return new Promise2((resolve, reject) => {\n        eos(stream, opts, (err) => {\n          if (err)\n            reject(err);\n          else\n            resolve();\n        });\n      });\n    }\n    module.exports = eos, module.exports.finished = finished2;\n  }\n}), require_operators = __commonJS({\n  \"node_modules/readable-stream/lib/internal/streams/operators.js\"(exports, module) {\n    var {\n      codes: { ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE2, ERR_MISSING_ARGS, ERR_OUT_OF_RANGE },\n      AbortError: AbortError2\n    } = require_errors(), { validateAbortSignal, validateInteger, validateObject } = require_validators(), kWeakHandler = require_primordials().Symbol(\"kWeak\"), { finished: finished2 } = require_end_of_stream(), {\n      ArrayPrototypePush,\n      MathFloor,\n      Number: Number2,\n      NumberIsNaN,\n      Promise: Promise2,\n      PromiseReject,\n      PromisePrototypeCatch,\n      Symbol: Symbol2\n    } = require_primordials(), kEmpty = Symbol2(\"kEmpty\"), kEof = Symbol2(\"kEof\");\n    function map(fn, options) {\n      if (typeof fn !== \"function\")\n        throw new ERR_INVALID_ARG_TYPE2(\"fn\", [\"Function\", \"AsyncFunction\"], fn);\n      if (options != null)\n        validateObject(options, \"options\");\n      if ((options === null || options === void 0 \? void 0 : options.signal) != null)\n        validateAbortSignal(options.signal, \"options.signal\");\n      let concurrency = 1;\n      if ((options === null || options === void 0 \? void 0 : options.concurrency) != null)\n        concurrency = MathFloor(options.concurrency);\n      return validateInteger(concurrency, \"concurrency\", 1), async function* map2() {\n        var _options$signal, _options$signal2;\n        const ac = new AbortController, stream = this, queue = [], signal = ac.signal, signalOpt = {\n          signal\n        }, abort = () => ac.abort();\n        if (options !== null && options !== void 0 && (_options$signal = options.signal) !== null && _options$signal !== void 0 && _options$signal.aborted)\n          abort();\n        options === null || options === void 0 || (_options$signal2 = options.signal) === null || _options$signal2 === void 0 || _options$signal2.addEventListener(\"abort\", abort);\n        let next, resume, done = !1;\n        function onDone() {\n          done = !0;\n        }\n        async function pump() {\n          try {\n            for await (let val of stream) {\n              var _val;\n              if (done)\n                return;\n              if (signal.aborted)\n                throw new AbortError2;\n              try {\n                val = fn(val, signalOpt);\n              } catch (err) {\n                val = PromiseReject(err);\n              }\n              if (val === kEmpty)\n                continue;\n              if (typeof ((_val = val) === null || _val === void 0 \? void 0 : _val.catch) === \"function\")\n                val.catch(onDone);\n              if (queue.push(val), next)\n                next(), next = null;\n              if (!done && queue.length && queue.length >= concurrency)\n                await new Promise2((resolve) => {\n                  resume = resolve;\n                });\n            }\n            queue.push(kEof);\n          } catch (err) {\n            const val = PromiseReject(err);\n            PromisePrototypeCatch(val, onDone), queue.push(val);\n          } finally {\n            var _options$signal3;\n            if (done = !0, next)\n              next(), next = null;\n            options === null || options === void 0 || (_options$signal3 = options.signal) === null || _options$signal3 === void 0 || _options$signal3.removeEventListener(\"abort\", abort);\n          }\n        }\n        pump();\n        try {\n          while (!0) {\n            while (queue.length > 0) {\n              const val = await queue[0];\n              if (val === kEof)\n                return;\n              if (signal.aborted)\n                throw new AbortError2;\n              if (val !== kEmpty)\n                yield val;\n              if (queue.shift(), resume)\n                resume(), resume = null;\n            }\n            await new Promise2((resolve) => {\n              next = resolve;\n            });\n          }\n        } finally {\n          if (ac.abort(), done = !0, resume)\n            resume(), resume = null;\n        }\n      }.call(this);\n    }\n    function asIndexedPairs(options = void 0) {\n      if (options != null)\n        validateObject(options, \"options\");\n      if ((options === null || options === void 0 \? void 0 : options.signal) != null)\n        validateAbortSignal(options.signal, \"options.signal\");\n      return async function* asIndexedPairs2() {\n        let index = 0;\n        for await (let val of this) {\n          var _options$signal4;\n          if (options !== null && options !== void 0 && (_options$signal4 = options.signal) !== null && _options$signal4 !== void 0 && _options$signal4.aborted)\n            throw new AbortError2({\n              cause: options.signal.reason\n            });\n          yield [index++, val];\n        }\n      }.call(this);\n    }\n    async function some(fn, options = void 0) {\n      for await (let unused of filter.call(this, fn, options))\n        return !0;\n      return !1;\n    }\n    async function every(fn, options = void 0) {\n      if (typeof fn !== \"function\")\n        throw new ERR_INVALID_ARG_TYPE2(\"fn\", [\"Function\", \"AsyncFunction\"], fn);\n      return !await some.call(this, async (...args) => {\n        return !await fn(...args);\n      }, options);\n    }\n    async function find(fn, options) {\n      for await (let result of filter.call(this, fn, options))\n        return result;\n      return;\n    }\n    async function forEach(fn, options) {\n      if (typeof fn !== \"function\")\n        throw new ERR_INVALID_ARG_TYPE2(\"fn\", [\"Function\", \"AsyncFunction\"], fn);\n      async function forEachFn(value, options2) {\n        return await fn(value, options2), kEmpty;\n      }\n      for await (let unused of map.call(this, forEachFn, options))\n        ;\n    }\n    function filter(fn, options) {\n      if (typeof fn !== \"function\")\n        throw new ERR_INVALID_ARG_TYPE2(\"fn\", [\"Function\", \"AsyncFunction\"], fn);\n      async function filterFn(value, options2) {\n        if (await fn(value, options2))\n          return value;\n        return kEmpty;\n      }\n      return map.call(this, filterFn, options);\n    }\n    var ReduceAwareErrMissingArgs = class extends ERR_MISSING_ARGS {\n      constructor() {\n        super(\"reduce\");\n        this.message = \"Reduce of an empty stream requires an initial value\";\n      }\n    };\n    async function reduce(reducer, initialValue, options) {\n      var _options$signal5;\n      if (typeof reducer !== \"function\")\n        throw new ERR_INVALID_ARG_TYPE2(\"reducer\", [\"Function\", \"AsyncFunction\"], reducer);\n      if (options != null)\n        validateObject(options, \"options\");\n      if ((options === null || options === void 0 \? void 0 : options.signal) != null)\n        validateAbortSignal(options.signal, \"options.signal\");\n      let hasInitialValue = arguments.length > 1;\n      if (options !== null && options !== void 0 && (_options$signal5 = options.signal) !== null && _options$signal5 !== void 0 && _options$signal5.aborted) {\n        const err = new AbortError2(void 0, {\n          cause: options.signal.reason\n        });\n        throw this.once(\"error\", () => {\n        }), await finished2(this.destroy(err)), err;\n      }\n      const ac = new AbortController, signal = ac.signal;\n      if (options !== null && options !== void 0 && options.signal) {\n        const opts = {\n          once: !0,\n          [kWeakHandler]: this\n        };\n        options.signal.addEventListener(\"abort\", () => ac.abort(), opts);\n      }\n      let gotAnyItemFromStream = !1;\n      try {\n        for await (let value of this) {\n          var _options$signal6;\n          if (gotAnyItemFromStream = !0, options !== null && options !== void 0 && (_options$signal6 = options.signal) !== null && _options$signal6 !== void 0 && _options$signal6.aborted)\n            throw new AbortError2;\n          if (!hasInitialValue)\n            initialValue = value, hasInitialValue = !0;\n          else\n            initialValue = await reducer(initialValue, value, {\n              signal\n            });\n        }\n        if (!gotAnyItemFromStream && !hasInitialValue)\n          throw new ReduceAwareErrMissingArgs;\n      } finally {\n        ac.abort();\n      }\n      return initialValue;\n    }\n    async function toArray(options) {\n      if (options != null)\n        validateObject(options, \"options\");\n      if ((options === null || options === void 0 \? void 0 : options.signal) != null)\n        validateAbortSignal(options.signal, \"options.signal\");\n      const result = [];\n      for await (let val of this) {\n        var _options$signal7;\n        if (options !== null && options !== void 0 && (_options$signal7 = options.signal) !== null && _options$signal7 !== void 0 && _options$signal7.aborted)\n          throw new AbortError2(void 0, {\n            cause: options.signal.reason\n          });\n        ArrayPrototypePush(result, val);\n      }\n      return result;\n    }\n    function flatMap(fn, options) {\n      const values = map.call(this, fn, options);\n      return async function* flatMap2() {\n        for await (let val of values)\n          yield* val;\n      }.call(this);\n    }\n    function toIntegerOrInfinity(number) {\n      if (number = Number2(number), NumberIsNaN(number))\n        return 0;\n      if (number < 0)\n        throw new ERR_OUT_OF_RANGE(\"number\", \">= 0\", number);\n      return number;\n    }\n    function drop(number, options = void 0) {\n      if (options != null)\n        validateObject(options, \"options\");\n      if ((options === null || options === void 0 \? void 0 : options.signal) != null)\n        validateAbortSignal(options.signal, \"options.signal\");\n      return number = toIntegerOrInfinity(number), async function* drop2() {\n        var _options$signal8;\n        if (options !== null && options !== void 0 && (_options$signal8 = options.signal) !== null && _options$signal8 !== void 0 && _options$signal8.aborted)\n          throw new AbortError2;\n        for await (let val of this) {\n          var _options$signal9;\n          if (options !== null && options !== void 0 && (_options$signal9 = options.signal) !== null && _options$signal9 !== void 0 && _options$signal9.aborted)\n            throw new AbortError2;\n          if (number-- <= 0)\n            yield val;\n        }\n      }.call(this);\n    }\n    function take(number, options = void 0) {\n      if (options != null)\n        validateObject(options, \"options\");\n      if ((options === null || options === void 0 \? void 0 : options.signal) != null)\n        validateAbortSignal(options.signal, \"options.signal\");\n      return number = toIntegerOrInfinity(number), async function* take2() {\n        var _options$signal10;\n        if (options !== null && options !== void 0 && (_options$signal10 = options.signal) !== null && _options$signal10 !== void 0 && _options$signal10.aborted)\n          throw new AbortError2;\n        for await (let val of this) {\n          var _options$signal11;\n          if (options !== null && options !== void 0 && (_options$signal11 = options.signal) !== null && _options$signal11 !== void 0 && _options$signal11.aborted)\n            throw new AbortError2;\n          if (number-- > 0)\n            yield val;\n          else\n            return;\n        }\n      }.call(this);\n    }\n    module.exports.streamReturningOperators = {\n      asIndexedPairs,\n      drop,\n      filter,\n      flatMap,\n      map,\n      take\n    }, module.exports.promiseReturningOperators = {\n      every,\n      forEach,\n      reduce,\n      toArray,\n      some,\n      find\n    };\n  }\n}), require_destroy = __commonJS({\n  \"node_modules/readable-stream/lib/internal/streams/destroy.js\"(exports, module) {\n    var {\n      aggregateTwoErrors,\n      codes: { ERR_MULTIPLE_CALLBACK },\n      AbortError: AbortError2\n    } = require_errors(), { Symbol: Symbol2 } = require_primordials(), { kDestroyed, isDestroyed, isFinished, isServerRequest } = require_utils(), kDestroy = \"#kDestroy\", kConstruct = \"#kConstruct\";\n    function checkError(err, w, r) {\n      if (err) {\n        if (err.stack, w && !w.errored)\n          w.errored = err;\n        if (r && !r.errored)\n          r.errored = err;\n      }\n    }\n    function destroy2(err, cb) {\n      const r = this._readableState, w = this._writableState, s = w || r;\n      if (w && w.destroyed || r && r.destroyed) {\n        if (typeof cb === \"function\")\n          cb();\n        return this;\n      }\n      if (checkError(err, w, r), w)\n        w.destroyed = !0;\n      if (r)\n        r.destroyed = !0;\n      if (!s.constructed)\n        this.once(kDestroy, (er) => {\n          _destroy(this, aggregateTwoErrors(er, err), cb);\n        });\n      else\n        _destroy(this, err, cb);\n      return this;\n    }\n    function _destroy(self, err, cb) {\n      let called = !1;\n      function onDestroy(err2) {\n        if (called)\n          return;\n        called = !0;\n        const { _readableState: r, _writableState: w } = self;\n        if (checkError(err2, w, r), w)\n          w.closed = !0;\n        if (r)\n          r.closed = !0;\n        if (typeof cb === \"function\")\n          cb(err2);\n        if (err2)\n          runOnNextTick(emitErrorCloseNT, self, err2);\n        else\n          runOnNextTick(emitCloseNT, self);\n      }\n      try {\n        self._destroy(err || null, onDestroy);\n      } catch (err2) {\n        onDestroy(err2);\n      }\n    }\n    function emitErrorCloseNT(self, err) {\n      emitErrorNT(self, err), emitCloseNT(self);\n    }\n    function emitCloseNT(self) {\n      const { _readableState: r, _writableState: w } = self;\n      if (w)\n        w.closeEmitted = !0;\n      if (r)\n        r.closeEmitted = !0;\n      if (w && w.emitClose || r && r.emitClose)\n        self.emit(\"close\");\n    }\n    function emitErrorNT(self, err) {\n      const r = self\?._readableState, w = self\?._writableState;\n      if (w\?.errorEmitted || r\?.errorEmitted)\n        return;\n      if (w)\n        w.errorEmitted = !0;\n      if (r)\n        r.errorEmitted = !0;\n      self\?.emit\?.(\"error\", err);\n    }\n    function undestroy() {\n      const r = this._readableState, w = this._writableState;\n      if (r)\n        r.constructed = !0, r.closed = !1, r.closeEmitted = !1, r.destroyed = !1, r.errored = null, r.errorEmitted = !1, r.reading = !1, r.ended = r.readable === !1, r.endEmitted = r.readable === !1;\n      if (w)\n        w.constructed = !0, w.destroyed = !1, w.closed = !1, w.closeEmitted = !1, w.errored = null, w.errorEmitted = !1, w.finalCalled = !1, w.prefinished = !1, w.ended = w.writable === !1, w.ending = w.writable === !1, w.finished = w.writable === !1;\n    }\n    function errorOrDestroy2(stream, err, sync) {\n      const r = stream\?._readableState, w = stream\?._writableState;\n      if (w && w.destroyed || r && r.destroyed)\n        return this;\n      if (r && r.autoDestroy || w && w.autoDestroy)\n        stream.destroy(err);\n      else if (err) {\n        if (Error.captureStackTrace(err), w && !w.errored)\n          w.errored = err;\n        if (r && !r.errored)\n          r.errored = err;\n        if (sync)\n          runOnNextTick(emitErrorNT, stream, err);\n        else\n          emitErrorNT(stream, err);\n      }\n    }\n    function construct(stream, cb) {\n      if (typeof stream._construct !== \"function\")\n        return;\n      const { _readableState: r, _writableState: w } = stream;\n      if (r)\n        r.constructed = !1;\n      if (w)\n        w.constructed = !1;\n      if (stream.once(kConstruct, cb), stream.listenerCount(kConstruct) > 1)\n        return;\n      runOnNextTick(constructNT, stream);\n    }\n    function constructNT(stream) {\n      let called = !1;\n      function onConstruct(err) {\n        if (called) {\n          errorOrDestroy2(stream, err !== null && err !== void 0 \? err : new ERR_MULTIPLE_CALLBACK);\n          return;\n        }\n        called = !0;\n        const { _readableState: r, _writableState: w } = stream, s = w || r;\n        if (r)\n          r.constructed = !0;\n        if (w)\n          w.constructed = !0;\n        if (s.destroyed)\n          stream.emit(kDestroy, err);\n        else if (err)\n          errorOrDestroy2(stream, err, !0);\n        else\n          runOnNextTick(emitConstructNT, stream);\n      }\n      try {\n        stream._construct(onConstruct);\n      } catch (err) {\n        onConstruct(err);\n      }\n    }\n    function emitConstructNT(stream) {\n      stream.emit(kConstruct);\n    }\n    function isRequest(stream) {\n      return stream && stream.setHeader && typeof stream.abort === \"function\";\n    }\n    function emitCloseLegacy(stream) {\n      stream.emit(\"close\");\n    }\n    function emitErrorCloseLegacy(stream, err) {\n      stream.emit(\"error\", err), runOnNextTick(emitCloseLegacy, stream);\n    }\n    function destroyer(stream, err) {\n      if (!stream || isDestroyed(stream))\n        return;\n      if (!err && !isFinished(stream))\n        err = new AbortError2;\n      if (isServerRequest(stream))\n        stream.socket = null, stream.destroy(err);\n      else if (isRequest(stream))\n        stream.abort();\n      else if (isRequest(stream.req))\n        stream.req.abort();\n      else if (typeof stream.destroy === \"function\")\n        stream.destroy(err);\n      else if (typeof stream.close === \"function\")\n        stream.close();\n      else if (err)\n        runOnNextTick(emitErrorCloseLegacy, stream);\n      else\n        runOnNextTick(emitCloseLegacy, stream);\n      if (!stream.destroyed)\n        stream[kDestroyed] = !0;\n    }\n    module.exports = {\n      construct,\n      destroyer,\n      destroy: destroy2,\n      undestroy,\n      errorOrDestroy: errorOrDestroy2\n    };\n  }\n}), require_legacy = __commonJS({\n  \"node_modules/readable-stream/lib/internal/streams/legacy.js\"(exports, module) {\n    var { ArrayIsArray: ArrayIsArray2, ObjectSetPrototypeOf } = require_primordials();\n    function Stream(options) {\n      if (!(this instanceof Stream))\n        return new Stream(options);\n      EE.call(this, options);\n    }\n    Stream.prototype = {}, ObjectSetPrototypeOf(Stream.prototype, EE.prototype), ObjectSetPrototypeOf(Stream, EE), Stream.prototype.pipe = function(dest, options) {\n      const source = this;\n      function ondata(chunk) {\n        if (dest.writable && dest.write(chunk) === !1 && source.pause)\n          source.pause();\n      }\n      source.on(\"data\", ondata);\n      function ondrain() {\n        if (source.readable && source.resume)\n          source.resume();\n      }\n      if (dest.on(\"drain\", ondrain), !dest._isStdio && (!options || options.end !== !1))\n        source.on(\"end\", onend), source.on(\"close\", onclose);\n      let didOnEnd = !1;\n      function onend() {\n        if (didOnEnd)\n          return;\n        didOnEnd = !0, dest.end();\n      }\n      function onclose() {\n        if (didOnEnd)\n          return;\n        if (didOnEnd = !0, typeof dest.destroy === \"function\")\n          dest.destroy();\n      }\n      function onerror(er) {\n        if (cleanup(), EE.listenerCount(this, \"error\") === 0)\n          this.emit(\"error\", er);\n      }\n      prependListener(source, \"error\", onerror), prependListener(dest, \"error\", onerror);\n      function cleanup() {\n        source.removeListener(\"data\", ondata), dest.removeListener(\"drain\", ondrain), source.removeListener(\"end\", onend), source.removeListener(\"close\", onclose), source.removeListener(\"error\", onerror), dest.removeListener(\"error\", onerror), source.removeListener(\"end\", cleanup), source.removeListener(\"close\", cleanup), dest.removeListener(\"close\", cleanup);\n      }\n      return source.on(\"end\", cleanup), source.on(\"close\", cleanup), dest.on(\"close\", cleanup), dest.emit(\"pipe\", source), dest;\n    };\n    function prependListener(emitter, event, fn) {\n      if (typeof emitter.prependListener === \"function\")\n        return emitter.prependListener(event, fn);\n      if (!emitter._events || !emitter._events[event])\n        emitter.on(event, fn);\n      else if (ArrayIsArray2(emitter._events[event]))\n        emitter._events[event].unshift(fn);\n      else\n        emitter._events[event] = [fn, emitter._events[event]];\n    }\n    module.exports = {\n      Stream,\n      prependListener\n    };\n  }\n}), require_add_abort_signal = __commonJS({\n  \"node_modules/readable-stream/lib/internal/streams/add-abort-signal.js\"(exports, module) {\n    var { AbortError: AbortError2, codes } = require_errors(), eos = require_end_of_stream(), { ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE2 } = codes, validateAbortSignal = (signal, name) => {\n      if (typeof signal !== \"object\" || !(\"aborted\" in signal))\n        throw new ERR_INVALID_ARG_TYPE2(name, \"AbortSignal\", signal);\n    };\n    function isNodeStream(obj) {\n      return !!(obj && typeof obj.pipe === \"function\");\n    }\n    module.exports.addAbortSignal = function addAbortSignal(signal, stream) {\n      if (validateAbortSignal(signal, \"signal\"), !isNodeStream(stream))\n        throw new ERR_INVALID_ARG_TYPE2(\"stream\", \"stream.Stream\", stream);\n      return module.exports.addAbortSignalNoValidate(signal, stream);\n    }, module.exports.addAbortSignalNoValidate = function(signal, stream) {\n      if (typeof signal !== \"object\" || !(\"aborted\" in signal))\n        return stream;\n      const onAbort = () => {\n        stream.destroy(new AbortError2(void 0, {\n          cause: signal.reason\n        }));\n      };\n      if (signal.aborted)\n        onAbort();\n      else\n        signal.addEventListener(\"abort\", onAbort), eos(stream, () => signal.removeEventListener(\"abort\", onAbort));\n      return stream;\n    };\n  }\n}), require_state = __commonJS({\n  \"node_modules/readable-stream/lib/internal/streams/state.js\"(exports, module) {\n    var { MathFloor, NumberIsInteger } = require_primordials(), { ERR_INVALID_ARG_VALUE: ERR_INVALID_ARG_VALUE2 } = require_errors().codes;\n    function highWaterMarkFrom(options, isDuplex, duplexKey) {\n      return options.highWaterMark != null \? options.highWaterMark : isDuplex \? options[duplexKey] : null;\n    }\n    function getDefaultHighWaterMark(objectMode) {\n      return objectMode \? 16 : 16384;\n    }\n    function getHighWaterMark(state, options, duplexKey, isDuplex) {\n      const hwm = highWaterMarkFrom(options, isDuplex, duplexKey);\n      if (hwm != null) {\n        if (!NumberIsInteger(hwm) || hwm < 0) {\n          const name = isDuplex \? `options.${duplexKey}` : \"options.highWaterMark\";\n          throw new ERR_INVALID_ARG_VALUE2(name, hwm);\n        }\n        return MathFloor(hwm);\n      }\n      return getDefaultHighWaterMark(state.objectMode);\n    }\n    module.exports = {\n      getHighWaterMark,\n      getDefaultHighWaterMark\n    };\n  }\n}), require_from = __commonJS({\n  \"node_modules/readable-stream/lib/internal/streams/from.js\"(exports, module) {\n    var { PromisePrototypeThen, SymbolAsyncIterator, SymbolIterator } = require_primordials(), { ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE2, ERR_STREAM_NULL_VALUES } = require_errors().codes;\n    function from(Readable, iterable, opts) {\n      let iterator;\n      if (typeof iterable === \"string\" || iterable instanceof Buffer)\n        return new Readable({\n          objectMode: !0,\n          ...opts,\n          read() {\n            this.push(iterable), this.push(null);\n          }\n        });\n      let isAsync;\n      if (iterable && iterable[SymbolAsyncIterator])\n        isAsync = !0, iterator = iterable[SymbolAsyncIterator]();\n      else if (iterable && iterable[SymbolIterator])\n        isAsync = !1, iterator = iterable[SymbolIterator]();\n      else\n        throw new ERR_INVALID_ARG_TYPE2(\"iterable\", [\"Iterable\"], iterable);\n      const readable = new Readable({\n        objectMode: !0,\n        highWaterMark: 1,\n        ...opts\n      });\n      let reading = !1;\n      readable._read = function() {\n        if (!reading)\n          reading = !0, next();\n      }, readable._destroy = function(error, cb) {\n        PromisePrototypeThen(close(error), () => runOnNextTick(cb, error), (e) => runOnNextTick(cb, e || error));\n      };\n      async function close(error) {\n        const hadError = error !== void 0 && error !== null, hasThrow = typeof iterator.throw === \"function\";\n        if (hadError && hasThrow) {\n          const { value, done } = await iterator.throw(error);\n          if (await value, done)\n            return;\n        }\n        if (typeof iterator.return === \"function\") {\n          const { value } = await iterator.return();\n          await value;\n        }\n      }\n      async function next() {\n        for (;; ) {\n          try {\n            const { value, done } = isAsync \? await iterator.next() : iterator.next();\n            if (done)\n              readable.push(null);\n            else {\n              const res = value && typeof value.then === \"function\" \? await value : value;\n              if (res === null)\n                throw reading = !1, new ERR_STREAM_NULL_VALUES;\n              else if (readable.push(res))\n                continue;\n              else\n                reading = !1;\n            }\n          } catch (err) {\n            readable.destroy(err);\n          }\n          break;\n        }\n      }\n      return readable;\n    }\n    module.exports = from;\n  }\n}), _ReadableFromWeb, _ReadableFromWebForUndici, require_readable = __commonJS({\n  \"node_modules/readable-stream/lib/internal/streams/readable.js\"(exports, module) {\n    var {\n      ArrayPrototypeIndexOf,\n      NumberIsInteger,\n      NumberIsNaN,\n      NumberParseInt,\n      ObjectDefineProperties,\n      ObjectKeys,\n      ObjectSetPrototypeOf,\n      Promise: Promise2,\n      SafeSet,\n      SymbolAsyncIterator,\n      Symbol: Symbol2\n    } = require_primordials(), ReadableState = globalThis[globalThis.Symbol.for('Bun.lazy')](\"bun:stream\").ReadableState, { Stream, prependListener } = require_legacy();\n    function Readable(options) {\n      if (!(this instanceof Readable))\n        return new Readable(options);\n      const isDuplex = this instanceof require_duplex();\n      if (this._readableState = new ReadableState(options, this, isDuplex), options) {\n        const { read, destroy: destroy2, construct, signal } = options;\n        if (typeof read === \"function\")\n          this._read = read;\n        if (typeof destroy2 === \"function\")\n          this._destroy = destroy2;\n        if (typeof construct === \"function\")\n          this._construct = construct;\n        if (signal && !isDuplex)\n          addAbortSignal(signal, this);\n      }\n      Stream.call(this, options), destroyImpl.construct(this, () => {\n        if (this._readableState.needReadable)\n          maybeReadMore(this, this._readableState);\n      });\n    }\n    Readable.prototype = {}, ObjectSetPrototypeOf(Readable.prototype, Stream.prototype), ObjectSetPrototypeOf(Readable, Stream), Readable.prototype.on = function(ev, fn) {\n      const res = Stream.prototype.on.call(this, ev, fn), state = this._readableState;\n      if (ev === \"data\") {\n        if (state.readableListening = this.listenerCount(\"readable\") > 0, state.flowing !== !1)\n          this.resume();\n      } else if (ev === \"readable\") {\n        if (!state.endEmitted && !state.readableListening) {\n          if (state.readableListening = state.needReadable = !0, state.flowing = !1, state.emittedReadable = !1, state.length)\n            emitReadable(this, state);\n          else if (!state.reading)\n            runOnNextTick(nReadingNextTick, this);\n        } else if (state.endEmitted)\n          ;\n      }\n      return res;\n    };\n\n    class ReadableFromWeb extends Readable {\n      #reader;\n      #closed;\n      #pendingChunks;\n      #stream;\n      constructor(options, stream) {\n        const { objectMode, highWaterMark, encoding, signal } = options;\n        super({\n          objectMode,\n          highWaterMark,\n          encoding,\n          signal\n        });\n        this.#pendingChunks = [], this.#reader = void 0, this.#stream = stream, this.#closed = !1;\n      }\n      #drainPending() {\n        var pendingChunks = this.#pendingChunks, pendingChunksI = 0, pendingChunksCount = pendingChunks.length;\n        for (;pendingChunksI < pendingChunksCount; pendingChunksI++) {\n          const chunk = pendingChunks[pendingChunksI];\n          if (pendingChunks[pendingChunksI] = void 0, !this.push(chunk, void 0))\n            return this.#pendingChunks = pendingChunks.slice(pendingChunksI + 1), !0;\n        }\n        if (pendingChunksCount > 0)\n          this.#pendingChunks = [];\n        return !1;\n      }\n      #handleDone(reader) {\n        reader.releaseLock(), this.#reader = void 0, this.#closed = !0, this.push(null);\n        return;\n      }\n      async _read() {\n        var stream = this.#stream, reader = this.#reader;\n        if (stream)\n          reader = this.#reader = stream.getReader(), this.#stream = void 0;\n        else if (this.#drainPending())\n          return;\n        var deferredError;\n        try {\n          do {\n            var done = !1, value;\n            const firstResult = reader.readMany();\n            if (@isPromise(firstResult)) {\n              if ({ done, value } = await firstResult, this.#closed) {\n                this.#pendingChunks.push(...value);\n                return;\n              }\n            } else\n              ({ done, value } = firstResult);\n            if (done) {\n              this.#handleDone(reader);\n              return;\n            }\n            if (!this.push(value[0])) {\n              this.#pendingChunks = value.slice(1);\n              return;\n            }\n            for (let i = 1, count = value.length;i < count; i++)\n              if (!this.push(value[i])) {\n                this.#pendingChunks = value.slice(i + 1);\n                return;\n              }\n          } while (!this.#closed);\n        } catch (e) {\n          deferredError = e;\n        } finally {\n          if (deferredError)\n            throw deferredError;\n        }\n      }\n      _destroy(error, callback) {\n        if (!this.#closed) {\n          var reader = this.#reader;\n          if (reader)\n            this.#reader = void 0, reader.cancel(error).finally(() => {\n              this.#closed = !0, callback(error);\n            });\n          return;\n        }\n        try {\n          callback(error);\n        } catch (error2) {\n          globalThis.reportError(error2);\n        }\n      }\n    }\n    _ReadableFromWebForUndici = ReadableFromWeb;\n    function newStreamReadableFromReadableStream(readableStream, options = {}) {\n      if (!isReadableStream(readableStream))\n        throw new ERR_INVALID_ARG_TYPE2(\"readableStream\", \"ReadableStream\", readableStream);\n      validateObject(options, \"options\");\n      const {\n        highWaterMark,\n        encoding,\n        objectMode = !1,\n        signal\n      } = options;\n      if (encoding !== void 0 && !Buffer.isEncoding(encoding))\n        throw new ERR_INVALID_ARG_VALUE(encoding, \"options.encoding\");\n      return validateBoolean(objectMode, \"options.objectMode\"), getNativeReadableStream(Readable, readableStream, options) || new ReadableFromWeb({\n        highWaterMark,\n        encoding,\n        objectMode,\n        signal\n      }, readableStream);\n    }\n    module.exports = Readable, _ReadableFromWeb = newStreamReadableFromReadableStream;\n    var { addAbortSignal } = require_add_abort_signal(), eos = require_end_of_stream();\n    const { maybeReadMore: _maybeReadMore, resume, emitReadable: _emitReadable, onEofChunk } = globalThis[globalThis.Symbol.for('Bun.lazy')](\"bun:stream\");\n    function maybeReadMore(stream, state) {\n      process.nextTick(_maybeReadMore, stream, state);\n    }\n    function emitReadable(stream, state) {\n      _emitReadable(stream, state);\n    }\n    var destroyImpl = require_destroy(), {\n      aggregateTwoErrors,\n      codes: {\n        ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE2,\n        ERR_METHOD_NOT_IMPLEMENTED,\n        ERR_OUT_OF_RANGE,\n        ERR_STREAM_PUSH_AFTER_EOF,\n        ERR_STREAM_UNSHIFT_AFTER_END_EVENT\n      }\n    } = require_errors(), { validateObject } = require_validators(), from = require_from(), nop = () => {\n    }, { errorOrDestroy: errorOrDestroy2 } = destroyImpl;\n    Readable.prototype.destroy = destroyImpl.destroy, Readable.prototype._undestroy = destroyImpl.undestroy, Readable.prototype._destroy = function(err, cb) {\n      cb(err);\n    }, Readable.prototype[EE.captureRejectionSymbol] = function(err) {\n      this.destroy(err);\n    }, Readable.prototype.push = function(chunk, encoding) {\n      return readableAddChunk(this, chunk, encoding, !1);\n    }, Readable.prototype.unshift = function(chunk, encoding) {\n      return readableAddChunk(this, chunk, encoding, !0);\n    };\n    function readableAddChunk(stream, chunk, encoding, addToFront) {\n      const state = stream._readableState;\n      let err;\n      if (!state.objectMode) {\n        if (typeof chunk === \"string\") {\n          if (encoding = encoding || state.defaultEncoding, state.encoding !== encoding)\n            if (addToFront && state.encoding)\n              chunk = Buffer.from(chunk, encoding).toString(state.encoding);\n            else\n              chunk = Buffer.from(chunk, encoding), encoding = \"\";\n        } else if (chunk instanceof Buffer)\n          encoding = \"\";\n        else if (Stream._isUint8Array(chunk)) {\n          if (addToFront || !state.decoder)\n            chunk = Stream._uint8ArrayToBuffer(chunk);\n          encoding = \"\";\n        } else if (chunk != null)\n          err = new ERR_INVALID_ARG_TYPE2(\"chunk\", [\"string\", \"Buffer\", \"Uint8Array\"], chunk);\n      }\n      if (err)\n        errorOrDestroy2(stream, err);\n      else if (chunk === null)\n        state.reading = !1, onEofChunk(stream, state);\n      else if (state.objectMode || chunk && chunk.length > 0)\n        if (addToFront)\n          if (state.endEmitted)\n            errorOrDestroy2(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT);\n          else if (state.destroyed || state.errored)\n            return !1;\n          else\n            addChunk(stream, state, chunk, !0);\n        else if (state.ended)\n          errorOrDestroy2(stream, new ERR_STREAM_PUSH_AFTER_EOF);\n        else if (state.destroyed || state.errored)\n          return !1;\n        else if (state.reading = !1, state.decoder && !encoding)\n          if (chunk = state.decoder.write(chunk), state.objectMode || chunk.length !== 0)\n            addChunk(stream, state, chunk, !1);\n          else\n            maybeReadMore(stream, state);\n        else\n          addChunk(stream, state, chunk, !1);\n      else if (!addToFront)\n        state.reading = !1, maybeReadMore(stream, state);\n      return !state.ended && (state.length < state.highWaterMark || state.length === 0);\n    }\n    function addChunk(stream, state, chunk, addToFront) {\n      if (state.flowing && state.length === 0 && !state.sync && stream.listenerCount(\"data\") > 0) {\n        if (state.multiAwaitDrain)\n          state.awaitDrainWriters.clear();\n        else\n          state.awaitDrainWriters = null;\n        state.dataEmitted = !0, stream.emit(\"data\", chunk);\n      } else {\n        if (state.length += state.objectMode \? 1 : chunk.length, addToFront)\n          state.buffer.unshift(chunk);\n        else\n          state.buffer.push(chunk);\n        if (state.needReadable)\n          emitReadable(stream, state);\n      }\n      maybeReadMore(stream, state);\n    }\n    Readable.prototype.isPaused = function() {\n      const state = this._readableState;\n      return state.paused === !0 || state.flowing === !1;\n    }, Readable.prototype.setEncoding = function(enc) {\n      const decoder = new StringDecoder(enc);\n      this._readableState.decoder = decoder, this._readableState.encoding = this._readableState.decoder.encoding;\n      const buffer = this._readableState.buffer;\n      let content = \"\";\n      for (let i = buffer.length;i > 0; i--)\n        content += decoder.write(buffer.shift());\n      if (content !== \"\")\n        buffer.push(content);\n      return this._readableState.length = content.length, this;\n    };\n    var MAX_HWM = 1073741824;\n    function computeNewHighWaterMark(n) {\n      if (n > MAX_HWM)\n        throw new ERR_OUT_OF_RANGE(\"size\", \"<= 1GiB\", n);\n      else\n        n--, n |= n >>> 1, n |= n >>> 2, n |= n >>> 4, n |= n >>> 8, n |= n >>> 16, n++;\n      return n;\n    }\n    function howMuchToRead(n, state) {\n      if (n <= 0 || state.length === 0 && state.ended)\n        return 0;\n      if (state.objectMode)\n        return 1;\n      if (NumberIsNaN(n)) {\n        if (state.flowing && state.length)\n          return state.buffer.first().length;\n        return state.length;\n      }\n      if (n <= state.length)\n        return n;\n      return state.ended \? state.length : 0;\n    }\n    Readable.prototype.read = function(n) {\n      if (!NumberIsInteger(n))\n        n = NumberParseInt(n, 10);\n      const state = this._readableState, nOrig = n;\n      if (n > state.highWaterMark)\n        state.highWaterMark = computeNewHighWaterMark(n);\n      if (n !== 0)\n        state.emittedReadable = !1;\n      if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 \? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {\n        if (state.length === 0 && state.ended)\n          endReadable(this);\n        else\n          emitReadable(this, state);\n        return null;\n      }\n      if (n = howMuchToRead(n, state), n === 0 && state.ended) {\n        if (state.length === 0)\n          endReadable(this);\n        return null;\n      }\n      let doRead = state.needReadable;\n      if (state.length === 0 || state.length - n < state.highWaterMark)\n        doRead = !0;\n      if (state.ended || state.reading || state.destroyed || state.errored || !state.constructed)\n        doRead = !1;\n      else if (doRead) {\n        if (state.reading = !0, state.sync = !0, state.length === 0)\n          state.needReadable = !0;\n        try {\n          var result = this._read(state.highWaterMark);\n          if (@isPromise(result)) {\n            const peeked = Bun.peek(result);\n            if (peeked !== result)\n              result = peeked;\n          }\n          if (@isPromise(result) && result\?.then && @isCallable(result.then))\n            result.then(nop, function(err) {\n              errorOrDestroy2(this, err);\n            });\n        } catch (err) {\n          errorOrDestroy2(this, err);\n        }\n        if (state.sync = !1, !state.reading)\n          n = howMuchToRead(nOrig, state);\n      }\n      let ret;\n      if (n > 0)\n        ret = fromList(n, state);\n      else\n        ret = null;\n      if (ret === null)\n        state.needReadable = state.length <= state.highWaterMark, n = 0;\n      else if (state.length -= n, state.multiAwaitDrain)\n        state.awaitDrainWriters.clear();\n      else\n        state.awaitDrainWriters = null;\n      if (state.length === 0) {\n        if (!state.ended)\n          state.needReadable = !0;\n        if (nOrig !== n && state.ended)\n          endReadable(this);\n      }\n      if (ret !== null && !state.errorEmitted && !state.closeEmitted)\n        state.dataEmitted = !0, this.emit(\"data\", ret);\n      return ret;\n    }, Readable.prototype._read = function(n) {\n      throw new ERR_METHOD_NOT_IMPLEMENTED(\"_read()\");\n    }, Readable.prototype.pipe = function(dest, pipeOpts) {\n      const src = this, state = this._readableState;\n      if (state.pipes.length === 1) {\n        if (!state.multiAwaitDrain)\n          state.multiAwaitDrain = !0, state.awaitDrainWriters = new SafeSet(state.awaitDrainWriters \? [state.awaitDrainWriters] : []);\n      }\n      state.pipes.push(dest);\n      const endFn = (!pipeOpts || pipeOpts.end !== !1) && dest !== process.stdout && dest !== process.stderr \? onend : unpipe;\n      if (state.endEmitted)\n        runOnNextTick(endFn);\n      else\n        src.once(\"end\", endFn);\n      dest.on(\"unpipe\", onunpipe);\n      function onunpipe(readable, unpipeInfo) {\n        if (readable === src) {\n          if (unpipeInfo && unpipeInfo.hasUnpiped === !1)\n            unpipeInfo.hasUnpiped = !0, cleanup();\n        }\n      }\n      function onend() {\n        dest.end();\n      }\n      let ondrain, cleanedUp = !1;\n      function cleanup() {\n        if (dest.removeListener(\"close\", onclose), dest.removeListener(\"finish\", onfinish), ondrain)\n          dest.removeListener(\"drain\", ondrain);\n        if (dest.removeListener(\"error\", onerror), dest.removeListener(\"unpipe\", onunpipe), src.removeListener(\"end\", onend), src.removeListener(\"end\", unpipe), src.removeListener(\"data\", ondata), cleanedUp = !0, ondrain && state.awaitDrainWriters && (!dest._writableState || dest._writableState.needDrain))\n          ondrain();\n      }\n      function pause() {\n        if (!cleanedUp) {\n          if (state.pipes.length === 1 && state.pipes[0] === dest)\n            state.awaitDrainWriters = dest, state.multiAwaitDrain = !1;\n          else if (state.pipes.length > 1 && state.pipes.includes(dest))\n            state.awaitDrainWriters.add(dest);\n          src.pause();\n        }\n        if (!ondrain)\n          ondrain = pipeOnDrain(src, dest), dest.on(\"drain\", ondrain);\n      }\n      src.on(\"data\", ondata);\n      function ondata(chunk) {\n        if (dest.write(chunk) === !1)\n          pause();\n      }\n      function onerror(er) {\n        if (unpipe(), dest.removeListener(\"error\", onerror), dest.listenerCount(\"error\") === 0) {\n          const s = dest._writableState || dest._readableState;\n          if (s && !s.errorEmitted)\n            errorOrDestroy2(dest, er);\n          else\n            dest.emit(\"error\", er);\n        }\n      }\n      prependListener(dest, \"error\", onerror);\n      function onclose() {\n        dest.removeListener(\"finish\", onfinish), unpipe();\n      }\n      dest.once(\"close\", onclose);\n      function onfinish() {\n        dest.removeListener(\"close\", onclose), unpipe();\n      }\n      dest.once(\"finish\", onfinish);\n      function unpipe() {\n        src.unpipe(dest);\n      }\n      if (dest.emit(\"pipe\", src), dest.writableNeedDrain === !0) {\n        if (state.flowing)\n          pause();\n      } else if (!state.flowing)\n        src.resume();\n      return dest;\n    };\n    function pipeOnDrain(src, dest) {\n      return function pipeOnDrainFunctionResult() {\n        const state = src._readableState;\n        if (state.awaitDrainWriters === dest)\n          state.awaitDrainWriters = null;\n        else if (state.multiAwaitDrain)\n          state.awaitDrainWriters.delete(dest);\n        if ((!state.awaitDrainWriters || state.awaitDrainWriters.size === 0) && src.listenerCount(\"data\"))\n          src.resume();\n      };\n    }\n    Readable.prototype.unpipe = function(dest) {\n      const state = this._readableState, unpipeInfo = {\n        hasUnpiped: !1\n      };\n      if (state.pipes.length === 0)\n        return this;\n      if (!dest) {\n        const dests = state.pipes;\n        state.pipes = [], this.pause();\n        for (let i = 0;i < dests.length; i++)\n          dests[i].emit(\"unpipe\", this, {\n            hasUnpiped: !1\n          });\n        return this;\n      }\n      const index = ArrayPrototypeIndexOf(state.pipes, dest);\n      if (index === -1)\n        return this;\n      if (state.pipes.splice(index, 1), state.pipes.length === 0)\n        this.pause();\n      return dest.emit(\"unpipe\", this, unpipeInfo), this;\n    }, Readable.prototype.addListener = Readable.prototype.on, Readable.prototype.removeListener = function(ev, fn) {\n      const res = Stream.prototype.removeListener.call(this, ev, fn);\n      if (ev === \"readable\")\n        runOnNextTick(updateReadableListening, this);\n      return res;\n    }, Readable.prototype.off = Readable.prototype.removeListener, Readable.prototype.removeAllListeners = function(ev) {\n      const res = Stream.prototype.removeAllListeners.apply(this, arguments);\n      if (ev === \"readable\" || ev === void 0)\n        runOnNextTick(updateReadableListening, this);\n      return res;\n    };\n    function updateReadableListening(self) {\n      const state = self._readableState;\n      if (state.readableListening = self.listenerCount(\"readable\") > 0, state.resumeScheduled && state.paused === !1)\n        state.flowing = !0;\n      else if (self.listenerCount(\"data\") > 0)\n        self.resume();\n      else if (!state.readableListening)\n        state.flowing = null;\n    }\n    function nReadingNextTick(self) {\n      self.read(0);\n    }\n    Readable.prototype.resume = function() {\n      const state = this._readableState;\n      if (!state.flowing)\n        state.flowing = !state.readableListening, resume(this, state);\n      return state.paused = !1, this;\n    }, Readable.prototype.pause = function() {\n      if (this._readableState.flowing !== !1)\n        this._readableState.flowing = !1, this.emit(\"pause\");\n      return this._readableState.paused = !0, this;\n    }, Readable.prototype.wrap = function(stream) {\n      let paused = !1;\n      stream.on(\"data\", (chunk) => {\n        if (!this.push(chunk) && stream.pause)\n          paused = !0, stream.pause();\n      }), stream.on(\"end\", () => {\n        this.push(null);\n      }), stream.on(\"error\", (err) => {\n        errorOrDestroy2(this, err);\n      }), stream.on(\"close\", () => {\n        this.destroy();\n      }), stream.on(\"destroy\", () => {\n        this.destroy();\n      }), this._read = () => {\n        if (paused && stream.resume)\n          paused = !1, stream.resume();\n      };\n      const streamKeys = ObjectKeys(stream);\n      for (let j = 1;j < streamKeys.length; j++) {\n        const i = streamKeys[j];\n        if (this[i] === void 0 && typeof stream[i] === \"function\")\n          this[i] = stream[i].bind(stream);\n      }\n      return this;\n    }, Readable.prototype[SymbolAsyncIterator] = function() {\n      return streamToAsyncIterator(this);\n    }, Readable.prototype.iterator = function(options) {\n      if (options !== void 0)\n        validateObject(options, \"options\");\n      return streamToAsyncIterator(this, options);\n    };\n    function streamToAsyncIterator(stream, options) {\n      if (typeof stream.read !== \"function\")\n        stream = Readable.wrap(stream, {\n          objectMode: !0\n        });\n      const iter = createAsyncIterator(stream, options);\n      return iter.stream = stream, iter;\n    }\n    async function* createAsyncIterator(stream, options) {\n      let callback = nop;\n      function next(resolve) {\n        if (this === stream)\n          callback(), callback = nop;\n        else\n          callback = resolve;\n      }\n      stream.on(\"readable\", next);\n      let error;\n      const cleanup = eos(stream, {\n        writable: !1\n      }, (err) => {\n        error = err \? aggregateTwoErrors(error, err) : null, callback(), callback = nop;\n      });\n      try {\n        while (!0) {\n          const chunk = stream.destroyed \? null : stream.read();\n          if (chunk !== null)\n            yield chunk;\n          else if (error)\n            throw error;\n          else if (error === null)\n            return;\n          else\n            await new Promise2(next);\n        }\n      } catch (err) {\n        throw error = aggregateTwoErrors(error, err), error;\n      } finally {\n        if ((error || (options === null || options === void 0 \? void 0 : options.destroyOnReturn) !== !1) && (error === void 0 || stream._readableState.autoDestroy))\n          destroyImpl.destroyer(stream, null);\n        else\n          stream.off(\"readable\", next), cleanup();\n      }\n    }\n    ObjectDefineProperties(Readable.prototype, {\n      readable: {\n        get() {\n          const r = this._readableState;\n          return !!r && r.readable !== !1 && !r.destroyed && !r.errorEmitted && !r.endEmitted;\n        },\n        set(val) {\n          if (this._readableState)\n            this._readableState.readable = !!val;\n        }\n      },\n      readableDidRead: {\n        enumerable: !1,\n        get: function() {\n          return this._readableState.dataEmitted;\n        }\n      },\n      readableAborted: {\n        enumerable: !1,\n        get: function() {\n          return !!(this._readableState.readable !== !1 && (this._readableState.destroyed || this._readableState.errored) && !this._readableState.endEmitted);\n        }\n      },\n      readableHighWaterMark: {\n        enumerable: !1,\n        get: function() {\n          return this._readableState.highWaterMark;\n        }\n      },\n      readableBuffer: {\n        enumerable: !1,\n        get: function() {\n          return this._readableState && this._readableState.buffer;\n        }\n      },\n      readableFlowing: {\n        enumerable: !1,\n        get: function() {\n          return this._readableState.flowing;\n        },\n        set: function(state) {\n          if (this._readableState)\n            this._readableState.flowing = state;\n        }\n      },\n      readableLength: {\n        enumerable: !1,\n        get() {\n          return this._readableState.length;\n        }\n      },\n      readableObjectMode: {\n        enumerable: !1,\n        get() {\n          return this._readableState \? this._readableState.objectMode : !1;\n        }\n      },\n      readableEncoding: {\n        enumerable: !1,\n        get() {\n          return this._readableState \? this._readableState.encoding : null;\n        }\n      },\n      errored: {\n        enumerable: !1,\n        get() {\n          return this._readableState \? this._readableState.errored : null;\n        }\n      },\n      closed: {\n        get() {\n          return this._readableState \? this._readableState.closed : !1;\n        }\n      },\n      destroyed: {\n        enumerable: !1,\n        get() {\n          return this._readableState \? this._readableState.destroyed : !1;\n        },\n        set(value) {\n          if (!this._readableState)\n            return;\n          this._readableState.destroyed = value;\n        }\n      },\n      readableEnded: {\n        enumerable: !1,\n        get() {\n          return this._readableState \? this._readableState.endEmitted : !1;\n        }\n      }\n    }), Readable._fromList = fromList;\n    function fromList(n, state) {\n      if (state.length === 0)\n        return null;\n      let ret;\n      if (state.objectMode)\n        ret = state.buffer.shift();\n      else if (!n || n >= state.length) {\n        if (state.decoder)\n          ret = state.buffer.join(\"\");\n        else if (state.buffer.length === 1)\n          ret = state.buffer.first();\n        else\n          ret = state.buffer.concat(state.length);\n        state.buffer.clear();\n      } else\n        ret = state.buffer.consume(n, state.decoder);\n      return ret;\n    }\n    function endReadable(stream) {\n      const state = stream._readableState;\n      if (!state.endEmitted)\n        state.ended = !0, runOnNextTick(endReadableNT, state, stream);\n    }\n    function endReadableNT(state, stream) {\n      if (!state.errored && !state.closeEmitted && !state.endEmitted && state.length === 0) {\n        if (state.endEmitted = !0, stream.emit(\"end\"), stream.writable && stream.allowHalfOpen === !1)\n          runOnNextTick(endWritableNT, stream);\n        else if (state.autoDestroy) {\n          const wState = stream._writableState;\n          if (!wState || wState.autoDestroy && (wState.finished || wState.writable === !1))\n            stream.destroy();\n        }\n      }\n    }\n    function endWritableNT(stream) {\n      if (stream.writable && !stream.writableEnded && !stream.destroyed)\n        stream.end();\n    }\n    Readable.from = function(iterable, opts) {\n      return from(Readable, iterable, opts);\n    };\n    var webStreamsAdapters = {\n      newStreamReadableFromReadableStream,\n      newReadableStreamFromStreamReadable(streamReadable, options = {}) {\n        if (typeof streamReadable\?._readableState !== \"object\")\n          throw new ERR_INVALID_ARG_TYPE2(\"streamReadable\", \"stream.Readable\", streamReadable);\n        var { isDestroyed, isReadable } = require_utils();\n        if (isDestroyed(streamReadable) || !isReadable(streamReadable)) {\n          const readable = new ReadableStream;\n          return readable.cancel(), readable;\n        }\n        const { readableObjectMode: objectMode, readableHighWaterMark: highWaterMark } = streamReadable, strategy = ((strategy2) => {\n          if (strategy2)\n            return strategy2;\n          if (objectMode)\n            return new CountQueuingStrategy({ highWaterMark });\n          return { highWaterMark };\n        })(options\?.strategy);\n        let controller;\n        function onData(chunk) {\n          if (controller.enqueue(chunk), controller.desiredSize <= 0)\n            streamReadable.pause();\n        }\n        streamReadable.pause();\n        const cleanup = finished(streamReadable, (error) => {\n          if (error\?.code === \"ERR_STREAM_PREMATURE_CLOSE\")\n            error = new AbortError(void 0, { cause: error });\n          if (cleanup(), streamReadable.on(\"error\", () => {\n          }), error)\n            return controller.error(error);\n          controller.close();\n        });\n        return streamReadable.on(\"data\", onData), new ReadableStream({\n          start(c) {\n            controller = c;\n          },\n          pull() {\n            streamReadable.resume();\n          },\n          cancel(reason) {\n            destroy(streamReadable, reason);\n          }\n        }, strategy);\n      }\n    };\n    Readable.fromWeb = function(readableStream, options) {\n      return webStreamsAdapters.newStreamReadableFromReadableStream(readableStream, options);\n    }, Readable.toWeb = function(streamReadable, options) {\n      return webStreamsAdapters.newReadableStreamFromStreamReadable(streamReadable, options);\n    }, Readable.wrap = function(src, options) {\n      var _ref, _src$readableObjectMo;\n      return new Readable({\n        objectMode: (_ref = (_src$readableObjectMo = src.readableObjectMode) !== null && _src$readableObjectMo !== void 0 \? _src$readableObjectMo : src.objectMode) !== null && _ref !== void 0 \? _ref : !0,\n        ...options,\n        destroy(err, callback) {\n          destroyImpl.destroyer(src, err), callback(err);\n        }\n      }).wrap(src);\n    };\n  }\n}), require_writable = __commonJS({\n  \"node_modules/readable-stream/lib/internal/streams/writable.js\"(exports, module) {\n    var {\n      ArrayPrototypeSlice,\n      Error: Error2,\n      FunctionPrototypeSymbolHasInstance,\n      ObjectDefineProperty,\n      ObjectDefineProperties,\n      ObjectSetPrototypeOf,\n      StringPrototypeToLowerCase,\n      Symbol: Symbol2,\n      SymbolHasInstance\n    } = require_primordials(), Stream = require_legacy().Stream, destroyImpl = require_destroy(), { addAbortSignal } = require_add_abort_signal(), { getHighWaterMark, getDefaultHighWaterMark } = require_state(), {\n      ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE2,\n      ERR_METHOD_NOT_IMPLEMENTED,\n      ERR_MULTIPLE_CALLBACK,\n      ERR_STREAM_CANNOT_PIPE,\n      ERR_STREAM_DESTROYED,\n      ERR_STREAM_ALREADY_FINISHED,\n      ERR_STREAM_NULL_VALUES,\n      ERR_STREAM_WRITE_AFTER_END,\n      ERR_UNKNOWN_ENCODING\n    } = require_errors().codes, { errorOrDestroy: errorOrDestroy2 } = destroyImpl;\n    function Writable(options = {}) {\n      const isDuplex = this instanceof require_duplex();\n      if (!isDuplex && !FunctionPrototypeSymbolHasInstance(Writable, this))\n        return new Writable(options);\n      if (this._writableState = new WritableState(options, this, isDuplex), options) {\n        if (typeof options.write === \"function\")\n          this._write = options.write;\n        if (typeof options.writev === \"function\")\n          this._writev = options.writev;\n        if (typeof options.destroy === \"function\")\n          this._destroy = options.destroy;\n        if (typeof options.final === \"function\")\n          this._final = options.final;\n        if (typeof options.construct === \"function\")\n          this._construct = options.construct;\n        if (options.signal)\n          addAbortSignal(options.signal, this);\n      }\n      Stream.call(this, options), destroyImpl.construct(this, () => {\n        const state = this._writableState;\n        if (!state.writing)\n          clearBuffer(this, state);\n        finishMaybe(this, state);\n      });\n    }\n    Writable.prototype = {}, ObjectSetPrototypeOf(Writable.prototype, Stream.prototype), ObjectSetPrototypeOf(Writable, Stream), module.exports = Writable;\n    function nop() {\n    }\n    var kOnFinished = Symbol2(\"kOnFinished\");\n    function WritableState(options, stream, isDuplex) {\n      if (typeof isDuplex !== \"boolean\")\n        isDuplex = stream instanceof require_duplex();\n      if (this.objectMode = !!(options && options.objectMode), isDuplex)\n        this.objectMode = this.objectMode || !!(options && options.writableObjectMode);\n      this.highWaterMark = options \? getHighWaterMark(this, options, \"writableHighWaterMark\", isDuplex) : getDefaultHighWaterMark(!1), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;\n      const noDecode = !!(options && options.decodeStrings === !1);\n      this.decodeStrings = !noDecode, this.defaultEncoding = options && options.defaultEncoding || \"utf8\", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = onwrite.bind(void 0, stream), this.writecb = null, this.writelen = 0, this.afterWriteTickInfo = null, resetBuffer(this), this.pendingcb = 0, this.constructed = !0, this.prefinished = !1, this.errorEmitted = !1, this.emitClose = !options || options.emitClose !== !1, this.autoDestroy = !options || options.autoDestroy !== !1, this.errored = null, this.closed = !1, this.closeEmitted = !1, this[kOnFinished] = [];\n    }\n    WritableState.prototype = {};\n    function resetBuffer(state) {\n      state.buffered = [], state.bufferedIndex = 0, state.allBuffers = !0, state.allNoop = !0;\n    }\n    WritableState.prototype.getBuffer = function getBuffer() {\n      return ArrayPrototypeSlice(this.buffered, this.bufferedIndex);\n    }, ObjectDefineProperty(WritableState.prototype, \"bufferedRequestCount\", {\n      get() {\n        return this.buffered.length - this.bufferedIndex;\n      }\n    }), ObjectDefineProperty(Writable, SymbolHasInstance, {\n      value: function(object) {\n        if (FunctionPrototypeSymbolHasInstance(this, object))\n          return !0;\n        if (this !== Writable)\n          return !1;\n        return object && object._writableState instanceof WritableState;\n      }\n    }), Writable.prototype.pipe = function() {\n      errorOrDestroy2(this, new ERR_STREAM_CANNOT_PIPE);\n    };\n    function _write(stream, chunk, encoding, cb) {\n      const state = stream._writableState;\n      if (typeof encoding === \"function\")\n        cb = encoding, encoding = state.defaultEncoding;\n      else {\n        if (!encoding)\n          encoding = state.defaultEncoding;\n        else if (encoding !== \"buffer\" && !Buffer.isEncoding(encoding))\n          throw new ERR_UNKNOWN_ENCODING(encoding);\n        if (typeof cb !== \"function\")\n          cb = nop;\n      }\n      if (chunk === null)\n        throw new ERR_STREAM_NULL_VALUES;\n      else if (!state.objectMode)\n        if (typeof chunk === \"string\") {\n          if (state.decodeStrings !== !1)\n            chunk = Buffer.from(chunk, encoding), encoding = \"buffer\";\n        } else if (chunk instanceof Buffer)\n          encoding = \"buffer\";\n        else if (Stream._isUint8Array(chunk))\n          chunk = Stream._uint8ArrayToBuffer(chunk), encoding = \"buffer\";\n        else\n          throw new ERR_INVALID_ARG_TYPE2(\"chunk\", [\"string\", \"Buffer\", \"Uint8Array\"], chunk);\n      let err;\n      if (state.ending)\n        err = new ERR_STREAM_WRITE_AFTER_END;\n      else if (state.destroyed)\n        err = new ERR_STREAM_DESTROYED(\"write\");\n      if (err)\n        return runOnNextTick(cb, err), errorOrDestroy2(stream, err, !0), err;\n      return state.pendingcb++, writeOrBuffer(stream, state, chunk, encoding, cb);\n    }\n    Writable.prototype.write = function(chunk, encoding, cb) {\n      return _write(this, chunk, encoding, cb) === !0;\n    }, Writable.prototype.cork = function() {\n      this._writableState.corked++;\n    }, Writable.prototype.uncork = function() {\n      const state = this._writableState;\n      if (state.corked) {\n        if (state.corked--, !state.writing)\n          clearBuffer(this, state);\n      }\n    }, Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {\n      if (typeof encoding === \"string\")\n        encoding = StringPrototypeToLowerCase(encoding);\n      if (!Buffer.isEncoding(encoding))\n        throw new ERR_UNKNOWN_ENCODING(encoding);\n      return this._writableState.defaultEncoding = encoding, this;\n    };\n    function writeOrBuffer(stream, state, chunk, encoding, callback) {\n      const len = state.objectMode \? 1 : chunk.length;\n      state.length += len;\n      const ret = state.length < state.highWaterMark;\n      if (!ret)\n        state.needDrain = !0;\n      if (state.writing || state.corked || state.errored || !state.constructed) {\n        if (state.buffered.push({\n          chunk,\n          encoding,\n          callback\n        }), state.allBuffers && encoding !== \"buffer\")\n          state.allBuffers = !1;\n        if (state.allNoop && callback !== nop)\n          state.allNoop = !1;\n      } else\n        state.writelen = len, state.writecb = callback, state.writing = !0, state.sync = !0, stream._write(chunk, encoding, state.onwrite), state.sync = !1;\n      return ret && !state.errored && !state.destroyed;\n    }\n    function doWrite(stream, state, writev, len, chunk, encoding, cb) {\n      if (state.writelen = len, state.writecb = cb, state.writing = !0, state.sync = !0, state.destroyed)\n        state.onwrite(new ERR_STREAM_DESTROYED(\"write\"));\n      else if (writev)\n        stream._writev(chunk, state.onwrite);\n      else\n        stream._write(chunk, encoding, state.onwrite);\n      state.sync = !1;\n    }\n    function onwriteError(stream, state, er, cb) {\n      --state.pendingcb, cb(er), errorBuffer(state), errorOrDestroy2(stream, er);\n    }\n    function onwrite(stream, er) {\n      const state = stream._writableState, sync = state.sync, cb = state.writecb;\n      if (typeof cb !== \"function\") {\n        errorOrDestroy2(stream, new ERR_MULTIPLE_CALLBACK);\n        return;\n      }\n      if (state.writing = !1, state.writecb = null, state.length -= state.writelen, state.writelen = 0, er) {\n        if (Error.captureStackTrace(er), !state.errored)\n          state.errored = er;\n        if (stream._readableState && !stream._readableState.errored)\n          stream._readableState.errored = er;\n        if (sync)\n          runOnNextTick(onwriteError, stream, state, er, cb);\n        else\n          onwriteError(stream, state, er, cb);\n      } else {\n        if (state.buffered.length > state.bufferedIndex)\n          clearBuffer(stream, state);\n        if (sync)\n          if (state.afterWriteTickInfo !== null && state.afterWriteTickInfo.cb === cb)\n            state.afterWriteTickInfo.count++;\n          else\n            state.afterWriteTickInfo = {\n              count: 1,\n              cb,\n              stream,\n              state\n            }, runOnNextTick(afterWriteTick, state.afterWriteTickInfo);\n        else\n          afterWrite(stream, state, 1, cb);\n      }\n    }\n    function afterWriteTick({ stream, state, count, cb }) {\n      return state.afterWriteTickInfo = null, afterWrite(stream, state, count, cb);\n    }\n    function afterWrite(stream, state, count, cb) {\n      if (!state.ending && !stream.destroyed && state.length === 0 && state.needDrain)\n        state.needDrain = !1, stream.emit(\"drain\");\n      while (count-- > 0)\n        state.pendingcb--, cb();\n      if (state.destroyed)\n        errorBuffer(state);\n      finishMaybe(stream, state);\n    }\n    function errorBuffer(state) {\n      if (state.writing)\n        return;\n      for (let n = state.bufferedIndex;n < state.buffered.length; ++n) {\n        var _state$errored;\n        const { chunk, callback } = state.buffered[n], len = state.objectMode \? 1 : chunk.length;\n        state.length -= len, callback((_state$errored = state.errored) !== null && _state$errored !== void 0 \? _state$errored : new ERR_STREAM_DESTROYED(\"write\"));\n      }\n      const onfinishCallbacks = state[kOnFinished].splice(0);\n      for (let i = 0;i < onfinishCallbacks.length; i++) {\n        var _state$errored2;\n        onfinishCallbacks[i]((_state$errored2 = state.errored) !== null && _state$errored2 !== void 0 \? _state$errored2 : new ERR_STREAM_DESTROYED(\"end\"));\n      }\n      resetBuffer(state);\n    }\n    function clearBuffer(stream, state) {\n      if (state.corked || state.bufferProcessing || state.destroyed || !state.constructed)\n        return;\n      const { buffered, bufferedIndex, objectMode } = state, bufferedLength = buffered.length - bufferedIndex;\n      if (!bufferedLength)\n        return;\n      let i = bufferedIndex;\n      if (state.bufferProcessing = !0, bufferedLength > 1 && stream._writev) {\n        state.pendingcb -= bufferedLength - 1;\n        const callback = state.allNoop \? nop : (err) => {\n          for (let n = i;n < buffered.length; ++n)\n            buffered[n].callback(err);\n        }, chunks = state.allNoop && i === 0 \? buffered : ArrayPrototypeSlice(buffered, i);\n        chunks.allBuffers = state.allBuffers, doWrite(stream, state, !0, state.length, chunks, \"\", callback), resetBuffer(state);\n      } else {\n        do {\n          const { chunk, encoding, callback } = buffered[i];\n          buffered[i++] = null;\n          const len = objectMode \? 1 : chunk.length;\n          doWrite(stream, state, !1, len, chunk, encoding, callback);\n        } while (i < buffered.length && !state.writing);\n        if (i === buffered.length)\n          resetBuffer(state);\n        else if (i > 256)\n          buffered.splice(0, i), state.bufferedIndex = 0;\n        else\n          state.bufferedIndex = i;\n      }\n      state.bufferProcessing = !1;\n    }\n    Writable.prototype._write = function(chunk, encoding, cb) {\n      if (this._writev)\n        this._writev([\n          {\n            chunk,\n            encoding\n          }\n        ], cb);\n      else\n        throw new ERR_METHOD_NOT_IMPLEMENTED(\"_write()\");\n    }, Writable.prototype._writev = null, Writable.prototype.end = function(chunk, encoding, cb, native = !1) {\n      const state = this._writableState;\n      if (typeof chunk === \"function\")\n        cb = chunk, chunk = null, encoding = null;\n      else if (typeof encoding === \"function\")\n        cb = encoding, encoding = null;\n      let err;\n      if (chunk !== null && chunk !== void 0) {\n        let ret;\n        if (!native)\n          ret = _write(this, chunk, encoding);\n        else\n          ret = this.write(chunk, encoding);\n        if (ret instanceof Error2)\n          err = ret;\n      }\n      if (state.corked)\n        state.corked = 1, this.uncork();\n      if (err)\n        this.emit(\"error\", err);\n      else if (!state.errored && !state.ending)\n        state.ending = !0, finishMaybe(this, state, !0), state.ended = !0;\n      else if (state.finished)\n        err = new ERR_STREAM_ALREADY_FINISHED(\"end\");\n      else if (state.destroyed)\n        err = new ERR_STREAM_DESTROYED(\"end\");\n      if (typeof cb === \"function\")\n        if (err || state.finished)\n          runOnNextTick(cb, err);\n        else\n          state[kOnFinished].push(cb);\n      return this;\n    };\n    function needFinish(state, tag) {\n      var needFinish2 = state.ending && !state.destroyed && state.constructed && state.length === 0 && !state.errored && state.buffered.length === 0 && !state.finished && !state.writing && !state.errorEmitted && !state.closeEmitted;\n      return needFinish2;\n    }\n    function callFinal(stream, state) {\n      let called = !1;\n      function onFinish(err) {\n        if (called) {\n          errorOrDestroy2(stream, err !== null && err !== void 0 \? err : ERR_MULTIPLE_CALLBACK());\n          return;\n        }\n        if (called = !0, state.pendingcb--, err) {\n          const onfinishCallbacks = state[kOnFinished].splice(0);\n          for (let i = 0;i < onfinishCallbacks.length; i++)\n            onfinishCallbacks[i](err);\n          errorOrDestroy2(stream, err, state.sync);\n        } else if (needFinish(state))\n          state.prefinished = !0, stream.emit(\"prefinish\"), state.pendingcb++, runOnNextTick(finish, stream, state);\n      }\n      state.sync = !0, state.pendingcb++;\n      try {\n        stream._final(onFinish);\n      } catch (err) {\n        onFinish(err);\n      }\n      state.sync = !1;\n    }\n    function prefinish(stream, state) {\n      if (!state.prefinished && !state.finalCalled)\n        if (typeof stream._final === \"function\" && !state.destroyed)\n          state.finalCalled = !0, callFinal(stream, state);\n        else\n          state.prefinished = !0, stream.emit(\"prefinish\");\n    }\n    function finishMaybe(stream, state, sync) {\n      if (!needFinish(state, stream.__id))\n        return;\n      if (prefinish(stream, state), state.pendingcb === 0) {\n        if (sync)\n          state.pendingcb++, runOnNextTick((stream2, state2) => {\n            if (needFinish(state2))\n              finish(stream2, state2);\n            else\n              state2.pendingcb--;\n          }, stream, state);\n        else if (needFinish(state))\n          state.pendingcb++, finish(stream, state);\n      }\n    }\n    function finish(stream, state) {\n      state.pendingcb--, state.finished = !0;\n      const onfinishCallbacks = state[kOnFinished].splice(0);\n      for (let i = 0;i < onfinishCallbacks.length; i++)\n        onfinishCallbacks[i]();\n      if (stream.emit(\"finish\"), state.autoDestroy) {\n        const rState = stream._readableState;\n        if (!rState || rState.autoDestroy && (rState.endEmitted || rState.readable === !1))\n          stream.destroy();\n      }\n    }\n    ObjectDefineProperties(Writable.prototype, {\n      closed: {\n        get() {\n          return this._writableState \? this._writableState.closed : !1;\n        }\n      },\n      destroyed: {\n        get() {\n          return this._writableState \? this._writableState.destroyed : !1;\n        },\n        set(value) {\n          if (this._writableState)\n            this._writableState.destroyed = value;\n        }\n      },\n      writable: {\n        get() {\n          const w = this._writableState;\n          return !!w && w.writable !== !1 && !w.destroyed && !w.errored && !w.ending && !w.ended;\n        },\n        set(val) {\n          if (this._writableState)\n            this._writableState.writable = !!val;\n        }\n      },\n      writableFinished: {\n        get() {\n          return this._writableState \? this._writableState.finished : !1;\n        }\n      },\n      writableObjectMode: {\n        get() {\n          return this._writableState \? this._writableState.objectMode : !1;\n        }\n      },\n      writableBuffer: {\n        get() {\n          return this._writableState && this._writableState.getBuffer();\n        }\n      },\n      writableEnded: {\n        get() {\n          return this._writableState \? this._writableState.ending : !1;\n        }\n      },\n      writableNeedDrain: {\n        get() {\n          const wState = this._writableState;\n          if (!wState)\n            return !1;\n          return !wState.destroyed && !wState.ending && wState.needDrain;\n        }\n      },\n      writableHighWaterMark: {\n        get() {\n          return this._writableState && this._writableState.highWaterMark;\n        }\n      },\n      writableCorked: {\n        get() {\n          return this._writableState \? this._writableState.corked : 0;\n        }\n      },\n      writableLength: {\n        get() {\n          return this._writableState && this._writableState.length;\n        }\n      },\n      errored: {\n        enumerable: !1,\n        get() {\n          return this._writableState \? this._writableState.errored : null;\n        }\n      },\n      writableAborted: {\n        enumerable: !1,\n        get: function() {\n          return !!(this._writableState.writable !== !1 && (this._writableState.destroyed || this._writableState.errored) && !this._writableState.finished);\n        }\n      }\n    });\n    var destroy2 = destroyImpl.destroy;\n    Writable.prototype.destroy = function(err, cb) {\n      const state = this._writableState;\n      if (!state.destroyed && (state.bufferedIndex < state.buffered.length || state[kOnFinished].length))\n        runOnNextTick(errorBuffer, state);\n      return destroy2.call(this, err, cb), this;\n    }, Writable.prototype._undestroy = destroyImpl.undestroy, Writable.prototype._destroy = function(err, cb) {\n      cb(err);\n    }, Writable.prototype[EE.captureRejectionSymbol] = function(err) {\n      this.destroy(err);\n    };\n    var webStreamsAdapters;\n    function lazyWebStreams() {\n      if (webStreamsAdapters === void 0)\n        webStreamsAdapters = {};\n      return webStreamsAdapters;\n    }\n    Writable.fromWeb = function(writableStream, options) {\n      return lazyWebStreams().newStreamWritableFromWritableStream(writableStream, options);\n    }, Writable.toWeb = function(streamWritable) {\n      return lazyWebStreams().newWritableStreamFromStreamWritable(streamWritable);\n    };\n  }\n}), require_duplexify = __commonJS({\n  \"node_modules/readable-stream/lib/internal/streams/duplexify.js\"(exports, module) {\n    var {\n      isReadable,\n      isWritable,\n      isIterable,\n      isNodeStream,\n      isReadableNodeStream,\n      isWritableNodeStream,\n      isDuplexNodeStream\n    } = require_utils(), eos = require_end_of_stream(), {\n      AbortError: AbortError2,\n      codes: { ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE2, ERR_INVALID_RETURN_VALUE }\n    } = require_errors(), { destroyer } = require_destroy(), Duplex = require_duplex(), Readable = require_readable(), { createDeferredPromise } = require_util(), from = require_from(), isBlob = typeof Blob !== \"undefined\" \? function isBlob2(b) {\n      return b instanceof Blob;\n    } : function isBlob2(b) {\n      return !1;\n    }, { FunctionPrototypeCall } = require_primordials();\n\n    class Duplexify extends Duplex {\n      constructor(options) {\n        super(options);\n        if ((options === null || options === void 0 \? void 0 : options.readable) === !1)\n          this._readableState.readable = !1, this._readableState.ended = !0, this._readableState.endEmitted = !0;\n        if ((options === null || options === void 0 \? void 0 : options.writable) === !1)\n          this._writableState.writable = !1, this._writableState.ending = !0, this._writableState.ended = !0, this._writableState.finished = !0;\n      }\n    }\n    module.exports = function duplexify(body, name) {\n      if (isDuplexNodeStream(body))\n        return body;\n      if (isReadableNodeStream(body))\n        return _duplexify({\n          readable: body\n        });\n      if (isWritableNodeStream(body))\n        return _duplexify({\n          writable: body\n        });\n      if (isNodeStream(body))\n        return _duplexify({\n          writable: !1,\n          readable: !1\n        });\n      if (typeof body === \"function\") {\n        const { value, write, final, destroy: destroy2 } = fromAsyncGen(body);\n        if (isIterable(value))\n          return from(Duplexify, value, {\n            objectMode: !0,\n            write,\n            final,\n            destroy: destroy2\n          });\n        const then2 = value === null || value === void 0 \? void 0 : value.then;\n        if (typeof then2 === \"function\") {\n          let d;\n          const promise = FunctionPrototypeCall(then2, value, (val) => {\n            if (val != null)\n              throw new ERR_INVALID_RETURN_VALUE(\"nully\", \"body\", val);\n          }, (err) => {\n            destroyer(d, err);\n          });\n          return d = new Duplexify({\n            objectMode: !0,\n            readable: !1,\n            write,\n            final(cb) {\n              final(async () => {\n                try {\n                  await promise, runOnNextTick(cb, null);\n                } catch (err) {\n                  runOnNextTick(cb, err);\n                }\n              });\n            },\n            destroy: destroy2\n          });\n        }\n        throw new ERR_INVALID_RETURN_VALUE(\"Iterable, AsyncIterable or AsyncFunction\", name, value);\n      }\n      if (isBlob(body))\n        return duplexify(body.arrayBuffer());\n      if (isIterable(body))\n        return from(Duplexify, body, {\n          objectMode: !0,\n          writable: !1\n        });\n      if (typeof (body === null || body === void 0 \? void 0 : body.writable) === \"object\" || typeof (body === null || body === void 0 \? void 0 : body.readable) === \"object\") {\n        const readable = body !== null && body !== void 0 && body.readable \? isReadableNodeStream(body === null || body === void 0 \? void 0 : body.readable) \? body === null || body === void 0 \? void 0 : body.readable : duplexify(body.readable) : void 0, writable = body !== null && body !== void 0 && body.writable \? isWritableNodeStream(body === null || body === void 0 \? void 0 : body.writable) \? body === null || body === void 0 \? void 0 : body.writable : duplexify(body.writable) : void 0;\n        return _duplexify({\n          readable,\n          writable\n        });\n      }\n      const then = body === null || body === void 0 \? void 0 : body.then;\n      if (typeof then === \"function\") {\n        let d;\n        return FunctionPrototypeCall(then, body, (val) => {\n          if (val != null)\n            d.push(val);\n          d.push(null);\n        }, (err) => {\n          destroyer(d, err);\n        }), d = new Duplexify({\n          objectMode: !0,\n          writable: !1,\n          read() {\n          }\n        });\n      }\n      throw new ERR_INVALID_ARG_TYPE2(name, [\n        \"Blob\",\n        \"ReadableStream\",\n        \"WritableStream\",\n        \"Stream\",\n        \"Iterable\",\n        \"AsyncIterable\",\n        \"Function\",\n        \"{ readable, writable } pair\",\n        \"Promise\"\n      ], body);\n    };\n    function fromAsyncGen(fn) {\n      let { promise, resolve } = createDeferredPromise();\n      const ac = new AbortController, signal = ac.signal;\n      return {\n        value: fn(async function* () {\n          while (!0) {\n            const _promise = promise;\n            promise = null;\n            const { chunk, done, cb } = await _promise;\n            if (runOnNextTick(cb), done)\n              return;\n            if (signal.aborted)\n              throw new AbortError2(void 0, {\n                cause: signal.reason\n              });\n            ({ promise, resolve } = createDeferredPromise()), yield chunk;\n          }\n        }(), {\n          signal\n        }),\n        write(chunk, encoding, cb) {\n          const _resolve = resolve;\n          resolve = null, _resolve({\n            chunk,\n            done: !1,\n            cb\n          });\n        },\n        final(cb) {\n          const _resolve = resolve;\n          resolve = null, _resolve({\n            done: !0,\n            cb\n          });\n        },\n        destroy(err, cb) {\n          ac.abort(), cb(err);\n        }\n      };\n    }\n    function _duplexify(pair) {\n      const r = pair.readable && typeof pair.readable.read !== \"function\" \? Readable.wrap(pair.readable) : pair.readable, w = pair.writable;\n      let readable = !!isReadable(r), writable = !!isWritable(w), ondrain, onfinish, onreadable, onclose, d;\n      function onfinished(err) {\n        const cb = onclose;\n        if (onclose = null, cb)\n          cb(err);\n        else if (err)\n          d.destroy(err);\n        else if (!readable && !writable)\n          d.destroy();\n      }\n      if (d = new Duplexify({\n        readableObjectMode: !!(r !== null && r !== void 0 && r.readableObjectMode),\n        writableObjectMode: !!(w !== null && w !== void 0 && w.writableObjectMode),\n        readable,\n        writable\n      }), writable)\n        eos(w, (err) => {\n          if (writable = !1, err)\n            destroyer(r, err);\n          onfinished(err);\n        }), d._write = function(chunk, encoding, callback) {\n          if (w.write(chunk, encoding))\n            callback();\n          else\n            ondrain = callback;\n        }, d._final = function(callback) {\n          w.end(), onfinish = callback;\n        }, w.on(\"drain\", function() {\n          if (ondrain) {\n            const cb = ondrain;\n            ondrain = null, cb();\n          }\n        }), w.on(\"finish\", function() {\n          if (onfinish) {\n            const cb = onfinish;\n            onfinish = null, cb();\n          }\n        });\n      if (readable)\n        eos(r, (err) => {\n          if (readable = !1, err)\n            destroyer(r, err);\n          onfinished(err);\n        }), r.on(\"readable\", function() {\n          if (onreadable) {\n            const cb = onreadable;\n            onreadable = null, cb();\n          }\n        }), r.on(\"end\", function() {\n          d.push(null);\n        }), d._read = function() {\n          while (!0) {\n            const buf = r.read();\n            if (buf === null) {\n              onreadable = d._read;\n              return;\n            }\n            if (!d.push(buf))\n              return;\n          }\n        };\n      return d._destroy = function(err, callback) {\n        if (!err && onclose !== null)\n          err = new AbortError2;\n        if (onreadable = null, ondrain = null, onfinish = null, onclose === null)\n          callback(err);\n        else\n          onclose = callback, destroyer(w, err), destroyer(r, err);\n      }, d;\n    }\n  }\n}), require_duplex = __commonJS({\n  \"node_modules/readable-stream/lib/internal/streams/duplex.js\"(exports, module) {\n    var { ObjectDefineProperties, ObjectGetOwnPropertyDescriptor, ObjectKeys, ObjectSetPrototypeOf } = require_primordials(), Readable = require_readable();\n    function Duplex(options) {\n      if (!(this instanceof Duplex))\n        return new Duplex(options);\n      if (Readable.call(this, options), Writable.call(this, options), options) {\n        if (this.allowHalfOpen = options.allowHalfOpen !== !1, options.readable === !1)\n          this._readableState.readable = !1, this._readableState.ended = !0, this._readableState.endEmitted = !0;\n        if (options.writable === !1)\n          this._writableState.writable = !1, this._writableState.ending = !0, this._writableState.ended = !0, this._writableState.finished = !0;\n      } else\n        this.allowHalfOpen = !0;\n    }\n    Duplex.prototype = {}, module.exports = Duplex, ObjectSetPrototypeOf(Duplex.prototype, Readable.prototype), ObjectSetPrototypeOf(Duplex, Readable);\n    for (var method in Writable.prototype)\n      if (!Duplex.prototype[method])\n        Duplex.prototype[method] = Writable.prototype[method];\n    ObjectDefineProperties(Duplex.prototype, {\n      writable: ObjectGetOwnPropertyDescriptor(Writable.prototype, \"writable\"),\n      writableHighWaterMark: ObjectGetOwnPropertyDescriptor(Writable.prototype, \"writableHighWaterMark\"),\n      writableObjectMode: ObjectGetOwnPropertyDescriptor(Writable.prototype, \"writableObjectMode\"),\n      writableBuffer: ObjectGetOwnPropertyDescriptor(Writable.prototype, \"writableBuffer\"),\n      writableLength: ObjectGetOwnPropertyDescriptor(Writable.prototype, \"writableLength\"),\n      writableFinished: ObjectGetOwnPropertyDescriptor(Writable.prototype, \"writableFinished\"),\n      writableCorked: ObjectGetOwnPropertyDescriptor(Writable.prototype, \"writableCorked\"),\n      writableEnded: ObjectGetOwnPropertyDescriptor(Writable.prototype, \"writableEnded\"),\n      writableNeedDrain: ObjectGetOwnPropertyDescriptor(Writable.prototype, \"writableNeedDrain\"),\n      destroyed: {\n        get() {\n          if (this._readableState === void 0 || this._writableState === void 0)\n            return !1;\n          return this._readableState.destroyed && this._writableState.destroyed;\n        },\n        set(value) {\n          if (this._readableState && this._writableState)\n            this._readableState.destroyed = value, this._writableState.destroyed = value;\n        }\n      }\n    });\n    var webStreamsAdapters;\n    function lazyWebStreams() {\n      if (webStreamsAdapters === void 0)\n        webStreamsAdapters = {};\n      return webStreamsAdapters;\n    }\n    Duplex.fromWeb = function(pair, options) {\n      return lazyWebStreams().newStreamDuplexFromReadableWritablePair(pair, options);\n    }, Duplex.toWeb = function(duplex) {\n      return lazyWebStreams().newReadableWritablePairFromDuplex(duplex);\n    };\n    var duplexify;\n    Duplex.from = function(body) {\n      if (!duplexify)\n        duplexify = require_duplexify();\n      return duplexify(body, \"body\");\n    };\n  }\n}), require_transform = __commonJS({\n  \"node_modules/readable-stream/lib/internal/streams/transform.js\"(exports, module) {\n    var { ObjectSetPrototypeOf, Symbol: Symbol2 } = require_primordials(), { ERR_METHOD_NOT_IMPLEMENTED } = require_errors().codes, Duplex = require_duplex();\n    function Transform(options) {\n      if (!(this instanceof Transform))\n        return new Transform(options);\n      if (Duplex.call(this, options), this._readableState.sync = !1, this[kCallback] = null, options) {\n        if (typeof options.transform === \"function\")\n          this._transform = options.transform;\n        if (typeof options.flush === \"function\")\n          this._flush = options.flush;\n      }\n      this.on(\"prefinish\", prefinish.bind(this));\n    }\n    Transform.prototype = {}, ObjectSetPrototypeOf(Transform.prototype, Duplex.prototype), ObjectSetPrototypeOf(Transform, Duplex), module.exports = Transform;\n    var kCallback = Symbol2(\"kCallback\");\n    function final(cb) {\n      if (typeof this._flush === \"function\" && !this.destroyed)\n        this._flush((er, data) => {\n          if (er) {\n            if (cb)\n              cb(er);\n            else\n              this.destroy(er);\n            return;\n          }\n          if (data != null)\n            this.push(data);\n          if (this.push(null), cb)\n            cb();\n        });\n      else if (this.push(null), cb)\n        cb();\n    }\n    function prefinish() {\n      if (this._final !== final)\n        final.call(this);\n    }\n    Transform.prototype._final = final, Transform.prototype._transform = function(chunk, encoding, callback) {\n      throw new ERR_METHOD_NOT_IMPLEMENTED(\"_transform()\");\n    }, Transform.prototype._write = function(chunk, encoding, callback) {\n      const rState = this._readableState, wState = this._writableState, length = rState.length;\n      this._transform(chunk, encoding, (err, val) => {\n        if (err) {\n          callback(err);\n          return;\n        }\n        if (val != null)\n          this.push(val);\n        if (wState.ended || length === rState.length || rState.length < rState.highWaterMark || rState.highWaterMark === 0 || rState.length === 0)\n          callback();\n        else\n          this[kCallback] = callback;\n      });\n    }, Transform.prototype._read = function() {\n      if (this[kCallback]) {\n        const callback = this[kCallback];\n        this[kCallback] = null, callback();\n      }\n    };\n  }\n}), require_passthrough = __commonJS({\n  \"node_modules/readable-stream/lib/internal/streams/passthrough.js\"(exports, module) {\n    var { ObjectSetPrototypeOf } = require_primordials(), Transform = require_transform();\n    function PassThrough(options) {\n      if (!(this instanceof PassThrough))\n        return new PassThrough(options);\n      Transform.call(this, options);\n    }\n    PassThrough.prototype = {}, ObjectSetPrototypeOf(PassThrough.prototype, Transform.prototype), ObjectSetPrototypeOf(PassThrough, Transform), PassThrough.prototype._transform = function(chunk, encoding, cb) {\n      cb(null, chunk);\n    }, module.exports = PassThrough;\n  }\n}), require_pipeline = __commonJS({\n  \"node_modules/readable-stream/lib/internal/streams/pipeline.js\"(exports, module) {\n    var { ArrayIsArray: ArrayIsArray2, Promise: Promise2, SymbolAsyncIterator } = require_primordials(), eos = require_end_of_stream(), { once } = require_util(), destroyImpl = require_destroy(), Duplex = require_duplex(), {\n      aggregateTwoErrors,\n      codes: { ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE2, ERR_INVALID_RETURN_VALUE, ERR_MISSING_ARGS, ERR_STREAM_DESTROYED },\n      AbortError: AbortError2\n    } = require_errors(), { validateFunction, validateAbortSignal } = require_validators(), { isIterable, isReadable, isReadableNodeStream, isNodeStream } = require_utils(), PassThrough, Readable;\n    function destroyer(stream, reading, writing) {\n      let finished2 = !1;\n      stream.on(\"close\", () => {\n        finished2 = !0;\n      });\n      const cleanup = eos(stream, {\n        readable: reading,\n        writable: writing\n      }, (err) => {\n        finished2 = !err;\n      });\n      return {\n        destroy: (err) => {\n          if (finished2)\n            return;\n          finished2 = !0, destroyImpl.destroyer(stream, err || new ERR_STREAM_DESTROYED(\"pipe\"));\n        },\n        cleanup\n      };\n    }\n    function popCallback(streams) {\n      return validateFunction(streams[streams.length - 1], \"streams[stream.length - 1]\"), streams.pop();\n    }\n    function makeAsyncIterable(val) {\n      if (isIterable(val))\n        return val;\n      else if (isReadableNodeStream(val))\n        return fromReadable(val);\n      throw new ERR_INVALID_ARG_TYPE2(\"val\", [\"Readable\", \"Iterable\", \"AsyncIterable\"], val);\n    }\n    async function* fromReadable(val) {\n      if (!Readable)\n        Readable = require_readable();\n      yield* Readable.prototype[SymbolAsyncIterator].call(val);\n    }\n    async function pump(iterable, writable, finish, { end }) {\n      let error, onresolve = null;\n      const resume = (err) => {\n        if (err)\n          error = err;\n        if (onresolve) {\n          const callback = onresolve;\n          onresolve = null, callback();\n        }\n      }, wait = () => new Promise2((resolve, reject) => {\n        if (error)\n          reject(error);\n        else\n          onresolve = () => {\n            if (error)\n              reject(error);\n            else\n              resolve();\n          };\n      });\n      writable.on(\"drain\", resume);\n      const cleanup = eos(writable, {\n        readable: !1\n      }, resume);\n      try {\n        if (writable.writableNeedDrain)\n          await wait();\n        for await (let chunk of iterable)\n          if (!writable.write(chunk))\n            await wait();\n        if (end)\n          writable.end();\n        await wait(), finish();\n      } catch (err) {\n        finish(error !== err \? aggregateTwoErrors(error, err) : err);\n      } finally {\n        cleanup(), writable.off(\"drain\", resume);\n      }\n    }\n    function pipeline(...streams) {\n      return pipelineImpl(streams, once(popCallback(streams)));\n    }\n    function pipelineImpl(streams, callback, opts) {\n      if (streams.length === 1 && ArrayIsArray2(streams[0]))\n        streams = streams[0];\n      if (streams.length < 2)\n        throw new ERR_MISSING_ARGS(\"streams\");\n      const ac = new AbortController, signal = ac.signal, outerSignal = opts === null || opts === void 0 \? void 0 : opts.signal, lastStreamCleanup = [];\n      validateAbortSignal(outerSignal, \"options.signal\");\n      function abort() {\n        finishImpl(new AbortError2);\n      }\n      outerSignal === null || outerSignal === void 0 || outerSignal.addEventListener(\"abort\", abort);\n      let error, value;\n      const destroys = [];\n      let finishCount = 0;\n      function finish(err) {\n        finishImpl(err, --finishCount === 0);\n      }\n      function finishImpl(err, final) {\n        if (err && (!error || error.code === \"ERR_STREAM_PREMATURE_CLOSE\"))\n          error = err;\n        if (!error && !final)\n          return;\n        while (destroys.length)\n          destroys.shift()(error);\n        if (outerSignal === null || outerSignal === void 0 || outerSignal.removeEventListener(\"abort\", abort), ac.abort(), final) {\n          if (!error)\n            lastStreamCleanup.forEach((fn) => fn());\n          runOnNextTick(callback, error, value);\n        }\n      }\n      let ret;\n      for (let i = 0;i < streams.length; i++) {\n        const stream = streams[i], reading = i < streams.length - 1, writing = i > 0, end = reading || (opts === null || opts === void 0 \? void 0 : opts.end) !== !1, isLastStream = i === streams.length - 1;\n        if (isNodeStream(stream)) {\n          let onError = function(err) {\n            if (err && err.name !== \"AbortError\" && err.code !== \"ERR_STREAM_PREMATURE_CLOSE\")\n              finish(err);\n          };\n          if (end) {\n            const { destroy: destroy2, cleanup } = destroyer(stream, reading, writing);\n            if (destroys.push(destroy2), isReadable(stream) && isLastStream)\n              lastStreamCleanup.push(cleanup);\n          }\n          if (stream.on(\"error\", onError), isReadable(stream) && isLastStream)\n            lastStreamCleanup.push(() => {\n              stream.removeListener(\"error\", onError);\n            });\n        }\n        if (i === 0)\n          if (typeof stream === \"function\") {\n            if (ret = stream({\n              signal\n            }), !isIterable(ret))\n              throw new ERR_INVALID_RETURN_VALUE(\"Iterable, AsyncIterable or Stream\", \"source\", ret);\n          } else if (isIterable(stream) || isReadableNodeStream(stream))\n            ret = stream;\n          else\n            ret = Duplex.from(stream);\n        else if (typeof stream === \"function\")\n          if (ret = makeAsyncIterable(ret), ret = stream(ret, {\n            signal\n          }), reading) {\n            if (!isIterable(ret, !0))\n              throw new ERR_INVALID_RETURN_VALUE(\"AsyncIterable\", `transform[${i - 1}]`, ret);\n          } else {\n            var _ret;\n            if (!PassThrough)\n              PassThrough = require_passthrough();\n            const pt = new PassThrough({\n              objectMode: !0\n            }), then = (_ret = ret) === null || _ret === void 0 \? void 0 : _ret.then;\n            if (typeof then === \"function\")\n              finishCount++, then.call(ret, (val) => {\n                if (value = val, val != null)\n                  pt.write(val);\n                if (end)\n                  pt.end();\n                runOnNextTick(finish);\n              }, (err) => {\n                pt.destroy(err), runOnNextTick(finish, err);\n              });\n            else if (isIterable(ret, !0))\n              finishCount++, pump(ret, pt, finish, {\n                end\n              });\n            else\n              throw new ERR_INVALID_RETURN_VALUE(\"AsyncIterable or Promise\", \"destination\", ret);\n            ret = pt;\n            const { destroy: destroy2, cleanup } = destroyer(ret, !1, !0);\n            if (destroys.push(destroy2), isLastStream)\n              lastStreamCleanup.push(cleanup);\n          }\n        else if (isNodeStream(stream)) {\n          if (isReadableNodeStream(ret)) {\n            finishCount += 2;\n            const cleanup = pipe(ret, stream, finish, {\n              end\n            });\n            if (isReadable(stream) && isLastStream)\n              lastStreamCleanup.push(cleanup);\n          } else if (isIterable(ret))\n            finishCount++, pump(ret, stream, finish, {\n              end\n            });\n          else\n            throw new ERR_INVALID_ARG_TYPE2(\"val\", [\"Readable\", \"Iterable\", \"AsyncIterable\"], ret);\n          ret = stream;\n        } else\n          ret = Duplex.from(stream);\n      }\n      if (signal !== null && signal !== void 0 && signal.aborted || outerSignal !== null && outerSignal !== void 0 && outerSignal.aborted)\n        runOnNextTick(abort);\n      return ret;\n    }\n    function pipe(src, dst, finish, { end }) {\n      if (src.pipe(dst, {\n        end\n      }), end)\n        src.once(\"end\", () => dst.end());\n      else\n        finish();\n      return eos(src, {\n        readable: !0,\n        writable: !1\n      }, (err) => {\n        const rState = src._readableState;\n        if (err && err.code === \"ERR_STREAM_PREMATURE_CLOSE\" && rState && rState.ended && !rState.errored && !rState.errorEmitted)\n          src.once(\"end\", finish).once(\"error\", finish);\n        else\n          finish(err);\n      }), eos(dst, {\n        readable: !1,\n        writable: !0\n      }, finish);\n    }\n    module.exports = {\n      pipelineImpl,\n      pipeline\n    };\n  }\n}), require_compose = __commonJS({\n  \"node_modules/readable-stream/lib/internal/streams/compose.js\"(exports, module) {\n    var { pipeline } = require_pipeline(), Duplex = require_duplex(), { destroyer } = require_destroy(), { isNodeStream, isReadable, isWritable } = require_utils(), {\n      AbortError: AbortError2,\n      codes: { ERR_INVALID_ARG_VALUE: ERR_INVALID_ARG_VALUE2, ERR_MISSING_ARGS }\n    } = require_errors();\n    module.exports = function compose(...streams) {\n      if (streams.length === 0)\n        throw new ERR_MISSING_ARGS(\"streams\");\n      if (streams.length === 1)\n        return Duplex.from(streams[0]);\n      const orgStreams = [...streams];\n      if (typeof streams[0] === \"function\")\n        streams[0] = Duplex.from(streams[0]);\n      if (typeof streams[streams.length - 1] === \"function\") {\n        const idx = streams.length - 1;\n        streams[idx] = Duplex.from(streams[idx]);\n      }\n      for (let n = 0;n < streams.length; ++n) {\n        if (!isNodeStream(streams[n]))\n          continue;\n        if (n < streams.length - 1 && !isReadable(streams[n]))\n          throw new ERR_INVALID_ARG_VALUE2(`streams[${n}]`, orgStreams[n], \"must be readable\");\n        if (n > 0 && !isWritable(streams[n]))\n          throw new ERR_INVALID_ARG_VALUE2(`streams[${n}]`, orgStreams[n], \"must be writable\");\n      }\n      let ondrain, onfinish, onreadable, onclose, d;\n      function onfinished(err) {\n        const cb = onclose;\n        if (onclose = null, cb)\n          cb(err);\n        else if (err)\n          d.destroy(err);\n        else if (!readable && !writable)\n          d.destroy();\n      }\n      const head = streams[0], tail = pipeline(streams, onfinished), writable = !!isWritable(head), readable = !!isReadable(tail);\n      if (d = new Duplex({\n        writableObjectMode: !!(head !== null && head !== void 0 && head.writableObjectMode),\n        readableObjectMode: !!(tail !== null && tail !== void 0 && tail.writableObjectMode),\n        writable,\n        readable\n      }), writable)\n        d._write = function(chunk, encoding, callback) {\n          if (head.write(chunk, encoding))\n            callback();\n          else\n            ondrain = callback;\n        }, d._final = function(callback) {\n          head.end(), onfinish = callback;\n        }, head.on(\"drain\", function() {\n          if (ondrain) {\n            const cb = ondrain;\n            ondrain = null, cb();\n          }\n        }), tail.on(\"finish\", function() {\n          if (onfinish) {\n            const cb = onfinish;\n            onfinish = null, cb();\n          }\n        });\n      if (readable)\n        tail.on(\"readable\", function() {\n          if (onreadable) {\n            const cb = onreadable;\n            onreadable = null, cb();\n          }\n        }), tail.on(\"end\", function() {\n          d.push(null);\n        }), d._read = function() {\n          while (!0) {\n            const buf = tail.read();\n            if (buf === null) {\n              onreadable = d._read;\n              return;\n            }\n            if (!d.push(buf))\n              return;\n          }\n        };\n      return d._destroy = function(err, callback) {\n        if (!err && onclose !== null)\n          err = new AbortError2;\n        if (onreadable = null, ondrain = null, onfinish = null, onclose === null)\n          callback(err);\n        else\n          onclose = callback, destroyer(tail, err);\n      }, d;\n    };\n  }\n}), require_promises = __commonJS({\n  \"node_modules/readable-stream/lib/stream/promises.js\"(exports, module) {\n    var { ArrayPrototypePop, Promise: Promise2 } = require_primordials(), { isIterable, isNodeStream } = require_utils(), { pipelineImpl: pl } = require_pipeline(), { finished: finished2 } = require_end_of_stream();\n    function pipeline(...streams) {\n      return new Promise2((resolve, reject) => {\n        let signal, end;\n        const lastArg = streams[streams.length - 1];\n        if (lastArg && typeof lastArg === \"object\" && !isNodeStream(lastArg) && !isIterable(lastArg)) {\n          const options = ArrayPrototypePop(streams);\n          signal = options.signal, end = options.end;\n        }\n        pl(streams, (err, value) => {\n          if (err)\n            reject(err);\n          else\n            resolve(value);\n        }, {\n          signal,\n          end\n        });\n      });\n    }\n    module.exports = {\n      finished: finished2,\n      pipeline\n    };\n  }\n}), require_stream = __commonJS({\n  \"node_modules/readable-stream/lib/stream.js\"(exports, module) {\n    var { ObjectDefineProperty, ObjectKeys, ReflectApply } = require_primordials(), {\n      promisify: { custom: customPromisify }\n    } = require_util(), { streamReturningOperators, promiseReturningOperators } = require_operators(), {\n      codes: { ERR_ILLEGAL_CONSTRUCTOR }\n    } = require_errors(), compose = require_compose(), { pipeline } = require_pipeline(), { destroyer } = require_destroy(), eos = require_end_of_stream(), promises = require_promises(), utils = require_utils(), Stream = module.exports = require_legacy().Stream;\n    Stream.isDisturbed = utils.isDisturbed, Stream.isErrored = utils.isErrored, Stream.isWritable = utils.isWritable, Stream.isReadable = utils.isReadable, Stream.Readable = require_readable();\n    for (let key of ObjectKeys(streamReturningOperators)) {\n      let fn = function(...args) {\n        if (new.target)\n          throw ERR_ILLEGAL_CONSTRUCTOR();\n        return Stream.Readable.from(ReflectApply(op, this, args));\n      };\n      const op = streamReturningOperators[key];\n      ObjectDefineProperty(fn, \"name\", {\n        value: op.name\n      }), ObjectDefineProperty(fn, \"length\", {\n        value: op.length\n      }), ObjectDefineProperty(Stream.Readable.prototype, key, {\n        value: fn,\n        enumerable: !1,\n        configurable: !0,\n        writable: !0\n      });\n    }\n    for (let key of ObjectKeys(promiseReturningOperators)) {\n      let fn = function(...args) {\n        if (new.target)\n          throw ERR_ILLEGAL_CONSTRUCTOR();\n        return ReflectApply(op, this, args);\n      };\n      const op = promiseReturningOperators[key];\n      ObjectDefineProperty(fn, \"name\", {\n        value: op.name\n      }), ObjectDefineProperty(fn, \"length\", {\n        value: op.length\n      }), ObjectDefineProperty(Stream.Readable.prototype, key, {\n        value: fn,\n        enumerable: !1,\n        configurable: !0,\n        writable: !0\n      });\n    }\n    Stream.Writable = require_writable(), Stream.Duplex = require_duplex(), Stream.Transform = require_transform(), Stream.PassThrough = require_passthrough(), Stream.pipeline = pipeline;\n    var { addAbortSignal } = require_add_abort_signal();\n    Stream.addAbortSignal = addAbortSignal, Stream.finished = eos, Stream.destroy = destroyer, Stream.compose = compose, ObjectDefineProperty(Stream, \"promises\", {\n      configurable: !0,\n      enumerable: !0,\n      get() {\n        return promises;\n      }\n    }), ObjectDefineProperty(pipeline, customPromisify, {\n      enumerable: !0,\n      get() {\n        return promises.pipeline;\n      }\n    }), ObjectDefineProperty(eos, customPromisify, {\n      enumerable: !0,\n      get() {\n        return promises.finished;\n      }\n    }), Stream.Stream = Stream, Stream._isUint8Array = function isUint8Array(value) {\n      return value instanceof Uint8Array;\n    }, Stream._uint8ArrayToBuffer = function _uint8ArrayToBuffer(chunk) {\n      return new Buffer(chunk.buffer, chunk.byteOffset, chunk.byteLength);\n    };\n  }\n}), nativeReadableStreamPrototypes = {\n  0: void 0,\n  1: void 0,\n  2: void 0,\n  3: void 0,\n  4: void 0,\n  5: void 0\n}, Writable = require_writable(), NativeWritable = class NativeWritable2 extends Writable {\n  #pathOrFdOrSink;\n  #fileSink;\n  #native = !0;\n  _construct;\n  _destroy;\n  _final;\n  constructor(pathOrFdOrSink, options = {}) {\n    super(options);\n    this._construct = this.#internalConstruct, this._destroy = this.#internalDestroy, this._final = this.#internalFinal, this.#pathOrFdOrSink = pathOrFdOrSink;\n  }\n  #internalConstruct(cb) {\n    this._writableState.constructed = !0, this.constructed = !0, cb();\n  }\n  #lazyConstruct() {\n    if (typeof this.#pathOrFdOrSink === \"object\")\n      if (typeof this.#pathOrFdOrSink.write === \"function\")\n        this.#fileSink = this.#pathOrFdOrSink;\n      else\n        throw new Error(\"Invalid FileSink\");\n    else\n      this.#fileSink = Bun.file(this.#pathOrFdOrSink).writer();\n  }\n  write(chunk, encoding, cb, native = this.#native) {\n    if (!native)\n      return this.#native = !1, super.write(chunk, encoding, cb);\n    if (!this.#fileSink)\n      this.#lazyConstruct();\n    var fileSink = this.#fileSink, result = fileSink.write(chunk);\n    if (@isPromise(result))\n      return result.then(() => {\n        this.emit(\"drain\"), fileSink.flush(!0);\n      }), !1;\n    if (fileSink.flush(!0), cb)\n      cb(null, chunk.byteLength);\n    return !0;\n  }\n  end(chunk, encoding, cb, native = this.#native) {\n    return super.end(chunk, encoding, cb, native);\n  }\n  #internalDestroy(error, cb) {\n    if (this._writableState.destroyed = !0, cb)\n      cb(error);\n  }\n  #internalFinal(cb) {\n    if (this.#fileSink)\n      this.#fileSink.end();\n    if (cb)\n      cb();\n  }\n  ref() {\n    if (!this.#fileSink)\n      this.#lazyConstruct();\n    this.#fileSink.ref();\n  }\n  unref() {\n    if (!this.#fileSink)\n      return;\n    this.#fileSink.unref();\n  }\n}, exports = require_stream(), promises = require_promises();\nexports._getNativeReadableStreamPrototype = getNativeReadableStreamPrototype;\nexports.NativeWritable = NativeWritable;\nObject.defineProperty(exports, \"promises\", {\n  configurable: !0,\n  enumerable: !0,\n  get() {\n    return promises;\n  }\n});\nexports[Symbol.for(\"::bunternal::\")] = { _ReadableFromWeb, _ReadableFromWebForUndici };\nexports.eos = require_end_of_stream();\nreturn exports})\n"_s;
//

//
static constexpr ASCIILiteral NodeStreamPromisesCode = "(function (){\"use strict\";// src/js/out/tmp/node/stream.promises.ts\nreturn (@getInternalField(@internalModuleRegistry, 35) || @createInternalModuleById(35)).promises})\n"_s;
//

//
static constexpr ASCIILiteral NodeStreamWebCode = "(function (){\"use strict\";// src/js/out/tmp/node/stream.web.ts\nvar $;\n$ = {\n  ReadableStream,\n  ReadableStreamDefaultReader,\n  ReadableStreamBYOBReader,\n  ReadableStreamBYOBRequest,\n  ReadableByteStreamController,\n  ReadableStreamDefaultController,\n  TransformStream,\n  TransformStreamDefaultController,\n  WritableStream,\n  WritableStreamDefaultWriter,\n  WritableStreamDefaultController,\n  ByteLengthQueuingStrategy,\n  CountQueuingStrategy\n};\nreturn $})\n"_s;
//

//
static constexpr ASCIILiteral NodeTimersCode = "(function (){\"use strict\";// src/js/out/tmp/node/timers.ts\nvar $;\n$ = {\n  setTimeout,\n  clearTimeout,\n  setInterval,\n  setImmediate,\n  clearInterval,\n  clearImmediate\n};\nreturn $})\n"_s;
//

//
static constexpr ASCIILiteral NodeTimersPromisesCode = "(function (){\"use strict\";// src/js/out/tmp/node/timers.promises.ts\nvar validateObject = function(object, name) {\n  if (object === null || typeof object !== \"object\")\n    throw new ERR_INVALID_ARG_TYPE(name, \"Object\", object);\n}, validateBoolean = function(value, name) {\n  if (typeof value !== \"boolean\")\n    throw new ERR_INVALID_ARG_TYPE(name, \"boolean\", value);\n}, validateAbortSignal = function(signal, name) {\n  if (typeof signal !== \"undefined\" && (signal === null || typeof signal !== \"object\" || !(\"aborted\" in signal)))\n    throw new ERR_INVALID_ARG_TYPE(name, \"AbortSignal\", signal);\n}, asyncIterator = function({ next: nextFunction, return: returnFunction }) {\n  const result = {};\n  if (typeof nextFunction === \"function\")\n    result.next = nextFunction;\n  if (typeof returnFunction === \"function\")\n    result.return = returnFunction;\n  return result[symbolAsyncIterator] = function() {\n    return this;\n  }, result;\n}, setTimeoutPromise = function(after = 1, value, options = {}) {\n  const arguments_ = [].concat(value \?\? []);\n  try {\n    validateObject(options, \"options\");\n  } catch (error) {\n    return Promise.reject(error);\n  }\n  const { signal, ref: reference = !0 } = options;\n  try {\n    validateAbortSignal(signal, \"options.signal\");\n  } catch (error) {\n    return Promise.reject(error);\n  }\n  try {\n    validateBoolean(reference, \"options.ref\");\n  } catch (error) {\n    return Promise.reject(error);\n  }\n  if (signal\?.aborted)\n    return Promise.reject(new AbortError);\n  let onCancel;\n  const returnValue = new Promise((resolve, reject) => {\n    const timeout = setTimeout(() => resolve(value), after, ...arguments_);\n    if (!reference)\n      timeout\?.unref\?.();\n    if (signal)\n      onCancel = () => {\n        clearTimeout(timeout), reject(new AbortError);\n      }, signal.addEventListener(\"abort\", onCancel);\n  });\n  if (typeof onCancel !== \"undefined\")\n    returnValue.finally(() => signal.removeEventListener(\"abort\", onCancel));\n  return returnValue;\n}, setImmediatePromise = function(value, options = {}) {\n  try {\n    validateObject(options, \"options\");\n  } catch (error) {\n    return Promise.reject(error);\n  }\n  const { signal, ref: reference = !0 } = options;\n  try {\n    validateAbortSignal(signal, \"options.signal\");\n  } catch (error) {\n    return Promise.reject(error);\n  }\n  try {\n    validateBoolean(reference, \"options.ref\");\n  } catch (error) {\n    return Promise.reject(error);\n  }\n  if (signal\?.aborted)\n    return Promise.reject(new AbortError);\n  let onCancel;\n  const returnValue = new Promise((resolve, reject) => {\n    const immediate = setImmediate(() => resolve(value));\n    if (!reference)\n      immediate\?.unref\?.();\n    if (signal)\n      onCancel = () => {\n        clearImmediate(immediate), reject(new AbortError);\n      }, signal.addEventListener(\"abort\", onCancel);\n  });\n  if (typeof onCancel !== \"undefined\")\n    returnValue.finally(() => signal.removeEventListener(\"abort\", onCancel));\n  return returnValue;\n}, setIntervalPromise = function(after = 1, value, options = {}) {\n  try {\n    validateObject(options, \"options\");\n  } catch (error) {\n    return asyncIterator({\n      next: function() {\n        return Promise.reject(error);\n      }\n    });\n  }\n  const { signal, ref: reference = !0 } = options;\n  try {\n    validateAbortSignal(signal, \"options.signal\");\n  } catch (error) {\n    return asyncIterator({\n      next: function() {\n        return Promise.reject(error);\n      }\n    });\n  }\n  try {\n    validateBoolean(reference, \"options.ref\");\n  } catch (error) {\n    return asyncIterator({\n      next: function() {\n        return Promise.reject(error);\n      }\n    });\n  }\n  if (signal\?.aborted)\n    return asyncIterator({\n      next: function() {\n        return Promise.reject(new AbortError);\n      }\n    });\n  let onCancel, interval;\n  try {\n    let notYielded = 0, callback;\n    if (interval = setInterval(() => {\n      if (notYielded++, callback)\n        callback(), callback = void 0;\n    }, after), !reference)\n      interval\?.unref\?.();\n    if (signal)\n      onCancel = () => {\n        if (clearInterval(interval), callback)\n          callback(), callback = void 0;\n      }, signal.addEventListener(\"abort\", onCancel);\n    return asyncIterator({\n      next: function() {\n        return new Promise((resolve, reject) => {\n          if (!signal\?.aborted)\n            if (notYielded === 0)\n              callback = resolve;\n            else\n              resolve();\n          else if (notYielded === 0)\n            reject(new AbortError);\n          else\n            resolve();\n        }).then(() => {\n          if (notYielded > 0)\n            return notYielded = notYielded - 1, { done: !1, value };\n          return { done: !0 };\n        });\n      },\n      return: function() {\n        return clearInterval(interval), signal\?.removeEventListener(\"abort\", onCancel), Promise.resolve({});\n      }\n    });\n  } catch (error) {\n    return asyncIterator({\n      next: function() {\n        clearInterval(interval), signal\?.removeEventListener(\"abort\", onCancel);\n      }\n    });\n  }\n}, $, symbolAsyncIterator = Symbol.asyncIterator;\n\nclass ERR_INVALID_ARG_TYPE extends Error {\n  constructor(name, expected, actual) {\n    super(`${name} must be ${expected}, ${typeof actual} given`);\n    this.code = \"ERR_INVALID_ARG_TYPE\";\n  }\n}\n\nclass AbortError extends Error {\n  constructor() {\n    super(\"The operation was aborted\");\n    this.code = \"ABORT_ERR\";\n  }\n}\n$ = {\n  setTimeout: setTimeoutPromise,\n  setImmediate: setImmediatePromise,\n  setInterval: setIntervalPromise,\n  scheduler: {\n    wait: (delay, options) => setTimeoutPromise(delay, void 0, options),\n    yield: setImmediatePromise\n  }\n};\nreturn $})\n"_s;
//

//
static constexpr ASCIILiteral NodeTLSCode = "(function (){\"use strict\";// src/js/out/tmp/node/tls.ts\nvar parseCertString = function() {\n  throwNotImplemented(\"Not implemented\");\n}, isValidTLSArray = function(obj) {\n  if (typeof obj === \"string\" || isTypedArray(obj) || obj instanceof ArrayBuffer || obj instanceof Blob)\n    return !0;\n  if (Array.isArray(obj)) {\n    for (var i = 0;i < obj.length; i++)\n      if (typeof obj !== \"string\" && !isTypedArray(obj) && !(obj instanceof ArrayBuffer) && !(obj instanceof Blob))\n        return !1;\n    return !0;\n  }\n}, unfqdn = function(host2) {\n  return RegExpPrototypeSymbolReplace.call(/[.]$/, host2, \"\");\n}, toLowerCase = function(c) {\n  return StringFromCharCode.call(32 + StringPrototypeCharCodeAt.call(c, 0));\n}, splitHost = function(host2) {\n  return StringPrototypeSplit.call(RegExpPrototypeSymbolReplace.call(/[A-Z]/g, unfqdn(host2), toLowerCase), \".\");\n}, check = function(hostParts, pattern, wildcards) {\n  if (!pattern)\n    return !1;\n  const patternParts = splitHost(pattern);\n  if (hostParts.length !== patternParts.length)\n    return !1;\n  if (ArrayPrototypeIncludes.call(patternParts, \"\"))\n    return !1;\n  const isBad = (s) => RegExpPrototypeExec.call(/[^\\u0021-\\u007F]/u, s) !== null;\n  if (ArrayPrototypeSome.call(patternParts, isBad))\n    return !1;\n  for (let i = hostParts.length - 1;i > 0; i -= 1)\n    if (hostParts[i] !== patternParts[i])\n      return !1;\n  const hostSubdomain = hostParts[0], patternSubdomain = patternParts[0], patternSubdomainParts = StringPrototypeSplit.call(patternSubdomain, \"*\");\n  if (patternSubdomainParts.length === 1 || StringPrototypeIncludes.call(patternSubdomain, \"xn--\"))\n    return hostSubdomain === patternSubdomain;\n  if (!wildcards)\n    return !1;\n  if (patternSubdomainParts.length > 2)\n    return !1;\n  if (patternParts.length <= 2)\n    return !1;\n  const { 0: prefix, 1: suffix } = patternSubdomainParts;\n  if (prefix.length + suffix.length > hostSubdomain.length)\n    return !1;\n  if (!StringPrototypeStartsWith.call(hostSubdomain, prefix))\n    return !1;\n  if (!StringPrototypeEndsWith.call(hostSubdomain, suffix))\n    return !1;\n  return !0;\n}, splitEscapedAltNames = function(altNames) {\n  const result = [];\n  let currentToken = \"\", offset = 0;\n  while (offset !== altNames.length) {\n    const nextSep = StringPrototypeIndexOf.call(altNames, \", \", offset), nextQuote = StringPrototypeIndexOf.call(altNames, '\"', offset);\n    if (nextQuote !== -1 && (nextSep === -1 || nextQuote < nextSep)) {\n      currentToken += StringPrototypeSubstring.call(altNames, offset, nextQuote);\n      const match = RegExpPrototypeExec.call(jsonStringPattern, StringPrototypeSubstring.call(altNames, nextQuote));\n      if (!match) {\n        let error = new SyntaxError(\"ERR_TLS_CERT_ALTNAME_FORMAT: Invalid subject alternative name string\");\n        throw error.name = ERR_TLS_CERT_ALTNAME_FORMAT, error;\n      }\n      currentToken += JSON.parse(match[0]), offset = nextQuote + match[0].length;\n    } else if (nextSep !== -1)\n      currentToken += StringPrototypeSubstring.call(altNames, offset, nextSep), ArrayPrototypePush.call(result, currentToken), currentToken = \"\", offset = nextSep + 2;\n    else\n      currentToken += StringPrototypeSubstring.call(altNames, offset), offset = altNames.length;\n  }\n  return ArrayPrototypePush.call(result, currentToken), result;\n}, checkServerIdentity = function(hostname, cert) {\n  const { subject, subjectaltname: altNames } = cert, dnsNames = [], ips = [];\n  if (hostname = \"\" + hostname, altNames) {\n    const splitAltNames = StringPrototypeIncludes.call(altNames, '\"') \? splitEscapedAltNames(altNames) : StringPrototypeSplit.call(altNames, \", \");\n    ArrayPrototypeForEach.call(splitAltNames, (name) => {\n      if (StringPrototypeStartsWith.call(name, \"DNS:\"))\n        ArrayPrototypePush.call(dnsNames, StringPrototypeSlice.call(name, 4));\n      else if (StringPrototypeStartsWith.call(name, \"IP Address:\"))\n        ArrayPrototypePush.call(ips, canonicalizeIP(StringPrototypeSlice.call(name, 11)));\n    });\n  }\n  let valid = !1, reason = \"Unknown reason\";\n  if (hostname = unfqdn(hostname), net.isIP(hostname)) {\n    if (valid = ArrayPrototypeIncludes.call(ips, canonicalizeIP(hostname)), !valid)\n      reason = `IP: ${hostname} is not in the cert's list: ` + ArrayPrototypeJoin.call(ips, \", \");\n  } else if (dnsNames.length > 0 || subject\?.CN) {\n    const hostParts = splitHost(hostname), wildcard = (pattern) => check(hostParts, pattern, !0);\n    if (dnsNames.length > 0) {\n      if (valid = ArrayPrototypeSome.call(dnsNames, wildcard), !valid)\n        reason = `Host: ${hostname}. is not in the cert's altnames: ${altNames}`;\n    } else {\n      const cn = subject.CN;\n      if (Array.isArray(cn))\n        valid = ArrayPrototypeSome.call(cn, wildcard);\n      else if (cn)\n        valid = wildcard(cn);\n      if (!valid)\n        reason = `Host: ${hostname}. is not cert's CN: ${cn}`;\n    }\n  } else\n    reason = \"Cert does not contain a DNS name\";\n  if (!valid) {\n    let error = new Error(`ERR_TLS_CERT_ALTNAME_INVALID: Hostname/IP does not match certificate's altnames: ${reason}`);\n    return error.name = \"ERR_TLS_CERT_ALTNAME_INVALID\", error.reason = reason, error.host = host, error.cert = cert, error;\n  }\n}, SecureContext = function(options) {\n  return new InternalSecureContext(options);\n}, createSecureContext = function(options) {\n  return new SecureContext(options);\n}, translatePeerCertificate = function(c) {\n  if (!c)\n    return null;\n  if (c.issuerCertificate != null && c.issuerCertificate !== c)\n    c.issuerCertificate = translatePeerCertificate(c.issuerCertificate);\n  if (c.infoAccess != null) {\n    const info = c.infoAccess;\n    c.infoAccess = { __proto__: null }, RegExpPrototypeSymbolReplace.call(/([^\\n:]*):([^\\n]*)(\?:\\n|$)/g, info, (all, key, val) => {\n      if (val.charCodeAt(0) === 34)\n        val = JSONParse(val);\n      if (key in c.infoAccess)\n        ArrayPrototypePush.call(c.infoAccess[key], val);\n      else\n        c.infoAccess[key] = [val];\n    });\n  }\n  return c;\n}, createServer = function(options, connectionListener) {\n  return new Server(options, connectionListener);\n}, getCiphers = function() {\n  return DEFAULT_CIPHERS.split(\":\");\n}, convertProtocols = function(protocols) {\n  const lens = new Array(protocols.length), buff = Buffer.allocUnsafe(ArrayPrototypeReduce.call(protocols, (p, c, i) => {\n    const len = Buffer.byteLength(c);\n    if (len > 255)\n      @throwRangeError(\"The byte length of the protocol at index \" + `${i} exceeds the maximum length.`, \"<= 255\", len, !0);\n    return lens[i] = len, p + 1 + len;\n  }, 0));\n  let offset = 0;\n  for (let i = 0, c = protocols.length;i < c; i++)\n    buff[offset++] = lens[i], buff.write(protocols[i], offset), offset += lens[i];\n  return buff;\n}, convertALPNProtocols = function(protocols, out) {\n  if (Array.isArray(protocols))\n    out.ALPNProtocols = convertProtocols(protocols);\n  else if (isTypedArray(protocols))\n    out.ALPNProtocols = Buffer.from(protocols);\n  else if (isArrayBufferView(protocols))\n    out.ALPNProtocols = Buffer.from(protocols.buffer.slice(protocols.byteOffset, protocols.byteOffset + protocols.byteLength));\n  else if (Buffer.isBuffer(protocols))\n    out.ALPNProtocols = protocols;\n}, $, { isArrayBufferView, isTypedArray } = @requireNativeModule(\"node:util/types\"), net = @getInternalField(@internalModuleRegistry, 23) || @createInternalModuleById(23), { Server: NetServer, [Symbol.for(\"::bunternal::\")]: InternalTCPSocket } = net, bunSocketInternal = Symbol.for(\"::bunnetsocketinternal::\"), { rootCertificates, canonicalizeIP } = globalThis[globalThis.Symbol.for('Bun.lazy')](\"internal/tls\"), SymbolReplace = Symbol.replace, RegExpPrototypeSymbolReplace = RegExp.prototype[SymbolReplace], RegExpPrototypeExec = RegExp.prototype.exec, StringPrototypeStartsWith = String.prototype.startsWith, StringPrototypeSlice = String.prototype.slice, StringPrototypeIncludes = String.prototype.includes, StringPrototypeSplit = String.prototype.split, StringPrototypeIndexOf = String.prototype.indexOf, StringPrototypeSubstring = String.prototype.substring, StringPrototypeEndsWith = String.prototype.endsWith, StringFromCharCode = String.fromCharCode, StringPrototypeCharCodeAt = String.prototype.charCodeAt, ArrayPrototypeIncludes = Array.prototype.includes, ArrayPrototypeJoin = Array.prototype.join, ArrayPrototypeForEach = Array.prototype.forEach, ArrayPrototypePush = Array.prototype.push, ArrayPrototypeSome = Array.prototype.some, ArrayPrototypeReduce = Array.prototype.reduce, jsonStringPattern = /^\"(\?:[^\"\\\\\\u0000-\\u001f]|\\\\(\?:[\"\\\\/bfnrt]|u[0-9a-fA-F]{4}))*\"/, InternalSecureContext = class SecureContext2 {\n  context;\n  constructor(options) {\n    const context = {};\n    if (options) {\n      let key = options.key;\n      if (key) {\n        if (!isValidTLSArray(key))\n          @throwTypeError(\"key argument must be an string, Buffer, TypedArray, BunFile or an array containing string, Buffer, TypedArray or BunFile\");\n        this.key = key;\n      }\n      let cert = options.cert;\n      if (cert) {\n        if (!isValidTLSArray(cert))\n          @throwTypeError(\"cert argument must be an string, Buffer, TypedArray, BunFile or an array containing string, Buffer, TypedArray or BunFile\");\n        this.cert = cert;\n      }\n      let ca = options.ca;\n      if (ca) {\n        if (!isValidTLSArray(ca))\n          @throwTypeError(\"ca argument must be an string, Buffer, TypedArray, BunFile or an array containing string, Buffer, TypedArray or BunFile\");\n        this.ca = ca;\n      }\n      let passphrase = options.passphrase;\n      if (passphrase && typeof passphrase !== \"string\")\n        @throwTypeError(\"passphrase argument must be an string\");\n      this.passphrase = passphrase;\n      let servername = options.servername;\n      if (servername && typeof servername !== \"string\")\n        @throwTypeError(\"servername argument must be an string\");\n      this.servername = servername;\n      let secureOptions = options.secureOptions || 0;\n      if (secureOptions && typeof secureOptions !== \"number\")\n        @throwTypeError(\"secureOptions argument must be an number\");\n      this.secureOptions = secureOptions;\n    }\n    this.context = context;\n  }\n}, buntls = Symbol.for(\"::buntls::\"), SocketClass, TLSSocket = function(InternalTLSSocket) {\n  return SocketClass = InternalTLSSocket, Object.defineProperty(SocketClass.prototype, Symbol.toStringTag, {\n    value: \"TLSSocket\",\n    enumerable: !1\n  }), Object.defineProperty(function Socket(options) {\n    return new InternalTLSSocket(options);\n  }, Symbol.hasInstance, {\n    value(instance) {\n      return instance instanceof InternalTLSSocket;\n    }\n  });\n}(class TLSSocket2 extends InternalTCPSocket {\n  #secureContext;\n  ALPNProtocols;\n  #socket;\n  #checkServerIdentity;\n  #session;\n  constructor(socket, options) {\n    super(socket instanceof InternalTCPSocket \? options : options || socket);\n    if (options = options || socket || {}, typeof options === \"object\") {\n      const { ALPNProtocols } = options;\n      if (ALPNProtocols)\n        convertALPNProtocols(ALPNProtocols, this);\n      if (socket instanceof InternalTCPSocket)\n        this.#socket = socket;\n    }\n    this.#secureContext = options.secureContext || createSecureContext(options), this.authorized = !1, this.secureConnecting = !0, this._secureEstablished = !1, this._securePending = !0, this.#checkServerIdentity = options.checkServerIdentity || checkServerIdentity, this.#session = options.session || null;\n  }\n  _secureEstablished = !1;\n  _securePending = !0;\n  _newSessionPending;\n  _controlReleased;\n  secureConnecting = !1;\n  _SNICallback;\n  servername;\n  authorized = !1;\n  authorizationError;\n  #renegotiationDisabled = !1;\n  encrypted = !0;\n  _start() {\n    this.connect();\n  }\n  getSession() {\n    return this[bunSocketInternal]\?.getSession();\n  }\n  getEphemeralKeyInfo() {\n    return this[bunSocketInternal]\?.getEphemeralKeyInfo();\n  }\n  getCipher() {\n    return this[bunSocketInternal]\?.getCipher();\n  }\n  getSharedSigalgs() {\n    return this[bunSocketInternal]\?.getSharedSigalgs();\n  }\n  getProtocol() {\n    return this[bunSocketInternal]\?.getTLSVersion();\n  }\n  getFinished() {\n    return this[bunSocketInternal]\?.getTLSFinishedMessage() || void 0;\n  }\n  getPeerFinished() {\n    return this[bunSocketInternal]\?.getTLSPeerFinishedMessage() || void 0;\n  }\n  isSessionReused() {\n    return !!this.#session;\n  }\n  renegotiate() {\n    if (this.#renegotiationDisabled) {\n      const error = new Error(\"ERR_TLS_RENEGOTIATION_DISABLED: TLS session renegotiation disabled for this socket\");\n      throw error.name = \"ERR_TLS_RENEGOTIATION_DISABLED\", error;\n    }\n    throw Error(\"Not implented in Bun yet\");\n  }\n  disableRenegotiation() {\n    this.#renegotiationDisabled = !0;\n  }\n  getTLSTicket() {\n    return this[bunSocketInternal]\?.getTLSTicket();\n  }\n  exportKeyingMaterial(length, label, context) {\n    if (context)\n      return this[bunSocketInternal]\?.exportKeyingMaterial(length, label, context);\n    return this[bunSocketInternal]\?.exportKeyingMaterial(length, label);\n  }\n  setMaxSendFragment(size) {\n    return this[bunSocketInternal]\?.setMaxSendFragment(size) || !1;\n  }\n  enableTrace() {\n  }\n  setServername(name) {\n    if (this.isServer) {\n      let error = new Error(\"ERR_TLS_SNI_FROM_SERVER: Cannot issue SNI from a TLS server-side socket\");\n      throw error.name = \"ERR_TLS_SNI_FROM_SERVER\", error;\n    }\n    this.servername = name, this[bunSocketInternal]\?.setServername(name);\n  }\n  setSession(session) {\n    if (this.#session = session, typeof session === \"string\")\n      session = Buffer.from(session, \"latin1\");\n    return this[bunSocketInternal]\?.setSession(session);\n  }\n  getPeerCertificate(abbreviated) {\n    const cert = arguments.length < 1 \? this[bunSocketInternal]\?.getPeerCertificate() : this[bunSocketInternal]\?.getPeerCertificate(abbreviated);\n    if (cert)\n      return translatePeerCertificate(cert);\n  }\n  getCertificate() {\n    const cert = this[bunSocketInternal]\?.getCertificate();\n    if (cert)\n      return translatePeerCertificate(cert);\n  }\n  getPeerX509Certificate() {\n    throw Error(\"Not implented in Bun yet\");\n  }\n  getX509Certificate() {\n    throw Error(\"Not implented in Bun yet\");\n  }\n  get alpnProtocol() {\n    return this[bunSocketInternal]\?.alpnProtocol;\n  }\n  [buntls](port, host2) {\n    return {\n      socket: this.#socket,\n      ALPNProtocols: this.ALPNProtocols,\n      serverName: this.servername || host2 || \"localhost\",\n      checkServerIdentity: this.#checkServerIdentity,\n      session: this.#session,\n      ...this.#secureContext\n    };\n  }\n});\n\nclass Server extends NetServer {\n  key;\n  cert;\n  ca;\n  passphrase;\n  secureOptions;\n  _rejectUnauthorized;\n  _requestCert;\n  servername;\n  ALPNProtocols;\n  constructor(options, secureConnectionListener) {\n    super(options, secureConnectionListener);\n    this.setSecureContext(options);\n  }\n  setSecureContext(options) {\n    if (options instanceof InternalSecureContext)\n      options = options.context;\n    if (options) {\n      const { ALPNProtocols } = options;\n      if (ALPNProtocols)\n        convertALPNProtocols(ALPNProtocols, this);\n      let key = options.key;\n      if (key) {\n        if (!isValidTLSArray(key))\n          @throwTypeError(\"key argument must be an string, Buffer, TypedArray, BunFile or an array containing string, Buffer, TypedArray or BunFile\");\n        this.key = key;\n      }\n      let cert = options.cert;\n      if (cert) {\n        if (!isValidTLSArray(cert))\n          @throwTypeError(\"cert argument must be an string, Buffer, TypedArray, BunFile or an array containing string, Buffer, TypedArray or BunFile\");\n        this.cert = cert;\n      }\n      let ca = options.ca;\n      if (ca) {\n        if (!isValidTLSArray(ca))\n          @throwTypeError(\"ca argument must be an string, Buffer, TypedArray, BunFile or an array containing string, Buffer, TypedArray or BunFile\");\n        this.ca = ca;\n      }\n      let passphrase = options.passphrase;\n      if (passphrase && typeof passphrase !== \"string\")\n        @throwTypeError(\"passphrase argument must be an string\");\n      this.passphrase = passphrase;\n      let servername = options.servername;\n      if (servername && typeof servername !== \"string\")\n        @throwTypeError(\"servername argument must be an string\");\n      this.servername = servername;\n      let secureOptions = options.secureOptions || 0;\n      if (secureOptions && typeof secureOptions !== \"number\")\n        @throwTypeError(\"secureOptions argument must be an number\");\n      this.secureOptions = secureOptions;\n      const requestCert = options.requestCert || !1;\n      if (requestCert)\n        this._requestCert = requestCert;\n      else\n        this._requestCert = void 0;\n      const rejectUnauthorized = options.rejectUnauthorized || !1;\n      if (rejectUnauthorized)\n        this._rejectUnauthorized = rejectUnauthorized;\n      else\n        this._rejectUnauthorized = void 0;\n    }\n  }\n  getTicketKeys() {\n    throw Error(\"Not implented in Bun yet\");\n  }\n  setTicketKeys() {\n    throw Error(\"Not implented in Bun yet\");\n  }\n  [buntls](port, host2, isClient) {\n    return [\n      {\n        serverName: this.servername || host2 || \"localhost\",\n        key: this.key,\n        cert: this.cert,\n        ca: this.ca,\n        passphrase: this.passphrase,\n        secureOptions: this.secureOptions,\n        rejectUnauthorized: isClient \? !1 : this._rejectUnauthorized,\n        requestCert: isClient \? !1 : this._requestCert,\n        ALPNProtocols: this.ALPNProtocols\n      },\n      SocketClass\n    ];\n  }\n}\nvar CLIENT_RENEG_LIMIT = 3, CLIENT_RENEG_WINDOW = 600, DEFAULT_ECDH_CURVE = \"auto\", DEFAULT_CIPHERS = \"DHE-RSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-RSA-AES128-GCM-SHA256\", DEFAULT_MIN_VERSION = \"TLSv1.2\", DEFAULT_MAX_VERSION = \"TLSv1.3\", createConnection = (port, host2, connectListener) => {\n  if (typeof port === \"object\") {\n    port.checkServerIdentity;\n    const { ALPNProtocols } = port;\n    if (ALPNProtocols)\n      convertALPNProtocols(ALPNProtocols, port);\n    return new TLSSocket(port).connect(port, host2, connectListener);\n  }\n  return new TLSSocket().connect(port, host2, connectListener);\n}, connect = createConnection;\n$ = {\n  CLIENT_RENEG_LIMIT,\n  CLIENT_RENEG_WINDOW,\n  connect,\n  convertALPNProtocols,\n  createConnection,\n  createSecureContext,\n  createServer,\n  DEFAULT_CIPHERS,\n  DEFAULT_ECDH_CURVE,\n  DEFAULT_MAX_VERSION,\n  DEFAULT_MIN_VERSION,\n  getCiphers,\n  parseCertString,\n  SecureContext,\n  Server,\n  TLSSocket,\n  checkServerIdentity,\n  rootCertificates\n};\nreturn $})\n"_s;
//

//
static constexpr ASCIILiteral NodeTraceEventsCode = "(function (){\"use strict\";// src/js/out/tmp/node/trace_events.ts\nvar ERR_INVALID_ARG_TYPE = function(name, type, value) {\n  const err = @makeTypeError(`The \"${name}\" argument must be of type ${type}. Received ${value}`);\n  return err.code = \"ERR_INVALID_ARG_TYPE\", err;\n}, createTracing = function(opts) {\n  if (typeof opts !== \"object\" || opts == null)\n    throw new ERR_INVALID_ARG_TYPE(\"options\", \"Object\", opts);\n  return new Tracing(opts);\n}, getEnabledCategories = function() {\n  return \"\";\n}, $;\n\nclass Tracing {\n  enabled = !1;\n  categories = \"\";\n}\n$ = {\n  createTracing,\n  getEnabledCategories\n};\nreturn $})\n"_s;
//

//
static constexpr ASCIILiteral NodeUrlCode = "(function (){\"use strict\";// src/js/out/tmp/node/url.ts\nvar Url = function() {\n  this.protocol = null, this.slashes = null, this.auth = null, this.host = null, this.port = null, this.hostname = null, this.hash = null, this.search = null, this.query = null, this.pathname = null, this.path = null, this.href = null;\n}, urlParse = function(url, parseQueryString, slashesDenoteHost) {\n  if (url && typeof url === \"object\" && url instanceof Url)\n    return url;\n  var u = new Url;\n  return u.parse(url, parseQueryString, slashesDenoteHost), u;\n}, urlFormat = function(obj) {\n  if (typeof obj === \"string\")\n    obj = urlParse(obj);\n  if (!(obj instanceof Url))\n    return Url.prototype.format.call(obj);\n  return obj.format();\n}, urlResolve = function(source, relative) {\n  return urlParse(source, !1, !0).resolve(relative);\n}, urlResolveObject = function(source, relative) {\n  if (!source)\n    return relative;\n  return urlParse(source, !1, !0).resolveObject(relative);\n}, urlToHttpOptions = function(url) {\n  const options = {\n    protocol: url.protocol,\n    hostname: typeof url.hostname === \"string\" && url.hostname.startsWith(\"[\") \? url.hostname.slice(1, -1) : url.hostname,\n    hash: url.hash,\n    search: url.search,\n    pathname: url.pathname,\n    path: `${url.pathname || \"\"}${url.search || \"\"}`,\n    href: url.href\n  };\n  if (url.port !== \"\")\n    options.port = Number(url.port);\n  if (url.username || url.password)\n    options.auth = `${decodeURIComponent(url.username)}:${decodeURIComponent(url.password)}`;\n  return options;\n}, $, { URL, URLSearchParams } = globalThis;\nUrl.prototype = {};\nvar protocolPattern = /^([a-z0-9.+-]+:)/i, portPattern = /:[0-9]*$/, simplePathPattern = /^(\\/\\/\?(\?!\\/)[^\?\\s]*)(\\\?[^\\s]*)\?$/, delims = [\"<\", \">\", '\"', \"`\", \" \", \"\\r\", \"\\n\", \"\\t\"], unwise = [\"{\", \"}\", \"|\", \"\\\\\", \"^\", \"`\"].concat(delims), autoEscape = [\"'\"].concat(unwise), nonHostChars = [\"%\", \"/\", \"\?\", \";\", \"#\"].concat(autoEscape), hostEndingChars = [\"/\", \"\?\", \"#\"], hostnameMaxLen = 255, hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/, hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/, unsafeProtocol = {\n  javascript: !0,\n  \"javascript:\": !0\n}, hostlessProtocol = {\n  javascript: !0,\n  \"javascript:\": !0\n}, slashedProtocol = {\n  http: !0,\n  https: !0,\n  ftp: !0,\n  gopher: !0,\n  file: !0,\n  \"http:\": !0,\n  \"https:\": !0,\n  \"ftp:\": !0,\n  \"gopher:\": !0,\n  \"file:\": !0\n};\nUrl.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {\n  if (typeof url !== \"string\")\n    @throwTypeError(\"Parameter 'url' must be a string, not \" + typeof url);\n  var queryIndex = url.indexOf(\"\?\"), splitter = queryIndex !== -1 && queryIndex < url.indexOf(\"#\") \? \"\?\" : \"#\", uSplit = url.split(splitter), slashRegex = /\\\\/g;\n  uSplit[0] = uSplit[0].replace(slashRegex, \"/\"), url = uSplit.join(splitter);\n  var rest = url;\n  if (rest = rest.trim(), !slashesDenoteHost && url.split(\"#\").length === 1) {\n    var simplePath = simplePathPattern.exec(rest);\n    if (simplePath) {\n      if (this.path = rest, this.href = rest, this.pathname = simplePath[1], simplePath[2])\n        if (this.search = simplePath[2], parseQueryString)\n          this.query = new URLSearchParams(this.search.substr(1)).toJSON();\n        else\n          this.query = this.search.substr(1);\n      else if (parseQueryString)\n        this.search = \"\", this.query = {};\n      return this;\n    }\n  }\n  var proto = protocolPattern.exec(rest);\n  if (proto) {\n    proto = proto[0];\n    var lowerProto = proto.toLowerCase();\n    this.protocol = lowerProto, rest = rest.substr(proto.length);\n  }\n  if (slashesDenoteHost || proto || rest.match(/^\\/\\/[^@/]+@[^@/]+/)) {\n    var slashes = rest.substr(0, 2) === \"//\";\n    if (slashes && !(proto && hostlessProtocol[proto]))\n      rest = rest.substr(2), this.slashes = !0;\n  }\n  if (!hostlessProtocol[proto] && (slashes || proto && !slashedProtocol[proto])) {\n    var hostEnd = -1;\n    for (var i = 0;i < hostEndingChars.length; i++) {\n      var hec = rest.indexOf(hostEndingChars[i]);\n      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))\n        hostEnd = hec;\n    }\n    var auth, atSign;\n    if (hostEnd === -1)\n      atSign = rest.lastIndexOf(\"@\");\n    else\n      atSign = rest.lastIndexOf(\"@\", hostEnd);\n    if (atSign !== -1)\n      auth = rest.slice(0, atSign), rest = rest.slice(atSign + 1), this.auth = decodeURIComponent(auth);\n    hostEnd = -1;\n    for (var i = 0;i < nonHostChars.length; i++) {\n      var hec = rest.indexOf(nonHostChars[i]);\n      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))\n        hostEnd = hec;\n    }\n    if (hostEnd === -1)\n      hostEnd = rest.length;\n    this.host = rest.slice(0, hostEnd), rest = rest.slice(hostEnd), this.parseHost(), this.hostname = this.hostname || \"\";\n    var ipv6Hostname = this.hostname[0] === \"[\" && this.hostname[this.hostname.length - 1] === \"]\";\n    if (!ipv6Hostname) {\n      var hostparts = this.hostname.split(/\\./);\n      for (var i = 0, l = hostparts.length;i < l; i++) {\n        var part = hostparts[i];\n        if (!part)\n          continue;\n        if (!part.match(hostnamePartPattern)) {\n          var newpart = \"\";\n          for (var j = 0, k = part.length;j < k; j++)\n            if (part.charCodeAt(j) > 127)\n              newpart += \"x\";\n            else\n              newpart += part[j];\n          if (!newpart.match(hostnamePartPattern)) {\n            var validParts = hostparts.slice(0, i), notHost = hostparts.slice(i + 1), bit = part.match(hostnamePartStart);\n            if (bit)\n              validParts.push(bit[1]), notHost.unshift(bit[2]);\n            if (notHost.length)\n              rest = \"/\" + notHost.join(\".\") + rest;\n            this.hostname = validParts.join(\".\");\n            break;\n          }\n        }\n      }\n    }\n    if (this.hostname.length > hostnameMaxLen)\n      this.hostname = \"\";\n    else\n      this.hostname = this.hostname.toLowerCase();\n    if (!ipv6Hostname)\n      this.hostname = new URL(\"http://\" + this.hostname).hostname;\n    var p = this.port \? \":\" + this.port : \"\", h = this.hostname || \"\";\n    if (this.host = h + p, this.href += this.host, ipv6Hostname) {\n      if (this.hostname = this.hostname.substr(1, this.hostname.length - 2), rest[0] !== \"/\")\n        rest = \"/\" + rest;\n    }\n  }\n  if (!unsafeProtocol[lowerProto])\n    for (var i = 0, l = autoEscape.length;i < l; i++) {\n      var ae = autoEscape[i];\n      if (rest.indexOf(ae) === -1)\n        continue;\n      var esc = encodeURIComponent(ae);\n      if (esc === ae)\n        esc = escape(ae);\n      rest = rest.split(ae).join(esc);\n    }\n  var hash = rest.indexOf(\"#\");\n  if (hash !== -1)\n    this.hash = rest.substr(hash), rest = rest.slice(0, hash);\n  var qm = rest.indexOf(\"\?\");\n  if (qm !== -1) {\n    if (this.search = rest.substr(qm), this.query = rest.substr(qm + 1), parseQueryString)\n      this.query = new URLSearchParams(this.query);\n    rest = rest.slice(0, qm);\n  } else if (parseQueryString)\n    this.search = \"\", this.query = {};\n  if (rest)\n    this.pathname = rest;\n  if (slashedProtocol[lowerProto] && this.hostname && !this.pathname)\n    this.pathname = \"/\";\n  if (this.pathname || this.search) {\n    var p = this.pathname || \"\", s = this.search || \"\";\n    this.path = p + s;\n  }\n  return this.href = this.format(), this;\n};\nUrl.prototype.format = function() {\n  var auth = this.auth || \"\";\n  if (auth)\n    auth = encodeURIComponent(auth), auth = auth.replace(/%3A/i, \":\"), auth += \"@\";\n  var protocol = this.protocol || \"\", pathname = this.pathname || \"\", hash = this.hash || \"\", host = !1, query = \"\";\n  if (this.host)\n    host = auth + this.host;\n  else if (this.hostname) {\n    if (host = auth + (this.hostname.indexOf(\":\") === -1 \? this.hostname : \"[\" + this.hostname + \"]\"), this.port)\n      host += \":\" + this.port;\n  }\n  if (this.query && typeof this.query === \"object\" && Object.keys(this.query).length)\n    query = new URLSearchParams(this.query).toString();\n  var search = this.search || query && \"\?\" + query || \"\";\n  if (protocol && protocol.substr(-1) !== \":\")\n    protocol += \":\";\n  if (this.slashes || (!protocol || slashedProtocol[protocol]) && host !== !1) {\n    if (host = \"//\" + (host || \"\"), pathname && pathname.charAt(0) !== \"/\")\n      pathname = \"/\" + pathname;\n  } else if (!host)\n    host = \"\";\n  if (hash && hash.charAt(0) !== \"#\")\n    hash = \"#\" + hash;\n  if (search && search.charAt(0) !== \"\?\")\n    search = \"\?\" + search;\n  return pathname = pathname.replace(/[\?#]/g, function(match) {\n    return encodeURIComponent(match);\n  }), search = search.replace(\"#\", \"%23\"), protocol + host + pathname + search + hash;\n};\nUrl.prototype.resolve = function(relative) {\n  return this.resolveObject(urlParse(relative, !1, !0)).format();\n};\nUrl.prototype.resolveObject = function(relative) {\n  if (typeof relative === \"string\") {\n    var rel = new Url;\n    rel.parse(relative, !1, !0), relative = rel;\n  }\n  var result = new Url, tkeys = Object.keys(this);\n  for (var tk = 0;tk < tkeys.length; tk++) {\n    var tkey = tkeys[tk];\n    result[tkey] = this[tkey];\n  }\n  if (result.hash = relative.hash, relative.href === \"\")\n    return result.href = result.format(), result;\n  if (relative.slashes && !relative.protocol) {\n    var rkeys = Object.keys(relative);\n    for (var rk = 0;rk < rkeys.length; rk++) {\n      var rkey = rkeys[rk];\n      if (rkey !== \"protocol\")\n        result[rkey] = relative[rkey];\n    }\n    if (slashedProtocol[result.protocol] && result.hostname && !result.pathname)\n      result.pathname = \"/\", result.path = result.pathname;\n    return result.href = result.format(), result;\n  }\n  if (relative.protocol && relative.protocol !== result.protocol) {\n    if (!slashedProtocol[relative.protocol]) {\n      var keys = Object.keys(relative);\n      for (var v = 0;v < keys.length; v++) {\n        var k = keys[v];\n        result[k] = relative[k];\n      }\n      return result.href = result.format(), result;\n    }\n    if (result.protocol = relative.protocol, !relative.host && !hostlessProtocol[relative.protocol]) {\n      var relPath = (relative.pathname || \"\").split(\"/\");\n      while (relPath.length && !(relative.host = relPath.shift()))\n        ;\n      if (!relative.host)\n        relative.host = \"\";\n      if (!relative.hostname)\n        relative.hostname = \"\";\n      if (relPath[0] !== \"\")\n        relPath.unshift(\"\");\n      if (relPath.length < 2)\n        relPath.unshift(\"\");\n      result.pathname = relPath.join(\"/\");\n    } else\n      result.pathname = relative.pathname;\n    if (result.search = relative.search, result.query = relative.query, result.host = relative.host || \"\", result.auth = relative.auth, result.hostname = relative.hostname || relative.host, result.port = relative.port, result.pathname || result.search) {\n      var p = result.pathname || \"\", s = result.search || \"\";\n      result.path = p + s;\n    }\n    return result.slashes = result.slashes || relative.slashes, result.href = result.format(), result;\n  }\n  var isSourceAbs = result.pathname && result.pathname.charAt(0) === \"/\", isRelAbs = relative.host || relative.pathname && relative.pathname.charAt(0) === \"/\", mustEndAbs = isRelAbs || isSourceAbs || result.host && relative.pathname, removeAllDots = mustEndAbs, srcPath = result.pathname && result.pathname.split(\"/\") || [], relPath = relative.pathname && relative.pathname.split(\"/\") || [], psychotic = result.protocol && !slashedProtocol[result.protocol];\n  if (psychotic) {\n    if (result.hostname = \"\", result.port = null, result.host)\n      if (srcPath[0] === \"\")\n        srcPath[0] = result.host;\n      else\n        srcPath.unshift(result.host);\n    if (result.host = \"\", relative.protocol) {\n      if (relative.hostname = null, relative.port = null, relative.host)\n        if (relPath[0] === \"\")\n          relPath[0] = relative.host;\n        else\n          relPath.unshift(relative.host);\n      relative.host = null;\n    }\n    mustEndAbs = mustEndAbs && (relPath[0] === \"\" || srcPath[0] === \"\");\n  }\n  if (isRelAbs)\n    result.host = relative.host || relative.host === \"\" \? relative.host : result.host, result.hostname = relative.hostname || relative.hostname === \"\" \? relative.hostname : result.hostname, result.search = relative.search, result.query = relative.query, srcPath = relPath;\n  else if (relPath.length) {\n    if (!srcPath)\n      srcPath = [];\n    srcPath.pop(), srcPath = srcPath.concat(relPath), result.search = relative.search, result.query = relative.query;\n  } else if (relative.search != null) {\n    if (psychotic) {\n      result.host = srcPath.shift(), result.hostname = result.host;\n      var authInHost = result.host && result.host.indexOf(\"@\") > 0 \? result.host.split(\"@\") : !1;\n      if (authInHost)\n        result.auth = authInHost.shift(), result.hostname = authInHost.shift(), result.host = result.hostname;\n    }\n    if (result.search = relative.search, result.query = relative.query, result.pathname !== null || result.search !== null)\n      result.path = (result.pathname \? result.pathname : \"\") + (result.search \? result.search : \"\");\n    return result.href = result.format(), result;\n  }\n  if (!srcPath.length) {\n    if (result.pathname = null, result.search)\n      result.path = \"/\" + result.search;\n    else\n      result.path = null;\n    return result.href = result.format(), result;\n  }\n  var last = srcPath.slice(-1)[0], hasTrailingSlash = (result.host || relative.host || srcPath.length > 1) && (last === \".\" || last === \"..\") || last === \"\", up = 0;\n  for (var i = srcPath.length;i >= 0; i--)\n    if (last = srcPath[i], last === \".\")\n      srcPath.splice(i, 1);\n    else if (last === \"..\")\n      srcPath.splice(i, 1), up++;\n    else if (up)\n      srcPath.splice(i, 1), up--;\n  if (!mustEndAbs && !removeAllDots)\n    for (;up--; up)\n      srcPath.unshift(\"..\");\n  if (mustEndAbs && srcPath[0] !== \"\" && (!srcPath[0] || srcPath[0].charAt(0) !== \"/\"))\n    srcPath.unshift(\"\");\n  if (hasTrailingSlash && srcPath.join(\"/\").substr(-1) !== \"/\")\n    srcPath.push(\"\");\n  var isAbsolute = srcPath[0] === \"\" || srcPath[0] && srcPath[0].charAt(0) === \"/\";\n  if (psychotic) {\n    result.hostname = isAbsolute \? \"\" : srcPath.length \? srcPath.shift() : \"\", result.host = result.hostname;\n    var authInHost = result.host && result.host.indexOf(\"@\") > 0 \? result.host.split(\"@\") : !1;\n    if (authInHost)\n      result.auth = authInHost.shift(), result.hostname = authInHost.shift(), result.host = result.hostname;\n  }\n  if (mustEndAbs = mustEndAbs || result.host && srcPath.length, mustEndAbs && !isAbsolute)\n    srcPath.unshift(\"\");\n  if (srcPath.length > 0)\n    result.pathname = srcPath.join(\"/\");\n  else\n    result.pathname = null, result.path = null;\n  if (result.pathname !== null || result.search !== null)\n    result.path = (result.pathname \? result.pathname : \"\") + (result.search \? result.search : \"\");\n  return result.auth = relative.auth || result.auth, result.slashes = result.slashes || relative.slashes, result.href = result.format(), result;\n};\nUrl.prototype.parseHost = function() {\n  var host = this.host, port = portPattern.exec(host);\n  if (port) {\n    if (port = port[0], port !== \":\")\n      this.port = port.substr(1);\n    host = host.substr(0, host.length - port.length);\n  }\n  if (host)\n    this.hostname = host;\n};\nvar pathToFileURL = globalThis[globalThis.Symbol.for('Bun.lazy')](\"pathToFileURL\"), fileURLToPath = globalThis[globalThis.Symbol.for('Bun.lazy')](\"fileURLToPath\");\n$ = {\n  parse: urlParse,\n  resolve: urlResolve,\n  resolveObject: urlResolveObject,\n  format: urlFormat,\n  Url,\n  URLSearchParams,\n  URL,\n  pathToFileURL,\n  fileURLToPath,\n  urlToHttpOptions\n};\nreturn $})\n"_s;
//

//
static constexpr ASCIILiteral NodeUtilCode = "(function (){\"use strict\";// src/js/out/tmp/node/util.ts\nvar isBufferInterface = function({ copy, fill, readUint8 }) {\n  return typeof copy === \"function\" && typeof fill === \"function\" && typeof readUint8 === \"function\";\n}, isBuffer = function(value) {\n  return Buffer.isBuffer(value) || typeof value === \"object\" && isBufferInterface(value || {});\n}, isFunction = function(value) {\n  return typeof value === \"function\";\n}, formatWithOptions = function(inspectOptions, f) {\n  if (!isString(f)) {\n    var objects = [];\n    for (var i = 0;i < arguments.length; i++)\n      objects.push(inspect(arguments[i], inspectOptions));\n    return objects.join(\" \");\n  }\n  var i = 2, args = arguments, len = args.length, str = String(f).replace(formatRegExp, function(x2) {\n    if (x2 === \"%%\")\n      return \"%\";\n    if (i >= len)\n      return x2;\n    switch (x2) {\n      case \"%s\":\n        return String(args[i++]);\n      case \"%f\":\n        return Number(args[i++]);\n      case \"%d\":\n        return Math.round(Number(args[i++]));\n      case \"%j\":\n        try {\n          return JSON.stringify(args[i++]);\n        } catch (_) {\n          return \"[Circular]\";\n        }\n      case \"%o\":\n        return inspect(args[i++], { showHidden: !0, showProxy: !0, ...inspectOptions });\n      case \"%O\":\n        return inspect(args[i++], { showHidden: !0, showProxy: !0, ...inspectOptions });\n      default:\n        return x2;\n    }\n  });\n  for (var x = args[i];i < len; x = args[++i])\n    if (isNull(x) || !isObject(x))\n      str += \" \" + x;\n    else\n      str += \" \" + inspect(x, inspectOptions);\n  return str;\n}, format = function(...args) {\n  return formatWithOptions({}, ...args);\n}, deprecate = function(fn, msg, code) {\n  if (process.noDeprecation === !0)\n    return fn;\n  var warned = !1;\n  function deprecated() {\n    if (!warned) {\n      if (process.throwDeprecation) {\n        var err = new Error(msg);\n        if (code)\n          err.code = code;\n        throw err;\n      } else if (process.traceDeprecation)\n        console.trace(msg);\n      else\n        console.error(msg);\n      warned = !0;\n    }\n    return fn.apply(this, arguments);\n  }\n  return deprecated;\n}, debuglog = function(set) {\n  if (set = set.toUpperCase(), !debugs[set])\n    if (debugEnvRegex.test(set)) {\n      var pid = process.pid;\n      debugs[set] = function() {\n        var msg = format.apply(cjs_exports, arguments);\n        console.error(\"%s %d: %s\", set, pid, msg);\n      };\n    } else\n      debugs[set] = function() {\n      };\n  return debugs[set];\n}, inspect = function(obj, opts) {\n  var ctx = {\n    seen: [],\n    stylize: stylizeNoColor\n  };\n  if (arguments.length >= 3)\n    ctx.depth = arguments[2];\n  if (arguments.length >= 4)\n    ctx.colors = arguments[3];\n  if (isBoolean(opts))\n    ctx.showHidden = opts;\n  else if (opts)\n    _extend(ctx, opts);\n  if (isUndefined(ctx.showHidden))\n    ctx.showHidden = !1;\n  if (isUndefined(ctx.depth))\n    ctx.depth = 2;\n  if (isUndefined(ctx.colors))\n    ctx.colors = !1;\n  if (isUndefined(ctx.customInspect))\n    ctx.customInspect = !0;\n  if (ctx.colors)\n    ctx.stylize = stylizeWithColor;\n  return formatValue(ctx, obj, ctx.depth);\n}, stylizeWithColor = function(str, styleType) {\n  const style = inspect.styles[styleType];\n  if (style !== void 0) {\n    const color = inspect.colors[style];\n    if (color !== void 0)\n      return `\\x1B[${color[0]}m${str}\\x1B[${color[1]}m`;\n  }\n  return str;\n}, stylizeNoColor = function(str, styleType) {\n  return str;\n}, arrayToHash = function(array) {\n  var hash = {};\n  return array.forEach(function(val, idx) {\n    hash[val] = !0;\n  }), hash;\n}, formatValue = function(ctx, value, recurseTimes) {\n  if (ctx.customInspect && value) {\n    const customInspect = value[kInspectCustom];\n    if (isFunction(customInspect)) {\n      var ret = customInspect.call(value, recurseTimes, ctx, inspect);\n      if (!isString(ret))\n        ret = formatValue(ctx, ret, recurseTimes);\n      return ret;\n    }\n  }\n  var primitive = formatPrimitive(ctx, value);\n  if (primitive)\n    return primitive;\n  var keys = Object.keys(value).concat(Object.getOwnPropertySymbols(value)), visibleKeys = arrayToHash(keys);\n  if (ctx.showHidden)\n    keys = Object.getOwnPropertyNames(value);\n  if (isError(value) && (keys.indexOf(\"message\") >= 0 || keys.indexOf(\"description\") >= 0))\n    return formatError(value);\n  if (keys.length === 0) {\n    if (isFunction(value)) {\n      var name = value.name \? \": \" + value.name : \"\";\n      return ctx.stylize(\"[Function\" + name + \"]\", \"special\");\n    }\n    if (isRegExp(value))\n      return ctx.stylize(RegExp.prototype.toString.call(value), \"regexp\");\n    if (isDate(value))\n      return ctx.stylize(Date.prototype.toString.call(value), \"date\");\n    if (isError(value))\n      return formatError(value);\n  }\n  var base = \"\", array = !1, braces = [\"{\", \"}\"];\n  if (@isArray(value))\n    array = !0, braces = [\"[\", \"]\"];\n  if (isFunction(value)) {\n    var n = value.name \? \": \" + value.name : \"\";\n    base = \" [Function\" + n + \"]\";\n  }\n  if (isRegExp(value))\n    base = \" \" + RegExp.prototype.toString.call(value);\n  if (isDate(value))\n    base = \" \" + Date.prototype.toUTCString.call(value);\n  if (isError(value))\n    base = \" \" + formatError(value);\n  if (keys.length === 0 && (!array || value.length == 0))\n    return braces[0] + base + braces[1];\n  if (recurseTimes < 0)\n    if (isRegExp(value))\n      return ctx.stylize(RegExp.prototype.toString.call(value), \"regexp\");\n    else\n      return ctx.stylize(\"[Object]\", \"special\");\n  ctx.seen.push(value);\n  var output;\n  if (array)\n    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);\n  else\n    output = keys.map(function(key) {\n      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);\n    });\n  return ctx.seen.pop(), reduceToSingleString(output, base, braces);\n}, formatPrimitive = function(ctx, value) {\n  if (isUndefined(value))\n    return ctx.stylize(\"undefined\", \"undefined\");\n  if (isString(value)) {\n    var simple = \"'\" + JSON.stringify(value).replace(/^\"|\"$/g, \"\").replace(/'/g, \"\\\\'\").replace(/\\\\\"/g, '\"') + \"'\";\n    return ctx.stylize(simple, \"string\");\n  }\n  if (isNumber(value))\n    return ctx.stylize(\"\" + value, \"number\");\n  if (isBoolean(value))\n    return ctx.stylize(\"\" + value, \"boolean\");\n  if (isNull(value))\n    return ctx.stylize(\"null\", \"null\");\n}, formatError = function(value) {\n  return \"[\" + Error.prototype.toString.call(value) + \"]\";\n}, formatArray = function(ctx, value, recurseTimes, visibleKeys, keys) {\n  var output = [];\n  for (var i = 0, l = value.length;i < l; ++i)\n    if (hasOwnProperty(value, String(i)))\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i), !0));\n    else\n      output.push(\"\");\n  return keys.forEach(function(key) {\n    if (!key.match(/^\\d+$/))\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, !0));\n  }), output;\n}, formatProperty = function(ctx, value, recurseTimes, visibleKeys, key, array) {\n  var name, str, desc;\n  if (desc = Object.getOwnPropertyDescriptor(value, key) || {\n    value: value[key]\n  }, desc.get)\n    if (desc.set)\n      str = ctx.stylize(\"[Getter/Setter]\", \"special\");\n    else\n      str = ctx.stylize(\"[Getter]\", \"special\");\n  else if (desc.set)\n    str = ctx.stylize(\"[Setter]\", \"special\");\n  if (!hasOwnProperty(visibleKeys, key))\n    name = \"[\" + (typeof key === \"symbol\" \? key.description : key) + \"]\";\n  if (typeof key === \"symbol\")\n    name = \"[\" + ctx.stylize(`Symbol(${key.description})`, \"string\") + \"]\";\n  if (!str)\n    if (ctx.seen.indexOf(desc.value) < 0) {\n      if (isNull(recurseTimes))\n        str = formatValue(ctx, desc.value, null);\n      else\n        str = formatValue(ctx, desc.value, recurseTimes - 1);\n      if (str.indexOf(\"\\n\") > -1)\n        if (array)\n          str = str.split(\"\\n\").map(function(line) {\n            return \"  \" + line;\n          }).join(\"\\n\").substr(2);\n        else\n          str = \"\\n\" + str.split(\"\\n\").map(function(line) {\n            return \"   \" + line;\n          }).join(\"\\n\");\n    } else\n      str = ctx.stylize(\"[Circular]\", \"special\");\n  if (isUndefined(name)) {\n    if (array && key.match(/^\\d+$/))\n      return str;\n    if (name = JSON.stringify(\"\" + key), name.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/))\n      name = name.substr(1, name.length - 2), name = ctx.stylize(name, \"name\");\n    else\n      name = name.replace(/'/g, \"\\\\'\").replace(/\\\\\"/g, '\"').replace(/(^\"|\"$)/g, \"'\"), name = ctx.stylize(name, \"string\");\n  }\n  return name + \": \" + str;\n}, reduceToSingleString = function(output, base, braces) {\n  var numLinesEst = 0, length = output.reduce(function(prev, cur) {\n    if (numLinesEst++, cur.indexOf(\"\\n\") >= 0)\n      numLinesEst++;\n    return prev + cur.replace(/\\u001b\\[\\d\\d\?m/g, \"\").length + 1;\n  }, 0);\n  if (length > 60)\n    return braces[0] + (base === \"\" \? \"\" : base + \"\\n \") + \" \" + output.join(\",\\n  \") + \" \" + braces[1];\n  return braces[0] + base + \" \" + output.join(\", \") + \" \" + braces[1];\n}, isBoolean = function(arg) {\n  return typeof arg === \"boolean\";\n}, isNull = function(arg) {\n  return arg === null;\n}, isNullOrUndefined = function(arg) {\n  return arg == null;\n}, isNumber = function(arg) {\n  return typeof arg === \"number\";\n}, isString = function(arg) {\n  return typeof arg === \"string\";\n}, isSymbol = function(arg) {\n  return typeof arg === \"symbol\";\n}, isUndefined = function(arg) {\n  return arg === void 0;\n}, isObject = function(arg) {\n  return typeof arg === \"object\" && arg !== null;\n}, isPrimitive = function(arg) {\n  return arg === null || typeof arg === \"boolean\" || typeof arg === \"number\" || typeof arg === \"string\" || typeof arg === \"symbol\" || typeof arg === \"undefined\";\n}, pad = function(n) {\n  return n < 10 \? \"0\" + n.toString(10) : n.toString(10);\n}, timestamp = function() {\n  var d = new Date, time = [pad(d.getHours()), pad(d.getMinutes()), pad(d.getSeconds())].join(\":\");\n  return [d.getDate(), months[d.getMonth()], time].join(\" \");\n}, hasOwnProperty = function(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}, callbackifyOnRejected = function(reason, cb) {\n  if (!reason) {\n    var newReason = new Error(\"Promise was rejected with a falsy value\");\n    newReason.reason = reason, newReason.code = \"ERR_FALSY_VALUE_REJECTION\", reason = newReason;\n  }\n  return cb(reason);\n}, callbackify = function(original) {\n  if (typeof original !== \"function\")\n    @throwTypeError('The \"original\" argument must be of type Function');\n  function callbackified() {\n    var args = Array.prototype.slice.call(arguments), maybeCb = args.pop();\n    if (typeof maybeCb !== \"function\")\n      @throwTypeError(\"The last argument must be of type Function\");\n    var self = this, cb = function() {\n      return maybeCb.apply(self, arguments);\n    };\n    original.apply(this, args).then(function(ret) {\n      process.nextTick(cb, null, ret);\n    }, function(rej) {\n      process.nextTick(callbackifyOnRejected, rej, cb);\n    });\n  }\n  return Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original)), Object.defineProperties(callbackified, getOwnPropertyDescriptors(original)), callbackified;\n}, $, types = @requireNativeModule(\"node:util/types\"), cjs_exports = {}, deepEquals = Bun.deepEquals, isDeepStrictEqual = (a, b) => deepEquals(a, b, !0), getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors, formatRegExp = /%[sdjfoc%]/g, debugs = {}, debugEnvRegex = /^$/;\nif (process.env.NODE_DEBUG)\n  debugEnv = process.env.NODE_DEBUG, debugEnv = debugEnv.replace(/[|\\\\{}()[\\]^$+\?.]/g, \"\\\\$&\").replace(/\\*/g, \".*\").replace(/,/g, \"$|^\").toUpperCase(), debugEnvRegex = new RegExp(\"^\" + debugEnv + \"$\", \"i\");\nvar debugEnv, kInspectCustom = Symbol.for(\"nodejs.util.inspect.custom\");\ninspect.colors = {\n  bold: [1, 22],\n  italic: [3, 23],\n  underline: [4, 24],\n  inverse: [7, 27],\n  white: [37, 39],\n  grey: [90, 39],\n  black: [30, 39],\n  blue: [34, 39],\n  cyan: [36, 39],\n  green: [32, 39],\n  magenta: [35, 39],\n  red: [31, 39],\n  yellow: [33, 39]\n};\ninspect.styles = {\n  special: \"cyan\",\n  number: \"yellow\",\n  boolean: \"yellow\",\n  undefined: \"grey\",\n  null: \"bold\",\n  string: \"green\",\n  date: \"magenta\",\n  regexp: \"red\"\n};\ninspect.custom = kInspectCustom;\ninspect.defaultOptions = {\n  showHidden: !1,\n  depth: 2,\n  colors: !1,\n  customInspect: !0,\n  showProxy: !1,\n  maxArrayLength: 100,\n  maxStringLength: 1e4,\n  breakLength: 80,\n  compact: 3,\n  sorted: !1,\n  getters: !1,\n  numericSeparator: !1\n};\nvar { isRegExp, isDate, isNativeError: isError } = types, months = [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"], log = function log2() {\n  console.log(\"%s - %s\", timestamp(), format.apply(cjs_exports, arguments));\n}, inherits = function inherits2(ctor, superCtor) {\n  ctor.super_ = superCtor, ctor.prototype = Object.create(superCtor.prototype, {\n    constructor: {\n      value: ctor,\n      enumerable: !1,\n      writable: !0,\n      configurable: !0\n    }\n  });\n}, _extend = function(origin, add) {\n  if (!add || !isObject(add))\n    return origin;\n  var keys = Object.keys(add), i = keys.length;\n  while (i--)\n    origin[keys[i]] = add[keys[i]];\n  return origin;\n}, kCustomPromisifiedSymbol = Symbol.for(\"util.promisify.custom\"), promisify = function promisify2(original) {\n  if (typeof original !== \"function\")\n    @throwTypeError('The \"original\" argument must be of type Function');\n  if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {\n    var fn = original[kCustomPromisifiedSymbol];\n    if (typeof fn !== \"function\")\n      @throwTypeError('The \"util.promisify.custom\" argument must be of type Function');\n    return Object.defineProperty(fn, kCustomPromisifiedSymbol, {\n      value: fn,\n      enumerable: !1,\n      writable: !1,\n      configurable: !0\n    }), fn;\n  }\n  function fn() {\n    var promiseResolve, promiseReject, promise = new Promise(function(resolve, reject) {\n      promiseResolve = resolve, promiseReject = reject;\n    }), args = [];\n    for (var i = 0;i < arguments.length; i++)\n      args.push(arguments[i]);\n    args.push(function(err, value) {\n      if (err)\n        promiseReject(err);\n      else\n        promiseResolve(value);\n    });\n    try {\n      original.apply(this, args);\n    } catch (err) {\n      promiseReject(err);\n    }\n    return promise;\n  }\n  if (Object.setPrototypeOf(fn, Object.getPrototypeOf(original)), kCustomPromisifiedSymbol)\n    Object.defineProperty(fn, kCustomPromisifiedSymbol, {\n      value: fn,\n      enumerable: !1,\n      writable: !1,\n      configurable: !0\n    });\n  return Object.defineProperties(fn, getOwnPropertyDescriptors(original));\n};\npromisify.custom = kCustomPromisifiedSymbol;\nvar toUSVString = (input) => {\n  return (input + \"\").toWellFormed();\n};\n$ = Object.assign(cjs_exports, {\n  format,\n  formatWithOptions,\n  deprecate,\n  debuglog,\n  _extend,\n  inspect,\n  types,\n  isArray: @isArray,\n  isBoolean,\n  isNull,\n  isNullOrUndefined,\n  isNumber,\n  isString,\n  isSymbol,\n  isUndefined,\n  isRegExp,\n  isObject,\n  isDate,\n  isFunction,\n  isError,\n  isPrimitive,\n  isBuffer,\n  log,\n  inherits,\n  toUSVString,\n  promisify,\n  callbackify,\n  isDeepStrictEqual,\n  TextDecoder,\n  TextEncoder\n});\nreturn $})\n"_s;
//

//
static constexpr ASCIILiteral NodeV8Code = "(function (){\"use strict\";// src/js/out/tmp/node/v8.ts\nvar notimpl = function(message) {\n  throwNotImplemented(\"node:v8 \" + message);\n}, cachedDataVersionTag = function() {\n  notimpl(\"cachedDataVersionTag\");\n}, getHeapSnapshot = function() {\n  notimpl(\"getHeapSnapshot\");\n}, getHeapStatistics = function() {\n  notimpl(\"getHeapStatistics\");\n}, getHeapSpaceStatistics = function() {\n  notimpl(\"getHeapSpaceStatistics\");\n}, getHeapCodeStatistics = function() {\n  notimpl(\"getHeapCodeStatistics\");\n}, setFlagsFromString = function() {\n  notimpl(\"setFlagsFromString\");\n}, deserialize = function(value) {\n  return jsc.deserialize(value);\n}, takeCoverage = function() {\n  notimpl(\"takeCoverage\");\n}, stopCoverage = function() {\n  notimpl(\"stopCoverage\");\n}, serialize = function(arg1) {\n  return jsc.serialize(arg1, { binaryType: \"nodebuffer\" });\n}, writeHeapSnapshot = function() {\n  notimpl(\"writeHeapSnapshot\");\n}, setHeapSnapshotNearHeapLimit = function() {\n  notimpl(\"setHeapSnapshotNearHeapLimit\");\n}, $, { hideFromStack, throwNotImplemented } = @getInternalField(@internalModuleRegistry, 3) || @createInternalModuleById(3), jsc = @requireNativeModule(\"bun:jsc\");\n\nclass Deserializer {\n  constructor() {\n    notimpl(\"Deserializer\");\n  }\n}\n\nclass Serializer {\n  constructor() {\n    notimpl(\"Serializer\");\n  }\n}\n\nclass DefaultDeserializer extends Deserializer {\n  constructor() {\n    super(...arguments);\n  }\n}\n\nclass DefaultSerializer extends Serializer {\n  constructor() {\n    super(...arguments);\n  }\n}\n\nclass GCProfiler {\n  constructor() {\n    notimpl(\"GCProfiler\");\n  }\n}\nvar promiseHooks = {\n  createHook: () => {\n    notimpl(\"createHook\");\n  },\n  onInit: () => {\n    notimpl(\"onInit\");\n  },\n  onBefore: () => {\n    notimpl(\"onBefore\");\n  },\n  onAfter: () => {\n    notimpl(\"onAfter\");\n  },\n  onSettled: () => {\n    notimpl(\"onSettled\");\n  }\n}, startupSnapshot = {\n  addDeserializeCallback: () => notimpl(\"addDeserializeCallback\"),\n  addSerializeCallback: () => notimpl(\"addSerializeCallback\"),\n  setDeserializeMainFunction: () => notimpl(\"setDeserializeMainFunction\"),\n  isBuildingSnapshot: () => notimpl(\"isBuildingSnapshot\")\n};\n$ = {\n  cachedDataVersionTag,\n  getHeapSnapshot,\n  getHeapStatistics,\n  getHeapSpaceStatistics,\n  getHeapCodeStatistics,\n  setFlagsFromString,\n  deserialize,\n  takeCoverage,\n  stopCoverage,\n  serialize,\n  writeHeapSnapshot,\n  setHeapSnapshotNearHeapLimit,\n  promiseHooks,\n  startupSnapshot,\n  Deserializer,\n  Serializer\n};\nhideFromStack(notimpl, cachedDataVersionTag, getHeapSnapshot, getHeapStatistics, getHeapSpaceStatistics, getHeapCodeStatistics, setFlagsFromString, deserialize, takeCoverage, stopCoverage, serialize, writeHeapSnapshot, setHeapSnapshotNearHeapLimit, Deserializer, Serializer, DefaultDeserializer, DefaultSerializer, GCProfiler);\nreturn $})\n"_s;
//

//
static constexpr ASCIILiteral NodeVMCode = "(function (){\"use strict\";// src/js/out/tmp/node/vm.ts\nvar runInContext = function(code, context, options) {\n  return new Script(code, options).runInContext(context);\n}, compileFunction = function() {\n  throwNotImplemented(\"node:vm compileFunction\");\n}, measureMemory = function() {\n  throwNotImplemented(\"node:vm measureMemory\");\n}, $, { throwNotImplemented } = @getInternalField(@internalModuleRegistry, 3) || @createInternalModuleById(3), vm = globalThis[globalThis.Symbol.for('Bun.lazy')](\"vm\"), { createContext, isContext, Script, runInNewContext, runInThisContext } = vm;\n\nclass Module {\n  constructor() {\n    throwNotImplemented(\"node:vm Module\");\n  }\n}\n\nclass SourceTextModule {\n  constructor() {\n    throwNotImplemented(\"node:vm Module\");\n  }\n}\n\nclass SyntheticModule {\n  constructor() {\n    throwNotImplemented(\"node:vm Module\");\n  }\n}\n$ = {\n  createContext,\n  runInContext,\n  runInNewContext,\n  runInThisContext,\n  isContext,\n  compileFunction,\n  measureMemory,\n  Script,\n  Module,\n  SourceTextModule,\n  SyntheticModule\n};\nreturn $})\n"_s;
//

//
static constexpr ASCIILiteral NodeWasiCode = "(function (){\"use strict\";// src/js/out/tmp/node/wasi.ts\nvar nodeFsConstants = @processBindingConstants.fs, __getOwnPropNames = Object.getOwnPropertyNames, __commonJS = (cb, mod) => function __require2() {\n  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;\n}, require_types = __commonJS({\n  \"node_modules/wasi-js/dist/types.js\"(exports) {\n    Object.defineProperty(exports, \"__esModule\", { value: !0 }), exports.WASIKillError = exports.WASIExitError = exports.WASIError = void 0;\n    var WASIError = class extends Error {\n      constructor(errno) {\n        super();\n        this.errno = errno, Object.setPrototypeOf(this, WASIError.prototype);\n      }\n    };\n    exports.WASIError = WASIError;\n    var WASIExitError = class extends Error {\n      constructor(code) {\n        super(`WASI Exit error: ${code}`);\n        this.code = code, Object.setPrototypeOf(this, WASIExitError.prototype);\n      }\n    };\n    exports.WASIExitError = WASIExitError;\n    var WASIKillError = class extends Error {\n      constructor(signal) {\n        super(`WASI Kill signal: ${signal}`);\n        this.signal = signal, Object.setPrototypeOf(this, WASIKillError.prototype);\n      }\n    };\n    exports.WASIKillError = WASIKillError;\n  }\n}), require_constants = __commonJS({\n  \"node_modules/wasi-js/dist/constants.js\"(exports) {\n    Object.defineProperty(exports, \"__esModule\", { value: !0 }), exports.WASI_ENOMSG = exports.WASI_ENOMEM = exports.WASI_ENOLINK = exports.WASI_ENOLCK = exports.WASI_ENOEXEC = exports.WASI_ENOENT = exports.WASI_ENODEV = exports.WASI_ENOBUFS = exports.WASI_ENFILE = exports.WASI_ENETUNREACH = exports.WASI_ENETRESET = exports.WASI_ENETDOWN = exports.WASI_ENAMETOOLONG = exports.WASI_EMULTIHOP = exports.WASI_EMSGSIZE = exports.WASI_EMLINK = exports.WASI_EMFILE = exports.WASI_ELOOP = exports.WASI_EISDIR = exports.WASI_EISCONN = exports.WASI_EIO = exports.WASI_EINVAL = exports.WASI_EINTR = exports.WASI_EINPROGRESS = exports.WASI_EILSEQ = exports.WASI_EIDRM = exports.WASI_EHOSTUNREACH = exports.WASI_EFBIG = exports.WASI_EFAULT = exports.WASI_EEXIST = exports.WASI_EDQUOT = exports.WASI_EDOM = exports.WASI_EDESTADDRREQ = exports.WASI_EDEADLK = exports.WASI_ECONNRESET = exports.WASI_ECONNREFUSED = exports.WASI_ECONNABORTED = exports.WASI_ECHILD = exports.WASI_ECANCELED = exports.WASI_EBUSY = exports.WASI_EBADMSG = exports.WASI_EBADF = exports.WASI_EALREADY = exports.WASI_EAGAIN = exports.WASI_EAFNOSUPPORT = exports.WASI_EADDRNOTAVAIL = exports.WASI_EADDRINUSE = exports.WASI_EACCES = exports.WASI_E2BIG = exports.WASI_ESUCCESS = void 0, exports.WASI_SIGVTALRM = exports.WASI_SIGUSR2 = exports.WASI_SIGUSR1 = exports.WASI_SIGURG = exports.WASI_SIGTTOU = exports.WASI_SIGTTIN = exports.WASI_SIGTSTP = exports.WASI_SIGTRAP = exports.WASI_SIGTERM = exports.WASI_SIGSTOP = exports.WASI_SIGSEGV = exports.WASI_SIGQUIT = exports.WASI_SIGPIPE = exports.WASI_SIGKILL = exports.WASI_SIGINT = exports.WASI_SIGILL = exports.WASI_SIGHUP = exports.WASI_SIGFPE = exports.WASI_SIGCONT = exports.WASI_SIGCHLD = exports.WASI_SIGBUS = exports.WASI_SIGALRM = exports.WASI_SIGABRT = exports.WASI_ENOTCAPABLE = exports.WASI_EXDEV = exports.WASI_ETXTBSY = exports.WASI_ETIMEDOUT = exports.WASI_ESTALE = exports.WASI_ESRCH = exports.WASI_ESPIPE = exports.WASI_EROFS = exports.WASI_ERANGE = exports.WASI_EPROTOTYPE = exports.WASI_EPROTONOSUPPORT = exports.WASI_EPROTO = exports.WASI_EPIPE = exports.WASI_EPERM = exports.WASI_EOWNERDEAD = exports.WASI_EOVERFLOW = exports.WASI_ENXIO = exports.WASI_ENOTTY = exports.WASI_ENOTSUP = exports.WASI_ENOTSOCK = exports.WASI_ENOTRECOVERABLE = exports.WASI_ENOTEMPTY = exports.WASI_ENOTDIR = exports.WASI_ENOTCONN = exports.WASI_ENOSYS = exports.WASI_ENOSPC = exports.WASI_ENOPROTOOPT = void 0, exports.RIGHTS_REGULAR_FILE_BASE = exports.RIGHTS_CHARACTER_DEVICE_INHERITING = exports.RIGHTS_CHARACTER_DEVICE_BASE = exports.RIGHTS_BLOCK_DEVICE_INHERITING = exports.RIGHTS_BLOCK_DEVICE_BASE = exports.RIGHTS_ALL = exports.WASI_RIGHT_SOCK_SHUTDOWN = exports.WASI_RIGHT_POLL_FD_READWRITE = exports.WASI_RIGHT_PATH_UNLINK_FILE = exports.WASI_RIGHT_PATH_REMOVE_DIRECTORY = exports.WASI_RIGHT_PATH_SYMLINK = exports.WASI_RIGHT_FD_FILESTAT_SET_TIMES = exports.WASI_RIGHT_FD_FILESTAT_SET_SIZE = exports.WASI_RIGHT_FD_FILESTAT_GET = exports.WASI_RIGHT_PATH_FILESTAT_SET_TIMES = exports.WASI_RIGHT_PATH_FILESTAT_SET_SIZE = exports.WASI_RIGHT_PATH_FILESTAT_GET = exports.WASI_RIGHT_PATH_RENAME_TARGET = exports.WASI_RIGHT_PATH_RENAME_SOURCE = exports.WASI_RIGHT_PATH_READLINK = exports.WASI_RIGHT_FD_READDIR = exports.WASI_RIGHT_PATH_OPEN = exports.WASI_RIGHT_PATH_LINK_TARGET = exports.WASI_RIGHT_PATH_LINK_SOURCE = exports.WASI_RIGHT_PATH_CREATE_FILE = exports.WASI_RIGHT_PATH_CREATE_DIRECTORY = exports.WASI_RIGHT_FD_ALLOCATE = exports.WASI_RIGHT_FD_ADVISE = exports.WASI_RIGHT_FD_WRITE = exports.WASI_RIGHT_FD_TELL = exports.WASI_RIGHT_FD_SYNC = exports.WASI_RIGHT_FD_FDSTAT_SET_FLAGS = exports.WASI_RIGHT_FD_SEEK = exports.WASI_RIGHT_FD_READ = exports.WASI_RIGHT_FD_DATASYNC = exports.WASI_FDFLAG_SYNC = exports.WASI_FDFLAG_RSYNC = exports.WASI_FDFLAG_NONBLOCK = exports.WASI_FDFLAG_DSYNC = exports.WASI_FDFLAG_APPEND = exports.WASI_FILETYPE_SYMBOLIC_LINK = exports.WASI_FILETYPE_SOCKET_STREAM = exports.WASI_FILETYPE_SOCKET_DGRAM = exports.WASI_FILETYPE_REGULAR_FILE = exports.WASI_FILETYPE_DIRECTORY = exports.WASI_FILETYPE_CHARACTER_DEVICE = exports.WASI_FILETYPE_BLOCK_DEVICE = exports.WASI_FILETYPE_UNKNOWN = exports.WASI_SIGXFSZ = exports.WASI_SIGXCPU = void 0, exports.SIGNAL_MAP = exports.ERROR_MAP = exports.WASI_WHENCE_END = exports.WASI_WHENCE_CUR = exports.WASI_WHENCE_SET = exports.WASI_STDERR_FILENO = exports.WASI_STDOUT_FILENO = exports.WASI_STDIN_FILENO = exports.WASI_DIRCOOKIE_START = exports.WASI_PREOPENTYPE_DIR = exports.WASI_O_TRUNC = exports.WASI_O_EXCL = exports.WASI_O_DIRECTORY = exports.WASI_O_CREAT = exports.WASI_FILESTAT_SET_MTIM_NOW = exports.WASI_FILESTAT_SET_MTIM = exports.WASI_FILESTAT_SET_ATIM_NOW = exports.WASI_FILESTAT_SET_ATIM = exports.WASI_EVENTTYPE_FD_WRITE = exports.WASI_EVENTTYPE_FD_READ = exports.WASI_EVENTTYPE_CLOCK = exports.WASI_CLOCK_THREAD_CPUTIME_ID = exports.WASI_CLOCK_PROCESS_CPUTIME_ID = exports.WASI_CLOCK_MONOTONIC = exports.WASI_CLOCK_REALTIME = exports.RIGHTS_TTY_INHERITING = exports.RIGHTS_TTY_BASE = exports.RIGHTS_SOCKET_INHERITING = exports.RIGHTS_SOCKET_BASE = exports.RIGHTS_DIRECTORY_INHERITING = exports.RIGHTS_DIRECTORY_BASE = exports.RIGHTS_REGULAR_FILE_INHERITING = void 0, exports.WASI_ESUCCESS = 0, exports.WASI_E2BIG = 1, exports.WASI_EACCES = 2, exports.WASI_EADDRINUSE = 3, exports.WASI_EADDRNOTAVAIL = 4, exports.WASI_EAFNOSUPPORT = 5, exports.WASI_EAGAIN = 6, exports.WASI_EALREADY = 7, exports.WASI_EBADF = 8, exports.WASI_EBADMSG = 9, exports.WASI_EBUSY = 10, exports.WASI_ECANCELED = 11, exports.WASI_ECHILD = 12, exports.WASI_ECONNABORTED = 13, exports.WASI_ECONNREFUSED = 14, exports.WASI_ECONNRESET = 15, exports.WASI_EDEADLK = 16, exports.WASI_EDESTADDRREQ = 17, exports.WASI_EDOM = 18, exports.WASI_EDQUOT = 19, exports.WASI_EEXIST = 20, exports.WASI_EFAULT = 21, exports.WASI_EFBIG = 22, exports.WASI_EHOSTUNREACH = 23, exports.WASI_EIDRM = 24, exports.WASI_EILSEQ = 25, exports.WASI_EINPROGRESS = 26, exports.WASI_EINTR = 27, exports.WASI_EINVAL = 28, exports.WASI_EIO = 29, exports.WASI_EISCONN = 30, exports.WASI_EISDIR = 31, exports.WASI_ELOOP = 32, exports.WASI_EMFILE = 33, exports.WASI_EMLINK = 34, exports.WASI_EMSGSIZE = 35, exports.WASI_EMULTIHOP = 36, exports.WASI_ENAMETOOLONG = 37, exports.WASI_ENETDOWN = 38, exports.WASI_ENETRESET = 39, exports.WASI_ENETUNREACH = 40, exports.WASI_ENFILE = 41, exports.WASI_ENOBUFS = 42, exports.WASI_ENODEV = 43, exports.WASI_ENOENT = 44, exports.WASI_ENOEXEC = 45, exports.WASI_ENOLCK = 46, exports.WASI_ENOLINK = 47, exports.WASI_ENOMEM = 48, exports.WASI_ENOMSG = 49, exports.WASI_ENOPROTOOPT = 50, exports.WASI_ENOSPC = 51, exports.WASI_ENOSYS = 52, exports.WASI_ENOTCONN = 53, exports.WASI_ENOTDIR = 54, exports.WASI_ENOTEMPTY = 55, exports.WASI_ENOTRECOVERABLE = 56, exports.WASI_ENOTSOCK = 57, exports.WASI_ENOTSUP = 58, exports.WASI_ENOTTY = 59, exports.WASI_ENXIO = 60, exports.WASI_EOVERFLOW = 61, exports.WASI_EOWNERDEAD = 62, exports.WASI_EPERM = 63, exports.WASI_EPIPE = 64, exports.WASI_EPROTO = 65, exports.WASI_EPROTONOSUPPORT = 66, exports.WASI_EPROTOTYPE = 67, exports.WASI_ERANGE = 68, exports.WASI_EROFS = 69, exports.WASI_ESPIPE = 70, exports.WASI_ESRCH = 71, exports.WASI_ESTALE = 72, exports.WASI_ETIMEDOUT = 73, exports.WASI_ETXTBSY = 74, exports.WASI_EXDEV = 75, exports.WASI_ENOTCAPABLE = 76, exports.WASI_SIGABRT = 0, exports.WASI_SIGALRM = 1, exports.WASI_SIGBUS = 2, exports.WASI_SIGCHLD = 3, exports.WASI_SIGCONT = 4, exports.WASI_SIGFPE = 5, exports.WASI_SIGHUP = 6, exports.WASI_SIGILL = 7, exports.WASI_SIGINT = 8, exports.WASI_SIGKILL = 9, exports.WASI_SIGPIPE = 10, exports.WASI_SIGQUIT = 11, exports.WASI_SIGSEGV = 12, exports.WASI_SIGSTOP = 13, exports.WASI_SIGTERM = 14, exports.WASI_SIGTRAP = 15, exports.WASI_SIGTSTP = 16, exports.WASI_SIGTTIN = 17, exports.WASI_SIGTTOU = 18, exports.WASI_SIGURG = 19, exports.WASI_SIGUSR1 = 20, exports.WASI_SIGUSR2 = 21, exports.WASI_SIGVTALRM = 22, exports.WASI_SIGXCPU = 23, exports.WASI_SIGXFSZ = 24, exports.WASI_FILETYPE_UNKNOWN = 0, exports.WASI_FILETYPE_BLOCK_DEVICE = 1, exports.WASI_FILETYPE_CHARACTER_DEVICE = 2, exports.WASI_FILETYPE_DIRECTORY = 3, exports.WASI_FILETYPE_REGULAR_FILE = 4, exports.WASI_FILETYPE_SOCKET_DGRAM = 5, exports.WASI_FILETYPE_SOCKET_STREAM = 6, exports.WASI_FILETYPE_SYMBOLIC_LINK = 7, exports.WASI_FDFLAG_APPEND = 1, exports.WASI_FDFLAG_DSYNC = 2, exports.WASI_FDFLAG_NONBLOCK = 4, exports.WASI_FDFLAG_RSYNC = 8, exports.WASI_FDFLAG_SYNC = 16, exports.WASI_RIGHT_FD_DATASYNC = BigInt(1), exports.WASI_RIGHT_FD_READ = BigInt(2), exports.WASI_RIGHT_FD_SEEK = BigInt(4), exports.WASI_RIGHT_FD_FDSTAT_SET_FLAGS = BigInt(8), exports.WASI_RIGHT_FD_SYNC = BigInt(16), exports.WASI_RIGHT_FD_TELL = BigInt(32), exports.WASI_RIGHT_FD_WRITE = BigInt(64), exports.WASI_RIGHT_FD_ADVISE = BigInt(128), exports.WASI_RIGHT_FD_ALLOCATE = BigInt(256), exports.WASI_RIGHT_PATH_CREATE_DIRECTORY = BigInt(512), exports.WASI_RIGHT_PATH_CREATE_FILE = BigInt(1024), exports.WASI_RIGHT_PATH_LINK_SOURCE = BigInt(2048), exports.WASI_RIGHT_PATH_LINK_TARGET = BigInt(4096), exports.WASI_RIGHT_PATH_OPEN = BigInt(8192), exports.WASI_RIGHT_FD_READDIR = BigInt(16384), exports.WASI_RIGHT_PATH_READLINK = BigInt(32768), exports.WASI_RIGHT_PATH_RENAME_SOURCE = BigInt(65536), exports.WASI_RIGHT_PATH_RENAME_TARGET = BigInt(131072), exports.WASI_RIGHT_PATH_FILESTAT_GET = BigInt(262144), exports.WASI_RIGHT_PATH_FILESTAT_SET_SIZE = BigInt(524288), exports.WASI_RIGHT_PATH_FILESTAT_SET_TIMES = BigInt(1048576), exports.WASI_RIGHT_FD_FILESTAT_GET = BigInt(2097152), exports.WASI_RIGHT_FD_FILESTAT_SET_SIZE = BigInt(4194304), exports.WASI_RIGHT_FD_FILESTAT_SET_TIMES = BigInt(8388608), exports.WASI_RIGHT_PATH_SYMLINK = BigInt(16777216), exports.WASI_RIGHT_PATH_REMOVE_DIRECTORY = BigInt(33554432), exports.WASI_RIGHT_PATH_UNLINK_FILE = BigInt(67108864), exports.WASI_RIGHT_POLL_FD_READWRITE = BigInt(134217728), exports.WASI_RIGHT_SOCK_SHUTDOWN = BigInt(268435456), exports.RIGHTS_ALL = exports.WASI_RIGHT_FD_DATASYNC | exports.WASI_RIGHT_FD_READ | exports.WASI_RIGHT_FD_SEEK | exports.WASI_RIGHT_FD_FDSTAT_SET_FLAGS | exports.WASI_RIGHT_FD_SYNC | exports.WASI_RIGHT_FD_TELL | exports.WASI_RIGHT_FD_WRITE | exports.WASI_RIGHT_FD_ADVISE | exports.WASI_RIGHT_FD_ALLOCATE | exports.WASI_RIGHT_PATH_CREATE_DIRECTORY | exports.WASI_RIGHT_PATH_CREATE_FILE | exports.WASI_RIGHT_PATH_LINK_SOURCE | exports.WASI_RIGHT_PATH_LINK_TARGET | exports.WASI_RIGHT_PATH_OPEN | exports.WASI_RIGHT_FD_READDIR | exports.WASI_RIGHT_PATH_READLINK | exports.WASI_RIGHT_PATH_RENAME_SOURCE | exports.WASI_RIGHT_PATH_RENAME_TARGET | exports.WASI_RIGHT_PATH_FILESTAT_GET | exports.WASI_RIGHT_PATH_FILESTAT_SET_SIZE | exports.WASI_RIGHT_PATH_FILESTAT_SET_TIMES | exports.WASI_RIGHT_FD_FILESTAT_GET | exports.WASI_RIGHT_FD_FILESTAT_SET_TIMES | exports.WASI_RIGHT_FD_FILESTAT_SET_SIZE | exports.WASI_RIGHT_PATH_SYMLINK | exports.WASI_RIGHT_PATH_UNLINK_FILE | exports.WASI_RIGHT_PATH_REMOVE_DIRECTORY | exports.WASI_RIGHT_POLL_FD_READWRITE | exports.WASI_RIGHT_SOCK_SHUTDOWN, exports.RIGHTS_BLOCK_DEVICE_BASE = exports.RIGHTS_ALL, exports.RIGHTS_BLOCK_DEVICE_INHERITING = exports.RIGHTS_ALL, exports.RIGHTS_CHARACTER_DEVICE_BASE = exports.RIGHTS_ALL, exports.RIGHTS_CHARACTER_DEVICE_INHERITING = exports.RIGHTS_ALL, exports.RIGHTS_REGULAR_FILE_BASE = exports.WASI_RIGHT_FD_DATASYNC | exports.WASI_RIGHT_FD_READ | exports.WASI_RIGHT_FD_SEEK | exports.WASI_RIGHT_FD_FDSTAT_SET_FLAGS | exports.WASI_RIGHT_FD_SYNC | exports.WASI_RIGHT_FD_TELL | exports.WASI_RIGHT_FD_WRITE | exports.WASI_RIGHT_FD_ADVISE | exports.WASI_RIGHT_FD_ALLOCATE | exports.WASI_RIGHT_FD_FILESTAT_GET | exports.WASI_RIGHT_FD_FILESTAT_SET_SIZE | exports.WASI_RIGHT_FD_FILESTAT_SET_TIMES | exports.WASI_RIGHT_POLL_FD_READWRITE, exports.RIGHTS_REGULAR_FILE_INHERITING = BigInt(0), exports.RIGHTS_DIRECTORY_BASE = exports.WASI_RIGHT_FD_FDSTAT_SET_FLAGS | exports.WASI_RIGHT_FD_SYNC | exports.WASI_RIGHT_FD_ADVISE | exports.WASI_RIGHT_PATH_CREATE_DIRECTORY | exports.WASI_RIGHT_PATH_CREATE_FILE | exports.WASI_RIGHT_PATH_LINK_SOURCE | exports.WASI_RIGHT_PATH_LINK_TARGET | exports.WASI_RIGHT_PATH_OPEN | exports.WASI_RIGHT_FD_READDIR | exports.WASI_RIGHT_PATH_READLINK | exports.WASI_RIGHT_PATH_RENAME_SOURCE | exports.WASI_RIGHT_PATH_RENAME_TARGET | exports.WASI_RIGHT_PATH_FILESTAT_GET | exports.WASI_RIGHT_PATH_FILESTAT_SET_SIZE | exports.WASI_RIGHT_PATH_FILESTAT_SET_TIMES | exports.WASI_RIGHT_FD_FILESTAT_GET | exports.WASI_RIGHT_FD_FILESTAT_SET_TIMES | exports.WASI_RIGHT_PATH_SYMLINK | exports.WASI_RIGHT_PATH_UNLINK_FILE | exports.WASI_RIGHT_PATH_REMOVE_DIRECTORY | exports.WASI_RIGHT_POLL_FD_READWRITE, exports.RIGHTS_DIRECTORY_INHERITING = exports.RIGHTS_DIRECTORY_BASE | exports.RIGHTS_REGULAR_FILE_BASE, exports.RIGHTS_SOCKET_BASE = exports.WASI_RIGHT_FD_READ | exports.WASI_RIGHT_FD_FDSTAT_SET_FLAGS | exports.WASI_RIGHT_FD_WRITE | exports.WASI_RIGHT_FD_FILESTAT_GET | exports.WASI_RIGHT_POLL_FD_READWRITE | exports.WASI_RIGHT_SOCK_SHUTDOWN, exports.RIGHTS_SOCKET_INHERITING = exports.RIGHTS_ALL, exports.RIGHTS_TTY_BASE = exports.WASI_RIGHT_FD_READ | exports.WASI_RIGHT_FD_FDSTAT_SET_FLAGS | exports.WASI_RIGHT_FD_WRITE | exports.WASI_RIGHT_FD_FILESTAT_GET | exports.WASI_RIGHT_POLL_FD_READWRITE, exports.RIGHTS_TTY_INHERITING = BigInt(0), exports.WASI_CLOCK_REALTIME = 0, exports.WASI_CLOCK_MONOTONIC = 1, exports.WASI_CLOCK_PROCESS_CPUTIME_ID = 2, exports.WASI_CLOCK_THREAD_CPUTIME_ID = 3, exports.WASI_EVENTTYPE_CLOCK = 0, exports.WASI_EVENTTYPE_FD_READ = 1, exports.WASI_EVENTTYPE_FD_WRITE = 2, exports.WASI_FILESTAT_SET_ATIM = 1 << 0, exports.WASI_FILESTAT_SET_ATIM_NOW = 1 << 1, exports.WASI_FILESTAT_SET_MTIM = 1 << 2, exports.WASI_FILESTAT_SET_MTIM_NOW = 1 << 3, exports.WASI_O_CREAT = 1 << 0, exports.WASI_O_DIRECTORY = 1 << 1, exports.WASI_O_EXCL = 1 << 2, exports.WASI_O_TRUNC = 1 << 3, exports.WASI_PREOPENTYPE_DIR = 0, exports.WASI_DIRCOOKIE_START = 0, exports.WASI_STDIN_FILENO = 0, exports.WASI_STDOUT_FILENO = 1, exports.WASI_STDERR_FILENO = 2, exports.WASI_WHENCE_SET = 0, exports.WASI_WHENCE_CUR = 1, exports.WASI_WHENCE_END = 2, exports.ERROR_MAP = {\n      E2BIG: exports.WASI_E2BIG,\n      EACCES: exports.WASI_EACCES,\n      EADDRINUSE: exports.WASI_EADDRINUSE,\n      EADDRNOTAVAIL: exports.WASI_EADDRNOTAVAIL,\n      EAFNOSUPPORT: exports.WASI_EAFNOSUPPORT,\n      EALREADY: exports.WASI_EALREADY,\n      EAGAIN: exports.WASI_EAGAIN,\n      EBADF: exports.WASI_EBADF,\n      EBADMSG: exports.WASI_EBADMSG,\n      EBUSY: exports.WASI_EBUSY,\n      ECANCELED: exports.WASI_ECANCELED,\n      ECHILD: exports.WASI_ECHILD,\n      ECONNABORTED: exports.WASI_ECONNABORTED,\n      ECONNREFUSED: exports.WASI_ECONNREFUSED,\n      ECONNRESET: exports.WASI_ECONNRESET,\n      EDEADLOCK: exports.WASI_EDEADLK,\n      EDESTADDRREQ: exports.WASI_EDESTADDRREQ,\n      EDOM: exports.WASI_EDOM,\n      EDQUOT: exports.WASI_EDQUOT,\n      EEXIST: exports.WASI_EEXIST,\n      EFAULT: exports.WASI_EFAULT,\n      EFBIG: exports.WASI_EFBIG,\n      EHOSTDOWN: exports.WASI_EHOSTUNREACH,\n      EHOSTUNREACH: exports.WASI_EHOSTUNREACH,\n      EIDRM: exports.WASI_EIDRM,\n      EILSEQ: exports.WASI_EILSEQ,\n      EINPROGRESS: exports.WASI_EINPROGRESS,\n      EINTR: exports.WASI_EINTR,\n      EINVAL: exports.WASI_EINVAL,\n      EIO: exports.WASI_EIO,\n      EISCONN: exports.WASI_EISCONN,\n      EISDIR: exports.WASI_EISDIR,\n      ELOOP: exports.WASI_ELOOP,\n      EMFILE: exports.WASI_EMFILE,\n      EMLINK: exports.WASI_EMLINK,\n      EMSGSIZE: exports.WASI_EMSGSIZE,\n      EMULTIHOP: exports.WASI_EMULTIHOP,\n      ENAMETOOLONG: exports.WASI_ENAMETOOLONG,\n      ENETDOWN: exports.WASI_ENETDOWN,\n      ENETRESET: exports.WASI_ENETRESET,\n      ENETUNREACH: exports.WASI_ENETUNREACH,\n      ENFILE: exports.WASI_ENFILE,\n      ENOBUFS: exports.WASI_ENOBUFS,\n      ENODEV: exports.WASI_ENODEV,\n      ENOENT: exports.WASI_ENOENT,\n      ENOEXEC: exports.WASI_ENOEXEC,\n      ENOLCK: exports.WASI_ENOLCK,\n      ENOLINK: exports.WASI_ENOLINK,\n      ENOMEM: exports.WASI_ENOMEM,\n      ENOMSG: exports.WASI_ENOMSG,\n      ENOPROTOOPT: exports.WASI_ENOPROTOOPT,\n      ENOSPC: exports.WASI_ENOSPC,\n      ENOSYS: exports.WASI_ENOSYS,\n      ENOTCONN: exports.WASI_ENOTCONN,\n      ENOTDIR: exports.WASI_ENOTDIR,\n      ENOTEMPTY: exports.WASI_ENOTEMPTY,\n      ENOTRECOVERABLE: exports.WASI_ENOTRECOVERABLE,\n      ENOTSOCK: exports.WASI_ENOTSOCK,\n      ENOTTY: exports.WASI_ENOTTY,\n      ENXIO: exports.WASI_ENXIO,\n      EOVERFLOW: exports.WASI_EOVERFLOW,\n      EOWNERDEAD: exports.WASI_EOWNERDEAD,\n      EPERM: exports.WASI_EPERM,\n      EPIPE: exports.WASI_EPIPE,\n      EPROTO: exports.WASI_EPROTO,\n      EPROTONOSUPPORT: exports.WASI_EPROTONOSUPPORT,\n      EPROTOTYPE: exports.WASI_EPROTOTYPE,\n      ERANGE: exports.WASI_ERANGE,\n      EROFS: exports.WASI_EROFS,\n      ESPIPE: exports.WASI_ESPIPE,\n      ESRCH: exports.WASI_ESRCH,\n      ESTALE: exports.WASI_ESTALE,\n      ETIMEDOUT: exports.WASI_ETIMEDOUT,\n      ETXTBSY: exports.WASI_ETXTBSY,\n      EXDEV: exports.WASI_EXDEV\n    }, exports.SIGNAL_MAP = {\n      [exports.WASI_SIGHUP]: \"SIGHUP\",\n      [exports.WASI_SIGINT]: \"SIGINT\",\n      [exports.WASI_SIGQUIT]: \"SIGQUIT\",\n      [exports.WASI_SIGILL]: \"SIGILL\",\n      [exports.WASI_SIGTRAP]: \"SIGTRAP\",\n      [exports.WASI_SIGABRT]: \"SIGABRT\",\n      [exports.WASI_SIGBUS]: \"SIGBUS\",\n      [exports.WASI_SIGFPE]: \"SIGFPE\",\n      [exports.WASI_SIGKILL]: \"SIGKILL\",\n      [exports.WASI_SIGUSR1]: \"SIGUSR1\",\n      [exports.WASI_SIGSEGV]: \"SIGSEGV\",\n      [exports.WASI_SIGUSR2]: \"SIGUSR2\",\n      [exports.WASI_SIGPIPE]: \"SIGPIPE\",\n      [exports.WASI_SIGALRM]: \"SIGALRM\",\n      [exports.WASI_SIGTERM]: \"SIGTERM\",\n      [exports.WASI_SIGCHLD]: \"SIGCHLD\",\n      [exports.WASI_SIGCONT]: \"SIGCONT\",\n      [exports.WASI_SIGSTOP]: \"SIGSTOP\",\n      [exports.WASI_SIGTSTP]: \"SIGTSTP\",\n      [exports.WASI_SIGTTIN]: \"SIGTTIN\",\n      [exports.WASI_SIGTTOU]: \"SIGTTOU\",\n      [exports.WASI_SIGURG]: \"SIGURG\",\n      [exports.WASI_SIGXCPU]: \"SIGXCPU\",\n      [exports.WASI_SIGXFSZ]: \"SIGXFSZ\",\n      [exports.WASI_SIGVTALRM]: \"SIGVTALRM\"\n    };\n  }\n}), require_wasi = __commonJS({\n  \"node_modules/wasi-js/dist/wasi.js\"(exports) {\n    var __importDefault = exports && exports.__importDefault || function(mod) {\n      return mod && mod.__esModule \? mod : { default: mod };\n    };\n    let fs;\n    Object.defineProperty(exports, \"__esModule\", { value: !0 }), exports.SOCKET_DEFAULT_RIGHTS = void 0;\n    var log = () => {\n    }, logOpen = () => {\n    }, SC_OPEN_MAX = 32768, types_1 = require_types(), constants_1 = require_constants(), STDIN_DEFAULT_RIGHTS = constants_1.WASI_RIGHT_FD_DATASYNC | constants_1.WASI_RIGHT_FD_READ | constants_1.WASI_RIGHT_FD_SYNC | constants_1.WASI_RIGHT_FD_ADVISE | constants_1.WASI_RIGHT_FD_FILESTAT_GET | constants_1.WASI_RIGHT_POLL_FD_READWRITE, STDOUT_DEFAULT_RIGHTS = constants_1.WASI_RIGHT_FD_DATASYNC | constants_1.WASI_RIGHT_FD_WRITE | constants_1.WASI_RIGHT_FD_SYNC | constants_1.WASI_RIGHT_FD_ADVISE | constants_1.WASI_RIGHT_FD_FILESTAT_GET | constants_1.WASI_RIGHT_POLL_FD_READWRITE, STDERR_DEFAULT_RIGHTS = STDOUT_DEFAULT_RIGHTS;\n    exports.SOCKET_DEFAULT_RIGHTS = constants_1.WASI_RIGHT_FD_DATASYNC | constants_1.WASI_RIGHT_FD_READ | constants_1.WASI_RIGHT_FD_WRITE | constants_1.WASI_RIGHT_FD_ADVISE | constants_1.WASI_RIGHT_FD_FILESTAT_GET | constants_1.WASI_RIGHT_POLL_FD_READWRITE | constants_1.WASI_RIGHT_FD_FDSTAT_SET_FLAGS;\n    var msToNs = (ms) => {\n      const msInt = Math.trunc(ms), decimal = BigInt(Math.round((ms - msInt) * 1e6));\n      return BigInt(msInt) * BigInt(1e6) + decimal;\n    }, nsToMs = (ns) => {\n      if (typeof ns === \"number\")\n        ns = Math.trunc(ns);\n      const nsInt = BigInt(ns);\n      return Number(nsInt / BigInt(1e6));\n    }, wrap = (f) => (...args) => {\n      try {\n        return f(...args);\n      } catch (err) {\n        let e = err;\n        while (e.prev != null)\n          e = e.prev;\n        if (e\?.code && typeof e\?.code === \"string\")\n          return constants_1.ERROR_MAP[e.code] || constants_1.WASI_EINVAL;\n        if (e instanceof types_1.WASIError)\n          return e.errno;\n        throw e;\n      }\n    }, stat = (wasi, fd) => {\n      const entry = wasi.FD_MAP.get(fd);\n      if (!entry)\n        throw new types_1.WASIError(constants_1.WASI_EBADF);\n      if (entry.filetype === void 0) {\n        const stats = wasi.fstatSync(entry.real), { filetype, rightsBase, rightsInheriting } = translateFileAttributes(wasi, fd, stats);\n        if (entry.filetype = filetype, !entry.rights)\n          entry.rights = {\n            base: rightsBase,\n            inheriting: rightsInheriting\n          };\n      }\n      return entry;\n    }, translateFileAttributes = (wasi, fd, stats) => {\n      switch (!0) {\n        case stats.isBlockDevice():\n          return {\n            filetype: constants_1.WASI_FILETYPE_BLOCK_DEVICE,\n            rightsBase: constants_1.RIGHTS_BLOCK_DEVICE_BASE,\n            rightsInheriting: constants_1.RIGHTS_BLOCK_DEVICE_INHERITING\n          };\n        case stats.isCharacterDevice(): {\n          const filetype = constants_1.WASI_FILETYPE_CHARACTER_DEVICE;\n          if (fd !== void 0 && wasi.bindings.isTTY(fd))\n            return {\n              filetype,\n              rightsBase: constants_1.RIGHTS_TTY_BASE,\n              rightsInheriting: constants_1.RIGHTS_TTY_INHERITING\n            };\n          return {\n            filetype,\n            rightsBase: constants_1.RIGHTS_CHARACTER_DEVICE_BASE,\n            rightsInheriting: constants_1.RIGHTS_CHARACTER_DEVICE_INHERITING\n          };\n        }\n        case stats.isDirectory():\n          return {\n            filetype: constants_1.WASI_FILETYPE_DIRECTORY,\n            rightsBase: constants_1.RIGHTS_DIRECTORY_BASE,\n            rightsInheriting: constants_1.RIGHTS_DIRECTORY_INHERITING\n          };\n        case stats.isFIFO():\n          return {\n            filetype: constants_1.WASI_FILETYPE_SOCKET_STREAM,\n            rightsBase: constants_1.RIGHTS_SOCKET_BASE,\n            rightsInheriting: constants_1.RIGHTS_SOCKET_INHERITING\n          };\n        case stats.isFile():\n          return {\n            filetype: constants_1.WASI_FILETYPE_REGULAR_FILE,\n            rightsBase: constants_1.RIGHTS_REGULAR_FILE_BASE,\n            rightsInheriting: constants_1.RIGHTS_REGULAR_FILE_INHERITING\n          };\n        case stats.isSocket():\n          return {\n            filetype: constants_1.WASI_FILETYPE_SOCKET_STREAM,\n            rightsBase: constants_1.RIGHTS_SOCKET_BASE,\n            rightsInheriting: constants_1.RIGHTS_SOCKET_INHERITING\n          };\n        case stats.isSymbolicLink():\n          return {\n            filetype: constants_1.WASI_FILETYPE_SYMBOLIC_LINK,\n            rightsBase: BigInt(0),\n            rightsInheriting: BigInt(0)\n          };\n        default:\n          return {\n            filetype: constants_1.WASI_FILETYPE_UNKNOWN,\n            rightsBase: BigInt(0),\n            rightsInheriting: BigInt(0)\n          };\n      }\n    }, warnedAboutSleep = !1, defaultConfig;\n    function getDefaults() {\n      if (defaultConfig)\n        return defaultConfig;\n      const defaultBindings = {\n        hrtime: () => process.hrtime.bigint(),\n        exit: (code) => {\n          process.exit(code);\n        },\n        kill: (signal) => {\n          process.kill(process.pid, signal);\n        },\n        randomFillSync: (array) => crypto.getRandomValues(array),\n        isTTY: (fd) => @requireNativeModule(\"node:tty\").isatty(fd),\n        fs: Bun.fs(),\n        path: @getInternalField(@internalModuleRegistry, 26) || @createInternalModuleById(26)\n      };\n      return defaultConfig = {\n        args: [],\n        env: {},\n        preopens: {},\n        bindings: defaultBindings,\n        sleep: (ms) => {\n          Bun.sleepSync(ms);\n        }\n      };\n    }\n    var WASI = class WASI2 {\n      constructor(wasiConfig = {}) {\n        const defaultConfig2 = getDefaults();\n        this.lastStdin = 0, this.sleep = wasiConfig.sleep || defaultConfig2.sleep, this.getStdin = wasiConfig.getStdin, this.sendStdout = wasiConfig.sendStdout, this.sendStderr = wasiConfig.sendStderr;\n        let preopens = wasiConfig.preopens \?\? defaultConfig2.preopens;\n        this.env = wasiConfig.env \?\? defaultConfig2.env;\n        const args = wasiConfig.args \?\? defaultConfig2.args;\n        this.memory = void 0, this.view = void 0, this.bindings = wasiConfig.bindings || defaultConfig2.bindings;\n        const bindings2 = this.bindings;\n        fs = bindings2.fs, this.FD_MAP = new Map([\n          [\n            constants_1.WASI_STDIN_FILENO,\n            {\n              real: 0,\n              filetype: constants_1.WASI_FILETYPE_CHARACTER_DEVICE,\n              rights: {\n                base: STDIN_DEFAULT_RIGHTS,\n                inheriting: BigInt(0)\n              },\n              path: \"/dev/stdin\"\n            }\n          ],\n          [\n            constants_1.WASI_STDOUT_FILENO,\n            {\n              real: 1,\n              filetype: constants_1.WASI_FILETYPE_CHARACTER_DEVICE,\n              rights: {\n                base: STDOUT_DEFAULT_RIGHTS,\n                inheriting: BigInt(0)\n              },\n              path: \"/dev/stdout\"\n            }\n          ],\n          [\n            constants_1.WASI_STDERR_FILENO,\n            {\n              real: 2,\n              filetype: constants_1.WASI_FILETYPE_CHARACTER_DEVICE,\n              rights: {\n                base: STDERR_DEFAULT_RIGHTS,\n                inheriting: BigInt(0)\n              },\n              path: \"/dev/stderr\"\n            }\n          ]\n        ]);\n        const path = bindings2.path;\n        for (let [k, v] of Object.entries(preopens)) {\n          const real = fs.openSync(v, nodeFsConstants.O_RDONLY), newfd = this.getUnusedFileDescriptor();\n          this.FD_MAP.set(newfd, {\n            real,\n            filetype: constants_1.WASI_FILETYPE_DIRECTORY,\n            rights: {\n              base: constants_1.RIGHTS_DIRECTORY_BASE,\n              inheriting: constants_1.RIGHTS_DIRECTORY_INHERITING\n            },\n            fakePath: k,\n            path: v\n          });\n        }\n        const getiovs = (iovs, iovsLen) => {\n          this.refreshMemory();\n          const { view, memory } = this, { buffer } = memory, { byteLength } = buffer;\n          if (iovsLen === 1) {\n            const ptr = iovs, buf = view.getUint32(ptr, !0);\n            let bufLen = view.getUint32(ptr + 4, !0);\n            if (bufLen > byteLength - buf)\n              console.log({\n                buf,\n                bufLen,\n                total_memory: byteLength\n              }), log(\"getiovs: warning -- truncating buffer to fit in memory\"), bufLen = Math.min(bufLen, Math.max(0, byteLength - buf));\n            try {\n              return [new Uint8Array(buffer, buf, bufLen)];\n            } catch (err) {\n              throw console.warn(\"WASI.getiovs -- invalid buffer\", err), new types_1.WASIError(constants_1.WASI_EINVAL);\n            }\n          }\n          const buffers = [];\n          buffers.length = iovsLen;\n          for (let i = 0, ptr = iovs;i < iovsLen; i++, ptr += 8) {\n            const buf = view.getUint32(ptr, !0);\n            let bufLen = view.getUint32(ptr + 4, !0);\n            if (bufLen > byteLength - buf)\n              console.log({\n                buf,\n                bufLen,\n                total_memory: byteLength\n              }), log(\"getiovs: warning -- truncating buffer to fit in memory\"), bufLen = Math.min(bufLen, Math.max(0, byteLength - buf));\n            try {\n              buffers[i] = new Uint8Array(buffer, buf, bufLen);\n            } catch (err) {\n              throw console.warn(\"WASI.getiovs -- invalid buffer\", err), new types_1.WASIError(constants_1.WASI_EINVAL);\n            }\n          }\n          return buffers;\n        }, CHECK_FD = (fd, rights) => {\n          const stats = stat(this, fd);\n          if (rights !== BigInt(0) && (stats.rights.base & rights) === BigInt(0))\n            throw new types_1.WASIError(constants_1.WASI_EPERM);\n          return stats;\n        }, CPUTIME_START = Bun.nanoseconds(), timeOrigin = Math.trunc(performance.timeOrigin * 1e6), now = (clockId) => {\n          switch (clockId) {\n            case constants_1.WASI_CLOCK_MONOTONIC:\n              return Bun.nanoseconds();\n            case constants_1.WASI_CLOCK_REALTIME:\n              return Bun.nanoseconds() + timeOrigin;\n            case constants_1.WASI_CLOCK_PROCESS_CPUTIME_ID:\n            case constants_1.WASI_CLOCK_THREAD_CPUTIME_ID:\n              return Bun.nanoseconds() - CPUTIME_START;\n            default:\n              return null;\n          }\n        };\n        if (this.wasiImport = {\n          args_get: (argv, argvBuf) => {\n            this.refreshMemory();\n            let coffset = argv, offset = argvBuf;\n            return args.forEach((a) => {\n              this.view.setUint32(coffset, offset, !0), coffset += 4, offset += Buffer.from(this.memory.buffer).write(`${a}\\0`, offset);\n            }), constants_1.WASI_ESUCCESS;\n          },\n          args_sizes_get: (argc, argvBufSize) => {\n            this.refreshMemory(), this.view.setUint32(argc, args.length, !0);\n            const size = args.reduce((acc, a) => acc + Buffer.byteLength(a) + 1, 0);\n            return this.view.setUint32(argvBufSize, size, !0), constants_1.WASI_ESUCCESS;\n          },\n          environ_get: (environ, environBuf) => {\n            this.refreshMemory();\n            let coffset = environ, offset = environBuf;\n            return Object.entries(this.env).forEach(([key, value]) => {\n              this.view.setUint32(coffset, offset, !0), coffset += 4, offset += Buffer.from(this.memory.buffer).write(`${key}=${value}\\0`, offset);\n            }), constants_1.WASI_ESUCCESS;\n          },\n          environ_sizes_get: (environCount, environBufSize) => {\n            this.refreshMemory();\n            const envProcessed = Object.entries(this.env).map(([key, value]) => `${key}=${value}\\0`), size = envProcessed.reduce((acc, e) => acc + Buffer.byteLength(e), 0);\n            return this.view.setUint32(environCount, envProcessed.length, !0), this.view.setUint32(environBufSize, size, !0), constants_1.WASI_ESUCCESS;\n          },\n          clock_res_get: (clockId, resolution) => {\n            let res;\n            switch (clockId) {\n              case constants_1.WASI_CLOCK_MONOTONIC:\n              case constants_1.WASI_CLOCK_PROCESS_CPUTIME_ID:\n              case constants_1.WASI_CLOCK_THREAD_CPUTIME_ID: {\n                res = BigInt(1);\n                break;\n              }\n              case constants_1.WASI_CLOCK_REALTIME: {\n                res = BigInt(1000);\n                break;\n              }\n            }\n            if (!res)\n              throw Error(\"invalid clockId\");\n            return this.view.setBigUint64(resolution, res), constants_1.WASI_ESUCCESS;\n          },\n          clock_time_get: (clockId, _precision, time) => {\n            this.refreshMemory();\n            const n = now(clockId);\n            if (n === null)\n              return constants_1.WASI_EINVAL;\n            return this.view.setBigUint64(time, BigInt(n), !0), constants_1.WASI_ESUCCESS;\n          },\n          fd_advise: wrap((fd, _offset, _len, _advice) => {\n            return CHECK_FD(fd, constants_1.WASI_RIGHT_FD_ADVISE), constants_1.WASI_ENOSYS;\n          }),\n          fd_allocate: wrap((fd, _offset, _len) => {\n            return CHECK_FD(fd, constants_1.WASI_RIGHT_FD_ALLOCATE), constants_1.WASI_ENOSYS;\n          }),\n          fd_close: wrap((fd) => {\n            const stats = CHECK_FD(fd, BigInt(0));\n            return fs.closeSync(stats.real), this.FD_MAP.delete(fd), constants_1.WASI_ESUCCESS;\n          }),\n          fd_datasync: wrap((fd) => {\n            const stats = CHECK_FD(fd, constants_1.WASI_RIGHT_FD_DATASYNC);\n            return fs.fdatasyncSync(stats.real), constants_1.WASI_ESUCCESS;\n          }),\n          fd_fdstat_get: wrap((fd, bufPtr) => {\n            const stats = CHECK_FD(fd, BigInt(0));\n            if (this.refreshMemory(), stats.filetype == null)\n              throw Error(\"stats.filetype must be set\");\n            return this.view.setUint8(bufPtr, stats.filetype), this.view.setUint16(bufPtr + 2, 0, !0), this.view.setUint16(bufPtr + 4, 0, !0), this.view.setBigUint64(bufPtr + 8, BigInt(stats.rights.base), !0), this.view.setBigUint64(bufPtr + 8 + 8, BigInt(stats.rights.inheriting), !0), constants_1.WASI_ESUCCESS;\n          }),\n          fd_fdstat_set_flags: wrap((fd, flags) => {\n            if (CHECK_FD(fd, constants_1.WASI_RIGHT_FD_FDSTAT_SET_FLAGS), this.wasiImport.sock_fcntlSetFlags(fd, flags) == 0)\n              return constants_1.WASI_ESUCCESS;\n            return constants_1.WASI_ENOSYS;\n          }),\n          fd_fdstat_set_rights: wrap((fd, fsRightsBase, fsRightsInheriting) => {\n            const stats = CHECK_FD(fd, BigInt(0));\n            if ((stats.rights.base | fsRightsBase) > stats.rights.base)\n              return constants_1.WASI_EPERM;\n            if ((stats.rights.inheriting | fsRightsInheriting) > stats.rights.inheriting)\n              return constants_1.WASI_EPERM;\n            return stats.rights.base = fsRightsBase, stats.rights.inheriting = fsRightsInheriting, constants_1.WASI_ESUCCESS;\n          }),\n          fd_filestat_get: wrap((fd, bufPtr) => {\n            const stats = CHECK_FD(fd, constants_1.WASI_RIGHT_FD_FILESTAT_GET), rstats = this.fstatSync(stats.real);\n            if (this.refreshMemory(), this.view.setBigUint64(bufPtr, BigInt(rstats.dev), !0), bufPtr += 8, this.view.setBigUint64(bufPtr, BigInt(rstats.ino), !0), bufPtr += 8, stats.filetype == null)\n              throw Error(\"stats.filetype must be set\");\n            return this.view.setUint8(bufPtr, stats.filetype), bufPtr += 8, this.view.setBigUint64(bufPtr, BigInt(rstats.nlink), !0), bufPtr += 8, this.view.setBigUint64(bufPtr, BigInt(rstats.size), !0), bufPtr += 8, this.view.setBigUint64(bufPtr, msToNs(rstats.atimeMs), !0), bufPtr += 8, this.view.setBigUint64(bufPtr, msToNs(rstats.mtimeMs), !0), bufPtr += 8, this.view.setBigUint64(bufPtr, msToNs(rstats.ctimeMs), !0), constants_1.WASI_ESUCCESS;\n          }),\n          fd_filestat_set_size: wrap((fd, stSize) => {\n            const stats = CHECK_FD(fd, constants_1.WASI_RIGHT_FD_FILESTAT_SET_SIZE);\n            return fs.ftruncateSync(stats.real, Number(stSize)), constants_1.WASI_ESUCCESS;\n          }),\n          fd_filestat_set_times: wrap((fd, stAtim, stMtim, fstflags) => {\n            const stats = CHECK_FD(fd, constants_1.WASI_RIGHT_FD_FILESTAT_SET_TIMES), rstats = this.fstatSync(stats.real);\n            let { atime: atim, mtime: mtim } = rstats;\n            const n = nsToMs(now(constants_1.WASI_CLOCK_REALTIME)), atimflags = constants_1.WASI_FILESTAT_SET_ATIM | constants_1.WASI_FILESTAT_SET_ATIM_NOW;\n            if ((fstflags & atimflags) === atimflags)\n              return constants_1.WASI_EINVAL;\n            const mtimflags = constants_1.WASI_FILESTAT_SET_MTIM | constants_1.WASI_FILESTAT_SET_MTIM_NOW;\n            if ((fstflags & mtimflags) === mtimflags)\n              return constants_1.WASI_EINVAL;\n            if ((fstflags & constants_1.WASI_FILESTAT_SET_ATIM) === constants_1.WASI_FILESTAT_SET_ATIM)\n              atim = nsToMs(stAtim);\n            else if ((fstflags & constants_1.WASI_FILESTAT_SET_ATIM_NOW) === constants_1.WASI_FILESTAT_SET_ATIM_NOW)\n              atim = n;\n            if ((fstflags & constants_1.WASI_FILESTAT_SET_MTIM) === constants_1.WASI_FILESTAT_SET_MTIM)\n              mtim = nsToMs(stMtim);\n            else if ((fstflags & constants_1.WASI_FILESTAT_SET_MTIM_NOW) === constants_1.WASI_FILESTAT_SET_MTIM_NOW)\n              mtim = n;\n            return fs.futimesSync(stats.real, new Date(atim), new Date(mtim)), constants_1.WASI_ESUCCESS;\n          }),\n          fd_prestat_get: wrap((fd, bufPtr) => {\n            const stats = CHECK_FD(fd, BigInt(0));\n            return this.refreshMemory(), this.view.setUint8(bufPtr, constants_1.WASI_PREOPENTYPE_DIR), this.view.setUint32(bufPtr + 4, Buffer.byteLength(stats.fakePath \?\? stats.path \?\? \"\"), !0), constants_1.WASI_ESUCCESS;\n          }),\n          fd_prestat_dir_name: wrap((fd, pathPtr, pathLen) => {\n            const stats = CHECK_FD(fd, BigInt(0));\n            return this.refreshMemory(), Buffer.from(this.memory.buffer).write(stats.fakePath \?\? stats.path \?\? \"\", pathPtr, pathLen, \"utf8\"), constants_1.WASI_ESUCCESS;\n          }),\n          fd_pwrite: wrap((fd, iovs, iovsLen, offset, nwritten) => {\n            const stats = CHECK_FD(fd, constants_1.WASI_RIGHT_FD_WRITE | constants_1.WASI_RIGHT_FD_SEEK);\n            let written = 0;\n            return getiovs(iovs, iovsLen).forEach((iov) => {\n              let w = 0;\n              while (w < iov.byteLength)\n                w += fs.writeSync(stats.real, iov, w, iov.byteLength - w, Number(offset) + written + w);\n              written += w;\n            }), this.view.setUint32(nwritten, written, !0), constants_1.WASI_ESUCCESS;\n          }),\n          fd_write: wrap((fd, iovs, iovsLen, nwritten) => {\n            const stats = CHECK_FD(fd, constants_1.WASI_RIGHT_FD_WRITE), IS_STDOUT = fd == constants_1.WASI_STDOUT_FILENO, IS_STDERR = fd == constants_1.WASI_STDERR_FILENO;\n            let written = 0;\n            return getiovs(iovs, iovsLen).forEach((iov) => {\n              if (iov.byteLength == 0)\n                return;\n              if (IS_STDOUT && this.sendStdout != null)\n                this.sendStdout(iov), written += iov.byteLength;\n              else if (IS_STDERR && this.sendStderr != null)\n                this.sendStderr(iov), written += iov.byteLength;\n              else {\n                let w = 0;\n                while (w < iov.byteLength) {\n                  const i = fs.writeSync(stats.real, iov, w, iov.byteLength - w, stats.offset \? Number(stats.offset) : null);\n                  if (stats.offset)\n                    stats.offset += BigInt(i);\n                  w += i;\n                }\n                written += w;\n              }\n            }), this.view.setUint32(nwritten, written, !0), constants_1.WASI_ESUCCESS;\n          }),\n          fd_pread: wrap((fd, iovs, iovsLen, offset, nread) => {\n            const stats = CHECK_FD(fd, constants_1.WASI_RIGHT_FD_READ | constants_1.WASI_RIGHT_FD_SEEK);\n            let read = 0;\n            outer:\n              for (let iov of getiovs(iovs, iovsLen)) {\n                let r = 0;\n                while (r < iov.byteLength) {\n                  const length = iov.byteLength - r, rr = fs.readSync(stats.real, iov, r, iov.byteLength - r, Number(offset) + read + r);\n                  if (r += rr, read += rr, rr === 0 || rr < length)\n                    break outer;\n                }\n                read += r;\n              }\n            return this.view.setUint32(nread, read, !0), constants_1.WASI_ESUCCESS;\n          }),\n          fd_read: wrap((fd, iovs, iovsLen, nread) => {\n            const stats = CHECK_FD(fd, constants_1.WASI_RIGHT_FD_READ), IS_STDIN = fd == constants_1.WASI_STDIN_FILENO;\n            let read = 0;\n            outer:\n              for (let iov of getiovs(iovs, iovsLen)) {\n                let r = 0;\n                while (r < iov.byteLength) {\n                  let length = iov.byteLength - r, position = IS_STDIN || stats.offset === void 0 \? null : Number(stats.offset), rr = 0;\n                  if (IS_STDIN)\n                    if (this.getStdin != null) {\n                      if (this.stdinBuffer == null)\n                        this.stdinBuffer = this.getStdin();\n                      if (this.stdinBuffer != null) {\n                        if (rr = this.stdinBuffer.copy(iov), rr == this.stdinBuffer.length)\n                          this.stdinBuffer = void 0;\n                        else\n                          this.stdinBuffer = this.stdinBuffer.slice(rr);\n                        if (rr > 0)\n                          this.lastStdin = (new Date()).valueOf();\n                      }\n                    } else {\n                      if (this.sleep == null && !warnedAboutSleep)\n                        warnedAboutSleep = !0, console.log(\"(cpu waiting for stdin: please define a way to sleep!) \");\n                      try {\n                        rr = fs.readSync(stats.real, iov, r, length, position);\n                      } catch (_err) {\n                      }\n                      if (rr == 0)\n                        this.shortPause();\n                      else\n                        this.lastStdin = (new Date()).valueOf();\n                    }\n                  else\n                    rr = fs.readSync(stats.real, iov, r, length, position);\n                  if (stats.filetype == constants_1.WASI_FILETYPE_REGULAR_FILE)\n                    stats.offset = (stats.offset \? stats.offset : BigInt(0)) + BigInt(rr);\n                  if (r += rr, read += rr, rr === 0 || rr < length)\n                    break outer;\n                }\n              }\n            return this.view.setUint32(nread, read, !0), constants_1.WASI_ESUCCESS;\n          }),\n          fd_readdir: wrap((fd, bufPtr, bufLen, cookie, bufusedPtr) => {\n            const stats = CHECK_FD(fd, constants_1.WASI_RIGHT_FD_READDIR);\n            this.refreshMemory();\n            const entries = fs.readdirSync(stats.path, { withFileTypes: !0 }), startPtr = bufPtr;\n            for (let i = Number(cookie);i < entries.length; i += 1) {\n              const entry = entries[i];\n              let nameLength = Buffer.byteLength(entry.name);\n              if (bufPtr - startPtr > bufLen)\n                break;\n              if (this.view.setBigUint64(bufPtr, BigInt(i + 1), !0), bufPtr += 8, bufPtr - startPtr > bufLen)\n                break;\n              const rstats = fs.lstatSync(path.resolve(stats.path, entry.name));\n              if (this.view.setBigUint64(bufPtr, BigInt(rstats.ino), !0), bufPtr += 8, bufPtr - startPtr > bufLen)\n                break;\n              if (this.view.setUint32(bufPtr, nameLength, !0), bufPtr += 4, bufPtr - startPtr > bufLen)\n                break;\n              let filetype;\n              switch (!0) {\n                case rstats.isBlockDevice():\n                  filetype = constants_1.WASI_FILETYPE_BLOCK_DEVICE;\n                  break;\n                case rstats.isCharacterDevice():\n                  filetype = constants_1.WASI_FILETYPE_CHARACTER_DEVICE;\n                  break;\n                case rstats.isDirectory():\n                  filetype = constants_1.WASI_FILETYPE_DIRECTORY;\n                  break;\n                case rstats.isFIFO():\n                  filetype = constants_1.WASI_FILETYPE_SOCKET_STREAM;\n                  break;\n                case rstats.isFile():\n                  filetype = constants_1.WASI_FILETYPE_REGULAR_FILE;\n                  break;\n                case rstats.isSocket():\n                  filetype = constants_1.WASI_FILETYPE_SOCKET_STREAM;\n                  break;\n                case rstats.isSymbolicLink():\n                  filetype = constants_1.WASI_FILETYPE_SYMBOLIC_LINK;\n                  break;\n                default:\n                  filetype = constants_1.WASI_FILETYPE_UNKNOWN;\n                  break;\n              }\n              if (this.view.setUint8(bufPtr, filetype), bufPtr += 1, bufPtr += 3, bufPtr + nameLength >= startPtr + bufLen)\n                break;\n              Buffer.from(this.memory.buffer).write(entry.name, bufPtr), bufPtr += nameLength;\n            }\n            const bufused = bufPtr - startPtr;\n            return this.view.setUint32(bufusedPtr, Math.min(bufused, bufLen), !0), constants_1.WASI_ESUCCESS;\n          }),\n          fd_renumber: wrap((from, to) => {\n            return CHECK_FD(from, BigInt(0)), CHECK_FD(to, BigInt(0)), fs.closeSync(this.FD_MAP.get(from).real), this.FD_MAP.set(from, this.FD_MAP.get(to)), this.FD_MAP.delete(to), constants_1.WASI_ESUCCESS;\n          }),\n          fd_seek: wrap((fd, offset, whence, newOffsetPtr) => {\n            const stats = CHECK_FD(fd, constants_1.WASI_RIGHT_FD_SEEK);\n            switch (this.refreshMemory(), whence) {\n              case constants_1.WASI_WHENCE_CUR:\n                stats.offset = (stats.offset \? stats.offset : BigInt(0)) + BigInt(offset);\n                break;\n              case constants_1.WASI_WHENCE_END:\n                const { size } = this.fstatSync(stats.real);\n                stats.offset = BigInt(size) + BigInt(offset);\n                break;\n              case constants_1.WASI_WHENCE_SET:\n                stats.offset = BigInt(offset);\n                break;\n            }\n            if (stats.offset == null)\n              throw Error(\"stats.offset must be defined\");\n            return this.view.setBigUint64(newOffsetPtr, stats.offset, !0), constants_1.WASI_ESUCCESS;\n          }),\n          fd_tell: wrap((fd, offsetPtr) => {\n            const stats = CHECK_FD(fd, constants_1.WASI_RIGHT_FD_TELL);\n            if (this.refreshMemory(), !stats.offset)\n              stats.offset = BigInt(0);\n            return this.view.setBigUint64(offsetPtr, stats.offset, !0), constants_1.WASI_ESUCCESS;\n          }),\n          fd_sync: wrap((fd) => {\n            const stats = CHECK_FD(fd, constants_1.WASI_RIGHT_FD_SYNC);\n            return fs.fsyncSync(stats.real), constants_1.WASI_ESUCCESS;\n          }),\n          path_create_directory: wrap((fd, pathPtr, pathLen) => {\n            const stats = CHECK_FD(fd, constants_1.WASI_RIGHT_PATH_CREATE_DIRECTORY);\n            if (!stats.path)\n              return constants_1.WASI_EINVAL;\n            this.refreshMemory();\n            const p = Buffer.from(this.memory.buffer, pathPtr, pathLen).toString();\n            return fs.mkdirSync(path.resolve(stats.path, p)), constants_1.WASI_ESUCCESS;\n          }),\n          path_filestat_get: wrap((fd, flags, pathPtr, pathLen, bufPtr) => {\n            const stats = CHECK_FD(fd, constants_1.WASI_RIGHT_PATH_FILESTAT_GET);\n            if (!stats.path)\n              return constants_1.WASI_EINVAL;\n            this.refreshMemory();\n            const p = Buffer.from(this.memory.buffer, pathPtr, pathLen).toString();\n            let rstats;\n            if (flags)\n              rstats = fs.statSync(path.resolve(stats.path, p));\n            else\n              rstats = fs.lstatSync(path.resolve(stats.path, p));\n            return this.view.setBigUint64(bufPtr, BigInt(rstats.dev), !0), bufPtr += 8, this.view.setBigUint64(bufPtr, BigInt(rstats.ino), !0), bufPtr += 8, this.view.setUint8(bufPtr, translateFileAttributes(this, void 0, rstats).filetype), bufPtr += 8, this.view.setBigUint64(bufPtr, BigInt(rstats.nlink), !0), bufPtr += 8, this.view.setBigUint64(bufPtr, BigInt(rstats.size), !0), bufPtr += 8, this.view.setBigUint64(bufPtr, BigInt(rstats.atime.getTime() * 1e6), !0), bufPtr += 8, this.view.setBigUint64(bufPtr, BigInt(rstats.mtime.getTime() * 1e6), !0), bufPtr += 8, this.view.setBigUint64(bufPtr, BigInt(rstats.ctime.getTime() * 1e6), !0), constants_1.WASI_ESUCCESS;\n          }),\n          path_filestat_set_times: wrap((fd, _dirflags, pathPtr, pathLen, stAtim, stMtim, fstflags) => {\n            const stats = CHECK_FD(fd, constants_1.WASI_RIGHT_PATH_FILESTAT_SET_TIMES);\n            if (!stats.path)\n              return constants_1.WASI_EINVAL;\n            this.refreshMemory();\n            const rstats = this.fstatSync(stats.real);\n            let { atime: atim, mtime: mtim } = rstats;\n            const n = nsToMs(now(constants_1.WASI_CLOCK_REALTIME)), atimflags = constants_1.WASI_FILESTAT_SET_ATIM | constants_1.WASI_FILESTAT_SET_ATIM_NOW;\n            if ((fstflags & atimflags) === atimflags)\n              return constants_1.WASI_EINVAL;\n            const mtimflags = constants_1.WASI_FILESTAT_SET_MTIM | constants_1.WASI_FILESTAT_SET_MTIM_NOW;\n            if ((fstflags & mtimflags) === mtimflags)\n              return constants_1.WASI_EINVAL;\n            if ((fstflags & constants_1.WASI_FILESTAT_SET_ATIM) === constants_1.WASI_FILESTAT_SET_ATIM)\n              atim = nsToMs(stAtim);\n            else if ((fstflags & constants_1.WASI_FILESTAT_SET_ATIM_NOW) === constants_1.WASI_FILESTAT_SET_ATIM_NOW)\n              atim = n;\n            if ((fstflags & constants_1.WASI_FILESTAT_SET_MTIM) === constants_1.WASI_FILESTAT_SET_MTIM)\n              mtim = nsToMs(stMtim);\n            else if ((fstflags & constants_1.WASI_FILESTAT_SET_MTIM_NOW) === constants_1.WASI_FILESTAT_SET_MTIM_NOW)\n              mtim = n;\n            const p = Buffer.from(this.memory.buffer, pathPtr, pathLen).toString();\n            return fs.utimesSync(path.resolve(stats.path, p), new Date(atim), new Date(mtim)), constants_1.WASI_ESUCCESS;\n          }),\n          path_link: wrap((oldFd, _oldFlags, oldPath, oldPathLen, newFd, newPath, newPathLen) => {\n            const ostats = CHECK_FD(oldFd, constants_1.WASI_RIGHT_PATH_LINK_SOURCE), nstats = CHECK_FD(newFd, constants_1.WASI_RIGHT_PATH_LINK_TARGET);\n            if (!ostats.path || !nstats.path)\n              return constants_1.WASI_EINVAL;\n            this.refreshMemory();\n            const op = Buffer.from(this.memory.buffer, oldPath, oldPathLen).toString(), np = Buffer.from(this.memory.buffer, newPath, newPathLen).toString();\n            return fs.linkSync(path.resolve(ostats.path, op), path.resolve(nstats.path, np)), constants_1.WASI_ESUCCESS;\n          }),\n          path_open: wrap((dirfd, _dirflags, pathPtr, pathLen, oflags, fsRightsBase, fsRightsInheriting, fsFlags, fdPtr) => {\n            try {\n              const stats = CHECK_FD(dirfd, constants_1.WASI_RIGHT_PATH_OPEN);\n              fsRightsBase = BigInt(fsRightsBase), fsRightsInheriting = BigInt(fsRightsInheriting);\n              const read = (fsRightsBase & (constants_1.WASI_RIGHT_FD_READ | constants_1.WASI_RIGHT_FD_READDIR)) !== BigInt(0), write = (fsRightsBase & (constants_1.WASI_RIGHT_FD_DATASYNC | constants_1.WASI_RIGHT_FD_WRITE | constants_1.WASI_RIGHT_FD_ALLOCATE | constants_1.WASI_RIGHT_FD_FILESTAT_SET_SIZE)) !== BigInt(0);\n              let noflags;\n              if (write && read)\n                noflags = nodeFsConstants.O_RDWR;\n              else if (read)\n                noflags = nodeFsConstants.O_RDONLY;\n              else if (write)\n                noflags = nodeFsConstants.O_WRONLY;\n              let neededBase = fsRightsBase | constants_1.WASI_RIGHT_PATH_OPEN, neededInheriting = fsRightsBase | fsRightsInheriting;\n              if ((oflags & constants_1.WASI_O_CREAT) !== 0)\n                noflags |= nodeFsConstants.O_CREAT, neededBase |= constants_1.WASI_RIGHT_PATH_CREATE_FILE;\n              if ((oflags & constants_1.WASI_O_DIRECTORY) !== 0)\n                noflags |= nodeFsConstants.O_DIRECTORY;\n              if ((oflags & constants_1.WASI_O_EXCL) !== 0)\n                noflags |= nodeFsConstants.O_EXCL;\n              if ((oflags & constants_1.WASI_O_TRUNC) !== 0)\n                noflags |= nodeFsConstants.O_TRUNC, neededBase |= constants_1.WASI_RIGHT_PATH_FILESTAT_SET_SIZE;\n              if ((fsFlags & constants_1.WASI_FDFLAG_APPEND) !== 0)\n                noflags |= nodeFsConstants.O_APPEND;\n              if ((fsFlags & constants_1.WASI_FDFLAG_DSYNC) !== 0) {\n                if (nodeFsConstants.O_DSYNC)\n                  noflags |= nodeFsConstants.O_DSYNC;\n                else\n                  noflags |= nodeFsConstants.O_SYNC;\n                neededInheriting |= constants_1.WASI_RIGHT_FD_DATASYNC;\n              }\n              if ((fsFlags & constants_1.WASI_FDFLAG_NONBLOCK) !== 0)\n                noflags |= nodeFsConstants.O_NONBLOCK;\n              if ((fsFlags & constants_1.WASI_FDFLAG_RSYNC) !== 0) {\n                if (nodeFsConstants.O_RSYNC)\n                  noflags |= nodeFsConstants.O_RSYNC;\n                else\n                  noflags |= nodeFsConstants.O_SYNC;\n                neededInheriting |= constants_1.WASI_RIGHT_FD_SYNC;\n              }\n              if ((fsFlags & constants_1.WASI_FDFLAG_SYNC) !== 0)\n                noflags |= nodeFsConstants.O_SYNC, neededInheriting |= constants_1.WASI_RIGHT_FD_SYNC;\n              if (write && (noflags & (nodeFsConstants.O_APPEND | nodeFsConstants.O_TRUNC)) === 0)\n                neededInheriting |= constants_1.WASI_RIGHT_FD_SEEK;\n              this.refreshMemory();\n              const p = Buffer.from(this.memory.buffer, pathPtr, pathLen).toString();\n              if (p == \"dev/tty\")\n                return this.view.setUint32(fdPtr, constants_1.WASI_STDIN_FILENO, !0), constants_1.WASI_ESUCCESS;\n              if (logOpen(\"path_open\", p), p.startsWith(\"proc/\"))\n                throw new types_1.WASIError(constants_1.WASI_EBADF);\n              const fullUnresolved = path.resolve(p);\n              let full;\n              try {\n                full = fs.realpathSync(fullUnresolved);\n              } catch (e) {\n                if (e\?.code === \"ENOENT\")\n                  full = fullUnresolved;\n                else\n                  throw e;\n              }\n              let isDirectory;\n              if (write)\n                try {\n                  isDirectory = fs.statSync(full).isDirectory();\n                } catch (_err) {\n                }\n              let realfd;\n              if (!write && isDirectory)\n                realfd = fs.openSync(full, nodeFsConstants.O_RDONLY);\n              else\n                realfd = fs.openSync(full, noflags);\n              const newfd = this.getUnusedFileDescriptor();\n              this.FD_MAP.set(newfd, {\n                real: realfd,\n                filetype: void 0,\n                rights: {\n                  base: neededBase,\n                  inheriting: neededInheriting\n                },\n                path: full\n              }), stat(this, newfd), this.view.setUint32(fdPtr, newfd, !0);\n            } catch (e) {\n              console.error(e);\n            }\n            return constants_1.WASI_ESUCCESS;\n          }),\n          path_readlink: wrap((fd, pathPtr, pathLen, buf, bufLen, bufused) => {\n            const stats = CHECK_FD(fd, constants_1.WASI_RIGHT_PATH_READLINK);\n            if (!stats.path)\n              return constants_1.WASI_EINVAL;\n            this.refreshMemory();\n            const p = Buffer.from(this.memory.buffer, pathPtr, pathLen).toString(), full = path.resolve(stats.path, p), r = fs.readlinkSync(full), used = Buffer.from(this.memory.buffer).write(r, buf, bufLen);\n            return this.view.setUint32(bufused, used, !0), constants_1.WASI_ESUCCESS;\n          }),\n          path_remove_directory: wrap((fd, pathPtr, pathLen) => {\n            const stats = CHECK_FD(fd, constants_1.WASI_RIGHT_PATH_REMOVE_DIRECTORY);\n            if (!stats.path)\n              return constants_1.WASI_EINVAL;\n            this.refreshMemory();\n            const p = Buffer.from(this.memory.buffer, pathPtr, pathLen).toString();\n            return fs.rmdirSync(path.resolve(stats.path, p)), constants_1.WASI_ESUCCESS;\n          }),\n          path_rename: wrap((oldFd, oldPath, oldPathLen, newFd, newPath, newPathLen) => {\n            const ostats = CHECK_FD(oldFd, constants_1.WASI_RIGHT_PATH_RENAME_SOURCE), nstats = CHECK_FD(newFd, constants_1.WASI_RIGHT_PATH_RENAME_TARGET);\n            if (!ostats.path || !nstats.path)\n              return constants_1.WASI_EINVAL;\n            this.refreshMemory();\n            const op = Buffer.from(this.memory.buffer, oldPath, oldPathLen).toString(), np = Buffer.from(this.memory.buffer, newPath, newPathLen).toString();\n            return fs.renameSync(path.resolve(ostats.path, op), path.resolve(nstats.path, np)), constants_1.WASI_ESUCCESS;\n          }),\n          path_symlink: wrap((oldPath, oldPathLen, fd, newPath, newPathLen) => {\n            const stats = CHECK_FD(fd, constants_1.WASI_RIGHT_PATH_SYMLINK);\n            if (!stats.path)\n              return constants_1.WASI_EINVAL;\n            this.refreshMemory();\n            const op = Buffer.from(this.memory.buffer, oldPath, oldPathLen).toString(), np = Buffer.from(this.memory.buffer, newPath, newPathLen).toString();\n            return fs.symlinkSync(op, path.resolve(stats.path, np)), constants_1.WASI_ESUCCESS;\n          }),\n          path_unlink_file: wrap((fd, pathPtr, pathLen) => {\n            const stats = CHECK_FD(fd, constants_1.WASI_RIGHT_PATH_UNLINK_FILE);\n            if (!stats.path)\n              return constants_1.WASI_EINVAL;\n            this.refreshMemory();\n            const p = Buffer.from(this.memory.buffer, pathPtr, pathLen).toString();\n            return fs.unlinkSync(path.resolve(stats.path, p)), constants_1.WASI_ESUCCESS;\n          }),\n          poll_oneoff: (sin, sout, nsubscriptions, neventsPtr) => {\n            let nevents = 0, name = \"\", waitTimeNs = BigInt(0), fd = -1, fd_type = \"read\", fd_timeout_ms = 0;\n            const startNs = BigInt(bindings2.hrtime());\n            this.refreshMemory();\n            let last_sin = sin;\n            for (let i = 0;i < nsubscriptions; i += 1) {\n              const userdata = this.view.getBigUint64(sin, !0);\n              sin += 8;\n              const type = this.view.getUint8(sin);\n              if (sin += 1, sin += 7, log.enabled) {\n                if (type == constants_1.WASI_EVENTTYPE_CLOCK)\n                  name = \"poll_oneoff (type=WASI_EVENTTYPE_CLOCK): \";\n                else if (type == constants_1.WASI_EVENTTYPE_FD_READ)\n                  name = \"poll_oneoff (type=WASI_EVENTTYPE_FD_READ): \";\n                else\n                  name = \"poll_oneoff (type=WASI_EVENTTYPE_FD_WRITE): \";\n                log(name);\n              }\n              switch (type) {\n                case constants_1.WASI_EVENTTYPE_CLOCK: {\n                  const clockid = this.view.getUint32(sin, !0);\n                  sin += 4, sin += 4;\n                  const timeout = this.view.getBigUint64(sin, !0);\n                  sin += 8, sin += 8;\n                  const subclockflags = this.view.getUint16(sin, !0);\n                  sin += 2, sin += 6;\n                  const absolute = subclockflags === 1;\n                  if (log.enabled)\n                    log(name, { clockid, timeout, absolute });\n                  if (!absolute)\n                    fd_timeout_ms = timeout / BigInt(1e6);\n                  let e = constants_1.WASI_ESUCCESS;\n                  const t = now(clockid);\n                  if (t == null)\n                    e = constants_1.WASI_EINVAL;\n                  else {\n                    const tNS = BigInt(t), waitNs = (absolute \? timeout : tNS + timeout) - tNS;\n                    if (waitNs > waitTimeNs)\n                      waitTimeNs = waitNs;\n                  }\n                  this.view.setBigUint64(sout, userdata, !0), sout += 8, this.view.setUint16(sout, e, !0), sout += 2, this.view.setUint8(sout, constants_1.WASI_EVENTTYPE_CLOCK), sout += 1, sout += 5, nevents += 1;\n                  break;\n                }\n                case constants_1.WASI_EVENTTYPE_FD_READ:\n                case constants_1.WASI_EVENTTYPE_FD_WRITE: {\n                  if (fd = this.view.getUint32(sin, !0), fd_type = type == constants_1.WASI_EVENTTYPE_FD_READ \? \"read\" : \"write\", sin += 4, log(name, \"fd =\", fd), sin += 28, this.view.setBigUint64(sout, userdata, !0), sout += 8, this.view.setUint16(sout, constants_1.WASI_ENOSYS, !0), sout += 2, this.view.setUint8(sout, type), sout += 1, sout += 5, nevents += 1, fd == constants_1.WASI_STDIN_FILENO && constants_1.WASI_EVENTTYPE_FD_READ == type)\n                    this.shortPause();\n                  break;\n                }\n                default:\n                  return constants_1.WASI_EINVAL;\n              }\n              if (sin - last_sin != 48)\n                console.warn(\"*** BUG in wasi-js in poll_oneoff \", {\n                  i,\n                  sin,\n                  last_sin,\n                  diff: sin - last_sin\n                });\n              last_sin = sin;\n            }\n            if (this.view.setUint32(neventsPtr, nevents, !0), nevents == 2 && fd >= 0) {\n              const r = this.wasiImport.sock_pollSocket(fd, fd_type, fd_timeout_ms);\n              if (r != constants_1.WASI_ENOSYS)\n                return r;\n            }\n            if (waitTimeNs > 0) {\n              if (waitTimeNs -= Bun.nanoseconds() - timeOrigin, waitTimeNs >= 1e6) {\n                if (this.sleep == null && !warnedAboutSleep)\n                  warnedAboutSleep = !0, console.log(\"(100% cpu burning waiting for stdin: please define a way to sleep!) \");\n                if (this.sleep != null) {\n                  const ms = nsToMs(waitTimeNs);\n                  this.sleep(ms);\n                } else {\n                  const end = BigInt(bindings2.hrtime()) + waitTimeNs;\n                  while (BigInt(bindings2.hrtime()) < end)\n                    ;\n                }\n              }\n            }\n            return constants_1.WASI_ESUCCESS;\n          },\n          proc_exit: (rval) => {\n            return bindings2.exit(rval), constants_1.WASI_ESUCCESS;\n          },\n          proc_raise: (sig) => {\n            if (!(sig in constants_1.SIGNAL_MAP))\n              return constants_1.WASI_EINVAL;\n            return bindings2.kill(constants_1.SIGNAL_MAP[sig]), constants_1.WASI_ESUCCESS;\n          },\n          random_get: (bufPtr, bufLen) => {\n            return this.refreshMemory(), crypto.getRandomValues(this.memory.buffer, bufPtr, bufLen), bufLen;\n          },\n          sched_yield() {\n            return constants_1.WASI_ESUCCESS;\n          },\n          sock_recv() {\n            return constants_1.WASI_ENOSYS;\n          },\n          sock_send() {\n            return constants_1.WASI_ENOSYS;\n          },\n          sock_shutdown() {\n            return constants_1.WASI_ENOSYS;\n          },\n          sock_fcntlSetFlags(_fd, _flags) {\n            return constants_1.WASI_ENOSYS;\n          },\n          sock_pollSocket(_fd, _eventtype, _timeout_ms) {\n            return constants_1.WASI_ENOSYS;\n          }\n        }, log.enabled)\n          Object.keys(this.wasiImport).forEach((key) => {\n            const prevImport = this.wasiImport[key];\n            this.wasiImport[key] = function(...args2) {\n              log(key, args2);\n              try {\n                let result = prevImport(...args2);\n                return log(\"result\", result), result;\n              } catch (e) {\n                throw log(\"error: \", e), e;\n              }\n            };\n          });\n      }\n      getState() {\n        return { env: this.env, FD_MAP: this.FD_MAP, bindings };\n      }\n      setState(state) {\n        this.env = state.env, this.FD_MAP = state.FD_MAP, bindings = state.bindings;\n      }\n      fstatSync(real_fd) {\n        if (real_fd <= 2)\n          try {\n            return fs.fstatSync(real_fd);\n          } catch (_) {\n            const now = new Date;\n            return {\n              dev: 0,\n              mode: 8592,\n              nlink: 1,\n              uid: 0,\n              gid: 0,\n              rdev: 0,\n              blksize: 65536,\n              ino: 0,\n              size: 0,\n              blocks: 0,\n              atimeMs: now.valueOf(),\n              mtimeMs: now.valueOf(),\n              ctimeMs: now.valueOf(),\n              birthtimeMs: 0,\n              atime: new Date,\n              mtime: new Date,\n              ctime: new Date,\n              birthtime: new Date(0)\n            };\n          }\n        return fs.fstatSync(real_fd);\n      }\n      shortPause() {\n        if (this.sleep == null)\n          return;\n        if ((new Date()).valueOf() - this.lastStdin > 2000)\n          this.sleep(50);\n      }\n      getUnusedFileDescriptor(start = 3) {\n        let fd = start;\n        while (this.FD_MAP.has(fd))\n          fd += 1;\n        if (fd > SC_OPEN_MAX)\n          throw Error(\"no available file descriptors\");\n        return fd;\n      }\n      refreshMemory() {\n        if (!this.view || this.view.buffer.byteLength === 0)\n          this.view = new DataView(this.memory.buffer);\n      }\n      setMemory(memory) {\n        this.memory = memory;\n      }\n      start(instance, memory) {\n        const exports2 = instance.exports;\n        if (exports2 === null || typeof exports2 !== \"object\")\n          throw new Error(`instance.exports must be an Object. Received ${exports2}.`);\n        if (memory == null) {\n          if (memory = exports2.memory, !(memory instanceof WebAssembly.Memory))\n            throw new Error(`instance.exports.memory must be a WebAssembly.Memory. Recceived ${memory}.`);\n        }\n        if (this.setMemory(memory), exports2._start)\n          exports2._start();\n      }\n      getImports(module2) {\n        let namespace = null;\n        const imports = WebAssembly.Module.imports(module2);\n        for (let imp of imports) {\n          if (imp.kind !== \"function\")\n            continue;\n          if (!imp.module.startsWith(\"wasi_\"))\n            continue;\n          namespace = imp.module;\n          break;\n        }\n        switch (namespace) {\n          case \"wasi_unstable\":\n            return {\n              wasi_unstable: this.wasiImport\n            };\n          case \"wasi_snapshot_preview1\":\n            return {\n              wasi_snapshot_preview1: this.wasiImport\n            };\n          default:\n            throw new Error(\"No WASI namespace found. Only wasi_unstable and wasi_snapshot_preview1 are supported.\\n\\nList of imports:\\n\\n\" + imports.map(({ name, kind, module }) => `${module}:${name} (${kind})`).join(\"\\n\") + \"\\n\");\n        }\n      }\n      initWasiFdInfo() {\n        if (this.env.WASI_FD_INFO != null) {\n          const fdInfo = JSON.parse(this.env.WASI_FD_INFO);\n          for (let wasi_fd in fdInfo) {\n            console.log(wasi_fd);\n            const fd = parseInt(wasi_fd);\n            if (this.FD_MAP.has(fd))\n              continue;\n            const real = fdInfo[wasi_fd];\n            try {\n              this.fstatSync(real);\n            } catch (_err) {\n              console.log(\"discarding \", { wasi_fd, real });\n              continue;\n            }\n            const file = {\n              real,\n              filetype: constants_1.WASI_FILETYPE_SOCKET_STREAM,\n              rights: {\n                base: STDIN_DEFAULT_RIGHTS,\n                inheriting: BigInt(0)\n              }\n            };\n            this.FD_MAP.set(fd, file);\n          }\n          console.log(\"after initWasiFdInfo: \", this.FD_MAP), console.log(\"fdInfo = \", fdInfo);\n        } else\n          console.log(\"no WASI_FD_INFO\");\n      }\n    };\n    exports.default = WASI;\n  }\n});\nreturn { WASI: require_wasi().default }})\n"_s;
//

//
static constexpr ASCIILiteral NodeWorkerThreadsCode = "(function (){\"use strict\";// src/js/out/tmp/node/worker_threads.ts\nvar emitWarning = function(type, message) {\n  if (emittedWarnings.has(type))\n    return;\n  emittedWarnings.add(type), console.warn(\"[bun] Warning:\", message);\n}, injectFakeEmitter = function(Class) {\n  function messageEventHandler(event) {\n    return event.data;\n  }\n  function errorEventHandler(event) {\n    return event.error;\n  }\n  const wrappedListener = Symbol(\"wrappedListener\");\n  function wrapped(run, listener) {\n    const callback = function(event) {\n      return listener(run(event));\n    };\n    return listener[wrappedListener] = callback, callback;\n  }\n  function functionForEventType(event, listener) {\n    switch (event) {\n      case \"error\":\n      case \"messageerror\":\n        return wrapped(errorEventHandler, listener);\n      default:\n        return wrapped(messageEventHandler, listener);\n    }\n  }\n  Class.prototype.on = function(event, listener) {\n    return this.addEventListener(event, functionForEventType(event, listener)), this;\n  }, Class.prototype.off = function(event, listener) {\n    if (listener)\n      this.removeEventListener(event, listener[wrappedListener] || listener);\n    else\n      this.removeEventListener(event);\n    return this;\n  }, Class.prototype.once = function(event, listener) {\n    return this.addEventListener(event, functionForEventType(event, listener), { once: !0 }), this;\n  };\n  function EventClass(eventName) {\n    if (eventName === \"error\" || eventName === \"messageerror\")\n      return ErrorEvent;\n    return MessageEvent;\n  }\n  Class.prototype.emit = function(event, ...args) {\n    return this.dispatchEvent(new (EventClass(event))(event, ...args)), this;\n  }, Class.prototype.prependListener = Class.prototype.on, Class.prototype.prependOnceListener = Class.prototype.once;\n}, receiveMessageOnPort = function(port) {\n  let res = _receiveMessageOnPort(port);\n  if (!res)\n    return;\n  return {\n    message: res\n  };\n}, fakeParentPort = function() {\n  const fake = Object.create(MessagePort.prototype);\n  return Object.defineProperty(fake, \"onmessage\", {\n    get() {\n      return self.onmessage;\n    },\n    set(value) {\n      self.onmessage = value;\n    }\n  }), Object.defineProperty(fake, \"onmessageerror\", {\n    get() {\n      return self.onmessageerror;\n    },\n    set(value) {\n    }\n  }), Object.defineProperty(fake, \"postMessage\", {\n    value(...args) {\n      return self.postMessage(...args);\n    }\n  }), Object.defineProperty(fake, \"close\", {\n    value() {\n      return process.exit(0);\n    }\n  }), Object.defineProperty(fake, \"start\", {\n    value() {\n    }\n  }), Object.defineProperty(fake, \"unref\", {\n    value() {\n    }\n  }), Object.defineProperty(fake, \"ref\", {\n    value() {\n    }\n  }), Object.defineProperty(fake, \"hasRef\", {\n    value() {\n      return !1;\n    }\n  }), Object.defineProperty(fake, \"setEncoding\", {\n    value() {\n    }\n  }), Object.defineProperty(fake, \"addEventListener\", {\n    value: self.addEventListener.bind(self)\n  }), Object.defineProperty(fake, \"removeEventListener\", {\n    value: self.removeEventListener.bind(self)\n  }), fake;\n}, getEnvironmentData = function() {\n  return process.env;\n}, setEnvironmentData = function(env) {\n  process.env = env;\n}, markAsUntransferable = function() {\n  throwNotImplemented(\"worker_threads.markAsUntransferable\");\n}, moveMessagePortToContext = function() {\n  throwNotImplemented(\"worker_threads.moveMessagePortToContext\");\n}, $, EventEmitter = @getInternalField(@internalModuleRegistry, 16) || @createInternalModuleById(16), { throwNotImplemented } = @getInternalField(@internalModuleRegistry, 3) || @createInternalModuleById(3), { MessageChannel, BroadcastChannel, Worker: WebWorker } = globalThis, SHARE_ENV = Symbol(\"nodejs.worker_threads.SHARE_ENV\"), isMainThread = Bun.isMainThread, [_workerData, _threadId, _receiveMessageOnPort] = globalThis[globalThis.Symbol.for('Bun.lazy')](\"worker_threads\"), emittedWarnings = new Set, _MessagePort = globalThis.MessagePort;\ninjectFakeEmitter(_MessagePort);\nvar MessagePort = _MessagePort, resourceLimits = {}, workerData = _workerData, threadId = _threadId, parentPort = isMainThread \? null : fakeParentPort(), unsupportedOptions = [\n  \"eval\",\n  \"argv\",\n  \"execArgv\",\n  \"stdin\",\n  \"stdout\",\n  \"stderr\",\n  \"trackedUnmanagedFds\",\n  \"resourceLimits\"\n];\n\nclass Worker extends EventEmitter {\n  #worker;\n  #performance;\n  #onExitPromise = void 0;\n  constructor(filename, options = {}) {\n    super();\n    for (let key of unsupportedOptions)\n      if (key in options)\n        emitWarning(\"option.\" + key, `worker_threads.Worker option \"${key}\" is not implemented.`);\n    this.#worker = new WebWorker(filename, options), this.#worker.addEventListener(\"close\", this.#onClose.bind(this)), this.#worker.addEventListener(\"error\", this.#onError.bind(this)), this.#worker.addEventListener(\"message\", this.#onMessage.bind(this)), this.#worker.addEventListener(\"messageerror\", this.#onMessageError.bind(this)), this.#worker.addEventListener(\"open\", this.#onOpen.bind(this));\n  }\n  ref() {\n    this.#worker.ref();\n  }\n  unref() {\n    this.#worker.unref();\n  }\n  get stdin() {\n    return null;\n  }\n  get stdout() {\n    return null;\n  }\n  get stderr() {\n    return null;\n  }\n  get performance() {\n    return this.#performance \?\?= {\n      eventLoopUtilization() {\n        return emitWarning(\"performance\", \"worker_threads.Worker.performance is not implemented.\"), {\n          idle: 0,\n          active: 0,\n          utilization: 0\n        };\n      }\n    };\n  }\n  terminate() {\n    var onExitPromise = this.#onExitPromise;\n    if (onExitPromise)\n      return @isPromise(onExitPromise) \? onExitPromise : Promise.resolve(onExitPromise);\n    const { resolve, promise } = Promise.withResolvers();\n    return this.#worker.addEventListener(\"close\", (event) => {\n      resolve(event.code);\n    }, { once: !0 }), this.#worker.terminate(), this.#onExitPromise = promise;\n  }\n  postMessage(...args) {\n    return this.#worker.postMessage(...args);\n  }\n  #onClose(e) {\n    this.#onExitPromise = e.code, this.emit(\"exit\", e.code);\n  }\n  #onError(error) {\n    this.emit(\"error\", error);\n  }\n  #onMessage(event) {\n    this.emit(\"message\", event.data);\n  }\n  #onMessageError(event) {\n    this.emit(\"messageerror\", event.error \?\? event.data \?\? event);\n  }\n  #onOpen() {\n    this.emit(\"online\");\n  }\n  async getHeapSnapshot() {\n    throwNotImplemented(\"worker_threads.Worker.getHeapSnapshot\");\n  }\n}\n$ = {\n  Worker,\n  workerData,\n  parentPort,\n  resourceLimits,\n  isMainThread,\n  MessageChannel,\n  BroadcastChannel,\n  MessagePort,\n  getEnvironmentData,\n  setEnvironmentData,\n  getHeapSnapshot() {\n    return {};\n  },\n  markAsUntransferable,\n  moveMessagePortToContext,\n  receiveMessageOnPort,\n  SHARE_ENV,\n  threadId\n};\nreturn $})\n"_s;
//

//
static constexpr ASCIILiteral NodeZlibCode = "(function (){\"use strict\";// src/js/out/tmp/node/zlib.ts\nvar assert = @getInternalField(@internalModuleRegistry, 4) || @createInternalModuleById(4), BufferModule = @requireNativeModule(\"node:buffer\"), StreamModule = @getInternalField(@internalModuleRegistry, 35) || @createInternalModuleById(35), Util = @getInternalField(@internalModuleRegistry, 43) || @createInternalModuleById(43), __getOwnPropNames = Object.getOwnPropertyNames, __commonJS = (cb, mod) => function __require() {\n  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;\n}, require_zstream = __commonJS({\n  \"node_modules/pako/lib/zlib/zstream.js\"(exports, module2) {\n    function ZStream() {\n      this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = \"\", this.state = null, this.data_type = 2, this.adler = 0;\n    }\n    module2.exports = ZStream;\n  }\n}), require_common = __commonJS({\n  \"node_modules/pako/lib/utils/common.js\"(exports) {\n    var TYPED_OK = typeof Uint8Array !== \"undefined\" && typeof Uint16Array !== \"undefined\" && typeof Int32Array !== \"undefined\";\n    function _has(obj, key) {\n      return Object.prototype.hasOwnProperty.call(obj, key);\n    }\n    exports.assign = function(obj) {\n      var sources = Array.prototype.slice.call(arguments, 1);\n      while (sources.length) {\n        var source = sources.shift();\n        if (!source)\n          continue;\n        if (typeof source !== \"object\")\n          @throwTypeError(source + \"must be non-object\");\n        for (var p in source)\n          if (_has(source, p))\n            obj[p] = source[p];\n      }\n      return obj;\n    }, exports.shrinkBuf = function(buf, size) {\n      if (buf.length === size)\n        return buf;\n      if (buf.subarray)\n        return buf.subarray(0, size);\n      return buf.length = size, buf;\n    };\n    var fnTyped = {\n      arraySet: function(dest, src, src_offs, len, dest_offs) {\n        if (src.subarray && dest.subarray) {\n          dest.set(src.subarray(src_offs, src_offs + len), dest_offs);\n          return;\n        }\n        for (var i = 0;i < len; i++)\n          dest[dest_offs + i] = src[src_offs + i];\n      },\n      flattenChunks: function(chunks) {\n        var i, l, len, pos, chunk, result;\n        len = 0;\n        for (i = 0, l = chunks.length;i < l; i++)\n          len += chunks[i].length;\n        result = new Uint8Array(len), pos = 0;\n        for (i = 0, l = chunks.length;i < l; i++)\n          chunk = chunks[i], result.set(chunk, pos), pos += chunk.length;\n        return result;\n      }\n    }, fnUntyped = {\n      arraySet: function(dest, src, src_offs, len, dest_offs) {\n        for (var i = 0;i < len; i++)\n          dest[dest_offs + i] = src[src_offs + i];\n      },\n      flattenChunks: function(chunks) {\n        return [].concat.apply([], chunks);\n      }\n    };\n    exports.setTyped = function(on) {\n      if (on)\n        exports.Buf8 = Uint8Array, exports.Buf16 = Uint16Array, exports.Buf32 = Int32Array, exports.assign(exports, fnTyped);\n      else\n        exports.Buf8 = Array, exports.Buf16 = Array, exports.Buf32 = Array, exports.assign(exports, fnUntyped);\n    }, exports.setTyped(TYPED_OK);\n  }\n}), require_trees = __commonJS({\n  \"node_modules/pako/lib/zlib/trees.js\"(exports) {\n    var utils = require_common(), Z_FIXED = 4, Z_BINARY = 0, Z_TEXT = 1, Z_UNKNOWN = 2;\n    function zero(buf) {\n      var len = buf.length;\n      while (--len >= 0)\n        buf[len] = 0;\n    }\n    var STORED_BLOCK = 0, STATIC_TREES = 1, DYN_TREES = 2, MIN_MATCH = 3, MAX_MATCH = 258, LENGTH_CODES = 29, LITERALS = 256, L_CODES = LITERALS + 1 + LENGTH_CODES, D_CODES = 30, BL_CODES = 19, HEAP_SIZE = 2 * L_CODES + 1, MAX_BITS = 15, Buf_size = 16, MAX_BL_BITS = 7, END_BLOCK = 256, REP_3_6 = 16, REPZ_3_10 = 17, REPZ_11_138 = 18, extra_lbits = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0], extra_dbits = [\n      0,\n      0,\n      0,\n      0,\n      1,\n      1,\n      2,\n      2,\n      3,\n      3,\n      4,\n      4,\n      5,\n      5,\n      6,\n      6,\n      7,\n      7,\n      8,\n      8,\n      9,\n      9,\n      10,\n      10,\n      11,\n      11,\n      12,\n      12,\n      13,\n      13\n    ], extra_blbits = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7], bl_order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], DIST_CODE_LEN = 512, static_ltree = new Array((L_CODES + 2) * 2);\n    zero(static_ltree);\n    var static_dtree = new Array(D_CODES * 2);\n    zero(static_dtree);\n    var _dist_code = new Array(DIST_CODE_LEN);\n    zero(_dist_code);\n    var _length_code = new Array(MAX_MATCH - MIN_MATCH + 1);\n    zero(_length_code);\n    var base_length = new Array(LENGTH_CODES);\n    zero(base_length);\n    var base_dist = new Array(D_CODES);\n    zero(base_dist);\n    function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {\n      this.static_tree = static_tree, this.extra_bits = extra_bits, this.extra_base = extra_base, this.elems = elems, this.max_length = max_length, this.has_stree = static_tree && static_tree.length;\n    }\n    var static_l_desc, static_d_desc, static_bl_desc;\n    function TreeDesc(dyn_tree, stat_desc) {\n      this.dyn_tree = dyn_tree, this.max_code = 0, this.stat_desc = stat_desc;\n    }\n    function d_code(dist) {\n      return dist < 256 \? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];\n    }\n    function put_short(s, w) {\n      s.pending_buf[s.pending++] = w & 255, s.pending_buf[s.pending++] = w >>> 8 & 255;\n    }\n    function send_bits(s, value, length) {\n      if (s.bi_valid > Buf_size - length)\n        s.bi_buf |= value << s.bi_valid & 65535, put_short(s, s.bi_buf), s.bi_buf = value >> Buf_size - s.bi_valid, s.bi_valid += length - Buf_size;\n      else\n        s.bi_buf |= value << s.bi_valid & 65535, s.bi_valid += length;\n    }\n    function send_code(s, c, tree) {\n      send_bits(s, tree[c * 2], tree[c * 2 + 1]);\n    }\n    function bi_reverse(code, len) {\n      var res = 0;\n      do\n        res |= code & 1, code >>>= 1, res <<= 1;\n      while (--len > 0);\n      return res >>> 1;\n    }\n    function bi_flush(s) {\n      if (s.bi_valid === 16)\n        put_short(s, s.bi_buf), s.bi_buf = 0, s.bi_valid = 0;\n      else if (s.bi_valid >= 8)\n        s.pending_buf[s.pending++] = s.bi_buf & 255, s.bi_buf >>= 8, s.bi_valid -= 8;\n    }\n    function gen_bitlen(s, desc) {\n      var { dyn_tree: tree, max_code } = desc, stree = desc.stat_desc.static_tree, has_stree = desc.stat_desc.has_stree, extra = desc.stat_desc.extra_bits, base = desc.stat_desc.extra_base, max_length = desc.stat_desc.max_length, h, n, m, bits, xbits, f, overflow = 0;\n      for (bits = 0;bits <= MAX_BITS; bits++)\n        s.bl_count[bits] = 0;\n      tree[s.heap[s.heap_max] * 2 + 1] = 0;\n      for (h = s.heap_max + 1;h < HEAP_SIZE; h++) {\n        if (n = s.heap[h], bits = tree[tree[n * 2 + 1] * 2 + 1] + 1, bits > max_length)\n          bits = max_length, overflow++;\n        if (tree[n * 2 + 1] = bits, n > max_code)\n          continue;\n        if (s.bl_count[bits]++, xbits = 0, n >= base)\n          xbits = extra[n - base];\n        if (f = tree[n * 2], s.opt_len += f * (bits + xbits), has_stree)\n          s.static_len += f * (stree[n * 2 + 1] + xbits);\n      }\n      if (overflow === 0)\n        return;\n      do {\n        bits = max_length - 1;\n        while (s.bl_count[bits] === 0)\n          bits--;\n        s.bl_count[bits]--, s.bl_count[bits + 1] += 2, s.bl_count[max_length]--, overflow -= 2;\n      } while (overflow > 0);\n      for (bits = max_length;bits !== 0; bits--) {\n        n = s.bl_count[bits];\n        while (n !== 0) {\n          if (m = s.heap[--h], m > max_code)\n            continue;\n          if (tree[m * 2 + 1] !== bits)\n            s.opt_len += (bits - tree[m * 2 + 1]) * tree[m * 2], tree[m * 2 + 1] = bits;\n          n--;\n        }\n      }\n    }\n    function gen_codes(tree, max_code, bl_count) {\n      var next_code = new Array(MAX_BITS + 1), code = 0, bits, n;\n      for (bits = 1;bits <= MAX_BITS; bits++)\n        next_code[bits] = code = code + bl_count[bits - 1] << 1;\n      for (n = 0;n <= max_code; n++) {\n        var len = tree[n * 2 + 1];\n        if (len === 0)\n          continue;\n        tree[n * 2] = bi_reverse(next_code[len]++, len);\n      }\n    }\n    function tr_static_init() {\n      var n, bits, length, code, dist, bl_count = new Array(MAX_BITS + 1);\n      length = 0;\n      for (code = 0;code < LENGTH_CODES - 1; code++) {\n        base_length[code] = length;\n        for (n = 0;n < 1 << extra_lbits[code]; n++)\n          _length_code[length++] = code;\n      }\n      _length_code[length - 1] = code, dist = 0;\n      for (code = 0;code < 16; code++) {\n        base_dist[code] = dist;\n        for (n = 0;n < 1 << extra_dbits[code]; n++)\n          _dist_code[dist++] = code;\n      }\n      dist >>= 7;\n      for (;code < D_CODES; code++) {\n        base_dist[code] = dist << 7;\n        for (n = 0;n < 1 << extra_dbits[code] - 7; n++)\n          _dist_code[256 + dist++] = code;\n      }\n      for (bits = 0;bits <= MAX_BITS; bits++)\n        bl_count[bits] = 0;\n      n = 0;\n      while (n <= 143)\n        static_ltree[n * 2 + 1] = 8, n++, bl_count[8]++;\n      while (n <= 255)\n        static_ltree[n * 2 + 1] = 9, n++, bl_count[9]++;\n      while (n <= 279)\n        static_ltree[n * 2 + 1] = 7, n++, bl_count[7]++;\n      while (n <= 287)\n        static_ltree[n * 2 + 1] = 8, n++, bl_count[8]++;\n      gen_codes(static_ltree, L_CODES + 1, bl_count);\n      for (n = 0;n < D_CODES; n++)\n        static_dtree[n * 2 + 1] = 5, static_dtree[n * 2] = bi_reverse(n, 5);\n      static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS), static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES, MAX_BITS), static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES, MAX_BL_BITS);\n    }\n    function init_block(s) {\n      var n;\n      for (n = 0;n < L_CODES; n++)\n        s.dyn_ltree[n * 2] = 0;\n      for (n = 0;n < D_CODES; n++)\n        s.dyn_dtree[n * 2] = 0;\n      for (n = 0;n < BL_CODES; n++)\n        s.bl_tree[n * 2] = 0;\n      s.dyn_ltree[END_BLOCK * 2] = 1, s.opt_len = s.static_len = 0, s.last_lit = s.matches = 0;\n    }\n    function bi_windup(s) {\n      if (s.bi_valid > 8)\n        put_short(s, s.bi_buf);\n      else if (s.bi_valid > 0)\n        s.pending_buf[s.pending++] = s.bi_buf;\n      s.bi_buf = 0, s.bi_valid = 0;\n    }\n    function copy_block(s, buf, len, header) {\n      if (bi_windup(s), header)\n        put_short(s, len), put_short(s, ~len);\n      utils.arraySet(s.pending_buf, s.window, buf, len, s.pending), s.pending += len;\n    }\n    function smaller(tree, n, m, depth) {\n      var _n2 = n * 2, _m2 = m * 2;\n      return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n] <= depth[m];\n    }\n    function pqdownheap(s, tree, k) {\n      var v = s.heap[k], j = k << 1;\n      while (j <= s.heap_len) {\n        if (j < s.heap_len && smaller(tree, s.heap[j + 1], s.heap[j], s.depth))\n          j++;\n        if (smaller(tree, v, s.heap[j], s.depth))\n          break;\n        s.heap[k] = s.heap[j], k = j, j <<= 1;\n      }\n      s.heap[k] = v;\n    }\n    function compress_block(s, ltree, dtree) {\n      var dist, lc, lx = 0, code, extra;\n      if (s.last_lit !== 0)\n        do\n          if (dist = s.pending_buf[s.d_buf + lx * 2] << 8 | s.pending_buf[s.d_buf + lx * 2 + 1], lc = s.pending_buf[s.l_buf + lx], lx++, dist === 0)\n            send_code(s, lc, ltree);\n          else {\n            if (code = _length_code[lc], send_code(s, code + LITERALS + 1, ltree), extra = extra_lbits[code], extra !== 0)\n              lc -= base_length[code], send_bits(s, lc, extra);\n            if (dist--, code = d_code(dist), send_code(s, code, dtree), extra = extra_dbits[code], extra !== 0)\n              dist -= base_dist[code], send_bits(s, dist, extra);\n          }\n        while (lx < s.last_lit);\n      send_code(s, END_BLOCK, ltree);\n    }\n    function build_tree(s, desc) {\n      var tree = desc.dyn_tree, stree = desc.stat_desc.static_tree, has_stree = desc.stat_desc.has_stree, elems = desc.stat_desc.elems, n, m, max_code = -1, node;\n      s.heap_len = 0, s.heap_max = HEAP_SIZE;\n      for (n = 0;n < elems; n++)\n        if (tree[n * 2] !== 0)\n          s.heap[++s.heap_len] = max_code = n, s.depth[n] = 0;\n        else\n          tree[n * 2 + 1] = 0;\n      while (s.heap_len < 2)\n        if (node = s.heap[++s.heap_len] = max_code < 2 \? ++max_code : 0, tree[node * 2] = 1, s.depth[node] = 0, s.opt_len--, has_stree)\n          s.static_len -= stree[node * 2 + 1];\n      desc.max_code = max_code;\n      for (n = s.heap_len >> 1;n >= 1; n--)\n        pqdownheap(s, tree, n);\n      node = elems;\n      do\n        n = s.heap[1], s.heap[1] = s.heap[s.heap_len--], pqdownheap(s, tree, 1), m = s.heap[1], s.heap[--s.heap_max] = n, s.heap[--s.heap_max] = m, tree[node * 2] = tree[n * 2] + tree[m * 2], s.depth[node] = (s.depth[n] >= s.depth[m] \? s.depth[n] : s.depth[m]) + 1, tree[n * 2 + 1] = tree[m * 2 + 1] = node, s.heap[1] = node++, pqdownheap(s, tree, 1);\n      while (s.heap_len >= 2);\n      s.heap[--s.heap_max] = s.heap[1], gen_bitlen(s, desc), gen_codes(tree, max_code, s.bl_count);\n    }\n    function scan_tree(s, tree, max_code) {\n      var n, prevlen = -1, curlen, nextlen = tree[1], count = 0, max_count = 7, min_count = 4;\n      if (nextlen === 0)\n        max_count = 138, min_count = 3;\n      tree[(max_code + 1) * 2 + 1] = 65535;\n      for (n = 0;n <= max_code; n++) {\n        if (curlen = nextlen, nextlen = tree[(n + 1) * 2 + 1], ++count < max_count && curlen === nextlen)\n          continue;\n        else if (count < min_count)\n          s.bl_tree[curlen * 2] += count;\n        else if (curlen !== 0) {\n          if (curlen !== prevlen)\n            s.bl_tree[curlen * 2]++;\n          s.bl_tree[REP_3_6 * 2]++;\n        } else if (count <= 10)\n          s.bl_tree[REPZ_3_10 * 2]++;\n        else\n          s.bl_tree[REPZ_11_138 * 2]++;\n        if (count = 0, prevlen = curlen, nextlen === 0)\n          max_count = 138, min_count = 3;\n        else if (curlen === nextlen)\n          max_count = 6, min_count = 3;\n        else\n          max_count = 7, min_count = 4;\n      }\n    }\n    function send_tree(s, tree, max_code) {\n      var n, prevlen = -1, curlen, nextlen = tree[1], count = 0, max_count = 7, min_count = 4;\n      if (nextlen === 0)\n        max_count = 138, min_count = 3;\n      for (n = 0;n <= max_code; n++) {\n        if (curlen = nextlen, nextlen = tree[(n + 1) * 2 + 1], ++count < max_count && curlen === nextlen)\n          continue;\n        else if (count < min_count)\n          do\n            send_code(s, curlen, s.bl_tree);\n          while (--count !== 0);\n        else if (curlen !== 0) {\n          if (curlen !== prevlen)\n            send_code(s, curlen, s.bl_tree), count--;\n          send_code(s, REP_3_6, s.bl_tree), send_bits(s, count - 3, 2);\n        } else if (count <= 10)\n          send_code(s, REPZ_3_10, s.bl_tree), send_bits(s, count - 3, 3);\n        else\n          send_code(s, REPZ_11_138, s.bl_tree), send_bits(s, count - 11, 7);\n        if (count = 0, prevlen = curlen, nextlen === 0)\n          max_count = 138, min_count = 3;\n        else if (curlen === nextlen)\n          max_count = 6, min_count = 3;\n        else\n          max_count = 7, min_count = 4;\n      }\n    }\n    function build_bl_tree(s) {\n      var max_blindex;\n      scan_tree(s, s.dyn_ltree, s.l_desc.max_code), scan_tree(s, s.dyn_dtree, s.d_desc.max_code), build_tree(s, s.bl_desc);\n      for (max_blindex = BL_CODES - 1;max_blindex >= 3; max_blindex--)\n        if (s.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0)\n          break;\n      return s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4, max_blindex;\n    }\n    function send_all_trees(s, lcodes, dcodes, blcodes) {\n      var rank;\n      send_bits(s, lcodes - 257, 5), send_bits(s, dcodes - 1, 5), send_bits(s, blcodes - 4, 4);\n      for (rank = 0;rank < blcodes; rank++)\n        send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1], 3);\n      send_tree(s, s.dyn_ltree, lcodes - 1), send_tree(s, s.dyn_dtree, dcodes - 1);\n    }\n    function detect_data_type(s) {\n      var black_mask = 4093624447, n;\n      for (n = 0;n <= 31; n++, black_mask >>>= 1)\n        if (black_mask & 1 && s.dyn_ltree[n * 2] !== 0)\n          return Z_BINARY;\n      if (s.dyn_ltree[18] !== 0 || s.dyn_ltree[20] !== 0 || s.dyn_ltree[26] !== 0)\n        return Z_TEXT;\n      for (n = 32;n < LITERALS; n++)\n        if (s.dyn_ltree[n * 2] !== 0)\n          return Z_TEXT;\n      return Z_BINARY;\n    }\n    var static_init_done = !1;\n    function _tr_init(s) {\n      if (!static_init_done)\n        tr_static_init(), static_init_done = !0;\n      s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc), s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc), s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc), s.bi_buf = 0, s.bi_valid = 0, init_block(s);\n    }\n    function _tr_stored_block(s, buf, stored_len, last) {\n      send_bits(s, (STORED_BLOCK << 1) + (last \? 1 : 0), 3), copy_block(s, buf, stored_len, !0);\n    }\n    function _tr_align(s) {\n      send_bits(s, STATIC_TREES << 1, 3), send_code(s, END_BLOCK, static_ltree), bi_flush(s);\n    }\n    function _tr_flush_block(s, buf, stored_len, last) {\n      var opt_lenb, static_lenb, max_blindex = 0;\n      if (s.level > 0) {\n        if (s.strm.data_type === Z_UNKNOWN)\n          s.strm.data_type = detect_data_type(s);\n        if (build_tree(s, s.l_desc), build_tree(s, s.d_desc), max_blindex = build_bl_tree(s), opt_lenb = s.opt_len + 3 + 7 >>> 3, static_lenb = s.static_len + 3 + 7 >>> 3, static_lenb <= opt_lenb)\n          opt_lenb = static_lenb;\n      } else\n        opt_lenb = static_lenb = stored_len + 5;\n      if (stored_len + 4 <= opt_lenb && buf !== -1)\n        _tr_stored_block(s, buf, stored_len, last);\n      else if (s.strategy === Z_FIXED || static_lenb === opt_lenb)\n        send_bits(s, (STATIC_TREES << 1) + (last \? 1 : 0), 3), compress_block(s, static_ltree, static_dtree);\n      else\n        send_bits(s, (DYN_TREES << 1) + (last \? 1 : 0), 3), send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1), compress_block(s, s.dyn_ltree, s.dyn_dtree);\n      if (init_block(s), last)\n        bi_windup(s);\n    }\n    function _tr_tally(s, dist, lc) {\n      if (s.pending_buf[s.d_buf + s.last_lit * 2] = dist >>> 8 & 255, s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 255, s.pending_buf[s.l_buf + s.last_lit] = lc & 255, s.last_lit++, dist === 0)\n        s.dyn_ltree[lc * 2]++;\n      else\n        s.matches++, dist--, s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]++, s.dyn_dtree[d_code(dist) * 2]++;\n      return s.last_lit === s.lit_bufsize - 1;\n    }\n    exports._tr_init = _tr_init, exports._tr_stored_block = _tr_stored_block, exports._tr_flush_block = _tr_flush_block, exports._tr_tally = _tr_tally, exports._tr_align = _tr_align;\n  }\n}), require_adler32 = __commonJS({\n  \"node_modules/pako/lib/zlib/adler32.js\"(exports, module2) {\n    function adler32(adler, buf, len, pos) {\n      var s1 = adler & 65535 | 0, s2 = adler >>> 16 & 65535 | 0, n = 0;\n      while (len !== 0) {\n        n = len > 2000 \? 2000 : len, len -= n;\n        do\n          s1 = s1 + buf[pos++] | 0, s2 = s2 + s1 | 0;\n        while (--n);\n        s1 %= 65521, s2 %= 65521;\n      }\n      return s1 | s2 << 16 | 0;\n    }\n    module2.exports = adler32;\n  }\n}), require_crc32 = __commonJS({\n  \"node_modules/pako/lib/zlib/crc32.js\"(exports, module2) {\n    function makeTable() {\n      var c, table = [];\n      for (var n = 0;n < 256; n++) {\n        c = n;\n        for (var k = 0;k < 8; k++)\n          c = c & 1 \? 3988292384 ^ c >>> 1 : c >>> 1;\n        table[n] = c;\n      }\n      return table;\n    }\n    var crcTable = makeTable();\n    function crc32(crc, buf, len, pos) {\n      var t = crcTable, end = pos + len;\n      crc ^= -1;\n      for (var i = pos;i < end; i++)\n        crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 255];\n      return crc ^ -1;\n    }\n    module2.exports = crc32;\n  }\n}), require_messages = __commonJS({\n  \"node_modules/pako/lib/zlib/messages.js\"(exports, module2) {\n    module2.exports = {\n      2: \"need dictionary\",\n      1: \"stream end\",\n      0: \"\",\n      \"-1\": \"file error\",\n      \"-2\": \"stream error\",\n      \"-3\": \"data error\",\n      \"-4\": \"insufficient memory\",\n      \"-5\": \"buffer error\",\n      \"-6\": \"incompatible version\"\n    };\n  }\n}), require_deflate = __commonJS({\n  \"node_modules/pako/lib/zlib/deflate.js\"(exports) {\n    var utils = require_common(), trees = require_trees(), adler32 = require_adler32(), crc32 = require_crc32(), msg = require_messages(), Z_NO_FLUSH = 0, Z_PARTIAL_FLUSH = 1, Z_FULL_FLUSH = 3, Z_FINISH = 4, Z_BLOCK = 5, Z_OK = 0, Z_STREAM_END = 1, Z_STREAM_ERROR = -2, Z_DATA_ERROR = -3, Z_BUF_ERROR = -5, Z_DEFAULT_COMPRESSION = -1, Z_FILTERED = 1, Z_HUFFMAN_ONLY = 2, Z_RLE = 3, Z_FIXED = 4, Z_DEFAULT_STRATEGY = 0, Z_UNKNOWN = 2, Z_DEFLATED = 8, MAX_MEM_LEVEL = 9, MAX_WBITS = 15, DEF_MEM_LEVEL = 8, LENGTH_CODES = 29, LITERALS = 256, L_CODES = LITERALS + 1 + LENGTH_CODES, D_CODES = 30, BL_CODES = 19, HEAP_SIZE = 2 * L_CODES + 1, MAX_BITS = 15, MIN_MATCH = 3, MAX_MATCH = 258, MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1, PRESET_DICT = 32, INIT_STATE = 42, EXTRA_STATE = 69, NAME_STATE = 73, COMMENT_STATE = 91, HCRC_STATE = 103, BUSY_STATE = 113, FINISH_STATE = 666, BS_NEED_MORE = 1, BS_BLOCK_DONE = 2, BS_FINISH_STARTED = 3, BS_FINISH_DONE = 4, OS_CODE = 3;\n    function err(strm, errorCode) {\n      return strm.msg = msg[errorCode], errorCode;\n    }\n    function rank(f) {\n      return (f << 1) - (f > 4 \? 9 : 0);\n    }\n    function zero(buf) {\n      var len = buf.length;\n      while (--len >= 0)\n        buf[len] = 0;\n    }\n    function flush_pending(strm) {\n      var s = strm.state, len = s.pending;\n      if (len > strm.avail_out)\n        len = strm.avail_out;\n      if (len === 0)\n        return;\n      if (utils.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out), strm.next_out += len, s.pending_out += len, strm.total_out += len, strm.avail_out -= len, s.pending -= len, s.pending === 0)\n        s.pending_out = 0;\n    }\n    function flush_block_only(s, last) {\n      trees._tr_flush_block(s, s.block_start >= 0 \? s.block_start : -1, s.strstart - s.block_start, last), s.block_start = s.strstart, flush_pending(s.strm);\n    }\n    function put_byte(s, b) {\n      s.pending_buf[s.pending++] = b;\n    }\n    function putShortMSB(s, b) {\n      s.pending_buf[s.pending++] = b >>> 8 & 255, s.pending_buf[s.pending++] = b & 255;\n    }\n    function read_buf(strm, buf, start, size) {\n      var len = strm.avail_in;\n      if (len > size)\n        len = size;\n      if (len === 0)\n        return 0;\n      if (strm.avail_in -= len, utils.arraySet(buf, strm.input, strm.next_in, len, start), strm.state.wrap === 1)\n        strm.adler = adler32(strm.adler, buf, len, start);\n      else if (strm.state.wrap === 2)\n        strm.adler = crc32(strm.adler, buf, len, start);\n      return strm.next_in += len, strm.total_in += len, len;\n    }\n    function longest_match(s, cur_match) {\n      var { max_chain_length: chain_length, strstart: scan } = s, match, len, best_len = s.prev_length, nice_match = s.nice_match, limit = s.strstart > s.w_size - MIN_LOOKAHEAD \? s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0, _win = s.window, wmask = s.w_mask, prev = s.prev, strend = s.strstart + MAX_MATCH, scan_end1 = _win[scan + best_len - 1], scan_end = _win[scan + best_len];\n      if (s.prev_length >= s.good_match)\n        chain_length >>= 2;\n      if (nice_match > s.lookahead)\n        nice_match = s.lookahead;\n      do {\n        if (match = cur_match, _win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1])\n          continue;\n        scan += 2, match++;\n        do\n          ;\n        while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);\n        if (len = MAX_MATCH - (strend - scan), scan = strend - MAX_MATCH, len > best_len) {\n          if (s.match_start = cur_match, best_len = len, len >= nice_match)\n            break;\n          scan_end1 = _win[scan + best_len - 1], scan_end = _win[scan + best_len];\n        }\n      } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);\n      if (best_len <= s.lookahead)\n        return best_len;\n      return s.lookahead;\n    }\n    function fill_window(s) {\n      var _w_size = s.w_size, p, n, m, more, str;\n      do {\n        if (more = s.window_size - s.lookahead - s.strstart, s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {\n          utils.arraySet(s.window, s.window, _w_size, _w_size, 0), s.match_start -= _w_size, s.strstart -= _w_size, s.block_start -= _w_size, n = s.hash_size, p = n;\n          do\n            m = s.head[--p], s.head[p] = m >= _w_size \? m - _w_size : 0;\n          while (--n);\n          n = _w_size, p = n;\n          do\n            m = s.prev[--p], s.prev[p] = m >= _w_size \? m - _w_size : 0;\n          while (--n);\n          more += _w_size;\n        }\n        if (s.strm.avail_in === 0)\n          break;\n        if (n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more), s.lookahead += n, s.lookahead + s.insert >= MIN_MATCH) {\n          str = s.strstart - s.insert, s.ins_h = s.window[str], s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + 1]) & s.hash_mask;\n          while (s.insert)\n            if (s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask, s.prev[str & s.w_mask] = s.head[s.ins_h], s.head[s.ins_h] = str, str++, s.insert--, s.lookahead + s.insert < MIN_MATCH)\n              break;\n        }\n      } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);\n    }\n    function deflate_stored(s, flush) {\n      var max_block_size = 65535;\n      if (max_block_size > s.pending_buf_size - 5)\n        max_block_size = s.pending_buf_size - 5;\n      for (;; ) {\n        if (s.lookahead <= 1) {\n          if (fill_window(s), s.lookahead === 0 && flush === Z_NO_FLUSH)\n            return BS_NEED_MORE;\n          if (s.lookahead === 0)\n            break;\n        }\n        s.strstart += s.lookahead, s.lookahead = 0;\n        var max_start = s.block_start + max_block_size;\n        if (s.strstart === 0 || s.strstart >= max_start) {\n          if (s.lookahead = s.strstart - max_start, s.strstart = max_start, flush_block_only(s, !1), s.strm.avail_out === 0)\n            return BS_NEED_MORE;\n        }\n        if (s.strstart - s.block_start >= s.w_size - MIN_LOOKAHEAD) {\n          if (flush_block_only(s, !1), s.strm.avail_out === 0)\n            return BS_NEED_MORE;\n        }\n      }\n      if (s.insert = 0, flush === Z_FINISH) {\n        if (flush_block_only(s, !0), s.strm.avail_out === 0)\n          return BS_FINISH_STARTED;\n        return BS_FINISH_DONE;\n      }\n      if (s.strstart > s.block_start) {\n        if (flush_block_only(s, !1), s.strm.avail_out === 0)\n          return BS_NEED_MORE;\n      }\n      return BS_NEED_MORE;\n    }\n    function deflate_fast(s, flush) {\n      var hash_head, bflush;\n      for (;; ) {\n        if (s.lookahead < MIN_LOOKAHEAD) {\n          if (fill_window(s), s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH)\n            return BS_NEED_MORE;\n          if (s.lookahead === 0)\n            break;\n        }\n        if (hash_head = 0, s.lookahead >= MIN_MATCH)\n          s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask, hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h], s.head[s.ins_h] = s.strstart;\n        if (hash_head !== 0 && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD)\n          s.match_length = longest_match(s, hash_head);\n        if (s.match_length >= MIN_MATCH)\n          if (bflush = trees._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH), s.lookahead -= s.match_length, s.match_length <= s.max_lazy_match && s.lookahead >= MIN_MATCH) {\n            s.match_length--;\n            do\n              s.strstart++, s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask, hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h], s.head[s.ins_h] = s.strstart;\n            while (--s.match_length !== 0);\n            s.strstart++;\n          } else\n            s.strstart += s.match_length, s.match_length = 0, s.ins_h = s.window[s.strstart], s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + 1]) & s.hash_mask;\n        else\n          bflush = trees._tr_tally(s, 0, s.window[s.strstart]), s.lookahead--, s.strstart++;\n        if (bflush) {\n          if (flush_block_only(s, !1), s.strm.avail_out === 0)\n            return BS_NEED_MORE;\n        }\n      }\n      if (s.insert = s.strstart < MIN_MATCH - 1 \? s.strstart : MIN_MATCH - 1, flush === Z_FINISH) {\n        if (flush_block_only(s, !0), s.strm.avail_out === 0)\n          return BS_FINISH_STARTED;\n        return BS_FINISH_DONE;\n      }\n      if (s.last_lit) {\n        if (flush_block_only(s, !1), s.strm.avail_out === 0)\n          return BS_NEED_MORE;\n      }\n      return BS_BLOCK_DONE;\n    }\n    function deflate_slow(s, flush) {\n      var hash_head, bflush, max_insert;\n      for (;; ) {\n        if (s.lookahead < MIN_LOOKAHEAD) {\n          if (fill_window(s), s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH)\n            return BS_NEED_MORE;\n          if (s.lookahead === 0)\n            break;\n        }\n        if (hash_head = 0, s.lookahead >= MIN_MATCH)\n          s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask, hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h], s.head[s.ins_h] = s.strstart;\n        if (s.prev_length = s.match_length, s.prev_match = s.match_start, s.match_length = MIN_MATCH - 1, hash_head !== 0 && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {\n          if (s.match_length = longest_match(s, hash_head), s.match_length <= 5 && (s.strategy === Z_FILTERED || s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096))\n            s.match_length = MIN_MATCH - 1;\n        }\n        if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {\n          max_insert = s.strstart + s.lookahead - MIN_MATCH, bflush = trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH), s.lookahead -= s.prev_length - 1, s.prev_length -= 2;\n          do\n            if (++s.strstart <= max_insert)\n              s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask, hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h], s.head[s.ins_h] = s.strstart;\n          while (--s.prev_length !== 0);\n          if (s.match_available = 0, s.match_length = MIN_MATCH - 1, s.strstart++, bflush) {\n            if (flush_block_only(s, !1), s.strm.avail_out === 0)\n              return BS_NEED_MORE;\n          }\n        } else if (s.match_available) {\n          if (bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]), bflush)\n            flush_block_only(s, !1);\n          if (s.strstart++, s.lookahead--, s.strm.avail_out === 0)\n            return BS_NEED_MORE;\n        } else\n          s.match_available = 1, s.strstart++, s.lookahead--;\n      }\n      if (s.match_available)\n        bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]), s.match_available = 0;\n      if (s.insert = s.strstart < MIN_MATCH - 1 \? s.strstart : MIN_MATCH - 1, flush === Z_FINISH) {\n        if (flush_block_only(s, !0), s.strm.avail_out === 0)\n          return BS_FINISH_STARTED;\n        return BS_FINISH_DONE;\n      }\n      if (s.last_lit) {\n        if (flush_block_only(s, !1), s.strm.avail_out === 0)\n          return BS_NEED_MORE;\n      }\n      return BS_BLOCK_DONE;\n    }\n    function deflate_rle(s, flush) {\n      var bflush, prev, scan, strend, _win = s.window;\n      for (;; ) {\n        if (s.lookahead <= MAX_MATCH) {\n          if (fill_window(s), s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH)\n            return BS_NEED_MORE;\n          if (s.lookahead === 0)\n            break;\n        }\n        if (s.match_length = 0, s.lookahead >= MIN_MATCH && s.strstart > 0) {\n          if (scan = s.strstart - 1, prev = _win[scan], prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {\n            strend = s.strstart + MAX_MATCH;\n            do\n              ;\n            while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);\n            if (s.match_length = MAX_MATCH - (strend - scan), s.match_length > s.lookahead)\n              s.match_length = s.lookahead;\n          }\n        }\n        if (s.match_length >= MIN_MATCH)\n          bflush = trees._tr_tally(s, 1, s.match_length - MIN_MATCH), s.lookahead -= s.match_length, s.strstart += s.match_length, s.match_length = 0;\n        else\n          bflush = trees._tr_tally(s, 0, s.window[s.strstart]), s.lookahead--, s.strstart++;\n        if (bflush) {\n          if (flush_block_only(s, !1), s.strm.avail_out === 0)\n            return BS_NEED_MORE;\n        }\n      }\n      if (s.insert = 0, flush === Z_FINISH) {\n        if (flush_block_only(s, !0), s.strm.avail_out === 0)\n          return BS_FINISH_STARTED;\n        return BS_FINISH_DONE;\n      }\n      if (s.last_lit) {\n        if (flush_block_only(s, !1), s.strm.avail_out === 0)\n          return BS_NEED_MORE;\n      }\n      return BS_BLOCK_DONE;\n    }\n    function deflate_huff(s, flush) {\n      var bflush;\n      for (;; ) {\n        if (s.lookahead === 0) {\n          if (fill_window(s), s.lookahead === 0) {\n            if (flush === Z_NO_FLUSH)\n              return BS_NEED_MORE;\n            break;\n          }\n        }\n        if (s.match_length = 0, bflush = trees._tr_tally(s, 0, s.window[s.strstart]), s.lookahead--, s.strstart++, bflush) {\n          if (flush_block_only(s, !1), s.strm.avail_out === 0)\n            return BS_NEED_MORE;\n        }\n      }\n      if (s.insert = 0, flush === Z_FINISH) {\n        if (flush_block_only(s, !0), s.strm.avail_out === 0)\n          return BS_FINISH_STARTED;\n        return BS_FINISH_DONE;\n      }\n      if (s.last_lit) {\n        if (flush_block_only(s, !1), s.strm.avail_out === 0)\n          return BS_NEED_MORE;\n      }\n      return BS_BLOCK_DONE;\n    }\n    function Config(good_length, max_lazy, nice_length, max_chain, func) {\n      this.good_length = good_length, this.max_lazy = max_lazy, this.nice_length = nice_length, this.max_chain = max_chain, this.func = func;\n    }\n    var configuration_table = [\n      new Config(0, 0, 0, 0, deflate_stored),\n      new Config(4, 4, 8, 4, deflate_fast),\n      new Config(4, 5, 16, 8, deflate_fast),\n      new Config(4, 6, 32, 32, deflate_fast),\n      new Config(4, 4, 16, 16, deflate_slow),\n      new Config(8, 16, 32, 32, deflate_slow),\n      new Config(8, 16, 128, 128, deflate_slow),\n      new Config(8, 32, 128, 256, deflate_slow),\n      new Config(32, 128, 258, 1024, deflate_slow),\n      new Config(32, 258, 258, 4096, deflate_slow)\n    ];\n    function lm_init(s) {\n      s.window_size = 2 * s.w_size, zero(s.head), s.max_lazy_match = configuration_table[s.level].max_lazy, s.good_match = configuration_table[s.level].good_length, s.nice_match = configuration_table[s.level].nice_length, s.max_chain_length = configuration_table[s.level].max_chain, s.strstart = 0, s.block_start = 0, s.lookahead = 0, s.insert = 0, s.match_length = s.prev_length = MIN_MATCH - 1, s.match_available = 0, s.ins_h = 0;\n    }\n    function DeflateState() {\n      this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = Z_DEFLATED, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new utils.Buf16(HEAP_SIZE * 2), this.dyn_dtree = new utils.Buf16((2 * D_CODES + 1) * 2), this.bl_tree = new utils.Buf16((2 * BL_CODES + 1) * 2), zero(this.dyn_ltree), zero(this.dyn_dtree), zero(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new utils.Buf16(MAX_BITS + 1), this.heap = new utils.Buf16(2 * L_CODES + 1), zero(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new utils.Buf16(2 * L_CODES + 1), zero(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;\n    }\n    function deflateResetKeep(strm) {\n      var s;\n      if (!strm || !strm.state)\n        return err(strm, Z_STREAM_ERROR);\n      if (strm.total_in = strm.total_out = 0, strm.data_type = Z_UNKNOWN, s = strm.state, s.pending = 0, s.pending_out = 0, s.wrap < 0)\n        s.wrap = -s.wrap;\n      return s.status = s.wrap \? INIT_STATE : BUSY_STATE, strm.adler = s.wrap === 2 \? 0 : 1, s.last_flush = Z_NO_FLUSH, trees._tr_init(s), Z_OK;\n    }\n    function deflateReset(strm) {\n      var ret = deflateResetKeep(strm);\n      if (ret === Z_OK)\n        lm_init(strm.state);\n      return ret;\n    }\n    function deflateSetHeader(strm, head) {\n      if (!strm || !strm.state)\n        return Z_STREAM_ERROR;\n      if (strm.state.wrap !== 2)\n        return Z_STREAM_ERROR;\n      return strm.state.gzhead = head, Z_OK;\n    }\n    function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {\n      if (!strm)\n        return Z_STREAM_ERROR;\n      var wrap = 1;\n      if (level === Z_DEFAULT_COMPRESSION)\n        level = 6;\n      if (windowBits < 0)\n        wrap = 0, windowBits = -windowBits;\n      else if (windowBits > 15)\n        wrap = 2, windowBits -= 16;\n      if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED)\n        return err(strm, Z_STREAM_ERROR);\n      if (windowBits === 8)\n        windowBits = 9;\n      var s = new DeflateState;\n      return strm.state = s, s.strm = strm, s.wrap = wrap, s.gzhead = null, s.w_bits = windowBits, s.w_size = 1 << s.w_bits, s.w_mask = s.w_size - 1, s.hash_bits = memLevel + 7, s.hash_size = 1 << s.hash_bits, s.hash_mask = s.hash_size - 1, s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH), s.window = new utils.Buf8(s.w_size * 2), s.head = new utils.Buf16(s.hash_size), s.prev = new utils.Buf16(s.w_size), s.lit_bufsize = 1 << memLevel + 6, s.pending_buf_size = s.lit_bufsize * 4, s.pending_buf = new utils.Buf8(s.pending_buf_size), s.d_buf = 1 * s.lit_bufsize, s.l_buf = 3 * s.lit_bufsize, s.level = level, s.strategy = strategy, s.method = method, deflateReset(strm);\n    }\n    function deflateInit(strm, level) {\n      return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);\n    }\n    function deflate(strm, flush) {\n      var old_flush, s, beg, val;\n      if (!strm || !strm.state || flush > Z_BLOCK || flush < 0)\n        return strm \? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;\n      if (s = strm.state, !strm.output || !strm.input && strm.avail_in !== 0 || s.status === FINISH_STATE && flush !== Z_FINISH)\n        return err(strm, strm.avail_out === 0 \? Z_BUF_ERROR : Z_STREAM_ERROR);\n      if (s.strm = strm, old_flush = s.last_flush, s.last_flush = flush, s.status === INIT_STATE)\n        if (s.wrap === 2)\n          if (strm.adler = 0, put_byte(s, 31), put_byte(s, 139), put_byte(s, 8), !s.gzhead)\n            put_byte(s, 0), put_byte(s, 0), put_byte(s, 0), put_byte(s, 0), put_byte(s, 0), put_byte(s, s.level === 9 \? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 \? 4 : 0), put_byte(s, OS_CODE), s.status = BUSY_STATE;\n          else {\n            if (put_byte(s, (s.gzhead.text \? 1 : 0) + (s.gzhead.hcrc \? 2 : 0) + (!s.gzhead.extra \? 0 : 4) + (!s.gzhead.name \? 0 : 8) + (!s.gzhead.comment \? 0 : 16)), put_byte(s, s.gzhead.time & 255), put_byte(s, s.gzhead.time >> 8 & 255), put_byte(s, s.gzhead.time >> 16 & 255), put_byte(s, s.gzhead.time >> 24 & 255), put_byte(s, s.level === 9 \? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 \? 4 : 0), put_byte(s, s.gzhead.os & 255), s.gzhead.extra && s.gzhead.extra.length)\n              put_byte(s, s.gzhead.extra.length & 255), put_byte(s, s.gzhead.extra.length >> 8 & 255);\n            if (s.gzhead.hcrc)\n              strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);\n            s.gzindex = 0, s.status = EXTRA_STATE;\n          }\n        else {\n          var header = Z_DEFLATED + (s.w_bits - 8 << 4) << 8, level_flags = -1;\n          if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2)\n            level_flags = 0;\n          else if (s.level < 6)\n            level_flags = 1;\n          else if (s.level === 6)\n            level_flags = 2;\n          else\n            level_flags = 3;\n          if (header |= level_flags << 6, s.strstart !== 0)\n            header |= PRESET_DICT;\n          if (header += 31 - header % 31, s.status = BUSY_STATE, putShortMSB(s, header), s.strstart !== 0)\n            putShortMSB(s, strm.adler >>> 16), putShortMSB(s, strm.adler & 65535);\n          strm.adler = 1;\n        }\n      if (s.status === EXTRA_STATE)\n        if (s.gzhead.extra) {\n          beg = s.pending;\n          while (s.gzindex < (s.gzhead.extra.length & 65535)) {\n            if (s.pending === s.pending_buf_size) {\n              if (s.gzhead.hcrc && s.pending > beg)\n                strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n              if (flush_pending(strm), beg = s.pending, s.pending === s.pending_buf_size)\n                break;\n            }\n            put_byte(s, s.gzhead.extra[s.gzindex] & 255), s.gzindex++;\n          }\n          if (s.gzhead.hcrc && s.pending > beg)\n            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n          if (s.gzindex === s.gzhead.extra.length)\n            s.gzindex = 0, s.status = NAME_STATE;\n        } else\n          s.status = NAME_STATE;\n      if (s.status === NAME_STATE)\n        if (s.gzhead.name) {\n          beg = s.pending;\n          do {\n            if (s.pending === s.pending_buf_size) {\n              if (s.gzhead.hcrc && s.pending > beg)\n                strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n              if (flush_pending(strm), beg = s.pending, s.pending === s.pending_buf_size) {\n                val = 1;\n                break;\n              }\n            }\n            if (s.gzindex < s.gzhead.name.length)\n              val = s.gzhead.name.charCodeAt(s.gzindex++) & 255;\n            else\n              val = 0;\n            put_byte(s, val);\n          } while (val !== 0);\n          if (s.gzhead.hcrc && s.pending > beg)\n            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n          if (val === 0)\n            s.gzindex = 0, s.status = COMMENT_STATE;\n        } else\n          s.status = COMMENT_STATE;\n      if (s.status === COMMENT_STATE)\n        if (s.gzhead.comment) {\n          beg = s.pending;\n          do {\n            if (s.pending === s.pending_buf_size) {\n              if (s.gzhead.hcrc && s.pending > beg)\n                strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n              if (flush_pending(strm), beg = s.pending, s.pending === s.pending_buf_size) {\n                val = 1;\n                break;\n              }\n            }\n            if (s.gzindex < s.gzhead.comment.length)\n              val = s.gzhead.comment.charCodeAt(s.gzindex++) & 255;\n            else\n              val = 0;\n            put_byte(s, val);\n          } while (val !== 0);\n          if (s.gzhead.hcrc && s.pending > beg)\n            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n          if (val === 0)\n            s.status = HCRC_STATE;\n        } else\n          s.status = HCRC_STATE;\n      if (s.status === HCRC_STATE)\n        if (s.gzhead.hcrc) {\n          if (s.pending + 2 > s.pending_buf_size)\n            flush_pending(strm);\n          if (s.pending + 2 <= s.pending_buf_size)\n            put_byte(s, strm.adler & 255), put_byte(s, strm.adler >> 8 & 255), strm.adler = 0, s.status = BUSY_STATE;\n        } else\n          s.status = BUSY_STATE;\n      if (s.pending !== 0) {\n        if (flush_pending(strm), strm.avail_out === 0)\n          return s.last_flush = -1, Z_OK;\n      } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH)\n        return err(strm, Z_BUF_ERROR);\n      if (s.status === FINISH_STATE && strm.avail_in !== 0)\n        return err(strm, Z_BUF_ERROR);\n      if (strm.avail_in !== 0 || s.lookahead !== 0 || flush !== Z_NO_FLUSH && s.status !== FINISH_STATE) {\n        var bstate = s.strategy === Z_HUFFMAN_ONLY \? deflate_huff(s, flush) : s.strategy === Z_RLE \? deflate_rle(s, flush) : configuration_table[s.level].func(s, flush);\n        if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE)\n          s.status = FINISH_STATE;\n        if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {\n          if (strm.avail_out === 0)\n            s.last_flush = -1;\n          return Z_OK;\n        }\n        if (bstate === BS_BLOCK_DONE) {\n          if (flush === Z_PARTIAL_FLUSH)\n            trees._tr_align(s);\n          else if (flush !== Z_BLOCK) {\n            if (trees._tr_stored_block(s, 0, 0, !1), flush === Z_FULL_FLUSH) {\n              if (zero(s.head), s.lookahead === 0)\n                s.strstart = 0, s.block_start = 0, s.insert = 0;\n            }\n          }\n          if (flush_pending(strm), strm.avail_out === 0)\n            return s.last_flush = -1, Z_OK;\n        }\n      }\n      if (flush !== Z_FINISH)\n        return Z_OK;\n      if (s.wrap <= 0)\n        return Z_STREAM_END;\n      if (s.wrap === 2)\n        put_byte(s, strm.adler & 255), put_byte(s, strm.adler >> 8 & 255), put_byte(s, strm.adler >> 16 & 255), put_byte(s, strm.adler >> 24 & 255), put_byte(s, strm.total_in & 255), put_byte(s, strm.total_in >> 8 & 255), put_byte(s, strm.total_in >> 16 & 255), put_byte(s, strm.total_in >> 24 & 255);\n      else\n        putShortMSB(s, strm.adler >>> 16), putShortMSB(s, strm.adler & 65535);\n      if (flush_pending(strm), s.wrap > 0)\n        s.wrap = -s.wrap;\n      return s.pending !== 0 \? Z_OK : Z_STREAM_END;\n    }\n    function deflateEnd(strm) {\n      var status;\n      if (!strm || !strm.state)\n        return Z_STREAM_ERROR;\n      if (status = strm.state.status, status !== INIT_STATE && status !== EXTRA_STATE && status !== NAME_STATE && status !== COMMENT_STATE && status !== HCRC_STATE && status !== BUSY_STATE && status !== FINISH_STATE)\n        return err(strm, Z_STREAM_ERROR);\n      return strm.state = null, status === BUSY_STATE \? err(strm, Z_DATA_ERROR) : Z_OK;\n    }\n    function deflateSetDictionary(strm, dictionary) {\n      var dictLength = dictionary.length, s, str, n, wrap, avail, next, input, tmpDict;\n      if (!strm || !strm.state)\n        return Z_STREAM_ERROR;\n      if (s = strm.state, wrap = s.wrap, wrap === 2 || wrap === 1 && s.status !== INIT_STATE || s.lookahead)\n        return Z_STREAM_ERROR;\n      if (wrap === 1)\n        strm.adler = adler32(strm.adler, dictionary, dictLength, 0);\n      if (s.wrap = 0, dictLength >= s.w_size) {\n        if (wrap === 0)\n          zero(s.head), s.strstart = 0, s.block_start = 0, s.insert = 0;\n        tmpDict = new utils.Buf8(s.w_size), utils.arraySet(tmpDict, dictionary, dictLength - s.w_size, s.w_size, 0), dictionary = tmpDict, dictLength = s.w_size;\n      }\n      avail = strm.avail_in, next = strm.next_in, input = strm.input, strm.avail_in = dictLength, strm.next_in = 0, strm.input = dictionary, fill_window(s);\n      while (s.lookahead >= MIN_MATCH) {\n        str = s.strstart, n = s.lookahead - (MIN_MATCH - 1);\n        do\n          s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask, s.prev[str & s.w_mask] = s.head[s.ins_h], s.head[s.ins_h] = str, str++;\n        while (--n);\n        s.strstart = str, s.lookahead = MIN_MATCH - 1, fill_window(s);\n      }\n      return s.strstart += s.lookahead, s.block_start = s.strstart, s.insert = s.lookahead, s.lookahead = 0, s.match_length = s.prev_length = MIN_MATCH - 1, s.match_available = 0, strm.next_in = next, strm.input = input, strm.avail_in = avail, s.wrap = wrap, Z_OK;\n    }\n    exports.deflateInit = deflateInit, exports.deflateInit2 = deflateInit2, exports.deflateReset = deflateReset, exports.deflateResetKeep = deflateResetKeep, exports.deflateSetHeader = deflateSetHeader, exports.deflate = deflate, exports.deflateEnd = deflateEnd, exports.deflateSetDictionary = deflateSetDictionary, exports.deflateInfo = \"pako deflate (from Nodeca project)\";\n  }\n}), require_inffast = __commonJS({\n  \"node_modules/pako/lib/zlib/inffast.js\"(exports, module2) {\n    var BAD = 30, TYPE = 12;\n    module2.exports = function inflate_fast(strm, start) {\n      var state, _in, last, _out, beg, end, dmax, wsize, whave, wnext, s_window, hold, bits, lcode, dcode, lmask, dmask, here, op, len, dist, from, from_source, input, output;\n      state = strm.state, _in = strm.next_in, input = strm.input, last = _in + (strm.avail_in - 5), _out = strm.next_out, output = strm.output, beg = _out - (start - strm.avail_out), end = _out + (strm.avail_out - 257), dmax = state.dmax, wsize = state.wsize, whave = state.whave, wnext = state.wnext, s_window = state.window, hold = state.hold, bits = state.bits, lcode = state.lencode, dcode = state.distcode, lmask = (1 << state.lenbits) - 1, dmask = (1 << state.distbits) - 1;\n      top:\n        do {\n          if (bits < 15)\n            hold += input[_in++] << bits, bits += 8, hold += input[_in++] << bits, bits += 8;\n          here = lcode[hold & lmask];\n          dolen:\n            for (;; ) {\n              if (op = here >>> 24, hold >>>= op, bits -= op, op = here >>> 16 & 255, op === 0)\n                output[_out++] = here & 65535;\n              else if (op & 16) {\n                if (len = here & 65535, op &= 15, op) {\n                  if (bits < op)\n                    hold += input[_in++] << bits, bits += 8;\n                  len += hold & (1 << op) - 1, hold >>>= op, bits -= op;\n                }\n                if (bits < 15)\n                  hold += input[_in++] << bits, bits += 8, hold += input[_in++] << bits, bits += 8;\n                here = dcode[hold & dmask];\n                dodist:\n                  for (;; ) {\n                    if (op = here >>> 24, hold >>>= op, bits -= op, op = here >>> 16 & 255, op & 16) {\n                      if (dist = here & 65535, op &= 15, bits < op) {\n                        if (hold += input[_in++] << bits, bits += 8, bits < op)\n                          hold += input[_in++] << bits, bits += 8;\n                      }\n                      if (dist += hold & (1 << op) - 1, dist > dmax) {\n                        strm.msg = \"invalid distance too far back\", state.mode = BAD;\n                        break top;\n                      }\n                      if (hold >>>= op, bits -= op, op = _out - beg, dist > op) {\n                        if (op = dist - op, op > whave) {\n                          if (state.sane) {\n                            strm.msg = \"invalid distance too far back\", state.mode = BAD;\n                            break top;\n                          }\n                        }\n                        if (from = 0, from_source = s_window, wnext === 0) {\n                          if (from += wsize - op, op < len) {\n                            len -= op;\n                            do\n                              output[_out++] = s_window[from++];\n                            while (--op);\n                            from = _out - dist, from_source = output;\n                          }\n                        } else if (wnext < op) {\n                          if (from += wsize + wnext - op, op -= wnext, op < len) {\n                            len -= op;\n                            do\n                              output[_out++] = s_window[from++];\n                            while (--op);\n                            if (from = 0, wnext < len) {\n                              op = wnext, len -= op;\n                              do\n                                output[_out++] = s_window[from++];\n                              while (--op);\n                              from = _out - dist, from_source = output;\n                            }\n                          }\n                        } else if (from += wnext - op, op < len) {\n                          len -= op;\n                          do\n                            output[_out++] = s_window[from++];\n                          while (--op);\n                          from = _out - dist, from_source = output;\n                        }\n                        while (len > 2)\n                          output[_out++] = from_source[from++], output[_out++] = from_source[from++], output[_out++] = from_source[from++], len -= 3;\n                        if (len) {\n                          if (output[_out++] = from_source[from++], len > 1)\n                            output[_out++] = from_source[from++];\n                        }\n                      } else {\n                        from = _out - dist;\n                        do\n                          output[_out++] = output[from++], output[_out++] = output[from++], output[_out++] = output[from++], len -= 3;\n                        while (len > 2);\n                        if (len) {\n                          if (output[_out++] = output[from++], len > 1)\n                            output[_out++] = output[from++];\n                        }\n                      }\n                    } else if ((op & 64) === 0) {\n                      here = dcode[(here & 65535) + (hold & (1 << op) - 1)];\n                      continue dodist;\n                    } else {\n                      strm.msg = \"invalid distance code\", state.mode = BAD;\n                      break top;\n                    }\n                    break;\n                  }\n              } else if ((op & 64) === 0) {\n                here = lcode[(here & 65535) + (hold & (1 << op) - 1)];\n                continue dolen;\n              } else if (op & 32) {\n                state.mode = TYPE;\n                break top;\n              } else {\n                strm.msg = \"invalid literal/length code\", state.mode = BAD;\n                break top;\n              }\n              break;\n            }\n        } while (_in < last && _out < end);\n      len = bits >> 3, _in -= len, bits -= len << 3, hold &= (1 << bits) - 1, strm.next_in = _in, strm.next_out = _out, strm.avail_in = _in < last \? 5 + (last - _in) : 5 - (_in - last), strm.avail_out = _out < end \? 257 + (end - _out) : 257 - (_out - end), state.hold = hold, state.bits = bits;\n      return;\n    };\n  }\n}), require_inftrees = __commonJS({\n  \"node_modules/pako/lib/zlib/inftrees.js\"(exports, module2) {\n    var utils = require_common(), MAXBITS = 15, ENOUGH_LENS = 852, ENOUGH_DISTS = 592, CODES = 0, LENS = 1, DISTS = 2, lbase = [\n      3,\n      4,\n      5,\n      6,\n      7,\n      8,\n      9,\n      10,\n      11,\n      13,\n      15,\n      17,\n      19,\n      23,\n      27,\n      31,\n      35,\n      43,\n      51,\n      59,\n      67,\n      83,\n      99,\n      115,\n      131,\n      163,\n      195,\n      227,\n      258,\n      0,\n      0\n    ], lext = [\n      16,\n      16,\n      16,\n      16,\n      16,\n      16,\n      16,\n      16,\n      17,\n      17,\n      17,\n      17,\n      18,\n      18,\n      18,\n      18,\n      19,\n      19,\n      19,\n      19,\n      20,\n      20,\n      20,\n      20,\n      21,\n      21,\n      21,\n      21,\n      16,\n      72,\n      78\n    ], dbase = [\n      1,\n      2,\n      3,\n      4,\n      5,\n      7,\n      9,\n      13,\n      17,\n      25,\n      33,\n      49,\n      65,\n      97,\n      129,\n      193,\n      257,\n      385,\n      513,\n      769,\n      1025,\n      1537,\n      2049,\n      3073,\n      4097,\n      6145,\n      8193,\n      12289,\n      16385,\n      24577,\n      0,\n      0\n    ], dext = [\n      16,\n      16,\n      16,\n      16,\n      17,\n      17,\n      18,\n      18,\n      19,\n      19,\n      20,\n      20,\n      21,\n      21,\n      22,\n      22,\n      23,\n      23,\n      24,\n      24,\n      25,\n      25,\n      26,\n      26,\n      27,\n      27,\n      28,\n      28,\n      29,\n      29,\n      64,\n      64\n    ];\n    module2.exports = function inflate_table(type, lens, lens_index, codes, table, table_index, work, opts) {\n      var bits = opts.bits, len = 0, sym = 0, min = 0, max = 0, root = 0, curr = 0, drop = 0, left = 0, used = 0, huff = 0, incr, fill, low, mask, next, base = null, base_index = 0, end, count = new utils.Buf16(MAXBITS + 1), offs = new utils.Buf16(MAXBITS + 1), extra = null, extra_index = 0, here_bits, here_op, here_val;\n      for (len = 0;len <= MAXBITS; len++)\n        count[len] = 0;\n      for (sym = 0;sym < codes; sym++)\n        count[lens[lens_index + sym]]++;\n      root = bits;\n      for (max = MAXBITS;max >= 1; max--)\n        if (count[max] !== 0)\n          break;\n      if (root > max)\n        root = max;\n      if (max === 0)\n        return table[table_index++] = 1 << 24 | 64 << 16 | 0, table[table_index++] = 1 << 24 | 64 << 16 | 0, opts.bits = 1, 0;\n      for (min = 1;min < max; min++)\n        if (count[min] !== 0)\n          break;\n      if (root < min)\n        root = min;\n      left = 1;\n      for (len = 1;len <= MAXBITS; len++)\n        if (left <<= 1, left -= count[len], left < 0)\n          return -1;\n      if (left > 0 && (type === CODES || max !== 1))\n        return -1;\n      offs[1] = 0;\n      for (len = 1;len < MAXBITS; len++)\n        offs[len + 1] = offs[len] + count[len];\n      for (sym = 0;sym < codes; sym++)\n        if (lens[lens_index + sym] !== 0)\n          work[offs[lens[lens_index + sym]]++] = sym;\n      if (type === CODES)\n        base = extra = work, end = 19;\n      else if (type === LENS)\n        base = lbase, base_index -= 257, extra = lext, extra_index -= 257, end = 256;\n      else\n        base = dbase, extra = dext, end = -1;\n      if (huff = 0, sym = 0, len = min, next = table_index, curr = root, drop = 0, low = -1, used = 1 << root, mask = used - 1, type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS)\n        return 1;\n      for (;; ) {\n        if (here_bits = len - drop, work[sym] < end)\n          here_op = 0, here_val = work[sym];\n        else if (work[sym] > end)\n          here_op = extra[extra_index + work[sym]], here_val = base[base_index + work[sym]];\n        else\n          here_op = 96, here_val = 0;\n        incr = 1 << len - drop, fill = 1 << curr, min = fill;\n        do\n          fill -= incr, table[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;\n        while (fill !== 0);\n        incr = 1 << len - 1;\n        while (huff & incr)\n          incr >>= 1;\n        if (incr !== 0)\n          huff &= incr - 1, huff += incr;\n        else\n          huff = 0;\n        if (sym++, --count[len] === 0) {\n          if (len === max)\n            break;\n          len = lens[lens_index + work[sym]];\n        }\n        if (len > root && (huff & mask) !== low) {\n          if (drop === 0)\n            drop = root;\n          next += min, curr = len - drop, left = 1 << curr;\n          while (curr + drop < max) {\n            if (left -= count[curr + drop], left <= 0)\n              break;\n            curr++, left <<= 1;\n          }\n          if (used += 1 << curr, type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS)\n            return 1;\n          low = huff & mask, table[low] = root << 24 | curr << 16 | next - table_index | 0;\n        }\n      }\n      if (huff !== 0)\n        table[next + huff] = len - drop << 24 | 64 << 16 | 0;\n      return opts.bits = root, 0;\n    };\n  }\n}), require_inflate = __commonJS({\n  \"node_modules/pako/lib/zlib/inflate.js\"(exports) {\n    var utils = require_common(), adler32 = require_adler32(), crc32 = require_crc32(), inflate_fast = require_inffast(), inflate_table = require_inftrees(), CODES = 0, LENS = 1, DISTS = 2, Z_FINISH = 4, Z_BLOCK = 5, Z_TREES = 6, Z_OK = 0, Z_STREAM_END = 1, Z_NEED_DICT = 2, Z_STREAM_ERROR = -2, Z_DATA_ERROR = -3, Z_MEM_ERROR = -4, Z_BUF_ERROR = -5, Z_DEFLATED = 8, HEAD = 1, FLAGS = 2, TIME = 3, OS = 4, EXLEN = 5, EXTRA = 6, NAME = 7, COMMENT = 8, HCRC = 9, DICTID = 10, DICT = 11, TYPE = 12, TYPEDO = 13, STORED = 14, COPY_ = 15, COPY = 16, TABLE = 17, LENLENS = 18, CODELENS = 19, LEN_ = 20, LEN = 21, LENEXT = 22, DIST = 23, DISTEXT = 24, MATCH = 25, LIT = 26, CHECK = 27, LENGTH = 28, DONE = 29, BAD = 30, MEM = 31, SYNC = 32, ENOUGH_LENS = 852, ENOUGH_DISTS = 592, MAX_WBITS = 15, DEF_WBITS = MAX_WBITS;\n    function zswap32(q) {\n      return (q >>> 24 & 255) + (q >>> 8 & 65280) + ((q & 65280) << 8) + ((q & 255) << 24);\n    }\n    function InflateState() {\n      this.mode = 0, this.last = !1, this.wrap = 0, this.havedict = !1, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new utils.Buf16(320), this.work = new utils.Buf16(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;\n    }\n    function inflateResetKeep(strm) {\n      var state;\n      if (!strm || !strm.state)\n        return Z_STREAM_ERROR;\n      if (state = strm.state, strm.total_in = strm.total_out = state.total = 0, strm.msg = \"\", state.wrap)\n        strm.adler = state.wrap & 1;\n      return state.mode = HEAD, state.last = 0, state.havedict = 0, state.dmax = 32768, state.head = null, state.hold = 0, state.bits = 0, state.lencode = state.lendyn = new utils.Buf32(ENOUGH_LENS), state.distcode = state.distdyn = new utils.Buf32(ENOUGH_DISTS), state.sane = 1, state.back = -1, Z_OK;\n    }\n    function inflateReset(strm) {\n      var state;\n      if (!strm || !strm.state)\n        return Z_STREAM_ERROR;\n      return state = strm.state, state.wsize = 0, state.whave = 0, state.wnext = 0, inflateResetKeep(strm);\n    }\n    function inflateReset2(strm, windowBits) {\n      var wrap, state;\n      if (!strm || !strm.state)\n        return Z_STREAM_ERROR;\n      if (state = strm.state, windowBits < 0)\n        wrap = 0, windowBits = -windowBits;\n      else if (wrap = (windowBits >> 4) + 1, windowBits < 48)\n        windowBits &= 15;\n      if (windowBits && (windowBits < 8 || windowBits > 15))\n        return Z_STREAM_ERROR;\n      if (state.window !== null && state.wbits !== windowBits)\n        state.window = null;\n      return state.wrap = wrap, state.wbits = windowBits, inflateReset(strm);\n    }\n    function inflateInit2(strm, windowBits) {\n      var ret, state;\n      if (!strm)\n        return Z_STREAM_ERROR;\n      if (state = new InflateState, strm.state = state, state.window = null, ret = inflateReset2(strm, windowBits), ret !== Z_OK)\n        strm.state = null;\n      return ret;\n    }\n    function inflateInit(strm) {\n      return inflateInit2(strm, DEF_WBITS);\n    }\n    var virgin = !0, lenfix, distfix;\n    function fixedtables(state) {\n      if (virgin) {\n        var sym;\n        lenfix = new utils.Buf32(512), distfix = new utils.Buf32(32), sym = 0;\n        while (sym < 144)\n          state.lens[sym++] = 8;\n        while (sym < 256)\n          state.lens[sym++] = 9;\n        while (sym < 280)\n          state.lens[sym++] = 7;\n        while (sym < 288)\n          state.lens[sym++] = 8;\n        inflate_table(LENS, state.lens, 0, 288, lenfix, 0, state.work, {\n          bits: 9\n        }), sym = 0;\n        while (sym < 32)\n          state.lens[sym++] = 5;\n        inflate_table(DISTS, state.lens, 0, 32, distfix, 0, state.work, {\n          bits: 5\n        }), virgin = !1;\n      }\n      state.lencode = lenfix, state.lenbits = 9, state.distcode = distfix, state.distbits = 5;\n    }\n    function updatewindow(strm, src, end, copy) {\n      var dist, state = strm.state;\n      if (state.window === null)\n        state.wsize = 1 << state.wbits, state.wnext = 0, state.whave = 0, state.window = new utils.Buf8(state.wsize);\n      if (copy >= state.wsize)\n        utils.arraySet(state.window, src, end - state.wsize, state.wsize, 0), state.wnext = 0, state.whave = state.wsize;\n      else {\n        if (dist = state.wsize - state.wnext, dist > copy)\n          dist = copy;\n        if (utils.arraySet(state.window, src, end - copy, dist, state.wnext), copy -= dist, copy)\n          utils.arraySet(state.window, src, end - copy, copy, 0), state.wnext = copy, state.whave = state.wsize;\n        else {\n          if (state.wnext += dist, state.wnext === state.wsize)\n            state.wnext = 0;\n          if (state.whave < state.wsize)\n            state.whave += dist;\n        }\n      }\n      return 0;\n    }\n    function inflate(strm, flush) {\n      var state, input, output, next, put, have, left, hold, bits, _in, _out, copy, from, from_source, here = 0, here_bits, here_op, here_val, last_bits, last_op, last_val, len, ret, hbuf = new utils.Buf8(4), opts, n, order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];\n      if (!strm || !strm.state || !strm.output || !strm.input && strm.avail_in !== 0)\n        return Z_STREAM_ERROR;\n      if (state = strm.state, state.mode === TYPE)\n        state.mode = TYPEDO;\n      put = strm.next_out, output = strm.output, left = strm.avail_out, next = strm.next_in, input = strm.input, have = strm.avail_in, hold = state.hold, bits = state.bits, _in = have, _out = left, ret = Z_OK;\n      inf_leave:\n        for (;; )\n          switch (state.mode) {\n            case HEAD:\n              if (state.wrap === 0) {\n                state.mode = TYPEDO;\n                break;\n              }\n              while (bits < 16) {\n                if (have === 0)\n                  break inf_leave;\n                have--, hold += input[next++] << bits, bits += 8;\n              }\n              if (state.wrap & 2 && hold === 35615) {\n                state.check = 0, hbuf[0] = hold & 255, hbuf[1] = hold >>> 8 & 255, state.check = crc32(state.check, hbuf, 2, 0), hold = 0, bits = 0, state.mode = FLAGS;\n                break;\n              }\n              if (state.flags = 0, state.head)\n                state.head.done = !1;\n              if (!(state.wrap & 1) || (((hold & 255) << 8) + (hold >> 8)) % 31) {\n                strm.msg = \"incorrect header check\", state.mode = BAD;\n                break;\n              }\n              if ((hold & 15) !== Z_DEFLATED) {\n                strm.msg = \"unknown compression method\", state.mode = BAD;\n                break;\n              }\n              if (hold >>>= 4, bits -= 4, len = (hold & 15) + 8, state.wbits === 0)\n                state.wbits = len;\n              else if (len > state.wbits) {\n                strm.msg = \"invalid window size\", state.mode = BAD;\n                break;\n              }\n              state.dmax = 1 << len, strm.adler = state.check = 1, state.mode = hold & 512 \? DICTID : TYPE, hold = 0, bits = 0;\n              break;\n            case FLAGS:\n              while (bits < 16) {\n                if (have === 0)\n                  break inf_leave;\n                have--, hold += input[next++] << bits, bits += 8;\n              }\n              if (state.flags = hold, (state.flags & 255) !== Z_DEFLATED) {\n                strm.msg = \"unknown compression method\", state.mode = BAD;\n                break;\n              }\n              if (state.flags & 57344) {\n                strm.msg = \"unknown header flags set\", state.mode = BAD;\n                break;\n              }\n              if (state.head)\n                state.head.text = hold >> 8 & 1;\n              if (state.flags & 512)\n                hbuf[0] = hold & 255, hbuf[1] = hold >>> 8 & 255, state.check = crc32(state.check, hbuf, 2, 0);\n              hold = 0, bits = 0, state.mode = TIME;\n            case TIME:\n              while (bits < 32) {\n                if (have === 0)\n                  break inf_leave;\n                have--, hold += input[next++] << bits, bits += 8;\n              }\n              if (state.head)\n                state.head.time = hold;\n              if (state.flags & 512)\n                hbuf[0] = hold & 255, hbuf[1] = hold >>> 8 & 255, hbuf[2] = hold >>> 16 & 255, hbuf[3] = hold >>> 24 & 255, state.check = crc32(state.check, hbuf, 4, 0);\n              hold = 0, bits = 0, state.mode = OS;\n            case OS:\n              while (bits < 16) {\n                if (have === 0)\n                  break inf_leave;\n                have--, hold += input[next++] << bits, bits += 8;\n              }\n              if (state.head)\n                state.head.xflags = hold & 255, state.head.os = hold >> 8;\n              if (state.flags & 512)\n                hbuf[0] = hold & 255, hbuf[1] = hold >>> 8 & 255, state.check = crc32(state.check, hbuf, 2, 0);\n              hold = 0, bits = 0, state.mode = EXLEN;\n            case EXLEN:\n              if (state.flags & 1024) {\n                while (bits < 16) {\n                  if (have === 0)\n                    break inf_leave;\n                  have--, hold += input[next++] << bits, bits += 8;\n                }\n                if (state.length = hold, state.head)\n                  state.head.extra_len = hold;\n                if (state.flags & 512)\n                  hbuf[0] = hold & 255, hbuf[1] = hold >>> 8 & 255, state.check = crc32(state.check, hbuf, 2, 0);\n                hold = 0, bits = 0;\n              } else if (state.head)\n                state.head.extra = null;\n              state.mode = EXTRA;\n            case EXTRA:\n              if (state.flags & 1024) {\n                if (copy = state.length, copy > have)\n                  copy = have;\n                if (copy) {\n                  if (state.head) {\n                    if (len = state.head.extra_len - state.length, !state.head.extra)\n                      state.head.extra = new Array(state.head.extra_len);\n                    utils.arraySet(state.head.extra, input, next, copy, len);\n                  }\n                  if (state.flags & 512)\n                    state.check = crc32(state.check, input, copy, next);\n                  have -= copy, next += copy, state.length -= copy;\n                }\n                if (state.length)\n                  break inf_leave;\n              }\n              state.length = 0, state.mode = NAME;\n            case NAME:\n              if (state.flags & 2048) {\n                if (have === 0)\n                  break inf_leave;\n                copy = 0;\n                do\n                  if (len = input[next + copy++], state.head && len && state.length < 65536)\n                    state.head.name += String.fromCharCode(len);\n                while (len && copy < have);\n                if (state.flags & 512)\n                  state.check = crc32(state.check, input, copy, next);\n                if (have -= copy, next += copy, len)\n                  break inf_leave;\n              } else if (state.head)\n                state.head.name = null;\n              state.length = 0, state.mode = COMMENT;\n            case COMMENT:\n              if (state.flags & 4096) {\n                if (have === 0)\n                  break inf_leave;\n                copy = 0;\n                do\n                  if (len = input[next + copy++], state.head && len && state.length < 65536)\n                    state.head.comment += String.fromCharCode(len);\n                while (len && copy < have);\n                if (state.flags & 512)\n                  state.check = crc32(state.check, input, copy, next);\n                if (have -= copy, next += copy, len)\n                  break inf_leave;\n              } else if (state.head)\n                state.head.comment = null;\n              state.mode = HCRC;\n            case HCRC:\n              if (state.flags & 512) {\n                while (bits < 16) {\n                  if (have === 0)\n                    break inf_leave;\n                  have--, hold += input[next++] << bits, bits += 8;\n                }\n                if (hold !== (state.check & 65535)) {\n                  strm.msg = \"header crc mismatch\", state.mode = BAD;\n                  break;\n                }\n                hold = 0, bits = 0;\n              }\n              if (state.head)\n                state.head.hcrc = state.flags >> 9 & 1, state.head.done = !0;\n              strm.adler = state.check = 0, state.mode = TYPE;\n              break;\n            case DICTID:\n              while (bits < 32) {\n                if (have === 0)\n                  break inf_leave;\n                have--, hold += input[next++] << bits, bits += 8;\n              }\n              strm.adler = state.check = zswap32(hold), hold = 0, bits = 0, state.mode = DICT;\n            case DICT:\n              if (state.havedict === 0)\n                return strm.next_out = put, strm.avail_out = left, strm.next_in = next, strm.avail_in = have, state.hold = hold, state.bits = bits, Z_NEED_DICT;\n              strm.adler = state.check = 1, state.mode = TYPE;\n            case TYPE:\n              if (flush === Z_BLOCK || flush === Z_TREES)\n                break inf_leave;\n            case TYPEDO:\n              if (state.last) {\n                hold >>>= bits & 7, bits -= bits & 7, state.mode = CHECK;\n                break;\n              }\n              while (bits < 3) {\n                if (have === 0)\n                  break inf_leave;\n                have--, hold += input[next++] << bits, bits += 8;\n              }\n              switch (state.last = hold & 1, hold >>>= 1, bits -= 1, hold & 3) {\n                case 0:\n                  state.mode = STORED;\n                  break;\n                case 1:\n                  if (fixedtables(state), state.mode = LEN_, flush === Z_TREES) {\n                    hold >>>= 2, bits -= 2;\n                    break inf_leave;\n                  }\n                  break;\n                case 2:\n                  state.mode = TABLE;\n                  break;\n                case 3:\n                  strm.msg = \"invalid block type\", state.mode = BAD;\n              }\n              hold >>>= 2, bits -= 2;\n              break;\n            case STORED:\n              hold >>>= bits & 7, bits -= bits & 7;\n              while (bits < 32) {\n                if (have === 0)\n                  break inf_leave;\n                have--, hold += input[next++] << bits, bits += 8;\n              }\n              if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {\n                strm.msg = \"invalid stored block lengths\", state.mode = BAD;\n                break;\n              }\n              if (state.length = hold & 65535, hold = 0, bits = 0, state.mode = COPY_, flush === Z_TREES)\n                break inf_leave;\n            case COPY_:\n              state.mode = COPY;\n            case COPY:\n              if (copy = state.length, copy) {\n                if (copy > have)\n                  copy = have;\n                if (copy > left)\n                  copy = left;\n                if (copy === 0)\n                  break inf_leave;\n                utils.arraySet(output, input, next, copy, put), have -= copy, next += copy, left -= copy, put += copy, state.length -= copy;\n                break;\n              }\n              state.mode = TYPE;\n              break;\n            case TABLE:\n              while (bits < 14) {\n                if (have === 0)\n                  break inf_leave;\n                have--, hold += input[next++] << bits, bits += 8;\n              }\n              if (state.nlen = (hold & 31) + 257, hold >>>= 5, bits -= 5, state.ndist = (hold & 31) + 1, hold >>>= 5, bits -= 5, state.ncode = (hold & 15) + 4, hold >>>= 4, bits -= 4, state.nlen > 286 || state.ndist > 30) {\n                strm.msg = \"too many length or distance symbols\", state.mode = BAD;\n                break;\n              }\n              state.have = 0, state.mode = LENLENS;\n            case LENLENS:\n              while (state.have < state.ncode) {\n                while (bits < 3) {\n                  if (have === 0)\n                    break inf_leave;\n                  have--, hold += input[next++] << bits, bits += 8;\n                }\n                state.lens[order[state.have++]] = hold & 7, hold >>>= 3, bits -= 3;\n              }\n              while (state.have < 19)\n                state.lens[order[state.have++]] = 0;\n              if (state.lencode = state.lendyn, state.lenbits = 7, opts = { bits: state.lenbits }, ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts), state.lenbits = opts.bits, ret) {\n                strm.msg = \"invalid code lengths set\", state.mode = BAD;\n                break;\n              }\n              state.have = 0, state.mode = CODELENS;\n            case CODELENS:\n              while (state.have < state.nlen + state.ndist) {\n                for (;; ) {\n                  if (here = state.lencode[hold & (1 << state.lenbits) - 1], here_bits = here >>> 24, here_op = here >>> 16 & 255, here_val = here & 65535, here_bits <= bits)\n                    break;\n                  if (have === 0)\n                    break inf_leave;\n                  have--, hold += input[next++] << bits, bits += 8;\n                }\n                if (here_val < 16)\n                  hold >>>= here_bits, bits -= here_bits, state.lens[state.have++] = here_val;\n                else {\n                  if (here_val === 16) {\n                    n = here_bits + 2;\n                    while (bits < n) {\n                      if (have === 0)\n                        break inf_leave;\n                      have--, hold += input[next++] << bits, bits += 8;\n                    }\n                    if (hold >>>= here_bits, bits -= here_bits, state.have === 0) {\n                      strm.msg = \"invalid bit length repeat\", state.mode = BAD;\n                      break;\n                    }\n                    len = state.lens[state.have - 1], copy = 3 + (hold & 3), hold >>>= 2, bits -= 2;\n                  } else if (here_val === 17) {\n                    n = here_bits + 3;\n                    while (bits < n) {\n                      if (have === 0)\n                        break inf_leave;\n                      have--, hold += input[next++] << bits, bits += 8;\n                    }\n                    hold >>>= here_bits, bits -= here_bits, len = 0, copy = 3 + (hold & 7), hold >>>= 3, bits -= 3;\n                  } else {\n                    n = here_bits + 7;\n                    while (bits < n) {\n                      if (have === 0)\n                        break inf_leave;\n                      have--, hold += input[next++] << bits, bits += 8;\n                    }\n                    hold >>>= here_bits, bits -= here_bits, len = 0, copy = 11 + (hold & 127), hold >>>= 7, bits -= 7;\n                  }\n                  if (state.have + copy > state.nlen + state.ndist) {\n                    strm.msg = \"invalid bit length repeat\", state.mode = BAD;\n                    break;\n                  }\n                  while (copy--)\n                    state.lens[state.have++] = len;\n                }\n              }\n              if (state.mode === BAD)\n                break;\n              if (state.lens[256] === 0) {\n                strm.msg = \"invalid code -- missing end-of-block\", state.mode = BAD;\n                break;\n              }\n              if (state.lenbits = 9, opts = { bits: state.lenbits }, ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts), state.lenbits = opts.bits, ret) {\n                strm.msg = \"invalid literal/lengths set\", state.mode = BAD;\n                break;\n              }\n              if (state.distbits = 6, state.distcode = state.distdyn, opts = { bits: state.distbits }, ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts), state.distbits = opts.bits, ret) {\n                strm.msg = \"invalid distances set\", state.mode = BAD;\n                break;\n              }\n              if (state.mode = LEN_, flush === Z_TREES)\n                break inf_leave;\n            case LEN_:\n              state.mode = LEN;\n            case LEN:\n              if (have >= 6 && left >= 258) {\n                if (strm.next_out = put, strm.avail_out = left, strm.next_in = next, strm.avail_in = have, state.hold = hold, state.bits = bits, inflate_fast(strm, _out), put = strm.next_out, output = strm.output, left = strm.avail_out, next = strm.next_in, input = strm.input, have = strm.avail_in, hold = state.hold, bits = state.bits, state.mode === TYPE)\n                  state.back = -1;\n                break;\n              }\n              state.back = 0;\n              for (;; ) {\n                if (here = state.lencode[hold & (1 << state.lenbits) - 1], here_bits = here >>> 24, here_op = here >>> 16 & 255, here_val = here & 65535, here_bits <= bits)\n                  break;\n                if (have === 0)\n                  break inf_leave;\n                have--, hold += input[next++] << bits, bits += 8;\n              }\n              if (here_op && (here_op & 240) === 0) {\n                last_bits = here_bits, last_op = here_op, last_val = here_val;\n                for (;; ) {\n                  if (here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)], here_bits = here >>> 24, here_op = here >>> 16 & 255, here_val = here & 65535, last_bits + here_bits <= bits)\n                    break;\n                  if (have === 0)\n                    break inf_leave;\n                  have--, hold += input[next++] << bits, bits += 8;\n                }\n                hold >>>= last_bits, bits -= last_bits, state.back += last_bits;\n              }\n              if (hold >>>= here_bits, bits -= here_bits, state.back += here_bits, state.length = here_val, here_op === 0) {\n                state.mode = LIT;\n                break;\n              }\n              if (here_op & 32) {\n                state.back = -1, state.mode = TYPE;\n                break;\n              }\n              if (here_op & 64) {\n                strm.msg = \"invalid literal/length code\", state.mode = BAD;\n                break;\n              }\n              state.extra = here_op & 15, state.mode = LENEXT;\n            case LENEXT:\n              if (state.extra) {\n                n = state.extra;\n                while (bits < n) {\n                  if (have === 0)\n                    break inf_leave;\n                  have--, hold += input[next++] << bits, bits += 8;\n                }\n                state.length += hold & (1 << state.extra) - 1, hold >>>= state.extra, bits -= state.extra, state.back += state.extra;\n              }\n              state.was = state.length, state.mode = DIST;\n            case DIST:\n              for (;; ) {\n                if (here = state.distcode[hold & (1 << state.distbits) - 1], here_bits = here >>> 24, here_op = here >>> 16 & 255, here_val = here & 65535, here_bits <= bits)\n                  break;\n                if (have === 0)\n                  break inf_leave;\n                have--, hold += input[next++] << bits, bits += 8;\n              }\n              if ((here_op & 240) === 0) {\n                last_bits = here_bits, last_op = here_op, last_val = here_val;\n                for (;; ) {\n                  if (here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)], here_bits = here >>> 24, here_op = here >>> 16 & 255, here_val = here & 65535, last_bits + here_bits <= bits)\n                    break;\n                  if (have === 0)\n                    break inf_leave;\n                  have--, hold += input[next++] << bits, bits += 8;\n                }\n                hold >>>= last_bits, bits -= last_bits, state.back += last_bits;\n              }\n              if (hold >>>= here_bits, bits -= here_bits, state.back += here_bits, here_op & 64) {\n                strm.msg = \"invalid distance code\", state.mode = BAD;\n                break;\n              }\n              state.offset = here_val, state.extra = here_op & 15, state.mode = DISTEXT;\n            case DISTEXT:\n              if (state.extra) {\n                n = state.extra;\n                while (bits < n) {\n                  if (have === 0)\n                    break inf_leave;\n                  have--, hold += input[next++] << bits, bits += 8;\n                }\n                state.offset += hold & (1 << state.extra) - 1, hold >>>= state.extra, bits -= state.extra, state.back += state.extra;\n              }\n              if (state.offset > state.dmax) {\n                strm.msg = \"invalid distance too far back\", state.mode = BAD;\n                break;\n              }\n              state.mode = MATCH;\n            case MATCH:\n              if (left === 0)\n                break inf_leave;\n              if (copy = _out - left, state.offset > copy) {\n                if (copy = state.offset - copy, copy > state.whave) {\n                  if (state.sane) {\n                    strm.msg = \"invalid distance too far back\", state.mode = BAD;\n                    break;\n                  }\n                }\n                if (copy > state.wnext)\n                  copy -= state.wnext, from = state.wsize - copy;\n                else\n                  from = state.wnext - copy;\n                if (copy > state.length)\n                  copy = state.length;\n                from_source = state.window;\n              } else\n                from_source = output, from = put - state.offset, copy = state.length;\n              if (copy > left)\n                copy = left;\n              left -= copy, state.length -= copy;\n              do\n                output[put++] = from_source[from++];\n              while (--copy);\n              if (state.length === 0)\n                state.mode = LEN;\n              break;\n            case LIT:\n              if (left === 0)\n                break inf_leave;\n              output[put++] = state.length, left--, state.mode = LEN;\n              break;\n            case CHECK:\n              if (state.wrap) {\n                while (bits < 32) {\n                  if (have === 0)\n                    break inf_leave;\n                  have--, hold |= input[next++] << bits, bits += 8;\n                }\n                if (_out -= left, strm.total_out += _out, state.total += _out, _out)\n                  strm.adler = state.check = state.flags \? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out);\n                if (_out = left, (state.flags \? hold : zswap32(hold)) !== state.check) {\n                  strm.msg = \"incorrect data check\", state.mode = BAD;\n                  break;\n                }\n                hold = 0, bits = 0;\n              }\n              state.mode = LENGTH;\n            case LENGTH:\n              if (state.wrap && state.flags) {\n                while (bits < 32) {\n                  if (have === 0)\n                    break inf_leave;\n                  have--, hold += input[next++] << bits, bits += 8;\n                }\n                if (hold !== (state.total & 4294967295)) {\n                  strm.msg = \"incorrect length check\", state.mode = BAD;\n                  break;\n                }\n                hold = 0, bits = 0;\n              }\n              state.mode = DONE;\n            case DONE:\n              ret = Z_STREAM_END;\n              break inf_leave;\n            case BAD:\n              ret = Z_DATA_ERROR;\n              break inf_leave;\n            case MEM:\n              return Z_MEM_ERROR;\n            case SYNC:\n            default:\n              return Z_STREAM_ERROR;\n          }\n      if (strm.next_out = put, strm.avail_out = left, strm.next_in = next, strm.avail_in = have, state.hold = hold, state.bits = bits, state.wsize || _out !== strm.avail_out && state.mode < BAD && (state.mode < CHECK || flush !== Z_FINISH)) {\n        if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out))\n          return state.mode = MEM, Z_MEM_ERROR;\n      }\n      if (_in -= strm.avail_in, _out -= strm.avail_out, strm.total_in += _in, strm.total_out += _out, state.total += _out, state.wrap && _out)\n        strm.adler = state.check = state.flags \? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out);\n      if (strm.data_type = state.bits + (state.last \? 64 : 0) + (state.mode === TYPE \? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ \? 256 : 0), (_in === 0 && _out === 0 || flush === Z_FINISH) && ret === Z_OK)\n        ret = Z_BUF_ERROR;\n      return ret;\n    }\n    function inflateEnd(strm) {\n      if (!strm || !strm.state)\n        return Z_STREAM_ERROR;\n      var state = strm.state;\n      if (state.window)\n        state.window = null;\n      return strm.state = null, Z_OK;\n    }\n    function inflateGetHeader(strm, head) {\n      var state;\n      if (!strm || !strm.state)\n        return Z_STREAM_ERROR;\n      if (state = strm.state, (state.wrap & 2) === 0)\n        return Z_STREAM_ERROR;\n      return state.head = head, head.done = !1, Z_OK;\n    }\n    function inflateSetDictionary(strm, dictionary) {\n      var dictLength = dictionary.length, state, dictid, ret;\n      if (!strm || !strm.state)\n        return Z_STREAM_ERROR;\n      if (state = strm.state, state.wrap !== 0 && state.mode !== DICT)\n        return Z_STREAM_ERROR;\n      if (state.mode === DICT) {\n        if (dictid = 1, dictid = adler32(dictid, dictionary, dictLength, 0), dictid !== state.check)\n          return Z_DATA_ERROR;\n      }\n      if (ret = updatewindow(strm, dictionary, dictLength, dictLength), ret)\n        return state.mode = MEM, Z_MEM_ERROR;\n      return state.havedict = 1, Z_OK;\n    }\n    exports.inflateReset = inflateReset, exports.inflateReset2 = inflateReset2, exports.inflateResetKeep = inflateResetKeep, exports.inflateInit = inflateInit, exports.inflateInit2 = inflateInit2, exports.inflate = inflate, exports.inflateEnd = inflateEnd, exports.inflateGetHeader = inflateGetHeader, exports.inflateSetDictionary = inflateSetDictionary, exports.inflateInfo = \"pako inflate (from Nodeca project)\";\n  }\n}), require_constants = __commonJS({\n  \"node_modules/pako/lib/zlib/constants.js\"(exports, module2) {\n    module2.exports = {\n      Z_NO_FLUSH: 0,\n      Z_PARTIAL_FLUSH: 1,\n      Z_SYNC_FLUSH: 2,\n      Z_FULL_FLUSH: 3,\n      Z_FINISH: 4,\n      Z_BLOCK: 5,\n      Z_TREES: 6,\n      Z_OK: 0,\n      Z_STREAM_END: 1,\n      Z_NEED_DICT: 2,\n      Z_ERRNO: -1,\n      Z_STREAM_ERROR: -2,\n      Z_DATA_ERROR: -3,\n      Z_BUF_ERROR: -5,\n      Z_NO_COMPRESSION: 0,\n      Z_BEST_SPEED: 1,\n      Z_BEST_COMPRESSION: 9,\n      Z_DEFAULT_COMPRESSION: -1,\n      Z_FILTERED: 1,\n      Z_HUFFMAN_ONLY: 2,\n      Z_RLE: 3,\n      Z_FIXED: 4,\n      Z_DEFAULT_STRATEGY: 0,\n      Z_BINARY: 0,\n      Z_TEXT: 1,\n      Z_UNKNOWN: 2,\n      Z_DEFLATED: 8\n    };\n  }\n}), require_binding = __commonJS({\n  \"node_modules/browserify-zlib/lib/binding.js\"(exports) {\n    var Zstream = require_zstream(), zlib_deflate = require_deflate(), zlib_inflate = require_inflate(), constants = require_constants();\n    for (key in constants)\n      exports[key] = constants[key];\n    var key;\n    exports.NONE = 0, exports.DEFLATE = 1, exports.INFLATE = 2, exports.GZIP = 3, exports.GUNZIP = 4, exports.DEFLATERAW = 5, exports.INFLATERAW = 6, exports.UNZIP = 7;\n    var GZIP_HEADER_ID1 = 31, GZIP_HEADER_ID2 = 139;\n    function Zlib(mode) {\n      if (typeof mode !== \"number\" || mode < exports.DEFLATE || mode > exports.UNZIP)\n        @throwTypeError(\"Bad argument\");\n      this.dictionary = null, this.err = 0, this.flush = 0, this.init_done = !1, this.level = 0, this.memLevel = 0, this.mode = mode, this.strategy = 0, this.windowBits = 0, this.write_in_progress = !1, this.pending_close = !1, this.gzip_id_bytes_read = 0;\n    }\n    Zlib.prototype = {}, Zlib.prototype.close = function() {\n      if (this.write_in_progress) {\n        this.pending_close = !0;\n        return;\n      }\n      if (this.pending_close = !1, assert(this.init_done, \"close before init\"), assert(this.mode <= exports.UNZIP), this.mode === exports.DEFLATE || this.mode === exports.GZIP || this.mode === exports.DEFLATERAW)\n        zlib_deflate.deflateEnd(this.strm);\n      else if (this.mode === exports.INFLATE || this.mode === exports.GUNZIP || this.mode === exports.INFLATERAW || this.mode === exports.UNZIP)\n        zlib_inflate.inflateEnd(this.strm);\n      this.mode = exports.NONE, this.dictionary = null;\n    }, Zlib.prototype.write = function(flush, input, in_off, in_len, out, out_off, out_len) {\n      return this._write(!0, flush, input, in_off, in_len, out, out_off, out_len);\n    }, Zlib.prototype.writeSync = function(flush, input, in_off, in_len, out, out_off, out_len) {\n      return this._write(!1, flush, input, in_off, in_len, out, out_off, out_len);\n    }, Zlib.prototype._write = function(async, flush, input, in_off, in_len, out, out_off, out_len) {\n      if (assert.equal(arguments.length, 8), assert(this.init_done, \"write before init\"), assert(this.mode !== exports.NONE, \"already finalized\"), assert.equal(!1, this.write_in_progress, \"write already in progress\"), assert.equal(!1, this.pending_close, \"close is pending\"), this.write_in_progress = !0, assert.equal(!1, flush === void 0, \"must provide flush value\"), this.write_in_progress = !0, flush !== exports.Z_NO_FLUSH && flush !== exports.Z_PARTIAL_FLUSH && flush !== exports.Z_SYNC_FLUSH && flush !== exports.Z_FULL_FLUSH && flush !== exports.Z_FINISH && flush !== exports.Z_BLOCK)\n        throw new Error(\"Invalid flush value\");\n      if (input == null)\n        input = Buffer.alloc(0), in_len = 0, in_off = 0;\n      if (this.strm.avail_in = in_len, this.strm.input = input, this.strm.next_in = in_off, this.strm.avail_out = out_len, this.strm.output = out, this.strm.next_out = out_off, this.flush = flush, !async) {\n        if (this._process(), this._checkError())\n          return this._afterSync();\n        return;\n      }\n      var self = this;\n      return process.nextTick(function() {\n        self._process(), self._after();\n      }), this;\n    }, Zlib.prototype._afterSync = function() {\n      var avail_out = this.strm.avail_out, avail_in = this.strm.avail_in;\n      return this.write_in_progress = !1, [avail_in, avail_out];\n    }, Zlib.prototype._process = function() {\n      var next_expected_header_byte = null;\n      switch (this.mode) {\n        case exports.DEFLATE:\n        case exports.GZIP:\n        case exports.DEFLATERAW:\n          this.err = zlib_deflate.deflate(this.strm, this.flush);\n          break;\n        case exports.UNZIP:\n          if (this.strm.avail_in > 0)\n            next_expected_header_byte = this.strm.next_in;\n          switch (this.gzip_id_bytes_read) {\n            case 0:\n              if (next_expected_header_byte === null)\n                break;\n              if (this.strm.input[next_expected_header_byte] === GZIP_HEADER_ID1) {\n                if (this.gzip_id_bytes_read = 1, next_expected_header_byte++, this.strm.avail_in === 1)\n                  break;\n              } else {\n                this.mode = exports.INFLATE;\n                break;\n              }\n            case 1:\n              if (next_expected_header_byte === null)\n                break;\n              if (this.strm.input[next_expected_header_byte] === GZIP_HEADER_ID2)\n                this.gzip_id_bytes_read = 2, this.mode = exports.GUNZIP;\n              else\n                this.mode = exports.INFLATE;\n              break;\n            default:\n              throw new Error(\"invalid number of gzip magic number bytes read\");\n          }\n        case exports.INFLATE:\n        case exports.GUNZIP:\n        case exports.INFLATERAW:\n          if (this.err = zlib_inflate.inflate(this.strm, this.flush), this.err === exports.Z_NEED_DICT && this.dictionary) {\n            if (this.err = zlib_inflate.inflateSetDictionary(this.strm, this.dictionary), this.err === exports.Z_OK)\n              this.err = zlib_inflate.inflate(this.strm, this.flush);\n            else if (this.err === exports.Z_DATA_ERROR)\n              this.err = exports.Z_NEED_DICT;\n          }\n          while (this.strm.avail_in > 0 && this.mode === exports.GUNZIP && this.err === exports.Z_STREAM_END && this.strm.next_in[0] !== 0)\n            this.reset(), this.err = zlib_inflate.inflate(this.strm, this.flush);\n          break;\n        default:\n          throw new Error(\"Unknown mode \" + this.mode);\n      }\n    }, Zlib.prototype._checkError = function() {\n      switch (this.err) {\n        case exports.Z_OK:\n        case exports.Z_BUF_ERROR:\n          if (this.strm.avail_out !== 0 && this.flush === exports.Z_FINISH)\n            return this._error(\"unexpected end of file\"), !1;\n          break;\n        case exports.Z_STREAM_END:\n          break;\n        case exports.Z_NEED_DICT:\n          if (this.dictionary == null)\n            this._error(\"Missing dictionary\");\n          else\n            this._error(\"Bad dictionary\");\n          return !1;\n        default:\n          return this._error(\"Zlib error\"), !1;\n      }\n      return !0;\n    }, Zlib.prototype._after = function() {\n      if (!this._checkError())\n        return;\n      var avail_out = this.strm.avail_out, avail_in = this.strm.avail_in;\n      if (this.write_in_progress = !1, this.callback(avail_in, avail_out), this.pending_close)\n        this.close();\n    }, Zlib.prototype._error = function(message) {\n      if (this.strm.msg)\n        message = this.strm.msg;\n      if (this.onerror(message, this.err), this.write_in_progress = !1, this.pending_close)\n        this.close();\n    }, Zlib.prototype.init = function(windowBits, level, memLevel, strategy, dictionary) {\n      assert(arguments.length === 4 || arguments.length === 5, \"init(windowBits, level, memLevel, strategy, [dictionary])\"), assert(windowBits >= 8 && windowBits <= 15, \"invalid windowBits\"), assert(level >= -1 && level <= 9, \"invalid compression level\"), assert(memLevel >= 1 && memLevel <= 9, \"invalid memlevel\"), assert(strategy === exports.Z_FILTERED || strategy === exports.Z_HUFFMAN_ONLY || strategy === exports.Z_RLE || strategy === exports.Z_FIXED || strategy === exports.Z_DEFAULT_STRATEGY, \"invalid strategy\"), this._init(level, windowBits, memLevel, strategy, dictionary), this._setDictionary();\n    }, Zlib.prototype.params = function() {\n      throw new Error(\"deflateParams Not supported\");\n    }, Zlib.prototype.reset = function() {\n      this._reset(), this._setDictionary();\n    }, Zlib.prototype._init = function(level, windowBits, memLevel, strategy, dictionary) {\n      if (this.level = level, this.windowBits = windowBits, this.memLevel = memLevel, this.strategy = strategy, this.flush = exports.Z_NO_FLUSH, this.err = exports.Z_OK, this.mode === exports.GZIP || this.mode === exports.GUNZIP)\n        this.windowBits += 16;\n      if (this.mode === exports.UNZIP)\n        this.windowBits += 32;\n      if (this.mode === exports.DEFLATERAW || this.mode === exports.INFLATERAW)\n        this.windowBits = -1 * this.windowBits;\n      switch (this.strm = new Zstream, this.mode) {\n        case exports.DEFLATE:\n        case exports.GZIP:\n        case exports.DEFLATERAW:\n          this.err = zlib_deflate.deflateInit2(this.strm, this.level, exports.Z_DEFLATED, this.windowBits, this.memLevel, this.strategy);\n          break;\n        case exports.INFLATE:\n        case exports.GUNZIP:\n        case exports.INFLATERAW:\n        case exports.UNZIP:\n          this.err = zlib_inflate.inflateInit2(this.strm, this.windowBits);\n          break;\n        default:\n          throw new Error(\"Unknown mode \" + this.mode);\n      }\n      if (this.err !== exports.Z_OK)\n        this._error(\"Init error\");\n      this.dictionary = dictionary, this.write_in_progress = !1, this.init_done = !0;\n    }, Zlib.prototype._setDictionary = function() {\n      if (this.dictionary == null)\n        return;\n      switch (this.err = exports.Z_OK, this.mode) {\n        case exports.DEFLATE:\n        case exports.DEFLATERAW:\n          this.err = zlib_deflate.deflateSetDictionary(this.strm, this.dictionary);\n          break;\n        default:\n          break;\n      }\n      if (this.err !== exports.Z_OK)\n        this._error(\"Failed to set dictionary\");\n    }, Zlib.prototype._reset = function() {\n      switch (this.err = exports.Z_OK, this.mode) {\n        case exports.DEFLATE:\n        case exports.DEFLATERAW:\n        case exports.GZIP:\n          this.err = zlib_deflate.deflateReset(this.strm);\n          break;\n        case exports.INFLATE:\n        case exports.INFLATERAW:\n        case exports.GUNZIP:\n          this.err = zlib_inflate.inflateReset(this.strm);\n          break;\n        default:\n          break;\n      }\n      if (this.err !== exports.Z_OK)\n        this._error(\"Failed to reset stream\");\n    }, exports.Zlib = Zlib;\n  }\n}), require_lib = __commonJS({\n  \"node_modules/browserify-zlib/lib/index.js\"(exports) {\n    var Buffer2 = BufferModule.Buffer, Transform = StreamModule.Transform, binding = require_binding(), util = Util, kMaxLength = BufferModule.kMaxLength, kRangeErrorMessage = \"Cannot create final Buffer. It would be larger than 0x\" + kMaxLength.toString(16) + \" bytes\";\n    binding.Z_MIN_WINDOWBITS = 8, binding.Z_MAX_WINDOWBITS = 15, binding.Z_DEFAULT_WINDOWBITS = 15, binding.Z_MIN_CHUNK = 64, binding.Z_MAX_CHUNK = Infinity, binding.Z_DEFAULT_CHUNK = 16384, binding.Z_MIN_MEMLEVEL = 1, binding.Z_MAX_MEMLEVEL = 9, binding.Z_DEFAULT_MEMLEVEL = 8, binding.Z_MIN_LEVEL = -1, binding.Z_MAX_LEVEL = 9, binding.Z_DEFAULT_LEVEL = binding.Z_DEFAULT_COMPRESSION;\n    var bkeys = Object.keys(binding);\n    for (bk = 0;bk < bkeys.length; bk++)\n      if (bkey = bkeys[bk], bkey.match(/^Z/))\n        Object.defineProperty(exports, bkey, {\n          enumerable: !0,\n          value: binding[bkey],\n          writable: !1\n        });\n    var bkey, bk, codes = {\n      Z_OK: binding.Z_OK,\n      Z_STREAM_END: binding.Z_STREAM_END,\n      Z_NEED_DICT: binding.Z_NEED_DICT,\n      Z_ERRNO: binding.Z_ERRNO,\n      Z_STREAM_ERROR: binding.Z_STREAM_ERROR,\n      Z_DATA_ERROR: binding.Z_DATA_ERROR,\n      Z_MEM_ERROR: binding.Z_MEM_ERROR,\n      Z_BUF_ERROR: binding.Z_BUF_ERROR,\n      Z_VERSION_ERROR: binding.Z_VERSION_ERROR\n    }, ckeys = Object.keys(codes);\n    for (ck = 0;ck < ckeys.length; ck++)\n      ckey = ckeys[ck], codes[codes[ckey]] = ckey;\n    var ckey, ck;\n    Object.defineProperty(exports, \"codes\", {\n      enumerable: !0,\n      value: Object.freeze(codes),\n      writable: !1\n    }), exports.constants = require_constants(), exports.Deflate = Deflate, exports.Inflate = Inflate, exports.Gzip = Gzip, exports.Gunzip = Gunzip, exports.DeflateRaw = DeflateRaw, exports.InflateRaw = InflateRaw, exports.Unzip = Unzip, exports.createDeflate = function(o) {\n      return new Deflate(o);\n    }, exports.createInflate = function(o) {\n      return new Inflate(o);\n    }, exports.createDeflateRaw = function(o) {\n      return new DeflateRaw(o);\n    }, exports.createInflateRaw = function(o) {\n      return new InflateRaw(o);\n    }, exports.createGzip = function(o) {\n      return new Gzip(o);\n    }, exports.createGunzip = function(o) {\n      return new Gunzip(o);\n    }, exports.createUnzip = function(o) {\n      return new Unzip(o);\n    }, exports.deflate = function(buffer, opts, callback) {\n      if (typeof opts === \"function\")\n        callback = opts, opts = {};\n      return zlibBuffer(new Deflate(opts), buffer, callback);\n    }, exports.deflateSync = function(buffer, opts) {\n      return zlibBufferSync(new Deflate(opts), buffer);\n    }, exports.gzip = function(buffer, opts, callback) {\n      if (typeof opts === \"function\")\n        callback = opts, opts = {};\n      return zlibBuffer(new Gzip(opts), buffer, callback);\n    }, exports.gzipSync = function(buffer, opts) {\n      return zlibBufferSync(new Gzip(opts), buffer);\n    }, exports.deflateRaw = function(buffer, opts, callback) {\n      if (typeof opts === \"function\")\n        callback = opts, opts = {};\n      return zlibBuffer(new DeflateRaw(opts), buffer, callback);\n    }, exports.deflateRawSync = function(buffer, opts) {\n      return zlibBufferSync(new DeflateRaw(opts), buffer);\n    }, exports.unzip = function(buffer, opts, callback) {\n      if (typeof opts === \"function\")\n        callback = opts, opts = {};\n      return zlibBuffer(new Unzip(opts), buffer, callback);\n    }, exports.unzipSync = function(buffer, opts) {\n      return zlibBufferSync(new Unzip(opts), buffer);\n    }, exports.inflate = function(buffer, opts, callback) {\n      if (typeof opts === \"function\")\n        callback = opts, opts = {};\n      return zlibBuffer(new Inflate(opts), buffer, callback);\n    }, exports.inflateSync = function(buffer, opts) {\n      return zlibBufferSync(new Inflate(opts), buffer);\n    }, exports.gunzip = function(buffer, opts, callback) {\n      if (typeof opts === \"function\")\n        callback = opts, opts = {};\n      return zlibBuffer(new Gunzip(opts), buffer, callback);\n    }, exports.gunzipSync = function(buffer, opts) {\n      return zlibBufferSync(new Gunzip(opts), buffer);\n    }, exports.inflateRaw = function(buffer, opts, callback) {\n      if (typeof opts === \"function\")\n        callback = opts, opts = {};\n      return zlibBuffer(new InflateRaw(opts), buffer, callback);\n    }, exports.inflateRawSync = function(buffer, opts) {\n      return zlibBufferSync(new InflateRaw(opts), buffer);\n    }, exports.brotliCompress = function(buffer, opts, callback) {\n      throw new Error(\"zlib.brotliCompress is not implemented\");\n    };\n    function zlibBuffer(engine, buffer, callback) {\n      var buffers = [], nread = 0;\n      engine.on(\"error\", onError), engine.on(\"end\", onEnd), engine.end(buffer), flow();\n      function flow() {\n        var chunk;\n        while ((chunk = engine.read()) !== null)\n          buffers.push(chunk), nread += chunk.length;\n        engine.once(\"readable\", flow);\n      }\n      function onError(err) {\n        engine.removeListener(\"end\", onEnd), engine.removeListener(\"readable\", flow), callback(err);\n      }\n      function onEnd() {\n        var buf, err = null;\n        if (nread >= kMaxLength)\n          err = new RangeError(kRangeErrorMessage);\n        else\n          buf = Buffer2.concat(buffers, nread);\n        buffers = [], engine.close(), callback(err, buf);\n      }\n    }\n    function zlibBufferSync(engine, buffer) {\n      if (typeof buffer === \"string\")\n        buffer = Buffer2.from(buffer);\n      if (!Buffer2.isBuffer(buffer))\n        @throwTypeError(\"Not a string or buffer\");\n      var flushFlag = engine._finishFlushFlag;\n      return engine._processChunk(buffer, flushFlag);\n    }\n    function Deflate(opts) {\n      if (!(this instanceof Deflate))\n        return new Deflate(opts);\n      Zlib.call(this, opts, binding.DEFLATE);\n    }\n    function Inflate(opts) {\n      if (!(this instanceof Inflate))\n        return new Inflate(opts);\n      Zlib.call(this, opts, binding.INFLATE);\n    }\n    function Gzip(opts) {\n      if (!(this instanceof Gzip))\n        return new Gzip(opts);\n      Zlib.call(this, opts, binding.GZIP);\n    }\n    function Gunzip(opts) {\n      if (!(this instanceof Gunzip))\n        return new Gunzip(opts);\n      Zlib.call(this, opts, binding.GUNZIP);\n    }\n    function DeflateRaw(opts) {\n      if (!(this instanceof DeflateRaw))\n        return new DeflateRaw(opts);\n      Zlib.call(this, opts, binding.DEFLATERAW);\n    }\n    function InflateRaw(opts) {\n      if (!(this instanceof InflateRaw))\n        return new InflateRaw(opts);\n      Zlib.call(this, opts, binding.INFLATERAW);\n    }\n    function Unzip(opts) {\n      if (!(this instanceof Unzip))\n        return new Unzip(opts);\n      Zlib.call(this, opts, binding.UNZIP);\n    }\n    function isValidFlushFlag(flag) {\n      return flag === binding.Z_NO_FLUSH || flag === binding.Z_PARTIAL_FLUSH || flag === binding.Z_SYNC_FLUSH || flag === binding.Z_FULL_FLUSH || flag === binding.Z_FINISH || flag === binding.Z_BLOCK;\n    }\n    function Zlib(opts, mode) {\n      var _this = this;\n      if (this._opts = opts = opts || {}, this._chunkSize = opts.chunkSize || exports.Z_DEFAULT_CHUNK, Transform.call(this, opts), opts.flush && !isValidFlushFlag(opts.flush))\n        throw new Error(\"Invalid flush flag: \" + opts.flush);\n      if (opts.finishFlush && !isValidFlushFlag(opts.finishFlush))\n        throw new Error(\"Invalid flush flag: \" + opts.finishFlush);\n      if (this._flushFlag = opts.flush || binding.Z_NO_FLUSH, this._finishFlushFlag = typeof opts.finishFlush !== \"undefined\" \? opts.finishFlush : binding.Z_FINISH, opts.chunkSize) {\n        if (opts.chunkSize < exports.Z_MIN_CHUNK || opts.chunkSize > exports.Z_MAX_CHUNK)\n          throw new Error(\"Invalid chunk size: \" + opts.chunkSize);\n      }\n      if (opts.windowBits) {\n        if (opts.windowBits < exports.Z_MIN_WINDOWBITS || opts.windowBits > exports.Z_MAX_WINDOWBITS)\n          throw new Error(\"Invalid windowBits: \" + opts.windowBits);\n      }\n      if (opts.level) {\n        if (opts.level < exports.Z_MIN_LEVEL || opts.level > exports.Z_MAX_LEVEL)\n          throw new Error(\"Invalid compression level: \" + opts.level);\n      }\n      if (opts.memLevel) {\n        if (opts.memLevel < exports.Z_MIN_MEMLEVEL || opts.memLevel > exports.Z_MAX_MEMLEVEL)\n          throw new Error(\"Invalid memLevel: \" + opts.memLevel);\n      }\n      if (opts.strategy) {\n        if (opts.strategy != exports.Z_FILTERED && opts.strategy != exports.Z_HUFFMAN_ONLY && opts.strategy != exports.Z_RLE && opts.strategy != exports.Z_FIXED && opts.strategy != exports.Z_DEFAULT_STRATEGY)\n          throw new Error(\"Invalid strategy: \" + opts.strategy);\n      }\n      if (opts.dictionary) {\n        if (!Buffer2.isBuffer(opts.dictionary))\n          throw new Error(\"Invalid dictionary: it should be a Buffer instance\");\n      }\n      this._handle = new binding.Zlib(mode);\n      var self = this;\n      this._hadError = !1, this._handle.onerror = function(message, errno) {\n        _close(self), self._hadError = !0;\n        var error = new Error(message);\n        error.errno = errno, error.code = exports.codes[errno], self.emit(\"error\", error);\n      };\n      var level = exports.Z_DEFAULT_COMPRESSION;\n      if (typeof opts.level === \"number\")\n        level = opts.level;\n      var strategy = exports.Z_DEFAULT_STRATEGY;\n      if (typeof opts.strategy === \"number\")\n        strategy = opts.strategy;\n      this._handle.init(opts.windowBits || exports.Z_DEFAULT_WINDOWBITS, level, opts.memLevel || exports.Z_DEFAULT_MEMLEVEL, strategy, opts.dictionary), this._buffer = Buffer2.allocUnsafe(this._chunkSize), this._offset = 0, this._level = level, this._strategy = strategy, this.once(\"end\", this.close), Object.defineProperty(this, \"_closed\", {\n        get: function() {\n          return !_this._handle;\n        },\n        configurable: !0,\n        enumerable: !0\n      });\n    }\n    util.inherits(Zlib, Transform), Zlib.prototype.params = function(level, strategy, callback) {\n      if (level < exports.Z_MIN_LEVEL || level > exports.Z_MAX_LEVEL)\n        @throwRangeError(\"Invalid compression level: \" + level);\n      if (strategy != exports.Z_FILTERED && strategy != exports.Z_HUFFMAN_ONLY && strategy != exports.Z_RLE && strategy != exports.Z_FIXED && strategy != exports.Z_DEFAULT_STRATEGY)\n        @throwTypeError(\"Invalid strategy: \" + strategy);\n      if (this._level !== level || this._strategy !== strategy) {\n        var self = this;\n        this.flush(binding.Z_SYNC_FLUSH, function() {\n          if (assert(self._handle, \"zlib binding closed\"), self._handle.params(level, strategy), !self._hadError) {\n            if (self._level = level, self._strategy = strategy, callback)\n              callback();\n          }\n        });\n      } else\n        process.nextTick(callback);\n    }, Zlib.prototype.reset = function() {\n      return assert(this._handle, \"zlib binding closed\"), this._handle.reset();\n    }, Zlib.prototype._flush = function(callback) {\n      this._transform(Buffer2.alloc(0), \"\", callback);\n    }, Zlib.prototype.flush = function(kind, callback) {\n      var _this2 = this, ws = this._writableState;\n      if (typeof kind === \"function\" || kind === void 0 && !callback)\n        callback = kind, kind = binding.Z_FULL_FLUSH;\n      if (ws.ended) {\n        if (callback)\n          process.nextTick(callback);\n      } else if (ws.ending) {\n        if (callback)\n          this.once(\"end\", callback);\n      } else if (ws.needDrain) {\n        if (callback)\n          this.once(\"drain\", function() {\n            return _this2.flush(kind, callback);\n          });\n      } else\n        this._flushFlag = kind, this.write(Buffer2.alloc(0), \"\", callback);\n    }, Zlib.prototype.close = function(callback) {\n      _close(this, callback), process.nextTick(emitCloseNT, this);\n    };\n    function _close(engine, callback) {\n      if (callback)\n        process.nextTick(callback);\n      if (!engine._handle)\n        return;\n      engine._handle.close(), engine._handle = null;\n    }\n    function emitCloseNT(self) {\n      self.emit(\"close\");\n    }\n    Zlib.prototype._transform = function(chunk, encoding, cb) {\n      var flushFlag, ws = this._writableState, ending = ws.ending || ws.ended, last = ending && (!chunk || ws.length === chunk.length);\n      if (chunk !== null && !Buffer2.isBuffer(chunk))\n        return cb(new Error(\"invalid input\"));\n      if (!this._handle)\n        return cb(new Error(\"zlib binding closed\"));\n      if (last)\n        flushFlag = this._finishFlushFlag;\n      else if (flushFlag = this._flushFlag, chunk.length >= ws.length)\n        this._flushFlag = this._opts.flush || binding.Z_NO_FLUSH;\n      this._processChunk(chunk, flushFlag, cb);\n    }, Zlib.prototype._processChunk = function(chunk, flushFlag, cb) {\n      var availInBefore = chunk && chunk.length, availOutBefore = this._chunkSize - this._offset, inOff = 0, self = this, async = typeof cb === \"function\";\n      if (!async) {\n        var buffers = [], nread = 0, error;\n        this.on(\"error\", function(er) {\n          error = er;\n        }), assert(this._handle, \"zlib binding closed\");\n        do\n          var res = this._handle.writeSync(flushFlag, chunk, inOff, availInBefore, this._buffer, this._offset, availOutBefore);\n        while (!this._hadError && callback(res[0], res[1]));\n        if (this._hadError)\n          throw error;\n        if (nread >= kMaxLength)\n          _close(this), @throwRangeError(kRangeErrorMessage);\n        var buf = Buffer2.concat(buffers, nread);\n        return _close(this), buf;\n      }\n      assert(this._handle, \"zlib binding closed\");\n      var req = this._handle.write(flushFlag, chunk, inOff, availInBefore, this._buffer, this._offset, availOutBefore);\n      req.buffer = chunk, req.callback = callback;\n      function callback(availInAfter, availOutAfter) {\n        if (this)\n          this.buffer = null, this.callback = null;\n        if (self._hadError)\n          return;\n        var have = availOutBefore - availOutAfter;\n        if (assert(have >= 0, \"have should not go down\"), have > 0) {\n          var out = self._buffer.slice(self._offset, self._offset + have);\n          if (self._offset += have, async)\n            self.push(out);\n          else\n            buffers.push(out), nread += out.length;\n        }\n        if (availOutAfter === 0 || self._offset >= self._chunkSize)\n          availOutBefore = self._chunkSize, self._offset = 0, self._buffer = Buffer2.allocUnsafe(self._chunkSize);\n        if (availOutAfter === 0) {\n          if (inOff += availInBefore - availInAfter, availInBefore = availInAfter, !async)\n            return !0;\n          var newReq = self._handle.write(flushFlag, chunk, inOff, availInBefore, self._buffer, self._offset, self._chunkSize);\n          newReq.callback = callback, newReq.buffer = chunk;\n          return;\n        }\n        if (!async)\n          return !1;\n        cb();\n      }\n    }, util.inherits(Deflate, Zlib), util.inherits(Inflate, Zlib), util.inherits(Gzip, Zlib), util.inherits(Gunzip, Zlib), util.inherits(DeflateRaw, Zlib), util.inherits(InflateRaw, Zlib), util.inherits(Unzip, Zlib);\n  }\n});\nreturn require_lib()})\n"_s;
//

//
static constexpr ASCIILiteral ThirdpartyDepdCode = "(function (){\"use strict\";// src/js/out/tmp/thirdparty/depd.ts\nvar wrapfunction = function(fn, message) {\n  if (typeof fn !== \"function\")\n    @throwTypeError(\"argument fn must be a function\");\n  return fn;\n}, wrapproperty = function(obj, prop, message) {\n  if (!obj || typeof obj !== \"object\" && typeof obj !== \"function\")\n    @throwTypeError(\"argument obj must be object\");\n  var descriptor = Object.getOwnPropertyDescriptor(obj, prop);\n  if (!descriptor)\n    @throwTypeError(\"must call property on owner object\");\n  if (!descriptor.configurable)\n    @throwTypeError(\"property must be configurable\");\n}, $;\n$ = function depd(namespace) {\n  if (!namespace)\n    @throwTypeError(\"argument namespace is required\");\n  function deprecate(message) {\n  }\n  return deprecate._file = void 0, deprecate._ignored = !0, deprecate._namespace = namespace, deprecate._traced = !1, deprecate._warned = Object.create(null), deprecate.function = wrapfunction, deprecate.property = wrapproperty, deprecate;\n};\nreturn $})\n"_s;
//

//
static constexpr ASCIILiteral ThirdpartyDetectLibcCode = "(function (){\"use strict\";// src/js/out/tmp/thirdparty/detect-libc.ts\nvar family = function() {\n  return Promise.resolve(familySync());\n}, familySync = function() {\n  return null;\n}, versionAsync = function() {\n  return Promise.resolve(version());\n}, version = function() {\n  return null;\n}, isNonGlibcLinuxSync = function() {\n  return !1;\n}, isNonGlibcLinux = function() {\n  return Promise.resolve(isNonGlibcLinuxSync());\n}, $, GLIBC = \"glibc\", MUSL = \"musl\";\n$ = {\n  GLIBC,\n  MUSL,\n  family,\n  familySync,\n  isNonGlibcLinux,\n  isNonGlibcLinuxSync,\n  version,\n  versionAsync\n};\nreturn $})\n"_s;
//

//
static constexpr ASCIILiteral ThirdpartyDetectLibcLinuxCode = "(function (){\"use strict\";// src/js/out/tmp/thirdparty/detect-libc.linux.ts\nvar family = function() {\n  return Promise.resolve(familySync());\n}, familySync = function() {\n  return GLIBC;\n}, versionAsync = function() {\n  return Promise.resolve(version());\n}, version = function() {\n  return \"2.29\";\n}, isNonGlibcLinuxSync = function() {\n  return !1;\n}, isNonGlibcLinux = function() {\n  return Promise.resolve(isNonGlibcLinuxSync());\n}, $, GLIBC = \"glibc\", MUSL = \"musl\";\n$ = {\n  GLIBC,\n  MUSL,\n  family,\n  familySync,\n  isNonGlibcLinux,\n  isNonGlibcLinuxSync,\n  version,\n  versionAsync\n};\nreturn $})\n"_s;
//

//
static constexpr ASCIILiteral ThirdpartyIsomorphicFetchCode = "(function (){\"use strict\";// src/js/out/tmp/thirdparty/isomorphic-fetch.ts\nvar bunFetch = Bun.fetch, fetch = (...args) => bunFetch(...args);\nfetch.default = fetch;\nfetch.fetch = fetch;\nreturn fetch})\n"_s;
//

//
static constexpr ASCIILiteral ThirdpartyNodeFetchCode = "(function (){\"use strict\";// src/js/out/tmp/thirdparty/node-fetch.ts\nvar fetch = function(...args) {\n  return realFetch(...args);\n}, blobFrom = function(path, options) {\n  return Promise.resolve(Bun.file(data));\n}, blobFromSync = function(path, options) {\n  return Bun.file(data);\n}, isRedirect = function(code) {\n  return code === 301 || code === 302 || code === 303 || code === 307 || code === 308;\n}, $, { Headers, Request, Response, Blob, File = Blob, FormData } = globalThis, realFetch = Bun.fetch;\n\nclass AbortError extends DOMException {\n  constructor(message) {\n    super(message, \"AbortError\");\n  }\n}\n\nclass FetchBaseError extends Error {\n  constructor(message, type) {\n    super(message);\n    this.type = type;\n  }\n}\n\nclass FetchError extends FetchBaseError {\n  constructor(message, type, systemError) {\n    super(message, type);\n    this.code = systemError\?.code;\n  }\n}\nvar fileFrom = blobFrom, fileFromSync = blobFromSync;\n$ = Object.assign(fetch, {\n  AbortError,\n  Blob,\n  FetchBaseError,\n  FetchError,\n  File,\n  FormData,\n  Headers,\n  Request,\n  Response,\n  blobFrom,\n  blobFromSync,\n  fileFrom,\n  fileFromSync,\n  isRedirect,\n  fetch,\n  default: fetch\n});\nreturn $})\n"_s;
//

//
static constexpr ASCIILiteral ThirdpartyUndiciCode = "(function (){\"use strict\";// src/js/out/tmp/thirdparty/undici.ts\nvar notImplemented = function() {\n  throw new Error(\"Not implemented in bun\");\n};\nasync function request(url, options = {\n  method: \"GET\",\n  signal: null,\n  headers: null,\n  query: null,\n  reset: !1,\n  throwOnError: !1,\n  body: null\n}) {\n  let {\n    method = \"GET\",\n    headers: inputHeaders,\n    query,\n    signal,\n    reset = !1,\n    throwOnError = !1,\n    body: inputBody,\n    maxRedirections\n  } = options;\n  if (typeof url === \"string\") {\n    if (query)\n      url = new URL(url);\n  } else if (typeof url === \"object\" && url !== null) {\n    if (!(url instanceof URL))\n      throw new Error(\"not implemented\");\n  } else\n    @throwTypeError(\"url must be a string, URL, or UrlObject\");\n  if (typeof url === \"string\" && query)\n    url = new URL(url);\n  if (typeof url === \"object\" && url !== null && query) {\n    if (query)\n      url.search = new URLSearchParams(query).toString();\n  }\n  if (method = method && typeof method === \"string\" \? method.toUpperCase() : null, inputBody && (method === \"GET\" || method === \"HEAD\"))\n    throw new Error(\"Body not allowed for GET or HEAD requests\");\n  if (inputBody && inputBody.read && inputBody instanceof Readable) {\n    let data = \"\";\n    inputBody.setEncoding(\"utf8\");\n    for await (let chunk of stream)\n      data += chunk;\n    inputBody = (new TextEncoder()).encode(data);\n  }\n  if (maxRedirections !== void 0 && Number.isNaN(maxRedirections))\n    throw new Error(\"maxRedirections must be a number if defined\");\n  if (signal && !(signal instanceof AbortSignal))\n    throw new Error(\"signal must be an instance of AbortSignal\");\n  let resp;\n  const {\n    status: statusCode,\n    headers,\n    trailers\n  } = resp = await fetch(url, {\n    signal,\n    mode: \"cors\",\n    method,\n    headers: inputHeaders || kEmptyObject,\n    body: inputBody,\n    redirect: maxRedirections === \"undefined\" || maxRedirections > 0 \? \"follow\" : \"manual\",\n    keepalive: !reset\n  });\n  if (throwOnError && statusCode >= 400 && statusCode < 600)\n    throw new Error(`Request failed with status code ${statusCode}`);\n  const body = resp.body \? new BodyReadable(resp) : null;\n  return { statusCode, headers: headers.toJSON(), body, trailers, opaque: kEmptyObject, context: kEmptyObject };\n}\nvar stream = function() {\n  throw new Error(\"Not implemented in bun\");\n}, pipeline = function() {\n  throw new Error(\"Not implemented in bun\");\n}, connect = function() {\n  throw new Error(\"Not implemented in bun\");\n}, upgrade = function() {\n  throw new Error(\"Not implemented in bun\");\n}, mockErrors = function() {\n  throw new Error(\"Not implemented in bun\");\n}, Undici = function() {\n  throw new Error(\"Not implemented in bun\");\n}, $, EventEmitter = @getInternalField(@internalModuleRegistry, 16) || @createInternalModuleById(16), StreamModule = @getInternalField(@internalModuleRegistry, 35) || @createInternalModuleById(35), { Readable } = StreamModule, { _ReadableFromWebForUndici: ReadableFromWeb } = StreamModule[Symbol.for(\"::bunternal::\")], ObjectCreate = Object.create, kEmptyObject = ObjectCreate(null), fetch = Bun.fetch, Response = globalThis.Response, Headers = globalThis.Headers, Request = globalThis.Request, URLSearchParams = globalThis.URLSearchParams, URL = globalThis.URL;\n\nclass File extends Blob {\n  constructor() {\n    super(...arguments);\n  }\n}\n\nclass FileReader extends EventTarget {\n  constructor() {\n    throw new Error(\"Not implemented yet!\");\n  }\n}\nvar FormData = globalThis.FormData;\n\nclass BodyReadable extends ReadableFromWeb {\n  #response;\n  #bodyUsed;\n  constructor(response, options = {}) {\n    var { body } = response;\n    if (!body)\n      throw new Error(\"Response body is null\");\n    super(options, body);\n    this.#response = response, this.#bodyUsed = response.bodyUsed;\n  }\n  get bodyUsed() {\n    return this.#bodyUsed;\n  }\n  #consume() {\n    if (this.#bodyUsed)\n      @throwTypeError(\"unusable\");\n    this.#bodyUsed = !0;\n  }\n  async arrayBuffer() {\n    return this.#consume(), await this.#response.arrayBuffer();\n  }\n  async blob() {\n    return this.#consume(), await this.#response.blob();\n  }\n  async formData() {\n    return this.#consume(), await this.#response.formData();\n  }\n  async json() {\n    return this.#consume(), await this.#response.json();\n  }\n  async text() {\n    return this.#consume(), await this.#response.text();\n  }\n}\n\nclass MockClient {\n  constructor() {\n    throw new Error(\"Not implemented in bun\");\n  }\n}\n\nclass MockPool {\n  constructor() {\n    throw new Error(\"Not implemented in bun\");\n  }\n}\n\nclass MockAgent {\n  constructor() {\n    throw new Error(\"Not implemented in bun\");\n  }\n}\n\nclass Dispatcher extends EventEmitter {\n  constructor() {\n    super(...arguments);\n  }\n}\n\nclass Agent extends Dispatcher {\n  constructor() {\n    super(...arguments);\n  }\n}\n\nclass Pool extends Dispatcher {\n  constructor() {\n    super(...arguments);\n  }\n  request() {\n    throw new Error(\"Not implemented in bun\");\n  }\n}\n\nclass BalancedPool extends Dispatcher {\n  constructor() {\n    super(...arguments);\n  }\n}\n\nclass Client extends Dispatcher {\n  constructor() {\n    super(...arguments);\n  }\n  request() {\n    throw new Error(\"Not implemented in bun\");\n  }\n}\nUndici.Dispatcher = Dispatcher;\nUndici.Pool = Pool;\nUndici.BalancedPool = BalancedPool;\nUndici.Client = Client;\nUndici.Agent = Agent;\nUndici.buildConnector = Undici.errors = Undici.setGlobalDispatcher = Undici.getGlobalDispatcher = Undici.request = Undici.stream = Undici.pipeline = Undici.connect = Undici.upgrade = Undici.MockClient = Undici.MockPool = Undici.MockAgent = Undici.mockErrors = notImplemented;\nUndici.fetch = fetch;\n$ = {\n  fetch,\n  Response,\n  Headers,\n  Request,\n  URLSearchParams,\n  URL,\n  File,\n  FileReader,\n  FormData,\n  request,\n  stream,\n  pipeline,\n  connect,\n  upgrade,\n  MockClient,\n  MockPool,\n  MockAgent,\n  mockErrors,\n  Dispatcher,\n  Pool,\n  BalancedPool,\n  Client,\n  Agent,\n  Undici\n};\nreturn $})\n"_s;
//

//
static constexpr ASCIILiteral ThirdpartyVercelFetchCode = "(function (){\"use strict\";// src/js/out/tmp/thirdparty/vercel_fetch.ts\nvar $;\n$ = (wrapper = Bun.fetch) => {\n  async function vercelFetch(url, opts = {}) {\n    if (opts.body && typeof opts.body === \"object\" && (!(\"buffer\" in opts.body) || typeof opts.body.buffer !== \"object\" || !(opts.body.buffer instanceof ArrayBuffer))) {\n      if (opts.body = JSON.stringify(opts.body), !opts.headers)\n        opts.headers = new Headers;\n      opts.headers.set(\"Content-Type\", \"application/json\");\n    }\n    try {\n      return await wrapper(url, opts);\n    } catch (err) {\n      if (typeof err === \"string\")\n        err = new Error(err);\n      throw err.url = url, err.opts = opts, err;\n    }\n  }\n  return vercelFetch.default = vercelFetch, vercelFetch;\n};\nreturn $})\n"_s;
//

//
static constexpr ASCIILiteral ThirdpartyWSCode = "(function (){\"use strict\";// src/js/out/tmp/thirdparty/ws.ts\nvar emitWarning = function(type, message) {\n  if (emittedWarnings.has(type))\n    return;\n  emittedWarnings.add(type), console.warn(\"[bun] Warning:\", message);\n}, subprotocolParse = function(header) {\n  const protocols = new Set;\n  let start = -1, end = -1, i = 0;\n  for (i;i < header.length; i++) {\n    const code = header.charCodeAt(i);\n    if (end === -1 && wsTokenChars[code] === 1) {\n      if (start === -1)\n        start = i;\n    } else if (i !== 0 && (code === 32 || code === 9)) {\n      if (end === -1 && start !== -1)\n        end = i;\n    } else if (code === 44) {\n      if (start === -1)\n        throw new SyntaxError(`Unexpected character at index ${i}`);\n      if (end === -1)\n        end = i;\n      const protocol2 = header.slice(start, end);\n      if (protocols.has(protocol2))\n        throw new SyntaxError(`The \"${protocol2}\" subprotocol is duplicated`);\n      protocols.add(protocol2), start = end = -1;\n    } else\n      throw new SyntaxError(`Unexpected character at index ${i}`);\n  }\n  if (start === -1 || end !== -1)\n    throw new SyntaxError(\"Unexpected end of input\");\n  const protocol = header.slice(start, i);\n  if (protocols.has(protocol))\n    throw new SyntaxError(`The \"${protocol}\" subprotocol is duplicated`);\n  return protocols.add(protocol), protocols;\n}, wsEmitClose = function(server) {\n  server._state = CLOSED, server.emit(\"close\");\n}, abortHandshake = function(response, code, message, headers) {\n  message = message || http.STATUS_CODES[code], headers = {\n    Connection: \"close\",\n    \"Content-Type\": \"text/html\",\n    \"Content-Length\": Buffer.byteLength(message),\n    ...headers\n  }, response.writeHead(code, headers), response.write(message), response.end();\n}, abortHandshakeOrEmitwsClientError = function(server, req, response, socket, code, message) {\n  if (server.listenerCount(\"wsClientError\")) {\n    const err = new Error(message);\n    Error.captureStackTrace(err, abortHandshakeOrEmitwsClientError), server.emit(\"wsClientError\", err, socket, req);\n  } else\n    abortHandshake(response, code, message);\n}, $, EventEmitter = @getInternalField(@internalModuleRegistry, 16) || @createInternalModuleById(16), http = @getInternalField(@internalModuleRegistry, 19) || @createInternalModuleById(19), kBunInternals = Symbol.for(\"::bunternal::\"), readyStates = [\"CONNECTING\", \"OPEN\", \"CLOSING\", \"CLOSED\"], encoder = new TextEncoder, eventIds = {\n  open: 1,\n  close: 2,\n  message: 3,\n  error: 4,\n  ping: 5,\n  pong: 6\n}, emittedWarnings = new Set;\n\nclass BunWebSocket extends EventEmitter {\n  static CONNECTING = 0;\n  static OPEN = 1;\n  static CLOSING = 2;\n  static CLOSED = 3;\n  #ws;\n  #paused = !1;\n  #fragments = !1;\n  #binaryType = \"nodebuffer\";\n  #eventId = 0;\n  constructor(url, protocols, options) {\n    super();\n    let ws = this.#ws = new WebSocket(url, protocols);\n    ws.binaryType = \"nodebuffer\";\n  }\n  on(event, listener) {\n    if (event === \"unexpected-response\" || event === \"upgrade\" || event === \"redirect\")\n      emitWarning(event, \"ws.WebSocket '\" + event + \"' event is not implemented in bun\");\n    const mask = 1 << eventIds[event];\n    if (mask && (this.#eventId & mask) !== mask) {\n      if (this.#eventId |= mask, event === \"open\")\n        this.#ws.addEventListener(\"open\", () => {\n          this.emit(\"open\");\n        });\n      else if (event === \"close\")\n        this.#ws.addEventListener(\"close\", ({ code, reason, wasClean }) => {\n          this.emit(\"close\", code, reason, wasClean);\n        });\n      else if (event === \"message\")\n        this.#ws.addEventListener(\"message\", ({ data }) => {\n          const isBinary = typeof data !== \"string\";\n          if (isBinary)\n            this.emit(\"message\", this.#fragments \? [data] : data, isBinary);\n          else {\n            let encoded = encoder.encode(data);\n            if (this.#binaryType !== \"arraybuffer\")\n              encoded = Buffer.from(encoded.buffer, encoded.byteOffset, encoded.byteLength);\n            this.emit(\"message\", this.#fragments \? [encoded] : encoded, isBinary);\n          }\n        });\n      else if (event === \"error\")\n        this.#ws.addEventListener(\"error\", (err) => {\n          this.emit(\"error\", err);\n        });\n      else if (event === \"ping\")\n        this.#ws.addEventListener(\"ping\", ({ data }) => {\n          this.emit(\"ping\", data);\n        });\n      else if (event === \"pong\")\n        this.#ws.addEventListener(\"pong\", ({ data }) => {\n          this.emit(\"pong\", data);\n        });\n    }\n    return super.on(event, listener);\n  }\n  send(data, opts, cb) {\n    try {\n      this.#ws.send(data, opts\?.compress);\n    } catch (error) {\n      typeof cb === \"function\" && cb(error);\n      return;\n    }\n    typeof cb === \"function\" && cb();\n  }\n  close(code, reason) {\n    this.#ws.close(code, reason);\n  }\n  terminate() {\n    this.#ws.terminate();\n  }\n  get url() {\n    return this.#ws.url;\n  }\n  get readyState() {\n    return this.#ws.readyState;\n  }\n  get binaryType() {\n    return this.#binaryType;\n  }\n  set binaryType(value) {\n    if (value === \"nodebuffer\" || value === \"arraybuffer\")\n      this.#ws.binaryType = this.#binaryType = value, this.#fragments = !1;\n    else if (value === \"fragments\")\n      this.#ws.binaryType = \"nodebuffer\", this.#binaryType = \"fragments\", this.#fragments = !0;\n    else\n      throw new Error(`Invalid binaryType: ${value}`);\n  }\n  get protocol() {\n    return this.#ws.protocol;\n  }\n  get extensions() {\n    return this.#ws.extensions;\n  }\n  addEventListener(type, listener, options) {\n    this.#ws.addEventListener(type, listener, options);\n  }\n  removeEventListener(type, listener) {\n    this.#ws.removeEventListener(type, listener);\n  }\n  get onopen() {\n    return this.#ws.onopen;\n  }\n  set onopen(value) {\n    this.#ws.onopen = value;\n  }\n  get onerror() {\n    return this.#ws.onerror;\n  }\n  set onerror(value) {\n    this.#ws.onerror = value;\n  }\n  get onclose() {\n    return this.#ws.onclose;\n  }\n  set onclose(value) {\n    this.#ws.onclose = value;\n  }\n  get onmessage() {\n    return this.#ws.onmessage;\n  }\n  set onmessage(value) {\n    this.#ws.onmessage = value;\n  }\n  get bufferedAmount() {\n    return this.#ws.bufferedAmount;\n  }\n  get isPaused() {\n    return this.#paused;\n  }\n  ping(data, mask, cb) {\n    if (typeof data === \"function\")\n      cb = data, data = mask = void 0;\n    else if (typeof mask === \"function\")\n      cb = mask, mask = void 0;\n    if (typeof data === \"number\")\n      data = data.toString();\n    try {\n      this.#ws.ping(data);\n    } catch (error) {\n      typeof cb === \"function\" && cb(error);\n      return;\n    }\n    typeof cb === \"function\" && cb();\n  }\n  pong(data, mask, cb) {\n    if (typeof data === \"function\")\n      cb = data, data = mask = void 0;\n    else if (typeof mask === \"function\")\n      cb = mask, mask = void 0;\n    if (typeof data === \"number\")\n      data = data.toString();\n    try {\n      this.#ws.pong(data);\n    } catch (error) {\n      typeof cb === \"function\" && cb(error);\n      return;\n    }\n    typeof cb === \"function\" && cb();\n  }\n  pause() {\n    switch (this.readyState) {\n      case WebSocket.CONNECTING:\n      case WebSocket.CLOSED:\n        return;\n    }\n    this.#paused = !0, emitWarning(\"pause()\", \"ws.WebSocket.pause() is not implemented in bun\");\n  }\n  resume() {\n    switch (this.readyState) {\n      case WebSocket.CONNECTING:\n      case WebSocket.CLOSED:\n        return;\n    }\n    this.#paused = !1, emitWarning(\"resume()\", \"ws.WebSocket.resume() is not implemented in bun\");\n  }\n}\nObject.defineProperty(BunWebSocket, \"name\", { value: \"WebSocket\" });\nvar wsKeyRegex = /^[+/0-9A-Za-z]{22}==$/, wsTokenChars = [\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  1,\n  0,\n  1,\n  1,\n  1,\n  1,\n  1,\n  0,\n  0,\n  1,\n  1,\n  0,\n  1,\n  1,\n  0,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  0,\n  0,\n  0,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  0,\n  1,\n  0,\n  1,\n  0\n], RUNNING = 0, CLOSING = 1, CLOSED = 2;\n\nclass BunWebSocketMocked extends EventEmitter {\n  #ws;\n  #state;\n  #enquedMessages = [];\n  #url;\n  #protocol;\n  #extensions;\n  #bufferedAmount = 0;\n  #binaryType = \"arraybuffer\";\n  #onclose;\n  #onerror;\n  #onmessage;\n  #onopen;\n  constructor(url, protocol, extensions, binaryType) {\n    super();\n    if (this.#ws = null, this.#state = 0, this.#url = url, this.#bufferedAmount = 0, binaryType = binaryType || \"arraybuffer\", binaryType !== \"nodebuffer\" && binaryType !== \"blob\" && binaryType !== \"arraybuffer\")\n      @throwTypeError(\"binaryType must be either 'blob', 'arraybuffer' or 'nodebuffer'\");\n    this.#binaryType = binaryType, this.#protocol = protocol, this.#extensions = extensions;\n    const message = this.#message.bind(this), open = this.#open.bind(this), close = this.#close.bind(this), drain = this.#drain.bind(this);\n    this[kBunInternals] = {\n      message,\n      open,\n      close,\n      drain\n    };\n  }\n  #message(ws, message) {\n    if (this.#ws = ws, typeof message === \"string\")\n      if (this.#binaryType === \"arraybuffer\")\n        message = encoder.encode(message).buffer;\n      else if (this.#binaryType === \"blob\")\n        message = new Blob([message], { type: \"text/plain\" });\n      else\n        message = Buffer.from(message);\n    else if (this.#binaryType !== \"nodebuffer\") {\n      if (this.#binaryType === \"arraybuffer\")\n        message = new Uint8Array(message);\n      else if (this.#binaryType === \"blob\")\n        message = new Blob([message]);\n    }\n    this.emit(\"message\", message);\n  }\n  #open(ws) {\n    this.#ws = ws, this.#state = 1, this.emit(\"open\", this), this.#drain(ws);\n  }\n  #close(ws, code, reason) {\n    this.#state = 3, this.#ws = null, this.emit(\"close\", code, reason);\n  }\n  #drain(ws) {\n    const chunk = this.#enquedMessages[0];\n    if (chunk) {\n      const [data, compress, cb] = chunk;\n      if (ws.send(data, compress) == -1)\n        return;\n      typeof cb === \"function\" && cb(), this.#bufferedAmount -= chunk.length, this.#enquedMessages.shift();\n    }\n  }\n  send(data, opts, cb) {\n    if (this.#state === 1) {\n      const compress = opts\?.compress;\n      if (this.#ws.send(data, compress) == -1) {\n        this.#enquedMessages.push([data, compress, cb]), this.#bufferedAmount += data.length;\n        return;\n      }\n      typeof cb === \"function\" && cb();\n    } else if (this.#state === 0)\n      this.#enquedMessages.push([data, opts\?.compress, cb]), this.#bufferedAmount += data.length;\n  }\n  close(code, reason) {\n    if (this.#state === 1)\n      this.#state = 2, this.#ws.close(code, reason);\n  }\n  get binaryType() {\n    return this.#binaryType;\n  }\n  set binaryType(type) {\n    if (type !== \"nodebuffer\" && type !== \"blob\" && type !== \"arraybuffer\")\n      @throwTypeError(\"binaryType must be either 'blob', 'arraybuffer' or 'nodebuffer'\");\n    this.#binaryType = type;\n  }\n  get readyState() {\n    return this.#state;\n  }\n  get url() {\n    return this.#url;\n  }\n  get protocol() {\n    return this.#protocol;\n  }\n  get extensions() {\n    return this.#extensions;\n  }\n  get bufferedAmount() {\n    return this.#bufferedAmount \?\? 0;\n  }\n  setSocket(socket, head, options) {\n    throw new Error(\"Not implemented\");\n  }\n  set onclose(cb) {\n    if (this.#onclose)\n      this.removeListener(\"close\", this.#onclose);\n    this.on(\"close\", cb), this.#onclose = cb;\n  }\n  set onerror(cb) {\n    if (this.#onerror)\n      this.removeListener(\"error\", this.#onerror);\n    this.on(\"error\", cb), this.#onerror = cb;\n  }\n  set onmessage(cb) {\n    if (this.#onmessage)\n      this.removeListener(\"message\", this.#onmessage);\n    this.on(\"message\", cb), this.#onmessage = cb;\n  }\n  set onopen(cb) {\n    if (this.#onopen)\n      this.removeListener(\"open\", this.#onopen);\n    this.on(\"open\", cb), this.#onopen = cb;\n  }\n  get onclose() {\n    return this.#onclose;\n  }\n  get onerror() {\n    return this.#onerror;\n  }\n  get onmessage() {\n    return this.#onmessage;\n  }\n  get onopen() {\n    return this.#onopen;\n  }\n}\n\nclass WebSocketServer extends EventEmitter {\n  _server;\n  options;\n  clients;\n  _shouldEmitClose;\n  _state;\n  _removeListeners;\n  constructor(options, callback) {\n    super();\n    if (options = {\n      maxPayload: 104857600,\n      skipUTF8Validation: !1,\n      perMessageDeflate: !1,\n      handleProtocols: null,\n      clientTracking: !0,\n      verifyClient: null,\n      noServer: !1,\n      backlog: null,\n      server: null,\n      host: null,\n      path: null,\n      port: null,\n      ...options\n    }, options.port == null && !options.server && !options.noServer || options.port != null && (options.server || options.noServer) || options.server && options.noServer)\n      @throwTypeError('One and only one of the \"port\", \"server\", or \"noServer\" options must be specified');\n    if (options.port != null)\n      this._server = http.createServer((req, res) => {\n        const body = http.STATUS_CODES[426];\n        res.writeHead(426, {\n          \"Content-Length\": body.length,\n          \"Content-Type\": \"text/plain\"\n        }), res.end(body);\n      }), this._server.listen(options.port, options.host, options.backlog, callback);\n    else if (options.server)\n      this._server = options.server;\n    if (this._server) {\n      const emitConnection = this.emit.bind(this, \"connection\"), emitListening = this.emit.bind(this, \"listening\"), emitError = this.emit.bind(this, \"error\"), doUpgrade = (req, socket, head) => {\n        this.handleUpgrade(req, socket, head, emitConnection);\n      };\n      this._server.on(\"listening\", emitListening), this._server.on(\"error\", emitError), this._server.on(\"upgrade\", doUpgrade), this._removeListeners = () => {\n        this._server.removeListener(\"upgrade\", doUpgrade), this._server.removeListener(\"listening\", emitListening), this._server.removeListener(\"error\", emitError);\n      };\n    }\n    if (options.perMessageDeflate === !0)\n      options.perMessageDeflate = {};\n    if (options.clientTracking)\n      this.clients = new Set, this._shouldEmitClose = !1;\n    this.options = options, this._state = RUNNING;\n  }\n  address() {\n    if (this.options.noServer)\n      throw new Error('The server is operating in \"noServer\" mode');\n    if (!this._server)\n      return null;\n    return this._server.address();\n  }\n  close(cb) {\n    if (this._state === CLOSED) {\n      if (cb)\n        this.once(\"close\", () => {\n          cb(new Error(\"The server is not running\"));\n        });\n      process.nextTick((server) => {\n        server._state = CLOSED, server.emit(\"close\");\n      }, this);\n      return;\n    }\n    if (cb)\n      this.once(\"close\", cb);\n    if (this._state === CLOSING)\n      return;\n    if (this._state = CLOSING, this.options.noServer || this.options.server) {\n      if (this._server)\n        this._removeListeners(), this._removeListeners = this._server = null;\n      if (this.clients)\n        if (!this.clients.size)\n          process.nextTick((server) => {\n            server._state = CLOSED, server.emit(\"close\");\n          }, this);\n        else\n          this._shouldEmitClose = !0;\n      else\n        process.nextTick((server) => {\n          server._state = CLOSED, server.emit(\"close\");\n        }, this);\n    } else {\n      const server = this._server;\n      this._removeListeners(), this._removeListeners = this._server = null, server.close(() => {\n        this._state = CLOSED, this.emit(\"close\");\n      });\n    }\n  }\n  shouldHandle(req) {\n    if (this.options.path) {\n      const index = req.url.indexOf(\"\?\");\n      if ((index !== -1 \? req.url.slice(0, index) : req.url) !== this.options.path)\n        return !1;\n    }\n    return !0;\n  }\n  completeUpgrade(extensions, key, protocols, request, socket, head, cb) {\n    const [server, response, req] = socket[kBunInternals];\n    if (this._state > RUNNING)\n      return abortHandshake(response, 503);\n    let protocol = \"\";\n    if (protocols.size)\n      protocol = this.options.handleProtocols \? this.options.handleProtocols(protocols, request) : protocols.values().next().value;\n    const ws = new BunWebSocketMocked(request.url, protocol, extensions, \"nodebuffer\"), headers = [\"HTTP/1.1 101 Switching Protocols\", \"Upgrade: websocket\", \"Connection: Upgrade\"];\n    if (this.emit(\"headers\", headers, request), server.upgrade(req, {\n      data: ws[kBunInternals]\n    })) {\n      if (response._reply(void 0), this.clients)\n        this.clients.add(ws), ws.on(\"close\", () => {\n          if (this.clients.delete(ws), this._shouldEmitClose && !this.clients.size)\n            process.nextTick(wsEmitClose, this);\n        });\n      cb(ws, request);\n    } else\n      abortHandshake(response, 500);\n  }\n  handleUpgrade(req, socket, head, cb) {\n    const [_, response] = socket[kBunInternals], key = req.headers[\"sec-websocket-key\"], version = +req.headers[\"sec-websocket-version\"];\n    if (req.method !== \"GET\") {\n      abortHandshakeOrEmitwsClientError(this, req, response, socket, 405, \"Invalid HTTP method\");\n      return;\n    }\n    if (req.headers.upgrade.toLowerCase() !== \"websocket\") {\n      abortHandshakeOrEmitwsClientError(this, req, response, socket, 400, \"Invalid Upgrade header\");\n      return;\n    }\n    if (!key || !wsKeyRegex.test(key)) {\n      abortHandshakeOrEmitwsClientError(this, req, response, socket, 400, \"Missing or invalid Sec-WebSocket-Key header\");\n      return;\n    }\n    if (version !== 8 && version !== 13) {\n      abortHandshakeOrEmitwsClientError(this, req, response, socket, 400, \"Missing or invalid Sec-WebSocket-Version header\");\n      return;\n    }\n    if (!this.shouldHandle(req)) {\n      abortHandshake(response, 400);\n      return;\n    }\n    const secWebSocketProtocol = req.headers[\"sec-websocket-protocol\"];\n    let protocols = new Set;\n    if (secWebSocketProtocol !== void 0)\n      try {\n        protocols = subprotocolParse(secWebSocketProtocol);\n      } catch (err) {\n        abortHandshakeOrEmitwsClientError(this, req, response, socket, 400, \"Invalid Sec-WebSocket-Protocol header\");\n        return;\n      }\n    const extensions = {};\n    if (this.options.verifyClient) {\n      const info = {\n        origin: req.headers[`${version === 8 \? \"sec-websocket-origin\" : \"origin\"}`],\n        secure: !!(req.socket.authorized || req.socket.encrypted),\n        req\n      };\n      if (this.options.verifyClient.length === 2) {\n        this.options.verifyClient(info, (verified, code, message, headers) => {\n          if (!verified)\n            return abortHandshake(response, code || 401, message, headers);\n          this.completeUpgrade(extensions, key, protocols, req, socket, head, cb);\n        });\n        return;\n      }\n      if (!this.options.verifyClient(info))\n        return abortHandshake(response, 401);\n    }\n    this.completeUpgrade(extensions, key, protocols, req, socket, head, cb);\n  }\n}\nObject.defineProperty(BunWebSocket, \"CONNECTING\", {\n  enumerable: !0,\n  value: readyStates.indexOf(\"CONNECTING\")\n});\nObject.defineProperty(BunWebSocket.prototype, \"CONNECTING\", {\n  enumerable: !0,\n  value: readyStates.indexOf(\"CONNECTING\")\n});\nObject.defineProperty(BunWebSocket, \"OPEN\", {\n  enumerable: !0,\n  value: readyStates.indexOf(\"OPEN\")\n});\nObject.defineProperty(BunWebSocket.prototype, \"OPEN\", {\n  enumerable: !0,\n  value: readyStates.indexOf(\"OPEN\")\n});\nObject.defineProperty(BunWebSocket, \"CLOSING\", {\n  enumerable: !0,\n  value: readyStates.indexOf(\"CLOSING\")\n});\nObject.defineProperty(BunWebSocket.prototype, \"CLOSING\", {\n  enumerable: !0,\n  value: readyStates.indexOf(\"CLOSING\")\n});\nObject.defineProperty(BunWebSocket, \"CLOSED\", {\n  enumerable: !0,\n  value: readyStates.indexOf(\"CLOSED\")\n});\nObject.defineProperty(BunWebSocket.prototype, \"CLOSED\", {\n  enumerable: !0,\n  value: readyStates.indexOf(\"CLOSED\")\n});\n\nclass Sender {\n  constructor() {\n    throw new Error(\"Not supported yet in Bun\");\n  }\n}\n\nclass Receiver {\n  constructor() {\n    throw new Error(\"Not supported yet in Bun\");\n  }\n}\nvar createWebSocketStream = (ws) => {\n  throw new Error(\"Not supported yet in Bun\");\n};\n$ = Object.assign(BunWebSocket, {\n  createWebSocketStream,\n  Receiver,\n  Sender,\n  WebSocket: BunWebSocket,\n  Server: WebSocketServer,\n  WebSocketServer\n});\nreturn $})\n"_s;
//

  #else
  // Not 100% accurate, but basically inlining linux on non-windows non-mac platforms.
  //
static constexpr ASCIILiteral BunFFICode = "(function (){\"use strict\";// src/js/out/tmp/bun/ffi.ts\nvar FFIBuilder = function(params, returnType, functionToCall, name) {\n  const hasReturnType = typeof FFIType[returnType] === \"number\" && FFIType[returnType] !== FFIType.void;\n  var paramNames = new Array(params.length), args = new Array(params.length);\n  for (let i = 0;i < params.length; i++) {\n    paramNames[i] = `p${i}`;\n    const wrapper = ffiWrappers[FFIType[params[i]]];\n    if (wrapper)\n      args[i] = `(val=>${wrapper})(p${i})`;\n    else\n      @throwTypeError(`Unsupported type ${params[i]}. Must be one of: ${Object.keys(FFIType).sort().join(\", \")}`);\n  }\n  var code = `functionToCall(${args.join(\", \")})`;\n  if (hasReturnType)\n    if (FFIType[returnType] === FFIType.cstring)\n      code = `return new __GlobalBunCString(${code})`;\n    else\n      code = `return ${code}`;\n  var func = new Function(\"functionToCall\", ...paramNames, code);\n  Object.defineProperty(func, \"name\", {\n    value: name\n  });\n  var wrap;\n  switch (paramNames.length) {\n    case 0:\n      wrap = () => func(functionToCall);\n      break;\n    case 1:\n      wrap = (arg1) => func(functionToCall, arg1);\n      break;\n    case 2:\n      wrap = (arg1, arg2) => func(functionToCall, arg1, arg2);\n      break;\n    case 3:\n      wrap = (arg1, arg2, arg3) => func(functionToCall, arg1, arg2, arg3);\n      break;\n    case 4:\n      wrap = (arg1, arg2, arg3, arg4) => func(functionToCall, arg1, arg2, arg3, arg4);\n      break;\n    case 5:\n      wrap = (arg1, arg2, arg3, arg4, arg5) => func(functionToCall, arg1, arg2, arg3, arg4, arg5);\n      break;\n    case 6:\n      wrap = (arg1, arg2, arg3, arg4, arg5, arg6) => func(functionToCall, arg1, arg2, arg3, arg4, arg5, arg6);\n      break;\n    case 7:\n      wrap = (arg1, arg2, arg3, arg4, arg5, arg6, arg7) => func(functionToCall, arg1, arg2, arg3, arg4, arg5, arg6, arg7);\n      break;\n    case 8:\n      wrap = (arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) => func(functionToCall, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);\n      break;\n    case 9:\n      wrap = (arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9) => func(functionToCall, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9);\n      break;\n    default: {\n      wrap = (...args2) => func(functionToCall, ...args2);\n      break;\n    }\n  }\n  return wrap.native = functionToCall, wrap.ptr = functionToCall.ptr, wrap;\n}, dlopen = function(path, options) {\n  const result = nativeDLOpen(path, options);\n  for (let key in result.symbols) {\n    var symbol = result.symbols[key];\n    if (options[key]\?.args\?.length || FFIType[options[key]\?.returns] === FFIType.cstring)\n      result.symbols[key] = FFIBuilder(options[key].args \?\? [], options[key].returns \?\? FFIType.void, symbol, path.includes(\"/\") \? `${key} (${path.split(\"/\").pop()})` : `${key} (${path})`);\n    else\n      result.symbols[key].native = result.symbols[key];\n  }\n  return result;\n}, linkSymbols = function(options) {\n  const result = nativeLinkSymbols(options);\n  for (let key in result.symbols) {\n    var symbol = result.symbols[key];\n    if (options[key]\?.args\?.length || FFIType[options[key]\?.returns] === FFIType.cstring)\n      result.symbols[key] = FFIBuilder(options[key].args \?\? [], options[key].returns \?\? FFIType.void, symbol, key);\n    else\n      result.symbols[key].native = result.symbols[key];\n  }\n  return result;\n}, onCloseCFunction = function(close) {\n  close();\n}, CFunction = function(options) {\n  const identifier = `CFunction${cFunctionI++}`;\n  var result = linkSymbols({\n    [identifier]: options\n  }), hasClosed = !1, close = result.close;\n  return result.symbols[identifier].close = () => {\n    if (hasClosed || !close)\n      return;\n    hasClosed = !0, close(), close = void 0;\n  }, cFunctionRegistry ||= new FinalizationRegistry(onCloseCFunction), cFunctionRegistry.register(result.symbols[identifier], result.symbols[identifier].close), result.symbols[identifier];\n}, $, FFIType = {\n  \"0\": 0,\n  \"1\": 1,\n  \"2\": 2,\n  \"3\": 3,\n  \"4\": 4,\n  \"5\": 5,\n  \"6\": 6,\n  \"7\": 7,\n  \"8\": 8,\n  \"9\": 9,\n  \"10\": 10,\n  \"11\": 11,\n  \"12\": 12,\n  \"13\": 13,\n  \"14\": 14,\n  \"15\": 15,\n  \"16\": 16,\n  \"17\": 17,\n  bool: 11,\n  c_int: 5,\n  c_uint: 6,\n  char: 0,\n  \"char*\": 12,\n  double: 9,\n  f32: 10,\n  f64: 9,\n  float: 10,\n  i16: 3,\n  i32: 5,\n  i64: 7,\n  i8: 1,\n  int: 5,\n  int16_t: 3,\n  int32_t: 5,\n  int64_t: 7,\n  int8_t: 1,\n  isize: 7,\n  u16: 4,\n  u32: 6,\n  u64: 8,\n  u8: 2,\n  uint16_t: 4,\n  uint32_t: 6,\n  uint64_t: 8,\n  uint8_t: 2,\n  usize: 8,\n  \"void*\": 12,\n  ptr: 12,\n  pointer: 12,\n  void: 13,\n  cstring: 14,\n  i64_fast: 15,\n  u64_fast: 16,\n  function: 17,\n  callback: 17,\n  fn: 17\n};\nvar ffi = globalThis.Bun.FFI, ptr = (arg1, arg2) => typeof arg2 === \"undefined\" \? ffi.ptr(arg1) : ffi.ptr(arg1, arg2), toBuffer = ffi.toBuffer, toArrayBuffer = ffi.toArrayBuffer, viewSource = ffi.viewSource, BunCString = ffi.CString, nativeLinkSymbols = ffi.linkSymbols, nativeDLOpen = ffi.dlopen, nativeCallback = ffi.callback, closeCallback = ffi.closeCallback;\ndelete ffi.callback;\ndelete ffi.closeCallback;\n\nclass JSCallback {\n  constructor(cb, options) {\n    const { ctx, ptr: ptr2 } = nativeCallback(options, cb);\n    this.#ctx = ctx, this.ptr = ptr2, this.#threadsafe = !!options\?.threadsafe;\n  }\n  ptr;\n  #ctx;\n  #threadsafe;\n  get threadsafe() {\n    return this.#threadsafe;\n  }\n  [Symbol.toPrimitive]() {\n    const { ptr: ptr2 } = this;\n    return typeof ptr2 === \"number\" \? ptr2 : 0;\n  }\n  close() {\n    const ctx = this.#ctx;\n    if (this.ptr = null, this.#ctx = null, ctx)\n      closeCallback(ctx);\n  }\n}\n\nclass CString extends String {\n  constructor(ptr2, byteOffset, byteLength) {\n    super(ptr2 \? typeof byteLength === \"number\" && Number.isSafeInteger(byteLength) \? BunCString(ptr2, byteOffset || 0, byteLength) : BunCString(ptr2) : \"\");\n    if (this.ptr = typeof ptr2 === \"number\" \? ptr2 : 0, typeof byteOffset !== \"undefined\")\n      this.byteOffset = byteOffset;\n    if (typeof byteLength !== \"undefined\")\n      this.byteLength = byteLength;\n  }\n  ptr;\n  byteOffset;\n  byteLength;\n  #cachedArrayBuffer;\n  get arrayBuffer() {\n    if (this.#cachedArrayBuffer)\n      return this.#cachedArrayBuffer;\n    if (!this.ptr)\n      return this.#cachedArrayBuffer = new ArrayBuffer(0);\n    return this.#cachedArrayBuffer = toArrayBuffer(this.ptr, this.byteOffset, this.byteLength);\n  }\n}\nObject.defineProperty(globalThis, \"__GlobalBunCString\", {\n  value: CString,\n  enumerable: !1,\n  configurable: !1\n});\nvar ffiWrappers = new Array(18), char = \"val|0\";\nffiWrappers.fill(char);\nffiWrappers[FFIType.uint8_t] = \"val<0\?0:val>=255\?255:val|0\";\nffiWrappers[FFIType.int16_t] = \"val<=-32768\?-32768:val>=32768\?32768:val|0\";\nffiWrappers[FFIType.uint16_t] = \"val<=0\?0:val>=65536\?65536:val|0\";\nffiWrappers[FFIType.int32_t] = \"val|0\";\nffiWrappers[FFIType.uint32_t] = \"val<=0\?0:val>=0xffffffff\?0xffffffff:+val||0\";\nffiWrappers[FFIType.i64_fast] = `{\n  if (typeof val === \"bigint\") {\n    if (val <= BigInt(Number.MAX_SAFE_INTEGER) && val >= BigInt(-Number.MAX_SAFE_INTEGER)) {\n      return Number(val).valueOf() || 0;\n    }\n\n    return val;\n  }\n\n  return !val \? 0 : +val || 0;\n}`;\nffiWrappers[FFIType.i64_fast] = `{\n  if (typeof val === \"bigint\") {\n    if (val <= BigInt(Number.MAX_SAFE_INTEGER) && val >= BigInt(-Number.MAX_SAFE_INTEGER)) {\n      return Number(val).valueOf() || 0;\n    }\n\n    return val;\n  }\n\n  return !val \? 0 : +val || 0;\n}`;\nffiWrappers[FFIType.u64_fast] = `{\n  if (typeof val === \"bigint\") {\n    if (val <= BigInt(Number.MAX_SAFE_INTEGER) && val >= 0) {\n      return Number(val).valueOf() || 0;\n    }\n\n    return val;\n  }\n\n  return !val \? 0 : +val || 0;\n}`;\nffiWrappers[FFIType.int64_t] = `{\n  if (typeof val === \"bigint\") {\n    return val;\n  }\n\n  if (typeof val === \"number\") {\n    return BigInt(val || 0);\n  }\n\n  return BigInt(+val || 0);\n}`;\nffiWrappers[FFIType.uint64_t] = `{\n  if (typeof val === \"bigint\") {\n    return val;\n  }\n\n  if (typeof val === \"number\") {\n    return val <= 0 \? BigInt(0) : BigInt(val || 0);\n  }\n\n  return BigInt(+val || 0);\n}`;\nffiWrappers[FFIType.u64_fast] = `{\n  if (typeof val === \"bigint\") {\n    if (val <= BigInt(Number.MAX_SAFE_INTEGER) && val >= BigInt(0)) return Number(val);\n    return val;\n  }\n\n  return typeof val === \"number\" \? (val <= 0 \? 0 : +val || 0) : +val || 0;\n}`;\nffiWrappers[FFIType.uint16_t] = `{\n  const ret = (typeof val === \"bigint\" \? Number(val) : val) | 0;\n  return ret <= 0 \? 0 : ret > 0xffff \? 0xffff : ret;\n}`;\nffiWrappers[FFIType.double] = `{\n  if (typeof val === \"bigint\") {\n    if (val.valueOf() < BigInt(Number.MAX_VALUE)) {\n      return Math.abs(Number(val).valueOf()) + 0.00000000000001 - 0.00000000000001;\n    }\n  }\n\n  if (!val) {\n    return 0 + 0.00000000000001 - 0.00000000000001;\n  }\n\n  return val + 0.00000000000001 - 0.00000000000001;\n}`;\nffiWrappers[FFIType.float] = ffiWrappers[10] = `{\n  return Math.fround(val);\n}`;\nffiWrappers[FFIType.bool] = `{\n  return !!val;\n}`;\nObject.defineProperty(globalThis, \"__GlobalBunFFIPtrFunctionForWrapper\", {\n  value: ptr,\n  enumerable: !1,\n  configurable: !0\n});\nffiWrappers[FFIType.cstring] = ffiWrappers[FFIType.pointer] = `{\n  if (typeof val === \"number\") return val;\n  if (!val) {\n    return null;\n  }\n\n  if (ArrayBuffer.isView(val) || val instanceof ArrayBuffer) {\n    return __GlobalBunFFIPtrFunctionForWrapper(val);\n  }\n\n  if (typeof val === \"string\") {\n    throw new TypeError(\"To convert a string to a pointer, encode it as a buffer\");\n  }\n\n  throw new TypeError(\\`Unable to convert \\${ val } to a pointer\\`);\n}`;\nffiWrappers[FFIType.function] = `{\n  if (typeof val === \"number\") {\n    return val;\n  }\n\n  if (typeof val === \"bigint\") {\n    return Number(val);\n  }\n\n  var ptr = val && val.ptr;\n\n  if (!ptr) {\n    throw new TypeError(\"Expected function to be a JSCallback or a number\");\n  }\n\n  return ptr;\n}`;\nvar native = {\n  dlopen: nativeDLOpen,\n  callback: () => {\n    throw new Error(\"Deprecated. Use new JSCallback(options, fn) instead\");\n  }\n}, cFunctionI = 0, cFunctionRegistry, read = ffi.read;\n$ = {\n  CFunction,\n  CString,\n  FFIType,\n  JSCallback,\n  dlopen,\n  linkSymbols,\n  native,\n  ptr,\n  read,\n  suffix: \"so\",\n  toArrayBuffer,\n  toBuffer,\n  viewSource\n};\nreturn $})\n"_s;
//

//
static constexpr ASCIILiteral BunSqliteCode = "(function (){\"use strict\";// src/js/out/tmp/bun/sqlite.ts\nvar $, defineProperties = Object.defineProperties, toStringTag = Symbol.toStringTag, isArray = Array.isArray, isTypedArray = ArrayBuffer.isView, constants = {\n  SQLITE_OPEN_READONLY: 1,\n  SQLITE_OPEN_READWRITE: 2,\n  SQLITE_OPEN_CREATE: 4,\n  SQLITE_OPEN_DELETEONCLOSE: 8,\n  SQLITE_OPEN_EXCLUSIVE: 16,\n  SQLITE_OPEN_AUTOPROXY: 32,\n  SQLITE_OPEN_URI: 64,\n  SQLITE_OPEN_MEMORY: 128,\n  SQLITE_OPEN_MAIN_DB: 256,\n  SQLITE_OPEN_TEMP_DB: 512,\n  SQLITE_OPEN_TRANSIENT_DB: 1024,\n  SQLITE_OPEN_MAIN_JOURNAL: 2048,\n  SQLITE_OPEN_TEMP_JOURNAL: 4096,\n  SQLITE_OPEN_SUBJOURNAL: 8192,\n  SQLITE_OPEN_SUPER_JOURNAL: 16384,\n  SQLITE_OPEN_NOMUTEX: 32768,\n  SQLITE_OPEN_FULLMUTEX: 65536,\n  SQLITE_OPEN_SHAREDCACHE: 131072,\n  SQLITE_OPEN_PRIVATECACHE: 262144,\n  SQLITE_OPEN_WAL: 524288,\n  SQLITE_OPEN_NOFOLLOW: 16777216,\n  SQLITE_OPEN_EXRESCODE: 33554432,\n  SQLITE_PREPARE_PERSISTENT: 1,\n  SQLITE_PREPARE_NORMALIZE: 2,\n  SQLITE_PREPARE_NO_VTAB: 4\n}, SQL, controllers;\n\nclass Statement {\n  constructor(raw) {\n    switch (this.#raw = raw, raw.paramsCount) {\n      case 0: {\n        this.get = this.#getNoArgs, this.all = this.#allNoArgs, this.values = this.#valuesNoArgs, this.run = this.#runNoArgs;\n        break;\n      }\n      default: {\n        this.get = this.#get, this.all = this.#all, this.values = this.#values, this.run = this.#run;\n        break;\n      }\n    }\n  }\n  #raw;\n  get;\n  all;\n  values;\n  run;\n  isFinalized = !1;\n  toJSON() {\n    return {\n      sql: this.native.toString(),\n      isFinalized: this.isFinalized,\n      paramsCount: this.paramsCount,\n      columnNames: this.columnNames\n    };\n  }\n  get [toStringTag]() {\n    return `\"${this.native.toString()}\"`;\n  }\n  toString() {\n    return this.native.toString();\n  }\n  get native() {\n    return this.#raw;\n  }\n  #getNoArgs() {\n    return this.#raw.get();\n  }\n  #allNoArgs() {\n    return this.#raw.all();\n  }\n  #valuesNoArgs() {\n    return this.#raw.values();\n  }\n  #runNoArgs() {\n    this.#raw.run();\n  }\n  #get(...args) {\n    if (args.length === 0)\n      return this.#getNoArgs();\n    var arg0 = args[0];\n    return !isArray(arg0) && (!arg0 || typeof arg0 !== \"object\" || isTypedArray(arg0)) \? this.#raw.get(args) : this.#raw.get(...args);\n  }\n  #all(...args) {\n    if (args.length === 0)\n      return this.#allNoArgs();\n    var arg0 = args[0];\n    return !isArray(arg0) && (!arg0 || typeof arg0 !== \"object\" || isTypedArray(arg0)) \? this.#raw.all(args) : this.#raw.all(...args);\n  }\n  #values(...args) {\n    if (args.length === 0)\n      return this.#valuesNoArgs();\n    var arg0 = args[0];\n    return !isArray(arg0) && (!arg0 || typeof arg0 !== \"object\" || isTypedArray(arg0)) \? this.#raw.values(args) : this.#raw.values(...args);\n  }\n  #run(...args) {\n    if (args.length === 0)\n      return this.#runNoArgs();\n    var arg0 = args[0];\n    !isArray(arg0) && (!arg0 || typeof arg0 !== \"object\" || isTypedArray(arg0)) \? this.#raw.run(args) : this.#raw.run(...args);\n  }\n  get columnNames() {\n    return this.#raw.columns;\n  }\n  get paramsCount() {\n    return this.#raw.paramsCount;\n  }\n  finalize(...args) {\n    return this.isFinalized = !0, this.#raw.finalize(...args);\n  }\n}\nvar cachedCount = Symbol.for(\"Bun.Database.cache.count\");\n\nclass Database {\n  constructor(filenameGiven, options) {\n    if (typeof filenameGiven === \"undefined\")\n      ;\n    else if (typeof filenameGiven !== \"string\") {\n      if (isTypedArray(filenameGiven)) {\n        this.#handle = Database.deserialize(filenameGiven, typeof options === \"object\" && options \? !!options.readonly : ((options | 0) & constants.SQLITE_OPEN_READONLY) != 0), this.filename = \":memory:\";\n        return;\n      }\n      @throwTypeError(`Expected 'filename' to be a string, got '${typeof filenameGiven}'`);\n    }\n    var filename = typeof filenameGiven === \"string\" \? filenameGiven.trim() : \":memory:\", flags = constants.SQLITE_OPEN_READWRITE | constants.SQLITE_OPEN_CREATE;\n    if (typeof options === \"object\" && options) {\n      if (flags = 0, options.readonly)\n        flags = constants.SQLITE_OPEN_READONLY;\n      if (\"readOnly\" in options)\n        @throwTypeError('Misspelled option \"readOnly\" should be \"readonly\"');\n      if (options.create)\n        flags = constants.SQLITE_OPEN_READWRITE | constants.SQLITE_OPEN_CREATE;\n      if (options.readwrite)\n        flags |= constants.SQLITE_OPEN_READWRITE;\n    } else if (typeof options === \"number\")\n      flags = options;\n    const anonymous = filename === \"\" || filename === \":memory:\";\n    if (anonymous && (flags & constants.SQLITE_OPEN_READONLY) !== 0)\n      throw new Error(\"Cannot open an anonymous database in read-only mode.\");\n    if (!SQL)\n      SQL = globalThis[globalThis.Symbol.for('Bun.lazy')](\"sqlite\");\n    this.#handle = SQL.open(anonymous \? \":memory:\" : filename, flags), this.filename = filename;\n  }\n  #handle;\n  #cachedQueriesKeys = [];\n  #cachedQueriesLengths = [];\n  #cachedQueriesValues = [];\n  filename;\n  get handle() {\n    return this.#handle;\n  }\n  get inTransaction() {\n    return SQL.isInTransaction(this.#handle);\n  }\n  static open(filename, options) {\n    return new Database(filename, options);\n  }\n  loadExtension(name, entryPoint) {\n    return SQL.loadExtension(this.#handle, name, entryPoint);\n  }\n  serialize(optionalName) {\n    return SQL.serialize(this.#handle, optionalName || \"main\");\n  }\n  static deserialize(serialized, isReadOnly = !1) {\n    if (!SQL)\n      SQL = globalThis[globalThis.Symbol.for('Bun.lazy')](\"sqlite\");\n    return SQL.deserialize(serialized, isReadOnly);\n  }\n  static setCustomSQLite(path) {\n    if (!SQL)\n      SQL = globalThis[globalThis.Symbol.for('Bun.lazy')](\"sqlite\");\n    return SQL.setCustomSQLite(path);\n  }\n  close() {\n    return this.clearQueryCache(), SQL.close(this.#handle);\n  }\n  clearQueryCache() {\n    for (let item of this.#cachedQueriesValues)\n      item.finalize();\n    this.#cachedQueriesKeys.length = 0, this.#cachedQueriesValues.length = 0, this.#cachedQueriesLengths.length = 0;\n  }\n  run(query, ...params) {\n    if (params.length === 0) {\n      SQL.run(this.#handle, query);\n      return;\n    }\n    var arg0 = params[0];\n    return !isArray(arg0) && (!arg0 || typeof arg0 !== \"object\" || isTypedArray(arg0)) \? SQL.run(this.#handle, query, params) : SQL.run(this.#handle, query, ...params);\n  }\n  prepare(query, params, flags) {\n    return new Statement(SQL.prepare(this.#handle, query, params, flags || 0));\n  }\n  static MAX_QUERY_CACHE_SIZE = 20;\n  get [cachedCount]() {\n    return this.#cachedQueriesKeys.length;\n  }\n  query(query) {\n    if (typeof query !== \"string\")\n      @throwTypeError(`Expected 'query' to be a string, got '${typeof query}'`);\n    if (query.length === 0)\n      throw new Error(\"SQL query cannot be empty.\");\n    var index = this.#cachedQueriesLengths.indexOf(query.length);\n    while (index !== -1) {\n      if (this.#cachedQueriesKeys[index] !== query) {\n        index = this.#cachedQueriesLengths.indexOf(query.length, index + 1);\n        continue;\n      }\n      var stmt = this.#cachedQueriesValues[index];\n      if (stmt.isFinalized)\n        return this.#cachedQueriesValues[index] = this.prepare(query, void 0, willCache \? constants.SQLITE_PREPARE_PERSISTENT : 0);\n      return stmt;\n    }\n    const willCache = this.#cachedQueriesKeys.length < Database.MAX_QUERY_CACHE_SIZE;\n    var stmt = this.prepare(query, void 0, willCache \? constants.SQLITE_PREPARE_PERSISTENT : 0);\n    if (willCache)\n      this.#cachedQueriesKeys.push(query), this.#cachedQueriesLengths.push(query.length), this.#cachedQueriesValues.push(stmt);\n    return stmt;\n  }\n  transaction(fn, self) {\n    if (typeof fn !== \"function\")\n      @throwTypeError(\"Expected first argument to be a function\");\n    const db = this, controller = getController(db, self), properties = {\n      default: { value: wrapTransaction(fn, db, controller.default) },\n      deferred: { value: wrapTransaction(fn, db, controller.deferred) },\n      immediate: {\n        value: wrapTransaction(fn, db, controller.immediate)\n      },\n      exclusive: {\n        value: wrapTransaction(fn, db, controller.exclusive)\n      },\n      database: { value: this, enumerable: !0 }\n    };\n    return defineProperties(properties.default.value, properties), defineProperties(properties.deferred.value, properties), defineProperties(properties.immediate.value, properties), defineProperties(properties.exclusive.value, properties), properties.default.value;\n  }\n}\nDatabase.prototype.exec = Database.prototype.run;\nvar getController = (db, self) => {\n  let controller = (controllers ||= new WeakMap).get(db);\n  if (!controller) {\n    const shared = {\n      commit: db.prepare(\"COMMIT\", void 0, 0),\n      rollback: db.prepare(\"ROLLBACK\", void 0, 0),\n      savepoint: db.prepare(\"SAVEPOINT `\\t_bs3.\\t`\", void 0, 0),\n      release: db.prepare(\"RELEASE `\\t_bs3.\\t`\", void 0, 0),\n      rollbackTo: db.prepare(\"ROLLBACK TO `\\t_bs3.\\t`\", void 0, 0)\n    };\n    controllers.set(db, controller = {\n      default: Object.assign({ begin: db.prepare(\"BEGIN\", void 0, 0) }, shared),\n      deferred: Object.assign({ begin: db.prepare(\"BEGIN DEFERRED\", void 0, 0) }, shared),\n      immediate: Object.assign({ begin: db.prepare(\"BEGIN IMMEDIATE\", void 0, 0) }, shared),\n      exclusive: Object.assign({ begin: db.prepare(\"BEGIN EXCLUSIVE\", void 0, 0) }, shared)\n    });\n  }\n  return controller;\n}, wrapTransaction = (fn, db, { begin, commit, rollback, savepoint, release, rollbackTo }) => function transaction(...args) {\n  let before, after, undo;\n  if (db.inTransaction)\n    before = savepoint, after = release, undo = rollbackTo;\n  else\n    before = begin, after = commit, undo = rollback;\n  try {\n    before.run();\n    const result = fn.apply(this, args);\n    return after.run(), result;\n  } catch (ex) {\n    if (db.inTransaction) {\n      if (undo.run(), undo !== rollback)\n        after.run();\n    }\n    throw ex;\n  }\n};\n$ = {\n  __esModule: !0,\n  Database,\n  Statement,\n  constants,\n  default: Database\n};\nreturn $})\n"_s;
//

//
static constexpr ASCIILiteral InternalDebuggerCode = "(function (){\"use strict\";// src/js/out/tmp/internal/debugger.ts\nvar generatePath = function() {\n  if (!generatedPath)\n    generatedPath = \"/\" + Math.random().toString(36).slice(2);\n  return generatedPath;\n}, terminalLink = function(url) {\n  if (Bun.enableANSIColors)\n    return \"\\x1B[1m\\x1B]8;;\" + url + \"\\x1B\\\\\" + url + \"\\x1B]8;;\\x1B\\\\\" + \"\\x1B[22m\";\n  return url;\n}, dim = function(text) {\n  if (Bun.enableANSIColors)\n    return \"\\x1B[2m\" + text + \"\\x1B[22m\";\n  return text;\n}, $, sendFn_, disconnectFn_, debuggerCounter = 1;\n\nclass DebuggerWithMessageQueue {\n  debugger = void 0;\n  messageQueue = [];\n  count = debuggerCounter++;\n  send(msg) {\n    sendFn_.call(this.debugger, msg);\n  }\n  disconnect() {\n    disconnectFn_.call(this.debugger), this.messageQueue.length = 0;\n  }\n}\nvar defaultPort = 6499, generatedPath = \"\";\n\nclass WebSocketListener {\n  server;\n  url = \"\";\n  createInspectorConnection;\n  scriptExecutionContextId = 0;\n  activeConnections = new Set;\n  constructor(scriptExecutionContextId = 0, url, createInspectorConnection) {\n    this.scriptExecutionContextId = scriptExecutionContextId, this.createInspectorConnection = createInspectorConnection, this.server = this.start(url);\n  }\n  start(url) {\n    let defaultHostname = \"localhost\", usingDefaultPort = !1;\n    if (/^[0-9]*$/.test(url))\n      url = \"ws://\" + defaultHostname + \":\" + url + generatePath();\n    else if (!url || url.startsWith(\"/\"))\n      url = \"ws://\" + defaultHostname + \":\" + defaultPort + generatePath(), usingDefaultPort = !0;\n    else if (url.includes(\":\") && !url.includes(\"://\"))\n      try {\n        const insertSlash = !url.includes(\"/\");\n        if (url = new URL(\"ws://\" + url).href, insertSlash)\n          url += generatePath().slice(1);\n      } catch (e) {\n        console.error(\"[Inspector]\", \"Failed to parse url\", '\"' + url + '\"'), process.exit(1);\n      }\n    try {\n      var { hostname, port, pathname } = new URL(url);\n      this.url = pathname.toLowerCase();\n    } catch (e) {\n      console.error(\"[Inspector]\", \"Failed to parse url\", '\"' + url + '\"'), process.exit(1);\n    }\n    const serveOptions = {\n      hostname,\n      development: !1,\n      reusePort: !1,\n      websocket: {\n        idleTimeout: 0,\n        open: (socket) => {\n          var connection = new DebuggerWithMessageQueue;\n          const shouldRefEventLoop = !!socket.data\?.shouldRefEventLoop;\n          socket.data = connection, this.activeConnections.add(socket), connection.debugger = this.createInspectorConnection(this.scriptExecutionContextId, shouldRefEventLoop, (...msgs) => {\n            if (socket.readyState > 1) {\n              connection.disconnect();\n              return;\n            }\n            if (connection.messageQueue.length > 0) {\n              connection.messageQueue.push(...msgs);\n              return;\n            }\n            for (let i = 0;i < msgs.length; i++)\n              if (!socket.sendText(msgs[i])) {\n                if (socket.readyState < 2)\n                  connection.messageQueue.push(...msgs.slice(i));\n                return;\n              }\n          }), console.log(\"[Inspector]\", \"Connection #\" + connection.count + \" opened\", \"(\" + new Intl.DateTimeFormat(void 0, {\n            timeStyle: \"long\",\n            dateStyle: \"short\"\n          }).format(new Date) + \")\");\n        },\n        drain: (socket) => {\n          const queue = socket.data.messageQueue;\n          for (let i = 0;i < queue.length; i++)\n            if (!socket.sendText(queue[i])) {\n              socket.data.messageQueue = queue.slice(i);\n              return;\n            }\n          queue.length = 0;\n        },\n        message: (socket, message) => {\n          if (typeof message !== \"string\") {\n            console.warn(\"[Inspector]\", \"Received non-string message\");\n            return;\n          }\n          socket.data.send(message);\n        },\n        close: (socket) => {\n          socket.data.disconnect(), console.log(\"[Inspector]\", \"Connection #\" + socket.data.count + \" closed\", \"(\" + new Intl.DateTimeFormat(void 0, {\n            timeStyle: \"long\",\n            dateStyle: \"short\"\n          }).format(new Date) + \")\"), this.activeConnections.delete(socket);\n        }\n      },\n      fetch: (req, server2) => {\n        let { pathname: pathname2 } = new URL(req.url);\n        if (pathname2 = pathname2.toLowerCase(), pathname2 === \"/json/version\")\n          return Response.json({\n            Browser: navigator.userAgent,\n            \"WebKit-Version\": process.versions.webkit,\n            \"Bun-Version\": Bun.version,\n            \"Bun-Revision\": Bun.revision\n          });\n        if (pathname2 === this.url) {\n          const refHeader = req.headers.get(\"Ref-Event-Loop\");\n          if (server2.upgrade(req, {\n            data: {\n              shouldRefEventLoop: !!refHeader && refHeader !== \"0\"\n            }\n          }))\n            return new Response;\n          return new Response(\"WebSocket expected\", {\n            status: 400\n          });\n        }\n        return new Response(\"Not found\", {\n          status: 404\n        });\n      }\n    };\n    if (port === \"\")\n      port = defaultPort + \"\";\n    let portNumber = Number(port);\n    var server, lastError;\n    if (usingDefaultPort)\n      for (let tries = 0;tries < 10 && !server; tries++)\n        try {\n          lastError = void 0, server = Bun.serve({\n            ...serveOptions,\n            port: portNumber++\n          });\n        } catch (e) {\n          lastError = e;\n        }\n    else\n      try {\n        server = Bun.serve({\n          ...serveOptions,\n          port: portNumber\n        });\n      } catch (e) {\n        lastError = e;\n      }\n    if (!server) {\n      if (console.error(\"[Inspector]\", \"Failed to start server\"), lastError)\n        console.error(lastError);\n      process.exit(1);\n    }\n    let textToWrite = \"\";\n    function writeToConsole(text) {\n      textToWrite += text;\n    }\n    function flushToConsole() {\n      console.write(textToWrite);\n    }\n    return writeToConsole(dim(\"------------------ Bun Inspector ------------------\\n\")), writeToConsole(\"\\x1B[49m\"), writeToConsole(\"Listening at:\\n  \" + `ws://${hostname}:${server.port}${this.url}` + \"\\n\\nInspect in browser:\\n  \" + terminalLink(new URL(`https://debug.bun.sh#${server.hostname}:${server.port}${this.url}`).href) + \"\\n\"), writeToConsole(dim(\"------------------ Bun Inspector ------------------\\n\")), flushToConsole(), server;\n  }\n}\nvar listener;\n$ = function start(debuggerId, hostOrPort, createInspectorConnection, sendFn, disconnectFn) {\n  try {\n    sendFn_ = sendFn, disconnectFn_ = disconnectFn, globalThis.listener = listener ||= new WebSocketListener(debuggerId, hostOrPort, createInspectorConnection);\n  } catch (e) {\n    console.error(\"Bun Inspector threw an exception\\n\", e), process.exit(1);\n  }\n  return `http://${listener.server.hostname}:${listener.server.port}${listener.url}`;\n};\nreturn $})\n"_s;
//

//
static constexpr ASCIILiteral InternalSharedCode = "(function (){\"use strict\";// src/js/out/tmp/internal/shared.ts\nvar throwNotImplemented = function(feature, issue) {\n  throw hideFromStack(throwNotImplemented), new NotImplementedError(feature, issue);\n}, hideFromStack = function(...fns) {\n  for (let fn of fns)\n    Object.defineProperty(fn, \"name\", {\n      value: \"::bunternal::\"\n    });\n}, $;\n\nclass NotImplementedError extends Error {\n  code;\n  constructor(feature, issue) {\n    super(feature + \" is not yet implemented in Bun.\" + (issue \? \" Track the status & thumbs up the issue: https://github.com/oven-sh/bun/issues/\" + issue : \"\"));\n    this.name = \"NotImplementedError\", this.code = \"ERR_NOT_IMPLEMENTED\", hideFromStack(NotImplementedError);\n  }\n}\n$ = {\n  NotImplementedError,\n  throwNotImplemented,\n  hideFromStack\n};\nreturn $})\n"_s;
//

//
static constexpr ASCIILiteral NodeAssertCode = "(function (){\"use strict\";// src/js/out/tmp/node/assert.ts\nvar CallTracker = function() {\n  throw new Error(\"CallTracker is not supported yet\");\n}, util = @getInternalField(@internalModuleRegistry, 43) || @createInternalModuleById(43), isDeepEqual = Bun.deepEquals, __commonJS = (cb, mod) => function() {\n  return mod || (0, cb[Object.keys(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;\n}, require_errors = __commonJS({\n  \"assert/build/internal/errors.js\"(exports, module2) {\n    function _typeof(obj) {\n      return typeof Symbol == \"function\" && typeof Symbol.iterator == \"symbol\" \? _typeof = function(obj2) {\n        return typeof obj2;\n      } : _typeof = function(obj2) {\n        return obj2 && typeof Symbol == \"function\" && obj2.constructor === Symbol && obj2 !== Symbol.prototype \? \"symbol\" : typeof obj2;\n      }, _typeof(obj);\n    }\n    function _classCallCheck(instance, Constructor) {\n      if (!(instance instanceof Constructor))\n        @throwTypeError(\"Cannot call a class as a function\");\n    }\n    function _possibleConstructorReturn(self, call) {\n      return call && (_typeof(call) === \"object\" || typeof call == \"function\") \? call : _assertThisInitialized(self);\n    }\n    function _assertThisInitialized(self) {\n      if (self === void 0)\n        throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n      return self;\n    }\n    function _getPrototypeOf(o) {\n      return _getPrototypeOf = Object.setPrototypeOf \? Object.getPrototypeOf : function(o2) {\n        return o2.__proto__ || Object.getPrototypeOf(o2);\n      }, _getPrototypeOf(o);\n    }\n    function _inherits(subClass, superClass) {\n      if (typeof superClass != \"function\" && superClass !== null)\n        @throwTypeError(\"Super expression must either be null or a function\");\n      subClass.prototype = Object.create(superClass && superClass.prototype, {\n        constructor: { value: subClass, writable: !0, configurable: !0 }\n      }), superClass && _setPrototypeOf(subClass, superClass);\n    }\n    function _setPrototypeOf(o, p) {\n      return _setPrototypeOf = Object.setPrototypeOf || function(o2, p2) {\n        return o2.__proto__ = p2, o2;\n      }, _setPrototypeOf(o, p);\n    }\n    var codes = {}, assert, util2;\n    function createErrorType(code, message, Base) {\n      Base || (Base = Error);\n      function getMessage(arg1, arg2, arg3) {\n        return typeof message == \"string\" \? message : message(arg1, arg2, arg3);\n      }\n      var NodeError = function(_Base) {\n        _inherits(NodeError2, _Base);\n        function NodeError2(arg1, arg2, arg3) {\n          var _this;\n          return _classCallCheck(this, NodeError2), _this = _possibleConstructorReturn(this, _getPrototypeOf(NodeError2).call(this, getMessage(arg1, arg2, arg3))), _this.code = code, _this;\n        }\n        return NodeError2;\n      }(Base);\n      codes[code] = NodeError;\n    }\n    function oneOf(expected, thing) {\n      if (Array.isArray(expected)) {\n        var len = expected.length;\n        return expected = expected.map(function(i) {\n          return String(i);\n        }), len > 2 \? \"one of \".concat(thing, \" \").concat(expected.slice(0, len - 1).join(\", \"), \", or \") + expected[len - 1] : len === 2 \? \"one of \".concat(thing, \" \").concat(expected[0], \" or \").concat(expected[1]) : \"of \".concat(thing, \" \").concat(expected[0]);\n      } else\n        return \"of \".concat(thing, \" \").concat(String(expected));\n    }\n    function startsWith(str, search, pos) {\n      return str.substr(!pos || pos < 0 \? 0 : +pos, search.length) === search;\n    }\n    function endsWith(str, search, this_len) {\n      return (this_len === void 0 || this_len > str.length) && (this_len = str.length), str.substring(this_len - search.length, this_len) === search;\n    }\n    function includes(str, search, start) {\n      return typeof start != \"number\" && (start = 0), start + search.length > str.length \? !1 : str.indexOf(search, start) !== -1;\n    }\n    createErrorType(\"ERR_AMBIGUOUS_ARGUMENT\", 'The \"%s\" argument is ambiguous. %s', TypeError), createErrorType(\"ERR_INVALID_ARG_TYPE\", function(name, expected, actual) {\n      assert === void 0 && (assert = require_assert()), assert(typeof name == \"string\", \"'name' must be a string\");\n      var determiner;\n      typeof expected == \"string\" && startsWith(expected, \"not \") \? (determiner = \"must not be\", expected = expected.replace(/^not /, \"\")) : determiner = \"must be\";\n      var msg;\n      if (endsWith(name, \" argument\"))\n        msg = \"The \".concat(name, \" \").concat(determiner, \" \").concat(oneOf(expected, \"type\"));\n      else {\n        var type = includes(name, \".\") \? \"property\" : \"argument\";\n        msg = 'The \"'.concat(name, '\" ').concat(type, \" \").concat(determiner, \" \").concat(oneOf(expected, \"type\"));\n      }\n      return msg += \". Received type \".concat(_typeof(actual)), msg;\n    }, TypeError), createErrorType(\"ERR_INVALID_ARG_VALUE\", function(name, value) {\n      var reason = arguments.length > 2 && arguments[2] !== void 0 \? arguments[2] : \"is invalid\", inspected = util2.inspect(value);\n      return inspected.length > 128 && (inspected = \"\".concat(inspected.slice(0, 128), \"...\")), \"The argument '\".concat(name, \"' \").concat(reason, \". Received \").concat(inspected);\n    }, TypeError, RangeError), createErrorType(\"ERR_INVALID_RETURN_VALUE\", function(input, name, value) {\n      var type;\n      return value && value.constructor && value.constructor.name \? type = \"instance of \".concat(value.constructor.name) : type = \"type \".concat(_typeof(value)), \"Expected \".concat(input, ' to be returned from the \"').concat(name, '\"') + \" function but got \".concat(type, \".\");\n    }, TypeError), createErrorType(\"ERR_MISSING_ARGS\", function() {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0;_key < _len; _key++)\n        args[_key] = arguments[_key];\n      assert === void 0 && (assert = require_assert()), assert(args.length > 0, \"At least one arg needs to be specified\");\n      var msg = \"The \", len = args.length;\n      switch (args = args.map(function(a) {\n        return '\"'.concat(a, '\"');\n      }), len) {\n        case 1:\n          msg += \"\".concat(args[0], \" argument\");\n          break;\n        case 2:\n          msg += \"\".concat(args[0], \" and \").concat(args[1], \" arguments\");\n          break;\n        default:\n          msg += args.slice(0, len - 1).join(\", \"), msg += \", and \".concat(args[len - 1], \" arguments\");\n          break;\n      }\n      return \"\".concat(msg, \" must be specified\");\n    }, TypeError), module2.exports.codes = codes;\n  }\n}), require_assertion_error = __commonJS({\n  \"assert/build/internal/assert/assertion_error.js\"(exports, module2) {\n    function _objectSpread(target) {\n      for (var i = 1;i < arguments.length; i++) {\n        var source = arguments[i] != null \? arguments[i] : {}, ownKeys = Object.keys(source);\n        typeof Object.getOwnPropertySymbols == \"function\" && (ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {\n          return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n        }))), ownKeys.forEach(function(key) {\n          _defineProperty(target, key, source[key]);\n        });\n      }\n      return target;\n    }\n    function _defineProperty(obj, key, value) {\n      return (key in obj) \? Object.defineProperty(obj, key, {\n        value,\n        enumerable: !0,\n        configurable: !0,\n        writable: !0\n      }) : obj[key] = value, obj;\n    }\n    function _classCallCheck(instance, Constructor) {\n      if (!(instance instanceof Constructor))\n        @throwTypeError(\"Cannot call a class as a function\");\n    }\n    function _defineProperties(target, props) {\n      for (var i = 0;i < props.length; i++) {\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, (\"value\" in descriptor) && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);\n      }\n    }\n    function _createClass(Constructor, protoProps, staticProps) {\n      return protoProps && _defineProperties(Constructor.prototype, protoProps), staticProps && _defineProperties(Constructor, staticProps), Constructor;\n    }\n    function _possibleConstructorReturn(self, call) {\n      return call && (_typeof(call) === \"object\" || typeof call == \"function\") \? call : _assertThisInitialized(self);\n    }\n    function _assertThisInitialized(self) {\n      if (self === void 0)\n        throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n      return self;\n    }\n    function _inherits(subClass, superClass) {\n      if (typeof superClass != \"function\" && superClass !== null)\n        @throwTypeError(\"Super expression must either be null or a function\");\n      subClass.prototype = Object.create(superClass && superClass.prototype, {\n        constructor: { value: subClass, writable: !0, configurable: !0 }\n      }), superClass && _setPrototypeOf(subClass, superClass);\n    }\n    function _wrapNativeSuper(Class) {\n      var _cache = typeof Map == \"function\" \? new Map : void 0;\n      return _wrapNativeSuper = function(Class2) {\n        if (Class2 === null || !_isNativeFunction(Class2))\n          return Class2;\n        if (typeof Class2 != \"function\")\n          @throwTypeError(\"Super expression must either be null or a function\");\n        if (typeof _cache != \"undefined\") {\n          if (_cache.has(Class2))\n            return _cache.get(Class2);\n          _cache.set(Class2, Wrapper);\n        }\n        function Wrapper() {\n          return _construct(Class2, arguments, _getPrototypeOf(this).constructor);\n        }\n        return Wrapper.prototype = Object.create(Class2.prototype, {\n          constructor: {\n            value: Wrapper,\n            enumerable: !1,\n            writable: !0,\n            configurable: !0\n          }\n        }), _setPrototypeOf(Wrapper, Class2);\n      }, _wrapNativeSuper(Class);\n    }\n    function isNativeReflectConstruct() {\n      if (typeof Reflect == \"undefined\" || !Reflect.construct || Reflect.construct.sham)\n        return !1;\n      if (typeof Proxy == \"function\")\n        return !0;\n      try {\n        return Date.prototype.toString.call(Reflect.construct(Date, [], function() {\n        })), !0;\n      } catch {\n        return !1;\n      }\n    }\n    function _construct(Parent, args, Class) {\n      return isNativeReflectConstruct() \? _construct = Reflect.construct : _construct = function(Parent2, args2, Class2) {\n        var a = [null];\n        a.push.apply(a, args2);\n        var Constructor = Function.bind.apply(Parent2, a), instance = new Constructor;\n        return Class2 && _setPrototypeOf(instance, Class2.prototype), instance;\n      }, _construct.apply(null, arguments);\n    }\n    function _isNativeFunction(fn) {\n      return Function.toString.call(fn).indexOf(\"[native code]\") !== -1;\n    }\n    function _setPrototypeOf(o, p) {\n      return _setPrototypeOf = Object.setPrototypeOf || function(o2, p2) {\n        return o2.__proto__ = p2, o2;\n      }, _setPrototypeOf(o, p);\n    }\n    function _getPrototypeOf(o) {\n      return _getPrototypeOf = Object.setPrototypeOf \? Object.getPrototypeOf : function(o2) {\n        return o2.__proto__ || Object.getPrototypeOf(o2);\n      }, _getPrototypeOf(o);\n    }\n    function _typeof(obj) {\n      return typeof Symbol == \"function\" && typeof Symbol.iterator == \"symbol\" \? _typeof = function(obj2) {\n        return typeof obj2;\n      } : _typeof = function(obj2) {\n        return obj2 && typeof Symbol == \"function\" && obj2.constructor === Symbol && obj2 !== Symbol.prototype \? \"symbol\" : typeof obj2;\n      }, _typeof(obj);\n    }\n    var inspect = util.inspect, _require2 = require_errors(), ERR_INVALID_ARG_TYPE = _require2.codes.ERR_INVALID_ARG_TYPE;\n    function endsWith(str, search, this_len) {\n      return (this_len === void 0 || this_len > str.length) && (this_len = str.length), str.substring(this_len - search.length, this_len) === search;\n    }\n    function repeat(str, count) {\n      if (count = Math.floor(count), str.length == 0 || count == 0)\n        return \"\";\n      var maxCount = str.length * count;\n      for (count = Math.floor(Math.log(count) / Math.log(2));count; )\n        str += str, count--;\n      return str += str.substring(0, maxCount - str.length), str;\n    }\n    var blue = \"\", green = \"\", red = \"\", white = \"\", kReadableOperator = {\n      deepStrictEqual: \"Expected values to be strictly deep-equal:\",\n      strictEqual: \"Expected values to be strictly equal:\",\n      strictEqualObject: 'Expected \"actual\" to be reference-equal to \"expected\":',\n      deepEqual: \"Expected values to be loosely deep-equal:\",\n      equal: \"Expected values to be loosely equal:\",\n      notDeepStrictEqual: 'Expected \"actual\" not to be strictly deep-equal to:',\n      notStrictEqual: 'Expected \"actual\" to be strictly unequal to:',\n      notStrictEqualObject: 'Expected \"actual\" not to be reference-equal to \"expected\":',\n      notDeepEqual: 'Expected \"actual\" not to be loosely deep-equal to:',\n      notEqual: 'Expected \"actual\" to be loosely unequal to:',\n      notIdentical: \"Values identical but not reference-equal:\"\n    }, kMaxShortLength = 10;\n    function copyError(source) {\n      var keys = Object.keys(source), target = Object.create(Object.getPrototypeOf(source));\n      return keys.forEach(function(key) {\n        target[key] = source[key];\n      }), Object.defineProperty(target, \"message\", {\n        value: source.message\n      }), target;\n    }\n    function inspectValue(val) {\n      return inspect(val, {\n        compact: !1,\n        customInspect: !1,\n        depth: 1000,\n        maxArrayLength: Infinity,\n        showHidden: !1,\n        breakLength: Infinity,\n        showProxy: !1,\n        sorted: !0,\n        getters: !0\n      });\n    }\n    function createErrDiff(actual, expected, operator) {\n      var other = \"\", res = \"\", lastPos = 0, end = \"\", skipped = !1, actualInspected = inspectValue(actual), actualLines = actualInspected.split(`\n`), expectedLines = inspectValue(expected).split(`\n`), i = 0, indicator = \"\";\n      if (operator === \"strictEqual\" && _typeof(actual) === \"object\" && _typeof(expected) === \"object\" && actual !== null && expected !== null && (operator = \"strictEqualObject\"), actualLines.length === 1 && expectedLines.length === 1 && actualLines[0] !== expectedLines[0]) {\n        var inputLength = actualLines[0].length + expectedLines[0].length;\n        if (inputLength <= kMaxShortLength) {\n          if ((_typeof(actual) !== \"object\" || actual === null) && (_typeof(expected) !== \"object\" || expected === null) && (actual !== 0 || expected !== 0))\n            return \"\".concat(kReadableOperator[operator], `\n\n`) + \"\".concat(actualLines[0], \" !== \").concat(expectedLines[0], `\n`);\n        } else if (operator !== \"strictEqualObject\") {\n          var maxLength = process.stderr && process.stderr.isTTY \? process.stderr.columns : 80;\n          if (inputLength < maxLength) {\n            for (;actualLines[0][i] === expectedLines[0][i]; )\n              i++;\n            i > 2 && (indicator = `\n  `.concat(repeat(\" \", i), \"^\"), i = 0);\n          }\n        }\n      }\n      for (var a = actualLines[actualLines.length - 1], b = expectedLines[expectedLines.length - 1];a === b && (i++ < 2 \? end = `\n  `.concat(a).concat(end) : other = a, actualLines.pop(), expectedLines.pop(), !(actualLines.length === 0 || expectedLines.length === 0)); )\n        a = actualLines[actualLines.length - 1], b = expectedLines[expectedLines.length - 1];\n      var maxLines = Math.max(actualLines.length, expectedLines.length);\n      if (maxLines === 0) {\n        var _actualLines = actualInspected.split(`\n`);\n        if (_actualLines.length > 30)\n          for (_actualLines[26] = \"\".concat(blue, \"...\").concat(white);_actualLines.length > 27; )\n            _actualLines.pop();\n        return \"\".concat(kReadableOperator.notIdentical, `\n\n`).concat(_actualLines.join(`\n`), `\n`);\n      }\n      i > 3 && (end = `\n`.concat(blue, \"...\").concat(white).concat(end), skipped = !0), other !== \"\" && (end = `\n  `.concat(other).concat(end), other = \"\");\n      var printedLines = 0, msg = kReadableOperator[operator] + `\n`.concat(green, \"+ actual\").concat(white, \" \").concat(red, \"- expected\").concat(white), skippedMsg = \" \".concat(blue, \"...\").concat(white, \" Lines skipped\");\n      for (i = 0;i < maxLines; i++) {\n        var cur = i - lastPos;\n        if (actualLines.length < i + 1)\n          cur > 1 && i > 2 && (cur > 4 \? (res += `\n`.concat(blue, \"...\").concat(white), skipped = !0) : cur > 3 && (res += `\n  `.concat(expectedLines[i - 2]), printedLines++), res += `\n  `.concat(expectedLines[i - 1]), printedLines++), lastPos = i, other += `\n`.concat(red, \"-\").concat(white, \" \").concat(expectedLines[i]), printedLines++;\n        else if (expectedLines.length < i + 1)\n          cur > 1 && i > 2 && (cur > 4 \? (res += `\n`.concat(blue, \"...\").concat(white), skipped = !0) : cur > 3 && (res += `\n  `.concat(actualLines[i - 2]), printedLines++), res += `\n  `.concat(actualLines[i - 1]), printedLines++), lastPos = i, res += `\n`.concat(green, \"+\").concat(white, \" \").concat(actualLines[i]), printedLines++;\n        else {\n          var expectedLine = expectedLines[i], actualLine = actualLines[i], divergingLines = actualLine !== expectedLine && (!endsWith(actualLine, \",\") || actualLine.slice(0, -1) !== expectedLine);\n          divergingLines && endsWith(expectedLine, \",\") && expectedLine.slice(0, -1) === actualLine && (divergingLines = !1, actualLine += \",\"), divergingLines \? (cur > 1 && i > 2 && (cur > 4 \? (res += `\n`.concat(blue, \"...\").concat(white), skipped = !0) : cur > 3 && (res += `\n  `.concat(actualLines[i - 2]), printedLines++), res += `\n  `.concat(actualLines[i - 1]), printedLines++), lastPos = i, res += `\n`.concat(green, \"+\").concat(white, \" \").concat(actualLine), other += `\n`.concat(red, \"-\").concat(white, \" \").concat(expectedLine), printedLines += 2) : (res += other, other = \"\", (cur === 1 || i === 0) && (res += `\n  `.concat(actualLine), printedLines++));\n        }\n        if (printedLines > 20 && i < maxLines - 2)\n          return \"\".concat(msg).concat(skippedMsg, `\n`).concat(res, `\n`).concat(blue, \"...\").concat(white).concat(other, `\n`) + \"\".concat(blue, \"...\").concat(white);\n      }\n      return \"\".concat(msg).concat(skipped \? skippedMsg : \"\", `\n`).concat(res).concat(other).concat(end).concat(indicator);\n    }\n    var AssertionError = function(_Error) {\n      function AssertionError2(options) {\n        var _this;\n        if (_classCallCheck(this, AssertionError2), _typeof(options) !== \"object\" || options === null)\n          throw new ERR_INVALID_ARG_TYPE(\"options\", \"Object\", options);\n        var { message, operator, stackStartFn, actual, expected } = options, limit = Error.stackTraceLimit;\n        if (Error.stackTraceLimit = 0, message != null)\n          _this = _possibleConstructorReturn(this, _getPrototypeOf(AssertionError2).call(this, String(message)));\n        else if (process.stderr && process.stderr.isTTY && (process.stderr && process.stderr.getColorDepth && process.stderr.getColorDepth() !== 1 \? (blue = \"[34m\", green = \"[32m\", white = \"[39m\", red = \"[31m\") : (blue = \"\", green = \"\", white = \"\", red = \"\")), _typeof(actual) === \"object\" && actual !== null && _typeof(expected) === \"object\" && expected !== null && (\"stack\" in actual) && actual instanceof Error && (\"stack\" in expected) && expected instanceof Error && (actual = copyError(actual), expected = copyError(expected)), operator === \"deepStrictEqual\" || operator === \"strictEqual\")\n          _this = _possibleConstructorReturn(this, _getPrototypeOf(AssertionError2).call(this, createErrDiff(actual, expected, operator)));\n        else if (operator === \"notDeepStrictEqual\" || operator === \"notStrictEqual\") {\n          var base = kReadableOperator[operator], res = inspectValue(actual).split(`\n`);\n          if (operator === \"notStrictEqual\" && _typeof(actual) === \"object\" && actual !== null && (base = kReadableOperator.notStrictEqualObject), res.length > 30)\n            for (res[26] = \"\".concat(blue, \"...\").concat(white);res.length > 27; )\n              res.pop();\n          res.length === 1 \? _this = _possibleConstructorReturn(this, _getPrototypeOf(AssertionError2).call(this, \"\".concat(base, \" \").concat(res[0]))) : _this = _possibleConstructorReturn(this, _getPrototypeOf(AssertionError2).call(this, \"\".concat(base, `\n\n`).concat(res.join(`\n`), `\n`)));\n        } else {\n          var _res = inspectValue(actual), other = \"\", knownOperators = kReadableOperator[operator];\n          operator === \"notDeepEqual\" || operator === \"notEqual\" \? (_res = \"\".concat(kReadableOperator[operator], `\n\n`).concat(_res), _res.length > 1024 && (_res = \"\".concat(_res.slice(0, 1021), \"...\"))) : (other = \"\".concat(inspectValue(expected)), _res.length > 512 && (_res = \"\".concat(_res.slice(0, 509), \"...\")), other.length > 512 && (other = \"\".concat(other.slice(0, 509), \"...\")), operator === \"deepEqual\" || operator === \"equal\" \? _res = \"\".concat(knownOperators, `\n\n`).concat(_res, `\n\nshould equal\n\n`) : other = \" \".concat(operator, \" \").concat(other)), _this = _possibleConstructorReturn(this, _getPrototypeOf(AssertionError2).call(this, \"\".concat(_res).concat(other)));\n        }\n        return Error.stackTraceLimit = limit, _this.generatedMessage = !message, Object.defineProperty(_assertThisInitialized(_this), \"name\", {\n          value: \"AssertionError [ERR_ASSERTION]\",\n          enumerable: !1,\n          writable: !0,\n          configurable: !0\n        }), _this.code = \"ERR_ASSERTION\", _this.actual = actual, _this.expected = expected, _this.operator = operator, Error.captureStackTrace && Error.captureStackTrace(_assertThisInitialized(_this), stackStartFn), _this.stack, _this.name = \"AssertionError\", _possibleConstructorReturn(_this);\n      }\n      return AssertionError2.prototype = {}, _inherits(AssertionError2, _Error), _createClass(AssertionError2, [\n        {\n          key: \"toString\",\n          value: function() {\n            return \"\".concat(this.name, \" [\").concat(this.code, \"]: \").concat(this.message);\n          }\n        },\n        {\n          key: inspect.custom,\n          value: function(recurseTimes, ctx) {\n            return inspect(this, _objectSpread({}, ctx, {\n              customInspect: !1,\n              depth: 0\n            }));\n          }\n        }\n      ]), AssertionError2;\n    }(_wrapNativeSuper(Error));\n    module2.exports = AssertionError;\n  }\n}), require_assert = __commonJS({\n  \"assert/build/assert.js\"(exports, module2) {\n    function _typeof(obj) {\n      return typeof Symbol == \"function\" && typeof Symbol.iterator == \"symbol\" \? _typeof = function(obj2) {\n        return typeof obj2;\n      } : _typeof = function(obj2) {\n        return obj2 && typeof Symbol == \"function\" && obj2.constructor === Symbol && obj2 !== Symbol.prototype \? \"symbol\" : typeof obj2;\n      }, _typeof(obj);\n    }\n    function _classCallCheck(instance, Constructor) {\n      if (!(instance instanceof Constructor))\n        @throwTypeError(\"Cannot call a class as a function\");\n    }\n    var _require = require_errors(), _require$codes = _require.codes, ERR_AMBIGUOUS_ARGUMENT = _require$codes.ERR_AMBIGUOUS_ARGUMENT, ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE, ERR_INVALID_ARG_VALUE = _require$codes.ERR_INVALID_ARG_VALUE, ERR_INVALID_RETURN_VALUE = _require$codes.ERR_INVALID_RETURN_VALUE, ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS, AssertionError = require_assertion_error(), _require2 = util, inspect = _require2.inspect, _require$types = util.types, isPromise = _require$types.isPromise, isRegExp = _require$types.isRegExp, objectAssign = Object.assign, objectIs = Object.is, errorCache = new Map, warned = !1, assert = module2.exports = ok, NO_EXCEPTION_SENTINEL = {};\n    function innerFail(obj) {\n      throw obj.message instanceof Error \? obj.message : new AssertionError(obj);\n    }\n    function fail(actual, expected, message, operator, stackStartFn) {\n      var argsLen = arguments.length, internalMessage;\n      if (argsLen === 0)\n        internalMessage = \"Failed\";\n      else if (argsLen === 1)\n        message = actual, actual = void 0;\n      else {\n        if (warned === !1) {\n          warned = !0;\n          var warn = process.emitWarning \? process.emitWarning : console.warn.bind(console);\n          warn(\"assert.fail() with more than one argument is deprecated. Please use assert.strictEqual() instead or only pass a message.\", \"DeprecationWarning\", \"DEP0094\");\n        }\n        argsLen === 2 && (operator = \"!=\");\n      }\n      if (message instanceof Error)\n        throw message;\n      var errArgs = {\n        actual,\n        expected,\n        operator: operator === void 0 \? \"fail\" : operator,\n        stackStartFn: stackStartFn || fail\n      };\n      message !== void 0 && (errArgs.message = message);\n      var err = new AssertionError(errArgs);\n      throw internalMessage && (err.message = internalMessage, err.generatedMessage = !0), err;\n    }\n    assert.fail = fail, assert.AssertionError = AssertionError;\n    function innerOk(fn, argLen, value, message) {\n      if (!value) {\n        var generatedMessage = !1;\n        if (argLen === 0)\n          generatedMessage = !0, message = \"No value argument passed to `assert.ok()`\";\n        else if (message instanceof Error)\n          throw message;\n        var err = new AssertionError({\n          actual: value,\n          expected: !0,\n          message,\n          operator: \"==\",\n          stackStartFn: fn\n        });\n        throw err.generatedMessage = generatedMessage, err;\n      }\n    }\n    function ok() {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0;_key < _len; _key++)\n        args[_key] = arguments[_key];\n      innerOk.apply(void 0, [ok, args.length].concat(args));\n    }\n    assert.ok = ok, assert.equal = function equal(actual, expected, message) {\n      if (arguments.length < 2)\n        throw new ERR_MISSING_ARGS(\"actual\", \"expected\");\n      actual != expected && innerFail({\n        actual,\n        expected,\n        message,\n        operator: \"==\",\n        stackStartFn: equal\n      });\n    }, assert.notEqual = function notEqual(actual, expected, message) {\n      if (arguments.length < 2)\n        throw new ERR_MISSING_ARGS(\"actual\", \"expected\");\n      actual == expected && innerFail({\n        actual,\n        expected,\n        message,\n        operator: \"!=\",\n        stackStartFn: notEqual\n      });\n    }, assert.deepEqual = function deepEqual(actual, expected, message) {\n      if (arguments.length < 2)\n        throw new ERR_MISSING_ARGS(\"actual\", \"expected\");\n      isDeepEqual(actual, expected, !1) || innerFail({\n        actual,\n        expected,\n        message,\n        operator: \"deepEqual\",\n        stackStartFn: deepEqual\n      });\n    }, assert.notDeepEqual = function notDeepEqual(actual, expected, message) {\n      if (arguments.length < 2)\n        throw new ERR_MISSING_ARGS(\"actual\", \"expected\");\n      isDeepEqual(actual, expected, !1) && innerFail({\n        actual,\n        expected,\n        message,\n        operator: \"notDeepEqual\",\n        stackStartFn: notDeepEqual\n      });\n    }, assert.deepStrictEqual = function deepStrictEqual(actual, expected, message) {\n      if (arguments.length < 2)\n        throw new ERR_MISSING_ARGS(\"actual\", \"expected\");\n      isDeepEqual(actual, expected, !0) || innerFail({\n        actual,\n        expected,\n        message,\n        operator: \"deepStrictEqual\",\n        stackStartFn: deepStrictEqual\n      });\n    }, assert.notDeepStrictEqual = notDeepStrictEqual;\n    function notDeepStrictEqual(actual, expected, message) {\n      if (arguments.length < 2)\n        throw new ERR_MISSING_ARGS(\"actual\", \"expected\");\n      isDeepEqual(actual, expected, !0) && innerFail({\n        actual,\n        expected,\n        message,\n        operator: \"notDeepStrictEqual\",\n        stackStartFn: notDeepStrictEqual\n      });\n    }\n    assert.strictEqual = function strictEqual(actual, expected, message) {\n      if (arguments.length < 2)\n        throw new ERR_MISSING_ARGS(\"actual\", \"expected\");\n      objectIs(actual, expected) || innerFail({\n        actual,\n        expected,\n        message,\n        operator: \"strictEqual\",\n        stackStartFn: strictEqual\n      });\n    }, assert.notStrictEqual = function notStrictEqual(actual, expected, message) {\n      if (arguments.length < 2)\n        throw new ERR_MISSING_ARGS(\"actual\", \"expected\");\n      objectIs(actual, expected) && innerFail({\n        actual,\n        expected,\n        message,\n        operator: \"notStrictEqual\",\n        stackStartFn: notStrictEqual\n      });\n    }, assert.match = function match(actual, expected, message) {\n      if (arguments.length < 2)\n        throw new ERR_MISSING_ARGS(\"actual\", \"expected\");\n      if (!isRegExp(expected))\n        throw new ERR_INVALID_ARG_TYPE(\"expected\", \"RegExp\", expected);\n      expected.test(actual) || innerFail({\n        actual,\n        expected,\n        message,\n        operator: \"match\",\n        stackStartFn: match\n      });\n    };\n    var Comparison = function Comparison2(obj, keys, actual) {\n      var _this = this;\n      _classCallCheck(this, Comparison2), keys.forEach(function(key) {\n        (key in obj) && (actual !== void 0 && typeof actual[key] == \"string\" && isRegExp(obj[key]) && obj[key].test(actual[key]) \? _this[key] = actual[key] : _this[key] = obj[key]);\n      });\n    };\n    function compareExceptionKey(actual, expected, key, message, keys, fn) {\n      if (!(key in actual) || !isDeepEqual(actual[key], expected[key], !0)) {\n        if (!message) {\n          var a = new Comparison(actual, keys), b = new Comparison(expected, keys, actual), err = new AssertionError({\n            actual: a,\n            expected: b,\n            operator: \"deepStrictEqual\",\n            stackStartFn: fn\n          });\n          throw err.actual = actual, err.expected = expected, err.operator = fn.name, err;\n        }\n        innerFail({\n          actual,\n          expected,\n          message,\n          operator: fn.name,\n          stackStartFn: fn\n        });\n      }\n    }\n    function expectedException(actual, expected, msg, fn) {\n      if (typeof expected != \"function\") {\n        if (isRegExp(expected))\n          return expected.test(actual);\n        if (arguments.length === 2)\n          throw new ERR_INVALID_ARG_TYPE(\"expected\", [\"Function\", \"RegExp\"], expected);\n        if (_typeof(actual) !== \"object\" || actual === null) {\n          var err = new AssertionError({\n            actual,\n            expected,\n            message: msg,\n            operator: \"deepStrictEqual\",\n            stackStartFn: fn\n          });\n          throw err.operator = fn.name, err;\n        }\n        var keys = Object.keys(expected);\n        if (expected instanceof Error)\n          keys.push(\"name\", \"message\");\n        else if (keys.length === 0)\n          throw new ERR_INVALID_ARG_VALUE(\"error\", expected, \"may not be an empty object\");\n        return keys.forEach(function(key) {\n          return typeof actual[key] == \"string\" && isRegExp(expected[key]) && expected[key].test(actual[key]) || compareExceptionKey(actual, expected, key, msg, keys, fn);\n        }), !0;\n      }\n      return expected.prototype !== void 0 && actual instanceof expected \? !0 : Error.isPrototypeOf(expected) \? !1 : expected.call({}, actual) === !0;\n    }\n    function getActual(fn) {\n      if (typeof fn != \"function\")\n        throw new ERR_INVALID_ARG_TYPE(\"fn\", \"Function\", fn);\n      try {\n        fn();\n      } catch (e) {\n        return e;\n      }\n      return NO_EXCEPTION_SENTINEL;\n    }\n    function checkIsPromise(obj) {\n      return isPromise(obj) || obj !== null && _typeof(obj) === \"object\" && typeof obj.then == \"function\" && typeof obj.catch == \"function\";\n    }\n    function waitForActual(promiseFn) {\n      return Promise.resolve().then(function() {\n        var resultPromise;\n        if (typeof promiseFn == \"function\") {\n          if (resultPromise = promiseFn(), !checkIsPromise(resultPromise))\n            throw new ERR_INVALID_RETURN_VALUE(\"instance of Promise\", \"promiseFn\", resultPromise);\n        } else if (checkIsPromise(promiseFn))\n          resultPromise = promiseFn;\n        else\n          throw new ERR_INVALID_ARG_TYPE(\"promiseFn\", [\"Function\", \"Promise\"], promiseFn);\n        return Promise.resolve().then(function() {\n          return resultPromise;\n        }).then(function() {\n          return NO_EXCEPTION_SENTINEL;\n        }).catch(function(e) {\n          return e;\n        });\n      });\n    }\n    function expectsError(stackStartFn, actual, error, message) {\n      if (typeof error == \"string\") {\n        if (arguments.length === 4)\n          throw new ERR_INVALID_ARG_TYPE(\"error\", [\"Object\", \"Error\", \"Function\", \"RegExp\"], error);\n        if (_typeof(actual) === \"object\" && actual !== null) {\n          if (actual.message === error)\n            throw new ERR_AMBIGUOUS_ARGUMENT(\"error/message\", 'The error message \"'.concat(actual.message, '\" is identical to the message.'));\n        } else if (actual === error)\n          throw new ERR_AMBIGUOUS_ARGUMENT(\"error/message\", 'The error \"'.concat(actual, '\" is identical to the message.'));\n        message = error, error = void 0;\n      } else if (error != null && _typeof(error) !== \"object\" && typeof error != \"function\")\n        throw new ERR_INVALID_ARG_TYPE(\"error\", [\"Object\", \"Error\", \"Function\", \"RegExp\"], error);\n      if (actual === NO_EXCEPTION_SENTINEL) {\n        var details = \"\";\n        error && error.name && (details += \" (\".concat(error.name, \")\")), details += message \? \": \".concat(message) : \".\";\n        var fnType = stackStartFn.name === \"rejects\" \? \"rejection\" : \"exception\";\n        innerFail({\n          actual: void 0,\n          expected: error,\n          operator: stackStartFn.name,\n          message: \"Missing expected \".concat(fnType).concat(details),\n          stackStartFn\n        });\n      }\n      if (error && !expectedException(actual, error, message, stackStartFn))\n        throw actual;\n    }\n    function expectsNoError(stackStartFn, actual, error, message) {\n      if (actual !== NO_EXCEPTION_SENTINEL) {\n        if (typeof error == \"string\" && (message = error, error = void 0), !error || expectedException(actual, error)) {\n          var details = message \? \": \".concat(message) : \".\", fnType = stackStartFn.name === \"doesNotReject\" \? \"rejection\" : \"exception\";\n          innerFail({\n            actual,\n            expected: error,\n            operator: stackStartFn.name,\n            message: \"Got unwanted \".concat(fnType).concat(details, `\n`) + 'Actual message: \"'.concat(actual && actual.message, '\"'),\n            stackStartFn\n          });\n        }\n        throw actual;\n      }\n    }\n    assert.throws = function throws(promiseFn) {\n      for (var _len2 = arguments.length, args = new Array(_len2 > 1 \? _len2 - 1 : 0), _key2 = 1;_key2 < _len2; _key2++)\n        args[_key2 - 1] = arguments[_key2];\n      expectsError.apply(void 0, [throws, getActual(promiseFn)].concat(args));\n    }, assert.rejects = function rejects(promiseFn) {\n      for (var _len3 = arguments.length, args = new Array(_len3 > 1 \? _len3 - 1 : 0), _key3 = 1;_key3 < _len3; _key3++)\n        args[_key3 - 1] = arguments[_key3];\n      return waitForActual(promiseFn).then(function(result) {\n        return expectsError.apply(void 0, [rejects, result].concat(args));\n      });\n    }, assert.doesNotThrow = function doesNotThrow(fn) {\n      for (var _len4 = arguments.length, args = new Array(_len4 > 1 \? _len4 - 1 : 0), _key4 = 1;_key4 < _len4; _key4++)\n        args[_key4 - 1] = arguments[_key4];\n      expectsNoError.apply(void 0, [doesNotThrow, getActual(fn)].concat(args));\n    }, assert.doesNotReject = function doesNotReject(fn) {\n      for (var _len5 = arguments.length, args = new Array(_len5 > 1 \? _len5 - 1 : 0), _key5 = 1;_key5 < _len5; _key5++)\n        args[_key5 - 1] = arguments[_key5];\n      return waitForActual(fn).then(function(result) {\n        return expectsNoError.apply(void 0, [doesNotReject, result].concat(args));\n      });\n    }, assert.ifError = function ifError(err) {\n      if (err != null) {\n        var message = \"ifError got unwanted exception: \";\n        _typeof(err) === \"object\" && typeof err.message == \"string\" \? err.message.length === 0 && err.constructor \? message += err.constructor.name : message += err.message : message += inspect(err);\n        var newErr = new AssertionError({\n          actual: err,\n          expected: null,\n          operator: \"ifError\",\n          message,\n          stackStartFn: ifError\n        }), origStack = err.stack;\n        if (typeof origStack == \"string\") {\n          var tmp2 = origStack.split(`\n`);\n          tmp2.shift();\n          for (var tmp1 = newErr.stack.split(`\n`), i = 0;i < tmp2.length; i++) {\n            var pos = tmp1.indexOf(tmp2[i]);\n            if (pos !== -1) {\n              tmp1 = tmp1.slice(0, pos);\n              break;\n            }\n          }\n          newErr.stack = \"\".concat(tmp1.join(`\n`), `\n`).concat(tmp2.join(`\n`));\n        }\n        throw newErr;\n      }\n    };\n    function strict() {\n      for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0;_key6 < _len6; _key6++)\n        args[_key6] = arguments[_key6];\n      innerOk.apply(void 0, [strict, args.length].concat(args));\n    }\n    assert.strict = objectAssign(strict, assert, {\n      equal: assert.strictEqual,\n      deepEqual: assert.deepStrictEqual,\n      notEqual: assert.notStrictEqual,\n      notDeepEqual: assert.notDeepStrictEqual\n    }), assert.strict.strict = assert.strict;\n  }\n}), assert_module = require_assert();\nassert_module.CallTracker = CallTracker;\nreturn assert_module})\n"_s;
//

//
static constexpr ASCIILiteral NodeAssertStrictCode = "(function (){\"use strict\";// src/js/out/tmp/node/assert.strict.ts\nreturn (@getInternalField(@internalModuleRegistry, 4) || @createInternalModuleById(4)).strict})\n"_s;
//

//
static constexpr ASCIILiteral NodeAsyncHooksCode = "(function (){\"use strict\";// src/js/out/tmp/node/async_hooks.ts\nvar get = function() {\n  return @getInternalField(@asyncContext, 0);\n}, set = function(contextValue) {\n  return @putInternalField(@asyncContext, 0, contextValue);\n}, createWarning = function(message) {\n  let warned = !1;\n  var wrapped = function() {\n    if (warned)\n      return;\n    if (new Error().stack.includes(\"zx/build/core.js\"))\n      return;\n    warned = !0, console.warn(\"[bun] Warning:\", message);\n  };\n  return wrapped;\n}, createHook = function(callbacks) {\n  return {\n    enable: createHookNotImpl,\n    disable: createHookNotImpl\n  };\n}, executionAsyncId = function() {\n  return executionAsyncIdNotImpl(), 0;\n}, triggerAsyncId = function() {\n  return 0;\n}, executionAsyncResource = function() {\n  return executionAsyncResourceWarning(), process.stdin;\n}, $, { cleanupLater } = globalThis[globalThis.Symbol.for('Bun.lazy')](\"async_hooks\");\n\nclass AsyncLocalStorage {\n  #disableCalled = !1;\n  constructor() {\n  }\n  static bind(fn, ...args) {\n    return this.snapshot().bind(null, fn, ...args);\n  }\n  static snapshot() {\n    var context = get();\n    return (fn, ...args) => {\n      var prev = get();\n      set(context);\n      try {\n        return fn(...args);\n      } catch (error) {\n        throw error;\n      } finally {\n        set(prev);\n      }\n    };\n  }\n  enterWith(store) {\n    cleanupLater();\n    var context = get();\n    if (!context) {\n      set([this, store]);\n      return;\n    }\n    var { length } = context;\n    for (var i = 0;i < length; i += 2)\n      if (context[i] === this) {\n        const clone = context.slice();\n        clone[i + 1] = store, set(clone);\n        return;\n      }\n    set(context.concat(this, store));\n  }\n  exit(cb, ...args) {\n    return this.run(void 0, cb, ...args);\n  }\n  run(store, callback, ...args) {\n    var context = get(), hasPrevious = !1, previous, i = 0, contextWasInit = !context;\n    if (contextWasInit)\n      set(context = [this, store]);\n    else {\n      if (context = context.slice(), i = context.indexOf(this), i > -1)\n        hasPrevious = !0, previous = context[i + 1], context[i + 1] = store;\n      else\n        context.push(this, store);\n      set(context);\n    }\n    try {\n      return callback(...args);\n    } catch (e) {\n      throw e;\n    } finally {\n      if (!this.#disableCalled) {\n        var context2 = get();\n        if (context2 === context && contextWasInit)\n          set(void 0);\n        else if (context2 = context2.slice(), hasPrevious)\n          context2[i + 1] = previous, set(context2);\n        else\n          context2.splice(i, 2), set(context2.length \? context2 : void 0);\n      }\n    }\n  }\n  disable() {\n    if (!this.#disableCalled) {\n      var context = get();\n      if (context) {\n        var { length } = context;\n        for (var i = 0;i < length; i += 2)\n          if (context[i] === this) {\n            context.splice(i, 2), set(context.length \? context : void 0);\n            break;\n          }\n      }\n      this.#disableCalled = !0;\n    }\n  }\n  getStore() {\n    var context = get();\n    if (!context)\n      return;\n    var { length } = context;\n    for (var i = 0;i < length; i += 2)\n      if (context[i] === this)\n        return context[i + 1];\n  }\n}\n\nclass AsyncResource {\n  type;\n  #snapshot;\n  constructor(type, options) {\n    if (typeof type !== \"string\")\n      @throwTypeError('The \"type\" argument must be of type string. Received type ' + typeof type);\n    this.type = type, this.#snapshot = get();\n  }\n  emitBefore() {\n    return !0;\n  }\n  emitAfter() {\n    return !0;\n  }\n  asyncId() {\n    return 0;\n  }\n  triggerAsyncId() {\n    return 0;\n  }\n  emitDestroy() {\n  }\n  runInAsyncScope(fn, thisArg, ...args) {\n    var prev = get();\n    set(this.#snapshot);\n    try {\n      return fn.apply(thisArg, args);\n    } catch (error) {\n      throw error;\n    } finally {\n      set(prev);\n    }\n  }\n}\nvar createHookNotImpl = createWarning(\"async_hooks.createHook is not implemented in Bun. Hooks can still be created but will never be called.\"), executionAsyncIdNotImpl = createWarning(\"async_hooks.executionAsyncId/triggerAsyncId are not implemented in Bun. It will return 0 every time.\"), executionAsyncResourceWarning = createWarning(\"async_hooks.executionAsyncResource is not implemented in Bun. It returns a reference to process.stdin every time.\"), asyncWrapProviders = {\n  NONE: 0,\n  DIRHANDLE: 1,\n  DNSCHANNEL: 2,\n  ELDHISTOGRAM: 3,\n  FILEHANDLE: 4,\n  FILEHANDLECLOSEREQ: 5,\n  FIXEDSIZEBLOBCOPY: 6,\n  FSEVENTWRAP: 7,\n  FSREQCALLBACK: 8,\n  FSREQPROMISE: 9,\n  GETADDRINFOREQWRAP: 10,\n  GETNAMEINFOREQWRAP: 11,\n  HEAPSNAPSHOT: 12,\n  HTTP2SESSION: 13,\n  HTTP2STREAM: 14,\n  HTTP2PING: 15,\n  HTTP2SETTINGS: 16,\n  HTTPINCOMINGMESSAGE: 17,\n  HTTPCLIENTREQUEST: 18,\n  JSSTREAM: 19,\n  JSUDPWRAP: 20,\n  MESSAGEPORT: 21,\n  PIPECONNECTWRAP: 22,\n  PIPESERVERWRAP: 23,\n  PIPEWRAP: 24,\n  PROCESSWRAP: 25,\n  PROMISE: 26,\n  QUERYWRAP: 27,\n  SHUTDOWNWRAP: 28,\n  SIGNALWRAP: 29,\n  STATWATCHER: 30,\n  STREAMPIPE: 31,\n  TCPCONNECTWRAP: 32,\n  TCPSERVERWRAP: 33,\n  TCPWRAP: 34,\n  TTYWRAP: 35,\n  UDPSENDWRAP: 36,\n  UDPWRAP: 37,\n  SIGINTWATCHDOG: 38,\n  WORKER: 39,\n  WORKERHEAPSNAPSHOT: 40,\n  WRITEWRAP: 41,\n  ZLIB: 42,\n  CHECKPRIMEREQUEST: 43,\n  PBKDF2REQUEST: 44,\n  KEYPAIRGENREQUEST: 45,\n  KEYGENREQUEST: 46,\n  KEYEXPORTREQUEST: 47,\n  CIPHERREQUEST: 48,\n  DERIVEBITSREQUEST: 49,\n  HASHREQUEST: 50,\n  RANDOMBYTESREQUEST: 51,\n  RANDOMPRIMEREQUEST: 52,\n  SCRYPTREQUEST: 53,\n  SIGNREQUEST: 54,\n  TLSWRAP: 55,\n  VERIFYREQUEST: 56,\n  INSPECTORJSBINDING: 57\n};\n$ = {\n  AsyncLocalStorage,\n  createHook,\n  executionAsyncId,\n  triggerAsyncId,\n  executionAsyncResource,\n  asyncWrapProviders,\n  AsyncResource\n};\nreturn $})\n"_s;
//

//
static constexpr ASCIILiteral NodeChildProcessCode = "(function (){\"use strict\";// src/js/out/tmp/node/child_process.ts\nvar spawn = function(file, args, options) {\n  options = normalizeSpawnArguments(file, args, options), validateTimeout(options.timeout), validateAbortSignal(options.signal, \"options.signal\");\n  const killSignal2 = sanitizeKillSignal(options.killSignal), child = new ChildProcess;\n  if (child.spawn(options), options.timeout > 0) {\n    let timeoutId = setTimeout(() => {\n      if (timeoutId) {\n        try {\n          child.kill(killSignal2);\n        } catch (err) {\n          child.emit(\"error\", err);\n        }\n        timeoutId = null;\n      }\n    });\n    child.once(\"exit\", () => {\n      if (timeoutId)\n        clearTimeout(timeoutId), timeoutId = null;\n    });\n  }\n  if (options.signal) {\n    let onAbortListener2 = function() {\n      abortChildProcess(child, killSignal2, options.signal.reason);\n    };\n    var onAbortListener = onAbortListener2;\n    const signal = options.signal;\n    if (signal.aborted)\n      process.nextTick(onAbortListener2);\n    else\n      signal.addEventListener(\"abort\", onAbortListener2, { once: !0 }), child.once(\"exit\", () => signal.removeEventListener(\"abort\", onAbortListener2));\n  }\n  return child;\n}, execFile = function(file, args, options, callback) {\n  ({ file, args, options, callback } = normalizeExecFileArgs(file, args, options, callback)), options = {\n    encoding: \"utf8\",\n    timeout: 0,\n    maxBuffer: MAX_BUFFER,\n    killSignal: \"SIGTERM\",\n    cwd: null,\n    env: null,\n    shell: !1,\n    ...options\n  };\n  const maxBuffer = options.maxBuffer;\n  validateTimeout(options.timeout), validateMaxBuffer(maxBuffer), options.killSignal = sanitizeKillSignal(options.killSignal);\n  const child = spawn(file, args, {\n    cwd: options.cwd,\n    env: options.env,\n    shell: options.shell,\n    signal: options.signal\n  });\n  let encoding;\n  const _stdout = [], _stderr = [];\n  if (options.encoding !== \"buffer\" && BufferIsEncoding(options.encoding))\n    encoding = options.encoding;\n  else\n    encoding = null;\n  let stdoutLen = 0, stderrLen = 0, killed = !1, exited = !1, timeoutId, encodedStdoutLen, encodedStderrLen, ex = null, cmd = file;\n  function exitHandler(code, signal) {\n    if (exited)\n      return;\n    if (exited = !0, timeoutId)\n      clearTimeout(timeoutId), timeoutId = null;\n    if (!callback)\n      return;\n    const readableEncoding = child\?.stdout\?.readableEncoding;\n    let stdout, stderr;\n    if (encoding || child.stdout && readableEncoding)\n      stdout = ArrayPrototypeJoin.call(_stdout, \"\");\n    else\n      stdout = BufferConcat(_stdout);\n    if (encoding || child.stderr && readableEncoding)\n      stderr = ArrayPrototypeJoin.call(_stderr, \"\");\n    else\n      stderr = BufferConcat(_stderr);\n    if (!ex && code === 0 && signal === null) {\n      callback(null, stdout, stderr);\n      return;\n    }\n    if (args\?.length)\n      cmd += ` ${ArrayPrototypeJoin.call(args, \" \")}`;\n    if (!ex) {\n      let message = `Command failed: ${cmd}`;\n      if (stderr)\n        message += `\\n${stderr}`;\n      ex = genericNodeError(message, {\n        code,\n        killed: child.killed || killed,\n        signal\n      });\n    }\n    ex.cmd = cmd, callback(ex, stdout, stderr);\n  }\n  function errorHandler(e) {\n    if (ex = e, child.stdout)\n      child.stdout.destroy();\n    if (child.stderr)\n      child.stderr.destroy();\n    exitHandler();\n  }\n  function kill() {\n    if (child.stdout)\n      child.stdout.destroy();\n    if (child.stderr)\n      child.stderr.destroy();\n    killed = !0;\n    try {\n      child.kill(options.killSignal);\n    } catch (e) {\n      ex = e, exitHandler();\n    }\n  }\n  if (options.timeout > 0)\n    timeoutId = setTimeout(function delayedKill() {\n      kill(), timeoutId = null;\n    }, options.timeout);\n  if (child.stdout) {\n    if (encoding)\n      child.stdout.setEncoding(encoding);\n    child.stdout.on(\"data\", maxBuffer === Infinity \? function onUnlimitedSizeBufferedData(chunk) {\n      ArrayPrototypePush.call(_stdout, chunk);\n    } : encoding \? function onChildStdoutEncoded(chunk) {\n      if (stdoutLen += chunk.length, stdoutLen * 4 > maxBuffer) {\n        const encoding2 = child.stdout.readableEncoding, actualLen = Buffer.byteLength(chunk, encoding2);\n        if (encodedStdoutLen === void 0)\n          for (let i = 0;i < _stdout.length; i++)\n            encodedStdoutLen += Buffer.byteLength(_stdout[i], encoding2);\n        else\n          encodedStdoutLen += actualLen;\n        const truncatedLen = maxBuffer - (encodedStdoutLen - actualLen);\n        ArrayPrototypePush.call(_stdout, StringPrototypeSlice.apply(chunk, 0, truncatedLen)), ex = new ERR_CHILD_PROCESS_STDIO_MAXBUFFER(\"stdout\"), kill();\n      } else\n        ArrayPrototypePush.call(_stdout, chunk);\n    } : function onChildStdoutRaw(chunk) {\n      if (stdoutLen += chunk.length, stdoutLen > maxBuffer) {\n        const truncatedLen = maxBuffer - (stdoutLen - chunk.length);\n        ArrayPrototypePush.call(_stdout, chunk.slice(0, truncatedLen)), ex = new ERR_CHILD_PROCESS_STDIO_MAXBUFFER(\"stdout\"), kill();\n      } else\n        ArrayPrototypePush.call(_stdout, chunk);\n    });\n  }\n  if (child.stderr) {\n    if (encoding)\n      child.stderr.setEncoding(encoding);\n    child.stderr.on(\"data\", maxBuffer === Infinity \? function onUnlimitedSizeBufferedData(chunk) {\n      ArrayPrototypePush.call(_stderr, chunk);\n    } : encoding \? function onChildStderrEncoded(chunk) {\n      if (stderrLen += chunk.length, stderrLen * 4 > maxBuffer) {\n        const encoding2 = child.stderr.readableEncoding, actualLen = Buffer.byteLength(chunk, encoding2);\n        if (encodedStderrLen === void 0)\n          for (let i = 0;i < _stderr.length; i++)\n            encodedStderrLen += Buffer.byteLength(_stderr[i], encoding2);\n        else\n          encodedStderrLen += actualLen;\n        const truncatedLen = maxBuffer - (encodedStderrLen - actualLen);\n        ArrayPrototypePush.call(_stderr, StringPrototypeSlice.call(chunk, 0, truncatedLen)), ex = new ERR_CHILD_PROCESS_STDIO_MAXBUFFER(\"stderr\"), kill();\n      } else\n        ArrayPrototypePush.call(_stderr, chunk);\n    } : function onChildStderrRaw(chunk) {\n      if (stderrLen += chunk.length, stderrLen > maxBuffer) {\n        const truncatedLen = maxBuffer - (stderrLen - chunk.length);\n        ArrayPrototypePush.call(_stderr, StringPrototypeSlice.call(chunk, 0, truncatedLen)), ex = new ERR_CHILD_PROCESS_STDIO_MAXBUFFER(\"stderr\"), kill();\n      } else\n        ArrayPrototypePush.call(_stderr, chunk);\n    });\n  }\n  return child.addListener(\"close\", exitHandler), child.addListener(\"error\", errorHandler), child;\n}, exec = function(command, options, callback) {\n  const opts = normalizeExecArgs(command, options, callback);\n  return execFile(opts.file, opts.options, opts.callback);\n}, spawnSync = function(file, args, options) {\n  options = {\n    maxBuffer: MAX_BUFFER,\n    ...normalizeSpawnArguments(file, args, options)\n  };\n  const { maxBuffer, encoding } = options;\n  validateTimeout(options.timeout), validateMaxBuffer(maxBuffer), options.killSignal = sanitizeKillSignal(options.killSignal);\n  const stdio = options.stdio || \"pipe\", bunStdio = getBunStdioFromOptions(stdio);\n  var { input } = options;\n  if (input)\n    if (ArrayBufferIsView(input))\n      bunStdio[0] = input;\n    else if (typeof input === \"string\")\n      bunStdio[0] = Buffer.from(input, encoding || \"utf8\");\n    else\n      throw new ERR_INVALID_ARG_TYPE(\"options.stdio[0]\", [\"Buffer\", \"TypedArray\", \"DataView\", \"string\"], input);\n  const { stdout, stderr, success, exitCode } = Bun.spawnSync({\n    cmd: options.args,\n    env: options.env || void 0,\n    cwd: options.cwd || void 0,\n    stdin: bunStdio[0],\n    stdout: bunStdio[1],\n    stderr: bunStdio[2]\n  }), result = {\n    signal: null,\n    status: exitCode,\n    output: [null, stdout, stderr]\n  };\n  if (stdout && encoding && encoding !== \"buffer\")\n    result.output[1] = result.output[1]\?.toString(encoding);\n  if (stderr && encoding && encoding !== \"buffer\")\n    result.output[2] = result.output[2]\?.toString(encoding);\n  if (result.stdout = result.output[1], result.stderr = result.output[2], !success)\n    result.error = new SystemError(result.output[2], options.file, \"spawnSync\", -1, result.status), result.error.spawnargs = ArrayPrototypeSlice.call(options.args, 1);\n  return result;\n}, execFileSync = function(file, args, options) {\n  ({ file, args, options } = normalizeExecFileArgs(file, args, options));\n  const ret = spawnSync(file, args, options), errArgs = [options.argv0 || file];\n  ArrayPrototypePush.apply(errArgs, args);\n  const err = checkExecSyncError(ret, errArgs);\n  if (err)\n    throw err;\n  return ret.stdout;\n}, execSync = function(command, options) {\n  const opts = normalizeExecArgs(command, options, null), ret = spawnSync(opts.file, opts.options), err = checkExecSyncError(ret, void 0, command);\n  if (err)\n    throw err;\n  return ret.stdout;\n}, stdioStringToArray = function(stdio, channel) {\n  const options = [];\n  switch (stdio) {\n    case \"ignore\":\n    case \"overlapped\":\n    case \"pipe\":\n      ArrayPrototypePush.call(options, stdio, stdio, stdio);\n      break;\n    case \"inherit\":\n      ArrayPrototypePush.call(options, 0, 1, 2);\n      break;\n    default:\n      throw new ERR_INVALID_ARG_VALUE(\"stdio\", stdio);\n  }\n  if (channel)\n    ArrayPrototypePush.call(options, channel);\n  return options;\n}, fork = function(modulePath, args = [], options) {\n  modulePath = getValidatedPath(modulePath, \"modulePath\");\n  let execArgv;\n  if (args == null)\n    args = [];\n  else if (typeof args === \"object\" && !ArrayIsArray(args))\n    options = args, args = [];\n  else\n    validateArray(args, \"args\");\n  if (options != null)\n    validateObject(options, \"options\");\n  if (options = { __proto__: null, ...options, shell: !1 }, options.execPath = options.execPath || process.execPath, validateArgumentNullCheck(options.execPath, \"options.execPath\"), execArgv = options.execArgv || process.execArgv, validateArgumentsNullCheck(execArgv, \"options.execArgv\"), execArgv === process.execArgv && process._eval != null) {\n    const index = ArrayPrototypeLastIndexOf.call(execArgv, process._eval);\n    if (index > 0)\n      execArgv = ArrayPrototypeSlice.call(execArgv), ArrayPrototypeSplice.call(execArgv, index - 1, 2);\n  }\n  if (args = [...execArgv, modulePath, ...args], typeof options.stdio === \"string\")\n    options.stdio = stdioStringToArray(options.stdio, \"ipc\");\n  else if (!ArrayIsArray(options.stdio))\n    options.stdio = stdioStringToArray(options.silent \? \"pipe\" : \"inherit\", \"ipc\");\n  else if (!ArrayPrototypeIncludes.call(options.stdio, \"ipc\"))\n    throw new ERR_CHILD_PROCESS_IPC_REQUIRED(\"options.stdio\");\n  return spawn(options.execPath, args, options);\n}, convertToValidSignal = function(signal) {\n  if (typeof signal === \"number\" && getSignalsToNamesMapping()[signal])\n    return signal;\n  if (typeof signal === \"string\") {\n    const signalName = signals[StringPrototypeToUpperCase.call(signal)];\n    if (signalName)\n      return signalName;\n  }\n  throw new ERR_UNKNOWN_SIGNAL(signal);\n}, sanitizeKillSignal = function(killSignal2) {\n  if (typeof killSignal2 === \"string\" || typeof killSignal2 === \"number\")\n    return convertToValidSignal(killSignal2);\n  else if (killSignal2 != null)\n    throw new ERR_INVALID_ARG_TYPE(\"options.killSignal\", [\"string\", \"number\"], killSignal2);\n}, getSignalsToNamesMapping = function() {\n  if (signalsToNamesMapping !== void 0)\n    return signalsToNamesMapping;\n  signalsToNamesMapping = ObjectCreate(null);\n  for (let key in signals)\n    signalsToNamesMapping[signals[key]] = key;\n  return signalsToNamesMapping;\n}, normalizeExecFileArgs = function(file, args, options, callback) {\n  if (ArrayIsArray(args))\n    args = ArrayPrototypeSlice.call(args);\n  else if (args != null && typeof args === \"object\")\n    callback = options, options = args, args = null;\n  else if (typeof args === \"function\")\n    callback = args, options = null, args = null;\n  if (args == null)\n    args = [];\n  if (typeof options === \"function\")\n    callback = options;\n  else if (options != null)\n    validateObject(options, \"options\");\n  if (options == null)\n    options = kEmptyObject;\n  if (callback != null)\n    validateFunction(callback, \"callback\");\n  if (options.argv0 != null)\n    validateString(options.argv0, \"options.argv0\"), validateArgumentNullCheck(options.argv0, \"options.argv0\");\n  return { file, args, options, callback };\n}, normalizeExecArgs = function(command, options, callback) {\n  if (validateString(command, \"command\"), validateArgumentNullCheck(command, \"command\"), typeof options === \"function\")\n    callback = options, options = void 0;\n  return options = { ...options }, options.shell = typeof options.shell === \"string\" \? options.shell : !0, {\n    file: command,\n    options,\n    callback\n  };\n}, normalizeSpawnArguments = function(file, args, options) {\n  if (validateString(file, \"file\"), validateArgumentNullCheck(file, \"file\"), file.length === 0)\n    throw new ERR_INVALID_ARG_VALUE(\"file\", file, \"cannot be empty\");\n  if (ArrayIsArray(args))\n    args = ArrayPrototypeSlice.call(args);\n  else if (args == null)\n    args = [];\n  else if (typeof args !== \"object\")\n    throw new ERR_INVALID_ARG_TYPE(\"args\", \"object\", args);\n  else\n    options = args, args = [];\n  if (validateArgumentsNullCheck(args, \"args\"), options === void 0)\n    options = {};\n  else\n    validateObject(options, \"options\");\n  let cwd = options.cwd;\n  if (cwd != null)\n    cwd = getValidatedPath(cwd, \"options.cwd\");\n  if (options.shell != null && typeof options.shell !== \"boolean\" && typeof options.shell !== \"string\")\n    throw new ERR_INVALID_ARG_TYPE(\"options.shell\", [\"boolean\", \"string\"], options.shell);\n  if (options.argv0 != null)\n    validateString(options.argv0, \"options.argv0\"), validateArgumentNullCheck(options.argv0, \"options.argv0\");\n  if (options.shell) {\n    validateArgumentNullCheck(options.shell, \"options.shell\");\n    const command = ArrayPrototypeJoin.call([file, ...args], \" \");\n    if (typeof options.shell === \"string\")\n      file = options.shell;\n    else\n      file = \"sh\";\n    args = [\"-c\", command];\n  }\n  if (typeof options.argv0 === \"string\")\n    ArrayPrototypeUnshift.call(args, options.argv0);\n  else\n    ArrayPrototypeUnshift.call(args, file);\n  const envPairs = options.env || process.env;\n  return { ...options, file, args, cwd, envPairs };\n}, checkExecSyncError = function(ret, args, cmd) {\n  let err;\n  if (ret.error)\n    err = ret.error, ObjectAssign(err, ret);\n  else if (ret.status !== 0) {\n    let msg = \"Command failed: \";\n    if (msg += cmd || ArrayPrototypeJoin.call(args, \" \"), ret.stderr && ret.stderr.length > 0)\n      msg += `\\n${ret.stderr.toString()}`;\n    err = genericNodeError(msg, ret);\n  }\n  return err;\n}, nodeToBun = function(item) {\n  if (typeof item === \"number\")\n    return item;\n  else {\n    const result = nodeToBunLookup[item];\n    if (result === void 0)\n      throw new Error(\"Invalid stdio option\");\n    return result;\n  }\n}, fdToStdioName = function(fd) {\n  switch (fd) {\n    case 0:\n      return \"stdin\";\n    case 1:\n      return \"stdout\";\n    case 2:\n      return \"stderr\";\n    default:\n      return null;\n  }\n}, getBunStdioFromOptions = function(stdio) {\n  return normalizeStdio(stdio).map((item) => nodeToBun(item));\n}, normalizeStdio = function(stdio) {\n  if (typeof stdio === \"string\")\n    switch (stdio) {\n      case \"ignore\":\n        return [\"ignore\", \"ignore\", \"ignore\"];\n      case \"pipe\":\n        return [\"pipe\", \"pipe\", \"pipe\"];\n      case \"inherit\":\n        return [\"inherit\", \"inherit\", \"inherit\"];\n      default:\n        throw new ERR_INVALID_OPT_VALUE(\"stdio\", stdio);\n    }\n  else if (ArrayIsArray(stdio)) {\n    let processedStdio;\n    if (stdio.length === 0)\n      processedStdio = [\"pipe\", \"pipe\", \"pipe\"];\n    else if (stdio.length === 1)\n      processedStdio = [stdio[0], \"pipe\", \"pipe\"];\n    else if (stdio.length === 2)\n      processedStdio = [stdio[0], stdio[1], \"pipe\"];\n    else if (stdio.length >= 3)\n      processedStdio = [stdio[0], stdio[1], stdio[2]];\n    return processedStdio.map((item) => !item \? \"pipe\" : item);\n  } else\n    throw new ERR_INVALID_OPT_VALUE(\"stdio\", stdio);\n}, flushStdio = function(subprocess) {\n  const stdio = subprocess.stdio;\n  if (stdio == null)\n    return;\n  for (let i = 0;i < stdio.length; i++) {\n    const stream = stdio[i];\n    if (!stream || !stream.readable)\n      continue;\n    stream.resume();\n  }\n}, onSpawnNT = function(self) {\n  self.emit(\"spawn\");\n}, abortChildProcess = function(child, killSignal2, reason) {\n  if (!child)\n    return;\n  try {\n    if (child.kill(killSignal2))\n      child.emit(\"error\", new AbortError(void 0, { cause: reason }));\n  } catch (err) {\n    child.emit(\"error\", err);\n  }\n}, validateMaxBuffer = function(maxBuffer) {\n  if (maxBuffer != null && !(typeof maxBuffer === \"number\" && maxBuffer >= 0))\n    throw new ERR_OUT_OF_RANGE(\"options.maxBuffer\", \"a positive number\", maxBuffer);\n}, validateArgumentNullCheck = function(arg, propName) {\n  if (typeof arg === \"string\" && StringPrototypeIncludes.call(arg, \"\\0\"))\n    throw new ERR_INVALID_ARG_VALUE(propName, arg, \"must be a string without null bytes\");\n}, validateArgumentsNullCheck = function(args, propName) {\n  for (let i = 0;i < args.length; ++i)\n    validateArgumentNullCheck(args[i], `${propName}[${i}]`);\n}, validateTimeout = function(timeout) {\n  if (timeout != null && !(NumberIsInteger(timeout) && timeout >= 0))\n    throw new ERR_OUT_OF_RANGE(\"timeout\", \"an unsigned integer\", timeout);\n};\nvar validateFunction = function(value, name) {\n  if (typeof value !== \"function\")\n    throw new ERR_INVALID_ARG_TYPE(name, \"Function\", value);\n}, validateString = function(value, name) {\n  if (typeof value !== \"string\")\n    throw new ERR_INVALID_ARG_TYPE(name, \"string\", value);\n}, nullCheck = function(path, propName, throwError = !0) {\n  const pathIsString = typeof path === \"string\", pathIsUint8Array = isUint8Array(path);\n  if (!pathIsString && !pathIsUint8Array || pathIsString && !StringPrototypeIncludes.call(path, \"\\0\") || pathIsUint8Array && !Uint8ArrayPrototypeIncludes.call(path, 0))\n    return;\n  const err = new ERR_INVALID_ARG_VALUE(propName, path, \"must be a string or Uint8Array without null bytes\");\n  if (throwError)\n    throw err;\n  return err;\n}, validatePath = function(path, propName = \"path\") {\n  if (typeof path !== \"string\" && !isUint8Array(path))\n    throw new ERR_INVALID_ARG_TYPE(propName, [\"string\", \"Buffer\", \"URL\"], path);\n  const err = nullCheck(path, propName, !1);\n  if (err !== void 0)\n    throw err;\n}, getValidatedPath = function(fileURLOrPath, propName = \"path\") {\n  const path = toPathIfFileURL(fileURLOrPath);\n  return validatePath(path, propName), path;\n}, isUint8Array = function(value) {\n  return typeof value === \"object\" && value !== null && value instanceof Uint8Array;\n}, isURLInstance = function(fileURLOrPath) {\n  return fileURLOrPath != null && fileURLOrPath.href && fileURLOrPath.origin;\n}, toPathIfFileURL = function(fileURLOrPath) {\n  if (!isURLInstance(fileURLOrPath))\n    return fileURLOrPath;\n  return Bun.fileURLToPath(fileURLOrPath);\n}, genericNodeError = function(message, options) {\n  const err = new Error(message);\n  return err.code = options.code, err.killed = options.killed, err.signal = options.signal, err;\n}, ERR_OUT_OF_RANGE = function(str, range, input, replaceDefaultBoolean = !1) {\n  return new RangeError(`The value of ${str} is out of range. It must be ${range}. Received ${input}`);\n}, ERR_CHILD_PROCESS_STDIO_MAXBUFFER = function(stdio) {\n  return Error(`${stdio} maxBuffer length exceeded`);\n}, ERR_UNKNOWN_SIGNAL = function(name) {\n  const err = @makeTypeError(`Unknown signal: ${name}`);\n  return err.code = \"ERR_UNKNOWN_SIGNAL\", err;\n}, ERR_INVALID_ARG_TYPE = function(name, type, value) {\n  const err = @makeTypeError(`The \"${name}\" argument must be of type ${type}. Received ${value\?.toString()}`);\n  return err.code = \"ERR_INVALID_ARG_TYPE\", err;\n}, ERR_INVALID_OPT_VALUE = function(name, value) {\n  return @makeTypeError(`The value \"${value}\" is invalid for option \"${name}\"`);\n}, ERR_INVALID_ARG_VALUE = function(name, value, reason) {\n  return new Error(`The value \"${value}\" is invalid for argument '${name}'. Reason: ${reason}`);\n}, ERR_CHILD_PROCESS_IPC_REQUIRED = function(name) {\n  const err = @makeTypeError(`Forked processes must have an IPC channel, missing value 'ipc' in ${name}`);\n  return err.code = \"ERR_CHILD_PROCESS_IPC_REQUIRED\", err;\n}, $, EventEmitter = @getInternalField(@internalModuleRegistry, 16) || @createInternalModuleById(16), StreamModule = @getInternalField(@internalModuleRegistry, 35) || @createInternalModuleById(35), {\n  constants: { signals }\n} = @getInternalField(@internalModuleRegistry, 24) || @createInternalModuleById(24), { promisify } = @getInternalField(@internalModuleRegistry, 43) || @createInternalModuleById(43), ObjectCreate = Object.create, ObjectAssign = Object.assign, ObjectDefineProperty = Object.defineProperty, BufferConcat = Buffer.concat, BufferIsEncoding = Buffer.isEncoding, kEmptyObject = ObjectCreate(null), ArrayPrototypePush = Array.prototype.push, ArrayPrototypeJoin = Array.prototype.join, ArrayPrototypeMap = Array.prototype.map, ArrayPrototypeIncludes = Array.prototype.includes, ArrayPrototypeSlice = Array.prototype.slice, ArrayPrototypeUnshift = Array.prototype.unshift, ArrayPrototypeLastIndexOf = Array.prototype.lastIndexOf, ArrayPrototypeSplice = Array.prototype.splice, ArrayIsArray = Array.isArray, ArrayBufferIsView = ArrayBuffer.isView, NumberIsInteger = Number.isInteger;\nvar StringPrototypeToUpperCase = String.prototype.toUpperCase, StringPrototypeIncludes = String.prototype.includes, StringPrototypeSlice = String.prototype.slice, Uint8ArrayPrototypeIncludes = Uint8Array.prototype.includes, MAX_BUFFER = 1048576, NativeWritable, ReadableFromWeb, customPromiseExecFunction = (orig) => {\n  return (...args) => {\n    let resolve, reject;\n    const promise = new Promise((res, rej) => {\n      resolve = res, reject = rej;\n    });\n    return promise.child = orig(...args, (err, stdout, stderr) => {\n      if (err !== null)\n        err.stdout = stdout, err.stderr = stderr, reject(err);\n      else\n        resolve({ stdout, stderr });\n    }), promise;\n  };\n};\nObjectDefineProperty(exec, promisify.custom, {\n  __proto__: null,\n  enumerable: !1,\n  value: customPromiseExecFunction(exec)\n});\nvar signalsToNamesMapping;\n\nclass ChildProcess extends EventEmitter {\n  constructor() {\n    super(...arguments);\n  }\n  #handle;\n  #exited = !1;\n  #closesNeeded = 1;\n  #closesGot = 0;\n  connected = !1;\n  signalCode = null;\n  exitCode = null;\n  spawnfile;\n  spawnargs;\n  pid;\n  channel;\n  get killed() {\n    if (this.#handle == null)\n      return !1;\n  }\n  #handleOnExit(exitCode, signalCode, err) {\n    if (this.#exited)\n      return;\n    if (signalCode)\n      this.signalCode = signalCode;\n    else\n      this.exitCode = exitCode;\n    if (this.#stdin)\n      this.#stdin.destroy();\n    if (this.#handle)\n      this.#handle = null;\n    if (exitCode < 0) {\n      const err2 = new SystemError(`Spawned process exited with error code: ${exitCode}`, void 0, \"spawn\", \"EUNKNOWN\", \"ERR_CHILD_PROCESS_UNKNOWN_ERROR\");\n      if (this.spawnfile)\n        err2.path = this.spawnfile;\n      err2.spawnargs = ArrayPrototypeSlice.call(this.spawnargs, 1), this.emit(\"error\", err2);\n    } else\n      this.emit(\"exit\", this.exitCode, this.signalCode);\n    process.nextTick(flushStdio, this), this.#maybeClose(), this.#exited = !0, this.#stdioOptions = [\"destroyed\", \"destroyed\", \"destroyed\"];\n  }\n  #getBunSpawnIo(i, encoding) {\n    NativeWritable ||= StreamModule.NativeWritable, ReadableFromWeb ||= StreamModule.Readable.fromWeb;\n    const io = this.#stdioOptions[i];\n    switch (i) {\n      case 0:\n        switch (io) {\n          case \"pipe\":\n            return new NativeWritable(this.#handle.stdin);\n          case \"inherit\":\n            return process.stdin || null;\n          case \"destroyed\":\n            return new ShimmedStdin;\n          default:\n            return null;\n        }\n      case 2:\n      case 1:\n        switch (io) {\n          case \"pipe\":\n            return ReadableFromWeb(this.#handle[fdToStdioName(i)], { encoding });\n          case \"inherit\":\n            return process[fdToStdioName(i)] || null;\n          case \"destroyed\":\n            return new ShimmedStdioOutStream;\n          default:\n            return null;\n        }\n    }\n  }\n  #stdin;\n  #stdout;\n  #stderr;\n  #stdioObject;\n  #encoding;\n  #stdioOptions;\n  #createStdioObject() {\n    return Object.create(null, {\n      0: {\n        get: () => this.stdin\n      },\n      1: {\n        get: () => this.stdout\n      },\n      2: {\n        get: () => this.stderr\n      }\n    });\n  }\n  get stdin() {\n    return this.#stdin \?\?= this.#getBunSpawnIo(0, this.#encoding);\n  }\n  get stdout() {\n    return this.#stdout \?\?= this.#getBunSpawnIo(1, this.#encoding);\n  }\n  get stderr() {\n    return this.#stderr \?\?= this.#getBunSpawnIo(2, this.#encoding);\n  }\n  get stdio() {\n    return this.#stdioObject \?\?= this.#createStdioObject();\n  }\n  spawn(options) {\n    validateObject(options, \"options\"), validateString(options.file, \"options.file\");\n    var file = this.spawnfile = options.file, spawnargs;\n    if (options.args == null)\n      spawnargs = this.spawnargs = [];\n    else\n      validateArray(options.args, \"options.args\"), spawnargs = this.spawnargs = options.args;\n    const stdio = options.stdio || [\"pipe\", \"pipe\", \"pipe\"], bunStdio = getBunStdioFromOptions(stdio);\n    var env = options.envPairs || void 0;\n    this.#encoding = options.encoding || void 0, this.#stdioOptions = bunStdio, this.#handle = Bun.spawn({\n      cmd: spawnargs,\n      stdin: bunStdio[0],\n      stdout: bunStdio[1],\n      stderr: bunStdio[2],\n      cwd: options.cwd || void 0,\n      env: env || process.env,\n      onExit: (handle, exitCode, signalCode, err) => {\n        this.#handle = handle, this.pid = this.#handle.pid, process.nextTick((exitCode2, signalCode2, err2) => this.#handleOnExit(exitCode2, signalCode2, err2), exitCode, signalCode, err);\n      },\n      lazy: !0\n    }), this.pid = this.#handle.pid, onSpawnNT(this);\n  }\n  send() {\n    console.log(\"ChildProcess.prototype.send() - Sorry! Not implemented yet\");\n  }\n  disconnect() {\n    console.log(\"ChildProcess.prototype.disconnect() - Sorry! Not implemented yet\");\n  }\n  kill(sig) {\n    const signal = sig === 0 \? sig : convertToValidSignal(sig === void 0 \? \"SIGTERM\" : sig);\n    if (this.#handle)\n      this.#handle.kill(signal);\n    return this.#maybeClose(), !0;\n  }\n  #maybeClose() {\n    if (this.#closesGot++, this.#closesGot === this.#closesNeeded)\n      this.emit(\"close\", this.exitCode, this.signalCode);\n  }\n  ref() {\n    if (this.#handle)\n      this.#handle.ref();\n  }\n  unref() {\n    if (this.#handle)\n      this.#handle.unref();\n  }\n}\nvar nodeToBunLookup = {\n  ignore: null,\n  pipe: \"pipe\",\n  overlapped: \"pipe\",\n  inherit: \"inherit\"\n};\n\nclass ShimmedStdin extends EventEmitter {\n  constructor() {\n    super();\n  }\n  write() {\n    return !1;\n  }\n  destroy() {\n  }\n  end() {\n  }\n  pipe() {\n  }\n}\n\nclass ShimmedStdioOutStream extends EventEmitter {\n  constructor() {\n    super(...arguments);\n  }\n  pipe() {\n  }\n}\nvar validateAbortSignal = (signal, name) => {\n  if (signal !== void 0 && (signal === null || typeof signal !== \"object\" || !(\"aborted\" in signal)))\n    throw new ERR_INVALID_ARG_TYPE(name, \"AbortSignal\", signal);\n};\nvar validateObject = (value, name, options = null) => {\n  const allowArray = options\?.allowArray \?\? !1, allowFunction = options\?.allowFunction \?\? !1;\n  if (!(options\?.nullable \?\? !1) && value === null || !allowArray && ArrayIsArray.call(value) || typeof value !== \"object\" && (!allowFunction || typeof value !== \"function\"))\n    throw new ERR_INVALID_ARG_TYPE(name, \"object\", value);\n}, validateArray = (value, name, minLength = 0) => {\n  if (!ArrayIsArray(value))\n    throw new ERR_INVALID_ARG_TYPE(name, \"Array\", value);\n  if (value.length < minLength) {\n    const reason = `must be longer than ${minLength}`;\n    throw new ERR_INVALID_ARG_VALUE(name, value, reason);\n  }\n}, Error = globalThis.Error, TypeError = globalThis.TypeError, RangeError = globalThis.RangeError;\n\nclass AbortError extends Error {\n  code = \"ABORT_ERR\";\n  name = \"AbortError\";\n  constructor(message = \"The operation was aborted\", options = void 0) {\n    if (options !== void 0 && typeof options !== \"object\")\n      throw new ERR_INVALID_ARG_TYPE(\"options\", \"Object\", options);\n    super(message, options);\n  }\n}\n\nclass SystemError extends Error {\n  path;\n  syscall;\n  errno;\n  code;\n  constructor(message, path, syscall, errno, code) {\n    super(message);\n    this.path = path, this.syscall = syscall, this.errno = errno, this.code = code;\n  }\n  get name() {\n    return \"SystemError\";\n  }\n}\n$ = {\n  ChildProcess,\n  spawn,\n  execFile,\n  exec,\n  fork,\n  spawnSync,\n  execFileSync,\n  execSync\n};\nreturn $})\n"_s;
//

//
static constexpr ASCIILiteral NodeClusterCode = "(function (){\"use strict\";// src/js/out/tmp/node/cluster.ts\nvar EventEmitter = @getInternalField(@internalModuleRegistry, 16) || @createInternalModuleById(16), { throwNotImplemented } = @getInternalField(@internalModuleRegistry, 3) || @createInternalModuleById(3);\n\nclass Cluster extends EventEmitter {\n  constructor() {\n    super(...arguments);\n  }\n  isWorker = !1;\n  isPrimary = !0;\n  isMaster = !0;\n  workers = {};\n  settings = {};\n  SCHED_NONE = 1;\n  SCHED_RR = 2;\n  schedulingPolicy = 2;\n  Worker = function Worker() {\n    throwNotImplemented(\"node:cluster Worker\", 2428);\n  };\n  setupPrimary() {\n    throwNotImplemented(\"node:cluster\", 2428);\n  }\n  setupMaster() {\n    throwNotImplemented(\"node:cluster\", 2428);\n  }\n  fork() {\n    throwNotImplemented(\"node:cluster\", 2428);\n  }\n  disconnect() {\n    throwNotImplemented(\"node:cluster\", 2428);\n  }\n}\nreturn new Cluster})\n"_s;
//

//
static constexpr ASCIILiteral NodeConsoleCode = "(function (){\"use strict\";// src/js/out/tmp/node/console.ts\nreturn console})\n"_s;
//

//
static constexpr ASCIILiteral NodeCryptoCode = "(function (){\"use strict\";// src/js/out/tmp/node/crypto.ts\nvar getArrayBufferOrView = function(buffer, name, encoding) {\n  if (isAnyArrayBuffer(buffer))\n    return buffer;\n  if (typeof buffer === \"string\") {\n    if (encoding === \"buffer\")\n      encoding = \"utf8\";\n    return Buffer.from(buffer, encoding);\n  }\n  if (!isArrayBufferView(buffer)) {\n    var error = @makeTypeError(`ERR_INVALID_ARG_TYPE: The \"${name}\" argument must be of type string or an instance of ArrayBuffer, Buffer, TypedArray, or DataView. Received ` + buffer);\n    throw error.code = \"ERR_INVALID_ARG_TYPE\", error;\n  }\n  return buffer;\n}, getCurves = function() {\n  return harcoded_curves;\n}, $, __defProp = Object.defineProperty, __getOwnPropNames = Object.getOwnPropertyNames, StreamModule = @getInternalField(@internalModuleRegistry, 35) || @createInternalModuleById(35), BufferModule = @requireNativeModule(\"node:buffer\"), StringDecoder = @requireNativeModule(\"node:string_decoder\").StringDecoder, MAX_STRING_LENGTH = 536870888, Buffer = globalThis.Buffer, EMPTY_BUFFER = Buffer.alloc(0), { isAnyArrayBuffer, isArrayBufferView } = @requireNativeModule(\"node:util/types\"), crypto = globalThis.crypto, globalCrypto = crypto, __commonJS = (cb, mod) => function() {\n  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;\n}, __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: !0 });\n}, require_safe_buffer = __commonJS({\n  \"node_modules/safe-buffer/index.js\"(exports, module) {\n    var buffer = BufferModule, Buffer2 = buffer.Buffer;\n    function copyProps(src, dst) {\n      for (var key in src)\n        dst[key] = src[key];\n    }\n    Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow \? module.exports = buffer : (copyProps(buffer, exports), exports.Buffer = SafeBuffer);\n    function SafeBuffer(arg, encodingOrOffset, length) {\n      return Buffer2(arg, encodingOrOffset, length);\n    }\n    SafeBuffer.prototype = Object.create(Buffer2.prototype), copyProps(Buffer2, SafeBuffer), SafeBuffer.from = function(arg, encodingOrOffset, length) {\n      if (typeof arg == \"number\")\n        @throwTypeError(\"Argument must not be a number\");\n      return Buffer2(arg, encodingOrOffset, length);\n    }, SafeBuffer.alloc = function(size, fill, encoding) {\n      if (typeof size != \"number\")\n        @throwTypeError(\"Argument must be a number\");\n      var buf = Buffer2(size);\n      return fill !== void 0 \? typeof encoding == \"string\" \? buf.fill(fill, encoding) : buf.fill(fill) : buf.fill(0), buf;\n    }, SafeBuffer.allocUnsafe = function(size) {\n      if (typeof size != \"number\")\n        @throwTypeError(\"Argument must be a number\");\n      return Buffer2(size);\n    }, SafeBuffer.allocUnsafeSlow = function(size) {\n      if (typeof size != \"number\")\n        @throwTypeError(\"Argument must be a number\");\n      return buffer.SlowBuffer(size);\n    };\n  }\n}), require_browser = __commonJS({\n  \"node_modules/randombytes/browser.js\"(exports, module) {\n    var MAX_BYTES = 65536, MAX_UINT32 = 4294967295;\n    function oldBrowser() {\n      throw new Error(`Secure random number generation is not supported by this browser.\nUse Chrome, Firefox or Internet Explorer 11`);\n    }\n    var Buffer2 = require_safe_buffer().Buffer, crypto2 = globalCrypto;\n    crypto2 && crypto2.getRandomValues \? module.exports = randomBytes : module.exports = oldBrowser;\n    function randomBytes(size, cb) {\n      if (size > MAX_UINT32)\n        @throwRangeError(\"requested too many random bytes\");\n      var bytes = Buffer2.allocUnsafe(size);\n      if (size > 0)\n        if (size > MAX_BYTES)\n          for (var generated = 0;generated < size; generated += MAX_BYTES)\n            crypto2.getRandomValues(bytes.slice(generated, generated + MAX_BYTES));\n        else\n          crypto2.getRandomValues(bytes);\n      return typeof cb == \"function\" \? process.nextTick(function() {\n        cb(null, bytes);\n      }) : bytes;\n    }\n  }\n}), require_inherits_browser = __commonJS({\n  \"node_modules/inherits/inherits_browser.js\"(exports, module) {\n    module.exports = function(ctor, superCtor) {\n      superCtor && (ctor.super_ = superCtor, ctor.prototype = Object.create(superCtor.prototype, {\n        constructor: {\n          value: ctor,\n          enumerable: !1,\n          writable: !0,\n          configurable: !0\n        }\n      }));\n    };\n  }\n}), require_hash_base = __commonJS({\n  \"node_modules/hash-base/index.js\"(exports, module) {\n    var Buffer2 = require_safe_buffer().Buffer, inherits = require_inherits_browser();\n    function throwIfNotStringOrBuffer(val, prefix) {\n      if (!Buffer2.isBuffer(val) && typeof val != \"string\")\n        @throwTypeError(prefix + \" must be a string or a buffer\");\n    }\n    function HashBase(blockSize) {\n      StreamModule.Transform.call(this), this._block = Buffer2.allocUnsafe(blockSize), this._blockSize = blockSize, this._blockOffset = 0, this._length = [0, 0, 0, 0], this._finalized = !1;\n    }\n    inherits(HashBase, StreamModule.Transform), HashBase.prototype._transform = function(chunk, encoding, callback) {\n      var error = null;\n      try {\n        this.update(chunk, encoding);\n      } catch (err) {\n        error = err;\n      }\n      callback(error);\n    }, HashBase.prototype._flush = function(callback) {\n      var error = null;\n      try {\n        this.push(this.digest());\n      } catch (err) {\n        error = err;\n      }\n      callback(error);\n    }, HashBase.prototype.update = function(data, encoding) {\n      if (throwIfNotStringOrBuffer(data, \"Data\"), this._finalized)\n        throw new Error(\"Digest already called\");\n      Buffer2.isBuffer(data) || (data = Buffer2.from(data, encoding));\n      for (var block = this._block, offset = 0;this._blockOffset + data.length - offset >= this._blockSize; ) {\n        for (var i = this._blockOffset;i < this._blockSize; )\n          block[i++] = data[offset++];\n        this._update(), this._blockOffset = 0;\n      }\n      for (;offset < data.length; )\n        block[this._blockOffset++] = data[offset++];\n      for (var j = 0, carry = data.length * 8;carry > 0; ++j)\n        this._length[j] += carry, carry = this._length[j] / 4294967296 | 0, carry > 0 && (this._length[j] -= 4294967296 * carry);\n      return this;\n    }, HashBase.prototype._update = function() {\n      throw new Error(\"_update is not implemented\");\n    }, HashBase.prototype.digest = function(encoding) {\n      if (this._finalized)\n        throw new Error(\"Digest already called\");\n      this._finalized = !0;\n      var digest = this._digest();\n      encoding !== void 0 && (digest = digest.toString(encoding)), this._block.fill(0), this._blockOffset = 0;\n      for (var i = 0;i < 4; ++i)\n        this._length[i] = 0;\n      return digest;\n    }, HashBase.prototype._digest = function() {\n      throw new Error(\"_digest is not implemented\");\n    }, module.exports = HashBase;\n  }\n}), require_md5 = __commonJS({\n  \"node_modules/md5.js/index.js\"(exports, module) {\n    var inherits = require_inherits_browser(), HashBase = require_hash_base(), Buffer2 = require_safe_buffer().Buffer, ARRAY16 = new Array(16);\n    function MD5() {\n      HashBase.call(this, 64), this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878;\n    }\n    inherits(MD5, HashBase), MD5.prototype._update = function() {\n      for (var M = ARRAY16, i = 0;i < 16; ++i)\n        M[i] = this._block.readInt32LE(i * 4);\n      var a = this._a, b = this._b, c = this._c, d = this._d;\n      a = fnF(a, b, c, d, M[0], 3614090360, 7), d = fnF(d, a, b, c, M[1], 3905402710, 12), c = fnF(c, d, a, b, M[2], 606105819, 17), b = fnF(b, c, d, a, M[3], 3250441966, 22), a = fnF(a, b, c, d, M[4], 4118548399, 7), d = fnF(d, a, b, c, M[5], 1200080426, 12), c = fnF(c, d, a, b, M[6], 2821735955, 17), b = fnF(b, c, d, a, M[7], 4249261313, 22), a = fnF(a, b, c, d, M[8], 1770035416, 7), d = fnF(d, a, b, c, M[9], 2336552879, 12), c = fnF(c, d, a, b, M[10], 4294925233, 17), b = fnF(b, c, d, a, M[11], 2304563134, 22), a = fnF(a, b, c, d, M[12], 1804603682, 7), d = fnF(d, a, b, c, M[13], 4254626195, 12), c = fnF(c, d, a, b, M[14], 2792965006, 17), b = fnF(b, c, d, a, M[15], 1236535329, 22), a = fnG(a, b, c, d, M[1], 4129170786, 5), d = fnG(d, a, b, c, M[6], 3225465664, 9), c = fnG(c, d, a, b, M[11], 643717713, 14), b = fnG(b, c, d, a, M[0], 3921069994, 20), a = fnG(a, b, c, d, M[5], 3593408605, 5), d = fnG(d, a, b, c, M[10], 38016083, 9), c = fnG(c, d, a, b, M[15], 3634488961, 14), b = fnG(b, c, d, a, M[4], 3889429448, 20), a = fnG(a, b, c, d, M[9], 568446438, 5), d = fnG(d, a, b, c, M[14], 3275163606, 9), c = fnG(c, d, a, b, M[3], 4107603335, 14), b = fnG(b, c, d, a, M[8], 1163531501, 20), a = fnG(a, b, c, d, M[13], 2850285829, 5), d = fnG(d, a, b, c, M[2], 4243563512, 9), c = fnG(c, d, a, b, M[7], 1735328473, 14), b = fnG(b, c, d, a, M[12], 2368359562, 20), a = fnH(a, b, c, d, M[5], 4294588738, 4), d = fnH(d, a, b, c, M[8], 2272392833, 11), c = fnH(c, d, a, b, M[11], 1839030562, 16), b = fnH(b, c, d, a, M[14], 4259657740, 23), a = fnH(a, b, c, d, M[1], 2763975236, 4), d = fnH(d, a, b, c, M[4], 1272893353, 11), c = fnH(c, d, a, b, M[7], 4139469664, 16), b = fnH(b, c, d, a, M[10], 3200236656, 23), a = fnH(a, b, c, d, M[13], 681279174, 4), d = fnH(d, a, b, c, M[0], 3936430074, 11), c = fnH(c, d, a, b, M[3], 3572445317, 16), b = fnH(b, c, d, a, M[6], 76029189, 23), a = fnH(a, b, c, d, M[9], 3654602809, 4), d = fnH(d, a, b, c, M[12], 3873151461, 11), c = fnH(c, d, a, b, M[15], 530742520, 16), b = fnH(b, c, d, a, M[2], 3299628645, 23), a = fnI(a, b, c, d, M[0], 4096336452, 6), d = fnI(d, a, b, c, M[7], 1126891415, 10), c = fnI(c, d, a, b, M[14], 2878612391, 15), b = fnI(b, c, d, a, M[5], 4237533241, 21), a = fnI(a, b, c, d, M[12], 1700485571, 6), d = fnI(d, a, b, c, M[3], 2399980690, 10), c = fnI(c, d, a, b, M[10], 4293915773, 15), b = fnI(b, c, d, a, M[1], 2240044497, 21), a = fnI(a, b, c, d, M[8], 1873313359, 6), d = fnI(d, a, b, c, M[15], 4264355552, 10), c = fnI(c, d, a, b, M[6], 2734768916, 15), b = fnI(b, c, d, a, M[13], 1309151649, 21), a = fnI(a, b, c, d, M[4], 4149444226, 6), d = fnI(d, a, b, c, M[11], 3174756917, 10), c = fnI(c, d, a, b, M[2], 718787259, 15), b = fnI(b, c, d, a, M[9], 3951481745, 21), this._a = this._a + a | 0, this._b = this._b + b | 0, this._c = this._c + c | 0, this._d = this._d + d | 0;\n    }, MD5.prototype._digest = function() {\n      this._block[this._blockOffset++] = 128, this._blockOffset > 56 && (this._block.fill(0, this._blockOffset, 64), this._update(), this._blockOffset = 0), this._block.fill(0, this._blockOffset, 56), this._block.writeUInt32LE(this._length[0], 56), this._block.writeUInt32LE(this._length[1], 60), this._update();\n      var buffer = Buffer2.allocUnsafe(16);\n      return buffer.writeInt32LE(this._a, 0), buffer.writeInt32LE(this._b, 4), buffer.writeInt32LE(this._c, 8), buffer.writeInt32LE(this._d, 12), buffer;\n    };\n    function rotl(x, n) {\n      return x << n | x >>> 32 - n;\n    }\n    function fnF(a, b, c, d, m, k, s) {\n      return rotl(a + (b & c | ~b & d) + m + k | 0, s) + b | 0;\n    }\n    function fnG(a, b, c, d, m, k, s) {\n      return rotl(a + (b & d | c & ~d) + m + k | 0, s) + b | 0;\n    }\n    function fnH(a, b, c, d, m, k, s) {\n      return rotl(a + (b ^ c ^ d) + m + k | 0, s) + b | 0;\n    }\n    function fnI(a, b, c, d, m, k, s) {\n      return rotl(a + (c ^ (b | ~d)) + m + k | 0, s) + b | 0;\n    }\n    module.exports = MD5;\n  }\n}), require_ripemd160 = __commonJS({\n  \"node_modules/ripemd160/index.js\"(exports, module) {\n    var Buffer2 = Buffer, inherits = require_inherits_browser(), HashBase = require_hash_base(), ARRAY16 = new Array(16), zl = [\n      0,\n      1,\n      2,\n      3,\n      4,\n      5,\n      6,\n      7,\n      8,\n      9,\n      10,\n      11,\n      12,\n      13,\n      14,\n      15,\n      7,\n      4,\n      13,\n      1,\n      10,\n      6,\n      15,\n      3,\n      12,\n      0,\n      9,\n      5,\n      2,\n      14,\n      11,\n      8,\n      3,\n      10,\n      14,\n      4,\n      9,\n      15,\n      8,\n      1,\n      2,\n      7,\n      0,\n      6,\n      13,\n      11,\n      5,\n      12,\n      1,\n      9,\n      11,\n      10,\n      0,\n      8,\n      12,\n      4,\n      13,\n      3,\n      7,\n      15,\n      14,\n      5,\n      6,\n      2,\n      4,\n      0,\n      5,\n      9,\n      7,\n      12,\n      2,\n      10,\n      14,\n      1,\n      3,\n      8,\n      11,\n      6,\n      15,\n      13\n    ], zr = [\n      5,\n      14,\n      7,\n      0,\n      9,\n      2,\n      11,\n      4,\n      13,\n      6,\n      15,\n      8,\n      1,\n      10,\n      3,\n      12,\n      6,\n      11,\n      3,\n      7,\n      0,\n      13,\n      5,\n      10,\n      14,\n      15,\n      8,\n      12,\n      4,\n      9,\n      1,\n      2,\n      15,\n      5,\n      1,\n      3,\n      7,\n      14,\n      6,\n      9,\n      11,\n      8,\n      12,\n      2,\n      10,\n      0,\n      4,\n      13,\n      8,\n      6,\n      4,\n      1,\n      3,\n      11,\n      15,\n      0,\n      5,\n      12,\n      2,\n      13,\n      9,\n      7,\n      10,\n      14,\n      12,\n      15,\n      10,\n      4,\n      1,\n      5,\n      8,\n      7,\n      6,\n      2,\n      13,\n      14,\n      0,\n      3,\n      9,\n      11\n    ], sl = [\n      11,\n      14,\n      15,\n      12,\n      5,\n      8,\n      7,\n      9,\n      11,\n      13,\n      14,\n      15,\n      6,\n      7,\n      9,\n      8,\n      7,\n      6,\n      8,\n      13,\n      11,\n      9,\n      7,\n      15,\n      7,\n      12,\n      15,\n      9,\n      11,\n      7,\n      13,\n      12,\n      11,\n      13,\n      6,\n      7,\n      14,\n      9,\n      13,\n      15,\n      14,\n      8,\n      13,\n      6,\n      5,\n      12,\n      7,\n      5,\n      11,\n      12,\n      14,\n      15,\n      14,\n      15,\n      9,\n      8,\n      9,\n      14,\n      5,\n      6,\n      8,\n      6,\n      5,\n      12,\n      9,\n      15,\n      5,\n      11,\n      6,\n      8,\n      13,\n      12,\n      5,\n      12,\n      13,\n      14,\n      11,\n      8,\n      5,\n      6\n    ], sr = [\n      8,\n      9,\n      9,\n      11,\n      13,\n      15,\n      15,\n      5,\n      7,\n      7,\n      8,\n      11,\n      14,\n      14,\n      12,\n      6,\n      9,\n      13,\n      15,\n      7,\n      12,\n      8,\n      9,\n      11,\n      7,\n      7,\n      12,\n      7,\n      6,\n      15,\n      13,\n      11,\n      9,\n      7,\n      15,\n      11,\n      8,\n      6,\n      6,\n      14,\n      12,\n      13,\n      5,\n      14,\n      13,\n      13,\n      7,\n      5,\n      15,\n      5,\n      8,\n      11,\n      14,\n      14,\n      6,\n      14,\n      6,\n      9,\n      12,\n      9,\n      12,\n      5,\n      15,\n      8,\n      8,\n      5,\n      12,\n      9,\n      12,\n      5,\n      14,\n      6,\n      8,\n      13,\n      6,\n      5,\n      15,\n      13,\n      11,\n      11\n    ], hl = [0, 1518500249, 1859775393, 2400959708, 2840853838], hr = [1352829926, 1548603684, 1836072691, 2053994217, 0];\n    function RIPEMD160() {\n      HashBase.call(this, 64), this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520;\n    }\n    inherits(RIPEMD160, HashBase), RIPEMD160.prototype._update = function() {\n      for (var words = ARRAY16, j = 0;j < 16; ++j)\n        words[j] = this._block.readInt32LE(j * 4);\n      for (var al = this._a | 0, bl = this._b | 0, cl = this._c | 0, dl = this._d | 0, el = this._e | 0, ar = this._a | 0, br = this._b | 0, cr = this._c | 0, dr = this._d | 0, er = this._e | 0, i = 0;i < 80; i += 1) {\n        var tl, tr;\n        i < 16 \? (tl = fn1(al, bl, cl, dl, el, words[zl[i]], hl[0], sl[i]), tr = fn5(ar, br, cr, dr, er, words[zr[i]], hr[0], sr[i])) : i < 32 \? (tl = fn2(al, bl, cl, dl, el, words[zl[i]], hl[1], sl[i]), tr = fn4(ar, br, cr, dr, er, words[zr[i]], hr[1], sr[i])) : i < 48 \? (tl = fn3(al, bl, cl, dl, el, words[zl[i]], hl[2], sl[i]), tr = fn3(ar, br, cr, dr, er, words[zr[i]], hr[2], sr[i])) : i < 64 \? (tl = fn4(al, bl, cl, dl, el, words[zl[i]], hl[3], sl[i]), tr = fn2(ar, br, cr, dr, er, words[zr[i]], hr[3], sr[i])) : (tl = fn5(al, bl, cl, dl, el, words[zl[i]], hl[4], sl[i]), tr = fn1(ar, br, cr, dr, er, words[zr[i]], hr[4], sr[i])), al = el, el = dl, dl = rotl(cl, 10), cl = bl, bl = tl, ar = er, er = dr, dr = rotl(cr, 10), cr = br, br = tr;\n      }\n      var t = this._b + cl + dr | 0;\n      this._b = this._c + dl + er | 0, this._c = this._d + el + ar | 0, this._d = this._e + al + br | 0, this._e = this._a + bl + cr | 0, this._a = t;\n    }, RIPEMD160.prototype._digest = function() {\n      this._block[this._blockOffset++] = 128, this._blockOffset > 56 && (this._block.fill(0, this._blockOffset, 64), this._update(), this._blockOffset = 0), this._block.fill(0, this._blockOffset, 56), this._block.writeUInt32LE(this._length[0], 56), this._block.writeUInt32LE(this._length[1], 60), this._update();\n      var buffer = Buffer2.alloc \? Buffer2.alloc(20) : new Buffer2(20);\n      return buffer.writeInt32LE(this._a, 0), buffer.writeInt32LE(this._b, 4), buffer.writeInt32LE(this._c, 8), buffer.writeInt32LE(this._d, 12), buffer.writeInt32LE(this._e, 16), buffer;\n    };\n    function rotl(x, n) {\n      return x << n | x >>> 32 - n;\n    }\n    function fn1(a, b, c, d, e, m, k, s) {\n      return rotl(a + (b ^ c ^ d) + m + k | 0, s) + e | 0;\n    }\n    function fn2(a, b, c, d, e, m, k, s) {\n      return rotl(a + (b & c | ~b & d) + m + k | 0, s) + e | 0;\n    }\n    function fn3(a, b, c, d, e, m, k, s) {\n      return rotl(a + ((b | ~c) ^ d) + m + k | 0, s) + e | 0;\n    }\n    function fn4(a, b, c, d, e, m, k, s) {\n      return rotl(a + (b & d | c & ~d) + m + k | 0, s) + e | 0;\n    }\n    function fn5(a, b, c, d, e, m, k, s) {\n      return rotl(a + (b ^ (c | ~d)) + m + k | 0, s) + e | 0;\n    }\n    module.exports = RIPEMD160;\n  }\n}), require_hash = __commonJS({\n  \"node_modules/sha.js/hash.js\"(exports, module) {\n    var Buffer2 = require_safe_buffer().Buffer;\n    function Hash(blockSize, finalSize) {\n      this._block = Buffer2.alloc(blockSize), this._finalSize = finalSize, this._blockSize = blockSize, this._len = 0;\n    }\n    Hash.prototype = {}, Hash.prototype.update = function(data, enc) {\n      typeof data == \"string\" && (enc = enc || \"utf8\", data = Buffer2.from(data, enc));\n      for (var block = this._block, blockSize = this._blockSize, length = data.length, accum = this._len, offset = 0;offset < length; ) {\n        for (var assigned = accum % blockSize, remainder = Math.min(length - offset, blockSize - assigned), i = 0;i < remainder; i++)\n          block[assigned + i] = data[offset + i];\n        accum += remainder, offset += remainder, accum % blockSize === 0 && this._update(block);\n      }\n      return this._len += length, this;\n    }, Hash.prototype.digest = function(enc) {\n      var rem = this._len % this._blockSize;\n      this._block[rem] = 128, this._block.fill(0, rem + 1), rem >= this._finalSize && (this._update(this._block), this._block.fill(0));\n      var bits = this._len * 8;\n      if (bits <= 4294967295)\n        this._block.writeUInt32BE(bits, this._blockSize - 4);\n      else {\n        var lowBits = (bits & 4294967295) >>> 0, highBits = (bits - lowBits) / 4294967296;\n        this._block.writeUInt32BE(highBits, this._blockSize - 8), this._block.writeUInt32BE(lowBits, this._blockSize - 4);\n      }\n      this._update(this._block);\n      var hash = this._hash();\n      return enc \? hash.toString(enc) : hash;\n    }, Hash.prototype._update = function() {\n      throw new Error(\"_update must be implemented by subclass\");\n    }, module.exports = Hash;\n  }\n}), require_sha = __commonJS({\n  \"node_modules/sha.js/sha.js\"(exports, module) {\n    var inherits = require_inherits_browser(), Hash = require_hash(), Buffer2 = require_safe_buffer().Buffer, K = [1518500249, 1859775393, -1894007588, -899497514], W = new Array(80);\n    function Sha() {\n      this.init(), this._w = W, Hash.call(this, 64, 56);\n    }\n    inherits(Sha, Hash), Sha.prototype.init = function() {\n      return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this;\n    };\n    function rotl5(num) {\n      return num << 5 | num >>> 27;\n    }\n    function rotl30(num) {\n      return num << 30 | num >>> 2;\n    }\n    function ft(s, b, c, d) {\n      return s === 0 \? b & c | ~b & d : s === 2 \? b & c | b & d | c & d : b ^ c ^ d;\n    }\n    Sha.prototype._update = function(M) {\n      for (var W2 = this._w, a = this._a | 0, b = this._b | 0, c = this._c | 0, d = this._d | 0, e = this._e | 0, i = 0;i < 16; ++i)\n        W2[i] = M.readInt32BE(i * 4);\n      for (;i < 80; ++i)\n        W2[i] = W2[i - 3] ^ W2[i - 8] ^ W2[i - 14] ^ W2[i - 16];\n      for (var j = 0;j < 80; ++j) {\n        var s = ~~(j / 20), t = rotl5(a) + ft(s, b, c, d) + e + W2[j] + K[s] | 0;\n        e = d, d = c, c = rotl30(b), b = a, a = t;\n      }\n      this._a = a + this._a | 0, this._b = b + this._b | 0, this._c = c + this._c | 0, this._d = d + this._d | 0, this._e = e + this._e | 0;\n    }, Sha.prototype._hash = function() {\n      var H = Buffer2.allocUnsafe(20);\n      return H.writeInt32BE(this._a | 0, 0), H.writeInt32BE(this._b | 0, 4), H.writeInt32BE(this._c | 0, 8), H.writeInt32BE(this._d | 0, 12), H.writeInt32BE(this._e | 0, 16), H;\n    }, module.exports = Sha;\n  }\n}), require_sha1 = __commonJS({\n  \"node_modules/sha.js/sha1.js\"(exports, module) {\n    var inherits = require_inherits_browser(), Hash = require_hash(), Buffer2 = require_safe_buffer().Buffer, K = [1518500249, 1859775393, -1894007588, -899497514], W = new Array(80);\n    function Sha1() {\n      this.init(), this._w = W, Hash.call(this, 64, 56);\n    }\n    inherits(Sha1, Hash), Sha1.prototype.init = function() {\n      return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this;\n    };\n    function rotl1(num) {\n      return num << 1 | num >>> 31;\n    }\n    function rotl5(num) {\n      return num << 5 | num >>> 27;\n    }\n    function rotl30(num) {\n      return num << 30 | num >>> 2;\n    }\n    function ft(s, b, c, d) {\n      return s === 0 \? b & c | ~b & d : s === 2 \? b & c | b & d | c & d : b ^ c ^ d;\n    }\n    Sha1.prototype._update = function(M) {\n      for (var W2 = this._w, a = this._a | 0, b = this._b | 0, c = this._c | 0, d = this._d | 0, e = this._e | 0, i = 0;i < 16; ++i)\n        W2[i] = M.readInt32BE(i * 4);\n      for (;i < 80; ++i)\n        W2[i] = rotl1(W2[i - 3] ^ W2[i - 8] ^ W2[i - 14] ^ W2[i - 16]);\n      for (var j = 0;j < 80; ++j) {\n        var s = ~~(j / 20), t = rotl5(a) + ft(s, b, c, d) + e + W2[j] + K[s] | 0;\n        e = d, d = c, c = rotl30(b), b = a, a = t;\n      }\n      this._a = a + this._a | 0, this._b = b + this._b | 0, this._c = c + this._c | 0, this._d = d + this._d | 0, this._e = e + this._e | 0;\n    }, Sha1.prototype._hash = function() {\n      var H = Buffer2.allocUnsafe(20);\n      return H.writeInt32BE(this._a | 0, 0), H.writeInt32BE(this._b | 0, 4), H.writeInt32BE(this._c | 0, 8), H.writeInt32BE(this._d | 0, 12), H.writeInt32BE(this._e | 0, 16), H;\n    }, module.exports = Sha1;\n  }\n}), require_sha256 = __commonJS({\n  \"node_modules/sha.js/sha256.js\"(exports, module) {\n    var inherits = require_inherits_browser(), Hash = require_hash(), Buffer2 = require_safe_buffer().Buffer, K = [\n      1116352408,\n      1899447441,\n      3049323471,\n      3921009573,\n      961987163,\n      1508970993,\n      2453635748,\n      2870763221,\n      3624381080,\n      310598401,\n      607225278,\n      1426881987,\n      1925078388,\n      2162078206,\n      2614888103,\n      3248222580,\n      3835390401,\n      4022224774,\n      264347078,\n      604807628,\n      770255983,\n      1249150122,\n      1555081692,\n      1996064986,\n      2554220882,\n      2821834349,\n      2952996808,\n      3210313671,\n      3336571891,\n      3584528711,\n      113926993,\n      338241895,\n      666307205,\n      773529912,\n      1294757372,\n      1396182291,\n      1695183700,\n      1986661051,\n      2177026350,\n      2456956037,\n      2730485921,\n      2820302411,\n      3259730800,\n      3345764771,\n      3516065817,\n      3600352804,\n      4094571909,\n      275423344,\n      430227734,\n      506948616,\n      659060556,\n      883997877,\n      958139571,\n      1322822218,\n      1537002063,\n      1747873779,\n      1955562222,\n      2024104815,\n      2227730452,\n      2361852424,\n      2428436474,\n      2756734187,\n      3204031479,\n      3329325298\n    ], W = new Array(64);\n    function Sha256() {\n      this.init(), this._w = W, Hash.call(this, 64, 56);\n    }\n    inherits(Sha256, Hash), Sha256.prototype.init = function() {\n      return this._a = 1779033703, this._b = 3144134277, this._c = 1013904242, this._d = 2773480762, this._e = 1359893119, this._f = 2600822924, this._g = 528734635, this._h = 1541459225, this;\n    };\n    function ch(x, y, z) {\n      return z ^ x & (y ^ z);\n    }\n    function maj(x, y, z) {\n      return x & y | z & (x | y);\n    }\n    function sigma0(x) {\n      return (x >>> 2 | x << 30) ^ (x >>> 13 | x << 19) ^ (x >>> 22 | x << 10);\n    }\n    function sigma1(x) {\n      return (x >>> 6 | x << 26) ^ (x >>> 11 | x << 21) ^ (x >>> 25 | x << 7);\n    }\n    function gamma0(x) {\n      return (x >>> 7 | x << 25) ^ (x >>> 18 | x << 14) ^ x >>> 3;\n    }\n    function gamma1(x) {\n      return (x >>> 17 | x << 15) ^ (x >>> 19 | x << 13) ^ x >>> 10;\n    }\n    Sha256.prototype._update = function(M) {\n      for (var W2 = this._w, a = this._a | 0, b = this._b | 0, c = this._c | 0, d = this._d | 0, e = this._e | 0, f = this._f | 0, g = this._g | 0, h = this._h | 0, i = 0;i < 16; ++i)\n        W2[i] = M.readInt32BE(i * 4);\n      for (;i < 64; ++i)\n        W2[i] = gamma1(W2[i - 2]) + W2[i - 7] + gamma0(W2[i - 15]) + W2[i - 16] | 0;\n      for (var j = 0;j < 64; ++j) {\n        var T1 = h + sigma1(e) + ch(e, f, g) + K[j] + W2[j] | 0, T2 = sigma0(a) + maj(a, b, c) | 0;\n        h = g, g = f, f = e, e = d + T1 | 0, d = c, c = b, b = a, a = T1 + T2 | 0;\n      }\n      this._a = a + this._a | 0, this._b = b + this._b | 0, this._c = c + this._c | 0, this._d = d + this._d | 0, this._e = e + this._e | 0, this._f = f + this._f | 0, this._g = g + this._g | 0, this._h = h + this._h | 0;\n    }, Sha256.prototype._hash = function() {\n      var H = Buffer2.allocUnsafe(32);\n      return H.writeInt32BE(this._a, 0), H.writeInt32BE(this._b, 4), H.writeInt32BE(this._c, 8), H.writeInt32BE(this._d, 12), H.writeInt32BE(this._e, 16), H.writeInt32BE(this._f, 20), H.writeInt32BE(this._g, 24), H.writeInt32BE(this._h, 28), H;\n    }, module.exports = Sha256;\n  }\n}), require_sha224 = __commonJS({\n  \"node_modules/sha.js/sha224.js\"(exports, module) {\n    var inherits = require_inherits_browser(), Sha256 = require_sha256(), Hash = require_hash(), Buffer2 = require_safe_buffer().Buffer, W = new Array(64);\n    function Sha224() {\n      this.init(), this._w = W, Hash.call(this, 64, 56);\n    }\n    inherits(Sha224, Sha256), Sha224.prototype.init = function() {\n      return this._a = 3238371032, this._b = 914150663, this._c = 812702999, this._d = 4144912697, this._e = 4290775857, this._f = 1750603025, this._g = 1694076839, this._h = 3204075428, this;\n    }, Sha224.prototype._hash = function() {\n      var H = Buffer2.allocUnsafe(28);\n      return H.writeInt32BE(this._a, 0), H.writeInt32BE(this._b, 4), H.writeInt32BE(this._c, 8), H.writeInt32BE(this._d, 12), H.writeInt32BE(this._e, 16), H.writeInt32BE(this._f, 20), H.writeInt32BE(this._g, 24), H;\n    }, module.exports = Sha224;\n  }\n}), require_sha512 = __commonJS({\n  \"node_modules/sha.js/sha512.js\"(exports, module) {\n    var inherits = require_inherits_browser(), Hash = require_hash(), Buffer2 = require_safe_buffer().Buffer, K = [\n      1116352408,\n      3609767458,\n      1899447441,\n      602891725,\n      3049323471,\n      3964484399,\n      3921009573,\n      2173295548,\n      961987163,\n      4081628472,\n      1508970993,\n      3053834265,\n      2453635748,\n      2937671579,\n      2870763221,\n      3664609560,\n      3624381080,\n      2734883394,\n      310598401,\n      1164996542,\n      607225278,\n      1323610764,\n      1426881987,\n      3590304994,\n      1925078388,\n      4068182383,\n      2162078206,\n      991336113,\n      2614888103,\n      633803317,\n      3248222580,\n      3479774868,\n      3835390401,\n      2666613458,\n      4022224774,\n      944711139,\n      264347078,\n      2341262773,\n      604807628,\n      2007800933,\n      770255983,\n      1495990901,\n      1249150122,\n      1856431235,\n      1555081692,\n      3175218132,\n      1996064986,\n      2198950837,\n      2554220882,\n      3999719339,\n      2821834349,\n      766784016,\n      2952996808,\n      2566594879,\n      3210313671,\n      3203337956,\n      3336571891,\n      1034457026,\n      3584528711,\n      2466948901,\n      113926993,\n      3758326383,\n      338241895,\n      168717936,\n      666307205,\n      1188179964,\n      773529912,\n      1546045734,\n      1294757372,\n      1522805485,\n      1396182291,\n      2643833823,\n      1695183700,\n      2343527390,\n      1986661051,\n      1014477480,\n      2177026350,\n      1206759142,\n      2456956037,\n      344077627,\n      2730485921,\n      1290863460,\n      2820302411,\n      3158454273,\n      3259730800,\n      3505952657,\n      3345764771,\n      106217008,\n      3516065817,\n      3606008344,\n      3600352804,\n      1432725776,\n      4094571909,\n      1467031594,\n      275423344,\n      851169720,\n      430227734,\n      3100823752,\n      506948616,\n      1363258195,\n      659060556,\n      3750685593,\n      883997877,\n      3785050280,\n      958139571,\n      3318307427,\n      1322822218,\n      3812723403,\n      1537002063,\n      2003034995,\n      1747873779,\n      3602036899,\n      1955562222,\n      1575990012,\n      2024104815,\n      1125592928,\n      2227730452,\n      2716904306,\n      2361852424,\n      442776044,\n      2428436474,\n      593698344,\n      2756734187,\n      3733110249,\n      3204031479,\n      2999351573,\n      3329325298,\n      3815920427,\n      3391569614,\n      3928383900,\n      3515267271,\n      566280711,\n      3940187606,\n      3454069534,\n      4118630271,\n      4000239992,\n      116418474,\n      1914138554,\n      174292421,\n      2731055270,\n      289380356,\n      3203993006,\n      460393269,\n      320620315,\n      685471733,\n      587496836,\n      852142971,\n      1086792851,\n      1017036298,\n      365543100,\n      1126000580,\n      2618297676,\n      1288033470,\n      3409855158,\n      1501505948,\n      4234509866,\n      1607167915,\n      987167468,\n      1816402316,\n      1246189591\n    ], W = new Array(160);\n    function Sha512() {\n      this.init(), this._w = W, Hash.call(this, 128, 112);\n    }\n    inherits(Sha512, Hash), Sha512.prototype.init = function() {\n      return this._ah = 1779033703, this._bh = 3144134277, this._ch = 1013904242, this._dh = 2773480762, this._eh = 1359893119, this._fh = 2600822924, this._gh = 528734635, this._hh = 1541459225, this._al = 4089235720, this._bl = 2227873595, this._cl = 4271175723, this._dl = 1595750129, this._el = 2917565137, this._fl = 725511199, this._gl = 4215389547, this._hl = 327033209, this;\n    };\n    function Ch(x, y, z) {\n      return z ^ x & (y ^ z);\n    }\n    function maj(x, y, z) {\n      return x & y | z & (x | y);\n    }\n    function sigma0(x, xl) {\n      return (x >>> 28 | xl << 4) ^ (xl >>> 2 | x << 30) ^ (xl >>> 7 | x << 25);\n    }\n    function sigma1(x, xl) {\n      return (x >>> 14 | xl << 18) ^ (x >>> 18 | xl << 14) ^ (xl >>> 9 | x << 23);\n    }\n    function Gamma0(x, xl) {\n      return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ x >>> 7;\n    }\n    function Gamma0l(x, xl) {\n      return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ (x >>> 7 | xl << 25);\n    }\n    function Gamma1(x, xl) {\n      return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ x >>> 6;\n    }\n    function Gamma1l(x, xl) {\n      return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ (x >>> 6 | xl << 26);\n    }\n    function getCarry(a, b) {\n      return a >>> 0 < b >>> 0 \? 1 : 0;\n    }\n    Sha512.prototype._update = function(M) {\n      for (var W2 = this._w, ah = this._ah | 0, bh = this._bh | 0, ch = this._ch | 0, dh = this._dh | 0, eh = this._eh | 0, fh = this._fh | 0, gh = this._gh | 0, hh = this._hh | 0, al = this._al | 0, bl = this._bl | 0, cl = this._cl | 0, dl = this._dl | 0, el = this._el | 0, fl = this._fl | 0, gl = this._gl | 0, hl = this._hl | 0, i = 0;i < 32; i += 2)\n        W2[i] = M.readInt32BE(i * 4), W2[i + 1] = M.readInt32BE(i * 4 + 4);\n      for (;i < 160; i += 2) {\n        var xh = W2[i - 30], xl = W2[i - 30 + 1], gamma0 = Gamma0(xh, xl), gamma0l = Gamma0l(xl, xh);\n        xh = W2[i - 4], xl = W2[i - 4 + 1];\n        var gamma1 = Gamma1(xh, xl), gamma1l = Gamma1l(xl, xh), Wi7h = W2[i - 14], Wi7l = W2[i - 14 + 1], Wi16h = W2[i - 32], Wi16l = W2[i - 32 + 1], Wil = gamma0l + Wi7l | 0, Wih = gamma0 + Wi7h + getCarry(Wil, gamma0l) | 0;\n        Wil = Wil + gamma1l | 0, Wih = Wih + gamma1 + getCarry(Wil, gamma1l) | 0, Wil = Wil + Wi16l | 0, Wih = Wih + Wi16h + getCarry(Wil, Wi16l) | 0, W2[i] = Wih, W2[i + 1] = Wil;\n      }\n      for (var j = 0;j < 160; j += 2) {\n        Wih = W2[j], Wil = W2[j + 1];\n        var majh = maj(ah, bh, ch), majl = maj(al, bl, cl), sigma0h = sigma0(ah, al), sigma0l = sigma0(al, ah), sigma1h = sigma1(eh, el), sigma1l = sigma1(el, eh), Kih = K[j], Kil = K[j + 1], chh = Ch(eh, fh, gh), chl = Ch(el, fl, gl), t1l = hl + sigma1l | 0, t1h = hh + sigma1h + getCarry(t1l, hl) | 0;\n        t1l = t1l + chl | 0, t1h = t1h + chh + getCarry(t1l, chl) | 0, t1l = t1l + Kil | 0, t1h = t1h + Kih + getCarry(t1l, Kil) | 0, t1l = t1l + Wil | 0, t1h = t1h + Wih + getCarry(t1l, Wil) | 0;\n        var t2l = sigma0l + majl | 0, t2h = sigma0h + majh + getCarry(t2l, sigma0l) | 0;\n        hh = gh, hl = gl, gh = fh, gl = fl, fh = eh, fl = el, el = dl + t1l | 0, eh = dh + t1h + getCarry(el, dl) | 0, dh = ch, dl = cl, ch = bh, cl = bl, bh = ah, bl = al, al = t1l + t2l | 0, ah = t1h + t2h + getCarry(al, t1l) | 0;\n      }\n      this._al = this._al + al | 0, this._bl = this._bl + bl | 0, this._cl = this._cl + cl | 0, this._dl = this._dl + dl | 0, this._el = this._el + el | 0, this._fl = this._fl + fl | 0, this._gl = this._gl + gl | 0, this._hl = this._hl + hl | 0, this._ah = this._ah + ah + getCarry(this._al, al) | 0, this._bh = this._bh + bh + getCarry(this._bl, bl) | 0, this._ch = this._ch + ch + getCarry(this._cl, cl) | 0, this._dh = this._dh + dh + getCarry(this._dl, dl) | 0, this._eh = this._eh + eh + getCarry(this._el, el) | 0, this._fh = this._fh + fh + getCarry(this._fl, fl) | 0, this._gh = this._gh + gh + getCarry(this._gl, gl) | 0, this._hh = this._hh + hh + getCarry(this._hl, hl) | 0;\n    }, Sha512.prototype._hash = function() {\n      var H = Buffer2.allocUnsafe(64);\n      function writeInt64BE(h, l, offset) {\n        H.writeInt32BE(h, offset), H.writeInt32BE(l, offset + 4);\n      }\n      return writeInt64BE(this._ah, this._al, 0), writeInt64BE(this._bh, this._bl, 8), writeInt64BE(this._ch, this._cl, 16), writeInt64BE(this._dh, this._dl, 24), writeInt64BE(this._eh, this._el, 32), writeInt64BE(this._fh, this._fl, 40), writeInt64BE(this._gh, this._gl, 48), writeInt64BE(this._hh, this._hl, 56), H;\n    }, module.exports = Sha512;\n  }\n}), require_sha384 = __commonJS({\n  \"node_modules/sha.js/sha384.js\"(exports, module) {\n    var inherits = require_inherits_browser(), SHA512 = require_sha512(), Hash = require_hash(), Buffer2 = require_safe_buffer().Buffer, W = new Array(160);\n    function Sha384() {\n      this.init(), this._w = W, Hash.call(this, 128, 112);\n    }\n    inherits(Sha384, SHA512), Sha384.prototype.init = function() {\n      return this._ah = 3418070365, this._bh = 1654270250, this._ch = 2438529370, this._dh = 355462360, this._eh = 1731405415, this._fh = 2394180231, this._gh = 3675008525, this._hh = 1203062813, this._al = 3238371032, this._bl = 914150663, this._cl = 812702999, this._dl = 4144912697, this._el = 4290775857, this._fl = 1750603025, this._gl = 1694076839, this._hl = 3204075428, this;\n    }, Sha384.prototype._hash = function() {\n      var H = Buffer2.allocUnsafe(48);\n      function writeInt64BE(h, l, offset) {\n        H.writeInt32BE(h, offset), H.writeInt32BE(l, offset + 4);\n      }\n      return writeInt64BE(this._ah, this._al, 0), writeInt64BE(this._bh, this._bl, 8), writeInt64BE(this._ch, this._cl, 16), writeInt64BE(this._dh, this._dl, 24), writeInt64BE(this._eh, this._el, 32), writeInt64BE(this._fh, this._fl, 40), H;\n    }, module.exports = Sha384;\n  }\n}), require_sha2 = __commonJS({\n  \"node_modules/sha.js/index.js\"(exports, module) {\n    var exports = module.exports = function(algorithm) {\n      algorithm = algorithm.toLowerCase();\n      var Algorithm = exports[algorithm];\n      if (!Algorithm)\n        throw new Error(algorithm + \" is not supported (we accept pull requests)\");\n      return new Algorithm;\n    };\n    exports.sha = require_sha(), exports.sha1 = require_sha1(), exports.sha224 = require_sha224(), exports.sha256 = require_sha256(), exports.sha384 = require_sha384(), exports.sha512 = require_sha512();\n  }\n}), require_cipher_base = __commonJS({\n  \"node_modules/cipher-base/index.js\"(exports, module) {\n    var Buffer2 = require_safe_buffer().Buffer, inherits = require_inherits_browser();\n    function CipherBase(hashMode) {\n      StreamModule.Transform.call(this), this.hashMode = typeof hashMode == \"string\", this.hashMode \? this[hashMode] = this._finalOrDigest : this.final = this._finalOrDigest, this._final && (this.__final = this._final, this._final = null), this._decoder = null, this._encoding = null;\n    }\n    inherits(CipherBase, StreamModule.Transform), CipherBase.prototype.update = function(data, inputEnc, outputEnc) {\n      typeof data == \"string\" && (data = Buffer2.from(data, inputEnc));\n      var outData = this._update(data);\n      return this.hashMode \? this : (outputEnc && (outData = this._toString(outData, outputEnc)), outData);\n    }, CipherBase.prototype.setAutoPadding = function() {\n    }, CipherBase.prototype.getAuthTag = function() {\n      throw new Error(\"trying to get auth tag in unsupported state\");\n    }, CipherBase.prototype.setAuthTag = function() {\n      throw new Error(\"trying to set auth tag in unsupported state\");\n    }, CipherBase.prototype.setAAD = function() {\n      throw new Error(\"trying to set aad in unsupported state\");\n    }, CipherBase.prototype._transform = function(data, _, next) {\n      var err;\n      try {\n        this.hashMode \? this._update(data) : this.push(this._update(data));\n      } catch (e) {\n        err = e;\n      } finally {\n        next(err);\n      }\n    }, CipherBase.prototype._flush = function(done) {\n      var err;\n      try {\n        this.push(this.__final());\n      } catch (e) {\n        err = e;\n      }\n      done(err);\n    }, CipherBase.prototype._finalOrDigest = function(outputEnc) {\n      var outData = this.__final() || Buffer2.alloc(0);\n      return outputEnc && (outData = this._toString(outData, outputEnc, !0)), outData;\n    }, CipherBase.prototype._toString = function(value, enc, fin) {\n      if (this._decoder || (this._decoder = new StringDecoder(enc), this._encoding = enc), this._encoding !== enc)\n        throw new Error(\"can't switch encodings\");\n      var out = this._decoder.write(value);\n      return fin && (out += this._decoder.end()), out;\n    }, module.exports = CipherBase;\n  }\n}), require_browser2 = __commonJS({\n  \"node_modules/create-hash/browser.js\"(exports, module) {\n    const LazyHash = function Hash(algorithm, options) {\n      this._options = options, this._hasher = new CryptoHasher(algorithm, options), this._finalized = !1;\n    };\n    LazyHash.prototype = Object.create(StreamModule.Transform.prototype), LazyHash.prototype.update = function update(data, encoding) {\n      return this._checkFinalized(), this._hasher.update(data, encoding), this;\n    }, LazyHash.prototype.digest = function update(data, encoding) {\n      return this._checkFinalized(), this._finalized = !0, this._hasher.digest(data, encoding);\n    }, LazyHash.prototype._checkFinalized = function _checkFinalized() {\n      if (this._finalized) {\n        var err = new Error(\"Digest already called\");\n        throw err.code = \"ERR_CRYPTO_HASH_FINALIZED\", err;\n      }\n    }, LazyHash.prototype.copy = function copy() {\n      const copy = Object.create(LazyHash.prototype);\n      return copy._options = this._options, copy._hasher = this._hasher.copy(), copy._finalized = this._finalized, copy;\n    };\n    const lazyHashFullInitProto = {\n      __proto__: StreamModule.Transform.prototype,\n      ...LazyHash.prototype,\n      _transform(data, encoding, callback) {\n        this.update(data, encoding), callback && callback();\n      },\n      _flush(callback) {\n        this.push(this.digest()), callback();\n      }\n    }, triggerMethods = [\n      \"_events\",\n      \"_eventsCount\",\n      \"_final\",\n      \"_maxListeners\",\n      \"_maxListeners\",\n      \"_read\",\n      \"_undestroy\",\n      \"_writableState\",\n      \"_write\",\n      \"_writev\",\n      \"addListener\",\n      \"asIndexedPairs\",\n      \"closed\",\n      \"compose\",\n      \"constructor\",\n      \"cork\",\n      \"destroy\",\n      \"destroyed\",\n      \"drop\",\n      \"emit\",\n      \"end\",\n      \"errored\",\n      \"eventNames\",\n      \"every\",\n      \"filter\",\n      \"find\",\n      \"flatMap\",\n      \"forEach\",\n      \"getMaxListeners\",\n      \"hasOwnProperty\",\n      \"isPaused\",\n      \"isPrototypeOf\",\n      \"iterator\",\n      \"listenerCount\",\n      \"listeners\",\n      \"map\",\n      \"off\",\n      \"on\",\n      \"once\",\n      \"pause\",\n      \"pipe\",\n      \"prependListener\",\n      \"prependOnceListener\",\n      \"propertyIsEnumerable\",\n      \"push\",\n      \"rawListeners\",\n      \"read\",\n      \"readable\",\n      \"readableAborted\",\n      \"readableBuffer\",\n      \"readableDidRead\",\n      \"readableEncoding\",\n      \"readableEnded\",\n      \"readableFlowing\",\n      \"readableHighWaterMark\",\n      \"readableLength\",\n      \"readableObjectMode\",\n      \"reduce\",\n      \"removeAllListeners\",\n      \"removeListener\",\n      \"resume\",\n      \"setDefaultEncoding\",\n      \"setEncoding\",\n      \"setMaxListeners\",\n      \"some\",\n      \"take\",\n      \"toArray\",\n      \"toLocaleString\",\n      \"toString\",\n      \"uncork\",\n      \"unpipe\",\n      \"unshift\",\n      \"valueOf\",\n      \"wrap\",\n      \"writable\",\n      \"writableBuffer\",\n      \"writableCorked\",\n      \"writableEnded\",\n      \"writableFinished\",\n      \"writableHighWaterMark\",\n      \"writableLength\",\n      \"writableNeedDrain\",\n      \"writableObjectMode\",\n      \"write\"\n    ];\n    for (let method of triggerMethods)\n      Object.defineProperty(LazyHash.prototype, method, {\n        get() {\n          return Object.setPrototypeOf(this, lazyHashFullInitProto), StreamModule.Transform.call(this, this._options), this[method];\n        },\n        enumerable: !1,\n        configurable: !0\n      });\n    module.exports = function createHash(algorithm) {\n      return new LazyHash(algorithm);\n    }, module.exports.createHash = module.exports, module.exports.Hash = LazyHash;\n  }\n}), require_legacy = __commonJS({\n  \"node_modules/create-hmac/legacy.js\"(exports, module) {\n    var inherits = require_inherits_browser(), Buffer2 = require_safe_buffer().Buffer, Base = require_cipher_base(), ZEROS = Buffer2.alloc(128), blocksize = 64;\n    function Hmac(alg, key) {\n      Base.call(this, \"digest\"), typeof key == \"string\" && (key = Buffer2.from(key)), this._alg = alg, this._key = key, key.length > blocksize \? key = alg(key) : key.length < blocksize && (key = Buffer2.concat([key, ZEROS], blocksize));\n      for (var ipad = this._ipad = Buffer2.allocUnsafe(blocksize), opad = this._opad = Buffer2.allocUnsafe(blocksize), i = 0;i < blocksize; i++)\n        ipad[i] = key[i] ^ 54, opad[i] = key[i] ^ 92;\n      this._hash = [ipad];\n    }\n    Hmac.prototype = {}, inherits(Hmac, Base), Hmac.prototype._update = function(data) {\n      this._hash.push(data);\n    }, Hmac.prototype._final = function() {\n      var h = this._alg(Buffer2.concat(this._hash));\n      return this._alg(Buffer2.concat([this._opad, h]));\n    }, module.exports = Hmac;\n  }\n}), require_md52 = __commonJS({\n  \"node_modules/create-hash/md5.js\"(exports, module) {\n    var MD5 = require_md5();\n    module.exports = function(buffer) {\n      return new MD5().update(buffer).digest();\n    };\n  }\n}), require_browser3 = __commonJS({\n  \"node_modules/create-hmac/browser.js\"(exports, module) {\n    var inherits = require_inherits_browser(), Legacy = require_legacy(), Base = require_cipher_base(), Buffer2 = require_safe_buffer().Buffer, md5 = require_md52(), RIPEMD160 = require_ripemd160(), sha = require_sha2(), ZEROS = Buffer2.alloc(128);\n    function Hmac(alg, key) {\n      Base.call(this, \"digest\"), typeof key == \"string\" && (key = Buffer2.from(key));\n      var blocksize = alg === \"sha512\" || alg === \"sha384\" \? 128 : 64;\n      if (this._alg = alg, this._key = key, key.length > blocksize) {\n        var hash = alg === \"rmd160\" \? new RIPEMD160 : sha(alg);\n        key = hash.update(key).digest();\n      } else\n        key.length < blocksize && (key = Buffer2.concat([key, ZEROS], blocksize));\n      for (var ipad = this._ipad = Buffer2.allocUnsafe(blocksize), opad = this._opad = Buffer2.allocUnsafe(blocksize), i = 0;i < blocksize; i++)\n        ipad[i] = key[i] ^ 54, opad[i] = key[i] ^ 92;\n      this._hash = alg === \"rmd160\" \? new RIPEMD160 : sha(alg), this._hash.update(ipad);\n    }\n    inherits(Hmac, Base), Hmac.prototype._update = function(data) {\n      this._hash.update(data);\n    }, Hmac.prototype._final = function() {\n      var h = this._hash.digest(), hash = this._alg === \"rmd160\" \? new RIPEMD160 : sha(this._alg);\n      return hash.update(this._opad).update(h).digest();\n    }, module.exports = function(alg, key) {\n      return alg = alg.toLowerCase(), alg === \"rmd160\" || alg === \"ripemd160\" \? new Hmac(\"rmd160\", key) : alg === \"md5\" \? new Legacy(md5, key) : new Hmac(alg, key);\n    };\n  }\n}), require_algorithms = __commonJS({\n  \"node_modules/browserify-sign/browser/algorithms.json\"(exports, module) {\n    module.exports = {\n      sha224WithRSAEncryption: {\n        sign: \"rsa\",\n        hash: \"sha224\",\n        id: \"302d300d06096086480165030402040500041c\"\n      },\n      \"RSA-SHA224\": {\n        sign: \"ecdsa/rsa\",\n        hash: \"sha224\",\n        id: \"302d300d06096086480165030402040500041c\"\n      },\n      sha256WithRSAEncryption: {\n        sign: \"rsa\",\n        hash: \"sha256\",\n        id: \"3031300d060960864801650304020105000420\"\n      },\n      \"RSA-SHA256\": {\n        sign: \"ecdsa/rsa\",\n        hash: \"sha256\",\n        id: \"3031300d060960864801650304020105000420\"\n      },\n      sha384WithRSAEncryption: {\n        sign: \"rsa\",\n        hash: \"sha384\",\n        id: \"3041300d060960864801650304020205000430\"\n      },\n      \"RSA-SHA384\": {\n        sign: \"ecdsa/rsa\",\n        hash: \"sha384\",\n        id: \"3041300d060960864801650304020205000430\"\n      },\n      sha512WithRSAEncryption: {\n        sign: \"rsa\",\n        hash: \"sha512\",\n        id: \"3051300d060960864801650304020305000440\"\n      },\n      \"RSA-SHA512\": {\n        sign: \"ecdsa/rsa\",\n        hash: \"sha512\",\n        id: \"3051300d060960864801650304020305000440\"\n      },\n      \"RSA-SHA1\": {\n        sign: \"rsa\",\n        hash: \"sha1\",\n        id: \"3021300906052b0e03021a05000414\"\n      },\n      \"ecdsa-with-SHA1\": {\n        sign: \"ecdsa\",\n        hash: \"sha1\",\n        id: \"\"\n      },\n      sha256: {\n        sign: \"ecdsa\",\n        hash: \"sha256\",\n        id: \"\"\n      },\n      sha224: {\n        sign: \"ecdsa\",\n        hash: \"sha224\",\n        id: \"\"\n      },\n      sha384: {\n        sign: \"ecdsa\",\n        hash: \"sha384\",\n        id: \"\"\n      },\n      sha512: {\n        sign: \"ecdsa\",\n        hash: \"sha512\",\n        id: \"\"\n      },\n      \"DSA-SHA\": {\n        sign: \"dsa\",\n        hash: \"sha1\",\n        id: \"\"\n      },\n      \"DSA-SHA1\": {\n        sign: \"dsa\",\n        hash: \"sha1\",\n        id: \"\"\n      },\n      DSA: {\n        sign: \"dsa\",\n        hash: \"sha1\",\n        id: \"\"\n      },\n      \"DSA-WITH-SHA224\": {\n        sign: \"dsa\",\n        hash: \"sha224\",\n        id: \"\"\n      },\n      \"DSA-SHA224\": {\n        sign: \"dsa\",\n        hash: \"sha224\",\n        id: \"\"\n      },\n      \"DSA-WITH-SHA256\": {\n        sign: \"dsa\",\n        hash: \"sha256\",\n        id: \"\"\n      },\n      \"DSA-SHA256\": {\n        sign: \"dsa\",\n        hash: \"sha256\",\n        id: \"\"\n      },\n      \"DSA-WITH-SHA384\": {\n        sign: \"dsa\",\n        hash: \"sha384\",\n        id: \"\"\n      },\n      \"DSA-SHA384\": {\n        sign: \"dsa\",\n        hash: \"sha384\",\n        id: \"\"\n      },\n      \"DSA-WITH-SHA512\": {\n        sign: \"dsa\",\n        hash: \"sha512\",\n        id: \"\"\n      },\n      \"DSA-SHA512\": {\n        sign: \"dsa\",\n        hash: \"sha512\",\n        id: \"\"\n      },\n      \"DSA-RIPEMD160\": {\n        sign: \"dsa\",\n        hash: \"rmd160\",\n        id: \"\"\n      },\n      ripemd160WithRSA: {\n        sign: \"rsa\",\n        hash: \"rmd160\",\n        id: \"3021300906052b2403020105000414\"\n      },\n      \"RSA-RIPEMD160\": {\n        sign: \"rsa\",\n        hash: \"rmd160\",\n        id: \"3021300906052b2403020105000414\"\n      },\n      md5WithRSAEncryption: {\n        sign: \"rsa\",\n        hash: \"md5\",\n        id: \"3020300c06082a864886f70d020505000410\"\n      },\n      \"RSA-MD5\": {\n        sign: \"rsa\",\n        hash: \"md5\",\n        id: \"3020300c06082a864886f70d020505000410\"\n      }\n    };\n  }\n}), require_algos = __commonJS({\n  \"node_modules/browserify-sign/algos.js\"(exports, module) {\n    module.exports = require_algorithms();\n  }\n}), require_precondition = __commonJS({\n  \"node_modules/pbkdf2/lib/precondition.js\"(exports, module) {\n    var MAX_ALLOC = Math.pow(2, 30) - 1;\n    module.exports = function(iterations, keylen) {\n      if (typeof iterations != \"number\")\n        @throwTypeError(\"Iterations not a number\");\n      if (iterations < 0)\n        @throwTypeError(\"Bad iterations\");\n      if (typeof keylen != \"number\")\n        @throwTypeError(\"Key length not a number\");\n      if (keylen < 0 || keylen > MAX_ALLOC || keylen !== keylen)\n        @throwTypeError(\"Bad key length\");\n    };\n  }\n}), require_default_encoding = __commonJS({\n  \"node_modules/pbkdf2/lib/default-encoding.js\"(exports, module) {\n    var defaultEncoding;\n    global.process && global.process.browser \? defaultEncoding = \"utf-8\" : global.process && global.process.version \? (pVersionMajor = parseInt(process.version.split(\".\")[0].slice(1), 10), defaultEncoding = pVersionMajor >= 6 \? \"utf-8\" : \"binary\") : defaultEncoding = \"utf-8\";\n    var pVersionMajor;\n    module.exports = defaultEncoding;\n  }\n}), require_to_buffer = __commonJS({\n  \"node_modules/pbkdf2/lib/to-buffer.js\"(exports, module) {\n    var Buffer2 = require_safe_buffer().Buffer;\n    module.exports = function(thing, encoding, name) {\n      if (Buffer2.isBuffer(thing))\n        return thing;\n      if (typeof thing == \"string\")\n        return Buffer2.from(thing, encoding);\n      if (ArrayBuffer.isView(thing))\n        return Buffer2.from(thing.buffer);\n      @throwTypeError(name + \" must be a string, a Buffer, a typed array or a DataView\");\n    };\n  }\n}), require_sync_browser = __commonJS({\n  \"node_modules/pbkdf2/lib/sync-browser.js\"(exports, module) {\n    var md5 = require_md52(), RIPEMD160 = require_ripemd160(), sha = require_sha2(), Buffer2 = require_safe_buffer().Buffer, checkParameters = require_precondition(), defaultEncoding = require_default_encoding(), toBuffer = require_to_buffer(), ZEROS = Buffer2.alloc(128), sizes = {\n      md5: 16,\n      sha1: 20,\n      sha224: 28,\n      sha256: 32,\n      sha384: 48,\n      sha512: 64,\n      rmd160: 20,\n      ripemd160: 20\n    };\n    function Hmac(alg, key, saltLen) {\n      var hash = getDigest(alg), blocksize = alg === \"sha512\" || alg === \"sha384\" \? 128 : 64;\n      key.length > blocksize \? key = hash(key) : key.length < blocksize && (key = Buffer2.concat([key, ZEROS], blocksize));\n      for (var ipad = Buffer2.allocUnsafe(blocksize + sizes[alg]), opad = Buffer2.allocUnsafe(blocksize + sizes[alg]), i = 0;i < blocksize; i++)\n        ipad[i] = key[i] ^ 54, opad[i] = key[i] ^ 92;\n      var ipad1 = Buffer2.allocUnsafe(blocksize + saltLen + 4);\n      ipad.copy(ipad1, 0, 0, blocksize), this.ipad1 = ipad1, this.ipad2 = ipad, this.opad = opad, this.alg = alg, this.blocksize = blocksize, this.hash = hash, this.size = sizes[alg];\n    }\n    Hmac.prototype = {}, Hmac.prototype.run = function(data, ipad) {\n      data.copy(ipad, this.blocksize);\n      var h = this.hash(ipad);\n      return h.copy(this.opad, this.blocksize), this.hash(this.opad);\n    };\n    function getDigest(alg) {\n      function shaFunc(data) {\n        return sha(alg).update(data).digest();\n      }\n      function rmd160Func(data) {\n        return new RIPEMD160().update(data).digest();\n      }\n      return alg === \"rmd160\" || alg === \"ripemd160\" \? rmd160Func : alg === \"md5\" \? md5 : shaFunc;\n    }\n    function pbkdf2(password, salt, iterations, keylen, digest) {\n      checkParameters(iterations, keylen), password = toBuffer(password, defaultEncoding, \"Password\"), salt = toBuffer(salt, defaultEncoding, \"Salt\"), digest = digest || \"sha1\";\n      var hmac = new Hmac(digest, password, salt.length), DK = Buffer2.allocUnsafe(keylen), block1 = Buffer2.allocUnsafe(salt.length + 4);\n      salt.copy(block1, 0, 0, salt.length);\n      for (var destPos = 0, hLen = sizes[digest], l = Math.ceil(keylen / hLen), i = 1;i <= l; i++) {\n        block1.writeUInt32BE(i, salt.length);\n        for (var T = hmac.run(block1, hmac.ipad1), U = T, j = 1;j < iterations; j++) {\n          U = hmac.run(U, hmac.ipad2);\n          for (var k = 0;k < hLen; k++)\n            T[k] ^= U[k];\n        }\n        T.copy(DK, destPos), destPos += hLen;\n      }\n      return DK;\n    }\n    module.exports = pbkdf2;\n  }\n}), require_async = __commonJS({\n  \"node_modules/pbkdf2/lib/async.js\"(exports, module) {\n    var Buffer2 = require_safe_buffer().Buffer, checkParameters = require_precondition(), defaultEncoding = require_default_encoding(), sync = require_sync_browser(), toBuffer = require_to_buffer(), ZERO_BUF, subtle = globalCrypto.subtle, toBrowser = {\n      sha: \"SHA-1\",\n      \"sha-1\": \"SHA-1\",\n      sha1: \"SHA-1\",\n      sha256: \"SHA-256\",\n      \"sha-256\": \"SHA-256\",\n      sha384: \"SHA-384\",\n      \"sha-384\": \"SHA-384\",\n      \"sha-512\": \"SHA-512\",\n      sha512: \"SHA-512\"\n    }, checks = [];\n    function checkNative(algo) {\n      if (global.process && !global.process.browser || !subtle || !subtle.importKey || !subtle.deriveBits)\n        return Promise.resolve(!1);\n      if (checks[algo] !== void 0)\n        return checks[algo];\n      ZERO_BUF = ZERO_BUF || Buffer2.alloc(8);\n      var prom = browserPbkdf2(ZERO_BUF, ZERO_BUF, 10, 128, algo).then(function() {\n        return !0;\n      }).catch(function() {\n        return !1;\n      });\n      return checks[algo] = prom, prom;\n    }\n    var nextTick;\n    function getNextTick() {\n      return nextTick || (global.process && global.process.nextTick \? nextTick = global.process.nextTick : global.queueMicrotask \? nextTick = global.queueMicrotask : global.setImmediate \? nextTick = global.setImmediate : nextTick = global.setTimeout, nextTick);\n    }\n    function browserPbkdf2(password, salt, iterations, length, algo) {\n      return subtle.importKey(\"raw\", password, { name: \"PBKDF2\" }, !1, [\"deriveBits\"]).then(function(key) {\n        return subtle.deriveBits({\n          name: \"PBKDF2\",\n          salt,\n          iterations,\n          hash: {\n            name: algo\n          }\n        }, key, length << 3);\n      }).then(function(res) {\n        return Buffer2.from(res);\n      });\n    }\n    function resolvePromise(promise, callback) {\n      promise.then(function(out) {\n        getNextTick()(function() {\n          callback(null, out);\n        });\n      }, function(e) {\n        getNextTick()(function() {\n          callback(e);\n        });\n      });\n    }\n    module.exports = function(password, salt, iterations, keylen, digest, callback) {\n      typeof digest == \"function\" && (callback = digest, digest = void 0), digest = digest || \"sha1\";\n      var algo = toBrowser[digest.toLowerCase()];\n      if (!algo || typeof global.Promise != \"function\") {\n        getNextTick()(function() {\n          var out;\n          try {\n            out = sync(password, salt, iterations, keylen, digest);\n          } catch (e) {\n            return callback(e);\n          }\n          callback(null, out);\n        });\n        return;\n      }\n      if (checkParameters(iterations, keylen), password = toBuffer(password, defaultEncoding, \"Password\"), salt = toBuffer(salt, defaultEncoding, \"Salt\"), typeof callback != \"function\")\n        throw new Error(\"No callback provided to pbkdf2\");\n      resolvePromise(checkNative(algo).then(function(resp) {\n        return resp \? browserPbkdf2(password, salt, iterations, keylen, algo) : sync(password, salt, iterations, keylen, digest);\n      }), callback);\n    };\n  }\n}), require_browser4 = __commonJS({\n  \"node_modules/pbkdf2/browser.js\"(exports) {\n    exports.pbkdf2 = require_async(), exports.pbkdf2Sync = require_sync_browser();\n  }\n}), require_utils = __commonJS({\n  \"node_modules/des.js/lib/des/utils.js\"(exports) {\n    exports.readUInt32BE = function(bytes, off) {\n      var res = bytes[0 + off] << 24 | bytes[1 + off] << 16 | bytes[2 + off] << 8 | bytes[3 + off];\n      return res >>> 0;\n    }, exports.writeUInt32BE = function(bytes, value, off) {\n      bytes[0 + off] = value >>> 24, bytes[1 + off] = value >>> 16 & 255, bytes[2 + off] = value >>> 8 & 255, bytes[3 + off] = value & 255;\n    }, exports.ip = function(inL, inR, out, off) {\n      for (var outL = 0, outR = 0, i = 6;i >= 0; i -= 2) {\n        for (var j = 0;j <= 24; j += 8)\n          outL <<= 1, outL |= inR >>> j + i & 1;\n        for (var j = 0;j <= 24; j += 8)\n          outL <<= 1, outL |= inL >>> j + i & 1;\n      }\n      for (var i = 6;i >= 0; i -= 2) {\n        for (var j = 1;j <= 25; j += 8)\n          outR <<= 1, outR |= inR >>> j + i & 1;\n        for (var j = 1;j <= 25; j += 8)\n          outR <<= 1, outR |= inL >>> j + i & 1;\n      }\n      out[off + 0] = outL >>> 0, out[off + 1] = outR >>> 0;\n    }, exports.rip = function(inL, inR, out, off) {\n      for (var outL = 0, outR = 0, i = 0;i < 4; i++)\n        for (var j = 24;j >= 0; j -= 8)\n          outL <<= 1, outL |= inR >>> j + i & 1, outL <<= 1, outL |= inL >>> j + i & 1;\n      for (var i = 4;i < 8; i++)\n        for (var j = 24;j >= 0; j -= 8)\n          outR <<= 1, outR |= inR >>> j + i & 1, outR <<= 1, outR |= inL >>> j + i & 1;\n      out[off + 0] = outL >>> 0, out[off + 1] = outR >>> 0;\n    }, exports.pc1 = function(inL, inR, out, off) {\n      for (var outL = 0, outR = 0, i = 7;i >= 5; i--) {\n        for (var j = 0;j <= 24; j += 8)\n          outL <<= 1, outL |= inR >> j + i & 1;\n        for (var j = 0;j <= 24; j += 8)\n          outL <<= 1, outL |= inL >> j + i & 1;\n      }\n      for (var j = 0;j <= 24; j += 8)\n        outL <<= 1, outL |= inR >> j + i & 1;\n      for (var i = 1;i <= 3; i++) {\n        for (var j = 0;j <= 24; j += 8)\n          outR <<= 1, outR |= inR >> j + i & 1;\n        for (var j = 0;j <= 24; j += 8)\n          outR <<= 1, outR |= inL >> j + i & 1;\n      }\n      for (var j = 0;j <= 24; j += 8)\n        outR <<= 1, outR |= inL >> j + i & 1;\n      out[off + 0] = outL >>> 0, out[off + 1] = outR >>> 0;\n    }, exports.r28shl = function(num, shift) {\n      return num << shift & 268435455 | num >>> 28 - shift;\n    };\n    var pc2table = [\n      14,\n      11,\n      17,\n      4,\n      27,\n      23,\n      25,\n      0,\n      13,\n      22,\n      7,\n      18,\n      5,\n      9,\n      16,\n      24,\n      2,\n      20,\n      12,\n      21,\n      1,\n      8,\n      15,\n      26,\n      15,\n      4,\n      25,\n      19,\n      9,\n      1,\n      26,\n      16,\n      5,\n      11,\n      23,\n      8,\n      12,\n      7,\n      17,\n      0,\n      22,\n      3,\n      10,\n      14,\n      6,\n      20,\n      27,\n      24\n    ];\n    exports.pc2 = function(inL, inR, out, off) {\n      for (var outL = 0, outR = 0, len = pc2table.length >>> 1, i = 0;i < len; i++)\n        outL <<= 1, outL |= inL >>> pc2table[i] & 1;\n      for (var i = len;i < pc2table.length; i++)\n        outR <<= 1, outR |= inR >>> pc2table[i] & 1;\n      out[off + 0] = outL >>> 0, out[off + 1] = outR >>> 0;\n    }, exports.expand = function(r, out, off) {\n      var outL = 0, outR = 0;\n      outL = (r & 1) << 5 | r >>> 27;\n      for (var i = 23;i >= 15; i -= 4)\n        outL <<= 6, outL |= r >>> i & 63;\n      for (var i = 11;i >= 3; i -= 4)\n        outR |= r >>> i & 63, outR <<= 6;\n      outR |= (r & 31) << 1 | r >>> 31, out[off + 0] = outL >>> 0, out[off + 1] = outR >>> 0;\n    };\n    var sTable = [\n      14,\n      0,\n      4,\n      15,\n      13,\n      7,\n      1,\n      4,\n      2,\n      14,\n      15,\n      2,\n      11,\n      13,\n      8,\n      1,\n      3,\n      10,\n      10,\n      6,\n      6,\n      12,\n      12,\n      11,\n      5,\n      9,\n      9,\n      5,\n      0,\n      3,\n      7,\n      8,\n      4,\n      15,\n      1,\n      12,\n      14,\n      8,\n      8,\n      2,\n      13,\n      4,\n      6,\n      9,\n      2,\n      1,\n      11,\n      7,\n      15,\n      5,\n      12,\n      11,\n      9,\n      3,\n      7,\n      14,\n      3,\n      10,\n      10,\n      0,\n      5,\n      6,\n      0,\n      13,\n      15,\n      3,\n      1,\n      13,\n      8,\n      4,\n      14,\n      7,\n      6,\n      15,\n      11,\n      2,\n      3,\n      8,\n      4,\n      14,\n      9,\n      12,\n      7,\n      0,\n      2,\n      1,\n      13,\n      10,\n      12,\n      6,\n      0,\n      9,\n      5,\n      11,\n      10,\n      5,\n      0,\n      13,\n      14,\n      8,\n      7,\n      10,\n      11,\n      1,\n      10,\n      3,\n      4,\n      15,\n      13,\n      4,\n      1,\n      2,\n      5,\n      11,\n      8,\n      6,\n      12,\n      7,\n      6,\n      12,\n      9,\n      0,\n      3,\n      5,\n      2,\n      14,\n      15,\n      9,\n      10,\n      13,\n      0,\n      7,\n      9,\n      0,\n      14,\n      9,\n      6,\n      3,\n      3,\n      4,\n      15,\n      6,\n      5,\n      10,\n      1,\n      2,\n      13,\n      8,\n      12,\n      5,\n      7,\n      14,\n      11,\n      12,\n      4,\n      11,\n      2,\n      15,\n      8,\n      1,\n      13,\n      1,\n      6,\n      10,\n      4,\n      13,\n      9,\n      0,\n      8,\n      6,\n      15,\n      9,\n      3,\n      8,\n      0,\n      7,\n      11,\n      4,\n      1,\n      15,\n      2,\n      14,\n      12,\n      3,\n      5,\n      11,\n      10,\n      5,\n      14,\n      2,\n      7,\n      12,\n      7,\n      13,\n      13,\n      8,\n      14,\n      11,\n      3,\n      5,\n      0,\n      6,\n      6,\n      15,\n      9,\n      0,\n      10,\n      3,\n      1,\n      4,\n      2,\n      7,\n      8,\n      2,\n      5,\n      12,\n      11,\n      1,\n      12,\n      10,\n      4,\n      14,\n      15,\n      9,\n      10,\n      3,\n      6,\n      15,\n      9,\n      0,\n      0,\n      6,\n      12,\n      10,\n      11,\n      1,\n      7,\n      13,\n      13,\n      8,\n      15,\n      9,\n      1,\n      4,\n      3,\n      5,\n      14,\n      11,\n      5,\n      12,\n      2,\n      7,\n      8,\n      2,\n      4,\n      14,\n      2,\n      14,\n      12,\n      11,\n      4,\n      2,\n      1,\n      12,\n      7,\n      4,\n      10,\n      7,\n      11,\n      13,\n      6,\n      1,\n      8,\n      5,\n      5,\n      0,\n      3,\n      15,\n      15,\n      10,\n      13,\n      3,\n      0,\n      9,\n      14,\n      8,\n      9,\n      6,\n      4,\n      11,\n      2,\n      8,\n      1,\n      12,\n      11,\n      7,\n      10,\n      1,\n      13,\n      14,\n      7,\n      2,\n      8,\n      13,\n      15,\n      6,\n      9,\n      15,\n      12,\n      0,\n      5,\n      9,\n      6,\n      10,\n      3,\n      4,\n      0,\n      5,\n      14,\n      3,\n      12,\n      10,\n      1,\n      15,\n      10,\n      4,\n      15,\n      2,\n      9,\n      7,\n      2,\n      12,\n      6,\n      9,\n      8,\n      5,\n      0,\n      6,\n      13,\n      1,\n      3,\n      13,\n      4,\n      14,\n      14,\n      0,\n      7,\n      11,\n      5,\n      3,\n      11,\n      8,\n      9,\n      4,\n      14,\n      3,\n      15,\n      2,\n      5,\n      12,\n      2,\n      9,\n      8,\n      5,\n      12,\n      15,\n      3,\n      10,\n      7,\n      11,\n      0,\n      14,\n      4,\n      1,\n      10,\n      7,\n      1,\n      6,\n      13,\n      0,\n      11,\n      8,\n      6,\n      13,\n      4,\n      13,\n      11,\n      0,\n      2,\n      11,\n      14,\n      7,\n      15,\n      4,\n      0,\n      9,\n      8,\n      1,\n      13,\n      10,\n      3,\n      14,\n      12,\n      3,\n      9,\n      5,\n      7,\n      12,\n      5,\n      2,\n      10,\n      15,\n      6,\n      8,\n      1,\n      6,\n      1,\n      6,\n      4,\n      11,\n      11,\n      13,\n      13,\n      8,\n      12,\n      1,\n      3,\n      4,\n      7,\n      10,\n      14,\n      7,\n      10,\n      9,\n      15,\n      5,\n      6,\n      0,\n      8,\n      15,\n      0,\n      14,\n      5,\n      2,\n      9,\n      3,\n      2,\n      12,\n      13,\n      1,\n      2,\n      15,\n      8,\n      13,\n      4,\n      8,\n      6,\n      10,\n      15,\n      3,\n      11,\n      7,\n      1,\n      4,\n      10,\n      12,\n      9,\n      5,\n      3,\n      6,\n      14,\n      11,\n      5,\n      0,\n      0,\n      14,\n      12,\n      9,\n      7,\n      2,\n      7,\n      2,\n      11,\n      1,\n      4,\n      14,\n      1,\n      7,\n      9,\n      4,\n      12,\n      10,\n      14,\n      8,\n      2,\n      13,\n      0,\n      15,\n      6,\n      12,\n      10,\n      9,\n      13,\n      0,\n      15,\n      3,\n      3,\n      5,\n      5,\n      6,\n      8,\n      11\n    ];\n    exports.substitute = function(inL, inR) {\n      for (var out = 0, i = 0;i < 4; i++) {\n        var b = inL >>> 18 - i * 6 & 63, sb = sTable[i * 64 + b];\n        out <<= 4, out |= sb;\n      }\n      for (var i = 0;i < 4; i++) {\n        var b = inR >>> 18 - i * 6 & 63, sb = sTable[256 + i * 64 + b];\n        out <<= 4, out |= sb;\n      }\n      return out >>> 0;\n    };\n    var permuteTable = [\n      16,\n      25,\n      12,\n      11,\n      3,\n      20,\n      4,\n      15,\n      31,\n      17,\n      9,\n      6,\n      27,\n      14,\n      1,\n      22,\n      30,\n      24,\n      8,\n      18,\n      0,\n      5,\n      29,\n      23,\n      13,\n      19,\n      2,\n      26,\n      10,\n      21,\n      28,\n      7\n    ];\n    exports.permute = function(num) {\n      for (var out = 0, i = 0;i < permuteTable.length; i++)\n        out <<= 1, out |= num >>> permuteTable[i] & 1;\n      return out >>> 0;\n    }, exports.padSplit = function(num, size, group) {\n      for (var str = num.toString(2);str.length < size; )\n        str = \"0\" + str;\n      for (var out = [], i = 0;i < size; i += group)\n        out.push(str.slice(i, i + group));\n      return out.join(\" \");\n    };\n  }\n}), require_minimalistic_assert = __commonJS({\n  \"node_modules/minimalistic-assert/index.js\"(exports, module) {\n    module.exports = assert;\n    function assert(val, msg) {\n      if (!val)\n        throw new Error(msg || \"Assertion failed\");\n    }\n    assert.equal = function(l, r, msg) {\n      if (l != r)\n        throw new Error(msg || \"Assertion failed: \" + l + \" != \" + r);\n    };\n  }\n}), require_cipher = __commonJS({\n  \"node_modules/des.js/lib/des/cipher.js\"(exports, module) {\n    var assert = require_minimalistic_assert();\n    function Cipher(options) {\n      this.options = options, this.type = this.options.type, this.blockSize = 8, this._init(), this.buffer = new Array(this.blockSize), this.bufferOff = 0;\n    }\n    Cipher.prototype = {}, module.exports = Cipher, Cipher.prototype._init = function() {\n    }, Cipher.prototype.update = function(data) {\n      return data.length === 0 \? [] : this.type === \"decrypt\" \? this._updateDecrypt(data) : this._updateEncrypt(data);\n    }, Cipher.prototype._buffer = function(data, off) {\n      for (var min = Math.min(this.buffer.length - this.bufferOff, data.length - off), i = 0;i < min; i++)\n        this.buffer[this.bufferOff + i] = data[off + i];\n      return this.bufferOff += min, min;\n    }, Cipher.prototype._flushBuffer = function(out, off) {\n      return this._update(this.buffer, 0, out, off), this.bufferOff = 0, this.blockSize;\n    }, Cipher.prototype._updateEncrypt = function(data) {\n      var inputOff = 0, outputOff = 0, count = (this.bufferOff + data.length) / this.blockSize | 0, out = new Array(count * this.blockSize);\n      this.bufferOff !== 0 && (inputOff += this._buffer(data, inputOff), this.bufferOff === this.buffer.length && (outputOff += this._flushBuffer(out, outputOff)));\n      for (var max = data.length - (data.length - inputOff) % this.blockSize;inputOff < max; inputOff += this.blockSize)\n        this._update(data, inputOff, out, outputOff), outputOff += this.blockSize;\n      for (;inputOff < data.length; inputOff++, this.bufferOff++)\n        this.buffer[this.bufferOff] = data[inputOff];\n      return out;\n    }, Cipher.prototype._updateDecrypt = function(data) {\n      for (var inputOff = 0, outputOff = 0, count = Math.ceil((this.bufferOff + data.length) / this.blockSize) - 1, out = new Array(count * this.blockSize);count > 0; count--)\n        inputOff += this._buffer(data, inputOff), outputOff += this._flushBuffer(out, outputOff);\n      return inputOff += this._buffer(data, inputOff), out;\n    }, Cipher.prototype.final = function(buffer) {\n      var first;\n      buffer && (first = this.update(buffer));\n      var last;\n      return this.type === \"encrypt\" \? last = this._finalEncrypt() : last = this._finalDecrypt(), first \? first.concat(last) : last;\n    }, Cipher.prototype._pad = function(buffer, off) {\n      if (off === 0)\n        return !1;\n      for (;off < buffer.length; )\n        buffer[off++] = 0;\n      return !0;\n    }, Cipher.prototype._finalEncrypt = function() {\n      if (!this._pad(this.buffer, this.bufferOff))\n        return [];\n      var out = new Array(this.blockSize);\n      return this._update(this.buffer, 0, out, 0), out;\n    }, Cipher.prototype._unpad = function(buffer) {\n      return buffer;\n    }, Cipher.prototype._finalDecrypt = function() {\n      assert.equal(this.bufferOff, this.blockSize, \"Not enough data to decrypt\");\n      var out = new Array(this.blockSize);\n      return this._flushBuffer(out, 0), this._unpad(out);\n    };\n  }\n}), require_des = __commonJS({\n  \"node_modules/des.js/lib/des/des.js\"(exports, module) {\n    var assert = require_minimalistic_assert(), inherits = require_inherits_browser(), utils = require_utils(), Cipher = require_cipher();\n    function DESState() {\n      this.tmp = new Array(2), this.keys = null;\n    }\n    function DES(options) {\n      Cipher.call(this, options);\n      var state = new DESState;\n      this._desState = state, this.deriveKeys(state, options.key);\n    }\n    inherits(DES, Cipher), module.exports = DES, DES.create = function(options) {\n      return new DES(options);\n    };\n    var shiftTable = [1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1];\n    DES.prototype.deriveKeys = function(state, key) {\n      state.keys = new Array(32), assert.equal(key.length, this.blockSize, \"Invalid key length\");\n      var kL = utils.readUInt32BE(key, 0), kR = utils.readUInt32BE(key, 4);\n      utils.pc1(kL, kR, state.tmp, 0), kL = state.tmp[0], kR = state.tmp[1];\n      for (var i = 0;i < state.keys.length; i += 2) {\n        var shift = shiftTable[i >>> 1];\n        kL = utils.r28shl(kL, shift), kR = utils.r28shl(kR, shift), utils.pc2(kL, kR, state.keys, i);\n      }\n    }, DES.prototype._update = function(inp, inOff, out, outOff) {\n      var state = this._desState, l = utils.readUInt32BE(inp, inOff), r = utils.readUInt32BE(inp, inOff + 4);\n      utils.ip(l, r, state.tmp, 0), l = state.tmp[0], r = state.tmp[1], this.type === \"encrypt\" \? this._encrypt(state, l, r, state.tmp, 0) : this._decrypt(state, l, r, state.tmp, 0), l = state.tmp[0], r = state.tmp[1], utils.writeUInt32BE(out, l, outOff), utils.writeUInt32BE(out, r, outOff + 4);\n    }, DES.prototype._pad = function(buffer, off) {\n      for (var value = buffer.length - off, i = off;i < buffer.length; i++)\n        buffer[i] = value;\n      return !0;\n    }, DES.prototype._unpad = function(buffer) {\n      for (var pad = buffer[buffer.length - 1], i = buffer.length - pad;i < buffer.length; i++)\n        assert.equal(buffer[i], pad);\n      return buffer.slice(0, buffer.length - pad);\n    }, DES.prototype._encrypt = function(state, lStart, rStart, out, off) {\n      for (var l = lStart, r = rStart, i = 0;i < state.keys.length; i += 2) {\n        var keyL = state.keys[i], keyR = state.keys[i + 1];\n        utils.expand(r, state.tmp, 0), keyL ^= state.tmp[0], keyR ^= state.tmp[1];\n        var s = utils.substitute(keyL, keyR), f = utils.permute(s), t = r;\n        r = (l ^ f) >>> 0, l = t;\n      }\n      utils.rip(r, l, out, off);\n    }, DES.prototype._decrypt = function(state, lStart, rStart, out, off) {\n      for (var l = rStart, r = lStart, i = state.keys.length - 2;i >= 0; i -= 2) {\n        var keyL = state.keys[i], keyR = state.keys[i + 1];\n        utils.expand(l, state.tmp, 0), keyL ^= state.tmp[0], keyR ^= state.tmp[1];\n        var s = utils.substitute(keyL, keyR), f = utils.permute(s), t = l;\n        l = (r ^ f) >>> 0, r = t;\n      }\n      utils.rip(l, r, out, off);\n    };\n  }\n}), require_cbc = __commonJS({\n  \"node_modules/des.js/lib/des/cbc.js\"(exports) {\n    var assert = require_minimalistic_assert(), inherits = require_inherits_browser(), proto = {};\n    function CBCState(iv) {\n      assert.equal(iv.length, 8, \"Invalid IV length\"), this.iv = new Array(8);\n      for (var i = 0;i < this.iv.length; i++)\n        this.iv[i] = iv[i];\n    }\n    function instantiate(Base) {\n      function CBC(options) {\n        Base.call(this, options), this._cbcInit();\n      }\n      inherits(CBC, Base);\n      for (var keys = Object.keys(proto), i = 0;i < keys.length; i++) {\n        var key = keys[i];\n        CBC.prototype[key] = proto[key];\n      }\n      return CBC.create = function(options) {\n        return new CBC(options);\n      }, CBC;\n    }\n    exports.instantiate = instantiate, proto._cbcInit = function() {\n      var state = new CBCState(this.options.iv);\n      this._cbcState = state;\n    }, proto._update = function(inp, inOff, out, outOff) {\n      var state = this._cbcState, superProto = this.constructor.super_.prototype, iv = state.iv;\n      if (this.type === \"encrypt\") {\n        for (var i = 0;i < this.blockSize; i++)\n          iv[i] ^= inp[inOff + i];\n        superProto._update.call(this, iv, 0, out, outOff);\n        for (var i = 0;i < this.blockSize; i++)\n          iv[i] = out[outOff + i];\n      } else {\n        superProto._update.call(this, inp, inOff, out, outOff);\n        for (var i = 0;i < this.blockSize; i++)\n          out[outOff + i] ^= iv[i];\n        for (var i = 0;i < this.blockSize; i++)\n          iv[i] = inp[inOff + i];\n      }\n    };\n  }\n}), require_ede = __commonJS({\n  \"node_modules/des.js/lib/des/ede.js\"(exports, module) {\n    var assert = require_minimalistic_assert(), inherits = require_inherits_browser(), Cipher = require_cipher(), DES = require_des();\n    function EDEState(type, key) {\n      assert.equal(key.length, 24, \"Invalid key length\");\n      var k1 = key.slice(0, 8), k2 = key.slice(8, 16), k3 = key.slice(16, 24);\n      type === \"encrypt\" \? this.ciphers = [\n        DES.create({ type: \"encrypt\", key: k1 }),\n        DES.create({ type: \"decrypt\", key: k2 }),\n        DES.create({ type: \"encrypt\", key: k3 })\n      ] : this.ciphers = [\n        DES.create({ type: \"decrypt\", key: k3 }),\n        DES.create({ type: \"encrypt\", key: k2 }),\n        DES.create({ type: \"decrypt\", key: k1 })\n      ];\n    }\n    function EDE(options) {\n      Cipher.call(this, options);\n      var state = new EDEState(this.type, this.options.key);\n      this._edeState = state;\n    }\n    inherits(EDE, Cipher), module.exports = EDE, EDE.create = function(options) {\n      return new EDE(options);\n    }, EDE.prototype._update = function(inp, inOff, out, outOff) {\n      var state = this._edeState;\n      state.ciphers[0]._update(inp, inOff, out, outOff), state.ciphers[1]._update(out, outOff, out, outOff), state.ciphers[2]._update(out, outOff, out, outOff);\n    }, EDE.prototype._pad = DES.prototype._pad, EDE.prototype._unpad = DES.prototype._unpad;\n  }\n}), require_des2 = __commonJS({\n  \"node_modules/des.js/lib/des.js\"(exports) {\n    exports.utils = require_utils(), exports.Cipher = require_cipher(), exports.DES = require_des(), exports.CBC = require_cbc(), exports.EDE = require_ede();\n  }\n}), require_browserify_des = __commonJS({\n  \"node_modules/browserify-des/index.js\"(exports, module) {\n    var CipherBase = require_cipher_base(), des = require_des2(), inherits = require_inherits_browser(), Buffer2 = require_safe_buffer().Buffer, modes = {\n      \"des-ede3-cbc\": des.CBC.instantiate(des.EDE),\n      \"des-ede3\": des.EDE,\n      \"des-ede-cbc\": des.CBC.instantiate(des.EDE),\n      \"des-ede\": des.EDE,\n      \"des-cbc\": des.CBC.instantiate(des.DES),\n      \"des-ecb\": des.DES\n    };\n    modes.des = modes[\"des-cbc\"], modes.des3 = modes[\"des-ede3-cbc\"], module.exports = DES, inherits(DES, CipherBase);\n    function DES(opts) {\n      CipherBase.call(this);\n      var modeName = opts.mode.toLowerCase(), mode = modes[modeName], type;\n      opts.decrypt \? type = \"decrypt\" : type = \"encrypt\";\n      var key = opts.key;\n      Buffer2.isBuffer(key) || (key = Buffer2.from(key)), (modeName === \"des-ede\" || modeName === \"des-ede-cbc\") && (key = Buffer2.concat([key, key.slice(0, 8)]));\n      var iv = opts.iv;\n      Buffer2.isBuffer(iv) || (iv = Buffer2.from(iv)), this._des = mode.create({\n        key,\n        iv,\n        type\n      });\n    }\n    DES.prototype._update = function(data) {\n      return Buffer2.from(this._des.update(data));\n    }, DES.prototype._final = function() {\n      return Buffer2.from(this._des.final());\n    };\n  }\n}), require_ecb = __commonJS({\n  \"node_modules/browserify-aes/modes/ecb.js\"(exports) {\n    exports.encrypt = function(self2, block) {\n      return self2._cipher.encryptBlock(block);\n    }, exports.decrypt = function(self2, block) {\n      return self2._cipher.decryptBlock(block);\n    };\n  }\n}), require_buffer_xor = __commonJS({\n  \"node_modules/buffer-xor/index.js\"(exports, module) {\n    module.exports = function(a, b) {\n      for (var length = Math.min(a.length, b.length), buffer = new Buffer(length), i = 0;i < length; ++i)\n        buffer[i] = a[i] ^ b[i];\n      return buffer;\n    };\n  }\n}), require_cbc2 = __commonJS({\n  \"node_modules/browserify-aes/modes/cbc.js\"(exports) {\n    var xor = require_buffer_xor();\n    exports.encrypt = function(self2, block) {\n      var data = xor(block, self2._prev);\n      return self2._prev = self2._cipher.encryptBlock(data), self2._prev;\n    }, exports.decrypt = function(self2, block) {\n      var pad = self2._prev;\n      self2._prev = block;\n      var out = self2._cipher.decryptBlock(block);\n      return xor(out, pad);\n    };\n  }\n}), require_cfb = __commonJS({\n  \"node_modules/browserify-aes/modes/cfb.js\"(exports) {\n    var Buffer2 = require_safe_buffer().Buffer, xor = require_buffer_xor();\n    function encryptStart(self2, data, decrypt) {\n      var len = data.length, out = xor(data, self2._cache);\n      return self2._cache = self2._cache.slice(len), self2._prev = Buffer2.concat([self2._prev, decrypt \? data : out]), out;\n    }\n    exports.encrypt = function(self2, data, decrypt) {\n      for (var out = Buffer2.allocUnsafe(0), len;data.length; )\n        if (self2._cache.length === 0 && (self2._cache = self2._cipher.encryptBlock(self2._prev), self2._prev = Buffer2.allocUnsafe(0)), self2._cache.length <= data.length)\n          len = self2._cache.length, out = Buffer2.concat([out, encryptStart(self2, data.slice(0, len), decrypt)]), data = data.slice(len);\n        else {\n          out = Buffer2.concat([out, encryptStart(self2, data, decrypt)]);\n          break;\n        }\n      return out;\n    };\n  }\n}), require_cfb8 = __commonJS({\n  \"node_modules/browserify-aes/modes/cfb8.js\"(exports) {\n    var Buffer2 = require_safe_buffer().Buffer;\n    function encryptByte(self2, byteParam, decrypt) {\n      var pad = self2._cipher.encryptBlock(self2._prev), out = pad[0] ^ byteParam;\n      return self2._prev = Buffer2.concat([self2._prev.slice(1), Buffer2.from([decrypt \? byteParam : out])]), out;\n    }\n    exports.encrypt = function(self2, chunk, decrypt) {\n      for (var len = chunk.length, out = Buffer2.allocUnsafe(len), i = -1;++i < len; )\n        out[i] = encryptByte(self2, chunk[i], decrypt);\n      return out;\n    };\n  }\n}), require_cfb1 = __commonJS({\n  \"node_modules/browserify-aes/modes/cfb1.js\"(exports) {\n    var Buffer2 = require_safe_buffer().Buffer;\n    function encryptByte(self2, byteParam, decrypt) {\n      for (var pad, i = -1, len = 8, out = 0, bit, value;++i < len; )\n        pad = self2._cipher.encryptBlock(self2._prev), bit = byteParam & 1 << 7 - i \? 128 : 0, value = pad[0] ^ bit, out += (value & 128) >> i % 8, self2._prev = shiftIn(self2._prev, decrypt \? bit : value);\n      return out;\n    }\n    function shiftIn(buffer, value) {\n      var len = buffer.length, i = -1, out = Buffer2.allocUnsafe(buffer.length);\n      for (buffer = Buffer2.concat([buffer, Buffer2.from([value])]);++i < len; )\n        out[i] = buffer[i] << 1 | buffer[i + 1] >> 7;\n      return out;\n    }\n    exports.encrypt = function(self2, chunk, decrypt) {\n      for (var len = chunk.length, out = Buffer2.allocUnsafe(len), i = -1;++i < len; )\n        out[i] = encryptByte(self2, chunk[i], decrypt);\n      return out;\n    };\n  }\n}), require_ofb = __commonJS({\n  \"node_modules/browserify-aes/modes/ofb.js\"(exports) {\n    var xor = require_buffer_xor();\n    function getBlock(self2) {\n      return self2._prev = self2._cipher.encryptBlock(self2._prev), self2._prev;\n    }\n    exports.encrypt = function(self2, chunk) {\n      for (;self2._cache.length < chunk.length; )\n        self2._cache = Buffer.concat([self2._cache, getBlock(self2)]);\n      var pad = self2._cache.slice(0, chunk.length);\n      return self2._cache = self2._cache.slice(chunk.length), xor(chunk, pad);\n    };\n  }\n}), require_incr32 = __commonJS({\n  \"node_modules/browserify-aes/incr32.js\"(exports, module) {\n    function incr32(iv) {\n      for (var len = iv.length, item;len--; )\n        if (item = iv.readUInt8(len), item === 255)\n          iv.writeUInt8(0, len);\n        else {\n          item++, iv.writeUInt8(item, len);\n          break;\n        }\n    }\n    module.exports = incr32;\n  }\n}), require_ctr = __commonJS({\n  \"node_modules/browserify-aes/modes/ctr.js\"(exports) {\n    var xor = require_buffer_xor(), Buffer2 = require_safe_buffer().Buffer, incr32 = require_incr32();\n    function getBlock(self2) {\n      var out = self2._cipher.encryptBlockRaw(self2._prev);\n      return incr32(self2._prev), out;\n    }\n    var blockSize = 16;\n    exports.encrypt = function(self2, chunk) {\n      var chunkNum = Math.ceil(chunk.length / blockSize), start = self2._cache.length;\n      self2._cache = Buffer2.concat([self2._cache, Buffer2.allocUnsafe(chunkNum * blockSize)]);\n      for (var i = 0;i < chunkNum; i++) {\n        var out = getBlock(self2), offset = start + i * blockSize;\n        self2._cache.writeUInt32BE(out[0], offset + 0), self2._cache.writeUInt32BE(out[1], offset + 4), self2._cache.writeUInt32BE(out[2], offset + 8), self2._cache.writeUInt32BE(out[3], offset + 12);\n      }\n      var pad = self2._cache.slice(0, chunk.length);\n      return self2._cache = self2._cache.slice(chunk.length), xor(chunk, pad);\n    };\n  }\n}), require_list = __commonJS({\n  \"node_modules/browserify-aes/modes/list.json\"(exports, module) {\n    module.exports = {\n      \"aes-128-ecb\": {\n        cipher: \"AES\",\n        key: 128,\n        iv: 0,\n        mode: \"ECB\",\n        type: \"block\"\n      },\n      \"aes-192-ecb\": {\n        cipher: \"AES\",\n        key: 192,\n        iv: 0,\n        mode: \"ECB\",\n        type: \"block\"\n      },\n      \"aes-256-ecb\": {\n        cipher: \"AES\",\n        key: 256,\n        iv: 0,\n        mode: \"ECB\",\n        type: \"block\"\n      },\n      \"aes-128-cbc\": {\n        cipher: \"AES\",\n        key: 128,\n        iv: 16,\n        mode: \"CBC\",\n        type: \"block\"\n      },\n      \"aes-192-cbc\": {\n        cipher: \"AES\",\n        key: 192,\n        iv: 16,\n        mode: \"CBC\",\n        type: \"block\"\n      },\n      \"aes-256-cbc\": {\n        cipher: \"AES\",\n        key: 256,\n        iv: 16,\n        mode: \"CBC\",\n        type: \"block\"\n      },\n      aes128: {\n        cipher: \"AES\",\n        key: 128,\n        iv: 16,\n        mode: \"CBC\",\n        type: \"block\"\n      },\n      aes192: {\n        cipher: \"AES\",\n        key: 192,\n        iv: 16,\n        mode: \"CBC\",\n        type: \"block\"\n      },\n      aes256: {\n        cipher: \"AES\",\n        key: 256,\n        iv: 16,\n        mode: \"CBC\",\n        type: \"block\"\n      },\n      \"aes-128-cfb\": {\n        cipher: \"AES\",\n        key: 128,\n        iv: 16,\n        mode: \"CFB\",\n        type: \"stream\"\n      },\n      \"aes-192-cfb\": {\n        cipher: \"AES\",\n        key: 192,\n        iv: 16,\n        mode: \"CFB\",\n        type: \"stream\"\n      },\n      \"aes-256-cfb\": {\n        cipher: \"AES\",\n        key: 256,\n        iv: 16,\n        mode: \"CFB\",\n        type: \"stream\"\n      },\n      \"aes-128-cfb8\": {\n        cipher: \"AES\",\n        key: 128,\n        iv: 16,\n        mode: \"CFB8\",\n        type: \"stream\"\n      },\n      \"aes-192-cfb8\": {\n        cipher: \"AES\",\n        key: 192,\n        iv: 16,\n        mode: \"CFB8\",\n        type: \"stream\"\n      },\n      \"aes-256-cfb8\": {\n        cipher: \"AES\",\n        key: 256,\n        iv: 16,\n        mode: \"CFB8\",\n        type: \"stream\"\n      },\n      \"aes-128-cfb1\": {\n        cipher: \"AES\",\n        key: 128,\n        iv: 16,\n        mode: \"CFB1\",\n        type: \"stream\"\n      },\n      \"aes-192-cfb1\": {\n        cipher: \"AES\",\n        key: 192,\n        iv: 16,\n        mode: \"CFB1\",\n        type: \"stream\"\n      },\n      \"aes-256-cfb1\": {\n        cipher: \"AES\",\n        key: 256,\n        iv: 16,\n        mode: \"CFB1\",\n        type: \"stream\"\n      },\n      \"aes-128-ofb\": {\n        cipher: \"AES\",\n        key: 128,\n        iv: 16,\n        mode: \"OFB\",\n        type: \"stream\"\n      },\n      \"aes-192-ofb\": {\n        cipher: \"AES\",\n        key: 192,\n        iv: 16,\n        mode: \"OFB\",\n        type: \"stream\"\n      },\n      \"aes-256-ofb\": {\n        cipher: \"AES\",\n        key: 256,\n        iv: 16,\n        mode: \"OFB\",\n        type: \"stream\"\n      },\n      \"aes-128-ctr\": {\n        cipher: \"AES\",\n        key: 128,\n        iv: 16,\n        mode: \"CTR\",\n        type: \"stream\"\n      },\n      \"aes-192-ctr\": {\n        cipher: \"AES\",\n        key: 192,\n        iv: 16,\n        mode: \"CTR\",\n        type: \"stream\"\n      },\n      \"aes-256-ctr\": {\n        cipher: \"AES\",\n        key: 256,\n        iv: 16,\n        mode: \"CTR\",\n        type: \"stream\"\n      },\n      \"aes-128-gcm\": {\n        cipher: \"AES\",\n        key: 128,\n        iv: 12,\n        mode: \"GCM\",\n        type: \"auth\"\n      },\n      \"aes-192-gcm\": {\n        cipher: \"AES\",\n        key: 192,\n        iv: 12,\n        mode: \"GCM\",\n        type: \"auth\"\n      },\n      \"aes-256-gcm\": {\n        cipher: \"AES\",\n        key: 256,\n        iv: 12,\n        mode: \"GCM\",\n        type: \"auth\"\n      }\n    };\n  }\n}), require_modes = __commonJS({\n  \"node_modules/browserify-aes/modes/index.js\"(exports, module) {\n    var modeModules = {\n      ECB: require_ecb(),\n      CBC: require_cbc2(),\n      CFB: require_cfb(),\n      CFB8: require_cfb8(),\n      CFB1: require_cfb1(),\n      OFB: require_ofb(),\n      CTR: require_ctr(),\n      GCM: require_ctr()\n    }, modes = require_list();\n    for (key in modes)\n      modes[key].module = modeModules[modes[key].mode];\n    var key;\n    module.exports = modes;\n  }\n}), require_aes = __commonJS({\n  \"node_modules/browserify-aes/aes.js\"(exports, module) {\n    var Buffer2 = require_safe_buffer().Buffer;\n    function asUInt32Array(buf) {\n      Buffer2.isBuffer(buf) || (buf = Buffer2.from(buf));\n      for (var len = buf.length / 4 | 0, out = new Array(len), i = 0;i < len; i++)\n        out[i] = buf.readUInt32BE(i * 4);\n      return out;\n    }\n    function scrubVec(v) {\n      for (var i = 0;i < v.length; v++)\n        v[i] = 0;\n    }\n    function cryptBlock(M, keySchedule, SUB_MIX, SBOX, nRounds) {\n      for (var SUB_MIX0 = SUB_MIX[0], SUB_MIX1 = SUB_MIX[1], SUB_MIX2 = SUB_MIX[2], SUB_MIX3 = SUB_MIX[3], s0 = M[0] ^ keySchedule[0], s1 = M[1] ^ keySchedule[1], s2 = M[2] ^ keySchedule[2], s3 = M[3] ^ keySchedule[3], t0, t1, t2, t3, ksRow = 4, round = 1;round < nRounds; round++)\n        t0 = SUB_MIX0[s0 >>> 24] ^ SUB_MIX1[s1 >>> 16 & 255] ^ SUB_MIX2[s2 >>> 8 & 255] ^ SUB_MIX3[s3 & 255] ^ keySchedule[ksRow++], t1 = SUB_MIX0[s1 >>> 24] ^ SUB_MIX1[s2 >>> 16 & 255] ^ SUB_MIX2[s3 >>> 8 & 255] ^ SUB_MIX3[s0 & 255] ^ keySchedule[ksRow++], t2 = SUB_MIX0[s2 >>> 24] ^ SUB_MIX1[s3 >>> 16 & 255] ^ SUB_MIX2[s0 >>> 8 & 255] ^ SUB_MIX3[s1 & 255] ^ keySchedule[ksRow++], t3 = SUB_MIX0[s3 >>> 24] ^ SUB_MIX1[s0 >>> 16 & 255] ^ SUB_MIX2[s1 >>> 8 & 255] ^ SUB_MIX3[s2 & 255] ^ keySchedule[ksRow++], s0 = t0, s1 = t1, s2 = t2, s3 = t3;\n      return t0 = (SBOX[s0 >>> 24] << 24 | SBOX[s1 >>> 16 & 255] << 16 | SBOX[s2 >>> 8 & 255] << 8 | SBOX[s3 & 255]) ^ keySchedule[ksRow++], t1 = (SBOX[s1 >>> 24] << 24 | SBOX[s2 >>> 16 & 255] << 16 | SBOX[s3 >>> 8 & 255] << 8 | SBOX[s0 & 255]) ^ keySchedule[ksRow++], t2 = (SBOX[s2 >>> 24] << 24 | SBOX[s3 >>> 16 & 255] << 16 | SBOX[s0 >>> 8 & 255] << 8 | SBOX[s1 & 255]) ^ keySchedule[ksRow++], t3 = (SBOX[s3 >>> 24] << 24 | SBOX[s0 >>> 16 & 255] << 16 | SBOX[s1 >>> 8 & 255] << 8 | SBOX[s2 & 255]) ^ keySchedule[ksRow++], t0 = t0 >>> 0, t1 = t1 >>> 0, t2 = t2 >>> 0, t3 = t3 >>> 0, [t0, t1, t2, t3];\n    }\n    var RCON = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54], G = function() {\n      for (var d = new Array(256), j = 0;j < 256; j++)\n        j < 128 \? d[j] = j << 1 : d[j] = j << 1 ^ 283;\n      for (var SBOX = [], INV_SBOX = [], SUB_MIX = [[], [], [], []], INV_SUB_MIX = [[], [], [], []], x = 0, xi = 0, i = 0;i < 256; ++i) {\n        var sx = xi ^ xi << 1 ^ xi << 2 ^ xi << 3 ^ xi << 4;\n        sx = sx >>> 8 ^ sx & 255 ^ 99, SBOX[x] = sx, INV_SBOX[sx] = x;\n        var x2 = d[x], x4 = d[x2], x8 = d[x4], t = d[sx] * 257 ^ sx * 16843008;\n        SUB_MIX[0][x] = t << 24 | t >>> 8, SUB_MIX[1][x] = t << 16 | t >>> 16, SUB_MIX[2][x] = t << 8 | t >>> 24, SUB_MIX[3][x] = t, t = x8 * 16843009 ^ x4 * 65537 ^ x2 * 257 ^ x * 16843008, INV_SUB_MIX[0][sx] = t << 24 | t >>> 8, INV_SUB_MIX[1][sx] = t << 16 | t >>> 16, INV_SUB_MIX[2][sx] = t << 8 | t >>> 24, INV_SUB_MIX[3][sx] = t, x === 0 \? x = xi = 1 : (x = x2 ^ d[d[d[x8 ^ x2]]], xi ^= d[d[xi]]);\n      }\n      return {\n        SBOX,\n        INV_SBOX,\n        SUB_MIX,\n        INV_SUB_MIX\n      };\n    }();\n    function AES(key) {\n      this._key = asUInt32Array(key), this._reset();\n    }\n    AES.prototype = {}, AES.blockSize = 16, AES.keySize = 32, AES.prototype.blockSize = AES.blockSize, AES.prototype.keySize = AES.keySize, AES.prototype._reset = function() {\n      for (var keyWords = this._key, keySize = keyWords.length, nRounds = keySize + 6, ksRows = (nRounds + 1) * 4, keySchedule = [], k = 0;k < keySize; k++)\n        keySchedule[k] = keyWords[k];\n      for (k = keySize;k < ksRows; k++) {\n        var t = keySchedule[k - 1];\n        k % keySize === 0 \? (t = t << 8 | t >>> 24, t = G.SBOX[t >>> 24] << 24 | G.SBOX[t >>> 16 & 255] << 16 | G.SBOX[t >>> 8 & 255] << 8 | G.SBOX[t & 255], t ^= RCON[k / keySize | 0] << 24) : keySize > 6 && k % keySize === 4 && (t = G.SBOX[t >>> 24] << 24 | G.SBOX[t >>> 16 & 255] << 16 | G.SBOX[t >>> 8 & 255] << 8 | G.SBOX[t & 255]), keySchedule[k] = keySchedule[k - keySize] ^ t;\n      }\n      for (var invKeySchedule = [], ik = 0;ik < ksRows; ik++) {\n        var ksR = ksRows - ik, tt = keySchedule[ksR - (ik % 4 \? 0 : 4)];\n        ik < 4 || ksR <= 4 \? invKeySchedule[ik] = tt : invKeySchedule[ik] = G.INV_SUB_MIX[0][G.SBOX[tt >>> 24]] ^ G.INV_SUB_MIX[1][G.SBOX[tt >>> 16 & 255]] ^ G.INV_SUB_MIX[2][G.SBOX[tt >>> 8 & 255]] ^ G.INV_SUB_MIX[3][G.SBOX[tt & 255]];\n      }\n      this._nRounds = nRounds, this._keySchedule = keySchedule, this._invKeySchedule = invKeySchedule;\n    }, AES.prototype.encryptBlockRaw = function(M) {\n      return M = asUInt32Array(M), cryptBlock(M, this._keySchedule, G.SUB_MIX, G.SBOX, this._nRounds);\n    }, AES.prototype.encryptBlock = function(M) {\n      var out = this.encryptBlockRaw(M), buf = Buffer2.allocUnsafe(16);\n      return buf.writeUInt32BE(out[0], 0), buf.writeUInt32BE(out[1], 4), buf.writeUInt32BE(out[2], 8), buf.writeUInt32BE(out[3], 12), buf;\n    }, AES.prototype.decryptBlock = function(M) {\n      M = asUInt32Array(M);\n      var m1 = M[1];\n      M[1] = M[3], M[3] = m1;\n      var out = cryptBlock(M, this._invKeySchedule, G.INV_SUB_MIX, G.INV_SBOX, this._nRounds), buf = Buffer2.allocUnsafe(16);\n      return buf.writeUInt32BE(out[0], 0), buf.writeUInt32BE(out[3], 4), buf.writeUInt32BE(out[2], 8), buf.writeUInt32BE(out[1], 12), buf;\n    }, AES.prototype.scrub = function() {\n      scrubVec(this._keySchedule), scrubVec(this._invKeySchedule), scrubVec(this._key);\n    }, module.exports.AES = AES;\n  }\n}), require_ghash = __commonJS({\n  \"node_modules/browserify-aes/ghash.js\"(exports, module) {\n    var Buffer2 = require_safe_buffer().Buffer, ZEROES = Buffer2.alloc(16, 0);\n    function toArray(buf) {\n      return [buf.readUInt32BE(0), buf.readUInt32BE(4), buf.readUInt32BE(8), buf.readUInt32BE(12)];\n    }\n    function fromArray(out) {\n      var buf = Buffer2.allocUnsafe(16);\n      return buf.writeUInt32BE(out[0] >>> 0, 0), buf.writeUInt32BE(out[1] >>> 0, 4), buf.writeUInt32BE(out[2] >>> 0, 8), buf.writeUInt32BE(out[3] >>> 0, 12), buf;\n    }\n    function GHASH(key) {\n      this.h = key, this.state = Buffer2.alloc(16, 0), this.cache = Buffer2.allocUnsafe(0);\n    }\n    GHASH.prototype = {}, GHASH.prototype.ghash = function(block) {\n      for (var i = -1;++i < block.length; )\n        this.state[i] ^= block[i];\n      this._multiply();\n    }, GHASH.prototype._multiply = function() {\n      for (var Vi = toArray(this.h), Zi = [0, 0, 0, 0], j, xi, lsbVi, i = -1;++i < 128; ) {\n        for (xi = (this.state[~~(i / 8)] & 1 << 7 - i % 8) !== 0, xi && (Zi[0] ^= Vi[0], Zi[1] ^= Vi[1], Zi[2] ^= Vi[2], Zi[3] ^= Vi[3]), lsbVi = (Vi[3] & 1) !== 0, j = 3;j > 0; j--)\n          Vi[j] = Vi[j] >>> 1 | (Vi[j - 1] & 1) << 31;\n        Vi[0] = Vi[0] >>> 1, lsbVi && (Vi[0] = Vi[0] ^ 225 << 24);\n      }\n      this.state = fromArray(Zi);\n    }, GHASH.prototype.update = function(buf) {\n      this.cache = Buffer2.concat([this.cache, buf]);\n      for (var chunk;this.cache.length >= 16; )\n        chunk = this.cache.slice(0, 16), this.cache = this.cache.slice(16), this.ghash(chunk);\n    }, GHASH.prototype.final = function(abl, bl) {\n      return this.cache.length && this.ghash(Buffer2.concat([this.cache, ZEROES], 16)), this.ghash(fromArray([0, abl, 0, bl])), this.state;\n    }, module.exports = GHASH;\n  }\n}), require_authCipher = __commonJS({\n  \"node_modules/browserify-aes/authCipher.js\"(exports, module) {\n    var aes = require_aes(), Buffer2 = require_safe_buffer().Buffer, Transform = require_cipher_base(), inherits = require_inherits_browser(), GHASH = require_ghash(), xor = require_buffer_xor(), incr32 = require_incr32();\n    function xorTest(a, b) {\n      var out = 0;\n      a.length !== b.length && out++;\n      for (var len = Math.min(a.length, b.length), i = 0;i < len; ++i)\n        out += a[i] ^ b[i];\n      return out;\n    }\n    function calcIv(self2, iv, ck) {\n      if (iv.length === 12)\n        return self2._finID = Buffer2.concat([iv, Buffer2.from([0, 0, 0, 1])]), Buffer2.concat([iv, Buffer2.from([0, 0, 0, 2])]);\n      var ghash = new GHASH(ck), len = iv.length, toPad = len % 16;\n      ghash.update(iv), toPad && (toPad = 16 - toPad, ghash.update(Buffer2.alloc(toPad, 0))), ghash.update(Buffer2.alloc(8, 0));\n      var ivBits = len * 8, tail = Buffer2.alloc(8);\n      tail.writeUIntBE(ivBits, 0, 8), ghash.update(tail), self2._finID = ghash.state;\n      var out = Buffer2.from(self2._finID);\n      return incr32(out), out;\n    }\n    function StreamCipher(mode, key, iv, decrypt) {\n      Transform.call(this);\n      var h = Buffer2.alloc(4, 0);\n      this._cipher = new aes.AES(key);\n      var ck = this._cipher.encryptBlock(h);\n      this._ghash = new GHASH(ck), iv = calcIv(this, iv, ck), this._prev = Buffer2.from(iv), this._cache = Buffer2.allocUnsafe(0), this._secCache = Buffer2.allocUnsafe(0), this._decrypt = decrypt, this._alen = 0, this._len = 0, this._mode = mode, this._authTag = null, this._called = !1;\n    }\n    inherits(StreamCipher, Transform), StreamCipher.prototype._update = function(chunk) {\n      if (!this._called && this._alen) {\n        var rump = 16 - this._alen % 16;\n        rump < 16 && (rump = Buffer2.alloc(rump, 0), this._ghash.update(rump));\n      }\n      this._called = !0;\n      var out = this._mode.encrypt(this, chunk);\n      return this._decrypt \? this._ghash.update(chunk) : this._ghash.update(out), this._len += chunk.length, out;\n    }, StreamCipher.prototype._final = function() {\n      if (this._decrypt && !this._authTag)\n        throw new Error(\"Unsupported state or unable to authenticate data\");\n      var tag = xor(this._ghash.final(this._alen * 8, this._len * 8), this._cipher.encryptBlock(this._finID));\n      if (this._decrypt && xorTest(tag, this._authTag))\n        throw new Error(\"Unsupported state or unable to authenticate data\");\n      this._authTag = tag, this._cipher.scrub();\n    }, StreamCipher.prototype.getAuthTag = function() {\n      if (this._decrypt || !Buffer2.isBuffer(this._authTag))\n        throw new Error(\"Attempting to get auth tag in unsupported state\");\n      return this._authTag;\n    }, StreamCipher.prototype.setAuthTag = function(tag) {\n      if (!this._decrypt)\n        throw new Error(\"Attempting to set auth tag in unsupported state\");\n      this._authTag = tag;\n    }, StreamCipher.prototype.setAAD = function(buf) {\n      if (this._called)\n        throw new Error(\"Attempting to set AAD in unsupported state\");\n      this._ghash.update(buf), this._alen += buf.length;\n    }, module.exports = StreamCipher;\n  }\n}), require_streamCipher = __commonJS({\n  \"node_modules/browserify-aes/streamCipher.js\"(exports, module) {\n    var aes = require_aes(), Buffer2 = require_safe_buffer().Buffer, Transform = require_cipher_base(), inherits = require_inherits_browser();\n    function StreamCipher(mode, key, iv, decrypt) {\n      Transform.call(this), this._cipher = new aes.AES(key), this._prev = Buffer2.from(iv), this._cache = Buffer2.allocUnsafe(0), this._secCache = Buffer2.allocUnsafe(0), this._decrypt = decrypt, this._mode = mode;\n    }\n    inherits(StreamCipher, Transform), StreamCipher.prototype._update = function(chunk) {\n      return this._mode.encrypt(this, chunk, this._decrypt);\n    }, StreamCipher.prototype._final = function() {\n      this._cipher.scrub();\n    }, module.exports = StreamCipher;\n  }\n}), require_evp_bytestokey = __commonJS({\n  \"node_modules/evp_bytestokey/index.js\"(exports, module) {\n    var Buffer2 = require_safe_buffer().Buffer, MD5 = require_md5();\n    function EVP_BytesToKey(password, salt, keyBits, ivLen) {\n      if (Buffer2.isBuffer(password) || (password = Buffer2.from(password, \"binary\")), salt && (Buffer2.isBuffer(salt) || (salt = Buffer2.from(salt, \"binary\")), salt.length !== 8))\n        @throwRangeError(\"salt should be Buffer with 8 byte length\");\n      for (var keyLen = keyBits / 8, key = Buffer2.alloc(keyLen), iv = Buffer2.alloc(ivLen || 0), tmp = Buffer2.alloc(0);keyLen > 0 || ivLen > 0; ) {\n        var hash = new MD5;\n        hash.update(tmp), hash.update(password), salt && hash.update(salt), tmp = hash.digest();\n        var used = 0;\n        if (keyLen > 0) {\n          var keyStart = key.length - keyLen;\n          used = Math.min(keyLen, tmp.length), tmp.copy(key, keyStart, 0, used), keyLen -= used;\n        }\n        if (used < tmp.length && ivLen > 0) {\n          var ivStart = iv.length - ivLen, length = Math.min(ivLen, tmp.length - used);\n          tmp.copy(iv, ivStart, used, used + length), ivLen -= length;\n        }\n      }\n      return tmp.fill(0), { key, iv };\n    }\n    module.exports = EVP_BytesToKey;\n  }\n}), require_encrypter = __commonJS({\n  \"node_modules/browserify-aes/encrypter.js\"(exports) {\n    var MODES = require_modes(), AuthCipher = require_authCipher(), Buffer2 = require_safe_buffer().Buffer, StreamCipher = require_streamCipher(), Transform = require_cipher_base(), aes = require_aes(), ebtk = require_evp_bytestokey(), inherits = require_inherits_browser();\n    function Cipher(mode, key, iv) {\n      Transform.call(this), this._cache = new Splitter, this._cipher = new aes.AES(key), this._prev = Buffer2.from(iv), this._mode = mode, this._autopadding = !0;\n    }\n    inherits(Cipher, Transform), Cipher.prototype._update = function(data) {\n      this._cache.add(data);\n      for (var chunk, thing, out = [];chunk = this._cache.get(); )\n        thing = this._mode.encrypt(this, chunk), out.push(thing);\n      return Buffer2.concat(out);\n    };\n    var PADDING = Buffer2.alloc(16, 16);\n    Cipher.prototype._final = function() {\n      var chunk = this._cache.flush();\n      if (this._autopadding)\n        return chunk = this._mode.encrypt(this, chunk), this._cipher.scrub(), chunk;\n      if (!chunk.equals(PADDING))\n        throw this._cipher.scrub(), new Error(\"data not multiple of block length\");\n    }, Cipher.prototype.setAutoPadding = function(setTo) {\n      return this._autopadding = !!setTo, this;\n    };\n    function Splitter() {\n      this.cache = Buffer2.allocUnsafe(0);\n    }\n    Splitter.prototype = {}, Splitter.prototype.add = function(data) {\n      this.cache = Buffer2.concat([this.cache, data]);\n    }, Splitter.prototype.get = function() {\n      if (this.cache.length > 15) {\n        var out = this.cache.slice(0, 16);\n        return this.cache = this.cache.slice(16), out;\n      }\n      return null;\n    }, Splitter.prototype.flush = function() {\n      for (var len = 16 - this.cache.length, padBuff = Buffer2.allocUnsafe(len), i = -1;++i < len; )\n        padBuff.writeUInt8(len, i);\n      return Buffer2.concat([this.cache, padBuff]);\n    };\n    function createCipheriv(suite, password, iv) {\n      var config = MODES[suite.toLowerCase()];\n      if (!config)\n        @throwTypeError(\"invalid suite type\");\n      password = getArrayBufferOrView(password, \"password\");\n      const iv_length = iv\?.length || 0, required_iv_length = config.iv || 0;\n      if (iv = iv === null \? EMPTY_BUFFER : getArrayBufferOrView(iv, \"iv\"), password\?.length !== config.key / 8) {\n        var error = new RangeError(\"Invalid key length\");\n        throw error.code = \"ERR_CRYPTO_INVALID_KEYLEN\", error;\n      }\n      if (config.mode !== \"GCM\" && iv_length !== required_iv_length) {\n        var error = new RangeError(\"Invalid key length\");\n        throw error.code = \"ERR_CRYPTO_INVALID_KEYLEN\", error;\n      }\n      return config.type === \"stream\" \? new StreamCipher(config.module, password, iv) : config.type === \"auth\" \? new AuthCipher(config.module, password, iv) : new Cipher(config.module, password, iv);\n    }\n    function createCipher(suite, password) {\n      var config = MODES[suite.toLowerCase()];\n      if (!config)\n        @throwTypeError(\"invalid suite type\");\n      var keys = ebtk(password, !1, config.key, config.iv);\n      return createCipheriv(suite, keys.key, keys.iv);\n    }\n    exports.createCipheriv = createCipheriv, exports.createCipher = createCipher;\n  }\n}), require_decrypter = __commonJS({\n  \"node_modules/browserify-aes/decrypter.js\"(exports) {\n    var AuthCipher = require_authCipher(), Buffer2 = require_safe_buffer().Buffer, MODES = require_modes(), StreamCipher = require_streamCipher(), Transform = require_cipher_base(), aes = require_aes(), ebtk = require_evp_bytestokey(), inherits = require_inherits_browser();\n    function Decipher(mode, key, iv) {\n      Transform.call(this), this._cache = new Splitter, this._last = void 0, this._cipher = new aes.AES(key), this._prev = Buffer2.from(iv), this._mode = mode, this._autopadding = !0;\n    }\n    inherits(Decipher, Transform), Decipher.prototype._update = function(data) {\n      this._cache.add(data);\n      for (var chunk, thing, out = [];chunk = this._cache.get(this._autopadding); )\n        thing = this._mode.decrypt(this, chunk), out.push(thing);\n      return Buffer2.concat(out);\n    }, Decipher.prototype._final = function() {\n      var chunk = this._cache.flush();\n      if (this._autopadding)\n        return unpad(this._mode.decrypt(this, chunk));\n      if (chunk)\n        throw new Error(\"data not multiple of block length\");\n    }, Decipher.prototype.setAutoPadding = function(setTo) {\n      return this._autopadding = !!setTo, this;\n    };\n    function Splitter() {\n      this.cache = Buffer2.allocUnsafe(0);\n    }\n    Splitter.prototype = {}, Splitter.prototype.add = function(data) {\n      this.cache = Buffer2.concat([this.cache, data]);\n    }, Splitter.prototype.get = function(autoPadding) {\n      var out;\n      if (autoPadding) {\n        if (this.cache.length > 16)\n          return out = this.cache.slice(0, 16), this.cache = this.cache.slice(16), out;\n      } else if (this.cache.length >= 16)\n        return out = this.cache.slice(0, 16), this.cache = this.cache.slice(16), out;\n      return null;\n    }, Splitter.prototype.flush = function() {\n      if (this.cache.length)\n        return this.cache;\n    };\n    function unpad(last) {\n      var padded = last[15];\n      if (padded < 1 || padded > 16)\n        throw new Error(\"unable to decrypt data\");\n      for (var i = -1;++i < padded; )\n        if (last[i + (16 - padded)] !== padded)\n          throw new Error(\"unable to decrypt data\");\n      if (padded !== 16)\n        return last.slice(0, 16 - padded);\n    }\n    function createDecipheriv(suite, password, iv) {\n      var config = MODES[suite.toLowerCase()];\n      if (!config)\n        @throwTypeError(\"invalid suite type\");\n      password = getArrayBufferOrView(password, \"password\");\n      const iv_length = iv\?.length || 0, required_iv_length = config.iv || 0;\n      if (iv = iv === null \? EMPTY_BUFFER : getArrayBufferOrView(iv, \"iv\"), config.mode !== \"GCM\" && iv_length !== required_iv_length) {\n        var error = new RangeError(\"Invalid key length\");\n        throw error.code = \"ERR_CRYPTO_INVALID_KEYLEN\", error;\n      }\n      if (password.length !== config.key / 8) {\n        var error = new RangeError(\"Invalid key length\");\n        throw error.code = \"ERR_CRYPTO_INVALID_KEYLEN\", error;\n      }\n      return config.type === \"stream\" \? new StreamCipher(config.module, password, iv, !0) : config.type === \"auth\" \? new AuthCipher(config.module, password, iv, !0) : new Decipher(config.module, password, iv);\n    }\n    function createDecipher(suite, password) {\n      var config = MODES[suite.toLowerCase()];\n      if (!config)\n        @throwTypeError(\"invalid suite type\");\n      var keys = ebtk(password, !1, config.key, config.iv);\n      return createDecipheriv(suite, keys.key, keys.iv);\n    }\n    exports.createDecipher = createDecipher, exports.createDecipheriv = createDecipheriv;\n  }\n}), require_browser5 = __commonJS({\n  \"node_modules/browserify-aes/browser.js\"(exports) {\n    var ciphers = require_encrypter(), deciphers = require_decrypter(), modes = require_list();\n    function getCiphers() {\n      return Object.keys(modes);\n    }\n    exports.createCipher = exports.Cipher = ciphers.createCipher, exports.createCipheriv = exports.Cipheriv = ciphers.createCipheriv, exports.createDecipher = exports.Decipher = deciphers.createDecipher, exports.createDecipheriv = exports.Decipheriv = deciphers.createDecipheriv, exports.listCiphers = exports.getCiphers = getCiphers;\n  }\n}), require_modes2 = __commonJS({\n  \"node_modules/browserify-des/modes.js\"(exports) {\n    exports[\"des-ecb\"] = {\n      key: 8,\n      iv: 0\n    }, exports[\"des-cbc\"] = exports.des = {\n      key: 8,\n      iv: 8\n    }, exports[\"des-ede3-cbc\"] = exports.des3 = {\n      key: 24,\n      iv: 8\n    }, exports[\"des-ede3\"] = {\n      key: 24,\n      iv: 0\n    }, exports[\"des-ede-cbc\"] = {\n      key: 16,\n      iv: 8\n    }, exports[\"des-ede\"] = {\n      key: 16,\n      iv: 0\n    };\n  }\n}), require_browser6 = __commonJS({\n  \"node_modules/browserify-cipher/browser.js\"(exports) {\n    var DES = require_browserify_des(), aes = require_browser5(), aesModes = require_modes(), desModes = require_modes2(), ebtk = require_evp_bytestokey();\n    function createCipher(suite, password) {\n      suite = suite.toLowerCase();\n      var keyLen, ivLen;\n      if (aesModes[suite])\n        keyLen = aesModes[suite].key, ivLen = aesModes[suite].iv;\n      else if (desModes[suite])\n        keyLen = desModes[suite].key * 8, ivLen = desModes[suite].iv;\n      else\n        @throwTypeError(\"invalid suite type\");\n      var keys = ebtk(password, !1, keyLen, ivLen);\n      return createCipheriv(suite, keys.key, keys.iv);\n    }\n    function createDecipher(suite, password) {\n      suite = suite.toLowerCase();\n      var keyLen, ivLen;\n      if (aesModes[suite])\n        keyLen = aesModes[suite].key, ivLen = aesModes[suite].iv;\n      else if (desModes[suite])\n        keyLen = desModes[suite].key * 8, ivLen = desModes[suite].iv;\n      else\n        @throwTypeError(\"invalid suite type\");\n      var keys = ebtk(password, !1, keyLen, ivLen);\n      return createDecipheriv(suite, keys.key, keys.iv);\n    }\n    function createCipheriv(suite, key, iv) {\n      if (suite = suite.toLowerCase(), aesModes[suite])\n        return aes.createCipheriv(suite, key, iv);\n      if (desModes[suite])\n        return new DES({ key, iv, mode: suite });\n      @throwTypeError(\"invalid suite type\");\n    }\n    function createDecipheriv(suite, key, iv) {\n      if (suite = suite.toLowerCase(), aesModes[suite])\n        return aes.createDecipheriv(suite, key, iv);\n      if (desModes[suite])\n        return new DES({ key, iv, mode: suite, decrypt: !0 });\n      @throwTypeError(\"invalid suite type\");\n    }\n    function getCiphers() {\n      return Object.keys(desModes).concat(aes.getCiphers());\n    }\n    exports.createCipher = exports.Cipher = createCipher, exports.createCipheriv = exports.Cipheriv = createCipheriv, exports.createDecipher = exports.Decipher = createDecipher, exports.createDecipheriv = exports.Decipheriv = createDecipheriv, exports.listCiphers = exports.getCiphers = getCiphers;\n  }\n}), require_bn = __commonJS({\n  \"node_modules/diffie-hellman/node_modules/bn.js/lib/bn.js\"(exports, module) {\n    (function(module2, exports2) {\n      function assert(val, msg) {\n        if (!val)\n          throw new Error(msg || \"Assertion failed\");\n      }\n      function inherits(ctor, superCtor) {\n        ctor.super_ = superCtor;\n        var TempCtor = function() {\n        };\n        TempCtor.prototype = superCtor.prototype, ctor.prototype = new TempCtor, ctor.prototype.constructor = ctor;\n      }\n      function BN(number, base, endian) {\n        if (BN.isBN(number))\n          return number;\n        this.negative = 0, this.words = null, this.length = 0, this.red = null, number !== null && ((base === \"le\" || base === \"be\") && (endian = base, base = 10), this._init(number || 0, base || 10, endian || \"be\"));\n      }\n      BN.prototype = {}, typeof module2 == \"object\" \? module2.exports = BN : exports2.BN = BN, BN.BN = BN, BN.wordSize = 26;\n      var Buffer2 = Buffer;\n      BN.isBN = function(num) {\n        return num instanceof BN \? !0 : num !== null && typeof num == \"object\" && num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);\n      }, BN.max = function(left, right) {\n        return left.cmp(right) > 0 \? left : right;\n      }, BN.min = function(left, right) {\n        return left.cmp(right) < 0 \? left : right;\n      }, BN.prototype._init = function(number, base, endian) {\n        if (typeof number == \"number\")\n          return this._initNumber(number, base, endian);\n        if (typeof number == \"object\")\n          return this._initArray(number, base, endian);\n        base === \"hex\" && (base = 16), assert(base === (base | 0) && base >= 2 && base <= 36), number = number.toString().replace(/\\s+/g, \"\");\n        var start = 0;\n        number[0] === \"-\" && (start++, this.negative = 1), start < number.length && (base === 16 \? this._parseHex(number, start, endian) : (this._parseBase(number, base, start), endian === \"le\" && this._initArray(this.toArray(), base, endian)));\n      }, BN.prototype._initNumber = function(number, base, endian) {\n        number < 0 && (this.negative = 1, number = -number), number < 67108864 \? (this.words = [number & 67108863], this.length = 1) : number < 4503599627370496 \? (this.words = [number & 67108863, number / 67108864 & 67108863], this.length = 2) : (assert(number < 9007199254740992), this.words = [number & 67108863, number / 67108864 & 67108863, 1], this.length = 3), endian === \"le\" && this._initArray(this.toArray(), base, endian);\n      }, BN.prototype._initArray = function(number, base, endian) {\n        if (assert(typeof number.length == \"number\"), number.length <= 0)\n          return this.words = [0], this.length = 1, this;\n        this.length = Math.ceil(number.length / 3), this.words = new Array(this.length);\n        for (var i = 0;i < this.length; i++)\n          this.words[i] = 0;\n        var j, w, off = 0;\n        if (endian === \"be\")\n          for (i = number.length - 1, j = 0;i >= 0; i -= 3)\n            w = number[i] | number[i - 1] << 8 | number[i - 2] << 16, this.words[j] |= w << off & 67108863, this.words[j + 1] = w >>> 26 - off & 67108863, off += 24, off >= 26 && (off -= 26, j++);\n        else if (endian === \"le\")\n          for (i = 0, j = 0;i < number.length; i += 3)\n            w = number[i] | number[i + 1] << 8 | number[i + 2] << 16, this.words[j] |= w << off & 67108863, this.words[j + 1] = w >>> 26 - off & 67108863, off += 24, off >= 26 && (off -= 26, j++);\n        return this.strip();\n      };\n      function parseHex4Bits(string, index) {\n        var c = string.charCodeAt(index);\n        return c >= 65 && c <= 70 \? c - 55 : c >= 97 && c <= 102 \? c - 87 : c - 48 & 15;\n      }\n      function parseHexByte(string, lowerBound, index) {\n        var r = parseHex4Bits(string, index);\n        return index - 1 >= lowerBound && (r |= parseHex4Bits(string, index - 1) << 4), r;\n      }\n      BN.prototype._parseHex = function(number, start, endian) {\n        this.length = Math.ceil((number.length - start) / 6), this.words = new Array(this.length);\n        for (var i = 0;i < this.length; i++)\n          this.words[i] = 0;\n        var off = 0, j = 0, w;\n        if (endian === \"be\")\n          for (i = number.length - 1;i >= start; i -= 2)\n            w = parseHexByte(number, start, i) << off, this.words[j] |= w & 67108863, off >= 18 \? (off -= 18, j += 1, this.words[j] |= w >>> 26) : off += 8;\n        else {\n          var parseLength = number.length - start;\n          for (i = parseLength % 2 === 0 \? start + 1 : start;i < number.length; i += 2)\n            w = parseHexByte(number, start, i) << off, this.words[j] |= w & 67108863, off >= 18 \? (off -= 18, j += 1, this.words[j] |= w >>> 26) : off += 8;\n        }\n        this.strip();\n      };\n      function parseBase(str, start, end, mul) {\n        for (var r = 0, len = Math.min(str.length, end), i = start;i < len; i++) {\n          var c = str.charCodeAt(i) - 48;\n          r *= mul, c >= 49 \? r += c - 49 + 10 : c >= 17 \? r += c - 17 + 10 : r += c;\n        }\n        return r;\n      }\n      BN.prototype._parseBase = function(number, base, start) {\n        this.words = [0], this.length = 1;\n        for (var limbLen = 0, limbPow = 1;limbPow <= 67108863; limbPow *= base)\n          limbLen++;\n        limbLen--, limbPow = limbPow / base | 0;\n        for (var total = number.length - start, mod = total % limbLen, end = Math.min(total, total - mod) + start, word = 0, i = start;i < end; i += limbLen)\n          word = parseBase(number, i, i + limbLen, base), this.imuln(limbPow), this.words[0] + word < 67108864 \? this.words[0] += word : this._iaddn(word);\n        if (mod !== 0) {\n          var pow = 1;\n          for (word = parseBase(number, i, number.length, base), i = 0;i < mod; i++)\n            pow *= base;\n          this.imuln(pow), this.words[0] + word < 67108864 \? this.words[0] += word : this._iaddn(word);\n        }\n        this.strip();\n      }, BN.prototype.copy = function(dest) {\n        dest.words = new Array(this.length);\n        for (var i = 0;i < this.length; i++)\n          dest.words[i] = this.words[i];\n        dest.length = this.length, dest.negative = this.negative, dest.red = this.red;\n      }, BN.prototype.clone = function() {\n        var r = new BN(null);\n        return this.copy(r), r;\n      }, BN.prototype._expand = function(size) {\n        for (;this.length < size; )\n          this.words[this.length++] = 0;\n        return this;\n      }, BN.prototype.strip = function() {\n        for (;this.length > 1 && this.words[this.length - 1] === 0; )\n          this.length--;\n        return this._normSign();\n      }, BN.prototype._normSign = function() {\n        return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;\n      }, BN.prototype.inspect = function() {\n        return (this.red \? \"<BN-R: \" : \"<BN: \") + this.toString(16) + \">\";\n      };\n      var zeros = [\n        \"\",\n        \"0\",\n        \"00\",\n        \"000\",\n        \"0000\",\n        \"00000\",\n        \"000000\",\n        \"0000000\",\n        \"00000000\",\n        \"000000000\",\n        \"0000000000\",\n        \"00000000000\",\n        \"000000000000\",\n        \"0000000000000\",\n        \"00000000000000\",\n        \"000000000000000\",\n        \"0000000000000000\",\n        \"00000000000000000\",\n        \"000000000000000000\",\n        \"0000000000000000000\",\n        \"00000000000000000000\",\n        \"000000000000000000000\",\n        \"0000000000000000000000\",\n        \"00000000000000000000000\",\n        \"000000000000000000000000\",\n        \"0000000000000000000000000\"\n      ], groupSizes = [\n        0,\n        0,\n        25,\n        16,\n        12,\n        11,\n        10,\n        9,\n        8,\n        8,\n        7,\n        7,\n        7,\n        7,\n        6,\n        6,\n        6,\n        6,\n        6,\n        6,\n        6,\n        5,\n        5,\n        5,\n        5,\n        5,\n        5,\n        5,\n        5,\n        5,\n        5,\n        5,\n        5,\n        5,\n        5,\n        5,\n        5\n      ], groupBases = [\n        0,\n        0,\n        33554432,\n        43046721,\n        16777216,\n        48828125,\n        60466176,\n        40353607,\n        16777216,\n        43046721,\n        1e7,\n        19487171,\n        35831808,\n        62748517,\n        7529536,\n        11390625,\n        16777216,\n        24137569,\n        34012224,\n        47045881,\n        64000000,\n        4084101,\n        5153632,\n        6436343,\n        7962624,\n        9765625,\n        11881376,\n        14348907,\n        17210368,\n        20511149,\n        24300000,\n        28629151,\n        33554432,\n        39135393,\n        45435424,\n        52521875,\n        60466176\n      ];\n      BN.prototype.toString = function(base, padding) {\n        base = base || 10, padding = padding | 0 || 1;\n        var out;\n        if (base === 16 || base === \"hex\") {\n          out = \"\";\n          for (var off = 0, carry = 0, i = 0;i < this.length; i++) {\n            var w = this.words[i], word = ((w << off | carry) & 16777215).toString(16);\n            carry = w >>> 24 - off & 16777215, carry !== 0 || i !== this.length - 1 \? out = zeros[6 - word.length] + word + out : out = word + out, off += 2, off >= 26 && (off -= 26, i--);\n          }\n          for (carry !== 0 && (out = carry.toString(16) + out);out.length % padding !== 0; )\n            out = \"0\" + out;\n          return this.negative !== 0 && (out = \"-\" + out), out;\n        }\n        if (base === (base | 0) && base >= 2 && base <= 36) {\n          var groupSize = groupSizes[base], groupBase = groupBases[base];\n          out = \"\";\n          var c = this.clone();\n          for (c.negative = 0;!c.isZero(); ) {\n            var r = c.modn(groupBase).toString(base);\n            c = c.idivn(groupBase), c.isZero() \? out = r + out : out = zeros[groupSize - r.length] + r + out;\n          }\n          for (this.isZero() && (out = \"0\" + out);out.length % padding !== 0; )\n            out = \"0\" + out;\n          return this.negative !== 0 && (out = \"-\" + out), out;\n        }\n        assert(!1, \"Base should be between 2 and 36\");\n      }, BN.prototype.toNumber = function() {\n        var ret = this.words[0];\n        return this.length === 2 \? ret += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 \? ret += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && assert(!1, \"Number can only safely store up to 53 bits\"), this.negative !== 0 \? -ret : ret;\n      }, BN.prototype.toJSON = function() {\n        return this.toString(16);\n      }, BN.prototype.toBuffer = function(endian, length) {\n        return assert(typeof Buffer2 < \"u\"), this.toArrayLike(Buffer2, endian, length);\n      }, BN.prototype.toArray = function(endian, length) {\n        return this.toArrayLike(Array, endian, length);\n      }, BN.prototype.toArrayLike = function(ArrayType, endian, length) {\n        var byteLength = this.byteLength(), reqLength = length || Math.max(1, byteLength);\n        assert(byteLength <= reqLength, \"byte array longer than desired length\"), assert(reqLength > 0, \"Requested array length <= 0\"), this.strip();\n        var littleEndian = endian === \"le\", res = new ArrayType(reqLength), b, i, q = this.clone();\n        if (littleEndian) {\n          for (i = 0;!q.isZero(); i++)\n            b = q.andln(255), q.iushrn(8), res[i] = b;\n          for (;i < reqLength; i++)\n            res[i] = 0;\n        } else {\n          for (i = 0;i < reqLength - byteLength; i++)\n            res[i] = 0;\n          for (i = 0;!q.isZero(); i++)\n            b = q.andln(255), q.iushrn(8), res[reqLength - i - 1] = b;\n        }\n        return res;\n      }, Math.clz32 \? BN.prototype._countBits = function(w) {\n        return 32 - Math.clz32(w);\n      } : BN.prototype._countBits = function(w) {\n        var t = w, r = 0;\n        return t >= 4096 && (r += 13, t >>>= 13), t >= 64 && (r += 7, t >>>= 7), t >= 8 && (r += 4, t >>>= 4), t >= 2 && (r += 2, t >>>= 2), r + t;\n      }, BN.prototype._zeroBits = function(w) {\n        if (w === 0)\n          return 26;\n        var t = w, r = 0;\n        return (t & 8191) === 0 && (r += 13, t >>>= 13), (t & 127) === 0 && (r += 7, t >>>= 7), (t & 15) === 0 && (r += 4, t >>>= 4), (t & 3) === 0 && (r += 2, t >>>= 2), (t & 1) === 0 && r++, r;\n      }, BN.prototype.bitLength = function() {\n        var w = this.words[this.length - 1], hi = this._countBits(w);\n        return (this.length - 1) * 26 + hi;\n      };\n      function toBitArray(num) {\n        for (var w = new Array(num.bitLength()), bit = 0;bit < w.length; bit++) {\n          var off = bit / 26 | 0, wbit = bit % 26;\n          w[bit] = (num.words[off] & 1 << wbit) >>> wbit;\n        }\n        return w;\n      }\n      BN.prototype.zeroBits = function() {\n        if (this.isZero())\n          return 0;\n        for (var r = 0, i = 0;i < this.length; i++) {\n          var b = this._zeroBits(this.words[i]);\n          if (r += b, b !== 26)\n            break;\n        }\n        return r;\n      }, BN.prototype.byteLength = function() {\n        return Math.ceil(this.bitLength() / 8);\n      }, BN.prototype.toTwos = function(width) {\n        return this.negative !== 0 \? this.abs().inotn(width).iaddn(1) : this.clone();\n      }, BN.prototype.fromTwos = function(width) {\n        return this.testn(width - 1) \? this.notn(width).iaddn(1).ineg() : this.clone();\n      }, BN.prototype.isNeg = function() {\n        return this.negative !== 0;\n      }, BN.prototype.neg = function() {\n        return this.clone().ineg();\n      }, BN.prototype.ineg = function() {\n        return this.isZero() || (this.negative ^= 1), this;\n      }, BN.prototype.iuor = function(num) {\n        for (;this.length < num.length; )\n          this.words[this.length++] = 0;\n        for (var i = 0;i < num.length; i++)\n          this.words[i] = this.words[i] | num.words[i];\n        return this.strip();\n      }, BN.prototype.ior = function(num) {\n        return assert((this.negative | num.negative) === 0), this.iuor(num);\n      }, BN.prototype.or = function(num) {\n        return this.length > num.length \? this.clone().ior(num) : num.clone().ior(this);\n      }, BN.prototype.uor = function(num) {\n        return this.length > num.length \? this.clone().iuor(num) : num.clone().iuor(this);\n      }, BN.prototype.iuand = function(num) {\n        var b;\n        this.length > num.length \? b = num : b = this;\n        for (var i = 0;i < b.length; i++)\n          this.words[i] = this.words[i] & num.words[i];\n        return this.length = b.length, this.strip();\n      }, BN.prototype.iand = function(num) {\n        return assert((this.negative | num.negative) === 0), this.iuand(num);\n      }, BN.prototype.and = function(num) {\n        return this.length > num.length \? this.clone().iand(num) : num.clone().iand(this);\n      }, BN.prototype.uand = function(num) {\n        return this.length > num.length \? this.clone().iuand(num) : num.clone().iuand(this);\n      }, BN.prototype.iuxor = function(num) {\n        var a, b;\n        this.length > num.length \? (a = this, b = num) : (a = num, b = this);\n        for (var i = 0;i < b.length; i++)\n          this.words[i] = a.words[i] ^ b.words[i];\n        if (this !== a)\n          for (;i < a.length; i++)\n            this.words[i] = a.words[i];\n        return this.length = a.length, this.strip();\n      }, BN.prototype.ixor = function(num) {\n        return assert((this.negative | num.negative) === 0), this.iuxor(num);\n      }, BN.prototype.xor = function(num) {\n        return this.length > num.length \? this.clone().ixor(num) : num.clone().ixor(this);\n      }, BN.prototype.uxor = function(num) {\n        return this.length > num.length \? this.clone().iuxor(num) : num.clone().iuxor(this);\n      }, BN.prototype.inotn = function(width) {\n        assert(typeof width == \"number\" && width >= 0);\n        var bytesNeeded = Math.ceil(width / 26) | 0, bitsLeft = width % 26;\n        this._expand(bytesNeeded), bitsLeft > 0 && bytesNeeded--;\n        for (var i = 0;i < bytesNeeded; i++)\n          this.words[i] = ~this.words[i] & 67108863;\n        return bitsLeft > 0 && (this.words[i] = ~this.words[i] & 67108863 >> 26 - bitsLeft), this.strip();\n      }, BN.prototype.notn = function(width) {\n        return this.clone().inotn(width);\n      }, BN.prototype.setn = function(bit, val) {\n        assert(typeof bit == \"number\" && bit >= 0);\n        var off = bit / 26 | 0, wbit = bit % 26;\n        return this._expand(off + 1), val \? this.words[off] = this.words[off] | 1 << wbit : this.words[off] = this.words[off] & ~(1 << wbit), this.strip();\n      }, BN.prototype.iadd = function(num) {\n        var r;\n        if (this.negative !== 0 && num.negative === 0)\n          return this.negative = 0, r = this.isub(num), this.negative ^= 1, this._normSign();\n        if (this.negative === 0 && num.negative !== 0)\n          return num.negative = 0, r = this.isub(num), num.negative = 1, r._normSign();\n        var a, b;\n        this.length > num.length \? (a = this, b = num) : (a = num, b = this);\n        for (var carry = 0, i = 0;i < b.length; i++)\n          r = (a.words[i] | 0) + (b.words[i] | 0) + carry, this.words[i] = r & 67108863, carry = r >>> 26;\n        for (;carry !== 0 && i < a.length; i++)\n          r = (a.words[i] | 0) + carry, this.words[i] = r & 67108863, carry = r >>> 26;\n        if (this.length = a.length, carry !== 0)\n          this.words[this.length] = carry, this.length++;\n        else if (a !== this)\n          for (;i < a.length; i++)\n            this.words[i] = a.words[i];\n        return this;\n      }, BN.prototype.add = function(num) {\n        var res;\n        return num.negative !== 0 && this.negative === 0 \? (num.negative = 0, res = this.sub(num), num.negative ^= 1, res) : num.negative === 0 && this.negative !== 0 \? (this.negative = 0, res = num.sub(this), this.negative = 1, res) : this.length > num.length \? this.clone().iadd(num) : num.clone().iadd(this);\n      }, BN.prototype.isub = function(num) {\n        if (num.negative !== 0) {\n          num.negative = 0;\n          var r = this.iadd(num);\n          return num.negative = 1, r._normSign();\n        } else if (this.negative !== 0)\n          return this.negative = 0, this.iadd(num), this.negative = 1, this._normSign();\n        var cmp = this.cmp(num);\n        if (cmp === 0)\n          return this.negative = 0, this.length = 1, this.words[0] = 0, this;\n        var a, b;\n        cmp > 0 \? (a = this, b = num) : (a = num, b = this);\n        for (var carry = 0, i = 0;i < b.length; i++)\n          r = (a.words[i] | 0) - (b.words[i] | 0) + carry, carry = r >> 26, this.words[i] = r & 67108863;\n        for (;carry !== 0 && i < a.length; i++)\n          r = (a.words[i] | 0) + carry, carry = r >> 26, this.words[i] = r & 67108863;\n        if (carry === 0 && i < a.length && a !== this)\n          for (;i < a.length; i++)\n            this.words[i] = a.words[i];\n        return this.length = Math.max(this.length, i), a !== this && (this.negative = 1), this.strip();\n      }, BN.prototype.sub = function(num) {\n        return this.clone().isub(num);\n      };\n      function smallMulTo(self2, num, out) {\n        out.negative = num.negative ^ self2.negative;\n        var len = self2.length + num.length | 0;\n        out.length = len, len = len - 1 | 0;\n        var a = self2.words[0] | 0, b = num.words[0] | 0, r = a * b, lo = r & 67108863, carry = r / 67108864 | 0;\n        out.words[0] = lo;\n        for (var k = 1;k < len; k++) {\n          for (var ncarry = carry >>> 26, rword = carry & 67108863, maxJ = Math.min(k, num.length - 1), j = Math.max(0, k - self2.length + 1);j <= maxJ; j++) {\n            var i = k - j | 0;\n            a = self2.words[i] | 0, b = num.words[j] | 0, r = a * b + rword, ncarry += r / 67108864 | 0, rword = r & 67108863;\n          }\n          out.words[k] = rword | 0, carry = ncarry | 0;\n        }\n        return carry !== 0 \? out.words[k] = carry | 0 : out.length--, out.strip();\n      }\n      var comb10MulTo = function(self2, num, out) {\n        var a = self2.words, b = num.words, o = out.words, c = 0, lo, mid, hi, a0 = a[0] | 0, al0 = a0 & 8191, ah0 = a0 >>> 13, a1 = a[1] | 0, al1 = a1 & 8191, ah1 = a1 >>> 13, a2 = a[2] | 0, al2 = a2 & 8191, ah2 = a2 >>> 13, a3 = a[3] | 0, al3 = a3 & 8191, ah3 = a3 >>> 13, a4 = a[4] | 0, al4 = a4 & 8191, ah4 = a4 >>> 13, a5 = a[5] | 0, al5 = a5 & 8191, ah5 = a5 >>> 13, a6 = a[6] | 0, al6 = a6 & 8191, ah6 = a6 >>> 13, a7 = a[7] | 0, al7 = a7 & 8191, ah7 = a7 >>> 13, a8 = a[8] | 0, al8 = a8 & 8191, ah8 = a8 >>> 13, a9 = a[9] | 0, al9 = a9 & 8191, ah9 = a9 >>> 13, b0 = b[0] | 0, bl0 = b0 & 8191, bh0 = b0 >>> 13, b1 = b[1] | 0, bl1 = b1 & 8191, bh1 = b1 >>> 13, b2 = b[2] | 0, bl2 = b2 & 8191, bh2 = b2 >>> 13, b3 = b[3] | 0, bl3 = b3 & 8191, bh3 = b3 >>> 13, b4 = b[4] | 0, bl4 = b4 & 8191, bh4 = b4 >>> 13, b5 = b[5] | 0, bl5 = b5 & 8191, bh5 = b5 >>> 13, b6 = b[6] | 0, bl6 = b6 & 8191, bh6 = b6 >>> 13, b7 = b[7] | 0, bl7 = b7 & 8191, bh7 = b7 >>> 13, b8 = b[8] | 0, bl8 = b8 & 8191, bh8 = b8 >>> 13, b9 = b[9] | 0, bl9 = b9 & 8191, bh9 = b9 >>> 13;\n        out.negative = self2.negative ^ num.negative, out.length = 19, lo = Math.imul(al0, bl0), mid = Math.imul(al0, bh0), mid = mid + Math.imul(ah0, bl0) | 0, hi = Math.imul(ah0, bh0);\n        var w0 = (c + lo | 0) + ((mid & 8191) << 13) | 0;\n        c = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0, w0 &= 67108863, lo = Math.imul(al1, bl0), mid = Math.imul(al1, bh0), mid = mid + Math.imul(ah1, bl0) | 0, hi = Math.imul(ah1, bh0), lo = lo + Math.imul(al0, bl1) | 0, mid = mid + Math.imul(al0, bh1) | 0, mid = mid + Math.imul(ah0, bl1) | 0, hi = hi + Math.imul(ah0, bh1) | 0;\n        var w1 = (c + lo | 0) + ((mid & 8191) << 13) | 0;\n        c = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0, w1 &= 67108863, lo = Math.imul(al2, bl0), mid = Math.imul(al2, bh0), mid = mid + Math.imul(ah2, bl0) | 0, hi = Math.imul(ah2, bh0), lo = lo + Math.imul(al1, bl1) | 0, mid = mid + Math.imul(al1, bh1) | 0, mid = mid + Math.imul(ah1, bl1) | 0, hi = hi + Math.imul(ah1, bh1) | 0, lo = lo + Math.imul(al0, bl2) | 0, mid = mid + Math.imul(al0, bh2) | 0, mid = mid + Math.imul(ah0, bl2) | 0, hi = hi + Math.imul(ah0, bh2) | 0;\n        var w2 = (c + lo | 0) + ((mid & 8191) << 13) | 0;\n        c = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0, w2 &= 67108863, lo = Math.imul(al3, bl0), mid = Math.imul(al3, bh0), mid = mid + Math.imul(ah3, bl0) | 0, hi = Math.imul(ah3, bh0), lo = lo + Math.imul(al2, bl1) | 0, mid = mid + Math.imul(al2, bh1) | 0, mid = mid + Math.imul(ah2, bl1) | 0, hi = hi + Math.imul(ah2, bh1) | 0, lo = lo + Math.imul(al1, bl2) | 0, mid = mid + Math.imul(al1, bh2) | 0, mid = mid + Math.imul(ah1, bl2) | 0, hi = hi + Math.imul(ah1, bh2) | 0, lo = lo + Math.imul(al0, bl3) | 0, mid = mid + Math.imul(al0, bh3) | 0, mid = mid + Math.imul(ah0, bl3) | 0, hi = hi + Math.imul(ah0, bh3) | 0;\n        var w3 = (c + lo | 0) + ((mid & 8191) << 13) | 0;\n        c = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0, w3 &= 67108863, lo = Math.imul(al4, bl0), mid = Math.imul(al4, bh0), mid = mid + Math.imul(ah4, bl0) | 0, hi = Math.imul(ah4, bh0), lo = lo + Math.imul(al3, bl1) | 0, mid = mid + Math.imul(al3, bh1) | 0, mid = mid + Math.imul(ah3, bl1) | 0, hi = hi + Math.imul(ah3, bh1) | 0, lo = lo + Math.imul(al2, bl2) | 0, mid = mid + Math.imul(al2, bh2) | 0, mid = mid + Math.imul(ah2, bl2) | 0, hi = hi + Math.imul(ah2, bh2) | 0, lo = lo + Math.imul(al1, bl3) | 0, mid = mid + Math.imul(al1, bh3) | 0, mid = mid + Math.imul(ah1, bl3) | 0, hi = hi + Math.imul(ah1, bh3) | 0, lo = lo + Math.imul(al0, bl4) | 0, mid = mid + Math.imul(al0, bh4) | 0, mid = mid + Math.imul(ah0, bl4) | 0, hi = hi + Math.imul(ah0, bh4) | 0;\n        var w4 = (c + lo | 0) + ((mid & 8191) << 13) | 0;\n        c = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0, w4 &= 67108863, lo = Math.imul(al5, bl0), mid = Math.imul(al5, bh0), mid = mid + Math.imul(ah5, bl0) | 0, hi = Math.imul(ah5, bh0), lo = lo + Math.imul(al4, bl1) | 0, mid = mid + Math.imul(al4, bh1) | 0, mid = mid + Math.imul(ah4, bl1) | 0, hi = hi + Math.imul(ah4, bh1) | 0, lo = lo + Math.imul(al3, bl2) | 0, mid = mid + Math.imul(al3, bh2) | 0, mid = mid + Math.imul(ah3, bl2) | 0, hi = hi + Math.imul(ah3, bh2) | 0, lo = lo + Math.imul(al2, bl3) | 0, mid = mid + Math.imul(al2, bh3) | 0, mid = mid + Math.imul(ah2, bl3) | 0, hi = hi + Math.imul(ah2, bh3) | 0, lo = lo + Math.imul(al1, bl4) | 0, mid = mid + Math.imul(al1, bh4) | 0, mid = mid + Math.imul(ah1, bl4) | 0, hi = hi + Math.imul(ah1, bh4) | 0, lo = lo + Math.imul(al0, bl5) | 0, mid = mid + Math.imul(al0, bh5) | 0, mid = mid + Math.imul(ah0, bl5) | 0, hi = hi + Math.imul(ah0, bh5) | 0;\n        var w5 = (c + lo | 0) + ((mid & 8191) << 13) | 0;\n        c = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0, w5 &= 67108863, lo = Math.imul(al6, bl0), mid = Math.imul(al6, bh0), mid = mid + Math.imul(ah6, bl0) | 0, hi = Math.imul(ah6, bh0), lo = lo + Math.imul(al5, bl1) | 0, mid = mid + Math.imul(al5, bh1) | 0, mid = mid + Math.imul(ah5, bl1) | 0, hi = hi + Math.imul(ah5, bh1) | 0, lo = lo + Math.imul(al4, bl2) | 0, mid = mid + Math.imul(al4, bh2) | 0, mid = mid + Math.imul(ah4, bl2) | 0, hi = hi + Math.imul(ah4, bh2) | 0, lo = lo + Math.imul(al3, bl3) | 0, mid = mid + Math.imul(al3, bh3) | 0, mid = mid + Math.imul(ah3, bl3) | 0, hi = hi + Math.imul(ah3, bh3) | 0, lo = lo + Math.imul(al2, bl4) | 0, mid = mid + Math.imul(al2, bh4) | 0, mid = mid + Math.imul(ah2, bl4) | 0, hi = hi + Math.imul(ah2, bh4) | 0, lo = lo + Math.imul(al1, bl5) | 0, mid = mid + Math.imul(al1, bh5) | 0, mid = mid + Math.imul(ah1, bl5) | 0, hi = hi + Math.imul(ah1, bh5) | 0, lo = lo + Math.imul(al0, bl6) | 0, mid = mid + Math.imul(al0, bh6) | 0, mid = mid + Math.imul(ah0, bl6) | 0, hi = hi + Math.imul(ah0, bh6) | 0;\n        var w6 = (c + lo | 0) + ((mid & 8191) << 13) | 0;\n        c = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0, w6 &= 67108863, lo = Math.imul(al7, bl0), mid = Math.imul(al7, bh0), mid = mid + Math.imul(ah7, bl0) | 0, hi = Math.imul(ah7, bh0), lo = lo + Math.imul(al6, bl1) | 0, mid = mid + Math.imul(al6, bh1) | 0, mid = mid + Math.imul(ah6, bl1) | 0, hi = hi + Math.imul(ah6, bh1) | 0, lo = lo + Math.imul(al5, bl2) | 0, mid = mid + Math.imul(al5, bh2) | 0, mid = mid + Math.imul(ah5, bl2) | 0, hi = hi + Math.imul(ah5, bh2) | 0, lo = lo + Math.imul(al4, bl3) | 0, mid = mid + Math.imul(al4, bh3) | 0, mid = mid + Math.imul(ah4, bl3) | 0, hi = hi + Math.imul(ah4, bh3) | 0, lo = lo + Math.imul(al3, bl4) | 0, mid = mid + Math.imul(al3, bh4) | 0, mid = mid + Math.imul(ah3, bl4) | 0, hi = hi + Math.imul(ah3, bh4) | 0, lo = lo + Math.imul(al2, bl5) | 0, mid = mid + Math.imul(al2, bh5) | 0, mid = mid + Math.imul(ah2, bl5) | 0, hi = hi + Math.imul(ah2, bh5) | 0, lo = lo + Math.imul(al1, bl6) | 0, mid = mid + Math.imul(al1, bh6) | 0, mid = mid + Math.imul(ah1, bl6) | 0, hi = hi + Math.imul(ah1, bh6) | 0, lo = lo + Math.imul(al0, bl7) | 0, mid = mid + Math.imul(al0, bh7) | 0, mid = mid + Math.imul(ah0, bl7) | 0, hi = hi + Math.imul(ah0, bh7) | 0;\n        var w7 = (c + lo | 0) + ((mid & 8191) << 13) | 0;\n        c = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0, w7 &= 67108863, lo = Math.imul(al8, bl0), mid = Math.imul(al8, bh0), mid = mid + Math.imul(ah8, bl0) | 0, hi = Math.imul(ah8, bh0), lo = lo + Math.imul(al7, bl1) | 0, mid = mid + Math.imul(al7, bh1) | 0, mid = mid + Math.imul(ah7, bl1) | 0, hi = hi + Math.imul(ah7, bh1) | 0, lo = lo + Math.imul(al6, bl2) | 0, mid = mid + Math.imul(al6, bh2) | 0, mid = mid + Math.imul(ah6, bl2) | 0, hi = hi + Math.imul(ah6, bh2) | 0, lo = lo + Math.imul(al5, bl3) | 0, mid = mid + Math.imul(al5, bh3) | 0, mid = mid + Math.imul(ah5, bl3) | 0, hi = hi + Math.imul(ah5, bh3) | 0, lo = lo + Math.imul(al4, bl4) | 0, mid = mid + Math.imul(al4, bh4) | 0, mid = mid + Math.imul(ah4, bl4) | 0, hi = hi + Math.imul(ah4, bh4) | 0, lo = lo + Math.imul(al3, bl5) | 0, mid = mid + Math.imul(al3, bh5) | 0, mid = mid + Math.imul(ah3, bl5) | 0, hi = hi + Math.imul(ah3, bh5) | 0, lo = lo + Math.imul(al2, bl6) | 0, mid = mid + Math.imul(al2, bh6) | 0, mid = mid + Math.imul(ah2, bl6) | 0, hi = hi + Math.imul(ah2, bh6) | 0, lo = lo + Math.imul(al1, bl7) | 0, mid = mid + Math.imul(al1, bh7) | 0, mid = mid + Math.imul(ah1, bl7) | 0, hi = hi + Math.imul(ah1, bh7) | 0, lo = lo + Math.imul(al0, bl8) | 0, mid = mid + Math.imul(al0, bh8) | 0, mid = mid + Math.imul(ah0, bl8) | 0, hi = hi + Math.imul(ah0, bh8) | 0;\n        var w8 = (c + lo | 0) + ((mid & 8191) << 13) | 0;\n        c = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0, w8 &= 67108863, lo = Math.imul(al9, bl0), mid = Math.imul(al9, bh0), mid = mid + Math.imul(ah9, bl0) | 0, hi = Math.imul(ah9, bh0), lo = lo + Math.imul(al8, bl1) | 0, mid = mid + Math.imul(al8, bh1) | 0, mid = mid + Math.imul(ah8, bl1) | 0, hi = hi + Math.imul(ah8, bh1) | 0, lo = lo + Math.imul(al7, bl2) | 0, mid = mid + Math.imul(al7, bh2) | 0, mid = mid + Math.imul(ah7, bl2) | 0, hi = hi + Math.imul(ah7, bh2) | 0, lo = lo + Math.imul(al6, bl3) | 0, mid = mid + Math.imul(al6, bh3) | 0, mid = mid + Math.imul(ah6, bl3) | 0, hi = hi + Math.imul(ah6, bh3) | 0, lo = lo + Math.imul(al5, bl4) | 0, mid = mid + Math.imul(al5, bh4) | 0, mid = mid + Math.imul(ah5, bl4) | 0, hi = hi + Math.imul(ah5, bh4) | 0, lo = lo + Math.imul(al4, bl5) | 0, mid = mid + Math.imul(al4, bh5) | 0, mid = mid + Math.imul(ah4, bl5) | 0, hi = hi + Math.imul(ah4, bh5) | 0, lo = lo + Math.imul(al3, bl6) | 0, mid = mid + Math.imul(al3, bh6) | 0, mid = mid + Math.imul(ah3, bl6) | 0, hi = hi + Math.imul(ah3, bh6) | 0, lo = lo + Math.imul(al2, bl7) | 0, mid = mid + Math.imul(al2, bh7) | 0, mid = mid + Math.imul(ah2, bl7) | 0, hi = hi + Math.imul(ah2, bh7) | 0, lo = lo + Math.imul(al1, bl8) | 0, mid = mid + Math.imul(al1, bh8) | 0, mid = mid + Math.imul(ah1, bl8) | 0, hi = hi + Math.imul(ah1, bh8) | 0, lo = lo + Math.imul(al0, bl9) | 0, mid = mid + Math.imul(al0, bh9) | 0, mid = mid + Math.imul(ah0, bl9) | 0, hi = hi + Math.imul(ah0, bh9) | 0;\n        var w9 = (c + lo | 0) + ((mid & 8191) << 13) | 0;\n        c = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0, w9 &= 67108863, lo = Math.imul(al9, bl1), mid = Math.imul(al9, bh1), mid = mid + Math.imul(ah9, bl1) | 0, hi = Math.imul(ah9, bh1), lo = lo + Math.imul(al8, bl2) | 0, mid = mid + Math.imul(al8, bh2) | 0, mid = mid + Math.imul(ah8, bl2) | 0, hi = hi + Math.imul(ah8, bh2) | 0, lo = lo + Math.imul(al7, bl3) | 0, mid = mid + Math.imul(al7, bh3) | 0, mid = mid + Math.imul(ah7, bl3) | 0, hi = hi + Math.imul(ah7, bh3) | 0, lo = lo + Math.imul(al6, bl4) | 0, mid = mid + Math.imul(al6, bh4) | 0, mid = mid + Math.imul(ah6, bl4) | 0, hi = hi + Math.imul(ah6, bh4) | 0, lo = lo + Math.imul(al5, bl5) | 0, mid = mid + Math.imul(al5, bh5) | 0, mid = mid + Math.imul(ah5, bl5) | 0, hi = hi + Math.imul(ah5, bh5) | 0, lo = lo + Math.imul(al4, bl6) | 0, mid = mid + Math.imul(al4, bh6) | 0, mid = mid + Math.imul(ah4, bl6) | 0, hi = hi + Math.imul(ah4, bh6) | 0, lo = lo + Math.imul(al3, bl7) | 0, mid = mid + Math.imul(al3, bh7) | 0, mid = mid + Math.imul(ah3, bl7) | 0, hi = hi + Math.imul(ah3, bh7) | 0, lo = lo + Math.imul(al2, bl8) | 0, mid = mid + Math.imul(al2, bh8) | 0, mid = mid + Math.imul(ah2, bl8) | 0, hi = hi + Math.imul(ah2, bh8) | 0, lo = lo + Math.imul(al1, bl9) | 0, mid = mid + Math.imul(al1, bh9) | 0, mid = mid + Math.imul(ah1, bl9) | 0, hi = hi + Math.imul(ah1, bh9) | 0;\n        var w10 = (c + lo | 0) + ((mid & 8191) << 13) | 0;\n        c = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0, w10 &= 67108863, lo = Math.imul(al9, bl2), mid = Math.imul(al9, bh2), mid = mid + Math.imul(ah9, bl2) | 0, hi = Math.imul(ah9, bh2), lo = lo + Math.imul(al8, bl3) | 0, mid = mid + Math.imul(al8, bh3) | 0, mid = mid + Math.imul(ah8, bl3) | 0, hi = hi + Math.imul(ah8, bh3) | 0, lo = lo + Math.imul(al7, bl4) | 0, mid = mid + Math.imul(al7, bh4) | 0, mid = mid + Math.imul(ah7, bl4) | 0, hi = hi + Math.imul(ah7, bh4) | 0, lo = lo + Math.imul(al6, bl5) | 0, mid = mid + Math.imul(al6, bh5) | 0, mid = mid + Math.imul(ah6, bl5) | 0, hi = hi + Math.imul(ah6, bh5) | 0, lo = lo + Math.imul(al5, bl6) | 0, mid = mid + Math.imul(al5, bh6) | 0, mid = mid + Math.imul(ah5, bl6) | 0, hi = hi + Math.imul(ah5, bh6) | 0, lo = lo + Math.imul(al4, bl7) | 0, mid = mid + Math.imul(al4, bh7) | 0, mid = mid + Math.imul(ah4, bl7) | 0, hi = hi + Math.imul(ah4, bh7) | 0, lo = lo + Math.imul(al3, bl8) | 0, mid = mid + Math.imul(al3, bh8) | 0, mid = mid + Math.imul(ah3, bl8) | 0, hi = hi + Math.imul(ah3, bh8) | 0, lo = lo + Math.imul(al2, bl9) | 0, mid = mid + Math.imul(al2, bh9) | 0, mid = mid + Math.imul(ah2, bl9) | 0, hi = hi + Math.imul(ah2, bh9) | 0;\n        var w11 = (c + lo | 0) + ((mid & 8191) << 13) | 0;\n        c = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0, w11 &= 67108863, lo = Math.imul(al9, bl3), mid = Math.imul(al9, bh3), mid = mid + Math.imul(ah9, bl3) | 0, hi = Math.imul(ah9, bh3), lo = lo + Math.imul(al8, bl4) | 0, mid = mid + Math.imul(al8, bh4) | 0, mid = mid + Math.imul(ah8, bl4) | 0, hi = hi + Math.imul(ah8, bh4) | 0, lo = lo + Math.imul(al7, bl5) | 0, mid = mid + Math.imul(al7, bh5) | 0, mid = mid + Math.imul(ah7, bl5) | 0, hi = hi + Math.imul(ah7, bh5) | 0, lo = lo + Math.imul(al6, bl6) | 0, mid = mid + Math.imul(al6, bh6) | 0, mid = mid + Math.imul(ah6, bl6) | 0, hi = hi + Math.imul(ah6, bh6) | 0, lo = lo + Math.imul(al5, bl7) | 0, mid = mid + Math.imul(al5, bh7) | 0, mid = mid + Math.imul(ah5, bl7) | 0, hi = hi + Math.imul(ah5, bh7) | 0, lo = lo + Math.imul(al4, bl8) | 0, mid = mid + Math.imul(al4, bh8) | 0, mid = mid + Math.imul(ah4, bl8) | 0, hi = hi + Math.imul(ah4, bh8) | 0, lo = lo + Math.imul(al3, bl9) | 0, mid = mid + Math.imul(al3, bh9) | 0, mid = mid + Math.imul(ah3, bl9) | 0, hi = hi + Math.imul(ah3, bh9) | 0;\n        var w12 = (c + lo | 0) + ((mid & 8191) << 13) | 0;\n        c = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0, w12 &= 67108863, lo = Math.imul(al9, bl4), mid = Math.imul(al9, bh4), mid = mid + Math.imul(ah9, bl4) | 0, hi = Math.imul(ah9, bh4), lo = lo + Math.imul(al8, bl5) | 0, mid = mid + Math.imul(al8, bh5) | 0, mid = mid + Math.imul(ah8, bl5) | 0, hi = hi + Math.imul(ah8, bh5) | 0, lo = lo + Math.imul(al7, bl6) | 0, mid = mid + Math.imul(al7, bh6) | 0, mid = mid + Math.imul(ah7, bl6) | 0, hi = hi + Math.imul(ah7, bh6) | 0, lo = lo + Math.imul(al6, bl7) | 0, mid = mid + Math.imul(al6, bh7) | 0, mid = mid + Math.imul(ah6, bl7) | 0, hi = hi + Math.imul(ah6, bh7) | 0, lo = lo + Math.imul(al5, bl8) | 0, mid = mid + Math.imul(al5, bh8) | 0, mid = mid + Math.imul(ah5, bl8) | 0, hi = hi + Math.imul(ah5, bh8) | 0, lo = lo + Math.imul(al4, bl9) | 0, mid = mid + Math.imul(al4, bh9) | 0, mid = mid + Math.imul(ah4, bl9) | 0, hi = hi + Math.imul(ah4, bh9) | 0;\n        var w13 = (c + lo | 0) + ((mid & 8191) << 13) | 0;\n        c = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0, w13 &= 67108863, lo = Math.imul(al9, bl5), mid = Math.imul(al9, bh5), mid = mid + Math.imul(ah9, bl5) | 0, hi = Math.imul(ah9, bh5), lo = lo + Math.imul(al8, bl6) | 0, mid = mid + Math.imul(al8, bh6) | 0, mid = mid + Math.imul(ah8, bl6) | 0, hi = hi + Math.imul(ah8, bh6) | 0, lo = lo + Math.imul(al7, bl7) | 0, mid = mid + Math.imul(al7, bh7) | 0, mid = mid + Math.imul(ah7, bl7) | 0, hi = hi + Math.imul(ah7, bh7) | 0, lo = lo + Math.imul(al6, bl8) | 0, mid = mid + Math.imul(al6, bh8) | 0, mid = mid + Math.imul(ah6, bl8) | 0, hi = hi + Math.imul(ah6, bh8) | 0, lo = lo + Math.imul(al5, bl9) | 0, mid = mid + Math.imul(al5, bh9) | 0, mid = mid + Math.imul(ah5, bl9) | 0, hi = hi + Math.imul(ah5, bh9) | 0;\n        var w14 = (c + lo | 0) + ((mid & 8191) << 13) | 0;\n        c = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0, w14 &= 67108863, lo = Math.imul(al9, bl6), mid = Math.imul(al9, bh6), mid = mid + Math.imul(ah9, bl6) | 0, hi = Math.imul(ah9, bh6), lo = lo + Math.imul(al8, bl7) | 0, mid = mid + Math.imul(al8, bh7) | 0, mid = mid + Math.imul(ah8, bl7) | 0, hi = hi + Math.imul(ah8, bh7) | 0, lo = lo + Math.imul(al7, bl8) | 0, mid = mid + Math.imul(al7, bh8) | 0, mid = mid + Math.imul(ah7, bl8) | 0, hi = hi + Math.imul(ah7, bh8) | 0, lo = lo + Math.imul(al6, bl9) | 0, mid = mid + Math.imul(al6, bh9) | 0, mid = mid + Math.imul(ah6, bl9) | 0, hi = hi + Math.imul(ah6, bh9) | 0;\n        var w15 = (c + lo | 0) + ((mid & 8191) << 13) | 0;\n        c = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0, w15 &= 67108863, lo = Math.imul(al9, bl7), mid = Math.imul(al9, bh7), mid = mid + Math.imul(ah9, bl7) | 0, hi = Math.imul(ah9, bh7), lo = lo + Math.imul(al8, bl8) | 0, mid = mid + Math.imul(al8, bh8) | 0, mid = mid + Math.imul(ah8, bl8) | 0, hi = hi + Math.imul(ah8, bh8) | 0, lo = lo + Math.imul(al7, bl9) | 0, mid = mid + Math.imul(al7, bh9) | 0, mid = mid + Math.imul(ah7, bl9) | 0, hi = hi + Math.imul(ah7, bh9) | 0;\n        var w16 = (c + lo | 0) + ((mid & 8191) << 13) | 0;\n        c = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0, w16 &= 67108863, lo = Math.imul(al9, bl8), mid = Math.imul(al9, bh8), mid = mid + Math.imul(ah9, bl8) | 0, hi = Math.imul(ah9, bh8), lo = lo + Math.imul(al8, bl9) | 0, mid = mid + Math.imul(al8, bh9) | 0, mid = mid + Math.imul(ah8, bl9) | 0, hi = hi + Math.imul(ah8, bh9) | 0;\n        var w17 = (c + lo | 0) + ((mid & 8191) << 13) | 0;\n        c = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0, w17 &= 67108863, lo = Math.imul(al9, bl9), mid = Math.imul(al9, bh9), mid = mid + Math.imul(ah9, bl9) | 0, hi = Math.imul(ah9, bh9);\n        var w18 = (c + lo | 0) + ((mid & 8191) << 13) | 0;\n        return c = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0, w18 &= 67108863, o[0] = w0, o[1] = w1, o[2] = w2, o[3] = w3, o[4] = w4, o[5] = w5, o[6] = w6, o[7] = w7, o[8] = w8, o[9] = w9, o[10] = w10, o[11] = w11, o[12] = w12, o[13] = w13, o[14] = w14, o[15] = w15, o[16] = w16, o[17] = w17, o[18] = w18, c !== 0 && (o[19] = c, out.length++), out;\n      };\n      Math.imul || (comb10MulTo = smallMulTo);\n      function bigMulTo(self2, num, out) {\n        out.negative = num.negative ^ self2.negative, out.length = self2.length + num.length;\n        for (var carry = 0, hncarry = 0, k = 0;k < out.length - 1; k++) {\n          var ncarry = hncarry;\n          hncarry = 0;\n          for (var rword = carry & 67108863, maxJ = Math.min(k, num.length - 1), j = Math.max(0, k - self2.length + 1);j <= maxJ; j++) {\n            var i = k - j, a = self2.words[i] | 0, b = num.words[j] | 0, r = a * b, lo = r & 67108863;\n            ncarry = ncarry + (r / 67108864 | 0) | 0, lo = lo + rword | 0, rword = lo & 67108863, ncarry = ncarry + (lo >>> 26) | 0, hncarry += ncarry >>> 26, ncarry &= 67108863;\n          }\n          out.words[k] = rword, carry = ncarry, ncarry = hncarry;\n        }\n        return carry !== 0 \? out.words[k] = carry : out.length--, out.strip();\n      }\n      function jumboMulTo(self2, num, out) {\n        var fftm = new FFTM;\n        return fftm.mulp(self2, num, out);\n      }\n      BN.prototype.mulTo = function(num, out) {\n        var res, len = this.length + num.length;\n        return this.length === 10 && num.length === 10 \? res = comb10MulTo(this, num, out) : len < 63 \? res = smallMulTo(this, num, out) : len < 1024 \? res = bigMulTo(this, num, out) : res = jumboMulTo(this, num, out), res;\n      };\n      function FFTM(x, y) {\n        this.x = x, this.y = y;\n      }\n      FFTM.prototype = {}, FFTM.prototype.makeRBT = function(N) {\n        for (var t = new Array(N), l = BN.prototype._countBits(N) - 1, i = 0;i < N; i++)\n          t[i] = this.revBin(i, l, N);\n        return t;\n      }, FFTM.prototype.revBin = function(x, l, N) {\n        if (x === 0 || x === N - 1)\n          return x;\n        for (var rb = 0, i = 0;i < l; i++)\n          rb |= (x & 1) << l - i - 1, x >>= 1;\n        return rb;\n      }, FFTM.prototype.permute = function(rbt, rws, iws, rtws, itws, N) {\n        for (var i = 0;i < N; i++)\n          rtws[i] = rws[rbt[i]], itws[i] = iws[rbt[i]];\n      }, FFTM.prototype.transform = function(rws, iws, rtws, itws, N, rbt) {\n        this.permute(rbt, rws, iws, rtws, itws, N);\n        for (var s = 1;s < N; s <<= 1)\n          for (var l = s << 1, rtwdf = Math.cos(2 * Math.PI / l), itwdf = Math.sin(2 * Math.PI / l), p = 0;p < N; p += l)\n            for (var rtwdf_ = rtwdf, itwdf_ = itwdf, j = 0;j < s; j++) {\n              var re = rtws[p + j], ie = itws[p + j], ro = rtws[p + j + s], io = itws[p + j + s], rx = rtwdf_ * ro - itwdf_ * io;\n              io = rtwdf_ * io + itwdf_ * ro, ro = rx, rtws[p + j] = re + ro, itws[p + j] = ie + io, rtws[p + j + s] = re - ro, itws[p + j + s] = ie - io, j !== l && (rx = rtwdf * rtwdf_ - itwdf * itwdf_, itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_, rtwdf_ = rx);\n            }\n      }, FFTM.prototype.guessLen13b = function(n, m) {\n        var N = Math.max(m, n) | 1, odd = N & 1, i = 0;\n        for (N = N / 2 | 0;N; N = N >>> 1)\n          i++;\n        return 1 << i + 1 + odd;\n      }, FFTM.prototype.conjugate = function(rws, iws, N) {\n        if (!(N <= 1))\n          for (var i = 0;i < N / 2; i++) {\n            var t = rws[i];\n            rws[i] = rws[N - i - 1], rws[N - i - 1] = t, t = iws[i], iws[i] = -iws[N - i - 1], iws[N - i - 1] = -t;\n          }\n      }, FFTM.prototype.normalize13b = function(ws, N) {\n        for (var carry = 0, i = 0;i < N / 2; i++) {\n          var w = Math.round(ws[2 * i + 1] / N) * 8192 + Math.round(ws[2 * i] / N) + carry;\n          ws[i] = w & 67108863, w < 67108864 \? carry = 0 : carry = w / 67108864 | 0;\n        }\n        return ws;\n      }, FFTM.prototype.convert13b = function(ws, len, rws, N) {\n        for (var carry = 0, i = 0;i < len; i++)\n          carry = carry + (ws[i] | 0), rws[2 * i] = carry & 8191, carry = carry >>> 13, rws[2 * i + 1] = carry & 8191, carry = carry >>> 13;\n        for (i = 2 * len;i < N; ++i)\n          rws[i] = 0;\n        assert(carry === 0), assert((carry & -8192) === 0);\n      }, FFTM.prototype.stub = function(N) {\n        for (var ph = new Array(N), i = 0;i < N; i++)\n          ph[i] = 0;\n        return ph;\n      }, FFTM.prototype.mulp = function(x, y, out) {\n        var N = 2 * this.guessLen13b(x.length, y.length), rbt = this.makeRBT(N), _ = this.stub(N), rws = new Array(N), rwst = new Array(N), iwst = new Array(N), nrws = new Array(N), nrwst = new Array(N), niwst = new Array(N), rmws = out.words;\n        rmws.length = N, this.convert13b(x.words, x.length, rws, N), this.convert13b(y.words, y.length, nrws, N), this.transform(rws, _, rwst, iwst, N, rbt), this.transform(nrws, _, nrwst, niwst, N, rbt);\n        for (var i = 0;i < N; i++) {\n          var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];\n          iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i], rwst[i] = rx;\n        }\n        return this.conjugate(rwst, iwst, N), this.transform(rwst, iwst, rmws, _, N, rbt), this.conjugate(rmws, _, N), this.normalize13b(rmws, N), out.negative = x.negative ^ y.negative, out.length = x.length + y.length, out.strip();\n      }, BN.prototype.mul = function(num) {\n        var out = new BN(null);\n        return out.words = new Array(this.length + num.length), this.mulTo(num, out);\n      }, BN.prototype.mulf = function(num) {\n        var out = new BN(null);\n        return out.words = new Array(this.length + num.length), jumboMulTo(this, num, out);\n      }, BN.prototype.imul = function(num) {\n        return this.clone().mulTo(num, this);\n      }, BN.prototype.imuln = function(num) {\n        assert(typeof num == \"number\"), assert(num < 67108864);\n        for (var carry = 0, i = 0;i < this.length; i++) {\n          var w = (this.words[i] | 0) * num, lo = (w & 67108863) + (carry & 67108863);\n          carry >>= 26, carry += w / 67108864 | 0, carry += lo >>> 26, this.words[i] = lo & 67108863;\n        }\n        return carry !== 0 && (this.words[i] = carry, this.length++), this;\n      }, BN.prototype.muln = function(num) {\n        return this.clone().imuln(num);\n      }, BN.prototype.sqr = function() {\n        return this.mul(this);\n      }, BN.prototype.isqr = function() {\n        return this.imul(this.clone());\n      }, BN.prototype.pow = function(num) {\n        var w = toBitArray(num);\n        if (w.length === 0)\n          return new BN(1);\n        for (var res = this, i = 0;i < w.length && w[i] === 0; i++, res = res.sqr())\n          ;\n        if (++i < w.length)\n          for (var q = res.sqr();i < w.length; i++, q = q.sqr())\n            w[i] !== 0 && (res = res.mul(q));\n        return res;\n      }, BN.prototype.iushln = function(bits) {\n        assert(typeof bits == \"number\" && bits >= 0);\n        var r = bits % 26, s = (bits - r) / 26, carryMask = 67108863 >>> 26 - r << 26 - r, i;\n        if (r !== 0) {\n          var carry = 0;\n          for (i = 0;i < this.length; i++) {\n            var newCarry = this.words[i] & carryMask, c = (this.words[i] | 0) - newCarry << r;\n            this.words[i] = c | carry, carry = newCarry >>> 26 - r;\n          }\n          carry && (this.words[i] = carry, this.length++);\n        }\n        if (s !== 0) {\n          for (i = this.length - 1;i >= 0; i--)\n            this.words[i + s] = this.words[i];\n          for (i = 0;i < s; i++)\n            this.words[i] = 0;\n          this.length += s;\n        }\n        return this.strip();\n      }, BN.prototype.ishln = function(bits) {\n        return assert(this.negative === 0), this.iushln(bits);\n      }, BN.prototype.iushrn = function(bits, hint, extended) {\n        assert(typeof bits == \"number\" && bits >= 0);\n        var h;\n        hint \? h = (hint - hint % 26) / 26 : h = 0;\n        var r = bits % 26, s = Math.min((bits - r) / 26, this.length), mask = 67108863 ^ 67108863 >>> r << r, maskedWords = extended;\n        if (h -= s, h = Math.max(0, h), maskedWords) {\n          for (var i = 0;i < s; i++)\n            maskedWords.words[i] = this.words[i];\n          maskedWords.length = s;\n        }\n        if (s !== 0)\n          if (this.length > s)\n            for (this.length -= s, i = 0;i < this.length; i++)\n              this.words[i] = this.words[i + s];\n          else\n            this.words[0] = 0, this.length = 1;\n        var carry = 0;\n        for (i = this.length - 1;i >= 0 && (carry !== 0 || i >= h); i--) {\n          var word = this.words[i] | 0;\n          this.words[i] = carry << 26 - r | word >>> r, carry = word & mask;\n        }\n        return maskedWords && carry !== 0 && (maskedWords.words[maskedWords.length++] = carry), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip();\n      }, BN.prototype.ishrn = function(bits, hint, extended) {\n        return assert(this.negative === 0), this.iushrn(bits, hint, extended);\n      }, BN.prototype.shln = function(bits) {\n        return this.clone().ishln(bits);\n      }, BN.prototype.ushln = function(bits) {\n        return this.clone().iushln(bits);\n      }, BN.prototype.shrn = function(bits) {\n        return this.clone().ishrn(bits);\n      }, BN.prototype.ushrn = function(bits) {\n        return this.clone().iushrn(bits);\n      }, BN.prototype.testn = function(bit) {\n        assert(typeof bit == \"number\" && bit >= 0);\n        var r = bit % 26, s = (bit - r) / 26, q = 1 << r;\n        if (this.length <= s)\n          return !1;\n        var w = this.words[s];\n        return !!(w & q);\n      }, BN.prototype.imaskn = function(bits) {\n        assert(typeof bits == \"number\" && bits >= 0);\n        var r = bits % 26, s = (bits - r) / 26;\n        if (assert(this.negative === 0, \"imaskn works only with positive numbers\"), this.length <= s)\n          return this;\n        if (r !== 0 && s++, this.length = Math.min(s, this.length), r !== 0) {\n          var mask = 67108863 ^ 67108863 >>> r << r;\n          this.words[this.length - 1] &= mask;\n        }\n        return this.strip();\n      }, BN.prototype.maskn = function(bits) {\n        return this.clone().imaskn(bits);\n      }, BN.prototype.iaddn = function(num) {\n        return assert(typeof num == \"number\"), assert(num < 67108864), num < 0 \? this.isubn(-num) : this.negative !== 0 \? this.length === 1 && (this.words[0] | 0) < num \? (this.words[0] = num - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(num), this.negative = 1, this) : this._iaddn(num);\n      }, BN.prototype._iaddn = function(num) {\n        this.words[0] += num;\n        for (var i = 0;i < this.length && this.words[i] >= 67108864; i++)\n          this.words[i] -= 67108864, i === this.length - 1 \? this.words[i + 1] = 1 : this.words[i + 1]++;\n        return this.length = Math.max(this.length, i + 1), this;\n      }, BN.prototype.isubn = function(num) {\n        if (assert(typeof num == \"number\"), assert(num < 67108864), num < 0)\n          return this.iaddn(-num);\n        if (this.negative !== 0)\n          return this.negative = 0, this.iaddn(num), this.negative = 1, this;\n        if (this.words[0] -= num, this.length === 1 && this.words[0] < 0)\n          this.words[0] = -this.words[0], this.negative = 1;\n        else\n          for (var i = 0;i < this.length && this.words[i] < 0; i++)\n            this.words[i] += 67108864, this.words[i + 1] -= 1;\n        return this.strip();\n      }, BN.prototype.addn = function(num) {\n        return this.clone().iaddn(num);\n      }, BN.prototype.subn = function(num) {\n        return this.clone().isubn(num);\n      }, BN.prototype.iabs = function() {\n        return this.negative = 0, this;\n      }, BN.prototype.abs = function() {\n        return this.clone().iabs();\n      }, BN.prototype._ishlnsubmul = function(num, mul, shift) {\n        var len = num.length + shift, i;\n        this._expand(len);\n        var w, carry = 0;\n        for (i = 0;i < num.length; i++) {\n          w = (this.words[i + shift] | 0) + carry;\n          var right = (num.words[i] | 0) * mul;\n          w -= right & 67108863, carry = (w >> 26) - (right / 67108864 | 0), this.words[i + shift] = w & 67108863;\n        }\n        for (;i < this.length - shift; i++)\n          w = (this.words[i + shift] | 0) + carry, carry = w >> 26, this.words[i + shift] = w & 67108863;\n        if (carry === 0)\n          return this.strip();\n        for (assert(carry === -1), carry = 0, i = 0;i < this.length; i++)\n          w = -(this.words[i] | 0) + carry, carry = w >> 26, this.words[i] = w & 67108863;\n        return this.negative = 1, this.strip();\n      }, BN.prototype._wordDiv = function(num, mode) {\n        var shift = this.length - num.length, a = this.clone(), b = num, bhi = b.words[b.length - 1] | 0, bhiBits = this._countBits(bhi);\n        shift = 26 - bhiBits, shift !== 0 && (b = b.ushln(shift), a.iushln(shift), bhi = b.words[b.length - 1] | 0);\n        var m = a.length - b.length, q;\n        if (mode !== \"mod\") {\n          q = new BN(null), q.length = m + 1, q.words = new Array(q.length);\n          for (var i = 0;i < q.length; i++)\n            q.words[i] = 0;\n        }\n        var diff = a.clone()._ishlnsubmul(b, 1, m);\n        diff.negative === 0 && (a = diff, q && (q.words[m] = 1));\n        for (var j = m - 1;j >= 0; j--) {\n          var qj = (a.words[b.length + j] | 0) * 67108864 + (a.words[b.length + j - 1] | 0);\n          for (qj = Math.min(qj / bhi | 0, 67108863), a._ishlnsubmul(b, qj, j);a.negative !== 0; )\n            qj--, a.negative = 0, a._ishlnsubmul(b, 1, j), a.isZero() || (a.negative ^= 1);\n          q && (q.words[j] = qj);\n        }\n        return q && q.strip(), a.strip(), mode !== \"div\" && shift !== 0 && a.iushrn(shift), {\n          div: q || null,\n          mod: a\n        };\n      }, BN.prototype.divmod = function(num, mode, positive) {\n        if (assert(!num.isZero()), this.isZero())\n          return {\n            div: new BN(0),\n            mod: new BN(0)\n          };\n        var div, mod, res;\n        return this.negative !== 0 && num.negative === 0 \? (res = this.neg().divmod(num, mode), mode !== \"mod\" && (div = res.div.neg()), mode !== \"div\" && (mod = res.mod.neg(), positive && mod.negative !== 0 && mod.iadd(num)), {\n          div,\n          mod\n        }) : this.negative === 0 && num.negative !== 0 \? (res = this.divmod(num.neg(), mode), mode !== \"mod\" && (div = res.div.neg()), {\n          div,\n          mod: res.mod\n        }) : (this.negative & num.negative) !== 0 \? (res = this.neg().divmod(num.neg(), mode), mode !== \"div\" && (mod = res.mod.neg(), positive && mod.negative !== 0 && mod.isub(num)), {\n          div: res.div,\n          mod\n        }) : num.length > this.length || this.cmp(num) < 0 \? {\n          div: new BN(0),\n          mod: this\n        } : num.length === 1 \? mode === \"div\" \? {\n          div: this.divn(num.words[0]),\n          mod: null\n        } : mode === \"mod\" \? {\n          div: null,\n          mod: new BN(this.modn(num.words[0]))\n        } : {\n          div: this.divn(num.words[0]),\n          mod: new BN(this.modn(num.words[0]))\n        } : this._wordDiv(num, mode);\n      }, BN.prototype.div = function(num) {\n        return this.divmod(num, \"div\", !1).div;\n      }, BN.prototype.mod = function(num) {\n        return this.divmod(num, \"mod\", !1).mod;\n      }, BN.prototype.umod = function(num) {\n        return this.divmod(num, \"mod\", !0).mod;\n      }, BN.prototype.divRound = function(num) {\n        var dm = this.divmod(num);\n        if (dm.mod.isZero())\n          return dm.div;\n        var mod = dm.div.negative !== 0 \? dm.mod.isub(num) : dm.mod, half = num.ushrn(1), r2 = num.andln(1), cmp = mod.cmp(half);\n        return cmp < 0 || r2 === 1 && cmp === 0 \? dm.div : dm.div.negative !== 0 \? dm.div.isubn(1) : dm.div.iaddn(1);\n      }, BN.prototype.modn = function(num) {\n        assert(num <= 67108863);\n        for (var p = (1 << 26) % num, acc = 0, i = this.length - 1;i >= 0; i--)\n          acc = (p * acc + (this.words[i] | 0)) % num;\n        return acc;\n      }, BN.prototype.idivn = function(num) {\n        assert(num <= 67108863);\n        for (var carry = 0, i = this.length - 1;i >= 0; i--) {\n          var w = (this.words[i] | 0) + carry * 67108864;\n          this.words[i] = w / num | 0, carry = w % num;\n        }\n        return this.strip();\n      }, BN.prototype.divn = function(num) {\n        return this.clone().idivn(num);\n      }, BN.prototype.egcd = function(p) {\n        assert(p.negative === 0), assert(!p.isZero());\n        var x = this, y = p.clone();\n        x.negative !== 0 \? x = x.umod(p) : x = x.clone();\n        for (var A = new BN(1), B = new BN(0), C = new BN(0), D = new BN(1), g = 0;x.isEven() && y.isEven(); )\n          x.iushrn(1), y.iushrn(1), ++g;\n        for (var yp = y.clone(), xp = x.clone();!x.isZero(); ) {\n          for (var i = 0, im = 1;(x.words[0] & im) === 0 && i < 26; ++i, im <<= 1)\n            ;\n          if (i > 0)\n            for (x.iushrn(i);i-- > 0; )\n              (A.isOdd() || B.isOdd()) && (A.iadd(yp), B.isub(xp)), A.iushrn(1), B.iushrn(1);\n          for (var j = 0, jm = 1;(y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)\n            ;\n          if (j > 0)\n            for (y.iushrn(j);j-- > 0; )\n              (C.isOdd() || D.isOdd()) && (C.iadd(yp), D.isub(xp)), C.iushrn(1), D.iushrn(1);\n          x.cmp(y) >= 0 \? (x.isub(y), A.isub(C), B.isub(D)) : (y.isub(x), C.isub(A), D.isub(B));\n        }\n        return {\n          a: C,\n          b: D,\n          gcd: y.iushln(g)\n        };\n      }, BN.prototype._invmp = function(p) {\n        assert(p.negative === 0), assert(!p.isZero());\n        var a = this, b = p.clone();\n        a.negative !== 0 \? a = a.umod(p) : a = a.clone();\n        for (var x1 = new BN(1), x2 = new BN(0), delta = b.clone();a.cmpn(1) > 0 && b.cmpn(1) > 0; ) {\n          for (var i = 0, im = 1;(a.words[0] & im) === 0 && i < 26; ++i, im <<= 1)\n            ;\n          if (i > 0)\n            for (a.iushrn(i);i-- > 0; )\n              x1.isOdd() && x1.iadd(delta), x1.iushrn(1);\n          for (var j = 0, jm = 1;(b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)\n            ;\n          if (j > 0)\n            for (b.iushrn(j);j-- > 0; )\n              x2.isOdd() && x2.iadd(delta), x2.iushrn(1);\n          a.cmp(b) >= 0 \? (a.isub(b), x1.isub(x2)) : (b.isub(a), x2.isub(x1));\n        }\n        var res;\n        return a.cmpn(1) === 0 \? res = x1 : res = x2, res.cmpn(0) < 0 && res.iadd(p), res;\n      }, BN.prototype.gcd = function(num) {\n        if (this.isZero())\n          return num.abs();\n        if (num.isZero())\n          return this.abs();\n        var a = this.clone(), b = num.clone();\n        a.negative = 0, b.negative = 0;\n        for (var shift = 0;a.isEven() && b.isEven(); shift++)\n          a.iushrn(1), b.iushrn(1);\n        do {\n          for (;a.isEven(); )\n            a.iushrn(1);\n          for (;b.isEven(); )\n            b.iushrn(1);\n          var r = a.cmp(b);\n          if (r < 0) {\n            var t = a;\n            a = b, b = t;\n          } else if (r === 0 || b.cmpn(1) === 0)\n            break;\n          a.isub(b);\n        } while (!0);\n        return b.iushln(shift);\n      }, BN.prototype.invm = function(num) {\n        return this.egcd(num).a.umod(num);\n      }, BN.prototype.isEven = function() {\n        return (this.words[0] & 1) === 0;\n      }, BN.prototype.isOdd = function() {\n        return (this.words[0] & 1) === 1;\n      }, BN.prototype.andln = function(num) {\n        return this.words[0] & num;\n      }, BN.prototype.bincn = function(bit) {\n        assert(typeof bit == \"number\");\n        var r = bit % 26, s = (bit - r) / 26, q = 1 << r;\n        if (this.length <= s)\n          return this._expand(s + 1), this.words[s] |= q, this;\n        for (var carry = q, i = s;carry !== 0 && i < this.length; i++) {\n          var w = this.words[i] | 0;\n          w += carry, carry = w >>> 26, w &= 67108863, this.words[i] = w;\n        }\n        return carry !== 0 && (this.words[i] = carry, this.length++), this;\n      }, BN.prototype.isZero = function() {\n        return this.length === 1 && this.words[0] === 0;\n      }, BN.prototype.cmpn = function(num) {\n        var negative = num < 0;\n        if (this.negative !== 0 && !negative)\n          return -1;\n        if (this.negative === 0 && negative)\n          return 1;\n        this.strip();\n        var res;\n        if (this.length > 1)\n          res = 1;\n        else {\n          negative && (num = -num), assert(num <= 67108863, \"Number is too big\");\n          var w = this.words[0] | 0;\n          res = w === num \? 0 : w < num \? -1 : 1;\n        }\n        return this.negative !== 0 \? -res | 0 : res;\n      }, BN.prototype.cmp = function(num) {\n        if (this.negative !== 0 && num.negative === 0)\n          return -1;\n        if (this.negative === 0 && num.negative !== 0)\n          return 1;\n        var res = this.ucmp(num);\n        return this.negative !== 0 \? -res | 0 : res;\n      }, BN.prototype.ucmp = function(num) {\n        if (this.length > num.length)\n          return 1;\n        if (this.length < num.length)\n          return -1;\n        for (var res = 0, i = this.length - 1;i >= 0; i--) {\n          var a = this.words[i] | 0, b = num.words[i] | 0;\n          if (a !== b) {\n            a < b \? res = -1 : a > b && (res = 1);\n            break;\n          }\n        }\n        return res;\n      }, BN.prototype.gtn = function(num) {\n        return this.cmpn(num) === 1;\n      }, BN.prototype.gt = function(num) {\n        return this.cmp(num) === 1;\n      }, BN.prototype.gten = function(num) {\n        return this.cmpn(num) >= 0;\n      }, BN.prototype.gte = function(num) {\n        return this.cmp(num) >= 0;\n      }, BN.prototype.ltn = function(num) {\n        return this.cmpn(num) === -1;\n      }, BN.prototype.lt = function(num) {\n        return this.cmp(num) === -1;\n      }, BN.prototype.lten = function(num) {\n        return this.cmpn(num) <= 0;\n      }, BN.prototype.lte = function(num) {\n        return this.cmp(num) <= 0;\n      }, BN.prototype.eqn = function(num) {\n        return this.cmpn(num) === 0;\n      }, BN.prototype.eq = function(num) {\n        return this.cmp(num) === 0;\n      }, BN.red = function(num) {\n        return new Red(num);\n      }, BN.prototype.toRed = function(ctx) {\n        return assert(!this.red, \"Already a number in reduction context\"), assert(this.negative === 0, \"red works only with positives\"), ctx.convertTo(this)._forceRed(ctx);\n      }, BN.prototype.fromRed = function() {\n        return assert(this.red, \"fromRed works only with numbers in reduction context\"), this.red.convertFrom(this);\n      }, BN.prototype._forceRed = function(ctx) {\n        return this.red = ctx, this;\n      }, BN.prototype.forceRed = function(ctx) {\n        return assert(!this.red, \"Already a number in reduction context\"), this._forceRed(ctx);\n      }, BN.prototype.redAdd = function(num) {\n        return assert(this.red, \"redAdd works only with red numbers\"), this.red.add(this, num);\n      }, BN.prototype.redIAdd = function(num) {\n        return assert(this.red, \"redIAdd works only with red numbers\"), this.red.iadd(this, num);\n      }, BN.prototype.redSub = function(num) {\n        return assert(this.red, \"redSub works only with red numbers\"), this.red.sub(this, num);\n      }, BN.prototype.redISub = function(num) {\n        return assert(this.red, \"redISub works only with red numbers\"), this.red.isub(this, num);\n      }, BN.prototype.redShl = function(num) {\n        return assert(this.red, \"redShl works only with red numbers\"), this.red.shl(this, num);\n      }, BN.prototype.redMul = function(num) {\n        return assert(this.red, \"redMul works only with red numbers\"), this.red._verify2(this, num), this.red.mul(this, num);\n      }, BN.prototype.redIMul = function(num) {\n        return assert(this.red, \"redMul works only with red numbers\"), this.red._verify2(this, num), this.red.imul(this, num);\n      }, BN.prototype.redSqr = function() {\n        return assert(this.red, \"redSqr works only with red numbers\"), this.red._verify1(this), this.red.sqr(this);\n      }, BN.prototype.redISqr = function() {\n        return assert(this.red, \"redISqr works only with red numbers\"), this.red._verify1(this), this.red.isqr(this);\n      }, BN.prototype.redSqrt = function() {\n        return assert(this.red, \"redSqrt works only with red numbers\"), this.red._verify1(this), this.red.sqrt(this);\n      }, BN.prototype.redInvm = function() {\n        return assert(this.red, \"redInvm works only with red numbers\"), this.red._verify1(this), this.red.invm(this);\n      }, BN.prototype.redNeg = function() {\n        return assert(this.red, \"redNeg works only with red numbers\"), this.red._verify1(this), this.red.neg(this);\n      }, BN.prototype.redPow = function(num) {\n        return assert(this.red && !num.red, \"redPow(normalNum)\"), this.red._verify1(this), this.red.pow(this, num);\n      };\n      var primes = {\n        k256: null,\n        p224: null,\n        p192: null,\n        p25519: null\n      };\n      function MPrime(name, p) {\n        this.name = name, this.p = new BN(p, 16), this.n = this.p.bitLength(), this.k = new BN(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();\n      }\n      MPrime.prototype = {}, MPrime.prototype._tmp = function() {\n        var tmp = new BN(null);\n        return tmp.words = new Array(Math.ceil(this.n / 13)), tmp;\n      }, MPrime.prototype.ireduce = function(num) {\n        var r = num, rlen;\n        do\n          this.split(r, this.tmp), r = this.imulK(r), r = r.iadd(this.tmp), rlen = r.bitLength();\n        while (rlen > this.n);\n        var cmp = rlen < this.n \? -1 : r.ucmp(this.p);\n        return cmp === 0 \? (r.words[0] = 0, r.length = 1) : cmp > 0 \? r.isub(this.p) : r.strip !== void 0 \? r.strip() : r._strip(), r;\n      }, MPrime.prototype.split = function(input, out) {\n        input.iushrn(this.n, 0, out);\n      }, MPrime.prototype.imulK = function(num) {\n        return num.imul(this.k);\n      };\n      function K256() {\n        MPrime.call(this, \"k256\", \"ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f\");\n      }\n      inherits(K256, MPrime), K256.prototype.split = function(input, output) {\n        for (var mask = 4194303, outLen = Math.min(input.length, 9), i = 0;i < outLen; i++)\n          output.words[i] = input.words[i];\n        if (output.length = outLen, input.length <= 9) {\n          input.words[0] = 0, input.length = 1;\n          return;\n        }\n        var prev = input.words[9];\n        for (output.words[output.length++] = prev & mask, i = 10;i < input.length; i++) {\n          var next = input.words[i] | 0;\n          input.words[i - 10] = (next & mask) << 4 | prev >>> 22, prev = next;\n        }\n        prev >>>= 22, input.words[i - 10] = prev, prev === 0 && input.length > 10 \? input.length -= 10 : input.length -= 9;\n      }, K256.prototype.imulK = function(num) {\n        num.words[num.length] = 0, num.words[num.length + 1] = 0, num.length += 2;\n        for (var lo = 0, i = 0;i < num.length; i++) {\n          var w = num.words[i] | 0;\n          lo += w * 977, num.words[i] = lo & 67108863, lo = w * 64 + (lo / 67108864 | 0);\n        }\n        return num.words[num.length - 1] === 0 && (num.length--, num.words[num.length - 1] === 0 && num.length--), num;\n      };\n      function P224() {\n        MPrime.call(this, \"p224\", \"ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001\");\n      }\n      inherits(P224, MPrime);\n      function P192() {\n        MPrime.call(this, \"p192\", \"ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff\");\n      }\n      inherits(P192, MPrime);\n      function P25519() {\n        MPrime.call(this, \"25519\", \"7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed\");\n      }\n      inherits(P25519, MPrime), P25519.prototype.imulK = function(num) {\n        for (var carry = 0, i = 0;i < num.length; i++) {\n          var hi = (num.words[i] | 0) * 19 + carry, lo = hi & 67108863;\n          hi >>>= 26, num.words[i] = lo, carry = hi;\n        }\n        return carry !== 0 && (num.words[num.length++] = carry), num;\n      }, BN._prime = function(name) {\n        if (primes[name])\n          return primes[name];\n        var prime2;\n        if (name === \"k256\")\n          prime2 = new K256;\n        else if (name === \"p224\")\n          prime2 = new P224;\n        else if (name === \"p192\")\n          prime2 = new P192;\n        else if (name === \"p25519\")\n          prime2 = new P25519;\n        else\n          throw new Error(\"Unknown prime \" + name);\n        return primes[name] = prime2, prime2;\n      };\n      function Red(m) {\n        if (typeof m == \"string\") {\n          var prime = BN._prime(m);\n          this.m = prime.p, this.prime = prime;\n        } else\n          assert(m.gtn(1), \"modulus must be greater than 1\"), this.m = m, this.prime = null;\n      }\n      Red.prototype = {}, Red.prototype._verify1 = function(a) {\n        assert(a.negative === 0, \"red works only with positives\"), assert(a.red, \"red works only with red numbers\");\n      }, Red.prototype._verify2 = function(a, b) {\n        assert((a.negative | b.negative) === 0, \"red works only with positives\"), assert(a.red && a.red === b.red, \"red works only with red numbers\");\n      }, Red.prototype.imod = function(a) {\n        return this.prime \? this.prime.ireduce(a)._forceRed(this) : a.umod(this.m)._forceRed(this);\n      }, Red.prototype.neg = function(a) {\n        return a.isZero() \? a.clone() : this.m.sub(a)._forceRed(this);\n      }, Red.prototype.add = function(a, b) {\n        this._verify2(a, b);\n        var res = a.add(b);\n        return res.cmp(this.m) >= 0 && res.isub(this.m), res._forceRed(this);\n      }, Red.prototype.iadd = function(a, b) {\n        this._verify2(a, b);\n        var res = a.iadd(b);\n        return res.cmp(this.m) >= 0 && res.isub(this.m), res;\n      }, Red.prototype.sub = function(a, b) {\n        this._verify2(a, b);\n        var res = a.sub(b);\n        return res.cmpn(0) < 0 && res.iadd(this.m), res._forceRed(this);\n      }, Red.prototype.isub = function(a, b) {\n        this._verify2(a, b);\n        var res = a.isub(b);\n        return res.cmpn(0) < 0 && res.iadd(this.m), res;\n      }, Red.prototype.shl = function(a, num) {\n        return this._verify1(a), this.imod(a.ushln(num));\n      }, Red.prototype.imul = function(a, b) {\n        return this._verify2(a, b), this.imod(a.imul(b));\n      }, Red.prototype.mul = function(a, b) {\n        return this._verify2(a, b), this.imod(a.mul(b));\n      }, Red.prototype.isqr = function(a) {\n        return this.imul(a, a.clone());\n      }, Red.prototype.sqr = function(a) {\n        return this.mul(a, a);\n      }, Red.prototype.sqrt = function(a) {\n        if (a.isZero())\n          return a.clone();\n        var mod3 = this.m.andln(3);\n        if (assert(mod3 % 2 === 1), mod3 === 3) {\n          var pow = this.m.add(new BN(1)).iushrn(2);\n          return this.pow(a, pow);\n        }\n        for (var q = this.m.subn(1), s = 0;!q.isZero() && q.andln(1) === 0; )\n          s++, q.iushrn(1);\n        assert(!q.isZero());\n        var one = new BN(1).toRed(this), nOne = one.redNeg(), lpow = this.m.subn(1).iushrn(1), z = this.m.bitLength();\n        for (z = new BN(2 * z * z).toRed(this);this.pow(z, lpow).cmp(nOne) !== 0; )\n          z.redIAdd(nOne);\n        for (var c = this.pow(z, q), r = this.pow(a, q.addn(1).iushrn(1)), t = this.pow(a, q), m = s;t.cmp(one) !== 0; ) {\n          for (var tmp = t, i = 0;tmp.cmp(one) !== 0; i++)\n            tmp = tmp.redSqr();\n          assert(i < m);\n          var b = this.pow(c, new BN(1).iushln(m - i - 1));\n          r = r.redMul(b), c = b.redSqr(), t = t.redMul(c), m = i;\n        }\n        return r;\n      }, Red.prototype.invm = function(a) {\n        var inv = a._invmp(this.m);\n        return inv.negative !== 0 \? (inv.negative = 0, this.imod(inv).redNeg()) : this.imod(inv);\n      }, Red.prototype.pow = function(a, num) {\n        if (num.isZero())\n          return new BN(1).toRed(this);\n        if (num.cmpn(1) === 0)\n          return a.clone();\n        var windowSize = 4, wnd = new Array(1 << windowSize);\n        wnd[0] = new BN(1).toRed(this), wnd[1] = a;\n        for (var i = 2;i < wnd.length; i++)\n          wnd[i] = this.mul(wnd[i - 1], a);\n        var res = wnd[0], current = 0, currentLen = 0, start = num.bitLength() % 26;\n        for (start === 0 && (start = 26), i = num.length - 1;i >= 0; i--) {\n          for (var word = num.words[i], j = start - 1;j >= 0; j--) {\n            var bit = word >> j & 1;\n            if (res !== wnd[0] && (res = this.sqr(res)), bit === 0 && current === 0) {\n              currentLen = 0;\n              continue;\n            }\n            current <<= 1, current |= bit, currentLen++, !(currentLen !== windowSize && (i !== 0 || j !== 0)) && (res = this.mul(res, wnd[current]), currentLen = 0, current = 0);\n          }\n          start = 26;\n        }\n        return res;\n      }, Red.prototype.convertTo = function(num) {\n        var r = num.umod(this.m);\n        return r === num \? r.clone() : r;\n      }, Red.prototype.convertFrom = function(num) {\n        var res = num.clone();\n        return res.red = null, res;\n      }, BN.mont = function(num) {\n        return new Mont(num);\n      };\n      function Mont(m) {\n        Red.call(this, m), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new BN(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);\n      }\n      inherits(Mont, Red), Mont.prototype.convertTo = function(num) {\n        return this.imod(num.ushln(this.shift));\n      }, Mont.prototype.convertFrom = function(num) {\n        var r = this.imod(num.mul(this.rinv));\n        return r.red = null, r;\n      }, Mont.prototype.imul = function(a, b) {\n        if (a.isZero() || b.isZero())\n          return a.words[0] = 0, a.length = 1, a;\n        var t = a.imul(b), c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), u = t.isub(c).iushrn(this.shift), res = u;\n        return u.cmp(this.m) >= 0 \? res = u.isub(this.m) : u.cmpn(0) < 0 && (res = u.iadd(this.m)), res._forceRed(this);\n      }, Mont.prototype.mul = function(a, b) {\n        if (a.isZero() || b.isZero())\n          return new BN(0)._forceRed(this);\n        var t = a.mul(b), c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), u = t.isub(c).iushrn(this.shift), res = u;\n        return u.cmp(this.m) >= 0 \? res = u.isub(this.m) : u.cmpn(0) < 0 && (res = u.iadd(this.m)), res._forceRed(this);\n      }, Mont.prototype.invm = function(a) {\n        var res = this.imod(a._invmp(this.m).mul(this.r2));\n        return res._forceRed(this);\n      };\n    })(typeof module > \"u\" || module, exports);\n  }\n}), require_bn2 = require_bn, require_brorand = __commonJS({\n  \"node_modules/brorand/index.js\"(exports, module) {\n    var r;\n    module.exports = function(len) {\n      return r || (r = new Rand(null)), r.generate(len);\n    };\n    function Rand(rand) {\n      this.rand = rand;\n    }\n    Rand.prototype = {}, module.exports.Rand = Rand, Rand.prototype.generate = function(len) {\n      return this._rand(len);\n    }, Rand.prototype._rand = function(n) {\n      var out = new Buffer(n);\n      return crypto.getRandomValues(out), out;\n    };\n  }\n}), require_mr = __commonJS({\n  \"node_modules/miller-rabin/lib/mr.js\"(exports, module) {\n    var bn = require_bn2(), brorand = require_brorand();\n    function MillerRabin(rand) {\n      this.rand = rand || new brorand.Rand;\n    }\n    module.exports = MillerRabin, MillerRabin.create = function(rand) {\n      return new MillerRabin(rand);\n    }, MillerRabin.prototype = {}, MillerRabin.prototype._randbelow = function(n) {\n      var len = n.bitLength(), min_bytes = Math.ceil(len / 8);\n      do\n        var a = new bn(this.rand.generate(min_bytes));\n      while (a.cmp(n) >= 0);\n      return a;\n    }, MillerRabin.prototype._randrange = function(start, stop) {\n      var size = stop.sub(start);\n      return start.add(this._randbelow(size));\n    }, MillerRabin.prototype.test = function(n, k, cb) {\n      var len = n.bitLength(), red = bn.mont(n), rone = new bn(1).toRed(red);\n      k || (k = Math.max(1, len / 48 | 0));\n      for (var n1 = n.subn(1), s = 0;!n1.testn(s); s++)\n        ;\n      for (var d = n.shrn(s), rn1 = n1.toRed(red), prime = !0;k > 0; k--) {\n        var a = this._randrange(new bn(2), n1);\n        cb && cb(a);\n        var x = a.toRed(red).redPow(d);\n        if (!(x.cmp(rone) === 0 || x.cmp(rn1) === 0)) {\n          for (var i = 1;i < s; i++) {\n            if (x = x.redSqr(), x.cmp(rone) === 0)\n              return !1;\n            if (x.cmp(rn1) === 0)\n              break;\n          }\n          if (i === s)\n            return !1;\n        }\n      }\n      return prime;\n    }, MillerRabin.prototype.getDivisor = function(n, k) {\n      var len = n.bitLength(), red = bn.mont(n), rone = new bn(1).toRed(red);\n      k || (k = Math.max(1, len / 48 | 0));\n      for (var n1 = n.subn(1), s = 0;!n1.testn(s); s++)\n        ;\n      for (var d = n.shrn(s), rn1 = n1.toRed(red);k > 0; k--) {\n        var a = this._randrange(new bn(2), n1), g = n.gcd(a);\n        if (g.cmpn(1) !== 0)\n          return g;\n        var x = a.toRed(red).redPow(d);\n        if (!(x.cmp(rone) === 0 || x.cmp(rn1) === 0)) {\n          for (var i = 1;i < s; i++) {\n            if (x = x.redSqr(), x.cmp(rone) === 0)\n              return x.fromRed().subn(1).gcd(n);\n            if (x.cmp(rn1) === 0)\n              break;\n          }\n          if (i === s)\n            return x = x.redSqr(), x.fromRed().subn(1).gcd(n);\n        }\n      }\n      return !1;\n    };\n  }\n}), require_generatePrime = __commonJS({\n  \"node_modules/diffie-hellman/lib/generatePrime.js\"(exports, module) {\n    var randomBytes = require_browser();\n    module.exports = findPrime, findPrime.simpleSieve = simpleSieve, findPrime.fermatTest = fermatTest;\n    var BN = require_bn(), TWENTYFOUR = new BN(24), MillerRabin = require_mr(), millerRabin = new MillerRabin, ONE = new BN(1), TWO = new BN(2), FIVE = new BN(5), SIXTEEN = new BN(16), EIGHT = new BN(8), TEN = new BN(10), THREE = new BN(3), SEVEN = new BN(7), ELEVEN = new BN(11), FOUR = new BN(4), TWELVE = new BN(12), primes = null;\n    function _getPrimes() {\n      if (primes !== null)\n        return primes;\n      var limit = 1048576, res = [];\n      res[0] = 2;\n      for (var i = 1, k = 3;k < limit; k += 2) {\n        for (var sqrt = Math.ceil(Math.sqrt(k)), j = 0;j < i && res[j] <= sqrt && k % res[j] !== 0; j++)\n          ;\n        i !== j && res[j] <= sqrt || (res[i++] = k);\n      }\n      return primes = res, res;\n    }\n    function simpleSieve(p) {\n      for (var primes2 = _getPrimes(), i = 0;i < primes2.length; i++)\n        if (p.modn(primes2[i]) === 0)\n          return p.cmpn(primes2[i]) === 0;\n      return !0;\n    }\n    function fermatTest(p) {\n      var red = BN.mont(p);\n      return TWO.toRed(red).redPow(p.subn(1)).fromRed().cmpn(1) === 0;\n    }\n    function findPrime(bits, gen) {\n      if (bits < 16)\n        return gen === 2 || gen === 5 \? new BN([140, 123]) : new BN([140, 39]);\n      gen = new BN(gen);\n      for (var num, n2;; ) {\n        for (num = new BN(randomBytes(Math.ceil(bits / 8)));num.bitLength() > bits; )\n          num.ishrn(1);\n        if (num.isEven() && num.iadd(ONE), num.testn(1) || num.iadd(TWO), gen.cmp(TWO)) {\n          if (!gen.cmp(FIVE))\n            for (;num.mod(TEN).cmp(THREE); )\n              num.iadd(FOUR);\n        } else\n          for (;num.mod(TWENTYFOUR).cmp(ELEVEN); )\n            num.iadd(FOUR);\n        if (n2 = num.shrn(1), simpleSieve(n2) && simpleSieve(num) && fermatTest(n2) && fermatTest(num) && millerRabin.test(n2) && millerRabin.test(num))\n          return num;\n      }\n    }\n  }\n}), require_primes = __commonJS({\n  \"node_modules/diffie-hellman/lib/primes.json\"(exports, module) {\n    module.exports = {\n      modp1: {\n        gen: \"02\",\n        prime: \"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a63a3620ffffffffffffffff\"\n      },\n      modp2: {\n        gen: \"02\",\n        prime: \"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece65381ffffffffffffffff\"\n      },\n      modp5: {\n        gen: \"02\",\n        prime: \"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca237327ffffffffffffffff\"\n      },\n      modp14: {\n        gen: \"02\",\n        prime: \"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aacaa68ffffffffffffffff\"\n      },\n      modp15: {\n        gen: \"02\",\n        prime: \"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a93ad2caffffffffffffffff\"\n      },\n      modp16: {\n        gen: \"02\",\n        prime: \"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c934063199ffffffffffffffff\"\n      },\n      modp17: {\n        gen: \"02\",\n        prime: \"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dcc4024ffffffffffffffff\"\n      },\n      modp18: {\n        gen: \"02\",\n        prime: \"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dbe115974a3926f12fee5e438777cb6a932df8cd8bec4d073b931ba3bc832b68d9dd300741fa7bf8afc47ed2576f6936ba424663aab639c5ae4f5683423b4742bf1c978238f16cbe39d652de3fdb8befc848ad922222e04a4037c0713eb57a81a23f0c73473fc646cea306b4bcbc8862f8385ddfa9d4b7fa2c087e879683303ed5bdd3a062b3cf5b3a278a66d2a13f83f44f82ddf310ee074ab6a364597e899a0255dc164f31cc50846851df9ab48195ded7ea1b1d510bd7ee74d73faf36bc31ecfa268359046f4eb879f924009438b481c6cd7889a002ed5ee382bc9190da6fc026e479558e4475677e9aa9e3050e2765694dfc81f56e880b96e7160c980dd98edd3dfffffffffffffffff\"\n      }\n    };\n  }\n}), require_dh = __commonJS({\n  \"node_modules/diffie-hellman/lib/dh.js\"(exports, module) {\n    var BN = require_bn(), MillerRabin = require_mr(), millerRabin = new MillerRabin, TWENTYFOUR = new BN(24), ELEVEN = new BN(11), TEN = new BN(10), THREE = new BN(3), SEVEN = new BN(7), primes = require_generatePrime(), randomBytes = require_browser();\n    module.exports = DH;\n    function setPublicKey(pub, enc) {\n      return enc = enc || \"utf8\", Buffer.isBuffer(pub) || (pub = new Buffer(pub, enc)), this._pub = new BN(pub), this;\n    }\n    function setPrivateKey(priv, enc) {\n      return enc = enc || \"utf8\", Buffer.isBuffer(priv) || (priv = new Buffer(priv, enc)), this._priv = new BN(priv), this;\n    }\n    var primeCache = {};\n    function checkPrime(prime, generator) {\n      var gen = generator.toString(\"hex\"), hex = [gen, prime.toString(16)].join(\"_\");\n      if (hex in primeCache)\n        return primeCache[hex];\n      var error = 0;\n      if (prime.isEven() || !primes.simpleSieve || !primes.fermatTest(prime) || !millerRabin.test(prime))\n        return error += 1, gen === \"02\" || gen === \"05\" \? error += 8 : error += 4, primeCache[hex] = error, error;\n      millerRabin.test(prime.shrn(1)) || (error += 2);\n      var rem;\n      switch (gen) {\n        case \"02\":\n          prime.mod(TWENTYFOUR).cmp(ELEVEN) && (error += 8);\n          break;\n        case \"05\":\n          rem = prime.mod(TEN), rem.cmp(THREE) && rem.cmp(SEVEN) && (error += 8);\n          break;\n        default:\n          error += 4;\n      }\n      return primeCache[hex] = error, error;\n    }\n    function DH(prime, generator, malleable) {\n      this.setGenerator(generator), this.__prime = new BN(prime), this._prime = BN.mont(this.__prime), this._primeLen = prime.length, this._pub = void 0, this._priv = void 0, this._primeCode = void 0, malleable \? (this.setPublicKey = setPublicKey, this.setPrivateKey = setPrivateKey) : this._primeCode = 8;\n    }\n    DH.prototype = {}, Object.defineProperty(DH.prototype, \"verifyError\", {\n      enumerable: !0,\n      get: function() {\n        return typeof this._primeCode != \"number\" && (this._primeCode = checkPrime(this.__prime, this.__gen)), this._primeCode;\n      }\n    }), DH.prototype.generateKeys = function() {\n      return this._priv || (this._priv = new BN(randomBytes(this._primeLen))), this._pub = this._gen.toRed(this._prime).redPow(this._priv).fromRed(), this.getPublicKey();\n    }, DH.prototype.computeSecret = function(other) {\n      other = new BN(other), other = other.toRed(this._prime);\n      var secret = other.redPow(this._priv).fromRed(), out = new Buffer(secret.toArray()), prime = this.getPrime();\n      if (out.length < prime.length) {\n        var front = new Buffer(prime.length - out.length);\n        front.fill(0), out = Buffer.concat([front, out]);\n      }\n      return out;\n    }, DH.prototype.getPublicKey = function(enc) {\n      return formatReturnValue(this._pub, enc);\n    }, DH.prototype.getPrivateKey = function(enc) {\n      return formatReturnValue(this._priv, enc);\n    }, DH.prototype.getPrime = function(enc) {\n      return formatReturnValue(this.__prime, enc);\n    }, DH.prototype.getGenerator = function(enc) {\n      return formatReturnValue(this._gen, enc);\n    }, DH.prototype.setGenerator = function(gen, enc) {\n      return enc = enc || \"utf8\", Buffer.isBuffer(gen) || (gen = new Buffer(gen, enc)), this.__gen = gen, this._gen = new BN(gen), this;\n    };\n    function formatReturnValue(bn, enc) {\n      var buf = new Buffer(bn.toArray());\n      return enc \? buf.toString(enc) : buf;\n    }\n  }\n}), require_browser7 = __commonJS({\n  \"node_modules/diffie-hellman/browser.js\"(exports) {\n    var generatePrime = require_generatePrime(), primes = require_primes(), DH = require_dh();\n    function getDiffieHellman(mod) {\n      var prime = new Buffer(primes[mod].prime, \"hex\"), gen = new Buffer(primes[mod].gen, \"hex\");\n      return new DH(prime, gen);\n    }\n    var ENCODINGS = {\n      binary: !0,\n      hex: !0,\n      base64: !0\n    };\n    function createDiffieHellman(prime, enc, generator, genc) {\n      return Buffer.isBuffer(enc) || ENCODINGS[enc] === void 0 \? createDiffieHellman(prime, \"binary\", enc, generator) : (enc = enc || \"binary\", genc = genc || \"binary\", generator = generator || new Buffer([2]), Buffer.isBuffer(generator) || (generator = new Buffer(generator, genc)), typeof prime == \"number\" \? new DH(generatePrime(prime, generator), generator, !0) : (Buffer.isBuffer(prime) || (prime = new Buffer(prime, enc)), new DH(prime, generator, !0)));\n    }\n    exports.DiffieHellmanGroup = exports.createDiffieHellmanGroup = exports.getDiffieHellman = getDiffieHellman, exports.createDiffieHellman = exports.DiffieHellman = createDiffieHellman;\n  }\n}), require_bn3 = require_bn, require_browserify_rsa = __commonJS({\n  \"node_modules/browserify-rsa/index.js\"(exports, module) {\n    var BN = require_bn3(), randomBytes = require_browser();\n    function blind(priv) {\n      var r = getr(priv), blinder = r.toRed(BN.mont(priv.modulus)).redPow(new BN(priv.publicExponent)).fromRed();\n      return { blinder, unblinder: r.invm(priv.modulus) };\n    }\n    function getr(priv) {\n      var len = priv.modulus.byteLength(), r;\n      do\n        r = new BN(randomBytes(len));\n      while (r.cmp(priv.modulus) >= 0 || !r.umod(priv.prime1) || !r.umod(priv.prime2));\n      return r;\n    }\n    function crt(msg, priv) {\n      var blinds = blind(priv), len = priv.modulus.byteLength(), blinded = new BN(msg).mul(blinds.blinder).umod(priv.modulus), c1 = blinded.toRed(BN.mont(priv.prime1)), c2 = blinded.toRed(BN.mont(priv.prime2)), qinv = priv.coefficient, p = priv.prime1, q = priv.prime2, m1 = c1.redPow(priv.exponent1).fromRed(), m2 = c2.redPow(priv.exponent2).fromRed(), h = m1.isub(m2).imul(qinv).umod(p).imul(q);\n      return m2.iadd(h).imul(blinds.unblinder).umod(priv.modulus).toArrayLike(Buffer, \"be\", len);\n    }\n    crt.getr = getr, module.exports = crt;\n  }\n}), require_package = __commonJS({\n  \"node_modules/elliptic/package.json\"(exports, module) {\n    module.exports = {\n      name: \"elliptic\",\n      version: \"6.5.4\",\n      description: \"EC cryptography\",\n      main: \"lib/elliptic.js\",\n      files: [\"lib\"],\n      scripts: {\n        lint: \"eslint lib test\",\n        \"lint:fix\": \"npm run lint -- --fix\",\n        unit: \"istanbul test _mocha --reporter=spec test/index.js\",\n        test: \"npm run lint && npm run unit\",\n        version: \"grunt dist && git add dist/\"\n      },\n      repository: {\n        type: \"git\",\n        url: \"git@github.com:indutny/elliptic\"\n      },\n      keywords: [\"EC\", \"Elliptic\", \"curve\", \"Cryptography\"],\n      author: \"Fedor Indutny <fedor@indutny.com>\",\n      license: \"MIT\",\n      bugs: {\n        url: \"https://github.com/indutny/elliptic/issues\"\n      },\n      homepage: \"https://github.com/indutny/elliptic\",\n      devDependencies: {\n        brfs: \"^2.0.2\",\n        coveralls: \"^3.1.0\",\n        eslint: \"^7.6.0\",\n        grunt: \"^1.2.1\",\n        \"grunt-browserify\": \"^5.3.0\",\n        \"grunt-cli\": \"^1.3.2\",\n        \"grunt-contrib-connect\": \"^3.0.0\",\n        \"grunt-contrib-copy\": \"^1.0.0\",\n        \"grunt-contrib-uglify\": \"^5.0.0\",\n        \"grunt-mocha-istanbul\": \"^5.0.2\",\n        \"grunt-saucelabs\": \"^9.0.1\",\n        istanbul: \"^0.4.5\",\n        mocha: \"^8.0.1\"\n      },\n      dependencies: {\n        \"bn.js\": \"^4.11.9\",\n        brorand: \"^1.1.0\",\n        \"hash.js\": \"^1.0.0\",\n        \"hmac-drbg\": \"^1.0.1\",\n        inherits: \"^2.0.4\",\n        \"minimalistic-assert\": \"^1.0.1\",\n        \"minimalistic-crypto-utils\": \"^1.0.1\"\n      }\n    };\n  }\n}), require_bn4 = require_bn, require_utils2 = __commonJS({\n  \"node_modules/minimalistic-crypto-utils/lib/utils.js\"(exports) {\n    var utils = exports;\n    function toArray(msg, enc) {\n      if (Array.isArray(msg))\n        return msg.slice();\n      if (!msg)\n        return [];\n      var res = [];\n      if (typeof msg != \"string\") {\n        for (var i = 0;i < msg.length; i++)\n          res[i] = msg[i] | 0;\n        return res;\n      }\n      if (enc === \"hex\") {\n        msg = msg.replace(/[^a-z0-9]+/gi, \"\"), msg.length % 2 !== 0 && (msg = \"0\" + msg);\n        for (var i = 0;i < msg.length; i += 2)\n          res.push(parseInt(msg[i] + msg[i + 1], 16));\n      } else\n        for (var i = 0;i < msg.length; i++) {\n          var c = msg.charCodeAt(i), hi = c >> 8, lo = c & 255;\n          hi \? res.push(hi, lo) : res.push(lo);\n        }\n      return res;\n    }\n    utils.toArray = toArray;\n    function zero2(word) {\n      return word.length === 1 \? \"0\" + word : word;\n    }\n    utils.zero2 = zero2;\n    function toHex(msg) {\n      for (var res = \"\", i = 0;i < msg.length; i++)\n        res += zero2(msg[i].toString(16));\n      return res;\n    }\n    utils.toHex = toHex, utils.encode = function(arr, enc) {\n      return enc === \"hex\" \? toHex(arr) : arr;\n    };\n  }\n}), require_utils3 = __commonJS({\n  \"node_modules/elliptic/lib/elliptic/utils.js\"(exports) {\n    var utils = exports, BN = require_bn4(), minAssert = require_minimalistic_assert(), minUtils = require_utils2();\n    utils.assert = minAssert, utils.toArray = minUtils.toArray, utils.zero2 = minUtils.zero2, utils.toHex = minUtils.toHex, utils.encode = minUtils.encode;\n    function getNAF(num, w, bits) {\n      var naf = new Array(Math.max(num.bitLength(), bits) + 1);\n      naf.fill(0);\n      for (var ws = 1 << w + 1, k = num.clone(), i = 0;i < naf.length; i++) {\n        var z, mod = k.andln(ws - 1);\n        k.isOdd() \? (mod > (ws >> 1) - 1 \? z = (ws >> 1) - mod : z = mod, k.isubn(z)) : z = 0, naf[i] = z, k.iushrn(1);\n      }\n      return naf;\n    }\n    utils.getNAF = getNAF;\n    function getJSF(k1, k2) {\n      var jsf = [[], []];\n      k1 = k1.clone(), k2 = k2.clone();\n      for (var d1 = 0, d2 = 0, m8;k1.cmpn(-d1) > 0 || k2.cmpn(-d2) > 0; ) {\n        var m14 = k1.andln(3) + d1 & 3, m24 = k2.andln(3) + d2 & 3;\n        m14 === 3 && (m14 = -1), m24 === 3 && (m24 = -1);\n        var u1;\n        (m14 & 1) === 0 \? u1 = 0 : (m8 = k1.andln(7) + d1 & 7, (m8 === 3 || m8 === 5) && m24 === 2 \? u1 = -m14 : u1 = m14), jsf[0].push(u1);\n        var u2;\n        (m24 & 1) === 0 \? u2 = 0 : (m8 = k2.andln(7) + d2 & 7, (m8 === 3 || m8 === 5) && m14 === 2 \? u2 = -m24 : u2 = m24), jsf[1].push(u2), 2 * d1 === u1 + 1 && (d1 = 1 - d1), 2 * d2 === u2 + 1 && (d2 = 1 - d2), k1.iushrn(1), k2.iushrn(1);\n      }\n      return jsf;\n    }\n    utils.getJSF = getJSF;\n    function cachedProperty(obj, name, computer) {\n      var key = \"_\" + name;\n      obj.prototype[name] = function() {\n        return this[key] !== void 0 \? this[key] : this[key] = computer.call(this);\n      };\n    }\n    utils.cachedProperty = cachedProperty;\n    function parseBytes(bytes) {\n      return typeof bytes == \"string\" \? utils.toArray(bytes, \"hex\") : bytes;\n    }\n    utils.parseBytes = parseBytes;\n    function intFromLE(bytes) {\n      return new BN(bytes, \"hex\", \"le\");\n    }\n    utils.intFromLE = intFromLE;\n  }\n}), require_base = __commonJS({\n  \"node_modules/elliptic/lib/elliptic/curve/base.js\"(exports, module) {\n    var BN = require_bn4(), utils = require_utils3(), getNAF = utils.getNAF, getJSF = utils.getJSF, assert = utils.assert;\n    function BaseCurve(type, conf) {\n      this.type = type, this.p = new BN(conf.p, 16), this.red = conf.prime \? BN.red(conf.prime) : BN.mont(this.p), this.zero = new BN(0).toRed(this.red), this.one = new BN(1).toRed(this.red), this.two = new BN(2).toRed(this.red), this.n = conf.n && new BN(conf.n, 16), this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed), this._wnafT1 = new Array(4), this._wnafT2 = new Array(4), this._wnafT3 = new Array(4), this._wnafT4 = new Array(4), this._bitLength = this.n \? this.n.bitLength() : 0;\n      var adjustCount = this.n && this.p.div(this.n);\n      !adjustCount || adjustCount.cmpn(100) > 0 \? this.redN = null : (this._maxwellTrick = !0, this.redN = this.n.toRed(this.red));\n    }\n    module.exports = BaseCurve, BaseCurve.prototype = {}, BaseCurve.prototype.point = function() {\n      throw new Error(\"Not implemented\");\n    }, BaseCurve.prototype.validate = function() {\n      throw new Error(\"Not implemented\");\n    }, BaseCurve.prototype._fixedNafMul = function(p, k) {\n      assert(p.precomputed);\n      var doubles = p._getDoubles(), naf = getNAF(k, 1, this._bitLength), I = (1 << doubles.step + 1) - (doubles.step % 2 === 0 \? 2 : 1);\n      I /= 3;\n      var repr = [], j, nafW;\n      for (j = 0;j < naf.length; j += doubles.step) {\n        nafW = 0;\n        for (var l = j + doubles.step - 1;l >= j; l--)\n          nafW = (nafW << 1) + naf[l];\n        repr.push(nafW);\n      }\n      for (var a = this.jpoint(null, null, null), b = this.jpoint(null, null, null), i = I;i > 0; i--) {\n        for (j = 0;j < repr.length; j++)\n          nafW = repr[j], nafW === i \? b = b.mixedAdd(doubles.points[j]) : nafW === -i && (b = b.mixedAdd(doubles.points[j].neg()));\n        a = a.add(b);\n      }\n      return a.toP();\n    }, BaseCurve.prototype._wnafMul = function(p, k) {\n      var w = 4, nafPoints = p._getNAFPoints(w);\n      w = nafPoints.wnd;\n      for (var wnd = nafPoints.points, naf = getNAF(k, w, this._bitLength), acc = this.jpoint(null, null, null), i = naf.length - 1;i >= 0; i--) {\n        for (var l = 0;i >= 0 && naf[i] === 0; i--)\n          l++;\n        if (i >= 0 && l++, acc = acc.dblp(l), i < 0)\n          break;\n        var z = naf[i];\n        assert(z !== 0), p.type === \"affine\" \? z > 0 \? acc = acc.mixedAdd(wnd[z - 1 >> 1]) : acc = acc.mixedAdd(wnd[-z - 1 >> 1].neg()) : z > 0 \? acc = acc.add(wnd[z - 1 >> 1]) : acc = acc.add(wnd[-z - 1 >> 1].neg());\n      }\n      return p.type === \"affine\" \? acc.toP() : acc;\n    }, BaseCurve.prototype._wnafMulAdd = function(defW, points, coeffs, len, jacobianResult) {\n      var wndWidth = this._wnafT1, wnd = this._wnafT2, naf = this._wnafT3, max = 0, i, j, p;\n      for (i = 0;i < len; i++) {\n        p = points[i];\n        var nafPoints = p._getNAFPoints(defW);\n        wndWidth[i] = nafPoints.wnd, wnd[i] = nafPoints.points;\n      }\n      for (i = len - 1;i >= 1; i -= 2) {\n        var a = i - 1, b = i;\n        if (wndWidth[a] !== 1 || wndWidth[b] !== 1) {\n          naf[a] = getNAF(coeffs[a], wndWidth[a], this._bitLength), naf[b] = getNAF(coeffs[b], wndWidth[b], this._bitLength), max = Math.max(naf[a].length, max), max = Math.max(naf[b].length, max);\n          continue;\n        }\n        var comb = [points[a], null, null, points[b]];\n        points[a].y.cmp(points[b].y) === 0 \? (comb[1] = points[a].add(points[b]), comb[2] = points[a].toJ().mixedAdd(points[b].neg())) : points[a].y.cmp(points[b].y.redNeg()) === 0 \? (comb[1] = points[a].toJ().mixedAdd(points[b]), comb[2] = points[a].add(points[b].neg())) : (comb[1] = points[a].toJ().mixedAdd(points[b]), comb[2] = points[a].toJ().mixedAdd(points[b].neg()));\n        var index = [-3, -1, -5, -7, 0, 7, 5, 1, 3], jsf = getJSF(coeffs[a], coeffs[b]);\n        for (max = Math.max(jsf[0].length, max), naf[a] = new Array(max), naf[b] = new Array(max), j = 0;j < max; j++) {\n          var ja = jsf[0][j] | 0, jb = jsf[1][j] | 0;\n          naf[a][j] = index[(ja + 1) * 3 + (jb + 1)], naf[b][j] = 0, wnd[a] = comb;\n        }\n      }\n      var acc = this.jpoint(null, null, null), tmp = this._wnafT4;\n      for (i = max;i >= 0; i--) {\n        for (var k = 0;i >= 0; ) {\n          var zero = !0;\n          for (j = 0;j < len; j++)\n            tmp[j] = naf[j][i] | 0, tmp[j] !== 0 && (zero = !1);\n          if (!zero)\n            break;\n          k++, i--;\n        }\n        if (i >= 0 && k++, acc = acc.dblp(k), i < 0)\n          break;\n        for (j = 0;j < len; j++) {\n          var z = tmp[j];\n          z !== 0 && (z > 0 \? p = wnd[j][z - 1 >> 1] : z < 0 && (p = wnd[j][-z - 1 >> 1].neg()), p.type === \"affine\" \? acc = acc.mixedAdd(p) : acc = acc.add(p));\n        }\n      }\n      for (i = 0;i < len; i++)\n        wnd[i] = null;\n      return jacobianResult \? acc : acc.toP();\n    };\n    function BasePoint(curve, type) {\n      this.curve = curve, this.type = type, this.precomputed = null;\n    }\n    BasePoint.prototype = {}, BaseCurve.BasePoint = BasePoint, BasePoint.prototype.eq = function() {\n      throw new Error(\"Not implemented\");\n    }, BasePoint.prototype.validate = function() {\n      return this.curve.validate(this);\n    }, BaseCurve.prototype.decodePoint = function(bytes, enc) {\n      bytes = utils.toArray(bytes, enc);\n      var len = this.p.byteLength();\n      if ((bytes[0] === 4 || bytes[0] === 6 || bytes[0] === 7) && bytes.length - 1 === 2 * len) {\n        bytes[0] === 6 \? assert(bytes[bytes.length - 1] % 2 === 0) : bytes[0] === 7 && assert(bytes[bytes.length - 1] % 2 === 1);\n        var res = this.point(bytes.slice(1, 1 + len), bytes.slice(1 + len, 1 + 2 * len));\n        return res;\n      } else if ((bytes[0] === 2 || bytes[0] === 3) && bytes.length - 1 === len)\n        return this.pointFromX(bytes.slice(1, 1 + len), bytes[0] === 3);\n      throw new Error(\"Unknown point format\");\n    }, BasePoint.prototype.encodeCompressed = function(enc) {\n      return this.encode(enc, !0);\n    }, BasePoint.prototype._encode = function(compact) {\n      var len = this.curve.p.byteLength(), x = this.getX().toArray(\"be\", len);\n      return compact \? [this.getY().isEven() \? 2 : 3].concat(x) : [4].concat(x, this.getY().toArray(\"be\", len));\n    }, BasePoint.prototype.encode = function(enc, compact) {\n      return utils.encode(this._encode(compact), enc);\n    }, BasePoint.prototype.precompute = function(power) {\n      if (this.precomputed)\n        return this;\n      var precomputed = {\n        doubles: null,\n        naf: null,\n        beta: null\n      };\n      return precomputed.naf = this._getNAFPoints(8), precomputed.doubles = this._getDoubles(4, power), precomputed.beta = this._getBeta(), this.precomputed = precomputed, this;\n    }, BasePoint.prototype._hasDoubles = function(k) {\n      if (!this.precomputed)\n        return !1;\n      var doubles = this.precomputed.doubles;\n      return doubles \? doubles.points.length >= Math.ceil((k.bitLength() + 1) / doubles.step) : !1;\n    }, BasePoint.prototype._getDoubles = function(step, power) {\n      if (this.precomputed && this.precomputed.doubles)\n        return this.precomputed.doubles;\n      for (var doubles = [this], acc = this, i = 0;i < power; i += step) {\n        for (var j = 0;j < step; j++)\n          acc = acc.dbl();\n        doubles.push(acc);\n      }\n      return {\n        step,\n        points: doubles\n      };\n    }, BasePoint.prototype._getNAFPoints = function(wnd) {\n      if (this.precomputed && this.precomputed.naf)\n        return this.precomputed.naf;\n      for (var res = [this], max = (1 << wnd) - 1, dbl = max === 1 \? null : this.dbl(), i = 1;i < max; i++)\n        res[i] = res[i - 1].add(dbl);\n      return {\n        wnd,\n        points: res\n      };\n    }, BasePoint.prototype._getBeta = function() {\n      return null;\n    }, BasePoint.prototype.dblp = function(k) {\n      for (var r = this, i = 0;i < k; i++)\n        r = r.dbl();\n      return r;\n    };\n  }\n}), require_short = __commonJS({\n  \"node_modules/elliptic/lib/elliptic/curve/short.js\"(exports, module) {\n    var utils = require_utils3(), BN = require_bn4(), inherits = require_inherits_browser(), Base = require_base(), assert = utils.assert;\n    function ShortCurve(conf) {\n      Base.call(this, \"short\", conf), this.a = new BN(conf.a, 16).toRed(this.red), this.b = new BN(conf.b, 16).toRed(this.red), this.tinv = this.two.redInvm(), this.zeroA = this.a.fromRed().cmpn(0) === 0, this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0, this.endo = this._getEndomorphism(conf), this._endoWnafT1 = new Array(4), this._endoWnafT2 = new Array(4);\n    }\n    inherits(ShortCurve, Base), module.exports = ShortCurve, ShortCurve.prototype._getEndomorphism = function(conf) {\n      if (!(!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)) {\n        var beta, lambda;\n        if (conf.beta)\n          beta = new BN(conf.beta, 16).toRed(this.red);\n        else {\n          var betas = this._getEndoRoots(this.p);\n          beta = betas[0].cmp(betas[1]) < 0 \? betas[0] : betas[1], beta = beta.toRed(this.red);\n        }\n        if (conf.lambda)\n          lambda = new BN(conf.lambda, 16);\n        else {\n          var lambdas = this._getEndoRoots(this.n);\n          this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0 \? lambda = lambdas[0] : (lambda = lambdas[1], assert(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0));\n        }\n        var basis;\n        return conf.basis \? basis = conf.basis.map(function(vec) {\n          return {\n            a: new BN(vec.a, 16),\n            b: new BN(vec.b, 16)\n          };\n        }) : basis = this._getEndoBasis(lambda), {\n          beta,\n          lambda,\n          basis\n        };\n      }\n    }, ShortCurve.prototype._getEndoRoots = function(num) {\n      var red = num === this.p \? this.red : BN.mont(num), tinv = new BN(2).toRed(red).redInvm(), ntinv = tinv.redNeg(), s = new BN(3).toRed(red).redNeg().redSqrt().redMul(tinv), l1 = ntinv.redAdd(s).fromRed(), l2 = ntinv.redSub(s).fromRed();\n      return [l1, l2];\n    }, ShortCurve.prototype._getEndoBasis = function(lambda) {\n      for (var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2)), u = lambda, v = this.n.clone(), x1 = new BN(1), y1 = new BN(0), x2 = new BN(0), y2 = new BN(1), a0, b0, a1, b1, a2, b2, prevR, i = 0, r, x;u.cmpn(0) !== 0; ) {\n        var q = v.div(u);\n        r = v.sub(q.mul(u)), x = x2.sub(q.mul(x1));\n        var y = y2.sub(q.mul(y1));\n        if (!a1 && r.cmp(aprxSqrt) < 0)\n          a0 = prevR.neg(), b0 = x1, a1 = r.neg(), b1 = x;\n        else if (a1 && ++i === 2)\n          break;\n        prevR = r, v = u, u = r, x2 = x1, x1 = x, y2 = y1, y1 = y;\n      }\n      a2 = r.neg(), b2 = x;\n      var len1 = a1.sqr().add(b1.sqr()), len2 = a2.sqr().add(b2.sqr());\n      return len2.cmp(len1) >= 0 && (a2 = a0, b2 = b0), a1.negative && (a1 = a1.neg(), b1 = b1.neg()), a2.negative && (a2 = a2.neg(), b2 = b2.neg()), [\n        { a: a1, b: b1 },\n        { a: a2, b: b2 }\n      ];\n    }, ShortCurve.prototype._endoSplit = function(k) {\n      var basis = this.endo.basis, v1 = basis[0], v2 = basis[1], c1 = v2.b.mul(k).divRound(this.n), c2 = v1.b.neg().mul(k).divRound(this.n), p1 = c1.mul(v1.a), p2 = c2.mul(v2.a), q1 = c1.mul(v1.b), q2 = c2.mul(v2.b), k1 = k.sub(p1).sub(p2), k2 = q1.add(q2).neg();\n      return { k1, k2 };\n    }, ShortCurve.prototype.pointFromX = function(x, odd) {\n      x = new BN(x, 16), x.red || (x = x.toRed(this.red));\n      var y2 = x.redSqr().redMul(x).redIAdd(x.redMul(this.a)).redIAdd(this.b), y = y2.redSqrt();\n      if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)\n        throw new Error(\"invalid point\");\n      var isOdd = y.fromRed().isOdd();\n      return (odd && !isOdd || !odd && isOdd) && (y = y.redNeg()), this.point(x, y);\n    }, ShortCurve.prototype.validate = function(point) {\n      if (point.inf)\n        return !0;\n      var { x, y } = point, ax = this.a.redMul(x), rhs = x.redSqr().redMul(x).redIAdd(ax).redIAdd(this.b);\n      return y.redSqr().redISub(rhs).cmpn(0) === 0;\n    }, ShortCurve.prototype._endoWnafMulAdd = function(points, coeffs, jacobianResult) {\n      for (var npoints = this._endoWnafT1, ncoeffs = this._endoWnafT2, i = 0;i < points.length; i++) {\n        var split = this._endoSplit(coeffs[i]), p = points[i], beta = p._getBeta();\n        split.k1.negative && (split.k1.ineg(), p = p.neg(!0)), split.k2.negative && (split.k2.ineg(), beta = beta.neg(!0)), npoints[i * 2] = p, npoints[i * 2 + 1] = beta, ncoeffs[i * 2] = split.k1, ncoeffs[i * 2 + 1] = split.k2;\n      }\n      for (var res = this._wnafMulAdd(1, npoints, ncoeffs, i * 2, jacobianResult), j = 0;j < i * 2; j++)\n        npoints[j] = null, ncoeffs[j] = null;\n      return res;\n    };\n    function Point(curve, x, y, isRed) {\n      Base.BasePoint.call(this, curve, \"affine\"), x === null && y === null \? (this.x = null, this.y = null, this.inf = !0) : (this.x = new BN(x, 16), this.y = new BN(y, 16), isRed && (this.x.forceRed(this.curve.red), this.y.forceRed(this.curve.red)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.inf = !1);\n    }\n    inherits(Point, Base.BasePoint), ShortCurve.prototype.point = function(x, y, isRed) {\n      return new Point(this, x, y, isRed);\n    }, ShortCurve.prototype.pointFromJSON = function(obj, red) {\n      return Point.fromJSON(this, obj, red);\n    }, Point.prototype._getBeta = function() {\n      if (this.curve.endo) {\n        var pre = this.precomputed;\n        if (pre && pre.beta)\n          return pre.beta;\n        var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);\n        if (pre) {\n          var curve = this.curve, endoMul = function(p) {\n            return curve.point(p.x.redMul(curve.endo.beta), p.y);\n          };\n          pre.beta = beta, beta.precomputed = {\n            beta: null,\n            naf: pre.naf && {\n              wnd: pre.naf.wnd,\n              points: pre.naf.points.map(endoMul)\n            },\n            doubles: pre.doubles && {\n              step: pre.doubles.step,\n              points: pre.doubles.points.map(endoMul)\n            }\n          };\n        }\n        return beta;\n      }\n    }, Point.prototype.toJSON = function() {\n      return this.precomputed \? [\n        this.x,\n        this.y,\n        this.precomputed && {\n          doubles: this.precomputed.doubles && {\n            step: this.precomputed.doubles.step,\n            points: this.precomputed.doubles.points.slice(1)\n          },\n          naf: this.precomputed.naf && {\n            wnd: this.precomputed.naf.wnd,\n            points: this.precomputed.naf.points.slice(1)\n          }\n        }\n      ] : [this.x, this.y];\n    }, Point.fromJSON = function(curve, obj, red) {\n      typeof obj == \"string\" && (obj = JSON.parse(obj));\n      var res = curve.point(obj[0], obj[1], red);\n      if (!obj[2])\n        return res;\n      function obj2point(obj2) {\n        return curve.point(obj2[0], obj2[1], red);\n      }\n      var pre = obj[2];\n      return res.precomputed = {\n        beta: null,\n        doubles: pre.doubles && {\n          step: pre.doubles.step,\n          points: [res].concat(pre.doubles.points.map(obj2point))\n        },\n        naf: pre.naf && {\n          wnd: pre.naf.wnd,\n          points: [res].concat(pre.naf.points.map(obj2point))\n        }\n      }, res;\n    }, Point.prototype.inspect = function() {\n      return this.isInfinity() \? \"<EC Point Infinity>\" : \"<EC Point x: \" + this.x.fromRed().toString(16, 2) + \" y: \" + this.y.fromRed().toString(16, 2) + \">\";\n    }, Point.prototype.isInfinity = function() {\n      return this.inf;\n    }, Point.prototype.add = function(p) {\n      if (this.inf)\n        return p;\n      if (p.inf)\n        return this;\n      if (this.eq(p))\n        return this.dbl();\n      if (this.neg().eq(p))\n        return this.curve.point(null, null);\n      if (this.x.cmp(p.x) === 0)\n        return this.curve.point(null, null);\n      var c = this.y.redSub(p.y);\n      c.cmpn(0) !== 0 && (c = c.redMul(this.x.redSub(p.x).redInvm()));\n      var nx = c.redSqr().redISub(this.x).redISub(p.x), ny = c.redMul(this.x.redSub(nx)).redISub(this.y);\n      return this.curve.point(nx, ny);\n    }, Point.prototype.dbl = function() {\n      if (this.inf)\n        return this;\n      var ys1 = this.y.redAdd(this.y);\n      if (ys1.cmpn(0) === 0)\n        return this.curve.point(null, null);\n      var a = this.curve.a, x2 = this.x.redSqr(), dyinv = ys1.redInvm(), c = x2.redAdd(x2).redIAdd(x2).redIAdd(a).redMul(dyinv), nx = c.redSqr().redISub(this.x.redAdd(this.x)), ny = c.redMul(this.x.redSub(nx)).redISub(this.y);\n      return this.curve.point(nx, ny);\n    }, Point.prototype.getX = function() {\n      return this.x.fromRed();\n    }, Point.prototype.getY = function() {\n      return this.y.fromRed();\n    }, Point.prototype.mul = function(k) {\n      return k = new BN(k, 16), this.isInfinity() \? this : this._hasDoubles(k) \? this.curve._fixedNafMul(this, k) : this.curve.endo \? this.curve._endoWnafMulAdd([this], [k]) : this.curve._wnafMul(this, k);\n    }, Point.prototype.mulAdd = function(k1, p2, k2) {\n      var points = [this, p2], coeffs = [k1, k2];\n      return this.curve.endo \? this.curve._endoWnafMulAdd(points, coeffs) : this.curve._wnafMulAdd(1, points, coeffs, 2);\n    }, Point.prototype.jmulAdd = function(k1, p2, k2) {\n      var points = [this, p2], coeffs = [k1, k2];\n      return this.curve.endo \? this.curve._endoWnafMulAdd(points, coeffs, !0) : this.curve._wnafMulAdd(1, points, coeffs, 2, !0);\n    }, Point.prototype.eq = function(p) {\n      return this === p || this.inf === p.inf && (this.inf || this.x.cmp(p.x) === 0 && this.y.cmp(p.y) === 0);\n    }, Point.prototype.neg = function(_precompute) {\n      if (this.inf)\n        return this;\n      var res = this.curve.point(this.x, this.y.redNeg());\n      if (_precompute && this.precomputed) {\n        var pre = this.precomputed, negate = function(p) {\n          return p.neg();\n        };\n        res.precomputed = {\n          naf: pre.naf && {\n            wnd: pre.naf.wnd,\n            points: pre.naf.points.map(negate)\n          },\n          doubles: pre.doubles && {\n            step: pre.doubles.step,\n            points: pre.doubles.points.map(negate)\n          }\n        };\n      }\n      return res;\n    }, Point.prototype.toJ = function() {\n      if (this.inf)\n        return this.curve.jpoint(null, null, null);\n      var res = this.curve.jpoint(this.x, this.y, this.curve.one);\n      return res;\n    };\n    function JPoint(curve, x, y, z) {\n      Base.BasePoint.call(this, curve, \"jacobian\"), x === null && y === null && z === null \? (this.x = this.curve.one, this.y = this.curve.one, this.z = new BN(0)) : (this.x = new BN(x, 16), this.y = new BN(y, 16), this.z = new BN(z, 16)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.zOne = this.z === this.curve.one;\n    }\n    inherits(JPoint, Base.BasePoint), ShortCurve.prototype.jpoint = function(x, y, z) {\n      return new JPoint(this, x, y, z);\n    }, JPoint.prototype.toP = function() {\n      if (this.isInfinity())\n        return this.curve.point(null, null);\n      var zinv = this.z.redInvm(), zinv2 = zinv.redSqr(), ax = this.x.redMul(zinv2), ay = this.y.redMul(zinv2).redMul(zinv);\n      return this.curve.point(ax, ay);\n    }, JPoint.prototype.neg = function() {\n      return this.curve.jpoint(this.x, this.y.redNeg(), this.z);\n    }, JPoint.prototype.add = function(p) {\n      if (this.isInfinity())\n        return p;\n      if (p.isInfinity())\n        return this;\n      var pz2 = p.z.redSqr(), z2 = this.z.redSqr(), u1 = this.x.redMul(pz2), u2 = p.x.redMul(z2), s1 = this.y.redMul(pz2.redMul(p.z)), s2 = p.y.redMul(z2.redMul(this.z)), h = u1.redSub(u2), r = s1.redSub(s2);\n      if (h.cmpn(0) === 0)\n        return r.cmpn(0) !== 0 \? this.curve.jpoint(null, null, null) : this.dbl();\n      var h2 = h.redSqr(), h3 = h2.redMul(h), v = u1.redMul(h2), nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v), ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3)), nz = this.z.redMul(p.z).redMul(h);\n      return this.curve.jpoint(nx, ny, nz);\n    }, JPoint.prototype.mixedAdd = function(p) {\n      if (this.isInfinity())\n        return p.toJ();\n      if (p.isInfinity())\n        return this;\n      var z2 = this.z.redSqr(), u1 = this.x, u2 = p.x.redMul(z2), s1 = this.y, s2 = p.y.redMul(z2).redMul(this.z), h = u1.redSub(u2), r = s1.redSub(s2);\n      if (h.cmpn(0) === 0)\n        return r.cmpn(0) !== 0 \? this.curve.jpoint(null, null, null) : this.dbl();\n      var h2 = h.redSqr(), h3 = h2.redMul(h), v = u1.redMul(h2), nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v), ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3)), nz = this.z.redMul(h);\n      return this.curve.jpoint(nx, ny, nz);\n    }, JPoint.prototype.dblp = function(pow) {\n      if (pow === 0)\n        return this;\n      if (this.isInfinity())\n        return this;\n      if (!pow)\n        return this.dbl();\n      var i;\n      if (this.curve.zeroA || this.curve.threeA) {\n        var r = this;\n        for (i = 0;i < pow; i++)\n          r = r.dbl();\n        return r;\n      }\n      var a = this.curve.a, tinv = this.curve.tinv, jx = this.x, jy = this.y, jz = this.z, jz4 = jz.redSqr().redSqr(), jyd = jy.redAdd(jy);\n      for (i = 0;i < pow; i++) {\n        var jx2 = jx.redSqr(), jyd2 = jyd.redSqr(), jyd4 = jyd2.redSqr(), c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4)), t1 = jx.redMul(jyd2), nx = c.redSqr().redISub(t1.redAdd(t1)), t2 = t1.redISub(nx), dny = c.redMul(t2);\n        dny = dny.redIAdd(dny).redISub(jyd4);\n        var nz = jyd.redMul(jz);\n        i + 1 < pow && (jz4 = jz4.redMul(jyd4)), jx = nx, jz = nz, jyd = dny;\n      }\n      return this.curve.jpoint(jx, jyd.redMul(tinv), jz);\n    }, JPoint.prototype.dbl = function() {\n      return this.isInfinity() \? this : this.curve.zeroA \? this._zeroDbl() : this.curve.threeA \? this._threeDbl() : this._dbl();\n    }, JPoint.prototype._zeroDbl = function() {\n      var nx, ny, nz;\n      if (this.zOne) {\n        var xx = this.x.redSqr(), yy = this.y.redSqr(), yyyy = yy.redSqr(), s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);\n        s = s.redIAdd(s);\n        var m = xx.redAdd(xx).redIAdd(xx), t = m.redSqr().redISub(s).redISub(s), yyyy8 = yyyy.redIAdd(yyyy);\n        yyyy8 = yyyy8.redIAdd(yyyy8), yyyy8 = yyyy8.redIAdd(yyyy8), nx = t, ny = m.redMul(s.redISub(t)).redISub(yyyy8), nz = this.y.redAdd(this.y);\n      } else {\n        var a = this.x.redSqr(), b = this.y.redSqr(), c = b.redSqr(), d = this.x.redAdd(b).redSqr().redISub(a).redISub(c);\n        d = d.redIAdd(d);\n        var e = a.redAdd(a).redIAdd(a), f = e.redSqr(), c8 = c.redIAdd(c);\n        c8 = c8.redIAdd(c8), c8 = c8.redIAdd(c8), nx = f.redISub(d).redISub(d), ny = e.redMul(d.redISub(nx)).redISub(c8), nz = this.y.redMul(this.z), nz = nz.redIAdd(nz);\n      }\n      return this.curve.jpoint(nx, ny, nz);\n    }, JPoint.prototype._threeDbl = function() {\n      var nx, ny, nz;\n      if (this.zOne) {\n        var xx = this.x.redSqr(), yy = this.y.redSqr(), yyyy = yy.redSqr(), s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);\n        s = s.redIAdd(s);\n        var m = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a), t = m.redSqr().redISub(s).redISub(s);\n        nx = t;\n        var yyyy8 = yyyy.redIAdd(yyyy);\n        yyyy8 = yyyy8.redIAdd(yyyy8), yyyy8 = yyyy8.redIAdd(yyyy8), ny = m.redMul(s.redISub(t)).redISub(yyyy8), nz = this.y.redAdd(this.y);\n      } else {\n        var delta = this.z.redSqr(), gamma = this.y.redSqr(), beta = this.x.redMul(gamma), alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));\n        alpha = alpha.redAdd(alpha).redIAdd(alpha);\n        var beta4 = beta.redIAdd(beta);\n        beta4 = beta4.redIAdd(beta4);\n        var beta8 = beta4.redAdd(beta4);\n        nx = alpha.redSqr().redISub(beta8), nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);\n        var ggamma8 = gamma.redSqr();\n        ggamma8 = ggamma8.redIAdd(ggamma8), ggamma8 = ggamma8.redIAdd(ggamma8), ggamma8 = ggamma8.redIAdd(ggamma8), ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);\n      }\n      return this.curve.jpoint(nx, ny, nz);\n    }, JPoint.prototype._dbl = function() {\n      var a = this.curve.a, jx = this.x, jy = this.y, jz = this.z, jz4 = jz.redSqr().redSqr(), jx2 = jx.redSqr(), jy2 = jy.redSqr(), c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4)), jxd4 = jx.redAdd(jx);\n      jxd4 = jxd4.redIAdd(jxd4);\n      var t1 = jxd4.redMul(jy2), nx = c.redSqr().redISub(t1.redAdd(t1)), t2 = t1.redISub(nx), jyd8 = jy2.redSqr();\n      jyd8 = jyd8.redIAdd(jyd8), jyd8 = jyd8.redIAdd(jyd8), jyd8 = jyd8.redIAdd(jyd8);\n      var ny = c.redMul(t2).redISub(jyd8), nz = jy.redAdd(jy).redMul(jz);\n      return this.curve.jpoint(nx, ny, nz);\n    }, JPoint.prototype.trpl = function() {\n      if (!this.curve.zeroA)\n        return this.dbl().add(this);\n      var xx = this.x.redSqr(), yy = this.y.redSqr(), zz = this.z.redSqr(), yyyy = yy.redSqr(), m = xx.redAdd(xx).redIAdd(xx), mm = m.redSqr(), e = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);\n      e = e.redIAdd(e), e = e.redAdd(e).redIAdd(e), e = e.redISub(mm);\n      var ee = e.redSqr(), t = yyyy.redIAdd(yyyy);\n      t = t.redIAdd(t), t = t.redIAdd(t), t = t.redIAdd(t);\n      var u = m.redIAdd(e).redSqr().redISub(mm).redISub(ee).redISub(t), yyu4 = yy.redMul(u);\n      yyu4 = yyu4.redIAdd(yyu4), yyu4 = yyu4.redIAdd(yyu4);\n      var nx = this.x.redMul(ee).redISub(yyu4);\n      nx = nx.redIAdd(nx), nx = nx.redIAdd(nx);\n      var ny = this.y.redMul(u.redMul(t.redISub(u)).redISub(e.redMul(ee)));\n      ny = ny.redIAdd(ny), ny = ny.redIAdd(ny), ny = ny.redIAdd(ny);\n      var nz = this.z.redAdd(e).redSqr().redISub(zz).redISub(ee);\n      return this.curve.jpoint(nx, ny, nz);\n    }, JPoint.prototype.mul = function(k, kbase) {\n      return k = new BN(k, kbase), this.curve._wnafMul(this, k);\n    }, JPoint.prototype.eq = function(p) {\n      if (p.type === \"affine\")\n        return this.eq(p.toJ());\n      if (this === p)\n        return !0;\n      var z2 = this.z.redSqr(), pz2 = p.z.redSqr();\n      if (this.x.redMul(pz2).redISub(p.x.redMul(z2)).cmpn(0) !== 0)\n        return !1;\n      var z3 = z2.redMul(this.z), pz3 = pz2.redMul(p.z);\n      return this.y.redMul(pz3).redISub(p.y.redMul(z3)).cmpn(0) === 0;\n    }, JPoint.prototype.eqXToP = function(x) {\n      var zs = this.z.redSqr(), rx = x.toRed(this.curve.red).redMul(zs);\n      if (this.x.cmp(rx) === 0)\n        return !0;\n      for (var xc = x.clone(), t = this.curve.redN.redMul(zs);; ) {\n        if (xc.iadd(this.curve.n), xc.cmp(this.curve.p) >= 0)\n          return !1;\n        if (rx.redIAdd(t), this.x.cmp(rx) === 0)\n          return !0;\n      }\n    }, JPoint.prototype.inspect = function() {\n      return this.isInfinity() \? \"<EC JPoint Infinity>\" : \"<EC JPoint x: \" + this.x.toString(16, 2) + \" y: \" + this.y.toString(16, 2) + \" z: \" + this.z.toString(16, 2) + \">\";\n    }, JPoint.prototype.isInfinity = function() {\n      return this.z.cmpn(0) === 0;\n    };\n  }\n}), require_mont = __commonJS({\n  \"node_modules/elliptic/lib/elliptic/curve/mont.js\"(exports, module) {\n    var BN = require_bn4(), inherits = require_inherits_browser(), Base = require_base(), utils = require_utils3();\n    function MontCurve(conf) {\n      Base.call(this, \"mont\", conf), this.a = new BN(conf.a, 16).toRed(this.red), this.b = new BN(conf.b, 16).toRed(this.red), this.i4 = new BN(4).toRed(this.red).redInvm(), this.two = new BN(2).toRed(this.red), this.a24 = this.i4.redMul(this.a.redAdd(this.two));\n    }\n    inherits(MontCurve, Base), module.exports = MontCurve, MontCurve.prototype.validate = function(point) {\n      var x = point.normalize().x, x2 = x.redSqr(), rhs = x2.redMul(x).redAdd(x2.redMul(this.a)).redAdd(x), y = rhs.redSqrt();\n      return y.redSqr().cmp(rhs) === 0;\n    };\n    function Point(curve, x, z) {\n      Base.BasePoint.call(this, curve, \"projective\"), x === null && z === null \? (this.x = this.curve.one, this.z = this.curve.zero) : (this.x = new BN(x, 16), this.z = new BN(z, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)));\n    }\n    inherits(Point, Base.BasePoint), MontCurve.prototype.decodePoint = function(bytes, enc) {\n      return this.point(utils.toArray(bytes, enc), 1);\n    }, MontCurve.prototype.point = function(x, z) {\n      return new Point(this, x, z);\n    }, MontCurve.prototype.pointFromJSON = function(obj) {\n      return Point.fromJSON(this, obj);\n    }, Point.prototype.precompute = function() {\n    }, Point.prototype._encode = function() {\n      return this.getX().toArray(\"be\", this.curve.p.byteLength());\n    }, Point.fromJSON = function(curve, obj) {\n      return new Point(curve, obj[0], obj[1] || curve.one);\n    }, Point.prototype.inspect = function() {\n      return this.isInfinity() \? \"<EC Point Infinity>\" : \"<EC Point x: \" + this.x.fromRed().toString(16, 2) + \" z: \" + this.z.fromRed().toString(16, 2) + \">\";\n    }, Point.prototype.isInfinity = function() {\n      return this.z.cmpn(0) === 0;\n    }, Point.prototype.dbl = function() {\n      var a = this.x.redAdd(this.z), aa = a.redSqr(), b = this.x.redSub(this.z), bb = b.redSqr(), c = aa.redSub(bb), nx = aa.redMul(bb), nz = c.redMul(bb.redAdd(this.curve.a24.redMul(c)));\n      return this.curve.point(nx, nz);\n    }, Point.prototype.add = function() {\n      throw new Error(\"Not supported on Montgomery curve\");\n    }, Point.prototype.diffAdd = function(p, diff) {\n      var a = this.x.redAdd(this.z), b = this.x.redSub(this.z), c = p.x.redAdd(p.z), d = p.x.redSub(p.z), da = d.redMul(a), cb = c.redMul(b), nx = diff.z.redMul(da.redAdd(cb).redSqr()), nz = diff.x.redMul(da.redISub(cb).redSqr());\n      return this.curve.point(nx, nz);\n    }, Point.prototype.mul = function(k) {\n      for (var t = k.clone(), a = this, b = this.curve.point(null, null), c = this, bits = [];t.cmpn(0) !== 0; t.iushrn(1))\n        bits.push(t.andln(1));\n      for (var i = bits.length - 1;i >= 0; i--)\n        bits[i] === 0 \? (a = a.diffAdd(b, c), b = b.dbl()) : (b = a.diffAdd(b, c), a = a.dbl());\n      return b;\n    }, Point.prototype.mulAdd = function() {\n      throw new Error(\"Not supported on Montgomery curve\");\n    }, Point.prototype.jumlAdd = function() {\n      throw new Error(\"Not supported on Montgomery curve\");\n    }, Point.prototype.eq = function(other) {\n      return this.getX().cmp(other.getX()) === 0;\n    }, Point.prototype.normalize = function() {\n      return this.x = this.x.redMul(this.z.redInvm()), this.z = this.curve.one, this;\n    }, Point.prototype.getX = function() {\n      return this.normalize(), this.x.fromRed();\n    };\n  }\n}), require_edwards = __commonJS({\n  \"node_modules/elliptic/lib/elliptic/curve/edwards.js\"(exports, module) {\n    var utils = require_utils3(), BN = require_bn4(), inherits = require_inherits_browser(), Base = require_base(), assert = utils.assert;\n    function EdwardsCurve(conf) {\n      this.twisted = (conf.a | 0) !== 1, this.mOneA = this.twisted && (conf.a | 0) === -1, this.extended = this.mOneA, Base.call(this, \"edwards\", conf), this.a = new BN(conf.a, 16).umod(this.red.m), this.a = this.a.toRed(this.red), this.c = new BN(conf.c, 16).toRed(this.red), this.c2 = this.c.redSqr(), this.d = new BN(conf.d, 16).toRed(this.red), this.dd = this.d.redAdd(this.d), assert(!this.twisted || this.c.fromRed().cmpn(1) === 0), this.oneC = (conf.c | 0) === 1;\n    }\n    inherits(EdwardsCurve, Base), module.exports = EdwardsCurve, EdwardsCurve.prototype._mulA = function(num) {\n      return this.mOneA \? num.redNeg() : this.a.redMul(num);\n    }, EdwardsCurve.prototype._mulC = function(num) {\n      return this.oneC \? num : this.c.redMul(num);\n    }, EdwardsCurve.prototype.jpoint = function(x, y, z, t) {\n      return this.point(x, y, z, t);\n    }, EdwardsCurve.prototype.pointFromX = function(x, odd) {\n      x = new BN(x, 16), x.red || (x = x.toRed(this.red));\n      var x2 = x.redSqr(), rhs = this.c2.redSub(this.a.redMul(x2)), lhs = this.one.redSub(this.c2.redMul(this.d).redMul(x2)), y2 = rhs.redMul(lhs.redInvm()), y = y2.redSqrt();\n      if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)\n        throw new Error(\"invalid point\");\n      var isOdd = y.fromRed().isOdd();\n      return (odd && !isOdd || !odd && isOdd) && (y = y.redNeg()), this.point(x, y);\n    }, EdwardsCurve.prototype.pointFromY = function(y, odd) {\n      y = new BN(y, 16), y.red || (y = y.toRed(this.red));\n      var y2 = y.redSqr(), lhs = y2.redSub(this.c2), rhs = y2.redMul(this.d).redMul(this.c2).redSub(this.a), x2 = lhs.redMul(rhs.redInvm());\n      if (x2.cmp(this.zero) === 0) {\n        if (odd)\n          throw new Error(\"invalid point\");\n        return this.point(this.zero, y);\n      }\n      var x = x2.redSqrt();\n      if (x.redSqr().redSub(x2).cmp(this.zero) !== 0)\n        throw new Error(\"invalid point\");\n      return x.fromRed().isOdd() !== odd && (x = x.redNeg()), this.point(x, y);\n    }, EdwardsCurve.prototype.validate = function(point) {\n      if (point.isInfinity())\n        return !0;\n      point.normalize();\n      var x2 = point.x.redSqr(), y2 = point.y.redSqr(), lhs = x2.redMul(this.a).redAdd(y2), rhs = this.c2.redMul(this.one.redAdd(this.d.redMul(x2).redMul(y2)));\n      return lhs.cmp(rhs) === 0;\n    };\n    function Point(curve, x, y, z, t) {\n      Base.BasePoint.call(this, curve, \"projective\"), x === null && y === null && z === null \? (this.x = this.curve.zero, this.y = this.curve.one, this.z = this.curve.one, this.t = this.curve.zero, this.zOne = !0) : (this.x = new BN(x, 16), this.y = new BN(y, 16), this.z = z \? new BN(z, 16) : this.curve.one, this.t = t && new BN(t, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.t && !this.t.red && (this.t = this.t.toRed(this.curve.red)), this.zOne = this.z === this.curve.one, this.curve.extended && !this.t && (this.t = this.x.redMul(this.y), this.zOne || (this.t = this.t.redMul(this.z.redInvm()))));\n    }\n    inherits(Point, Base.BasePoint), EdwardsCurve.prototype.pointFromJSON = function(obj) {\n      return Point.fromJSON(this, obj);\n    }, EdwardsCurve.prototype.point = function(x, y, z, t) {\n      return new Point(this, x, y, z, t);\n    }, Point.fromJSON = function(curve, obj) {\n      return new Point(curve, obj[0], obj[1], obj[2]);\n    }, Point.prototype.inspect = function() {\n      return this.isInfinity() \? \"<EC Point Infinity>\" : \"<EC Point x: \" + this.x.fromRed().toString(16, 2) + \" y: \" + this.y.fromRed().toString(16, 2) + \" z: \" + this.z.fromRed().toString(16, 2) + \">\";\n    }, Point.prototype.isInfinity = function() {\n      return this.x.cmpn(0) === 0 && (this.y.cmp(this.z) === 0 || this.zOne && this.y.cmp(this.curve.c) === 0);\n    }, Point.prototype._extDbl = function() {\n      var a = this.x.redSqr(), b = this.y.redSqr(), c = this.z.redSqr();\n      c = c.redIAdd(c);\n      var d = this.curve._mulA(a), e = this.x.redAdd(this.y).redSqr().redISub(a).redISub(b), g = d.redAdd(b), f = g.redSub(c), h = d.redSub(b), nx = e.redMul(f), ny = g.redMul(h), nt = e.redMul(h), nz = f.redMul(g);\n      return this.curve.point(nx, ny, nz, nt);\n    }, Point.prototype._projDbl = function() {\n      var b = this.x.redAdd(this.y).redSqr(), c = this.x.redSqr(), d = this.y.redSqr(), nx, ny, nz, e, h, j;\n      if (this.curve.twisted) {\n        e = this.curve._mulA(c);\n        var f = e.redAdd(d);\n        this.zOne \? (nx = b.redSub(c).redSub(d).redMul(f.redSub(this.curve.two)), ny = f.redMul(e.redSub(d)), nz = f.redSqr().redSub(f).redSub(f)) : (h = this.z.redSqr(), j = f.redSub(h).redISub(h), nx = b.redSub(c).redISub(d).redMul(j), ny = f.redMul(e.redSub(d)), nz = f.redMul(j));\n      } else\n        e = c.redAdd(d), h = this.curve._mulC(this.z).redSqr(), j = e.redSub(h).redSub(h), nx = this.curve._mulC(b.redISub(e)).redMul(j), ny = this.curve._mulC(e).redMul(c.redISub(d)), nz = e.redMul(j);\n      return this.curve.point(nx, ny, nz);\n    }, Point.prototype.dbl = function() {\n      return this.isInfinity() \? this : this.curve.extended \? this._extDbl() : this._projDbl();\n    }, Point.prototype._extAdd = function(p) {\n      var a = this.y.redSub(this.x).redMul(p.y.redSub(p.x)), b = this.y.redAdd(this.x).redMul(p.y.redAdd(p.x)), c = this.t.redMul(this.curve.dd).redMul(p.t), d = this.z.redMul(p.z.redAdd(p.z)), e = b.redSub(a), f = d.redSub(c), g = d.redAdd(c), h = b.redAdd(a), nx = e.redMul(f), ny = g.redMul(h), nt = e.redMul(h), nz = f.redMul(g);\n      return this.curve.point(nx, ny, nz, nt);\n    }, Point.prototype._projAdd = function(p) {\n      var a = this.z.redMul(p.z), b = a.redSqr(), c = this.x.redMul(p.x), d = this.y.redMul(p.y), e = this.curve.d.redMul(c).redMul(d), f = b.redSub(e), g = b.redAdd(e), tmp = this.x.redAdd(this.y).redMul(p.x.redAdd(p.y)).redISub(c).redISub(d), nx = a.redMul(f).redMul(tmp), ny, nz;\n      return this.curve.twisted \? (ny = a.redMul(g).redMul(d.redSub(this.curve._mulA(c))), nz = f.redMul(g)) : (ny = a.redMul(g).redMul(d.redSub(c)), nz = this.curve._mulC(f).redMul(g)), this.curve.point(nx, ny, nz);\n    }, Point.prototype.add = function(p) {\n      return this.isInfinity() \? p : p.isInfinity() \? this : this.curve.extended \? this._extAdd(p) : this._projAdd(p);\n    }, Point.prototype.mul = function(k) {\n      return this._hasDoubles(k) \? this.curve._fixedNafMul(this, k) : this.curve._wnafMul(this, k);\n    }, Point.prototype.mulAdd = function(k1, p, k2) {\n      return this.curve._wnafMulAdd(1, [this, p], [k1, k2], 2, !1);\n    }, Point.prototype.jmulAdd = function(k1, p, k2) {\n      return this.curve._wnafMulAdd(1, [this, p], [k1, k2], 2, !0);\n    }, Point.prototype.normalize = function() {\n      if (this.zOne)\n        return this;\n      var zi = this.z.redInvm();\n      return this.x = this.x.redMul(zi), this.y = this.y.redMul(zi), this.t && (this.t = this.t.redMul(zi)), this.z = this.curve.one, this.zOne = !0, this;\n    }, Point.prototype.neg = function() {\n      return this.curve.point(this.x.redNeg(), this.y, this.z, this.t && this.t.redNeg());\n    }, Point.prototype.getX = function() {\n      return this.normalize(), this.x.fromRed();\n    }, Point.prototype.getY = function() {\n      return this.normalize(), this.y.fromRed();\n    }, Point.prototype.eq = function(other) {\n      return this === other || this.getX().cmp(other.getX()) === 0 && this.getY().cmp(other.getY()) === 0;\n    }, Point.prototype.eqXToP = function(x) {\n      var rx = x.toRed(this.curve.red).redMul(this.z);\n      if (this.x.cmp(rx) === 0)\n        return !0;\n      for (var xc = x.clone(), t = this.curve.redN.redMul(this.z);; ) {\n        if (xc.iadd(this.curve.n), xc.cmp(this.curve.p) >= 0)\n          return !1;\n        if (rx.redIAdd(t), this.x.cmp(rx) === 0)\n          return !0;\n      }\n    }, Point.prototype.toP = Point.prototype.normalize, Point.prototype.mixedAdd = Point.prototype.add;\n  }\n}), require_curve = __commonJS({\n  \"node_modules/elliptic/lib/elliptic/curve/index.js\"(exports) {\n    var curve = exports;\n    curve.base = require_base(), curve.short = require_short(), curve.mont = require_mont(), curve.edwards = require_edwards();\n  }\n}), require_utils4 = __commonJS({\n  \"node_modules/hash.js/lib/hash/utils.js\"(exports) {\n    var assert = require_minimalistic_assert(), inherits = require_inherits_browser();\n    exports.inherits = inherits;\n    function isSurrogatePair(msg, i) {\n      return (msg.charCodeAt(i) & 64512) !== 55296 || i < 0 || i + 1 >= msg.length \? !1 : (msg.charCodeAt(i + 1) & 64512) === 56320;\n    }\n    function toArray(msg, enc) {\n      if (Array.isArray(msg))\n        return msg.slice();\n      if (!msg)\n        return [];\n      var res = [];\n      if (typeof msg == \"string\")\n        if (enc) {\n          if (enc === \"hex\")\n            for (msg = msg.replace(/[^a-z0-9]+/gi, \"\"), msg.length % 2 !== 0 && (msg = \"0\" + msg), i = 0;i < msg.length; i += 2)\n              res.push(parseInt(msg[i] + msg[i + 1], 16));\n        } else\n          for (var p = 0, i = 0;i < msg.length; i++) {\n            var c = msg.charCodeAt(i);\n            c < 128 \? res[p++] = c : c < 2048 \? (res[p++] = c >> 6 | 192, res[p++] = c & 63 | 128) : isSurrogatePair(msg, i) \? (c = 65536 + ((c & 1023) << 10) + (msg.charCodeAt(++i) & 1023), res[p++] = c >> 18 | 240, res[p++] = c >> 12 & 63 | 128, res[p++] = c >> 6 & 63 | 128, res[p++] = c & 63 | 128) : (res[p++] = c >> 12 | 224, res[p++] = c >> 6 & 63 | 128, res[p++] = c & 63 | 128);\n          }\n      else\n        for (i = 0;i < msg.length; i++)\n          res[i] = msg[i] | 0;\n      return res;\n    }\n    exports.toArray = toArray;\n    function toHex(msg) {\n      for (var res = \"\", i = 0;i < msg.length; i++)\n        res += zero2(msg[i].toString(16));\n      return res;\n    }\n    exports.toHex = toHex;\n    function htonl(w) {\n      var res = w >>> 24 | w >>> 8 & 65280 | w << 8 & 16711680 | (w & 255) << 24;\n      return res >>> 0;\n    }\n    exports.htonl = htonl;\n    function toHex32(msg, endian) {\n      for (var res = \"\", i = 0;i < msg.length; i++) {\n        var w = msg[i];\n        endian === \"little\" && (w = htonl(w)), res += zero8(w.toString(16));\n      }\n      return res;\n    }\n    exports.toHex32 = toHex32;\n    function zero2(word) {\n      return word.length === 1 \? \"0\" + word : word;\n    }\n    exports.zero2 = zero2;\n    function zero8(word) {\n      return word.length === 7 \? \"0\" + word : word.length === 6 \? \"00\" + word : word.length === 5 \? \"000\" + word : word.length === 4 \? \"0000\" + word : word.length === 3 \? \"00000\" + word : word.length === 2 \? \"000000\" + word : word.length === 1 \? \"0000000\" + word : word;\n    }\n    exports.zero8 = zero8;\n    function join32(msg, start, end, endian) {\n      var len = end - start;\n      assert(len % 4 === 0);\n      for (var res = new Array(len / 4), i = 0, k = start;i < res.length; i++, k += 4) {\n        var w;\n        endian === \"big\" \? w = msg[k] << 24 | msg[k + 1] << 16 | msg[k + 2] << 8 | msg[k + 3] : w = msg[k + 3] << 24 | msg[k + 2] << 16 | msg[k + 1] << 8 | msg[k], res[i] = w >>> 0;\n      }\n      return res;\n    }\n    exports.join32 = join32;\n    function split32(msg, endian) {\n      for (var res = new Array(msg.length * 4), i = 0, k = 0;i < msg.length; i++, k += 4) {\n        var m = msg[i];\n        endian === \"big\" \? (res[k] = m >>> 24, res[k + 1] = m >>> 16 & 255, res[k + 2] = m >>> 8 & 255, res[k + 3] = m & 255) : (res[k + 3] = m >>> 24, res[k + 2] = m >>> 16 & 255, res[k + 1] = m >>> 8 & 255, res[k] = m & 255);\n      }\n      return res;\n    }\n    exports.split32 = split32;\n    function rotr32(w, b) {\n      return w >>> b | w << 32 - b;\n    }\n    exports.rotr32 = rotr32;\n    function rotl32(w, b) {\n      return w << b | w >>> 32 - b;\n    }\n    exports.rotl32 = rotl32;\n    function sum32(a, b) {\n      return a + b >>> 0;\n    }\n    exports.sum32 = sum32;\n    function sum32_3(a, b, c) {\n      return a + b + c >>> 0;\n    }\n    exports.sum32_3 = sum32_3;\n    function sum32_4(a, b, c, d) {\n      return a + b + c + d >>> 0;\n    }\n    exports.sum32_4 = sum32_4;\n    function sum32_5(a, b, c, d, e) {\n      return a + b + c + d + e >>> 0;\n    }\n    exports.sum32_5 = sum32_5;\n    function sum64(buf, pos, ah, al) {\n      var bh = buf[pos], bl = buf[pos + 1], lo = al + bl >>> 0, hi = (lo < al \? 1 : 0) + ah + bh;\n      buf[pos] = hi >>> 0, buf[pos + 1] = lo;\n    }\n    exports.sum64 = sum64;\n    function sum64_hi(ah, al, bh, bl) {\n      var lo = al + bl >>> 0, hi = (lo < al \? 1 : 0) + ah + bh;\n      return hi >>> 0;\n    }\n    exports.sum64_hi = sum64_hi;\n    function sum64_lo(ah, al, bh, bl) {\n      var lo = al + bl;\n      return lo >>> 0;\n    }\n    exports.sum64_lo = sum64_lo;\n    function sum64_4_hi(ah, al, bh, bl, ch, cl, dh, dl) {\n      var carry = 0, lo = al;\n      lo = lo + bl >>> 0, carry += lo < al \? 1 : 0, lo = lo + cl >>> 0, carry += lo < cl \? 1 : 0, lo = lo + dl >>> 0, carry += lo < dl \? 1 : 0;\n      var hi = ah + bh + ch + dh + carry;\n      return hi >>> 0;\n    }\n    exports.sum64_4_hi = sum64_4_hi;\n    function sum64_4_lo(ah, al, bh, bl, ch, cl, dh, dl) {\n      var lo = al + bl + cl + dl;\n      return lo >>> 0;\n    }\n    exports.sum64_4_lo = sum64_4_lo;\n    function sum64_5_hi(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {\n      var carry = 0, lo = al;\n      lo = lo + bl >>> 0, carry += lo < al \? 1 : 0, lo = lo + cl >>> 0, carry += lo < cl \? 1 : 0, lo = lo + dl >>> 0, carry += lo < dl \? 1 : 0, lo = lo + el >>> 0, carry += lo < el \? 1 : 0;\n      var hi = ah + bh + ch + dh + eh + carry;\n      return hi >>> 0;\n    }\n    exports.sum64_5_hi = sum64_5_hi;\n    function sum64_5_lo(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {\n      var lo = al + bl + cl + dl + el;\n      return lo >>> 0;\n    }\n    exports.sum64_5_lo = sum64_5_lo;\n    function rotr64_hi(ah, al, num) {\n      var r = al << 32 - num | ah >>> num;\n      return r >>> 0;\n    }\n    exports.rotr64_hi = rotr64_hi;\n    function rotr64_lo(ah, al, num) {\n      var r = ah << 32 - num | al >>> num;\n      return r >>> 0;\n    }\n    exports.rotr64_lo = rotr64_lo;\n    function shr64_hi(ah, al, num) {\n      return ah >>> num;\n    }\n    exports.shr64_hi = shr64_hi;\n    function shr64_lo(ah, al, num) {\n      var r = ah << 32 - num | al >>> num;\n      return r >>> 0;\n    }\n    exports.shr64_lo = shr64_lo;\n  }\n}), require_common = __commonJS({\n  \"node_modules/hash.js/lib/hash/common.js\"(exports) {\n    var utils = require_utils4(), assert = require_minimalistic_assert();\n    function BlockHash() {\n      this.pending = null, this.pendingTotal = 0, this.blockSize = this.constructor.blockSize, this.outSize = this.constructor.outSize, this.hmacStrength = this.constructor.hmacStrength, this.padLength = this.constructor.padLength / 8, this.endian = \"big\", this._delta8 = this.blockSize / 8, this._delta32 = this.blockSize / 32;\n    }\n    BlockHash.prototype = {}, exports.BlockHash = BlockHash, BlockHash.prototype.update = function(msg, enc) {\n      if (msg = utils.toArray(msg, enc), this.pending \? this.pending = this.pending.concat(msg) : this.pending = msg, this.pendingTotal += msg.length, this.pending.length >= this._delta8) {\n        msg = this.pending;\n        var r = msg.length % this._delta8;\n        this.pending = msg.slice(msg.length - r, msg.length), this.pending.length === 0 && (this.pending = null), msg = utils.join32(msg, 0, msg.length - r, this.endian);\n        for (var i = 0;i < msg.length; i += this._delta32)\n          this._update(msg, i, i + this._delta32);\n      }\n      return this;\n    }, BlockHash.prototype.digest = function(enc) {\n      return this.update(this._pad()), assert(this.pending === null), this._digest(enc);\n    }, BlockHash.prototype._pad = function() {\n      var len = this.pendingTotal, bytes = this._delta8, k = bytes - (len + this.padLength) % bytes, res = new Array(k + this.padLength);\n      res[0] = 128;\n      for (var i = 1;i < k; i++)\n        res[i] = 0;\n      if (len <<= 3, this.endian === \"big\") {\n        for (var t = 8;t < this.padLength; t++)\n          res[i++] = 0;\n        res[i++] = 0, res[i++] = 0, res[i++] = 0, res[i++] = 0, res[i++] = len >>> 24 & 255, res[i++] = len >>> 16 & 255, res[i++] = len >>> 8 & 255, res[i++] = len & 255;\n      } else\n        for (res[i++] = len & 255, res[i++] = len >>> 8 & 255, res[i++] = len >>> 16 & 255, res[i++] = len >>> 24 & 255, res[i++] = 0, res[i++] = 0, res[i++] = 0, res[i++] = 0, t = 8;t < this.padLength; t++)\n          res[i++] = 0;\n      return res;\n    };\n  }\n}), require_common2 = __commonJS({\n  \"node_modules/hash.js/lib/hash/sha/common.js\"(exports) {\n    var utils = require_utils4(), rotr32 = utils.rotr32;\n    function ft_1(s, x, y, z) {\n      if (s === 0)\n        return ch32(x, y, z);\n      if (s === 1 || s === 3)\n        return p32(x, y, z);\n      if (s === 2)\n        return maj32(x, y, z);\n    }\n    exports.ft_1 = ft_1;\n    function ch32(x, y, z) {\n      return x & y ^ ~x & z;\n    }\n    exports.ch32 = ch32;\n    function maj32(x, y, z) {\n      return x & y ^ x & z ^ y & z;\n    }\n    exports.maj32 = maj32;\n    function p32(x, y, z) {\n      return x ^ y ^ z;\n    }\n    exports.p32 = p32;\n    function s0_256(x) {\n      return rotr32(x, 2) ^ rotr32(x, 13) ^ rotr32(x, 22);\n    }\n    exports.s0_256 = s0_256;\n    function s1_256(x) {\n      return rotr32(x, 6) ^ rotr32(x, 11) ^ rotr32(x, 25);\n    }\n    exports.s1_256 = s1_256;\n    function g0_256(x) {\n      return rotr32(x, 7) ^ rotr32(x, 18) ^ x >>> 3;\n    }\n    exports.g0_256 = g0_256;\n    function g1_256(x) {\n      return rotr32(x, 17) ^ rotr32(x, 19) ^ x >>> 10;\n    }\n    exports.g1_256 = g1_256;\n  }\n}), require__ = __commonJS({\n  \"node_modules/hash.js/lib/hash/sha/1.js\"(exports, module) {\n    var utils = require_utils4(), common = require_common(), shaCommon = require_common2(), rotl32 = utils.rotl32, sum32 = utils.sum32, sum32_5 = utils.sum32_5, ft_1 = shaCommon.ft_1, BlockHash = common.BlockHash, sha1_K = [1518500249, 1859775393, 2400959708, 3395469782];\n    function SHA1() {\n      if (!(this instanceof SHA1))\n        return new SHA1;\n      BlockHash.call(this), this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.W = new Array(80);\n    }\n    utils.inherits(SHA1, BlockHash), module.exports = SHA1, SHA1.blockSize = 512, SHA1.outSize = 160, SHA1.hmacStrength = 80, SHA1.padLength = 64, SHA1.prototype._update = function(msg, start) {\n      for (var W = this.W, i = 0;i < 16; i++)\n        W[i] = msg[start + i];\n      for (;i < W.length; i++)\n        W[i] = rotl32(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16], 1);\n      var a = this.h[0], b = this.h[1], c = this.h[2], d = this.h[3], e = this.h[4];\n      for (i = 0;i < W.length; i++) {\n        var s = ~~(i / 20), t = sum32_5(rotl32(a, 5), ft_1(s, b, c, d), e, W[i], sha1_K[s]);\n        e = d, d = c, c = rotl32(b, 30), b = a, a = t;\n      }\n      this.h[0] = sum32(this.h[0], a), this.h[1] = sum32(this.h[1], b), this.h[2] = sum32(this.h[2], c), this.h[3] = sum32(this.h[3], d), this.h[4] = sum32(this.h[4], e);\n    }, SHA1.prototype._digest = function(enc) {\n      return enc === \"hex\" \? utils.toHex32(this.h, \"big\") : utils.split32(this.h, \"big\");\n    };\n  }\n}), require__2 = __commonJS({\n  \"node_modules/hash.js/lib/hash/sha/256.js\"(exports, module) {\n    var utils = require_utils4(), common = require_common(), shaCommon = require_common2(), assert = require_minimalistic_assert(), sum32 = utils.sum32, sum32_4 = utils.sum32_4, sum32_5 = utils.sum32_5, ch32 = shaCommon.ch32, maj32 = shaCommon.maj32, s0_256 = shaCommon.s0_256, s1_256 = shaCommon.s1_256, g0_256 = shaCommon.g0_256, g1_256 = shaCommon.g1_256, BlockHash = common.BlockHash, sha256_K = [\n      1116352408,\n      1899447441,\n      3049323471,\n      3921009573,\n      961987163,\n      1508970993,\n      2453635748,\n      2870763221,\n      3624381080,\n      310598401,\n      607225278,\n      1426881987,\n      1925078388,\n      2162078206,\n      2614888103,\n      3248222580,\n      3835390401,\n      4022224774,\n      264347078,\n      604807628,\n      770255983,\n      1249150122,\n      1555081692,\n      1996064986,\n      2554220882,\n      2821834349,\n      2952996808,\n      3210313671,\n      3336571891,\n      3584528711,\n      113926993,\n      338241895,\n      666307205,\n      773529912,\n      1294757372,\n      1396182291,\n      1695183700,\n      1986661051,\n      2177026350,\n      2456956037,\n      2730485921,\n      2820302411,\n      3259730800,\n      3345764771,\n      3516065817,\n      3600352804,\n      4094571909,\n      275423344,\n      430227734,\n      506948616,\n      659060556,\n      883997877,\n      958139571,\n      1322822218,\n      1537002063,\n      1747873779,\n      1955562222,\n      2024104815,\n      2227730452,\n      2361852424,\n      2428436474,\n      2756734187,\n      3204031479,\n      3329325298\n    ];\n    function SHA256() {\n      if (!(this instanceof SHA256))\n        return new SHA256;\n      BlockHash.call(this), this.h = [1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225], this.k = sha256_K, this.W = new Array(64);\n    }\n    utils.inherits(SHA256, BlockHash), module.exports = SHA256, SHA256.blockSize = 512, SHA256.outSize = 256, SHA256.hmacStrength = 192, SHA256.padLength = 64, SHA256.prototype._update = function(msg, start) {\n      for (var W = this.W, i = 0;i < 16; i++)\n        W[i] = msg[start + i];\n      for (;i < W.length; i++)\n        W[i] = sum32_4(g1_256(W[i - 2]), W[i - 7], g0_256(W[i - 15]), W[i - 16]);\n      var a = this.h[0], b = this.h[1], c = this.h[2], d = this.h[3], e = this.h[4], f = this.h[5], g = this.h[6], h = this.h[7];\n      for (assert(this.k.length === W.length), i = 0;i < W.length; i++) {\n        var T1 = sum32_5(h, s1_256(e), ch32(e, f, g), this.k[i], W[i]), T2 = sum32(s0_256(a), maj32(a, b, c));\n        h = g, g = f, f = e, e = sum32(d, T1), d = c, c = b, b = a, a = sum32(T1, T2);\n      }\n      this.h[0] = sum32(this.h[0], a), this.h[1] = sum32(this.h[1], b), this.h[2] = sum32(this.h[2], c), this.h[3] = sum32(this.h[3], d), this.h[4] = sum32(this.h[4], e), this.h[5] = sum32(this.h[5], f), this.h[6] = sum32(this.h[6], g), this.h[7] = sum32(this.h[7], h);\n    }, SHA256.prototype._digest = function(enc) {\n      return enc === \"hex\" \? utils.toHex32(this.h, \"big\") : utils.split32(this.h, \"big\");\n    };\n  }\n}), require__3 = __commonJS({\n  \"node_modules/hash.js/lib/hash/sha/224.js\"(exports, module) {\n    var utils = require_utils4(), SHA256 = require__2();\n    function SHA224() {\n      if (!(this instanceof SHA224))\n        return new SHA224;\n      SHA256.call(this), this.h = [3238371032, 914150663, 812702999, 4144912697, 4290775857, 1750603025, 1694076839, 3204075428];\n    }\n    utils.inherits(SHA224, SHA256), module.exports = SHA224, SHA224.blockSize = 512, SHA224.outSize = 224, SHA224.hmacStrength = 192, SHA224.padLength = 64, SHA224.prototype._digest = function(enc) {\n      return enc === \"hex\" \? utils.toHex32(this.h.slice(0, 7), \"big\") : utils.split32(this.h.slice(0, 7), \"big\");\n    };\n  }\n}), require__4 = __commonJS({\n  \"node_modules/hash.js/lib/hash/sha/512.js\"(exports, module) {\n    var utils = require_utils4(), common = require_common(), assert = require_minimalistic_assert(), rotr64_hi = utils.rotr64_hi, rotr64_lo = utils.rotr64_lo, shr64_hi = utils.shr64_hi, shr64_lo = utils.shr64_lo, sum64 = utils.sum64, sum64_hi = utils.sum64_hi, sum64_lo = utils.sum64_lo, sum64_4_hi = utils.sum64_4_hi, sum64_4_lo = utils.sum64_4_lo, sum64_5_hi = utils.sum64_5_hi, sum64_5_lo = utils.sum64_5_lo, BlockHash = common.BlockHash, sha512_K = [\n      1116352408,\n      3609767458,\n      1899447441,\n      602891725,\n      3049323471,\n      3964484399,\n      3921009573,\n      2173295548,\n      961987163,\n      4081628472,\n      1508970993,\n      3053834265,\n      2453635748,\n      2937671579,\n      2870763221,\n      3664609560,\n      3624381080,\n      2734883394,\n      310598401,\n      1164996542,\n      607225278,\n      1323610764,\n      1426881987,\n      3590304994,\n      1925078388,\n      4068182383,\n      2162078206,\n      991336113,\n      2614888103,\n      633803317,\n      3248222580,\n      3479774868,\n      3835390401,\n      2666613458,\n      4022224774,\n      944711139,\n      264347078,\n      2341262773,\n      604807628,\n      2007800933,\n      770255983,\n      1495990901,\n      1249150122,\n      1856431235,\n      1555081692,\n      3175218132,\n      1996064986,\n      2198950837,\n      2554220882,\n      3999719339,\n      2821834349,\n      766784016,\n      2952996808,\n      2566594879,\n      3210313671,\n      3203337956,\n      3336571891,\n      1034457026,\n      3584528711,\n      2466948901,\n      113926993,\n      3758326383,\n      338241895,\n      168717936,\n      666307205,\n      1188179964,\n      773529912,\n      1546045734,\n      1294757372,\n      1522805485,\n      1396182291,\n      2643833823,\n      1695183700,\n      2343527390,\n      1986661051,\n      1014477480,\n      2177026350,\n      1206759142,\n      2456956037,\n      344077627,\n      2730485921,\n      1290863460,\n      2820302411,\n      3158454273,\n      3259730800,\n      3505952657,\n      3345764771,\n      106217008,\n      3516065817,\n      3606008344,\n      3600352804,\n      1432725776,\n      4094571909,\n      1467031594,\n      275423344,\n      851169720,\n      430227734,\n      3100823752,\n      506948616,\n      1363258195,\n      659060556,\n      3750685593,\n      883997877,\n      3785050280,\n      958139571,\n      3318307427,\n      1322822218,\n      3812723403,\n      1537002063,\n      2003034995,\n      1747873779,\n      3602036899,\n      1955562222,\n      1575990012,\n      2024104815,\n      1125592928,\n      2227730452,\n      2716904306,\n      2361852424,\n      442776044,\n      2428436474,\n      593698344,\n      2756734187,\n      3733110249,\n      3204031479,\n      2999351573,\n      3329325298,\n      3815920427,\n      3391569614,\n      3928383900,\n      3515267271,\n      566280711,\n      3940187606,\n      3454069534,\n      4118630271,\n      4000239992,\n      116418474,\n      1914138554,\n      174292421,\n      2731055270,\n      289380356,\n      3203993006,\n      460393269,\n      320620315,\n      685471733,\n      587496836,\n      852142971,\n      1086792851,\n      1017036298,\n      365543100,\n      1126000580,\n      2618297676,\n      1288033470,\n      3409855158,\n      1501505948,\n      4234509866,\n      1607167915,\n      987167468,\n      1816402316,\n      1246189591\n    ];\n    function SHA512() {\n      if (!(this instanceof SHA512))\n        return new SHA512;\n      BlockHash.call(this), this.h = [\n        1779033703,\n        4089235720,\n        3144134277,\n        2227873595,\n        1013904242,\n        4271175723,\n        2773480762,\n        1595750129,\n        1359893119,\n        2917565137,\n        2600822924,\n        725511199,\n        528734635,\n        4215389547,\n        1541459225,\n        327033209\n      ], this.k = sha512_K, this.W = new Array(160);\n    }\n    utils.inherits(SHA512, BlockHash), module.exports = SHA512, SHA512.blockSize = 1024, SHA512.outSize = 512, SHA512.hmacStrength = 192, SHA512.padLength = 128, SHA512.prototype._prepareBlock = function(msg, start) {\n      for (var W = this.W, i = 0;i < 32; i++)\n        W[i] = msg[start + i];\n      for (;i < W.length; i += 2) {\n        var c0_hi = g1_512_hi(W[i - 4], W[i - 3]), c0_lo = g1_512_lo(W[i - 4], W[i - 3]), c1_hi = W[i - 14], c1_lo = W[i - 13], c2_hi = g0_512_hi(W[i - 30], W[i - 29]), c2_lo = g0_512_lo(W[i - 30], W[i - 29]), c3_hi = W[i - 32], c3_lo = W[i - 31];\n        W[i] = sum64_4_hi(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo), W[i + 1] = sum64_4_lo(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo);\n      }\n    }, SHA512.prototype._update = function(msg, start) {\n      this._prepareBlock(msg, start);\n      var W = this.W, ah = this.h[0], al = this.h[1], bh = this.h[2], bl = this.h[3], ch = this.h[4], cl = this.h[5], dh = this.h[6], dl = this.h[7], eh = this.h[8], el = this.h[9], fh = this.h[10], fl = this.h[11], gh = this.h[12], gl = this.h[13], hh = this.h[14], hl = this.h[15];\n      assert(this.k.length === W.length);\n      for (var i = 0;i < W.length; i += 2) {\n        var c0_hi = hh, c0_lo = hl, c1_hi = s1_512_hi(eh, el), c1_lo = s1_512_lo(eh, el), c2_hi = ch64_hi(eh, el, fh, fl, gh, gl), c2_lo = ch64_lo(eh, el, fh, fl, gh, gl), c3_hi = this.k[i], c3_lo = this.k[i + 1], c4_hi = W[i], c4_lo = W[i + 1], T1_hi = sum64_5_hi(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo, c4_hi, c4_lo), T1_lo = sum64_5_lo(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo, c4_hi, c4_lo);\n        c0_hi = s0_512_hi(ah, al), c0_lo = s0_512_lo(ah, al), c1_hi = maj64_hi(ah, al, bh, bl, ch, cl), c1_lo = maj64_lo(ah, al, bh, bl, ch, cl);\n        var T2_hi = sum64_hi(c0_hi, c0_lo, c1_hi, c1_lo), T2_lo = sum64_lo(c0_hi, c0_lo, c1_hi, c1_lo);\n        hh = gh, hl = gl, gh = fh, gl = fl, fh = eh, fl = el, eh = sum64_hi(dh, dl, T1_hi, T1_lo), el = sum64_lo(dl, dl, T1_hi, T1_lo), dh = ch, dl = cl, ch = bh, cl = bl, bh = ah, bl = al, ah = sum64_hi(T1_hi, T1_lo, T2_hi, T2_lo), al = sum64_lo(T1_hi, T1_lo, T2_hi, T2_lo);\n      }\n      sum64(this.h, 0, ah, al), sum64(this.h, 2, bh, bl), sum64(this.h, 4, ch, cl), sum64(this.h, 6, dh, dl), sum64(this.h, 8, eh, el), sum64(this.h, 10, fh, fl), sum64(this.h, 12, gh, gl), sum64(this.h, 14, hh, hl);\n    }, SHA512.prototype._digest = function(enc) {\n      return enc === \"hex\" \? utils.toHex32(this.h, \"big\") : utils.split32(this.h, \"big\");\n    };\n    function ch64_hi(xh, xl, yh, yl, zh) {\n      var r = xh & yh ^ ~xh & zh;\n      return r < 0 && (r += 4294967296), r;\n    }\n    function ch64_lo(xh, xl, yh, yl, zh, zl) {\n      var r = xl & yl ^ ~xl & zl;\n      return r < 0 && (r += 4294967296), r;\n    }\n    function maj64_hi(xh, xl, yh, yl, zh) {\n      var r = xh & yh ^ xh & zh ^ yh & zh;\n      return r < 0 && (r += 4294967296), r;\n    }\n    function maj64_lo(xh, xl, yh, yl, zh, zl) {\n      var r = xl & yl ^ xl & zl ^ yl & zl;\n      return r < 0 && (r += 4294967296), r;\n    }\n    function s0_512_hi(xh, xl) {\n      var c0_hi = rotr64_hi(xh, xl, 28), c1_hi = rotr64_hi(xl, xh, 2), c2_hi = rotr64_hi(xl, xh, 7), r = c0_hi ^ c1_hi ^ c2_hi;\n      return r < 0 && (r += 4294967296), r;\n    }\n    function s0_512_lo(xh, xl) {\n      var c0_lo = rotr64_lo(xh, xl, 28), c1_lo = rotr64_lo(xl, xh, 2), c2_lo = rotr64_lo(xl, xh, 7), r = c0_lo ^ c1_lo ^ c2_lo;\n      return r < 0 && (r += 4294967296), r;\n    }\n    function s1_512_hi(xh, xl) {\n      var c0_hi = rotr64_hi(xh, xl, 14), c1_hi = rotr64_hi(xh, xl, 18), c2_hi = rotr64_hi(xl, xh, 9), r = c0_hi ^ c1_hi ^ c2_hi;\n      return r < 0 && (r += 4294967296), r;\n    }\n    function s1_512_lo(xh, xl) {\n      var c0_lo = rotr64_lo(xh, xl, 14), c1_lo = rotr64_lo(xh, xl, 18), c2_lo = rotr64_lo(xl, xh, 9), r = c0_lo ^ c1_lo ^ c2_lo;\n      return r < 0 && (r += 4294967296), r;\n    }\n    function g0_512_hi(xh, xl) {\n      var c0_hi = rotr64_hi(xh, xl, 1), c1_hi = rotr64_hi(xh, xl, 8), c2_hi = shr64_hi(xh, xl, 7), r = c0_hi ^ c1_hi ^ c2_hi;\n      return r < 0 && (r += 4294967296), r;\n    }\n    function g0_512_lo(xh, xl) {\n      var c0_lo = rotr64_lo(xh, xl, 1), c1_lo = rotr64_lo(xh, xl, 8), c2_lo = shr64_lo(xh, xl, 7), r = c0_lo ^ c1_lo ^ c2_lo;\n      return r < 0 && (r += 4294967296), r;\n    }\n    function g1_512_hi(xh, xl) {\n      var c0_hi = rotr64_hi(xh, xl, 19), c1_hi = rotr64_hi(xl, xh, 29), c2_hi = shr64_hi(xh, xl, 6), r = c0_hi ^ c1_hi ^ c2_hi;\n      return r < 0 && (r += 4294967296), r;\n    }\n    function g1_512_lo(xh, xl) {\n      var c0_lo = rotr64_lo(xh, xl, 19), c1_lo = rotr64_lo(xl, xh, 29), c2_lo = shr64_lo(xh, xl, 6), r = c0_lo ^ c1_lo ^ c2_lo;\n      return r < 0 && (r += 4294967296), r;\n    }\n  }\n}), require__5 = __commonJS({\n  \"node_modules/hash.js/lib/hash/sha/384.js\"(exports, module) {\n    var utils = require_utils4(), SHA512 = require__4();\n    function SHA384() {\n      if (!(this instanceof SHA384))\n        return new SHA384;\n      SHA512.call(this), this.h = [\n        3418070365,\n        3238371032,\n        1654270250,\n        914150663,\n        2438529370,\n        812702999,\n        355462360,\n        4144912697,\n        1731405415,\n        4290775857,\n        2394180231,\n        1750603025,\n        3675008525,\n        1694076839,\n        1203062813,\n        3204075428\n      ];\n    }\n    utils.inherits(SHA384, SHA512), module.exports = SHA384, SHA384.blockSize = 1024, SHA384.outSize = 384, SHA384.hmacStrength = 192, SHA384.padLength = 128, SHA384.prototype._digest = function(enc) {\n      return enc === \"hex\" \? utils.toHex32(this.h.slice(0, 12), \"big\") : utils.split32(this.h.slice(0, 12), \"big\");\n    };\n  }\n}), require_sha3 = __commonJS({\n  \"node_modules/hash.js/lib/hash/sha.js\"(exports) {\n    exports.sha1 = require__(), exports.sha224 = require__3(), exports.sha256 = require__2(), exports.sha384 = require__5(), exports.sha512 = require__4();\n  }\n}), require_ripemd = __commonJS({\n  \"node_modules/hash.js/lib/hash/ripemd.js\"(exports) {\n    var utils = require_utils4(), common = require_common(), rotl32 = utils.rotl32, sum32 = utils.sum32, sum32_3 = utils.sum32_3, sum32_4 = utils.sum32_4, BlockHash = common.BlockHash;\n    function RIPEMD160() {\n      if (!(this instanceof RIPEMD160))\n        return new RIPEMD160;\n      BlockHash.call(this), this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.endian = \"little\";\n    }\n    utils.inherits(RIPEMD160, BlockHash), exports.ripemd160 = RIPEMD160, RIPEMD160.blockSize = 512, RIPEMD160.outSize = 160, RIPEMD160.hmacStrength = 192, RIPEMD160.padLength = 64, RIPEMD160.prototype._update = function(msg, start) {\n      for (var A = this.h[0], B = this.h[1], C = this.h[2], D = this.h[3], E = this.h[4], Ah = A, Bh = B, Ch = C, Dh = D, Eh = E, j = 0;j < 80; j++) {\n        var T = sum32(rotl32(sum32_4(A, f(j, B, C, D), msg[r[j] + start], K(j)), s[j]), E);\n        A = E, E = D, D = rotl32(C, 10), C = B, B = T, T = sum32(rotl32(sum32_4(Ah, f(79 - j, Bh, Ch, Dh), msg[rh[j] + start], Kh(j)), sh[j]), Eh), Ah = Eh, Eh = Dh, Dh = rotl32(Ch, 10), Ch = Bh, Bh = T;\n      }\n      T = sum32_3(this.h[1], C, Dh), this.h[1] = sum32_3(this.h[2], D, Eh), this.h[2] = sum32_3(this.h[3], E, Ah), this.h[3] = sum32_3(this.h[4], A, Bh), this.h[4] = sum32_3(this.h[0], B, Ch), this.h[0] = T;\n    }, RIPEMD160.prototype._digest = function(enc) {\n      return enc === \"hex\" \? utils.toHex32(this.h, \"little\") : utils.split32(this.h, \"little\");\n    };\n    function f(j, x, y, z) {\n      return j <= 15 \? x ^ y ^ z : j <= 31 \? x & y | ~x & z : j <= 47 \? (x | ~y) ^ z : j <= 63 \? x & z | y & ~z : x ^ (y | ~z);\n    }\n    function K(j) {\n      return j <= 15 \? 0 : j <= 31 \? 1518500249 : j <= 47 \? 1859775393 : j <= 63 \? 2400959708 : 2840853838;\n    }\n    function Kh(j) {\n      return j <= 15 \? 1352829926 : j <= 31 \? 1548603684 : j <= 47 \? 1836072691 : j <= 63 \? 2053994217 : 0;\n    }\n    var r = [\n      0,\n      1,\n      2,\n      3,\n      4,\n      5,\n      6,\n      7,\n      8,\n      9,\n      10,\n      11,\n      12,\n      13,\n      14,\n      15,\n      7,\n      4,\n      13,\n      1,\n      10,\n      6,\n      15,\n      3,\n      12,\n      0,\n      9,\n      5,\n      2,\n      14,\n      11,\n      8,\n      3,\n      10,\n      14,\n      4,\n      9,\n      15,\n      8,\n      1,\n      2,\n      7,\n      0,\n      6,\n      13,\n      11,\n      5,\n      12,\n      1,\n      9,\n      11,\n      10,\n      0,\n      8,\n      12,\n      4,\n      13,\n      3,\n      7,\n      15,\n      14,\n      5,\n      6,\n      2,\n      4,\n      0,\n      5,\n      9,\n      7,\n      12,\n      2,\n      10,\n      14,\n      1,\n      3,\n      8,\n      11,\n      6,\n      15,\n      13\n    ], rh = [\n      5,\n      14,\n      7,\n      0,\n      9,\n      2,\n      11,\n      4,\n      13,\n      6,\n      15,\n      8,\n      1,\n      10,\n      3,\n      12,\n      6,\n      11,\n      3,\n      7,\n      0,\n      13,\n      5,\n      10,\n      14,\n      15,\n      8,\n      12,\n      4,\n      9,\n      1,\n      2,\n      15,\n      5,\n      1,\n      3,\n      7,\n      14,\n      6,\n      9,\n      11,\n      8,\n      12,\n      2,\n      10,\n      0,\n      4,\n      13,\n      8,\n      6,\n      4,\n      1,\n      3,\n      11,\n      15,\n      0,\n      5,\n      12,\n      2,\n      13,\n      9,\n      7,\n      10,\n      14,\n      12,\n      15,\n      10,\n      4,\n      1,\n      5,\n      8,\n      7,\n      6,\n      2,\n      13,\n      14,\n      0,\n      3,\n      9,\n      11\n    ], s = [\n      11,\n      14,\n      15,\n      12,\n      5,\n      8,\n      7,\n      9,\n      11,\n      13,\n      14,\n      15,\n      6,\n      7,\n      9,\n      8,\n      7,\n      6,\n      8,\n      13,\n      11,\n      9,\n      7,\n      15,\n      7,\n      12,\n      15,\n      9,\n      11,\n      7,\n      13,\n      12,\n      11,\n      13,\n      6,\n      7,\n      14,\n      9,\n      13,\n      15,\n      14,\n      8,\n      13,\n      6,\n      5,\n      12,\n      7,\n      5,\n      11,\n      12,\n      14,\n      15,\n      14,\n      15,\n      9,\n      8,\n      9,\n      14,\n      5,\n      6,\n      8,\n      6,\n      5,\n      12,\n      9,\n      15,\n      5,\n      11,\n      6,\n      8,\n      13,\n      12,\n      5,\n      12,\n      13,\n      14,\n      11,\n      8,\n      5,\n      6\n    ], sh = [\n      8,\n      9,\n      9,\n      11,\n      13,\n      15,\n      15,\n      5,\n      7,\n      7,\n      8,\n      11,\n      14,\n      14,\n      12,\n      6,\n      9,\n      13,\n      15,\n      7,\n      12,\n      8,\n      9,\n      11,\n      7,\n      7,\n      12,\n      7,\n      6,\n      15,\n      13,\n      11,\n      9,\n      7,\n      15,\n      11,\n      8,\n      6,\n      6,\n      14,\n      12,\n      13,\n      5,\n      14,\n      13,\n      13,\n      7,\n      5,\n      15,\n      5,\n      8,\n      11,\n      14,\n      14,\n      6,\n      14,\n      6,\n      9,\n      12,\n      9,\n      12,\n      5,\n      15,\n      8,\n      8,\n      5,\n      12,\n      9,\n      12,\n      5,\n      14,\n      6,\n      8,\n      13,\n      6,\n      5,\n      15,\n      13,\n      11,\n      11\n    ];\n  }\n}), require_hmac = __commonJS({\n  \"node_modules/hash.js/lib/hash/hmac.js\"(exports, module) {\n    var utils = require_utils4(), assert = require_minimalistic_assert();\n    function Hmac(hash, key, enc) {\n      if (!(this instanceof Hmac))\n        return new Hmac(hash, key, enc);\n      this.Hash = hash, this.blockSize = hash.blockSize / 8, this.outSize = hash.outSize / 8, this.inner = null, this.outer = null, this._init(utils.toArray(key, enc));\n    }\n    Hmac.prototype = {}, module.exports = Hmac, Hmac.prototype._init = function(key) {\n      key.length > this.blockSize && (key = new this.Hash().update(key).digest()), assert(key.length <= this.blockSize);\n      for (var i = key.length;i < this.blockSize; i++)\n        key.push(0);\n      for (i = 0;i < key.length; i++)\n        key[i] ^= 54;\n      for (this.inner = new this.Hash().update(key), i = 0;i < key.length; i++)\n        key[i] ^= 106;\n      this.outer = new this.Hash().update(key);\n    }, Hmac.prototype.update = function(msg, enc) {\n      return this.inner.update(msg, enc), this;\n    }, Hmac.prototype.digest = function(enc) {\n      return this.outer.update(this.inner.digest()), this.outer.digest(enc);\n    };\n  }\n}), require_hash2 = __commonJS({\n  \"node_modules/hash.js/lib/hash.js\"(exports) {\n    var hash = exports;\n    hash.utils = require_utils4(), hash.common = require_common(), hash.sha = require_sha3(), hash.ripemd = require_ripemd(), hash.hmac = require_hmac(), hash.sha1 = hash.sha.sha1, hash.sha256 = hash.sha.sha256, hash.sha224 = hash.sha.sha224, hash.sha384 = hash.sha.sha384, hash.sha512 = hash.sha.sha512, hash.ripemd160 = hash.ripemd.ripemd160;\n  }\n}), require_secp256k1 = __commonJS({\n  \"node_modules/elliptic/lib/elliptic/precomputed/secp256k1.js\"(exports, module) {\n    module.exports = {\n      doubles: {\n        step: 4,\n        points: [\n          [\n            \"e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a\",\n            \"f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821\"\n          ],\n          [\n            \"8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508\",\n            \"11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf\"\n          ],\n          [\n            \"175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739\",\n            \"d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695\"\n          ],\n          [\n            \"363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640\",\n            \"4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9\"\n          ],\n          [\n            \"8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c\",\n            \"4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36\"\n          ],\n          [\n            \"723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda\",\n            \"96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f\"\n          ],\n          [\n            \"eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa\",\n            \"5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999\"\n          ],\n          [\n            \"100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0\",\n            \"cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09\"\n          ],\n          [\n            \"e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d\",\n            \"9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d\"\n          ],\n          [\n            \"feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d\",\n            \"e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088\"\n          ],\n          [\n            \"da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1\",\n            \"9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d\"\n          ],\n          [\n            \"53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0\",\n            \"5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8\"\n          ],\n          [\n            \"8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047\",\n            \"10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a\"\n          ],\n          [\n            \"385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862\",\n            \"283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453\"\n          ],\n          [\n            \"6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7\",\n            \"7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160\"\n          ],\n          [\n            \"3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd\",\n            \"56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0\"\n          ],\n          [\n            \"85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83\",\n            \"7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6\"\n          ],\n          [\n            \"948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a\",\n            \"53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589\"\n          ],\n          [\n            \"6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8\",\n            \"bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17\"\n          ],\n          [\n            \"e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d\",\n            \"4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda\"\n          ],\n          [\n            \"e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725\",\n            \"7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd\"\n          ],\n          [\n            \"213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754\",\n            \"4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2\"\n          ],\n          [\n            \"4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c\",\n            \"17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6\"\n          ],\n          [\n            \"fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6\",\n            \"6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f\"\n          ],\n          [\n            \"76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39\",\n            \"c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01\"\n          ],\n          [\n            \"c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891\",\n            \"893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3\"\n          ],\n          [\n            \"d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b\",\n            \"febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f\"\n          ],\n          [\n            \"b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03\",\n            \"2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7\"\n          ],\n          [\n            \"e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d\",\n            \"eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78\"\n          ],\n          [\n            \"a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070\",\n            \"7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1\"\n          ],\n          [\n            \"90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4\",\n            \"e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150\"\n          ],\n          [\n            \"8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da\",\n            \"662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82\"\n          ],\n          [\n            \"e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11\",\n            \"1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc\"\n          ],\n          [\n            \"8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e\",\n            \"efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b\"\n          ],\n          [\n            \"e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41\",\n            \"2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51\"\n          ],\n          [\n            \"b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef\",\n            \"67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45\"\n          ],\n          [\n            \"d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8\",\n            \"db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120\"\n          ],\n          [\n            \"324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d\",\n            \"648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84\"\n          ],\n          [\n            \"4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96\",\n            \"35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d\"\n          ],\n          [\n            \"9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd\",\n            \"ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d\"\n          ],\n          [\n            \"6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5\",\n            \"9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8\"\n          ],\n          [\n            \"a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266\",\n            \"40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8\"\n          ],\n          [\n            \"7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71\",\n            \"34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac\"\n          ],\n          [\n            \"928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac\",\n            \"c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f\"\n          ],\n          [\n            \"85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751\",\n            \"1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962\"\n          ],\n          [\n            \"ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e\",\n            \"493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907\"\n          ],\n          [\n            \"827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241\",\n            \"c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec\"\n          ],\n          [\n            \"eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3\",\n            \"be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d\"\n          ],\n          [\n            \"e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f\",\n            \"4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414\"\n          ],\n          [\n            \"1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19\",\n            \"aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd\"\n          ],\n          [\n            \"146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be\",\n            \"b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0\"\n          ],\n          [\n            \"fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9\",\n            \"6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811\"\n          ],\n          [\n            \"da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2\",\n            \"8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1\"\n          ],\n          [\n            \"a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13\",\n            \"7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c\"\n          ],\n          [\n            \"174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c\",\n            \"ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73\"\n          ],\n          [\n            \"959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba\",\n            \"2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd\"\n          ],\n          [\n            \"d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151\",\n            \"e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405\"\n          ],\n          [\n            \"64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073\",\n            \"d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589\"\n          ],\n          [\n            \"8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458\",\n            \"38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e\"\n          ],\n          [\n            \"13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b\",\n            \"69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27\"\n          ],\n          [\n            \"bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366\",\n            \"d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1\"\n          ],\n          [\n            \"8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa\",\n            \"40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482\"\n          ],\n          [\n            \"8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0\",\n            \"620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945\"\n          ],\n          [\n            \"dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787\",\n            \"7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573\"\n          ],\n          [\n            \"f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e\",\n            \"ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82\"\n          ]\n        ]\n      },\n      naf: {\n        wnd: 7,\n        points: [\n          [\n            \"f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9\",\n            \"388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672\"\n          ],\n          [\n            \"2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4\",\n            \"d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6\"\n          ],\n          [\n            \"5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc\",\n            \"6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da\"\n          ],\n          [\n            \"acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe\",\n            \"cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37\"\n          ],\n          [\n            \"774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb\",\n            \"d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b\"\n          ],\n          [\n            \"f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8\",\n            \"ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81\"\n          ],\n          [\n            \"d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e\",\n            \"581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58\"\n          ],\n          [\n            \"defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34\",\n            \"4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77\"\n          ],\n          [\n            \"2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c\",\n            \"85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a\"\n          ],\n          [\n            \"352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5\",\n            \"321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c\"\n          ],\n          [\n            \"2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f\",\n            \"2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67\"\n          ],\n          [\n            \"9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714\",\n            \"73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402\"\n          ],\n          [\n            \"daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729\",\n            \"a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55\"\n          ],\n          [\n            \"c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db\",\n            \"2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482\"\n          ],\n          [\n            \"6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4\",\n            \"e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82\"\n          ],\n          [\n            \"1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5\",\n            \"b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396\"\n          ],\n          [\n            \"605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479\",\n            \"2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49\"\n          ],\n          [\n            \"62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d\",\n            \"80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf\"\n          ],\n          [\n            \"80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f\",\n            \"1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a\"\n          ],\n          [\n            \"7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb\",\n            \"d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7\"\n          ],\n          [\n            \"d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9\",\n            \"eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933\"\n          ],\n          [\n            \"49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963\",\n            \"758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a\"\n          ],\n          [\n            \"77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74\",\n            \"958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6\"\n          ],\n          [\n            \"f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530\",\n            \"e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37\"\n          ],\n          [\n            \"463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b\",\n            \"5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e\"\n          ],\n          [\n            \"f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247\",\n            \"cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6\"\n          ],\n          [\n            \"caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1\",\n            \"cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476\"\n          ],\n          [\n            \"2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120\",\n            \"4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40\"\n          ],\n          [\n            \"7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435\",\n            \"91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61\"\n          ],\n          [\n            \"754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18\",\n            \"673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683\"\n          ],\n          [\n            \"e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8\",\n            \"59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5\"\n          ],\n          [\n            \"186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb\",\n            \"3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b\"\n          ],\n          [\n            \"df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f\",\n            \"55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417\"\n          ],\n          [\n            \"5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143\",\n            \"efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868\"\n          ],\n          [\n            \"290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba\",\n            \"e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a\"\n          ],\n          [\n            \"af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45\",\n            \"f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6\"\n          ],\n          [\n            \"766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a\",\n            \"744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996\"\n          ],\n          [\n            \"59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e\",\n            \"c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e\"\n          ],\n          [\n            \"f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8\",\n            \"e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d\"\n          ],\n          [\n            \"7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c\",\n            \"30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2\"\n          ],\n          [\n            \"948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519\",\n            \"e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e\"\n          ],\n          [\n            \"7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab\",\n            \"100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437\"\n          ],\n          [\n            \"3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca\",\n            \"ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311\"\n          ],\n          [\n            \"d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf\",\n            \"8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4\"\n          ],\n          [\n            \"1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610\",\n            \"68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575\"\n          ],\n          [\n            \"733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4\",\n            \"f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d\"\n          ],\n          [\n            \"15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c\",\n            \"d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d\"\n          ],\n          [\n            \"a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940\",\n            \"edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629\"\n          ],\n          [\n            \"e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980\",\n            \"a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06\"\n          ],\n          [\n            \"311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3\",\n            \"66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374\"\n          ],\n          [\n            \"34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf\",\n            \"9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee\"\n          ],\n          [\n            \"f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63\",\n            \"4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1\"\n          ],\n          [\n            \"d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448\",\n            \"fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b\"\n          ],\n          [\n            \"32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf\",\n            \"5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661\"\n          ],\n          [\n            \"7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5\",\n            \"8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6\"\n          ],\n          [\n            \"ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6\",\n            \"8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e\"\n          ],\n          [\n            \"16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5\",\n            \"5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d\"\n          ],\n          [\n            \"eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99\",\n            \"f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc\"\n          ],\n          [\n            \"78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51\",\n            \"f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4\"\n          ],\n          [\n            \"494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5\",\n            \"42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c\"\n          ],\n          [\n            \"a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5\",\n            \"204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b\"\n          ],\n          [\n            \"c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997\",\n            \"4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913\"\n          ],\n          [\n            \"841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881\",\n            \"73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154\"\n          ],\n          [\n            \"5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5\",\n            \"39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865\"\n          ],\n          [\n            \"36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66\",\n            \"d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc\"\n          ],\n          [\n            \"336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726\",\n            \"ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224\"\n          ],\n          [\n            \"8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede\",\n            \"6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e\"\n          ],\n          [\n            \"1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94\",\n            \"60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6\"\n          ],\n          [\n            \"85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31\",\n            \"3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511\"\n          ],\n          [\n            \"29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51\",\n            \"b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b\"\n          ],\n          [\n            \"a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252\",\n            \"ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2\"\n          ],\n          [\n            \"4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5\",\n            \"cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c\"\n          ],\n          [\n            \"d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b\",\n            \"6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3\"\n          ],\n          [\n            \"ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4\",\n            \"322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d\"\n          ],\n          [\n            \"af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f\",\n            \"6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700\"\n          ],\n          [\n            \"e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889\",\n            \"2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4\"\n          ],\n          [\n            \"591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246\",\n            \"b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196\"\n          ],\n          [\n            \"11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984\",\n            \"998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4\"\n          ],\n          [\n            \"3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a\",\n            \"b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257\"\n          ],\n          [\n            \"cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030\",\n            \"bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13\"\n          ],\n          [\n            \"c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197\",\n            \"6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096\"\n          ],\n          [\n            \"c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593\",\n            \"c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38\"\n          ],\n          [\n            \"a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef\",\n            \"21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f\"\n          ],\n          [\n            \"347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38\",\n            \"60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448\"\n          ],\n          [\n            \"da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a\",\n            \"49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a\"\n          ],\n          [\n            \"c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111\",\n            \"5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4\"\n          ],\n          [\n            \"4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502\",\n            \"7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437\"\n          ],\n          [\n            \"3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea\",\n            \"be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7\"\n          ],\n          [\n            \"cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26\",\n            \"8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d\"\n          ],\n          [\n            \"b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986\",\n            \"39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a\"\n          ],\n          [\n            \"d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e\",\n            \"62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54\"\n          ],\n          [\n            \"48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4\",\n            \"25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77\"\n          ],\n          [\n            \"dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda\",\n            \"ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517\"\n          ],\n          [\n            \"6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859\",\n            \"cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10\"\n          ],\n          [\n            \"e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f\",\n            \"f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125\"\n          ],\n          [\n            \"eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c\",\n            \"6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e\"\n          ],\n          [\n            \"13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942\",\n            \"fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1\"\n          ],\n          [\n            \"ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a\",\n            \"1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2\"\n          ],\n          [\n            \"b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80\",\n            \"5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423\"\n          ],\n          [\n            \"ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d\",\n            \"438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8\"\n          ],\n          [\n            \"8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1\",\n            \"cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758\"\n          ],\n          [\n            \"52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63\",\n            \"c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375\"\n          ],\n          [\n            \"e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352\",\n            \"6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d\"\n          ],\n          [\n            \"7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193\",\n            \"ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec\"\n          ],\n          [\n            \"5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00\",\n            \"9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0\"\n          ],\n          [\n            \"32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58\",\n            \"ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c\"\n          ],\n          [\n            \"e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7\",\n            \"d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4\"\n          ],\n          [\n            \"8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8\",\n            \"c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f\"\n          ],\n          [\n            \"4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e\",\n            \"67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649\"\n          ],\n          [\n            \"3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d\",\n            \"cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826\"\n          ],\n          [\n            \"674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b\",\n            \"299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5\"\n          ],\n          [\n            \"d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f\",\n            \"f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87\"\n          ],\n          [\n            \"30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6\",\n            \"462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b\"\n          ],\n          [\n            \"be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297\",\n            \"62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc\"\n          ],\n          [\n            \"93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a\",\n            \"7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c\"\n          ],\n          [\n            \"b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c\",\n            \"ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f\"\n          ],\n          [\n            \"d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52\",\n            \"4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a\"\n          ],\n          [\n            \"d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb\",\n            \"bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46\"\n          ],\n          [\n            \"463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065\",\n            \"bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f\"\n          ],\n          [\n            \"7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917\",\n            \"603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03\"\n          ],\n          [\n            \"74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9\",\n            \"cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08\"\n          ],\n          [\n            \"30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3\",\n            \"553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8\"\n          ],\n          [\n            \"9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57\",\n            \"712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373\"\n          ],\n          [\n            \"176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66\",\n            \"ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3\"\n          ],\n          [\n            \"75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8\",\n            \"9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8\"\n          ],\n          [\n            \"809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721\",\n            \"9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1\"\n          ],\n          [\n            \"1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180\",\n            \"4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9\"\n          ]\n        ]\n      }\n    };\n  }\n}), require_curves = __commonJS({\n  \"node_modules/elliptic/lib/elliptic/curves.js\"(exports) {\n    var curves = exports, hash = require_hash2(), curve = require_curve(), utils = require_utils3(), assert = utils.assert;\n    function PresetCurve(options) {\n      options.type === \"short\" \? this.curve = new curve.short(options) : options.type === \"edwards\" \? this.curve = new curve.edwards(options) : this.curve = new curve.mont(options), this.g = this.curve.g, this.n = this.curve.n, this.hash = options.hash, assert(this.g.validate(), \"Invalid curve\"), assert(this.g.mul(this.n).isInfinity(), \"Invalid curve, G*N != O\");\n    }\n    curves.PresetCurve = PresetCurve;\n    function defineCurve(name, options) {\n      Object.defineProperty(curves, name, {\n        configurable: !0,\n        enumerable: !0,\n        get: function() {\n          var curve2 = new PresetCurve(options);\n          return Object.defineProperty(curves, name, {\n            configurable: !0,\n            enumerable: !0,\n            value: curve2\n          }), curve2;\n        }\n      });\n    }\n    defineCurve(\"p192\", {\n      type: \"short\",\n      prime: \"p192\",\n      p: \"ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff\",\n      a: \"ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc\",\n      b: \"64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1\",\n      n: \"ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831\",\n      hash: hash.sha256,\n      gRed: !1,\n      g: [\n        \"188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012\",\n        \"07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811\"\n      ]\n    }), defineCurve(\"p224\", {\n      type: \"short\",\n      prime: \"p224\",\n      p: \"ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001\",\n      a: \"ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe\",\n      b: \"b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4\",\n      n: \"ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d\",\n      hash: hash.sha256,\n      gRed: !1,\n      g: [\n        \"b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21\",\n        \"bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34\"\n      ]\n    }), defineCurve(\"p256\", {\n      type: \"short\",\n      prime: null,\n      p: \"ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff\",\n      a: \"ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc\",\n      b: \"5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b\",\n      n: \"ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551\",\n      hash: hash.sha256,\n      gRed: !1,\n      g: [\n        \"6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296\",\n        \"4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5\"\n      ]\n    }), defineCurve(\"p384\", {\n      type: \"short\",\n      prime: null,\n      p: \"ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff\",\n      a: \"ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc\",\n      b: \"b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef\",\n      n: \"ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973\",\n      hash: hash.sha384,\n      gRed: !1,\n      g: [\n        \"aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7\",\n        \"3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f\"\n      ]\n    }), defineCurve(\"p521\", {\n      type: \"short\",\n      prime: null,\n      p: \"000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff\",\n      a: \"000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc\",\n      b: \"00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00\",\n      n: \"000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409\",\n      hash: hash.sha512,\n      gRed: !1,\n      g: [\n        \"000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66\",\n        \"00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650\"\n      ]\n    }), defineCurve(\"curve25519\", {\n      type: \"mont\",\n      prime: \"p25519\",\n      p: \"7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed\",\n      a: \"76d06\",\n      b: \"1\",\n      n: \"1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed\",\n      hash: hash.sha256,\n      gRed: !1,\n      g: [\"9\"]\n    }), defineCurve(\"ed25519\", {\n      type: \"edwards\",\n      prime: \"p25519\",\n      p: \"7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed\",\n      a: \"-1\",\n      c: \"1\",\n      d: \"52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3\",\n      n: \"1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed\",\n      hash: hash.sha256,\n      gRed: !1,\n      g: [\n        \"216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a\",\n        \"6666666666666666666666666666666666666666666666666666666666666658\"\n      ]\n    });\n    var pre;\n    try {\n      pre = require_secp256k1();\n    } catch {\n      pre = void 0;\n    }\n    defineCurve(\"secp256k1\", {\n      type: \"short\",\n      prime: \"k256\",\n      p: \"ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f\",\n      a: \"0\",\n      b: \"7\",\n      n: \"ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141\",\n      h: \"1\",\n      hash: hash.sha256,\n      beta: \"7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\",\n      lambda: \"5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72\",\n      basis: [\n        {\n          a: \"3086d221a7d46bcde86c90e49284eb15\",\n          b: \"-e4437ed6010e88286f547fa90abfe4c3\"\n        },\n        {\n          a: \"114ca50f7a8e2f3f657c1108d9d44cfd8\",\n          b: \"3086d221a7d46bcde86c90e49284eb15\"\n        }\n      ],\n      gRed: !1,\n      g: [\n        \"79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798\",\n        \"483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8\",\n        pre\n      ]\n    });\n  }\n}), require_hmac_drbg = __commonJS({\n  \"node_modules/hmac-drbg/lib/hmac-drbg.js\"(exports, module) {\n    var hash = require_hash2(), utils = require_utils2(), assert = require_minimalistic_assert();\n    function HmacDRBG(options) {\n      if (!(this instanceof HmacDRBG))\n        return new HmacDRBG(options);\n      this.hash = options.hash, this.predResist = !!options.predResist, this.outLen = this.hash.outSize, this.minEntropy = options.minEntropy || this.hash.hmacStrength, this._reseed = null, this.reseedInterval = null, this.K = null, this.V = null;\n      var entropy = utils.toArray(options.entropy, options.entropyEnc || \"hex\"), nonce = utils.toArray(options.nonce, options.nonceEnc || \"hex\"), pers = utils.toArray(options.pers, options.persEnc || \"hex\");\n      assert(entropy.length >= this.minEntropy / 8, \"Not enough entropy. Minimum is: \" + this.minEntropy + \" bits\"), this._init(entropy, nonce, pers);\n    }\n    HmacDRBG.prototype = {}, module.exports = HmacDRBG, HmacDRBG.prototype._init = function(entropy, nonce, pers) {\n      var seed = entropy.concat(nonce).concat(pers);\n      this.K = new Array(this.outLen / 8), this.V = new Array(this.outLen / 8);\n      for (var i = 0;i < this.V.length; i++)\n        this.K[i] = 0, this.V[i] = 1;\n      this._update(seed), this._reseed = 1, this.reseedInterval = 281474976710656;\n    }, HmacDRBG.prototype._hmac = function() {\n      return new hash.hmac(this.hash, this.K);\n    }, HmacDRBG.prototype._update = function(seed) {\n      var kmac = this._hmac().update(this.V).update([0]);\n      seed && (kmac = kmac.update(seed)), this.K = kmac.digest(), this.V = this._hmac().update(this.V).digest(), seed && (this.K = this._hmac().update(this.V).update([1]).update(seed).digest(), this.V = this._hmac().update(this.V).digest());\n    }, HmacDRBG.prototype.reseed = function(entropy, entropyEnc, add, addEnc) {\n      typeof entropyEnc != \"string\" && (addEnc = add, add = entropyEnc, entropyEnc = null), entropy = utils.toArray(entropy, entropyEnc), add = utils.toArray(add, addEnc), assert(entropy.length >= this.minEntropy / 8, \"Not enough entropy. Minimum is: \" + this.minEntropy + \" bits\"), this._update(entropy.concat(add || [])), this._reseed = 1;\n    }, HmacDRBG.prototype.generate = function(len, enc, add, addEnc) {\n      if (this._reseed > this.reseedInterval)\n        throw new Error(\"Reseed is required\");\n      typeof enc != \"string\" && (addEnc = add, add = enc, enc = null), add && (add = utils.toArray(add, addEnc || \"hex\"), this._update(add));\n      for (var temp = [];temp.length < len; )\n        this.V = this._hmac().update(this.V).digest(), temp = temp.concat(this.V);\n      var res = temp.slice(0, len);\n      return this._update(add), this._reseed++, utils.encode(res, enc);\n    };\n  }\n}), require_key = __commonJS({\n  \"node_modules/elliptic/lib/elliptic/ec/key.js\"(exports, module) {\n    var BN = require_bn4(), utils = require_utils3(), assert = utils.assert;\n    function KeyPair(ec, options) {\n      this.ec = ec, this.priv = null, this.pub = null, options.priv && this._importPrivate(options.priv, options.privEnc), options.pub && this._importPublic(options.pub, options.pubEnc);\n    }\n    KeyPair.prototype = {}, module.exports = KeyPair, KeyPair.fromPublic = function(ec, pub, enc) {\n      return pub instanceof KeyPair \? pub : new KeyPair(ec, {\n        pub,\n        pubEnc: enc\n      });\n    }, KeyPair.fromPrivate = function(ec, priv, enc) {\n      return priv instanceof KeyPair \? priv : new KeyPair(ec, {\n        priv,\n        privEnc: enc\n      });\n    }, KeyPair.prototype.validate = function() {\n      var pub = this.getPublic();\n      return pub.isInfinity() \? { result: !1, reason: \"Invalid public key\" } : pub.validate() \? pub.mul(this.ec.curve.n).isInfinity() \? { result: !0, reason: null } : { result: !1, reason: \"Public key * N != O\" } : { result: !1, reason: \"Public key is not a point\" };\n    }, KeyPair.prototype.getPublic = function(compact, enc) {\n      return typeof compact == \"string\" && (enc = compact, compact = null), this.pub || (this.pub = this.ec.g.mul(this.priv)), enc \? this.pub.encode(enc, compact) : this.pub;\n    }, KeyPair.prototype.getPrivate = function(enc) {\n      return enc === \"hex\" \? this.priv.toString(16, 2) : this.priv;\n    }, KeyPair.prototype._importPrivate = function(key, enc) {\n      this.priv = new BN(key, enc || 16), this.priv = this.priv.umod(this.ec.curve.n);\n    }, KeyPair.prototype._importPublic = function(key, enc) {\n      if (key.x || key.y) {\n        this.ec.curve.type === \"mont\" \? assert(key.x, \"Need x coordinate\") : (this.ec.curve.type === \"short\" || this.ec.curve.type === \"edwards\") && assert(key.x && key.y, \"Need both x and y coordinate\"), this.pub = this.ec.curve.point(key.x, key.y);\n        return;\n      }\n      this.pub = this.ec.curve.decodePoint(key, enc);\n    }, KeyPair.prototype.derive = function(pub) {\n      return pub.validate() || assert(pub.validate(), \"public point not validated\"), pub.mul(this.priv).getX();\n    }, KeyPair.prototype.sign = function(msg, enc, options) {\n      return this.ec.sign(msg, this, enc, options);\n    }, KeyPair.prototype.verify = function(msg, signature) {\n      return this.ec.verify(msg, signature, this);\n    }, KeyPair.prototype.inspect = function() {\n      return \"<Key priv: \" + (this.priv && this.priv.toString(16, 2)) + \" pub: \" + (this.pub && this.pub.inspect()) + \" >\";\n    };\n  }\n}), require_signature = __commonJS({\n  \"node_modules/elliptic/lib/elliptic/ec/signature.js\"(exports, module) {\n    var BN = require_bn4(), utils = require_utils3(), assert = utils.assert;\n    function Signature(options, enc) {\n      if (options instanceof Signature)\n        return options;\n      this._importDER(options, enc) || (assert(options.r && options.s, \"Signature without r or s\"), this.r = new BN(options.r, 16), this.s = new BN(options.s, 16), options.recoveryParam === void 0 \? this.recoveryParam = null : this.recoveryParam = options.recoveryParam);\n    }\n    Signature.prototype = {}, module.exports = Signature;\n    function Position() {\n      this.place = 0;\n    }\n    function getLength(buf, p) {\n      var initial = buf[p.place++];\n      if (!(initial & 128))\n        return initial;\n      var octetLen = initial & 15;\n      if (octetLen === 0 || octetLen > 4)\n        return !1;\n      for (var val = 0, i = 0, off = p.place;i < octetLen; i++, off++)\n        val <<= 8, val |= buf[off], val >>>= 0;\n      return val <= 127 \? !1 : (p.place = off, val);\n    }\n    function rmPadding(buf) {\n      for (var i = 0, len = buf.length - 1;!buf[i] && !(buf[i + 1] & 128) && i < len; )\n        i++;\n      return i === 0 \? buf : buf.slice(i);\n    }\n    Signature.prototype._importDER = function(data, enc) {\n      data = utils.toArray(data, enc);\n      var p = new Position;\n      if (data[p.place++] !== 48)\n        return !1;\n      var len = getLength(data, p);\n      if (len === !1 || len + p.place !== data.length || data[p.place++] !== 2)\n        return !1;\n      var rlen = getLength(data, p);\n      if (rlen === !1)\n        return !1;\n      var r = data.slice(p.place, rlen + p.place);\n      if (p.place += rlen, data[p.place++] !== 2)\n        return !1;\n      var slen = getLength(data, p);\n      if (slen === !1 || data.length !== slen + p.place)\n        return !1;\n      var s = data.slice(p.place, slen + p.place);\n      if (r[0] === 0)\n        if (r[1] & 128)\n          r = r.slice(1);\n        else\n          return !1;\n      if (s[0] === 0)\n        if (s[1] & 128)\n          s = s.slice(1);\n        else\n          return !1;\n      return this.r = new BN(r), this.s = new BN(s), this.recoveryParam = null, !0;\n    };\n    function constructLength(arr, len) {\n      if (len < 128) {\n        arr.push(len);\n        return;\n      }\n      var octets = 1 + (Math.log(len) / Math.LN2 >>> 3);\n      for (arr.push(octets | 128);--octets; )\n        arr.push(len >>> (octets << 3) & 255);\n      arr.push(len);\n    }\n    Signature.prototype.toDER = function(enc) {\n      var r = this.r.toArray(), s = this.s.toArray();\n      for (r[0] & 128 && (r = [0].concat(r)), s[0] & 128 && (s = [0].concat(s)), r = rmPadding(r), s = rmPadding(s);!s[0] && !(s[1] & 128); )\n        s = s.slice(1);\n      var arr = [2];\n      constructLength(arr, r.length), arr = arr.concat(r), arr.push(2), constructLength(arr, s.length);\n      var backHalf = arr.concat(s), res = [48];\n      return constructLength(res, backHalf.length), res = res.concat(backHalf), utils.encode(res, enc);\n    };\n  }\n}), require_ec = __commonJS({\n  \"node_modules/elliptic/lib/elliptic/ec/index.js\"(exports, module) {\n    var BN = require_bn4(), HmacDRBG = require_hmac_drbg(), utils = require_utils3(), curves = require_curves(), rand = require_brorand(), assert = utils.assert, KeyPair = require_key(), Signature = require_signature();\n    function EC(options) {\n      if (!(this instanceof EC))\n        return new EC(options);\n      typeof options == \"string\" && (assert(Object.prototype.hasOwnProperty.call(curves, options), \"Unknown curve \" + options), options = curves[options]), options instanceof curves.PresetCurve && (options = { curve: options }), this.curve = options.curve.curve, this.n = this.curve.n, this.nh = this.n.ushrn(1), this.g = this.curve.g, this.g = options.curve.g, this.g.precompute(options.curve.n.bitLength() + 1), this.hash = options.hash || options.curve.hash;\n    }\n    EC.prototype = {}, module.exports = EC, EC.prototype.keyPair = function(options) {\n      return new KeyPair(this, options);\n    }, EC.prototype.keyFromPrivate = function(priv, enc) {\n      return KeyPair.fromPrivate(this, priv, enc);\n    }, EC.prototype.keyFromPublic = function(pub, enc) {\n      return KeyPair.fromPublic(this, pub, enc);\n    }, EC.prototype.genKeyPair = function(options) {\n      options || (options = {});\n      for (var drbg = new HmacDRBG({\n        hash: this.hash,\n        pers: options.pers,\n        persEnc: options.persEnc || \"utf8\",\n        entropy: options.entropy || rand(this.hash.hmacStrength),\n        entropyEnc: options.entropy && options.entropyEnc || \"utf8\",\n        nonce: this.n.toArray()\n      }), bytes = this.n.byteLength(), ns2 = this.n.sub(new BN(2));; ) {\n        var priv = new BN(drbg.generate(bytes));\n        if (!(priv.cmp(ns2) > 0))\n          return priv.iaddn(1), this.keyFromPrivate(priv);\n      }\n    }, EC.prototype._truncateToN = function(msg, truncOnly) {\n      var delta = msg.byteLength() * 8 - this.n.bitLength();\n      return delta > 0 && (msg = msg.ushrn(delta)), !truncOnly && msg.cmp(this.n) >= 0 \? msg.sub(this.n) : msg;\n    }, EC.prototype.sign = function(msg, key, enc, options) {\n      typeof enc == \"object\" && (options = enc, enc = null), options || (options = {}), key = this.keyFromPrivate(key, enc), msg = this._truncateToN(new BN(msg, 16));\n      for (var bytes = this.n.byteLength(), bkey = key.getPrivate().toArray(\"be\", bytes), nonce = msg.toArray(\"be\", bytes), drbg = new HmacDRBG({\n        hash: this.hash,\n        entropy: bkey,\n        nonce,\n        pers: options.pers,\n        persEnc: options.persEnc || \"utf8\"\n      }), ns1 = this.n.sub(new BN(1)), iter = 0;; iter++) {\n        var k = options.k \? options.k(iter) : new BN(drbg.generate(this.n.byteLength()));\n        if (k = this._truncateToN(k, !0), !(k.cmpn(1) <= 0 || k.cmp(ns1) >= 0)) {\n          var kp = this.g.mul(k);\n          if (!kp.isInfinity()) {\n            var kpX = kp.getX(), r = kpX.umod(this.n);\n            if (r.cmpn(0) !== 0) {\n              var s = k.invm(this.n).mul(r.mul(key.getPrivate()).iadd(msg));\n              if (s = s.umod(this.n), s.cmpn(0) !== 0) {\n                var recoveryParam = (kp.getY().isOdd() \? 1 : 0) | (kpX.cmp(r) !== 0 \? 2 : 0);\n                return options.canonical && s.cmp(this.nh) > 0 && (s = this.n.sub(s), recoveryParam ^= 1), new Signature({ r, s, recoveryParam });\n              }\n            }\n          }\n        }\n      }\n    }, EC.prototype.verify = function(msg, signature, key, enc) {\n      msg = this._truncateToN(new BN(msg, 16)), key = this.keyFromPublic(key, enc), signature = new Signature(signature, \"hex\");\n      var { r, s } = signature;\n      if (r.cmpn(1) < 0 || r.cmp(this.n) >= 0 || s.cmpn(1) < 0 || s.cmp(this.n) >= 0)\n        return !1;\n      var sinv = s.invm(this.n), u1 = sinv.mul(msg).umod(this.n), u2 = sinv.mul(r).umod(this.n), p;\n      return this.curve._maxwellTrick \? (p = this.g.jmulAdd(u1, key.getPublic(), u2), p.isInfinity() \? !1 : p.eqXToP(r)) : (p = this.g.mulAdd(u1, key.getPublic(), u2), p.isInfinity() \? !1 : p.getX().umod(this.n).cmp(r) === 0);\n    }, EC.prototype.recoverPubKey = function(msg, signature, j, enc) {\n      assert((3 & j) === j, \"The recovery param is more than two bits\"), signature = new Signature(signature, enc);\n      var n = this.n, e = new BN(msg), r = signature.r, s = signature.s, isYOdd = j & 1, isSecondKey = j >> 1;\n      if (r.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey)\n        throw new Error(\"Unable to find sencond key candinate\");\n      isSecondKey \? r = this.curve.pointFromX(r.add(this.curve.n), isYOdd) : r = this.curve.pointFromX(r, isYOdd);\n      var rInv = signature.r.invm(n), s1 = n.sub(e).mul(rInv).umod(n), s2 = s.mul(rInv).umod(n);\n      return this.g.mulAdd(s1, r, s2);\n    }, EC.prototype.getKeyRecoveryParam = function(e, signature, Q, enc) {\n      if (signature = new Signature(signature, enc), signature.recoveryParam !== null)\n        return signature.recoveryParam;\n      for (var i = 0;i < 4; i++) {\n        var Qprime;\n        try {\n          Qprime = this.recoverPubKey(e, signature, i);\n        } catch {\n          continue;\n        }\n        if (Qprime.eq(Q))\n          return i;\n      }\n      throw new Error(\"Unable to find valid recovery factor\");\n    };\n  }\n}), require_key2 = __commonJS({\n  \"node_modules/elliptic/lib/elliptic/eddsa/key.js\"(exports, module) {\n    var utils = require_utils3(), assert = utils.assert, parseBytes = utils.parseBytes, cachedProperty = utils.cachedProperty;\n    function KeyPair(eddsa, params) {\n      this.eddsa = eddsa, this._secret = parseBytes(params.secret), eddsa.isPoint(params.pub) \? this._pub = params.pub : this._pubBytes = parseBytes(params.pub);\n    }\n    KeyPair.prototype = {}, KeyPair.fromPublic = function(eddsa, pub) {\n      return pub instanceof KeyPair \? pub : new KeyPair(eddsa, { pub });\n    }, KeyPair.fromSecret = function(eddsa, secret) {\n      return secret instanceof KeyPair \? secret : new KeyPair(eddsa, { secret });\n    }, KeyPair.prototype.secret = function() {\n      return this._secret;\n    }, cachedProperty(KeyPair, \"pubBytes\", function() {\n      return this.eddsa.encodePoint(this.pub());\n    }), cachedProperty(KeyPair, \"pub\", function() {\n      return this._pubBytes \? this.eddsa.decodePoint(this._pubBytes) : this.eddsa.g.mul(this.priv());\n    }), cachedProperty(KeyPair, \"privBytes\", function() {\n      var eddsa = this.eddsa, hash = this.hash(), lastIx = eddsa.encodingLength - 1, a = hash.slice(0, eddsa.encodingLength);\n      return a[0] &= 248, a[lastIx] &= 127, a[lastIx] |= 64, a;\n    }), cachedProperty(KeyPair, \"priv\", function() {\n      return this.eddsa.decodeInt(this.privBytes());\n    }), cachedProperty(KeyPair, \"hash\", function() {\n      return this.eddsa.hash().update(this.secret()).digest();\n    }), cachedProperty(KeyPair, \"messagePrefix\", function() {\n      return this.hash().slice(this.eddsa.encodingLength);\n    }), KeyPair.prototype.sign = function(message) {\n      return assert(this._secret, \"KeyPair can only verify\"), this.eddsa.sign(message, this);\n    }, KeyPair.prototype.verify = function(message, sig) {\n      return this.eddsa.verify(message, sig, this);\n    }, KeyPair.prototype.getSecret = function(enc) {\n      return assert(this._secret, \"KeyPair is public only\"), utils.encode(this.secret(), enc);\n    }, KeyPair.prototype.getPublic = function(enc) {\n      return utils.encode(this.pubBytes(), enc);\n    }, module.exports = KeyPair;\n  }\n}), require_signature2 = __commonJS({\n  \"node_modules/elliptic/lib/elliptic/eddsa/signature.js\"(exports, module) {\n    var BN = require_bn4(), utils = require_utils3(), assert = utils.assert, cachedProperty = utils.cachedProperty, parseBytes = utils.parseBytes;\n    function Signature(eddsa, sig) {\n      this.eddsa = eddsa, typeof sig != \"object\" && (sig = parseBytes(sig)), Array.isArray(sig) && (sig = {\n        R: sig.slice(0, eddsa.encodingLength),\n        S: sig.slice(eddsa.encodingLength)\n      }), assert(sig.R && sig.S, \"Signature without R or S\"), eddsa.isPoint(sig.R) && (this._R = sig.R), sig.S instanceof BN && (this._S = sig.S), this._Rencoded = Array.isArray(sig.R) \? sig.R : sig.Rencoded, this._Sencoded = Array.isArray(sig.S) \? sig.S : sig.Sencoded;\n    }\n    Signature.prototype = {}, cachedProperty(Signature, \"S\", function() {\n      return this.eddsa.decodeInt(this.Sencoded());\n    }), cachedProperty(Signature, \"R\", function() {\n      return this.eddsa.decodePoint(this.Rencoded());\n    }), cachedProperty(Signature, \"Rencoded\", function() {\n      return this.eddsa.encodePoint(this.R());\n    }), cachedProperty(Signature, \"Sencoded\", function() {\n      return this.eddsa.encodeInt(this.S());\n    }), Signature.prototype.toBytes = function() {\n      return this.Rencoded().concat(this.Sencoded());\n    }, Signature.prototype.toHex = function() {\n      return utils.encode(this.toBytes(), \"hex\").toUpperCase();\n    }, module.exports = Signature;\n  }\n}), require_eddsa = __commonJS({\n  \"node_modules/elliptic/lib/elliptic/eddsa/index.js\"(exports, module) {\n    var hash = require_hash2(), curves = require_curves(), utils = require_utils3(), assert = utils.assert, parseBytes = utils.parseBytes, KeyPair = require_key2(), Signature = require_signature2();\n    function EDDSA(curve) {\n      if (assert(curve === \"ed25519\", \"only tested with ed25519 so far\"), !(this instanceof EDDSA))\n        return new EDDSA(curve);\n      curve = curves[curve].curve, this.curve = curve, this.g = curve.g, this.g.precompute(curve.n.bitLength() + 1), this.pointClass = curve.point().constructor, this.encodingLength = Math.ceil(curve.n.bitLength() / 8), this.hash = hash.sha512;\n    }\n    EDDSA.prototype = {}, module.exports = EDDSA, EDDSA.prototype.sign = function(message, secret) {\n      message = parseBytes(message);\n      var key = this.keyFromSecret(secret), r = this.hashInt(key.messagePrefix(), message), R = this.g.mul(r), Rencoded = this.encodePoint(R), s_ = this.hashInt(Rencoded, key.pubBytes(), message).mul(key.priv()), S = r.add(s_).umod(this.curve.n);\n      return this.makeSignature({ R, S, Rencoded });\n    }, EDDSA.prototype.verify = function(message, sig, pub) {\n      message = parseBytes(message), sig = this.makeSignature(sig);\n      var key = this.keyFromPublic(pub), h = this.hashInt(sig.Rencoded(), key.pubBytes(), message), SG = this.g.mul(sig.S()), RplusAh = sig.R().add(key.pub().mul(h));\n      return RplusAh.eq(SG);\n    }, EDDSA.prototype.hashInt = function() {\n      for (var hash2 = this.hash(), i = 0;i < arguments.length; i++)\n        hash2.update(arguments[i]);\n      return utils.intFromLE(hash2.digest()).umod(this.curve.n);\n    }, EDDSA.prototype.keyFromPublic = function(pub) {\n      return KeyPair.fromPublic(this, pub);\n    }, EDDSA.prototype.keyFromSecret = function(secret) {\n      return KeyPair.fromSecret(this, secret);\n    }, EDDSA.prototype.makeSignature = function(sig) {\n      return sig instanceof Signature \? sig : new Signature(this, sig);\n    }, EDDSA.prototype.encodePoint = function(point) {\n      var enc = point.getY().toArray(\"le\", this.encodingLength);\n      return enc[this.encodingLength - 1] |= point.getX().isOdd() \? 128 : 0, enc;\n    }, EDDSA.prototype.decodePoint = function(bytes) {\n      bytes = utils.parseBytes(bytes);\n      var lastIx = bytes.length - 1, normed = bytes.slice(0, lastIx).concat(bytes[lastIx] & -129), xIsOdd = (bytes[lastIx] & 128) !== 0, y = utils.intFromLE(normed);\n      return this.curve.pointFromY(y, xIsOdd);\n    }, EDDSA.prototype.encodeInt = function(num) {\n      return num.toArray(\"le\", this.encodingLength);\n    }, EDDSA.prototype.decodeInt = function(bytes) {\n      return utils.intFromLE(bytes);\n    }, EDDSA.prototype.isPoint = function(val) {\n      return val instanceof this.pointClass;\n    };\n  }\n}), require_elliptic = __commonJS({\n  \"node_modules/elliptic/lib/elliptic.js\"(exports) {\n    var elliptic = exports;\n    elliptic.version = require_package().version, elliptic.utils = require_utils3(), elliptic.rand = require_brorand(), elliptic.curve = require_curve(), elliptic.curves = require_curves(), elliptic.ec = require_ec(), elliptic.eddsa = require_eddsa();\n  }\n}), require_bn5 = require_bn, require_safer = __commonJS({\n  \"node_modules/safer-buffer/safer.js\"(exports, module) {\n    var buffer = BufferModule, Buffer2 = Buffer, safer = {}, key;\n    for (key in buffer)\n      !buffer.hasOwnProperty(key) || key === \"SlowBuffer\" || key === \"Buffer\" || (safer[key] = buffer[key]);\n    var Safer = safer.Buffer = {};\n    for (key in Buffer2)\n      !Buffer2.hasOwnProperty(key) || key === \"allocUnsafe\" || key === \"allocUnsafeSlow\" || (Safer[key] = Buffer2[key]);\n    if (safer.Buffer.prototype = Buffer2.prototype, (!Safer.from || Safer.from === Uint8Array.from) && (Safer.from = function(value, encodingOrOffset, length) {\n      if (typeof value == \"number\")\n        @throwTypeError('The \"value\" argument must not be of type number. Received type ' + typeof value);\n      if (value && typeof value.length > \"u\")\n        @throwTypeError(\"The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type \" + typeof value);\n      return Buffer2(value, encodingOrOffset, length);\n    }), Safer.alloc || (Safer.alloc = function(size, fill, encoding) {\n      if (typeof size != \"number\")\n        @throwTypeError('The \"size\" argument must be of type number. Received type ' + typeof size);\n      if (size < 0 || size >= 2 * (1 << 30))\n        @throwRangeError('The value \"' + size + '\" is invalid for option \"size\"');\n      var buf = Buffer2(size);\n      return !fill || fill.length === 0 \? buf.fill(0) : typeof encoding == \"string\" \? buf.fill(fill, encoding) : buf.fill(fill), buf;\n    }), !safer.kStringMaxLength)\n      try {\n        safer.kStringMaxLength = MAX_STRING_LENGTH;\n      } catch {\n      }\n    safer.constants || (safer.constants = {\n      MAX_LENGTH: safer.kMaxLength\n    }, safer.kStringMaxLength && (safer.constants.MAX_STRING_LENGTH = safer.kStringMaxLength)), module.exports = safer;\n  }\n}), require_reporter = __commonJS({\n  \"node_modules/asn1.js/lib/asn1/base/reporter.js\"(exports) {\n    var inherits = require_inherits_browser();\n    function Reporter(options) {\n      this._reporterState = {\n        obj: null,\n        path: [],\n        options: options || {},\n        errors: []\n      };\n    }\n    Reporter.prototype = {}, exports.Reporter = Reporter, Reporter.prototype.isError = function(obj) {\n      return obj instanceof ReporterError;\n    }, Reporter.prototype.save = function() {\n      let state = this._reporterState;\n      return { obj: state.obj, pathLen: state.path.length };\n    }, Reporter.prototype.restore = function(data) {\n      let state = this._reporterState;\n      state.obj = data.obj, state.path = state.path.slice(0, data.pathLen);\n    }, Reporter.prototype.enterKey = function(key) {\n      return this._reporterState.path.push(key);\n    }, Reporter.prototype.exitKey = function(index) {\n      let state = this._reporterState;\n      state.path = state.path.slice(0, index - 1);\n    }, Reporter.prototype.leaveKey = function(index, key, value) {\n      let state = this._reporterState;\n      this.exitKey(index), state.obj !== null && (state.obj[key] = value);\n    }, Reporter.prototype.path = function() {\n      return this._reporterState.path.join(\"/\");\n    }, Reporter.prototype.enterObject = function() {\n      let state = this._reporterState, prev = state.obj;\n      return state.obj = {}, prev;\n    }, Reporter.prototype.leaveObject = function(prev) {\n      let state = this._reporterState, now = state.obj;\n      return state.obj = prev, now;\n    }, Reporter.prototype.error = function(msg) {\n      let err, state = this._reporterState, inherited = msg instanceof ReporterError;\n      if (inherited \? err = msg : err = new ReporterError(state.path.map(function(elem) {\n        return \"[\" + JSON.stringify(elem) + \"]\";\n      }).join(\"\"), msg.message || msg, msg.stack), !state.options.partial)\n        throw err;\n      return inherited || state.errors.push(err), err;\n    }, Reporter.prototype.wrapResult = function(result) {\n      let state = this._reporterState;\n      return state.options.partial \? {\n        result: this.isError(result) \? null : result,\n        errors: state.errors\n      } : result;\n    };\n    function ReporterError(path, msg) {\n      this.path = path, this.rethrow(msg);\n    }\n    inherits(ReporterError, Error), ReporterError.prototype.rethrow = function(msg) {\n      if (this.message = msg + \" at: \" + (this.path || \"(shallow)\"), Error.captureStackTrace && Error.captureStackTrace(this, ReporterError), !this.stack)\n        try {\n          throw new Error(this.message);\n        } catch (e) {\n          this.stack = e.stack;\n        }\n      return this;\n    };\n  }\n}), require_buffer = __commonJS({\n  \"node_modules/asn1.js/lib/asn1/base/buffer.js\"(exports) {\n    var inherits = require_inherits_browser(), Reporter = require_reporter().Reporter, Buffer2 = require_safer().Buffer;\n    function DecoderBuffer(base, options) {\n      if (Reporter.call(this, options), !Buffer2.isBuffer(base)) {\n        this.error(\"Input not Buffer\");\n        return;\n      }\n      this.base = base, this.offset = 0, this.length = base.length;\n    }\n    inherits(DecoderBuffer, Reporter), exports.DecoderBuffer = DecoderBuffer, DecoderBuffer.isDecoderBuffer = function(data) {\n      return data instanceof DecoderBuffer \? !0 : typeof data == \"object\" && Buffer2.isBuffer(data.base) && data.constructor.name === \"DecoderBuffer\" && typeof data.offset == \"number\" && typeof data.length == \"number\" && typeof data.save == \"function\" && typeof data.restore == \"function\" && typeof data.isEmpty == \"function\" && typeof data.readUInt8 == \"function\" && typeof data.skip == \"function\" && typeof data.raw == \"function\";\n    }, DecoderBuffer.prototype.save = function() {\n      return {\n        offset: this.offset,\n        reporter: Reporter.prototype.save.call(this)\n      };\n    }, DecoderBuffer.prototype.restore = function(save) {\n      let res = new DecoderBuffer(this.base);\n      return res.offset = save.offset, res.length = this.offset, this.offset = save.offset, Reporter.prototype.restore.call(this, save.reporter), res;\n    }, DecoderBuffer.prototype.isEmpty = function() {\n      return this.offset === this.length;\n    }, DecoderBuffer.prototype.readUInt8 = function(fail) {\n      return this.offset + 1 <= this.length \? this.base.readUInt8(this.offset++, !0) : this.error(fail || \"DecoderBuffer overrun\");\n    }, DecoderBuffer.prototype.skip = function(bytes, fail) {\n      if (!(this.offset + bytes <= this.length))\n        return this.error(fail || \"DecoderBuffer overrun\");\n      let res = new DecoderBuffer(this.base);\n      return res._reporterState = this._reporterState, res.offset = this.offset, res.length = this.offset + bytes, this.offset += bytes, res;\n    }, DecoderBuffer.prototype.raw = function(save) {\n      return this.base.slice(save \? save.offset : this.offset, this.length);\n    };\n    function EncoderBuffer(value, reporter) {\n      if (Array.isArray(value))\n        this.length = 0, this.value = value.map(function(item) {\n          return EncoderBuffer.isEncoderBuffer(item) || (item = new EncoderBuffer(item, reporter)), this.length += item.length, item;\n        }, this);\n      else if (typeof value == \"number\") {\n        if (!(0 <= value && value <= 255))\n          return reporter.error(\"non-byte EncoderBuffer value\");\n        this.value = value, this.length = 1;\n      } else if (typeof value == \"string\")\n        this.value = value, this.length = Buffer2.byteLength(value);\n      else if (Buffer2.isBuffer(value))\n        this.value = value, this.length = value.length;\n      else\n        return reporter.error(\"Unsupported type: \" + typeof value);\n    }\n    EncoderBuffer.prototype = {}, exports.EncoderBuffer = EncoderBuffer, EncoderBuffer.isEncoderBuffer = function(data) {\n      return data instanceof EncoderBuffer \? !0 : typeof data == \"object\" && data.constructor.name === \"EncoderBuffer\" && typeof data.length == \"number\" && typeof data.join == \"function\";\n    }, EncoderBuffer.prototype.join = function(out, offset) {\n      return out || (out = Buffer2.alloc(this.length)), offset || (offset = 0), this.length === 0 || (Array.isArray(this.value) \? this.value.forEach(function(item) {\n        item.join(out, offset), offset += item.length;\n      }) : (typeof this.value == \"number\" \? out[offset] = this.value : typeof this.value == \"string\" \? out.write(this.value, offset) : Buffer2.isBuffer(this.value) && this.value.copy(out, offset), offset += this.length)), out;\n    };\n  }\n}), require_node = __commonJS({\n  \"node_modules/asn1.js/lib/asn1/base/node.js\"(exports, module) {\n    var Reporter = require_reporter().Reporter, EncoderBuffer = require_buffer().EncoderBuffer, DecoderBuffer = require_buffer().DecoderBuffer, assert = require_minimalistic_assert(), tags = [\n      \"seq\",\n      \"seqof\",\n      \"set\",\n      \"setof\",\n      \"objid\",\n      \"bool\",\n      \"gentime\",\n      \"utctime\",\n      \"null_\",\n      \"enum\",\n      \"int\",\n      \"objDesc\",\n      \"bitstr\",\n      \"bmpstr\",\n      \"charstr\",\n      \"genstr\",\n      \"graphstr\",\n      \"ia5str\",\n      \"iso646str\",\n      \"numstr\",\n      \"octstr\",\n      \"printstr\",\n      \"t61str\",\n      \"unistr\",\n      \"utf8str\",\n      \"videostr\"\n    ], methods = [\"key\", \"obj\", \"use\", \"optional\", \"explicit\", \"implicit\", \"def\", \"choice\", \"any\", \"contains\"].concat(tags), overrided = [\n      \"_peekTag\",\n      \"_decodeTag\",\n      \"_use\",\n      \"_decodeStr\",\n      \"_decodeObjid\",\n      \"_decodeTime\",\n      \"_decodeNull\",\n      \"_decodeInt\",\n      \"_decodeBool\",\n      \"_decodeList\",\n      \"_encodeComposite\",\n      \"_encodeStr\",\n      \"_encodeObjid\",\n      \"_encodeTime\",\n      \"_encodeNull\",\n      \"_encodeInt\",\n      \"_encodeBool\"\n    ];\n    function Node(enc, parent, name) {\n      let state = {};\n      this._baseState = state, state.name = name, state.enc = enc, state.parent = parent || null, state.children = null, state.tag = null, state.args = null, state.reverseArgs = null, state.choice = null, state.optional = !1, state.any = !1, state.obj = !1, state.use = null, state.useDecoder = null, state.key = null, state.default = null, state.explicit = null, state.implicit = null, state.contains = null, state.parent || (state.children = [], this._wrap());\n    }\n    Node.prototype = {}, module.exports = Node;\n    var stateProps = [\n      \"enc\",\n      \"parent\",\n      \"children\",\n      \"tag\",\n      \"args\",\n      \"reverseArgs\",\n      \"choice\",\n      \"optional\",\n      \"any\",\n      \"obj\",\n      \"use\",\n      \"alteredUse\",\n      \"key\",\n      \"default\",\n      \"explicit\",\n      \"implicit\",\n      \"contains\"\n    ];\n    Node.prototype.clone = function() {\n      let state = this._baseState, cstate = {};\n      stateProps.forEach(function(prop) {\n        cstate[prop] = state[prop];\n      });\n      let res = new this.constructor(cstate.parent);\n      return res._baseState = cstate, res;\n    }, Node.prototype._wrap = function() {\n      let state = this._baseState;\n      methods.forEach(function(method) {\n        this[method] = function() {\n          let clone = new this.constructor(this);\n          return state.children.push(clone), clone[method].apply(clone, arguments);\n        };\n      }, this);\n    }, Node.prototype._init = function(body) {\n      let state = this._baseState;\n      assert(state.parent === null), body.call(this), state.children = state.children.filter(function(child) {\n        return child._baseState.parent === this;\n      }, this), assert.equal(state.children.length, 1, \"Root node can have only one child\");\n    }, Node.prototype._useArgs = function(args) {\n      let state = this._baseState, children = args.filter(function(arg) {\n        return arg instanceof this.constructor;\n      }, this);\n      args = args.filter(function(arg) {\n        return !(arg instanceof this.constructor);\n      }, this), children.length !== 0 && (assert(state.children === null), state.children = children, children.forEach(function(child) {\n        child._baseState.parent = this;\n      }, this)), args.length !== 0 && (assert(state.args === null), state.args = args, state.reverseArgs = args.map(function(arg) {\n        if (typeof arg != \"object\" || arg.constructor !== Object)\n          return arg;\n        let res = {};\n        return Object.keys(arg).forEach(function(key) {\n          key == (key | 0) && (key |= 0);\n          let value = arg[key];\n          res[value] = key;\n        }), res;\n      }));\n    }, overrided.forEach(function(method) {\n      Node.prototype[method] = function() {\n        let state = this._baseState;\n        throw new Error(method + \" not implemented for encoding: \" + state.enc);\n      };\n    }), tags.forEach(function(tag) {\n      Node.prototype[tag] = function() {\n        let state = this._baseState, args = Array.prototype.slice.call(arguments);\n        return assert(state.tag === null), state.tag = tag, this._useArgs(args), this;\n      };\n    }), Node.prototype.use = function(item) {\n      assert(item);\n      let state = this._baseState;\n      return assert(state.use === null), state.use = item, this;\n    }, Node.prototype.optional = function() {\n      let state = this._baseState;\n      return state.optional = !0, this;\n    }, Node.prototype.def = function(val) {\n      let state = this._baseState;\n      return assert(state.default === null), state.default = val, state.optional = !0, this;\n    }, Node.prototype.explicit = function(num) {\n      let state = this._baseState;\n      return assert(state.explicit === null && state.implicit === null), state.explicit = num, this;\n    }, Node.prototype.implicit = function(num) {\n      let state = this._baseState;\n      return assert(state.explicit === null && state.implicit === null), state.implicit = num, this;\n    }, Node.prototype.obj = function() {\n      let state = this._baseState, args = Array.prototype.slice.call(arguments);\n      return state.obj = !0, args.length !== 0 && this._useArgs(args), this;\n    }, Node.prototype.key = function(newKey) {\n      let state = this._baseState;\n      return assert(state.key === null), state.key = newKey, this;\n    }, Node.prototype.any = function() {\n      let state = this._baseState;\n      return state.any = !0, this;\n    }, Node.prototype.choice = function(obj) {\n      let state = this._baseState;\n      return assert(state.choice === null), state.choice = obj, this._useArgs(Object.keys(obj).map(function(key) {\n        return obj[key];\n      })), this;\n    }, Node.prototype.contains = function(item) {\n      let state = this._baseState;\n      return assert(state.use === null), state.contains = item, this;\n    }, Node.prototype._decode = function(input, options) {\n      let state = this._baseState;\n      if (state.parent === null)\n        return input.wrapResult(state.children[0]._decode(input, options));\n      let result = state.default, present = !0, prevKey = null;\n      if (state.key !== null && (prevKey = input.enterKey(state.key)), state.optional) {\n        let tag = null;\n        if (state.explicit !== null \? tag = state.explicit : state.implicit !== null \? tag = state.implicit : state.tag !== null && (tag = state.tag), tag === null && !state.any) {\n          let save = input.save();\n          try {\n            state.choice === null \? this._decodeGeneric(state.tag, input, options) : this._decodeChoice(input, options), present = !0;\n          } catch {\n            present = !1;\n          }\n          input.restore(save);\n        } else if (present = this._peekTag(input, tag, state.any), input.isError(present))\n          return present;\n      }\n      let prevObj;\n      if (state.obj && present && (prevObj = input.enterObject()), present) {\n        if (state.explicit !== null) {\n          let explicit = this._decodeTag(input, state.explicit);\n          if (input.isError(explicit))\n            return explicit;\n          input = explicit;\n        }\n        let start = input.offset;\n        if (state.use === null && state.choice === null) {\n          let save;\n          state.any && (save = input.save());\n          let body = this._decodeTag(input, state.implicit !== null \? state.implicit : state.tag, state.any);\n          if (input.isError(body))\n            return body;\n          state.any \? result = input.raw(save) : input = body;\n        }\n        if (options && options.track && state.tag !== null && options.track(input.path(), start, input.length, \"tagged\"), options && options.track && state.tag !== null && options.track(input.path(), input.offset, input.length, \"content\"), state.any || (state.choice === null \? result = this._decodeGeneric(state.tag, input, options) : result = this._decodeChoice(input, options)), input.isError(result))\n          return result;\n        if (!state.any && state.choice === null && state.children !== null && state.children.forEach(function(child) {\n          child._decode(input, options);\n        }), state.contains && (state.tag === \"octstr\" || state.tag === \"bitstr\")) {\n          let data = new DecoderBuffer(result);\n          result = this._getUse(state.contains, input._reporterState.obj)._decode(data, options);\n        }\n      }\n      return state.obj && present && (result = input.leaveObject(prevObj)), state.key !== null && (result !== null || present === !0) \? input.leaveKey(prevKey, state.key, result) : prevKey !== null && input.exitKey(prevKey), result;\n    }, Node.prototype._decodeGeneric = function(tag, input, options) {\n      let state = this._baseState;\n      return tag === \"seq\" || tag === \"set\" \? null : tag === \"seqof\" || tag === \"setof\" \? this._decodeList(input, tag, state.args[0], options) : /str$/.test(tag) \? this._decodeStr(input, tag, options) : tag === \"objid\" && state.args \? this._decodeObjid(input, state.args[0], state.args[1], options) : tag === \"objid\" \? this._decodeObjid(input, null, null, options) : tag === \"gentime\" || tag === \"utctime\" \? this._decodeTime(input, tag, options) : tag === \"null_\" \? this._decodeNull(input, options) : tag === \"bool\" \? this._decodeBool(input, options) : tag === \"objDesc\" \? this._decodeStr(input, tag, options) : tag === \"int\" || tag === \"enum\" \? this._decodeInt(input, state.args && state.args[0], options) : state.use !== null \? this._getUse(state.use, input._reporterState.obj)._decode(input, options) : input.error(\"unknown tag: \" + tag);\n    }, Node.prototype._getUse = function(entity, obj) {\n      let state = this._baseState;\n      return state.useDecoder = this._use(entity, obj), assert(state.useDecoder._baseState.parent === null), state.useDecoder = state.useDecoder._baseState.children[0], state.implicit !== state.useDecoder._baseState.implicit && (state.useDecoder = state.useDecoder.clone(), state.useDecoder._baseState.implicit = state.implicit), state.useDecoder;\n    }, Node.prototype._decodeChoice = function(input, options) {\n      let state = this._baseState, result = null, match = !1;\n      return Object.keys(state.choice).some(function(key) {\n        let save = input.save(), node = state.choice[key];\n        try {\n          let value = node._decode(input, options);\n          if (input.isError(value))\n            return !1;\n          result = { type: key, value }, match = !0;\n        } catch {\n          return input.restore(save), !1;\n        }\n        return !0;\n      }, this), match \? result : input.error(\"Choice not matched\");\n    }, Node.prototype._createEncoderBuffer = function(data) {\n      return new EncoderBuffer(data, this.reporter);\n    }, Node.prototype._encode = function(data, reporter, parent) {\n      let state = this._baseState;\n      if (state.default !== null && state.default === data)\n        return;\n      let result = this._encodeValue(data, reporter, parent);\n      if (result !== void 0 && !this._skipDefault(result, reporter, parent))\n        return result;\n    }, Node.prototype._encodeValue = function(data, reporter, parent) {\n      let state = this._baseState;\n      if (state.parent === null)\n        return state.children[0]._encode(data, reporter || new Reporter);\n      let result = null;\n      if (this.reporter = reporter, state.optional && data === void 0)\n        if (state.default !== null)\n          data = state.default;\n        else\n          return;\n      let content = null, primitive = !1;\n      if (state.any)\n        result = this._createEncoderBuffer(data);\n      else if (state.choice)\n        result = this._encodeChoice(data, reporter);\n      else if (state.contains)\n        content = this._getUse(state.contains, parent)._encode(data, reporter), primitive = !0;\n      else if (state.children)\n        content = state.children.map(function(child) {\n          if (child._baseState.tag === \"null_\")\n            return child._encode(null, reporter, data);\n          if (child._baseState.key === null)\n            return reporter.error(\"Child should have a key\");\n          let prevKey = reporter.enterKey(child._baseState.key);\n          if (typeof data != \"object\")\n            return reporter.error(\"Child expected, but input is not object\");\n          let res = child._encode(data[child._baseState.key], reporter, data);\n          return reporter.leaveKey(prevKey), res;\n        }, this).filter(function(child) {\n          return child;\n        }), content = this._createEncoderBuffer(content);\n      else if (state.tag === \"seqof\" || state.tag === \"setof\") {\n        if (!(state.args && state.args.length === 1))\n          return reporter.error(\"Too many args for : \" + state.tag);\n        if (!Array.isArray(data))\n          return reporter.error(\"seqof/setof, but data is not Array\");\n        let child = this.clone();\n        child._baseState.implicit = null, content = this._createEncoderBuffer(data.map(function(item) {\n          let state2 = this._baseState;\n          return this._getUse(state2.args[0], data)._encode(item, reporter);\n        }, child));\n      } else\n        state.use !== null \? result = this._getUse(state.use, parent)._encode(data, reporter) : (content = this._encodePrimitive(state.tag, data), primitive = !0);\n      if (!state.any && state.choice === null) {\n        let tag = state.implicit !== null \? state.implicit : state.tag, cls = state.implicit === null \? \"universal\" : \"context\";\n        tag === null \? state.use === null && reporter.error(\"Tag could be omitted only for .use()\") : state.use === null && (result = this._encodeComposite(tag, primitive, cls, content));\n      }\n      return state.explicit !== null && (result = this._encodeComposite(state.explicit, !1, \"context\", result)), result;\n    }, Node.prototype._encodeChoice = function(data, reporter) {\n      let state = this._baseState, node = state.choice[data.type];\n      return node || assert(!1, data.type + \" not found in \" + JSON.stringify(Object.keys(state.choice))), node._encode(data.value, reporter);\n    }, Node.prototype._encodePrimitive = function(tag, data) {\n      let state = this._baseState;\n      if (/str$/.test(tag))\n        return this._encodeStr(data, tag);\n      if (tag === \"objid\" && state.args)\n        return this._encodeObjid(data, state.reverseArgs[0], state.args[1]);\n      if (tag === \"objid\")\n        return this._encodeObjid(data, null, null);\n      if (tag === \"gentime\" || tag === \"utctime\")\n        return this._encodeTime(data, tag);\n      if (tag === \"null_\")\n        return this._encodeNull();\n      if (tag === \"int\" || tag === \"enum\")\n        return this._encodeInt(data, state.args && state.reverseArgs[0]);\n      if (tag === \"bool\")\n        return this._encodeBool(data);\n      if (tag === \"objDesc\")\n        return this._encodeStr(data, tag);\n      throw new Error(\"Unsupported tag: \" + tag);\n    }, Node.prototype._isNumstr = function(str) {\n      return /^[0-9 ]*$/.test(str);\n    }, Node.prototype._isPrintstr = function(str) {\n      return /^[A-Za-z0-9 '()+,-./:=\?]*$/.test(str);\n    };\n  }\n}), require_der = __commonJS({\n  \"node_modules/asn1.js/lib/asn1/constants/der.js\"(exports) {\n    function reverse(map) {\n      let res = {};\n      return Object.keys(map).forEach(function(key) {\n        (key | 0) == key && (key = key | 0);\n        let value = map[key];\n        res[value] = key;\n      }), res;\n    }\n    exports.tagClass = {\n      0: \"universal\",\n      1: \"application\",\n      2: \"context\",\n      3: \"private\"\n    }, exports.tagClassByName = reverse(exports.tagClass), exports.tag = {\n      0: \"end\",\n      1: \"bool\",\n      2: \"int\",\n      3: \"bitstr\",\n      4: \"octstr\",\n      5: \"null_\",\n      6: \"objid\",\n      7: \"objDesc\",\n      8: \"external\",\n      9: \"real\",\n      10: \"enum\",\n      11: \"embed\",\n      12: \"utf8str\",\n      13: \"relativeOid\",\n      16: \"seq\",\n      17: \"set\",\n      18: \"numstr\",\n      19: \"printstr\",\n      20: \"t61str\",\n      21: \"videostr\",\n      22: \"ia5str\",\n      23: \"utctime\",\n      24: \"gentime\",\n      25: \"graphstr\",\n      26: \"iso646str\",\n      27: \"genstr\",\n      28: \"unistr\",\n      29: \"charstr\",\n      30: \"bmpstr\"\n    }, exports.tagByName = reverse(exports.tag);\n  }\n}), require_der2 = __commonJS({\n  \"node_modules/asn1.js/lib/asn1/encoders/der.js\"(exports, module) {\n    var inherits = require_inherits_browser(), Buffer2 = require_safer().Buffer, Node = require_node(), der = require_der();\n    function DEREncoder(entity) {\n      this.enc = \"der\", this.name = entity.name, this.entity = entity, this.tree = new DERNode, this.tree._init(entity.body);\n    }\n    DEREncoder.prototype = {}, module.exports = DEREncoder, DEREncoder.prototype.encode = function(data, reporter) {\n      return this.tree._encode(data, reporter).join();\n    };\n    function DERNode(parent) {\n      Node.call(this, \"der\", parent);\n    }\n    inherits(DERNode, Node), DERNode.prototype._encodeComposite = function(tag, primitive, cls, content) {\n      let encodedTag = encodeTag(tag, primitive, cls, this.reporter);\n      if (content.length < 128) {\n        let header2 = Buffer2.alloc(2);\n        return header2[0] = encodedTag, header2[1] = content.length, this._createEncoderBuffer([header2, content]);\n      }\n      let lenOctets = 1;\n      for (let i = content.length;i >= 256; i >>= 8)\n        lenOctets++;\n      let header = Buffer2.alloc(2 + lenOctets);\n      header[0] = encodedTag, header[1] = 128 | lenOctets;\n      for (let i = 1 + lenOctets, j = content.length;j > 0; i--, j >>= 8)\n        header[i] = j & 255;\n      return this._createEncoderBuffer([header, content]);\n    }, DERNode.prototype._encodeStr = function(str, tag) {\n      if (tag === \"bitstr\")\n        return this._createEncoderBuffer([str.unused | 0, str.data]);\n      if (tag === \"bmpstr\") {\n        let buf = Buffer2.alloc(str.length * 2);\n        for (let i = 0;i < str.length; i++)\n          buf.writeUInt16BE(str.charCodeAt(i), i * 2);\n        return this._createEncoderBuffer(buf);\n      } else\n        return tag === \"numstr\" \? this._isNumstr(str) \? this._createEncoderBuffer(str) : this.reporter.error(\"Encoding of string type: numstr supports only digits and space\") : tag === \"printstr\" \? this._isPrintstr(str) \? this._createEncoderBuffer(str) : this.reporter.error(\"Encoding of string type: printstr supports only latin upper and lower case letters, digits, space, apostrophe, left and rigth parenthesis, plus sign, comma, hyphen, dot, slash, colon, equal sign, question mark\") : /str$/.test(tag) \? this._createEncoderBuffer(str) : tag === \"objDesc\" \? this._createEncoderBuffer(str) : this.reporter.error(\"Encoding of string type: \" + tag + \" unsupported\");\n    }, DERNode.prototype._encodeObjid = function(id, values, relative) {\n      if (typeof id == \"string\") {\n        if (!values)\n          return this.reporter.error(\"string objid given, but no values map found\");\n        if (!values.hasOwnProperty(id))\n          return this.reporter.error(\"objid not found in values map\");\n        id = values[id].split(/[\\s.]+/g);\n        for (let i = 0;i < id.length; i++)\n          id[i] |= 0;\n      } else if (Array.isArray(id)) {\n        id = id.slice();\n        for (let i = 0;i < id.length; i++)\n          id[i] |= 0;\n      }\n      if (!Array.isArray(id))\n        return this.reporter.error(\"objid() should be either array or string, got: \" + JSON.stringify(id));\n      if (!relative) {\n        if (id[1] >= 40)\n          return this.reporter.error(\"Second objid identifier OOB\");\n        id.splice(0, 2, id[0] * 40 + id[1]);\n      }\n      let size = 0;\n      for (let i = 0;i < id.length; i++) {\n        let ident = id[i];\n        for (size++;ident >= 128; ident >>= 7)\n          size++;\n      }\n      let objid = Buffer2.alloc(size), offset = objid.length - 1;\n      for (let i = id.length - 1;i >= 0; i--) {\n        let ident = id[i];\n        for (objid[offset--] = ident & 127;(ident >>= 7) > 0; )\n          objid[offset--] = 128 | ident & 127;\n      }\n      return this._createEncoderBuffer(objid);\n    };\n    function two(num) {\n      return num < 10 \? \"0\" + num : num;\n    }\n    DERNode.prototype._encodeTime = function(time, tag) {\n      let str, date = new Date(time);\n      return tag === \"gentime\" \? str = [\n        two(date.getUTCFullYear()),\n        two(date.getUTCMonth() + 1),\n        two(date.getUTCDate()),\n        two(date.getUTCHours()),\n        two(date.getUTCMinutes()),\n        two(date.getUTCSeconds()),\n        \"Z\"\n      ].join(\"\") : tag === \"utctime\" \? str = [\n        two(date.getUTCFullYear() % 100),\n        two(date.getUTCMonth() + 1),\n        two(date.getUTCDate()),\n        two(date.getUTCHours()),\n        two(date.getUTCMinutes()),\n        two(date.getUTCSeconds()),\n        \"Z\"\n      ].join(\"\") : this.reporter.error(\"Encoding \" + tag + \" time is not supported yet\"), this._encodeStr(str, \"octstr\");\n    }, DERNode.prototype._encodeNull = function() {\n      return this._createEncoderBuffer(\"\");\n    }, DERNode.prototype._encodeInt = function(num, values) {\n      if (typeof num == \"string\") {\n        if (!values)\n          return this.reporter.error(\"String int or enum given, but no values map\");\n        if (!values.hasOwnProperty(num))\n          return this.reporter.error(\"Values map doesn't contain: \" + JSON.stringify(num));\n        num = values[num];\n      }\n      if (typeof num != \"number\" && !Buffer2.isBuffer(num)) {\n        let numArray = num.toArray();\n        !num.sign && numArray[0] & 128 && numArray.unshift(0), num = Buffer2.from(numArray);\n      }\n      if (Buffer2.isBuffer(num)) {\n        let size2 = num.length;\n        num.length === 0 && size2++;\n        let out2 = Buffer2.alloc(size2);\n        return num.copy(out2), num.length === 0 && (out2[0] = 0), this._createEncoderBuffer(out2);\n      }\n      if (num < 128)\n        return this._createEncoderBuffer(num);\n      if (num < 256)\n        return this._createEncoderBuffer([0, num]);\n      let size = 1;\n      for (let i = num;i >= 256; i >>= 8)\n        size++;\n      let out = new Array(size);\n      for (let i = out.length - 1;i >= 0; i--)\n        out[i] = num & 255, num >>= 8;\n      return out[0] & 128 && out.unshift(0), this._createEncoderBuffer(Buffer2.from(out));\n    }, DERNode.prototype._encodeBool = function(value) {\n      return this._createEncoderBuffer(value \? 255 : 0);\n    }, DERNode.prototype._use = function(entity, obj) {\n      return typeof entity == \"function\" && (entity = entity(obj)), entity._getEncoder(\"der\").tree;\n    }, DERNode.prototype._skipDefault = function(dataBuffer, reporter, parent) {\n      let state = this._baseState, i;\n      if (state.default === null)\n        return !1;\n      let data = dataBuffer.join();\n      if (state.defaultBuffer === void 0 && (state.defaultBuffer = this._encodeValue(state.default, reporter, parent).join()), data.length !== state.defaultBuffer.length)\n        return !1;\n      for (i = 0;i < data.length; i++)\n        if (data[i] !== state.defaultBuffer[i])\n          return !1;\n      return !0;\n    };\n    function encodeTag(tag, primitive, cls, reporter) {\n      let res;\n      if (tag === \"seqof\" \? tag = \"seq\" : tag === \"setof\" && (tag = \"set\"), der.tagByName.hasOwnProperty(tag))\n        res = der.tagByName[tag];\n      else if (typeof tag == \"number\" && (tag | 0) === tag)\n        res = tag;\n      else\n        return reporter.error(\"Unknown tag: \" + tag);\n      return res >= 31 \? reporter.error(\"Multi-octet tag encoding unsupported\") : (primitive || (res |= 32), res |= der.tagClassByName[cls || \"universal\"] << 6, res);\n    }\n  }\n}), require_pem = __commonJS({\n  \"node_modules/asn1.js/lib/asn1/encoders/pem.js\"(exports, module) {\n    var inherits = require_inherits_browser(), DEREncoder = require_der2();\n    function PEMEncoder(entity) {\n      DEREncoder.call(this, entity), this.enc = \"pem\";\n    }\n    inherits(PEMEncoder, DEREncoder), module.exports = PEMEncoder, PEMEncoder.prototype.encode = function(data, options) {\n      let p = DEREncoder.prototype.encode.call(this, data).toString(\"base64\"), out = [\"-----BEGIN \" + options.label + \"-----\"];\n      for (let i = 0;i < p.length; i += 64)\n        out.push(p.slice(i, i + 64));\n      return out.push(\"-----END \" + options.label + \"-----\"), out.join(`\n`);\n    };\n  }\n}), require_encoders = __commonJS({\n  \"node_modules/asn1.js/lib/asn1/encoders/index.js\"(exports) {\n    var encoders = exports;\n    encoders.der = require_der2(), encoders.pem = require_pem();\n  }\n}), require_der3 = __commonJS({\n  \"node_modules/asn1.js/lib/asn1/decoders/der.js\"(exports, module) {\n    var inherits = require_inherits_browser(), bignum = require_bn5(), DecoderBuffer = require_buffer().DecoderBuffer, Node = require_node(), der = require_der();\n    function DERDecoder(entity) {\n      this.enc = \"der\", this.name = entity.name, this.entity = entity, this.tree = new DERNode, this.tree._init(entity.body);\n    }\n    DERDecoder.prototype = {}, module.exports = DERDecoder, DERDecoder.prototype.decode = function(data, options) {\n      return DecoderBuffer.isDecoderBuffer(data) || (data = new DecoderBuffer(data, options)), this.tree._decode(data, options);\n    };\n    function DERNode(parent) {\n      Node.call(this, \"der\", parent);\n    }\n    inherits(DERNode, Node), DERNode.prototype._peekTag = function(buffer, tag, any) {\n      if (buffer.isEmpty())\n        return !1;\n      let state = buffer.save(), decodedTag = derDecodeTag(buffer, 'Failed to peek tag: \"' + tag + '\"');\n      return buffer.isError(decodedTag) \? decodedTag : (buffer.restore(state), decodedTag.tag === tag || decodedTag.tagStr === tag || decodedTag.tagStr + \"of\" === tag || any);\n    }, DERNode.prototype._decodeTag = function(buffer, tag, any) {\n      let decodedTag = derDecodeTag(buffer, 'Failed to decode tag of \"' + tag + '\"');\n      if (buffer.isError(decodedTag))\n        return decodedTag;\n      let len = derDecodeLen(buffer, decodedTag.primitive, 'Failed to get length of \"' + tag + '\"');\n      if (buffer.isError(len))\n        return len;\n      if (!any && decodedTag.tag !== tag && decodedTag.tagStr !== tag && decodedTag.tagStr + \"of\" !== tag)\n        return buffer.error('Failed to match tag: \"' + tag + '\"');\n      if (decodedTag.primitive || len !== null)\n        return buffer.skip(len, 'Failed to match body of: \"' + tag + '\"');\n      let state = buffer.save(), res = this._skipUntilEnd(buffer, 'Failed to skip indefinite length body: \"' + this.tag + '\"');\n      return buffer.isError(res) \? res : (len = buffer.offset - state.offset, buffer.restore(state), buffer.skip(len, 'Failed to match body of: \"' + tag + '\"'));\n    }, DERNode.prototype._skipUntilEnd = function(buffer, fail) {\n      for (;; ) {\n        let tag = derDecodeTag(buffer, fail);\n        if (buffer.isError(tag))\n          return tag;\n        let len = derDecodeLen(buffer, tag.primitive, fail);\n        if (buffer.isError(len))\n          return len;\n        let res;\n        if (tag.primitive || len !== null \? res = buffer.skip(len) : res = this._skipUntilEnd(buffer, fail), buffer.isError(res))\n          return res;\n        if (tag.tagStr === \"end\")\n          break;\n      }\n    }, DERNode.prototype._decodeList = function(buffer, tag, decoder, options) {\n      let result = [];\n      for (;!buffer.isEmpty(); ) {\n        let possibleEnd = this._peekTag(buffer, \"end\");\n        if (buffer.isError(possibleEnd))\n          return possibleEnd;\n        let res = decoder.decode(buffer, \"der\", options);\n        if (buffer.isError(res) && possibleEnd)\n          break;\n        result.push(res);\n      }\n      return result;\n    }, DERNode.prototype._decodeStr = function(buffer, tag) {\n      if (tag === \"bitstr\") {\n        let unused = buffer.readUInt8();\n        return buffer.isError(unused) \? unused : { unused, data: buffer.raw() };\n      } else if (tag === \"bmpstr\") {\n        let raw = buffer.raw();\n        if (raw.length % 2 === 1)\n          return buffer.error(\"Decoding of string type: bmpstr length mismatch\");\n        let str = \"\";\n        for (let i = 0;i < raw.length / 2; i++)\n          str += String.fromCharCode(raw.readUInt16BE(i * 2));\n        return str;\n      } else if (tag === \"numstr\") {\n        let numstr = buffer.raw().toString(\"ascii\");\n        return this._isNumstr(numstr) \? numstr : buffer.error(\"Decoding of string type: numstr unsupported characters\");\n      } else {\n        if (tag === \"octstr\")\n          return buffer.raw();\n        if (tag === \"objDesc\")\n          return buffer.raw();\n        if (tag === \"printstr\") {\n          let printstr = buffer.raw().toString(\"ascii\");\n          return this._isPrintstr(printstr) \? printstr : buffer.error(\"Decoding of string type: printstr unsupported characters\");\n        } else\n          return /str$/.test(tag) \? buffer.raw().toString() : buffer.error(\"Decoding of string type: \" + tag + \" unsupported\");\n      }\n    }, DERNode.prototype._decodeObjid = function(buffer, values, relative) {\n      let result, identifiers = [], ident = 0, subident = 0;\n      for (;!buffer.isEmpty(); )\n        subident = buffer.readUInt8(), ident <<= 7, ident |= subident & 127, (subident & 128) === 0 && (identifiers.push(ident), ident = 0);\n      subident & 128 && identifiers.push(ident);\n      let first = identifiers[0] / 40 | 0, second = identifiers[0] % 40;\n      if (relative \? result = identifiers : result = [first, second].concat(identifiers.slice(1)), values) {\n        let tmp = values[result.join(\" \")];\n        tmp === void 0 && (tmp = values[result.join(\".\")]), tmp !== void 0 && (result = tmp);\n      }\n      return result;\n    }, DERNode.prototype._decodeTime = function(buffer, tag) {\n      let str = buffer.raw().toString(), year, mon, day, hour, min, sec;\n      if (tag === \"gentime\")\n        year = str.slice(0, 4) | 0, mon = str.slice(4, 6) | 0, day = str.slice(6, 8) | 0, hour = str.slice(8, 10) | 0, min = str.slice(10, 12) | 0, sec = str.slice(12, 14) | 0;\n      else if (tag === \"utctime\")\n        year = str.slice(0, 2) | 0, mon = str.slice(2, 4) | 0, day = str.slice(4, 6) | 0, hour = str.slice(6, 8) | 0, min = str.slice(8, 10) | 0, sec = str.slice(10, 12) | 0, year < 70 \? year = 2000 + year : year = 1900 + year;\n      else\n        return buffer.error(\"Decoding \" + tag + \" time is not supported yet\");\n      return Date.UTC(year, mon - 1, day, hour, min, sec, 0);\n    }, DERNode.prototype._decodeNull = function() {\n      return null;\n    }, DERNode.prototype._decodeBool = function(buffer) {\n      let res = buffer.readUInt8();\n      return buffer.isError(res) \? res : res !== 0;\n    }, DERNode.prototype._decodeInt = function(buffer, values) {\n      let raw = buffer.raw(), res = new bignum(raw);\n      return values && (res = values[res.toString(10)] || res), res;\n    }, DERNode.prototype._use = function(entity, obj) {\n      return typeof entity == \"function\" && (entity = entity(obj)), entity._getDecoder(\"der\").tree;\n    };\n    function derDecodeTag(buf, fail) {\n      let tag = buf.readUInt8(fail);\n      if (buf.isError(tag))\n        return tag;\n      let cls = der.tagClass[tag >> 6], primitive = (tag & 32) === 0;\n      if ((tag & 31) === 31) {\n        let oct = tag;\n        for (tag = 0;(oct & 128) === 128; ) {\n          if (oct = buf.readUInt8(fail), buf.isError(oct))\n            return oct;\n          tag <<= 7, tag |= oct & 127;\n        }\n      } else\n        tag &= 31;\n      let tagStr = der.tag[tag];\n      return {\n        cls,\n        primitive,\n        tag,\n        tagStr\n      };\n    }\n    function derDecodeLen(buf, primitive, fail) {\n      let len = buf.readUInt8(fail);\n      if (buf.isError(len))\n        return len;\n      if (!primitive && len === 128)\n        return null;\n      if ((len & 128) === 0)\n        return len;\n      let num = len & 127;\n      if (num > 4)\n        return buf.error(\"length octect is too long\");\n      len = 0;\n      for (let i = 0;i < num; i++) {\n        len <<= 8;\n        let j = buf.readUInt8(fail);\n        if (buf.isError(j))\n          return j;\n        len |= j;\n      }\n      return len;\n    }\n  }\n}), require_pem2 = __commonJS({\n  \"node_modules/asn1.js/lib/asn1/decoders/pem.js\"(exports, module) {\n    var inherits = require_inherits_browser(), Buffer2 = require_safer().Buffer, DERDecoder = require_der3();\n    function PEMDecoder(entity) {\n      DERDecoder.call(this, entity), this.enc = \"pem\";\n    }\n    inherits(PEMDecoder, DERDecoder), module.exports = PEMDecoder, PEMDecoder.prototype.decode = function(data, options) {\n      let lines = data.toString().split(/[\\r\\n]+/g), label = options.label.toUpperCase(), re = /^-----(BEGIN|END) ([^-]+)-----$/, start = -1, end = -1;\n      for (let i = 0;i < lines.length; i++) {\n        let match = lines[i].match(re);\n        if (match !== null && match[2] === label)\n          if (start === -1) {\n            if (match[1] !== \"BEGIN\")\n              break;\n            start = i;\n          } else {\n            if (match[1] !== \"END\")\n              break;\n            end = i;\n            break;\n          }\n      }\n      if (start === -1 || end === -1)\n        throw new Error(\"PEM section not found for: \" + label);\n      let base64 = lines.slice(start + 1, end).join(\"\");\n      base64.replace(/[^a-z0-9+/=]+/gi, \"\");\n      let input = Buffer2.from(base64, \"base64\");\n      return DERDecoder.prototype.decode.call(this, input, options);\n    };\n  }\n}), require_decoders = __commonJS({\n  \"node_modules/asn1.js/lib/asn1/decoders/index.js\"(exports) {\n    var decoders = exports;\n    decoders.der = require_der3(), decoders.pem = require_pem2();\n  }\n}), require_api = __commonJS({\n  \"node_modules/asn1.js/lib/asn1/api.js\"(exports) {\n    var encoders = require_encoders(), decoders = require_decoders(), inherits = require_inherits_browser(), api = exports;\n    api.define = function(name, body) {\n      return new Entity(name, body);\n    };\n    function Entity(name, body) {\n      this.name = name, this.body = body, this.decoders = {}, this.encoders = {};\n    }\n    Entity.prototype = {}, Entity.prototype._createNamed = function(Base) {\n      let name = this.name;\n      function Generated(entity) {\n        this._initNamed(entity, name);\n      }\n      return inherits(Generated, Base), Generated.prototype._initNamed = function(entity, name2) {\n        Base.call(this, entity, name2);\n      }, new Generated(this);\n    }, Entity.prototype._getDecoder = function(enc) {\n      return enc = enc || \"der\", this.decoders.hasOwnProperty(enc) || (this.decoders[enc] = this._createNamed(decoders[enc])), this.decoders[enc];\n    }, Entity.prototype.decode = function(data, enc, options) {\n      return this._getDecoder(enc).decode(data, options);\n    }, Entity.prototype._getEncoder = function(enc) {\n      return enc = enc || \"der\", this.encoders.hasOwnProperty(enc) || (this.encoders[enc] = this._createNamed(encoders[enc])), this.encoders[enc];\n    }, Entity.prototype.encode = function(data, enc, reporter) {\n      return this._getEncoder(enc).encode(data, reporter);\n    };\n  }\n}), require_base2 = __commonJS({\n  \"node_modules/asn1.js/lib/asn1/base/index.js\"(exports) {\n    var base = exports;\n    base.Reporter = require_reporter().Reporter, base.DecoderBuffer = require_buffer().DecoderBuffer, base.EncoderBuffer = require_buffer().EncoderBuffer, base.Node = require_node();\n  }\n}), require_constants = __commonJS({\n  \"node_modules/asn1.js/lib/asn1/constants/index.js\"(exports) {\n    var constants = exports;\n    constants._reverse = function(map) {\n      let res = {};\n      return Object.keys(map).forEach(function(key) {\n        (key | 0) == key && (key = key | 0);\n        let value = map[key];\n        res[value] = key;\n      }), res;\n    }, constants.der = require_der();\n  }\n}), require_asn1 = __commonJS({\n  \"node_modules/asn1.js/lib/asn1.js\"(exports) {\n    var asn1 = exports;\n    asn1.bignum = require_bn5(), asn1.define = require_api().define, asn1.base = require_base2(), asn1.constants = require_constants(), asn1.decoders = require_decoders(), asn1.encoders = require_encoders();\n  }\n}), require_certificate = __commonJS({\n  \"node_modules/parse-asn1/certificate.js\"(exports, module) {\n    var asn = require_asn1(), Time = asn.define(\"Time\", function() {\n      this.choice({\n        utcTime: this.utctime(),\n        generalTime: this.gentime()\n      });\n    }), AttributeTypeValue = asn.define(\"AttributeTypeValue\", function() {\n      this.seq().obj(this.key(\"type\").objid(), this.key(\"value\").any());\n    }), AlgorithmIdentifier = asn.define(\"AlgorithmIdentifier\", function() {\n      this.seq().obj(this.key(\"algorithm\").objid(), this.key(\"parameters\").optional(), this.key(\"curve\").objid().optional());\n    }), SubjectPublicKeyInfo = asn.define(\"SubjectPublicKeyInfo\", function() {\n      this.seq().obj(this.key(\"algorithm\").use(AlgorithmIdentifier), this.key(\"subjectPublicKey\").bitstr());\n    }), RelativeDistinguishedName = asn.define(\"RelativeDistinguishedName\", function() {\n      this.setof(AttributeTypeValue);\n    }), RDNSequence = asn.define(\"RDNSequence\", function() {\n      this.seqof(RelativeDistinguishedName);\n    }), Name = asn.define(\"Name\", function() {\n      this.choice({\n        rdnSequence: this.use(RDNSequence)\n      });\n    }), Validity = asn.define(\"Validity\", function() {\n      this.seq().obj(this.key(\"notBefore\").use(Time), this.key(\"notAfter\").use(Time));\n    }), Extension = asn.define(\"Extension\", function() {\n      this.seq().obj(this.key(\"extnID\").objid(), this.key(\"critical\").bool().def(!1), this.key(\"extnValue\").octstr());\n    }), TBSCertificate = asn.define(\"TBSCertificate\", function() {\n      this.seq().obj(this.key(\"version\").explicit(0).int().optional(), this.key(\"serialNumber\").int(), this.key(\"signature\").use(AlgorithmIdentifier), this.key(\"issuer\").use(Name), this.key(\"validity\").use(Validity), this.key(\"subject\").use(Name), this.key(\"subjectPublicKeyInfo\").use(SubjectPublicKeyInfo), this.key(\"issuerUniqueID\").implicit(1).bitstr().optional(), this.key(\"subjectUniqueID\").implicit(2).bitstr().optional(), this.key(\"extensions\").explicit(3).seqof(Extension).optional());\n    }), X509Certificate = asn.define(\"X509Certificate\", function() {\n      this.seq().obj(this.key(\"tbsCertificate\").use(TBSCertificate), this.key(\"signatureAlgorithm\").use(AlgorithmIdentifier), this.key(\"signatureValue\").bitstr());\n    });\n    module.exports = X509Certificate;\n  }\n}), require_asn12 = __commonJS({\n  \"node_modules/parse-asn1/asn1.js\"(exports) {\n    var asn1 = require_asn1();\n    exports.certificate = require_certificate();\n    var RSAPrivateKey = asn1.define(\"RSAPrivateKey\", function() {\n      this.seq().obj(this.key(\"version\").int(), this.key(\"modulus\").int(), this.key(\"publicExponent\").int(), this.key(\"privateExponent\").int(), this.key(\"prime1\").int(), this.key(\"prime2\").int(), this.key(\"exponent1\").int(), this.key(\"exponent2\").int(), this.key(\"coefficient\").int());\n    });\n    exports.RSAPrivateKey = RSAPrivateKey;\n    var RSAPublicKey = asn1.define(\"RSAPublicKey\", function() {\n      this.seq().obj(this.key(\"modulus\").int(), this.key(\"publicExponent\").int());\n    });\n    exports.RSAPublicKey = RSAPublicKey;\n    var PublicKey = asn1.define(\"SubjectPublicKeyInfo\", function() {\n      this.seq().obj(this.key(\"algorithm\").use(AlgorithmIdentifier), this.key(\"subjectPublicKey\").bitstr());\n    });\n    exports.PublicKey = PublicKey;\n    var AlgorithmIdentifier = asn1.define(\"AlgorithmIdentifier\", function() {\n      this.seq().obj(this.key(\"algorithm\").objid(), this.key(\"none\").null_().optional(), this.key(\"curve\").objid().optional(), this.key(\"params\").seq().obj(this.key(\"p\").int(), this.key(\"q\").int(), this.key(\"g\").int()).optional());\n    }), PrivateKeyInfo = asn1.define(\"PrivateKeyInfo\", function() {\n      this.seq().obj(this.key(\"version\").int(), this.key(\"algorithm\").use(AlgorithmIdentifier), this.key(\"subjectPrivateKey\").octstr());\n    });\n    exports.PrivateKey = PrivateKeyInfo;\n    var EncryptedPrivateKeyInfo = asn1.define(\"EncryptedPrivateKeyInfo\", function() {\n      this.seq().obj(this.key(\"algorithm\").seq().obj(this.key(\"id\").objid(), this.key(\"decrypt\").seq().obj(this.key(\"kde\").seq().obj(this.key(\"id\").objid(), this.key(\"kdeparams\").seq().obj(this.key(\"salt\").octstr(), this.key(\"iters\").int())), this.key(\"cipher\").seq().obj(this.key(\"algo\").objid(), this.key(\"iv\").octstr()))), this.key(\"subjectPrivateKey\").octstr());\n    });\n    exports.EncryptedPrivateKey = EncryptedPrivateKeyInfo;\n    var DSAPrivateKey = asn1.define(\"DSAPrivateKey\", function() {\n      this.seq().obj(this.key(\"version\").int(), this.key(\"p\").int(), this.key(\"q\").int(), this.key(\"g\").int(), this.key(\"pub_key\").int(), this.key(\"priv_key\").int());\n    });\n    exports.DSAPrivateKey = DSAPrivateKey, exports.DSAparam = asn1.define(\"DSAparam\", function() {\n      this.int();\n    });\n    var ECPrivateKey = asn1.define(\"ECPrivateKey\", function() {\n      this.seq().obj(this.key(\"version\").int(), this.key(\"privateKey\").octstr(), this.key(\"parameters\").optional().explicit(0).use(ECParameters), this.key(\"publicKey\").optional().explicit(1).bitstr());\n    });\n    exports.ECPrivateKey = ECPrivateKey;\n    var ECParameters = asn1.define(\"ECParameters\", function() {\n      this.choice({\n        namedCurve: this.objid()\n      });\n    });\n    exports.signature = asn1.define(\"signature\", function() {\n      this.seq().obj(this.key(\"r\").int(), this.key(\"s\").int());\n    });\n  }\n}), require_aesid = __commonJS({\n  \"node_modules/parse-asn1/aesid.json\"(exports, module) {\n    module.exports = {\n      \"2.16.840.1.101.3.4.1.1\": \"aes-128-ecb\",\n      \"2.16.840.1.101.3.4.1.2\": \"aes-128-cbc\",\n      \"2.16.840.1.101.3.4.1.3\": \"aes-128-ofb\",\n      \"2.16.840.1.101.3.4.1.4\": \"aes-128-cfb\",\n      \"2.16.840.1.101.3.4.1.21\": \"aes-192-ecb\",\n      \"2.16.840.1.101.3.4.1.22\": \"aes-192-cbc\",\n      \"2.16.840.1.101.3.4.1.23\": \"aes-192-ofb\",\n      \"2.16.840.1.101.3.4.1.24\": \"aes-192-cfb\",\n      \"2.16.840.1.101.3.4.1.41\": \"aes-256-ecb\",\n      \"2.16.840.1.101.3.4.1.42\": \"aes-256-cbc\",\n      \"2.16.840.1.101.3.4.1.43\": \"aes-256-ofb\",\n      \"2.16.840.1.101.3.4.1.44\": \"aes-256-cfb\"\n    };\n  }\n}), require_fixProc = __commonJS({\n  \"node_modules/parse-asn1/fixProc.js\"(exports, module) {\n    var findProc = /Proc-Type: 4,ENCRYPTED[\\n\\r]+DEK-Info: AES-((\?:128)|(\?:192)|(\?:256))-CBC,([0-9A-H]+)[\\n\\r]+([0-9A-z\\n\\r+/=]+)[\\n\\r]+/m, startRegex = /^-----BEGIN ((\?:.*\? KEY)|CERTIFICATE)-----/m, fullRegex = /^-----BEGIN ((\?:.*\? KEY)|CERTIFICATE)-----([0-9A-z\\n\\r+/=]+)-----END \\1-----$/m, evp = require_evp_bytestokey(), ciphers = require_browser5(), Buffer2 = require_safe_buffer().Buffer;\n    module.exports = function(okey, password) {\n      var key = okey.toString(), match = key.match(findProc), decrypted;\n      if (match) {\n        var suite = \"aes\" + match[1], iv = Buffer2.from(match[2], \"hex\"), cipherText = Buffer2.from(match[3].replace(/[\\r\\n]/g, \"\"), \"base64\"), cipherKey = evp(password, iv.slice(0, 8), parseInt(match[1], 10)).key, out = [], cipher = ciphers.createDecipheriv(suite, cipherKey, iv);\n        out.push(cipher.update(cipherText)), out.push(cipher.final()), decrypted = Buffer2.concat(out);\n      } else {\n        var match2 = key.match(fullRegex);\n        decrypted = Buffer2.from(match2[2].replace(/[\\r\\n]/g, \"\"), \"base64\");\n      }\n      var tag = key.match(startRegex)[1];\n      return {\n        tag,\n        data: decrypted\n      };\n    };\n  }\n}), require_parse_asn1 = __commonJS({\n  \"node_modules/parse-asn1/index.js\"(exports, module) {\n    var asn1 = require_asn12(), aesid = require_aesid(), fixProc = require_fixProc(), ciphers = require_browser5(), compat = require_browser4(), Buffer2 = require_safe_buffer().Buffer;\n    module.exports = parseKeys;\n    function parseKeys(buffer) {\n      var password;\n      typeof buffer == \"object\" && !Buffer2.isBuffer(buffer) && (password = buffer.passphrase, buffer = buffer.key), typeof buffer == \"string\" && (buffer = Buffer2.from(buffer));\n      var stripped = fixProc(buffer, password), type = stripped.tag, data = stripped.data, subtype, ndata;\n      switch (type) {\n        case \"CERTIFICATE\":\n          ndata = asn1.certificate.decode(data, \"der\").tbsCertificate.subjectPublicKeyInfo;\n        case \"PUBLIC KEY\":\n          switch (ndata || (ndata = asn1.PublicKey.decode(data, \"der\")), subtype = ndata.algorithm.algorithm.join(\".\"), subtype) {\n            case \"1.2.840.113549.1.1.1\":\n              return asn1.RSAPublicKey.decode(ndata.subjectPublicKey.data, \"der\");\n            case \"1.2.840.10045.2.1\":\n              return ndata.subjectPrivateKey = ndata.subjectPublicKey, {\n                type: \"ec\",\n                data: ndata\n              };\n            case \"1.2.840.10040.4.1\":\n              return ndata.algorithm.params.pub_key = asn1.DSAparam.decode(ndata.subjectPublicKey.data, \"der\"), {\n                type: \"dsa\",\n                data: ndata.algorithm.params\n              };\n            default:\n              throw new Error(\"unknown key id \" + subtype);\n          }\n        case \"ENCRYPTED PRIVATE KEY\":\n          data = asn1.EncryptedPrivateKey.decode(data, \"der\"), data = decrypt(data, password);\n        case \"PRIVATE KEY\":\n          switch (ndata = asn1.PrivateKey.decode(data, \"der\"), subtype = ndata.algorithm.algorithm.join(\".\"), subtype) {\n            case \"1.2.840.113549.1.1.1\":\n              return asn1.RSAPrivateKey.decode(ndata.subjectPrivateKey, \"der\");\n            case \"1.2.840.10045.2.1\":\n              return {\n                curve: ndata.algorithm.curve,\n                privateKey: asn1.ECPrivateKey.decode(ndata.subjectPrivateKey, \"der\").privateKey\n              };\n            case \"1.2.840.10040.4.1\":\n              return ndata.algorithm.params.priv_key = asn1.DSAparam.decode(ndata.subjectPrivateKey, \"der\"), {\n                type: \"dsa\",\n                params: ndata.algorithm.params\n              };\n            default:\n              throw new Error(\"unknown key id \" + subtype);\n          }\n        case \"RSA PUBLIC KEY\":\n          return asn1.RSAPublicKey.decode(data, \"der\");\n        case \"RSA PRIVATE KEY\":\n          return asn1.RSAPrivateKey.decode(data, \"der\");\n        case \"DSA PRIVATE KEY\":\n          return {\n            type: \"dsa\",\n            params: asn1.DSAPrivateKey.decode(data, \"der\")\n          };\n        case \"EC PRIVATE KEY\":\n          return data = asn1.ECPrivateKey.decode(data, \"der\"), {\n            curve: data.parameters.value,\n            privateKey: data.privateKey\n          };\n        default:\n          throw new Error(\"unknown key type \" + type);\n      }\n    }\n    parseKeys.signature = asn1.signature;\n    function decrypt(data, password) {\n      var salt = data.algorithm.decrypt.kde.kdeparams.salt, iters = parseInt(data.algorithm.decrypt.kde.kdeparams.iters.toString(), 10), algo = aesid[data.algorithm.decrypt.cipher.algo.join(\".\")], iv = data.algorithm.decrypt.cipher.iv, cipherText = data.subjectPrivateKey, keylen = parseInt(algo.split(\"-\")[1], 10) / 8, key = compat.pbkdf2Sync(password, salt, iters, keylen, \"sha1\"), cipher = ciphers.createDecipheriv(algo, key, iv), out = [];\n      return out.push(cipher.update(cipherText)), out.push(cipher.final()), Buffer2.concat(out);\n    }\n  }\n}), require_curves2 = __commonJS({\n  \"node_modules/browserify-sign/browser/curves.json\"(exports, module) {\n    module.exports = {\n      \"1.3.132.0.10\": \"secp256k1\",\n      \"1.3.132.0.33\": \"p224\",\n      \"1.2.840.10045.3.1.1\": \"p192\",\n      \"1.2.840.10045.3.1.7\": \"p256\",\n      \"1.3.132.0.34\": \"p384\",\n      \"1.3.132.0.35\": \"p521\"\n    };\n  }\n}), require_sign = __commonJS({\n  \"node_modules/browserify-sign/browser/sign.js\"(exports, module) {\n    var Buffer2 = require_safe_buffer().Buffer, createHmac = require_browser3(), crt = require_browserify_rsa(), EC = require_elliptic().ec, BN = require_bn3(), parseKeys = require_parse_asn1(), curves = require_curves2();\n    function sign(hash, key, hashType, signType, tag) {\n      var priv = parseKeys(key);\n      if (priv.curve) {\n        if (signType !== \"ecdsa\" && signType !== \"ecdsa/rsa\")\n          throw new Error(\"wrong private key type\");\n        return ecSign(hash, priv);\n      } else if (priv.type === \"dsa\") {\n        if (signType !== \"dsa\")\n          throw new Error(\"wrong private key type\");\n        return dsaSign(hash, priv, hashType);\n      } else if (signType !== \"rsa\" && signType !== \"ecdsa/rsa\")\n        throw new Error(\"wrong private key type\");\n      hash = Buffer2.concat([tag, hash]);\n      for (var len = priv.modulus.byteLength(), pad = [0, 1];hash.length + pad.length + 1 < len; )\n        pad.push(255);\n      pad.push(0);\n      for (var i = -1;++i < hash.length; )\n        pad.push(hash[i]);\n      var out = crt(pad, priv);\n      return out;\n    }\n    function ecSign(hash, priv) {\n      var curveId = curves[priv.curve.join(\".\")];\n      if (!curveId)\n        throw new Error(\"unknown curve \" + priv.curve.join(\".\"));\n      var curve = new EC(curveId), key = curve.keyFromPrivate(priv.privateKey), out = key.sign(hash);\n      return Buffer2.from(out.toDER());\n    }\n    function dsaSign(hash, priv, algo) {\n      for (var x = priv.params.priv_key, p = priv.params.p, q = priv.params.q, g = priv.params.g, r = new BN(0), k, H = bits2int(hash, q).mod(q), s = !1, kv = getKey(x, q, hash, algo);s === !1; )\n        k = makeKey(q, kv, algo), r = makeR(g, k, p, q), s = k.invm(q).imul(H.add(x.mul(r))).mod(q), s.cmpn(0) === 0 && (s = !1, r = new BN(0));\n      return toDER(r, s);\n    }\n    function toDER(r, s) {\n      r = r.toArray(), s = s.toArray(), r[0] & 128 && (r = [0].concat(r)), s[0] & 128 && (s = [0].concat(s));\n      var total = r.length + s.length + 4, res = [48, total, 2, r.length];\n      return res = res.concat(r, [2, s.length], s), Buffer2.from(res);\n    }\n    function getKey(x, q, hash, algo) {\n      if (x = Buffer2.from(x.toArray()), x.length < q.byteLength()) {\n        var zeros = Buffer2.alloc(q.byteLength() - x.length);\n        x = Buffer2.concat([zeros, x]);\n      }\n      var hlen = hash.length, hbits = bits2octets(hash, q), v = Buffer2.alloc(hlen);\n      v.fill(1);\n      var k = Buffer2.alloc(hlen);\n      return k = createHmac(algo, k).update(v).update(Buffer2.from([0])).update(x).update(hbits).digest(), v = createHmac(algo, k).update(v).digest(), k = createHmac(algo, k).update(v).update(Buffer2.from([1])).update(x).update(hbits).digest(), v = createHmac(algo, k).update(v).digest(), { k, v };\n    }\n    function bits2int(obits, q) {\n      var bits = new BN(obits), shift = (obits.length << 3) - q.bitLength();\n      return shift > 0 && bits.ishrn(shift), bits;\n    }\n    function bits2octets(bits, q) {\n      bits = bits2int(bits, q), bits = bits.mod(q);\n      var out = Buffer2.from(bits.toArray());\n      if (out.length < q.byteLength()) {\n        var zeros = Buffer2.alloc(q.byteLength() - out.length);\n        out = Buffer2.concat([zeros, out]);\n      }\n      return out;\n    }\n    function makeKey(q, kv, algo) {\n      var t, k;\n      do {\n        for (t = Buffer2.alloc(0);t.length * 8 < q.bitLength(); )\n          kv.v = createHmac(algo, kv.k).update(kv.v).digest(), t = Buffer2.concat([t, kv.v]);\n        k = bits2int(t, q), kv.k = createHmac(algo, kv.k).update(kv.v).update(Buffer2.from([0])).digest(), kv.v = createHmac(algo, kv.k).update(kv.v).digest();\n      } while (k.cmp(q) !== -1);\n      return k;\n    }\n    function makeR(g, k, p, q) {\n      return g.toRed(BN.mont(p)).redPow(k).fromRed().mod(q);\n    }\n    module.exports = sign, module.exports.getKey = getKey, module.exports.makeKey = makeKey;\n  }\n}), require_verify = __commonJS({\n  \"node_modules/browserify-sign/browser/verify.js\"(exports, module) {\n    var Buffer2 = require_safe_buffer().Buffer, BN = require_bn3(), EC = require_elliptic().ec, parseKeys = require_parse_asn1(), curves = require_curves2();\n    function verify(sig, hash, key, signType, tag) {\n      var pub = parseKeys(key);\n      if (pub.type === \"ec\") {\n        if (signType !== \"ecdsa\" && signType !== \"ecdsa/rsa\")\n          throw new Error(\"wrong public key type\");\n        return ecVerify(sig, hash, pub);\n      } else if (pub.type === \"dsa\") {\n        if (signType !== \"dsa\")\n          throw new Error(\"wrong public key type\");\n        return dsaVerify(sig, hash, pub);\n      } else if (signType !== \"rsa\" && signType !== \"ecdsa/rsa\")\n        throw new Error(\"wrong public key type\");\n      hash = Buffer2.concat([tag, hash]);\n      for (var len = pub.modulus.byteLength(), pad = [1], padNum = 0;hash.length + pad.length + 2 < len; )\n        pad.push(255), padNum++;\n      pad.push(0);\n      for (var i = -1;++i < hash.length; )\n        pad.push(hash[i]);\n      pad = Buffer2.from(pad);\n      var red = BN.mont(pub.modulus);\n      sig = new BN(sig).toRed(red), sig = sig.redPow(new BN(pub.publicExponent)), sig = Buffer2.from(sig.fromRed().toArray());\n      var out = padNum < 8 \? 1 : 0;\n      for (len = Math.min(sig.length, pad.length), sig.length !== pad.length && (out = 1), i = -1;++i < len; )\n        out |= sig[i] ^ pad[i];\n      return out === 0;\n    }\n    function ecVerify(sig, hash, pub) {\n      var curveId = curves[pub.data.algorithm.curve.join(\".\")];\n      if (!curveId)\n        throw new Error(\"unknown curve \" + pub.data.algorithm.curve.join(\".\"));\n      var curve = new EC(curveId), pubkey = pub.data.subjectPrivateKey.data;\n      return curve.verify(hash, sig, pubkey);\n    }\n    function dsaVerify(sig, hash, pub) {\n      var p = pub.data.p, q = pub.data.q, g = pub.data.g, y = pub.data.pub_key, unpacked = parseKeys.signature.decode(sig, \"der\"), s = unpacked.s, r = unpacked.r;\n      checkValue(s, q), checkValue(r, q);\n      var montp = BN.mont(p), w = s.invm(q), v = g.toRed(montp).redPow(new BN(hash).mul(w).mod(q)).fromRed().mul(y.toRed(montp).redPow(r.mul(w).mod(q)).fromRed()).mod(p).mod(q);\n      return v.cmp(r) === 0;\n    }\n    function checkValue(b, q) {\n      if (b.cmpn(0) <= 0)\n        throw new Error(\"invalid sig\");\n      if (b.cmp(q) >= q)\n        throw new Error(\"invalid sig\");\n    }\n    module.exports = verify;\n  }\n}), require_browser8 = __commonJS({\n  \"node_modules/browserify-sign/browser/index.js\"(exports, module) {\n    var Buffer2 = require_safe_buffer().Buffer, createHash = require_browser2(), inherits = require_inherits_browser(), sign = require_sign(), verify = require_verify(), algorithms = require_algorithms();\n    Object.keys(algorithms).forEach(function(key) {\n      algorithms[key].id = Buffer2.from(algorithms[key].id, \"hex\"), algorithms[key.toLowerCase()] = algorithms[key];\n    });\n    function Sign(algorithm) {\n      StreamModule.Writable.call(this);\n      var data = algorithms[algorithm];\n      if (!data)\n        throw new Error(\"Unknown message digest\");\n      this._hashType = data.hash, this._hash = createHash(data.hash), this._tag = data.id, this._signType = data.sign;\n    }\n    inherits(Sign, StreamModule.Writable), Sign.prototype._write = function(data, _, done) {\n      this._hash.update(data), done();\n    }, Sign.prototype.update = function(data, enc) {\n      return typeof data == \"string\" && (data = Buffer2.from(data, enc)), this._hash.update(data), this;\n    }, Sign.prototype.sign = function(key, enc) {\n      this.end();\n      var hash = this._hash.digest(), sig = sign(hash, key, this._hashType, this._signType, this._tag);\n      return enc \? sig.toString(enc) : sig;\n    };\n    function Verify(algorithm) {\n      StreamModule.Writable.call(this);\n      var data = algorithms[algorithm];\n      if (!data)\n        throw new Error(\"Unknown message digest\");\n      this._hash = createHash(data.hash), this._tag = data.id, this._signType = data.sign;\n    }\n    inherits(Verify, StreamModule.Writable), Verify.prototype._write = function(data, _, done) {\n      this._hash.update(data), done();\n    }, Verify.prototype.update = function(data, enc) {\n      return typeof data == \"string\" && (data = Buffer2.from(data, enc)), this._hash.update(data), this;\n    }, Verify.prototype.verify = function(key, sig, enc) {\n      typeof sig == \"string\" && (sig = Buffer2.from(sig, enc)), this.end();\n      var hash = this._hash.digest();\n      return verify(sig, hash, key, this._signType, this._tag);\n    };\n    function createSign(algorithm) {\n      return new Sign(algorithm);\n    }\n    function createVerify(algorithm) {\n      return new Verify(algorithm);\n    }\n    module.exports = {\n      Sign: createSign,\n      Verify: createVerify,\n      createSign,\n      createVerify\n    };\n  }\n}), require_bn6 = require_bn, require_browser9 = __commonJS({\n  \"node_modules/create-ecdh/browser.js\"(exports, module) {\n    var elliptic = require_elliptic(), BN = require_bn6();\n    module.exports = function(curve) {\n      return new ECDH(curve);\n    };\n    var aliases = {\n      secp256k1: {\n        name: \"secp256k1\",\n        byteLength: 32\n      },\n      secp224r1: {\n        name: \"p224\",\n        byteLength: 28\n      },\n      prime256v1: {\n        name: \"p256\",\n        byteLength: 32\n      },\n      prime192v1: {\n        name: \"p192\",\n        byteLength: 24\n      },\n      ed25519: {\n        name: \"ed25519\",\n        byteLength: 32\n      },\n      secp384r1: {\n        name: \"p384\",\n        byteLength: 48\n      },\n      secp521r1: {\n        name: \"p521\",\n        byteLength: 66\n      }\n    };\n    aliases.p224 = aliases.secp224r1, aliases.p256 = aliases.secp256r1 = aliases.prime256v1, aliases.p192 = aliases.secp192r1 = aliases.prime192v1, aliases.p384 = aliases.secp384r1, aliases.p521 = aliases.secp521r1;\n    function ECDH(curve) {\n      this.curveType = aliases[curve], this.curveType || (this.curveType = {\n        name: curve\n      }), this.curve = new elliptic.ec(this.curveType.name), this.keys = void 0;\n    }\n    ECDH.prototype = {}, ECDH.prototype.generateKeys = function(enc, format) {\n      return this.keys = this.curve.genKeyPair(), this.getPublicKey(enc, format);\n    }, ECDH.prototype.computeSecret = function(other, inenc, enc) {\n      inenc = inenc || \"utf8\", Buffer.isBuffer(other) || (other = new Buffer(other, inenc));\n      var otherPub = this.curve.keyFromPublic(other).getPublic(), out = otherPub.mul(this.keys.getPrivate()).getX();\n      return formatReturnValue(out, enc, this.curveType.byteLength);\n    }, ECDH.prototype.getPublicKey = function(enc, format) {\n      var key = this.keys.getPublic(format === \"compressed\", !0);\n      return format === \"hybrid\" && (key[key.length - 1] % 2 \? key[0] = 7 : key[0] = 6), formatReturnValue(key, enc);\n    }, ECDH.prototype.getPrivateKey = function(enc) {\n      return formatReturnValue(this.keys.getPrivate(), enc);\n    }, ECDH.prototype.setPublicKey = function(pub, enc) {\n      return enc = enc || \"utf8\", Buffer.isBuffer(pub) || (pub = new Buffer(pub, enc)), this.keys._importPublic(pub), this;\n    }, ECDH.prototype.setPrivateKey = function(priv, enc) {\n      enc = enc || \"utf8\", Buffer.isBuffer(priv) || (priv = new Buffer(priv, enc));\n      var _priv = new BN(priv);\n      return _priv = _priv.toString(16), this.keys = this.curve.genKeyPair(), this.keys._importPrivate(_priv), this;\n    };\n    function formatReturnValue(bn, enc, len) {\n      Array.isArray(bn) || (bn = bn.toArray());\n      var buf = new Buffer(bn);\n      if (len && buf.length < len) {\n        var zeros = new Buffer(len - buf.length);\n        zeros.fill(0), buf = Buffer.concat([zeros, buf]);\n      }\n      return enc \? buf.toString(enc) : buf;\n    }\n  }\n}), require_mgf = __commonJS({\n  \"node_modules/public-encrypt/mgf.js\"(exports, module) {\n    var createHash = require_browser2(), Buffer2 = require_safe_buffer().Buffer;\n    module.exports = function(seed, len) {\n      for (var t = Buffer2.alloc(0), i = 0, c;t.length < len; )\n        c = i2ops(i++), t = Buffer2.concat([t, createHash(\"sha1\").update(seed).update(c).digest()]);\n      return t.slice(0, len);\n    };\n    function i2ops(c) {\n      var out = Buffer2.allocUnsafe(4);\n      return out.writeUInt32BE(c, 0), out;\n    }\n  }\n}), require_xor = __commonJS({\n  \"node_modules/public-encrypt/xor.js\"(exports, module) {\n    module.exports = function(a, b) {\n      for (var len = a.length, i = -1;++i < len; )\n        a[i] ^= b[i];\n      return a;\n    };\n  }\n}), require_bn7 = require_bn, { CryptoHasher } = globalThis.Bun, require_withPublic = __commonJS({\n  \"node_modules/public-encrypt/withPublic.js\"(exports, module) {\n    var BN = require_bn7(), Buffer2 = require_safe_buffer().Buffer;\n    function withPublic(paddedMsg, key) {\n      return Buffer2.from(paddedMsg.toRed(BN.mont(key.modulus)).redPow(new BN(key.publicExponent)).fromRed().toArray());\n    }\n    module.exports = withPublic;\n  }\n}), require_publicEncrypt = __commonJS({\n  \"node_modules/public-encrypt/publicEncrypt.js\"(exports, module) {\n    var parseKeys = require_parse_asn1(), randomBytes = require_browser(), createHash = require_browser2(), mgf = require_mgf(), xor = require_xor(), BN = require_bn7(), withPublic = require_withPublic(), crt = require_browserify_rsa(), Buffer2 = require_safe_buffer().Buffer;\n    module.exports = function(publicKey, msg, reverse) {\n      var padding;\n      publicKey.padding \? padding = publicKey.padding : reverse \? padding = 1 : padding = 4;\n      var key = parseKeys(publicKey), paddedMsg;\n      if (padding === 4)\n        paddedMsg = oaep(key, msg);\n      else if (padding === 1)\n        paddedMsg = pkcs1(key, msg, reverse);\n      else if (padding === 3) {\n        if (paddedMsg = new BN(msg), paddedMsg.cmp(key.modulus) >= 0)\n          throw new Error(\"data too long for modulus\");\n      } else\n        throw new Error(\"unknown padding\");\n      return reverse \? crt(paddedMsg, key) : withPublic(paddedMsg, key);\n    };\n    function oaep(key, msg) {\n      var k = key.modulus.byteLength(), mLen = msg.length, iHash = createHash(\"sha1\").update(Buffer2.alloc(0)).digest(), hLen = iHash.length, hLen2 = 2 * hLen;\n      if (mLen > k - hLen2 - 2)\n        throw new Error(\"message too long\");\n      var ps = Buffer2.alloc(k - mLen - hLen2 - 2), dblen = k - hLen - 1, seed = randomBytes(hLen), maskedDb = xor(Buffer2.concat([iHash, ps, Buffer2.alloc(1, 1), msg], dblen), mgf(seed, dblen)), maskedSeed = xor(seed, mgf(maskedDb, hLen));\n      return new BN(Buffer2.concat([Buffer2.alloc(1), maskedSeed, maskedDb], k));\n    }\n    function pkcs1(key, msg, reverse) {\n      var mLen = msg.length, k = key.modulus.byteLength();\n      if (mLen > k - 11)\n        throw new Error(\"message too long\");\n      var ps;\n      return reverse \? ps = Buffer2.alloc(k - mLen - 3, 255) : ps = nonZero(k - mLen - 3), new BN(Buffer2.concat([Buffer2.from([0, reverse \? 1 : 2]), ps, Buffer2.alloc(1), msg], k));\n    }\n    function nonZero(len) {\n      for (var out = Buffer2.allocUnsafe(len), i = 0, cache = randomBytes(len * 2), cur = 0, num;i < len; )\n        cur === cache.length && (cache = randomBytes(len * 2), cur = 0), num = cache[cur++], num && (out[i++] = num);\n      return out;\n    }\n  }\n}), require_privateDecrypt = __commonJS({\n  \"node_modules/public-encrypt/privateDecrypt.js\"(exports, module) {\n    var parseKeys = require_parse_asn1(), mgf = require_mgf(), xor = require_xor(), BN = require_bn7(), crt = require_browserify_rsa(), createHash = require_browser2(), withPublic = require_withPublic(), Buffer2 = require_safe_buffer().Buffer;\n    module.exports = function(privateKey, enc, reverse) {\n      var padding;\n      privateKey.padding \? padding = privateKey.padding : reverse \? padding = 1 : padding = 4;\n      var key = parseKeys(privateKey), k = key.modulus.byteLength();\n      if (enc.length > k || new BN(enc).cmp(key.modulus) >= 0)\n        throw new Error(\"decryption error\");\n      var msg;\n      reverse \? msg = withPublic(new BN(enc), key) : msg = crt(enc, key);\n      var zBuffer = Buffer2.alloc(k - msg.length);\n      if (msg = Buffer2.concat([zBuffer, msg], k), padding === 4)\n        return oaep(key, msg);\n      if (padding === 1)\n        return pkcs1(key, msg, reverse);\n      if (padding === 3)\n        return msg;\n      throw new Error(\"unknown padding\");\n    };\n    function oaep(key, msg) {\n      var k = key.modulus.byteLength(), iHash = createHash(\"sha1\").update(Buffer2.alloc(0)).digest(), hLen = iHash.length;\n      if (msg[0] !== 0)\n        throw new Error(\"decryption error\");\n      var maskedSeed = msg.slice(1, hLen + 1), maskedDb = msg.slice(hLen + 1), seed = xor(maskedSeed, mgf(maskedDb, hLen)), db = xor(maskedDb, mgf(seed, k - hLen - 1));\n      if (compare(iHash, db.slice(0, hLen)))\n        throw new Error(\"decryption error\");\n      for (var i = hLen;db[i] === 0; )\n        i++;\n      if (db[i++] !== 1)\n        throw new Error(\"decryption error\");\n      return db.slice(i);\n    }\n    function pkcs1(key, msg, reverse) {\n      for (var p1 = msg.slice(0, 2), i = 2, status = 0;msg[i++] !== 0; )\n        if (i >= msg.length) {\n          status++;\n          break;\n        }\n      var ps = msg.slice(2, i - 1);\n      if ((p1.toString(\"hex\") !== \"0002\" && !reverse || p1.toString(\"hex\") !== \"0001\" && reverse) && status++, ps.length < 8 && status++, status)\n        throw new Error(\"decryption error\");\n      return msg.slice(i);\n    }\n    function compare(a, b) {\n      a = Buffer2.from(a), b = Buffer2.from(b);\n      var dif = 0, len = a.length;\n      a.length !== b.length && (dif++, len = Math.min(a.length, b.length));\n      for (var i = -1;++i < len; )\n        dif += a[i] ^ b[i];\n      return dif;\n    }\n  }\n}), require_browser10 = __commonJS({\n  \"node_modules/public-encrypt/browser.js\"(exports) {\n    exports.publicEncrypt = require_publicEncrypt(), exports.privateDecrypt = require_privateDecrypt(), exports.privateEncrypt = function(key, buf) {\n      return exports.publicEncrypt(key, buf, !0);\n    }, exports.publicDecrypt = function(key, buf) {\n      return exports.privateDecrypt(key, buf, !0);\n    };\n  }\n}), require_browser11 = __commonJS({\n  \"node_modules/randomfill/browser.js\"(exports) {\n    var safeBuffer = require_safe_buffer(), randombytes = require_browser(), Buffer2 = safeBuffer.Buffer, kBufferMaxLength = safeBuffer.kMaxLength, kMaxUint32 = Math.pow(2, 32) - 1;\n    function assertOffset(offset, length) {\n      if (typeof offset != \"number\" || offset !== offset)\n        @throwTypeError(\"offset must be a number\");\n      if (offset > kMaxUint32 || offset < 0)\n        @throwTypeError(\"offset must be a uint32\");\n      if (offset > kBufferMaxLength || offset > length)\n        @throwRangeError(\"offset out of range\");\n    }\n    function assertSize(size, offset, length) {\n      if (typeof size != \"number\" || size !== size)\n        @throwTypeError(\"size must be a number\");\n      if (size > kMaxUint32 || size < 0)\n        @throwTypeError(\"size must be a uint32\");\n      if (size + offset > length || size > kBufferMaxLength)\n        @throwRangeError(\"buffer too small\");\n    }\n    exports.randomFill = randomFill, exports.randomFillSync = randomFillSync;\n    function randomFill(buf, offset, size, cb) {\n      if (!Buffer2.isBuffer(buf) && !(buf instanceof global.Uint8Array))\n        @throwTypeError('\"buf\" argument must be a Buffer or Uint8Array');\n      if (typeof offset == \"function\")\n        cb = offset, offset = 0, size = buf.length;\n      else if (typeof size == \"function\")\n        cb = size, size = buf.length - offset;\n      else if (typeof cb != \"function\")\n        @throwTypeError('\"cb\" argument must be a function');\n      return assertOffset(offset, buf.length), assertSize(size, offset, buf.length), actualFill(buf, offset, size, cb);\n    }\n    function actualFill(buf, offset, size, cb) {\n      if (cb) {\n        randombytes(size, function(err, bytes2) {\n          if (err)\n            return cb(err);\n          bytes2.copy(buf, offset), cb(null, buf);\n        });\n        return;\n      }\n      var bytes = randombytes(size);\n      return bytes.copy(buf, offset), buf;\n    }\n    function randomFillSync(buf, offset, size) {\n      if (typeof offset > \"u\" && (offset = 0), !Buffer2.isBuffer(buf) && !(buf instanceof global.Uint8Array))\n        @throwTypeError('\"buf\" argument must be a Buffer or Uint8Array');\n      return assertOffset(offset, buf.length), size === void 0 && (size = buf.length - offset), assertSize(size, offset, buf.length), actualFill(buf, offset, size);\n    }\n  }\n}), require_crypto_browserify2 = __commonJS({\n  \"node_modules/crypto-browserify/index.js\"(exports) {\n    exports.randomBytes = exports.rng = exports.pseudoRandomBytes = exports.prng = require_browser(), exports.createHash = require_browser2(), exports.Hash = exports.createHash.Hash, exports.createHmac = exports.Hmac = require_browser3();\n    var algos = require_algos(), algoKeys = Object.keys(algos), hashes = [\"sha1\", \"sha224\", \"sha256\", \"sha384\", \"sha512\", \"md5\", \"rmd160\"].concat(algoKeys);\n    exports.getHashes = function() {\n      return hashes;\n    };\n    var p = require_browser4();\n    exports.pbkdf2 = p.pbkdf2, exports.pbkdf2Sync = p.pbkdf2Sync;\n    var aes = require_browser6();\n    exports.Cipher = aes.Cipher, exports.createCipher = aes.createCipher, exports.Cipheriv = aes.Cipheriv, exports.createCipheriv = aes.createCipheriv, exports.Decipher = aes.Decipher, exports.createDecipher = aes.createDecipher, exports.Decipheriv = aes.Decipheriv, exports.createDecipheriv = aes.createDecipheriv, exports.getCiphers = aes.getCiphers, exports.listCiphers = aes.listCiphers;\n    var dh = require_browser7();\n    exports.DiffieHellmanGroup = dh.DiffieHellmanGroup, exports.createDiffieHellmanGroup = dh.createDiffieHellmanGroup, exports.getDiffieHellman = dh.getDiffieHellman, exports.createDiffieHellman = dh.createDiffieHellman, exports.DiffieHellman = dh.DiffieHellman;\n    var sign = require_browser8();\n    exports.createSign = sign.createSign, exports.Sign = sign.Sign, exports.createVerify = sign.createVerify, exports.Verify = sign.Verify, exports.createECDH = require_browser9();\n    var publicEncrypt = require_browser10();\n    exports.publicEncrypt = publicEncrypt.publicEncrypt, exports.privateEncrypt = publicEncrypt.privateEncrypt, exports.publicDecrypt = publicEncrypt.publicDecrypt, exports.privateDecrypt = publicEncrypt.privateDecrypt, exports.getRandomValues = (values) => crypto.getRandomValues(values);\n    var rf = require_browser11();\n    exports.randomFill = rf.randomFill, exports.randomFillSync = rf.randomFillSync, exports.createCredentials = function() {\n      throw new Error([\n        \"sorry, createCredentials is not implemented yet\",\n        \"we accept pull requests\",\n        \"https://github.com/crypto-browserify/crypto-browserify\"\n      ].join(`\n`));\n    }, exports.constants = @processBindingConstants.crypto;\n  }\n}), crypto_exports = require_crypto_browserify2(), DEFAULT_ENCODING = \"buffer\", getRandomValues = (array) => crypto.getRandomValues(array), randomUUID = () => crypto.randomUUID(), randomInt = (...args) => crypto.randomInt(...args), timingSafeEqual = \"timingSafeEqual\" in crypto \? (a, b) => {\n  let { byteLength: byteLengthA } = a, { byteLength: byteLengthB } = b;\n  if (typeof byteLengthA != \"number\" || typeof byteLengthB != \"number\")\n    @throwTypeError(\"Input must be an array buffer view\");\n  if (byteLengthA !== byteLengthB)\n    @throwRangeError(\"Input buffers must have the same length\");\n  return crypto.timingSafeEqual(a, b);\n} : void 0, scryptSync = \"scryptSync\" in crypto \? (password, salt, keylen, options) => {\n  let res = crypto.scryptSync(password, salt, keylen, options);\n  return DEFAULT_ENCODING !== \"buffer\" \? new Buffer(res).toString(DEFAULT_ENCODING) : new Buffer(res);\n} : void 0, scrypt = \"scryptSync\" in crypto \? function(password, salt, keylen, options, callback) {\n  if (typeof options == \"function\" && (callback = options, options = void 0), typeof callback != \"function\") {\n    var err = @makeTypeError(\"callback must be a function\");\n    throw err.code = \"ERR_INVALID_CALLBACK\", err;\n  }\n  try {\n    let result = crypto.scryptSync(password, salt, keylen, options);\n    process.nextTick(callback, null, DEFAULT_ENCODING !== \"buffer\" \? new Buffer(result).toString(DEFAULT_ENCODING) : new Buffer(result));\n  } catch (err2) {\n    throw err2;\n  }\n} : void 0;\ntimingSafeEqual && (Object.defineProperty(timingSafeEqual, \"name\", {\n  value: \"::bunternal::\"\n}), Object.defineProperty(scrypt, \"name\", {\n  value: \"::bunternal::\"\n}), Object.defineProperty(scryptSync, \"name\", {\n  value: \"::bunternal::\"\n}));\nvar harcoded_curves = [\n  \"p192\",\n  \"p224\",\n  \"p256\",\n  \"p384\",\n  \"p521\",\n  \"curve25519\",\n  \"ed25519\",\n  \"secp256k1\",\n  \"secp224r1\",\n  \"prime256v1\",\n  \"prime192v1\",\n  \"ed25519\",\n  \"secp384r1\",\n  \"secp521r1\"\n], webcrypto = crypto;\n__export(crypto_exports, {\n  DEFAULT_ENCODING: () => DEFAULT_ENCODING,\n  getRandomValues: () => getRandomValues,\n  randomUUID: () => randomUUID,\n  randomInt: () => randomInt,\n  getCurves: () => getCurves,\n  scrypt: () => scrypt,\n  scryptSync: () => scryptSync,\n  timingSafeEqual: () => timingSafeEqual,\n  webcrypto: () => webcrypto,\n  subtle: () => webcrypto.subtle\n});\n$ = crypto_exports;\n/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */\nreturn $})\n"_s;
//

//
static constexpr ASCIILiteral NodeDgramCode = "(function (){\"use strict\";// src/js/out/tmp/node/dgram.ts\nvar createSocket = function() {\n  throwNotImplemented(\"node:dgram createSocket\", 1630);\n}, Socket = function() {\n  throwNotImplemented(\"node:dgram Socket\", 1630);\n}, _createSocketHandle = function() {\n  throwNotImplemented(\"node:dgram _createSocketHandle\", 1630);\n}, $, { hideFromStack, throwNotImplemented } = @getInternalField(@internalModuleRegistry, 3) || @createInternalModuleById(3);\n$ = {\n  createSocket,\n  Socket,\n  _createSocketHandle\n};\nhideFromStack(createSocket, Socket, _createSocketHandle);\nreturn $})\n"_s;
//

//
static constexpr ASCIILiteral NodeDiagnosticsChannelCode = "(function (){\"use strict\";// src/js/out/tmp/node/diagnostics_channel.ts\nvar markActive = function(channel) {\n  ObjectSetPrototypeOf(channel, ActiveChannel.prototype), channel._subscribers = [], channel._stores = new SafeMap;\n}, maybeMarkInactive = function(channel) {\n  if (!channel._subscribers.length && !channel._stores.size)\n    ObjectSetPrototypeOf(channel, Channel.prototype), channel._subscribers = void 0, channel._stores = void 0;\n}, defaultTransform = function(data) {\n  return data;\n}, wrapStoreRun = function(store, data, next, transform = defaultTransform) {\n  return () => {\n    let context;\n    try {\n      context = transform(data);\n    } catch (err) {\n      return process.nextTick(() => reportError(err)), next();\n    }\n    return store.run(context, next);\n  };\n}, channel = function(name) {\n  const channel2 = channels.get(name);\n  if (channel2)\n    return channel2;\n  if (typeof name !== \"string\" && typeof name !== \"symbol\")\n    throw new ERR_INVALID_ARG_TYPE(\"channel\", [\"string\", \"symbol\"], name);\n  return new Channel(name);\n}, subscribe = function(name, subscription) {\n  return channel(name).subscribe(subscription);\n}, unsubscribe = function(name, subscription) {\n  return channel(name).unsubscribe(subscription);\n}, hasSubscribers = function(name) {\n  const channel2 = channels.get(name);\n  if (!channel2)\n    return !1;\n  return channel2.hasSubscribers;\n}, assertChannel = function(value, name) {\n  if (!(value instanceof Channel))\n    throw new ERR_INVALID_ARG_TYPE(name, [\"Channel\"], value);\n}, tracingChannel = function(nameOrChannels) {\n  return new TracingChannel(nameOrChannels);\n}, validateFunction = function(callable, field) {\n  if (typeof callable !== \"function\")\n    throw new ERR_INVALID_ARG_TYPE(field, \"Function\", callable);\n  return callable;\n}, $, SafeMap = Map, SafeFinalizationRegistry = FinalizationRegistry, ArrayPrototypeAt = (array, index) => array[index], ArrayPrototypeIndexOf = (array, value) => array.indexOf(value), ArrayPrototypePush = (array, value) => array.push(value), ArrayPrototypeSplice = (array, start, deleteCount) => array.splice(start, deleteCount), ObjectGetPrototypeOf = Object.getPrototypeOf, ObjectSetPrototypeOf = Object.setPrototypeOf, SymbolHasInstance = Symbol.hasInstance, ReflectApply = Reflect.apply, PromiseResolve = Promise.resolve, PromiseReject = Promise.reject, PromisePrototypeThen = (promise, onFulfilled, onRejected) => promise.then(onFulfilled, onRejected);\n\nclass WeakReference extends WeakRef {\n  constructor() {\n    super(...arguments);\n  }\n  #refs = 0;\n  get() {\n    return this.deref();\n  }\n  incRef() {\n    return ++this.#refs;\n  }\n  decRef() {\n    return --this.#refs;\n  }\n}\n\nclass WeakRefMap extends SafeMap {\n  constructor() {\n    super(...arguments);\n  }\n  #finalizers = new SafeFinalizationRegistry((key) => {\n    this.delete(key);\n  });\n  set(key, value) {\n    return this.#finalizers.register(value, key), super.set(key, new WeakReference(value));\n  }\n  get(key) {\n    return super.get(key)\?.get();\n  }\n  incRef(key) {\n    return super.get(key)\?.incRef();\n  }\n  decRef(key) {\n    return super.get(key)\?.decRef();\n  }\n}\n\nclass ActiveChannel {\n  subscribe(subscription) {\n    validateFunction(subscription, \"subscription\"), ArrayPrototypePush(this._subscribers, subscription), channels.incRef(this.name);\n  }\n  unsubscribe(subscription) {\n    const index = ArrayPrototypeIndexOf(this._subscribers, subscription);\n    if (index === -1)\n      return !1;\n    return ArrayPrototypeSplice(this._subscribers, index, 1), channels.decRef(this.name), maybeMarkInactive(this), !0;\n  }\n  bindStore(store, transform) {\n    if (!this._stores.has(store))\n      channels.incRef(this.name);\n    this._stores.set(store, transform);\n  }\n  unbindStore(store) {\n    if (!this._stores.has(store))\n      return !1;\n    return this._stores.delete(store), channels.decRef(this.name), maybeMarkInactive(this), !0;\n  }\n  get hasSubscribers() {\n    return !0;\n  }\n  publish(data) {\n    for (let i = 0;i < (this._subscribers\?.length || 0); i++)\n      try {\n        const onMessage = this._subscribers[i];\n        onMessage(data, this.name);\n      } catch (err) {\n        process.nextTick(() => reportError(err));\n      }\n  }\n  runStores(data, fn, thisArg, ...args) {\n    let run = () => {\n      return this.publish(data), ReflectApply(fn, thisArg, args);\n    };\n    for (let entry of this._stores.entries()) {\n      const store = entry[0], transform = entry[1];\n      run = wrapStoreRun(store, data, run, transform);\n    }\n    return run();\n  }\n}\n\nclass Channel {\n  constructor(name) {\n    this._subscribers = void 0, this._stores = void 0, this.name = name, channels.set(name, this);\n  }\n  static [SymbolHasInstance](instance) {\n    const prototype = ObjectGetPrototypeOf(instance);\n    return prototype === Channel.prototype || prototype === ActiveChannel.prototype;\n  }\n  subscribe(subscription) {\n    markActive(this), this.subscribe(subscription);\n  }\n  unsubscribe() {\n    return !1;\n  }\n  bindStore(store, transform) {\n    markActive(this), this.bindStore(store, transform);\n  }\n  unbindStore() {\n    return !1;\n  }\n  get hasSubscribers() {\n    return !1;\n  }\n  publish() {\n  }\n  runStores(data, fn, thisArg, ...args) {\n    return ReflectApply(fn, thisArg, args);\n  }\n}\nvar channels = new WeakRefMap, traceEvents = [\"start\", \"end\", \"asyncStart\", \"asyncEnd\", \"error\"];\n\nclass TracingChannel {\n  constructor(nameOrChannels) {\n    if (typeof nameOrChannels === \"string\")\n      this.start = channel(`tracing:${nameOrChannels}:start`), this.end = channel(`tracing:${nameOrChannels}:end`), this.asyncStart = channel(`tracing:${nameOrChannels}:asyncStart`), this.asyncEnd = channel(`tracing:${nameOrChannels}:asyncEnd`), this.error = channel(`tracing:${nameOrChannels}:error`);\n    else if (typeof nameOrChannels === \"object\") {\n      const { start, end, asyncStart, asyncEnd, error } = nameOrChannels;\n      assertChannel(start, \"nameOrChannels.start\"), assertChannel(end, \"nameOrChannels.end\"), assertChannel(asyncStart, \"nameOrChannels.asyncStart\"), assertChannel(asyncEnd, \"nameOrChannels.asyncEnd\"), assertChannel(error, \"nameOrChannels.error\"), this.start = start, this.end = end, this.asyncStart = asyncStart, this.asyncEnd = asyncEnd, this.error = error;\n    } else\n      throw new ERR_INVALID_ARG_TYPE(\"nameOrChannels\", [\"string\", \"object\", \"Channel\"], nameOrChannels);\n  }\n  subscribe(handlers) {\n    for (let name of traceEvents) {\n      if (!handlers[name])\n        continue;\n      this[name]\?.subscribe(handlers[name]);\n    }\n  }\n  unsubscribe(handlers) {\n    let done = !0;\n    for (let name of traceEvents) {\n      if (!handlers[name])\n        continue;\n      if (!this[name]\?.unsubscribe(handlers[name]))\n        done = !1;\n    }\n    return done;\n  }\n  traceSync(fn, context = {}, thisArg, ...args) {\n    const { start, end, error } = this;\n    return start.runStores(context, () => {\n      try {\n        const result = ReflectApply(fn, thisArg, args);\n        return context.result = result, result;\n      } catch (err) {\n        throw context.error = err, error.publish(context), err;\n      } finally {\n        end.publish(context);\n      }\n    });\n  }\n  tracePromise(fn, context = {}, thisArg, ...args) {\n    const { start, end, asyncStart, asyncEnd, error } = this;\n    function reject(err) {\n      return context.error = err, error.publish(context), asyncStart.publish(context), asyncEnd.publish(context), PromiseReject(err);\n    }\n    function resolve(result) {\n      return context.result = result, asyncStart.publish(context), asyncEnd.publish(context), result;\n    }\n    return start.runStores(context, () => {\n      try {\n        let promise = ReflectApply(fn, thisArg, args);\n        if (!(promise instanceof Promise))\n          promise = PromiseResolve(promise);\n        return PromisePrototypeThen(promise, resolve, reject);\n      } catch (err) {\n        throw context.error = err, error.publish(context), err;\n      } finally {\n        end.publish(context);\n      }\n    });\n  }\n  traceCallback(fn, position = -1, context = {}, thisArg, ...args) {\n    const { start, end, asyncStart, asyncEnd, error } = this;\n    function wrappedCallback(err, res) {\n      if (err)\n        context.error = err, error.publish(context);\n      else\n        context.result = res;\n      asyncStart.runStores(context, () => {\n        try {\n          if (callback)\n            return ReflectApply(callback, this, arguments);\n        } finally {\n          asyncEnd.publish(context);\n        }\n      });\n    }\n    const callback = ArrayPrototypeAt(args, position);\n    if (typeof callback !== \"function\")\n      throw new ERR_INVALID_ARG_TYPE(\"callback\", [\"function\"], callback);\n    return ArrayPrototypeSplice(args, position, 1, wrappedCallback), start.runStores(context, () => {\n      try {\n        return ReflectApply(fn, thisArg, args);\n      } catch (err) {\n        throw context.error = err, error.publish(context), err;\n      } finally {\n        end.publish(context);\n      }\n    });\n  }\n}\n\nclass ERR_INVALID_ARG_TYPE extends TypeError {\n  constructor(name, expected, actual) {\n    super(`The ${name} argument must be of type ${expected}. Received type ${typeof actual}`);\n    this.code = \"ERR_INVALID_ARG_TYPE\";\n  }\n}\n$ = {\n  channel,\n  hasSubscribers,\n  subscribe,\n  tracingChannel,\n  unsubscribe,\n  Channel\n};\nreturn $})\n"_s;
//

//
static constexpr ASCIILiteral NodeDNSCode = "(function (){\"use strict\";// src/js/out/tmp/node/dns.ts\nvar getServers = function() {\n  return dns.getServers();\n}, lookup = function(domain, options, callback) {\n  if (typeof options == \"function\")\n    callback = options;\n  if (typeof callback != \"function\")\n    @throwTypeError(\"callback must be a function\");\n  if (typeof options == \"number\")\n    options = { family: options };\n  dns.lookup(domain, options).then((res) => {\n    if (res.sort((a, b) => a.family - b.family), options\?.all)\n      callback(null, res.map(mapLookupAll));\n    else {\n      const [{ address, family }] = res;\n      callback(null, address, family);\n    }\n  }, (error) => {\n    callback(error);\n  });\n}, resolveSrv = function(hostname, callback) {\n  if (typeof callback != \"function\")\n    @throwTypeError(\"callback must be a function\");\n  dns.resolveSrv(hostname, callback).then((results) => {\n    callback(null, results);\n  }, (error) => {\n    callback(error);\n  });\n}, resolveTxt = function(hostname, callback) {\n  if (typeof callback != \"function\")\n    @throwTypeError(\"callback must be a function\");\n  dns.resolveTxt(hostname, callback).then((results) => {\n    callback(null, results);\n  }, (error) => {\n    callback(error);\n  });\n}, resolveSoa = function(hostname, callback) {\n  if (typeof callback != \"function\")\n    @throwTypeError(\"callback must be a function\");\n  dns.resolveSoa(hostname, callback).then((results) => {\n    callback(null, results);\n  }, (error) => {\n    callback(error);\n  });\n}, resolveNaptr = function(hostname, callback) {\n  if (typeof callback != \"function\")\n    @throwTypeError(\"callback must be a function\");\n  dns.resolveNaptr(hostname, callback).then((results) => {\n    callback(null, results);\n  }, (error) => {\n    callback(error);\n  });\n}, resolveMx = function(hostname, callback) {\n  if (typeof callback != \"function\")\n    @throwTypeError(\"callback must be a function\");\n  dns.resolveMx(hostname, callback).then((results) => {\n    callback(null, results);\n  }, (error) => {\n    callback(error);\n  });\n}, resolveCaa = function(hostname, callback) {\n  if (typeof callback != \"function\")\n    @throwTypeError(\"callback must be a function\");\n  dns.resolveCaa(hostname, callback).then((results) => {\n    callback(null, results);\n  }, (error) => {\n    callback(error);\n  });\n}, resolveNs = function(hostname, callback) {\n  if (typeof callback != \"function\")\n    @throwTypeError(\"callback must be a function\");\n  dns.resolveNs(hostname, callback).then((results) => {\n    callback(null, results);\n  }, (error) => {\n    callback(error);\n  });\n}, resolvePtr = function(hostname, callback) {\n  if (typeof callback != \"function\")\n    @throwTypeError(\"callback must be a function\");\n  dns.resolvePtr(hostname, callback).then((results) => {\n    callback(null, results);\n  }, (error) => {\n    callback(error);\n  });\n}, resolveCname = function(hostname, callback) {\n  if (typeof callback != \"function\")\n    @throwTypeError(\"callback must be a function\");\n  dns.resolveCname(hostname, callback).then((results) => {\n    callback(null, results);\n  }, (error) => {\n    callback(error);\n  });\n}, lookupService = function(address, port, callback) {\n  if (typeof callback != \"function\")\n    @throwTypeError(\"callback must be a function\");\n  callback(null, address, port);\n}, resolve = function(hostname, rrtype, callback) {\n  if (typeof rrtype == \"function\")\n    callback = rrtype;\n  if (typeof callback != \"function\")\n    @throwTypeError(\"callback must be a function\");\n  dns.resolve(hostname).then((results) => {\n    switch (rrtype\?.toLowerCase()) {\n      case \"a\":\n      case \"aaaa\":\n        callback(null, hostname, results.map(({ address }) => address));\n        break;\n      default:\n        callback(null, results);\n        break;\n    }\n  }, (error) => {\n    callback(error);\n  });\n}, Resolver = function(options) {\n  return new InternalResolver(options);\n}, setDefaultResultOrder = function() {\n}, setServers = function() {\n}, $, dns = Bun.dns, InternalResolver = class Resolver2 {\n  constructor(options) {\n  }\n  cancel() {\n  }\n  getServers() {\n    return [];\n  }\n  resolve(hostname, rrtype, callback) {\n    if (typeof rrtype == \"function\")\n      callback = rrtype, rrtype = null;\n    if (typeof callback != \"function\")\n      @throwTypeError(\"callback must be a function\");\n    dns.resolve(hostname).then((results) => {\n      switch (rrtype\?.toLowerCase()) {\n        case \"a\":\n        case \"aaaa\":\n          callback(null, hostname, results.map(mapResolveX));\n          break;\n        default:\n          callback(null, results);\n          break;\n      }\n    }, (error) => {\n      callback(error);\n    });\n  }\n  resolve4(hostname, options, callback) {\n    if (typeof options == \"function\")\n      callback = options, options = null;\n    if (typeof callback != \"function\")\n      @throwTypeError(\"callback must be a function\");\n    dns.lookup(hostname, { family: 4 }).then((addresses) => {\n      callback(null, options\?.ttl \? addresses : addresses.map(mapResolveX));\n    }, (error) => {\n      callback(error);\n    });\n  }\n  resolve6(hostname, options, callback) {\n    if (typeof options == \"function\")\n      callback = options, options = null;\n    if (typeof callback != \"function\")\n      @throwTypeError(\"callback must be a function\");\n    dns.lookup(hostname, { family: 6 }).then((addresses) => {\n      callback(null, options\?.ttl \? addresses : addresses.map(({ address }) => address));\n    }, (error) => {\n      callback(error);\n    });\n  }\n  resolveAny(hostname, callback) {\n    callback(null, []);\n  }\n  resolveCname(hostname, callback) {\n    if (typeof callback != \"function\")\n      @throwTypeError(\"callback must be a function\");\n    dns.resolveCname(hostname, callback).then((results) => {\n      callback(null, results);\n    }, (error) => {\n      callback(error);\n    });\n  }\n  resolveMx(hostname, callback) {\n    if (typeof callback != \"function\")\n      @throwTypeError(\"callback must be a function\");\n    dns.resolveMx(hostname, callback).then((results) => {\n      callback(null, results);\n    }, (error) => {\n      callback(error);\n    });\n  }\n  resolveNaptr(hostname, callback) {\n    if (typeof callback != \"function\")\n      @throwTypeError(\"callback must be a function\");\n    dns.resolveNaptr(hostname, callback).then((results) => {\n      callback(null, results);\n    }, (error) => {\n      callback(error);\n    });\n  }\n  resolveNs(hostname, callback) {\n    if (typeof callback != \"function\")\n      @throwTypeError(\"callback must be a function\");\n    dns.resolveNs(hostname, callback).then((results) => {\n      callback(null, results);\n    }, (error) => {\n      callback(error);\n    });\n  }\n  resolvePtr(hostname, callback) {\n    if (typeof callback != \"function\")\n      @throwTypeError(\"callback must be a function\");\n    dns.resolvePtr(hostname, callback).then((results) => {\n      callback(null, results);\n    }, (error) => {\n      callback(error);\n    });\n  }\n  resolveSrv(hostname, callback) {\n    if (typeof callback != \"function\")\n      @throwTypeError(\"callback must be a function\");\n    dns.resolveSrv(hostname, callback).then((results) => {\n      callback(null, results);\n    }, (error) => {\n      callback(error);\n    });\n  }\n  resolveCaa(hostname, callback) {\n    if (typeof callback != \"function\")\n      @throwTypeError(\"callback must be a function\");\n    dns.resolveCaa(hostname, callback).then((results) => {\n      callback(null, results);\n    }, (error) => {\n      callback(error);\n    });\n  }\n  resolveTxt(hostname, callback) {\n    if (typeof callback != \"function\")\n      @throwTypeError(\"callback must be a function\");\n    dns.resolveTxt(hostname, callback).then((results) => {\n      callback(null, results);\n    }, (error) => {\n      callback(error);\n    });\n  }\n  resolveSoa(hostname, callback) {\n    if (typeof callback != \"function\")\n      @throwTypeError(\"callback must be a function\");\n    dns.resolveSoa(hostname, callback).then((results) => {\n      callback(null, results);\n    }, (error) => {\n      callback(error);\n    });\n  }\n  reverse(ip, callback) {\n    callback(null, []);\n  }\n  setServers(servers) {\n  }\n};\nResolver.prototype = {};\nObject.setPrototypeOf(Resolver.prototype, InternalResolver.prototype);\nObject.setPrototypeOf(Resolver, InternalResolver);\nvar {\n  resolve,\n  resolve4,\n  resolve6,\n  resolveAny,\n  resolveCname,\n  resolveCaa,\n  resolveMx,\n  resolveNaptr,\n  resolveNs,\n  resolvePtr,\n  resolveSoa,\n  resolveSrv,\n  reverse,\n  resolveTxt\n} = InternalResolver.prototype, promisifyLookup = (res) => {\n  res.sort((a, b) => a.family - b.family);\n  const [{ address, family }] = res;\n  return { address, family };\n}, mapLookupAll = (res) => {\n  const { address, family } = res;\n  return { address, family };\n}, promisifyLookupAll = (res) => {\n  return res.sort((a, b) => a.family - b.family), res.map(mapLookupAll);\n}, mapResolveX = (a) => a.address, promisifyResolveX = (res) => {\n  return res\?.map(mapResolveX);\n}, promises = {\n  lookup(domain, options) {\n    if (options\?.all)\n      return dns.lookup(domain, options).then(promisifyLookupAll);\n    return dns.lookup(domain, options).then(promisifyLookup);\n  },\n  lookupService(address, port) {\n    return Promise.resolve([]);\n  },\n  resolve(hostname, rrtype) {\n    if (typeof rrtype !== \"string\")\n      rrtype = null;\n    switch (rrtype\?.toLowerCase()) {\n      case \"a\":\n      case \"aaaa\":\n        return dns.resolve(hostname, rrtype).then(promisifyLookup);\n      default:\n        return dns.resolve(hostname, rrtype);\n    }\n  },\n  resolve4(hostname, options) {\n    if (options\?.ttl)\n      return dns.lookup(hostname, { family: 4 });\n    return dns.lookup(hostname, { family: 4 }).then(promisifyResolveX);\n  },\n  resolve6(hostname, options) {\n    if (options\?.ttl)\n      return dns.lookup(hostname, { family: 6 });\n    return dns.lookup(hostname, { family: 6 }).then(promisifyResolveX);\n  },\n  resolveSrv(hostname) {\n    return dns.resolveSrv(hostname);\n  },\n  resolveTxt(hostname) {\n    return dns.resolveTxt(hostname);\n  },\n  resolveSoa(hostname) {\n    return dns.resolveSoa(hostname);\n  },\n  resolveNaptr(hostname) {\n    return dns.resolveNaptr(hostname);\n  },\n  resolveMx(hostname) {\n    return dns.resolveMx(hostname);\n  },\n  resolveCaa(hostname) {\n    return dns.resolveCaa(hostname);\n  },\n  resolveNs(hostname) {\n    return dns.resolveNs(hostname);\n  },\n  resolvePtr(hostname) {\n    return dns.resolvePtr(hostname);\n  },\n  resolveCname(hostname) {\n    return dns.resolveCname(hostname);\n  },\n  Resolver: class Resolver3 {\n    constructor(options) {\n    }\n    cancel() {\n    }\n    getServers() {\n      return [];\n    }\n    resolve(hostname, rrtype) {\n      if (typeof rrtype !== \"string\")\n        rrtype = null;\n      switch (rrtype\?.toLowerCase()) {\n        case \"a\":\n        case \"aaaa\":\n          return dns.resolve(hostname, rrtype).then(promisifyLookup);\n        default:\n          return dns.resolve(hostname, rrtype);\n      }\n    }\n    resolve4(hostname, options) {\n      if (options\?.ttl)\n        return dns.lookup(hostname, { family: 4 });\n      return dns.lookup(hostname, { family: 4 }).then(promisifyResolveX);\n    }\n    resolve6(hostname, options) {\n      if (options\?.ttl)\n        return dns.lookup(hostname, { family: 6 });\n      return dns.lookup(hostname, { family: 6 }).then(promisifyResolveX);\n    }\n    resolveAny(hostname) {\n      return Promise.resolve([]);\n    }\n    resolveCname(hostname) {\n      return dns.resolveCname(hostname);\n    }\n    resolveMx(hostname) {\n      return dns.resolveMx(hostname);\n    }\n    resolveNaptr(hostname) {\n      return dns.resolveNaptr(hostname);\n    }\n    resolveNs(hostname) {\n      return dns.resolveNs(hostname);\n    }\n    resolvePtr(hostname) {\n      return dns.resolvePtr(hostname);\n    }\n    resolveSoa(hostname) {\n      return dns.resolveSoa(hostname);\n    }\n    resolveSrv(hostname) {\n      return dns.resolveSrv(hostname);\n    }\n    resolveCaa(hostname) {\n      return dns.resolveCaa(hostname);\n    }\n    resolveTxt(hostname) {\n      return dns.resolveTxt(hostname);\n    }\n    reverse(ip) {\n      return Promise.resolve([]);\n    }\n    setServers(servers) {\n    }\n  }\n};\nfor (let key of [\"resolveAny\", \"reverse\"])\n  promises[key] = () => Promise.resolve(void 0);\n$ = {\n  ADDRCONFIG: 0,\n  ALL: 1,\n  V4MAPPED: 2,\n  NODATA: \"DNS_ENODATA\",\n  FORMERR: \"DNS_EFORMERR\",\n  SERVFAIL: \"DNS_ESERVFAIL\",\n  NOTFOUND: \"DNS_ENOTFOUND\",\n  NOTIMP: \"DNS_ENOTIMP\",\n  REFUSED: \"DNS_EREFUSED\",\n  BADQUERY: \"DNS_EBADQUERY\",\n  BADNAME: \"DNS_EBADNAME\",\n  BADFAMILY: \"DNS_EBADFAMILY\",\n  BADRESP: \"DNS_EBADRESP\",\n  CONNREFUSED: \"DNS_ECONNREFUSED\",\n  TIMEOUT: \"DNS_ETIMEOUT\",\n  EOF: \"DNS_EEOF\",\n  FILE: \"DNS_EFILE\",\n  NOMEM: \"DNS_ENOMEM\",\n  DESTRUCTION: \"DNS_EDESTRUCTION\",\n  BADSTR: \"DNS_EBADSTR\",\n  BADFLAGS: \"DNS_EBADFLAGS\",\n  NONAME: \"DNS_ENONAME\",\n  BADHINTS: \"DNS_EBADHINTS\",\n  NOTINITIALIZED: \"DNS_ENOTINITIALIZED\",\n  LOADIPHLPAPI: \"DNS_ELOADIPHLPAPI\",\n  ADDRGETNETWORKPARAMS: \"DNS_EADDRGETNETWORKPARAMS\",\n  CANCELLED: \"DNS_ECANCELLED\",\n  lookup,\n  lookupService,\n  Resolver,\n  setServers,\n  setDefaultResultOrder,\n  resolve,\n  reverse,\n  resolve4,\n  resolve6,\n  resolveAny,\n  resolveCname,\n  resolveCaa,\n  resolveMx,\n  resolveNs,\n  resolvePtr,\n  resolveSoa,\n  resolveSrv,\n  resolveTxt,\n  resolveNaptr,\n  promises,\n  getServers\n};\nreturn $})\n"_s;
//

//
static constexpr ASCIILiteral NodeDNSPromisesCode = "(function (){\"use strict\";// src/js/out/tmp/node/dns.promises.ts\nreturn (@getInternalField(@internalModuleRegistry, 13) || @createInternalModuleById(13)).promises})\n"_s;
//

//
static constexpr ASCIILiteral NodeDomainCode = "(function (){\"use strict\";// src/js/out/tmp/node/domain.ts\nvar EventEmitter = @getInternalField(@internalModuleRegistry, 16) || @createInternalModuleById(16), domain = {};\ndomain.createDomain = domain.create = function() {\n  var d = new EventEmitter;\n  function emitError(e) {\n    d.emit(\"error\", e);\n  }\n  return d.add = function(emitter) {\n    emitter.on(\"error\", emitError);\n  }, d.remove = function(emitter) {\n    emitter.removeListener(\"error\", emitError);\n  }, d.bind = function(fn) {\n    return function() {\n      var args = Array.prototype.slice.call(arguments);\n      try {\n        fn.apply(null, args);\n      } catch (err) {\n        emitError(err);\n      }\n    };\n  }, d.intercept = function(fn) {\n    return function(err) {\n      if (err)\n        emitError(err);\n      else {\n        var args = Array.prototype.slice.call(arguments, 1);\n        try {\n          fn.apply(null, args);\n        } catch (err2) {\n          emitError(err2);\n        }\n      }\n    };\n  }, d.run = function(fn) {\n    try {\n      fn();\n    } catch (err) {\n      emitError(err);\n    }\n    return this;\n  }, d.dispose = function() {\n    return this.removeAllListeners(), this;\n  }, d.enter = d.exit = function() {\n    return this;\n  }, d;\n};\nreturn domain})\n"_s;
//

//
static constexpr ASCIILiteral NodeEventsCode = "(function (){\"use strict\";// src/js/out/tmp/node/events.ts\nvar emitError = function(emitter, args) {\n  var { _events: events } = emitter;\n  if (args[0] \?\?= new Error(\"Unhandled error.\"), !events)\n    throw args[0];\n  var errorMonitor = events[kErrorMonitor];\n  if (errorMonitor)\n    for (var handler of ArrayPrototypeSlice.call(errorMonitor))\n      handler.apply(emitter, args);\n  var handlers = events.error;\n  if (!handlers)\n    throw args[0];\n  for (var handler of ArrayPrototypeSlice.call(handlers))\n    handler.apply(emitter, args);\n  return !0;\n}, addCatch = function(emitter, promise, type, args) {\n  promise.then(void 0, function(err) {\n    process.nextTick(emitUnhandledRejectionOrErr, emitter, err, type, args);\n  });\n}, emitUnhandledRejectionOrErr = function(emitter, err, type, args) {\n  if (typeof emitter[kRejection] === \"function\")\n    emitter[kRejection](err, type, ...args);\n  else\n    try {\n      emitter[kCapture] = !1, emitter.emit(\"error\", err);\n    } finally {\n      emitter[kCapture] = !0;\n    }\n}, overflowWarning = function(emitter, type, handlers) {\n  handlers.warned = !0;\n  const warn = new Error(`Possible EventEmitter memory leak detected. ${handlers.length} ${String(type)} listeners ` + `added to [${emitter.constructor.name}]. Use emitter.setMaxListeners() to increase limit`);\n  warn.name = \"MaxListenersExceededWarning\", warn.emitter = emitter, warn.type = type, warn.count = handlers.length, process.emitWarning(warn);\n}, onceWrapper = function(type, listener, ...args) {\n  this.removeListener(type, listener), listener.apply(this, args);\n}, once = function(emitter, type, options) {\n  var signal = options\?.signal;\n  if (validateAbortSignal(signal, \"options.signal\"), signal\?.aborted)\n    throw new AbortError(void 0, { cause: signal\?.reason });\n  return new Promise((resolve, reject) => {\n    const errorListener = (err) => {\n      if (emitter.removeListener(type, resolver), signal != null)\n        eventTargetAgnosticRemoveListener(signal, \"abort\", abortListener);\n      reject(err);\n    }, resolver = (...args) => {\n      if (typeof emitter.removeListener === \"function\")\n        emitter.removeListener(\"error\", errorListener);\n      if (signal != null)\n        eventTargetAgnosticRemoveListener(signal, \"abort\", abortListener);\n      resolve(args);\n    };\n    if (eventTargetAgnosticAddListener(emitter, type, resolver, { once: !0 }), type !== \"error\" && typeof emitter.once === \"function\")\n      emitter.once(\"error\", errorListener);\n    function abortListener() {\n      eventTargetAgnosticRemoveListener(emitter, type, resolver), eventTargetAgnosticRemoveListener(emitter, \"error\", errorListener), reject(new AbortError(void 0, { cause: signal\?.reason }));\n    }\n    if (signal != null)\n      eventTargetAgnosticAddListener(signal, \"abort\", abortListener, { once: !0 });\n  });\n}, on = function(emitter, type, options) {\n  var { signal, close, highWatermark = Number.MAX_SAFE_INTEGER, lowWatermark = 1 } = options || {};\n  throwNotImplemented(\"events.on\", 2679);\n}, getEventListeners = function(emitter, type) {\n  if (emitter instanceof EventTarget)\n    throwNotImplemented(\"getEventListeners with an EventTarget\", 2678);\n  return emitter.listeners(type);\n}, setMaxListeners = function(n, ...eventTargets) {\n  validateNumber(n, \"setMaxListeners\", 0);\n  var length;\n  if (eventTargets && (length = eventTargets.length))\n    for (let i = 0;i < length; i++)\n      eventTargets[i].setMaxListeners(n);\n  else\n    defaultMaxListeners = n;\n}, listenerCount = function(emitter, type) {\n  return emitter.listenerCount(type);\n}, eventTargetAgnosticRemoveListener = function(emitter, name, listener, flags) {\n  if (typeof emitter.removeListener === \"function\")\n    emitter.removeListener(name, listener);\n  else\n    emitter.removeEventListener(name, listener, flags);\n}, eventTargetAgnosticAddListener = function(emitter, name, listener, flags) {\n  if (typeof emitter.on === \"function\")\n    emitter.on(name, listener);\n  else\n    emitter.addEventListener(name, listener);\n}, ERR_INVALID_ARG_TYPE = function(name, type, value) {\n  const err = @makeTypeError(`The \"${name}\" argument must be of type ${type}. Received ${value}`);\n  return err.code = \"ERR_INVALID_ARG_TYPE\", err;\n}, ERR_OUT_OF_RANGE = function(name, range, value) {\n  const err = new RangeError(`The \"${name}\" argument is out of range. It must be ${range}. Received ${value}`);\n  return err.code = \"ERR_OUT_OF_RANGE\", err;\n}, validateAbortSignal = function(signal, name) {\n  if (signal !== void 0 && (signal === null || typeof signal !== \"object\" || !(\"aborted\" in signal)))\n    throw new ERR_INVALID_ARG_TYPE(name, \"AbortSignal\", signal);\n}, validateNumber = function(value, name, min = void 0, max) {\n  if (typeof value !== \"number\")\n    throw new ERR_INVALID_ARG_TYPE(name, \"number\", value);\n  if (min != null && value < min || max != null && value > max || (min != null || max != null) && Number.isNaN(value))\n    throw new ERR_OUT_OF_RANGE(name, `${min != null \? `>= ${min}` : \"\"}${min != null && max != null \? \" && \" : \"\"}${max != null \? `<= ${max}` : \"\"}`, value);\n}, checkListener = function(listener) {\n  if (typeof listener !== \"function\")\n    @throwTypeError(\"The listener must be a function\");\n}, { throwNotImplemented } = @getInternalField(@internalModuleRegistry, 3) || @createInternalModuleById(3), SymbolFor = Symbol.for, kCapture = Symbol(\"kCapture\"), kErrorMonitor = SymbolFor(\"events.errorMonitor\"), kMaxEventTargetListeners = Symbol(\"events.maxEventTargetListeners\"), kMaxEventTargetListenersWarned = Symbol(\"events.maxEventTargetListenersWarned\"), kWatermarkData = SymbolFor(\"nodejs.watermarkData\"), kRejection = SymbolFor(\"nodejs.rejection\"), captureRejectionSymbol = SymbolFor(\"nodejs.rejection\"), ArrayPrototypeSlice = Array.prototype.slice, defaultMaxListeners = 10, EventEmitter = function EventEmitter2(opts) {\n  if (this._events === void 0 || this._events === this.__proto__._events)\n    this._events = { __proto__: null }, this._eventsCount = 0;\n  if (this._maxListeners \?\?= void 0, this[kCapture] = opts\?.captureRejections \? Boolean(opts\?.captureRejections) : EventEmitterPrototype[kCapture])\n    this.emit = emitWithRejectionCapture;\n}, EventEmitterPrototype = EventEmitter.prototype = {};\nEventEmitterPrototype._events = void 0;\nEventEmitterPrototype._eventsCount = 0;\nEventEmitterPrototype._maxListeners = void 0;\nEventEmitterPrototype.setMaxListeners = function setMaxListeners2(n) {\n  return validateNumber(n, \"setMaxListeners\", 0), this._maxListeners = n, this;\n};\nEventEmitterPrototype.getMaxListeners = function getMaxListeners() {\n  return this._maxListeners \?\? defaultMaxListeners;\n};\nvar emitWithoutRejectionCapture = function emit(type, ...args) {\n  if (type === \"error\")\n    return emitError(this, args);\n  var { _events: events } = this;\n  if (events === void 0)\n    return !1;\n  var handlers = events[type];\n  if (handlers === void 0)\n    return !1;\n  for (var handler of [...handlers])\n    handler.apply(this, args);\n  return !0;\n}, emitWithRejectionCapture = function emit2(type, ...args) {\n  if (type === \"error\")\n    return emitError(this, args);\n  var { _events: events } = this;\n  if (events === void 0)\n    return !1;\n  var handlers = events[type];\n  if (handlers === void 0)\n    return !1;\n  for (var handler of [...handlers]) {\n    var result = handler.apply(this, args);\n    if (result !== void 0 && @isPromise(result))\n      addCatch(this, result, type, args);\n  }\n  return !0;\n};\nEventEmitterPrototype.emit = emitWithoutRejectionCapture;\nEventEmitterPrototype.addListener = function addListener(type, fn) {\n  checkListener(fn);\n  var events = this._events;\n  if (!events)\n    events = this._events = { __proto__: null }, this._eventsCount = 0;\n  else if (events.newListener)\n    this.emit(\"newListener\", type, fn.listener \?\? fn);\n  var handlers = events[type];\n  if (!handlers)\n    events[type] = [fn], this._eventsCount++;\n  else {\n    handlers.push(fn);\n    var m = this._maxListeners \?\? defaultMaxListeners;\n    if (m > 0 && handlers.length > m && !handlers.warned)\n      overflowWarning(this, type, handlers);\n  }\n  return this;\n};\nEventEmitterPrototype.on = EventEmitterPrototype.addListener;\nEventEmitterPrototype.prependListener = function prependListener(type, fn) {\n  checkListener(fn);\n  var events = this._events;\n  if (!events)\n    events = this._events = { __proto__: null }, this._eventsCount = 0;\n  else if (events.newListener)\n    this.emit(\"newListener\", type, fn.listener \?\? fn);\n  var handlers = events[type];\n  if (!handlers)\n    events[type] = [fn], this._eventsCount++;\n  else {\n    handlers.unshift(fn);\n    var m = this._maxListeners \?\? defaultMaxListeners;\n    if (m > 0 && handlers.length > m && !handlers.warned)\n      overflowWarning(this, type, handlers);\n  }\n  return this;\n};\nEventEmitterPrototype.once = function once2(type, fn) {\n  checkListener(fn);\n  const bound = onceWrapper.bind(this, type, fn);\n  return bound.listener = fn, this.addListener(type, bound), this;\n};\nEventEmitterPrototype.prependOnceListener = function prependOnceListener(type, fn) {\n  checkListener(fn);\n  const bound = onceWrapper.bind(this, type, fn);\n  return bound.listener = fn, this.prependListener(type, bound), this;\n};\nEventEmitterPrototype.removeListener = function removeListener(type, fn) {\n  checkListener(fn);\n  var { _events: events } = this;\n  if (!events)\n    return this;\n  var handlers = events[type];\n  if (!handlers)\n    return this;\n  var length = handlers.length;\n  let position = -1;\n  for (let i = length - 1;i >= 0; i--)\n    if (handlers[i] === fn || handlers[i].listener === fn) {\n      position = i;\n      break;\n    }\n  if (position < 0)\n    return this;\n  if (position === 0)\n    handlers.shift();\n  else\n    handlers.splice(position, 1);\n  if (handlers.length === 0)\n    delete events[type], this._eventsCount--;\n  return this;\n};\nEventEmitterPrototype.off = EventEmitterPrototype.removeListener;\nEventEmitterPrototype.removeAllListeners = function removeAllListeners(type) {\n  var { _events: events } = this;\n  if (type && events) {\n    if (events[type])\n      delete events[type], this._eventsCount--;\n  } else\n    this._events = { __proto__: null };\n  return this;\n};\nEventEmitterPrototype.listeners = function listeners(type) {\n  var { _events: events } = this;\n  if (!events)\n    return [];\n  var handlers = events[type];\n  if (!handlers)\n    return [];\n  return handlers.map((x) => x.listener \?\? x);\n};\nEventEmitterPrototype.rawListeners = function rawListeners(type) {\n  var { _events } = this;\n  if (!_events)\n    return [];\n  var handlers = _events[type];\n  if (!handlers)\n    return [];\n  return handlers.slice();\n};\nEventEmitterPrototype.listenerCount = function listenerCount2(type) {\n  var { _events: events } = this;\n  if (!events)\n    return 0;\n  return events[type]\?.length \?\? 0;\n};\nEventEmitterPrototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 \? Reflect.ownKeys(this._events) : [];\n};\nEventEmitterPrototype[kCapture] = !1;\n\nclass AbortError extends Error {\n  constructor(message = \"The operation was aborted\", options = void 0) {\n    if (options !== void 0 && typeof options !== \"object\")\n      throw new codes.ERR_INVALID_ARG_TYPE(\"options\", \"Object\", options);\n    super(message, options);\n    this.code = \"ABORT_ERR\", this.name = \"AbortError\";\n  }\n}\nvar AsyncResource = null;\n\nclass EventEmitterAsyncResource extends EventEmitter {\n  triggerAsyncId;\n  asyncResource;\n  constructor(options) {\n    if (!AsyncResource)\n      AsyncResource = (@getInternalField(@internalModuleRegistry, 6) || @createInternalModuleById(6)).AsyncResource;\n    var { captureRejections = !1, triggerAsyncId, name = new.target.name, requireManualDestroy } = options || {};\n    super({ captureRejections });\n    this.triggerAsyncId = triggerAsyncId \?\? 0, this.asyncResource = new AsyncResource(name, { triggerAsyncId, requireManualDestroy });\n  }\n  emit(...args) {\n    this.asyncResource.runInAsyncScope(() => super.emit(...args));\n  }\n  emitDestroy() {\n    this.asyncResource.emitDestroy();\n  }\n}\nObject.defineProperties(EventEmitter, {\n  captureRejections: {\n    get() {\n      return EventEmitterPrototype[kCapture];\n    },\n    set(value) {\n      validateBoolean(value, \"EventEmitter.captureRejections\"), EventEmitterPrototype[kCapture] = value;\n    },\n    enumerable: !0\n  },\n  defaultMaxListeners: {\n    enumerable: !0,\n    get: () => {\n      return defaultMaxListeners;\n    },\n    set: (arg) => {\n      validateNumber(arg, \"defaultMaxListeners\", 0), defaultMaxListeners = arg;\n    }\n  },\n  kMaxEventTargetListeners: {\n    value: kMaxEventTargetListeners,\n    enumerable: !1,\n    configurable: !1,\n    writable: !1\n  },\n  kMaxEventTargetListenersWarned: {\n    value: kMaxEventTargetListenersWarned,\n    enumerable: !1,\n    configurable: !1,\n    writable: !1\n  }\n});\nObject.assign(EventEmitter, {\n  once,\n  on,\n  getEventListeners,\n  setMaxListeners,\n  EventEmitter,\n  usingDomains: !1,\n  captureRejectionSymbol,\n  EventEmitterAsyncResource,\n  errorMonitor: kErrorMonitor,\n  setMaxListeners,\n  init: EventEmitter,\n  listenerCount\n});\nreturn EventEmitter})\n"_s;
//

//
static constexpr ASCIILiteral NodeFSCode = "(function (){\"use strict\";// src/js/out/tmp/node/fs.ts\nvar callbackify = function(fsFunction, args) {\n  try {\n    const result = fsFunction.apply(fs, args.slice(0, args.length - 1)), callback = args[args.length - 1];\n    if (typeof callback === \"function\")\n      queueMicrotask(() => callback(null, result));\n  } catch (e) {\n    const callback = args[args.length - 1];\n    if (typeof callback === \"function\")\n      queueMicrotask(() => callback(e));\n  }\n}, createReadStream = function(path, options) {\n  return new ReadStream(path, options);\n}, createWriteStream = function(path, options) {\n  return new WriteStream(path, options);\n}, $, ReadStream, WriteStream, EventEmitter = @getInternalField(@internalModuleRegistry, 16) || @createInternalModuleById(16), promises = @getInternalField(@internalModuleRegistry, 18) || @createInternalModuleById(18), Stream = @getInternalField(@internalModuleRegistry, 35) || @createInternalModuleById(35), { isArrayBufferView } = @requireNativeModule(\"node:util/types\"), fs = Bun.fs();\n\nclass FSWatcher extends EventEmitter {\n  #watcher;\n  #listener;\n  constructor(path, options, listener) {\n    super();\n    if (typeof options === \"function\")\n      listener = options, options = {};\n    else if (typeof options === \"string\")\n      options = { encoding: options };\n    if (typeof listener !== \"function\")\n      listener = () => {\n      };\n    this.#listener = listener;\n    try {\n      this.#watcher = fs.watch(path, options || {}, this.#onEvent.bind(this));\n    } catch (e) {\n      if (!e.message\?.startsWith(\"FileNotFound\"))\n        throw e;\n      const notFound = new Error(`ENOENT: no such file or directory, watch '${path}'`);\n      throw notFound.code = \"ENOENT\", notFound.errno = -2, notFound.path = path, notFound.syscall = \"watch\", notFound.filename = path, notFound;\n    }\n  }\n  #onEvent(eventType, filenameOrError) {\n    if (eventType === \"error\" || eventType === \"close\")\n      this.emit(eventType, filenameOrError);\n    else\n      this.emit(\"change\", eventType, filenameOrError), this.#listener(eventType, filenameOrError);\n  }\n  close() {\n    this.#watcher\?.close(), this.#watcher = null;\n  }\n  ref() {\n    this.#watcher\?.ref();\n  }\n  unref() {\n    this.#watcher\?.unref();\n  }\n}\nvar access = function access2(...args) {\n  callbackify(fs.accessSync, args);\n}, appendFile = function appendFile2(...args) {\n  callbackify(fs.appendFileSync, args);\n}, close = function close2(...args) {\n  callbackify(fs.closeSync, args);\n}, rm = function rm2(...args) {\n  callbackify(fs.rmSync, args);\n}, rmdir = function rmdir2(...args) {\n  callbackify(fs.rmdirSync, args);\n}, copyFile = function copyFile2(...args) {\n  callbackify(fs.copyFileSync, args);\n}, exists = function exists2(...args) {\n  callbackify(fs.existsSync, args);\n}, chown = function chown2(...args) {\n  callbackify(fs.chownSync, args);\n}, chmod = function chmod2(...args) {\n  callbackify(fs.chmodSync, args);\n}, fchmod = function fchmod2(...args) {\n  callbackify(fs.fchmodSync, args);\n}, fchown = function fchown2(...args) {\n  callbackify(fs.fchownSync, args);\n}, fstat = function fstat2(...args) {\n  callbackify(fs.fstatSync, args);\n}, fsync = function fsync2(...args) {\n  callbackify(fs.fsyncSync, args);\n}, ftruncate = function ftruncate2(...args) {\n  callbackify(fs.ftruncateSync, args);\n}, futimes = function futimes2(...args) {\n  callbackify(fs.futimesSync, args);\n}, lchmod = function lchmod2(...args) {\n  callbackify(fs.lchmodSync, args);\n}, lchown = function lchown2(...args) {\n  callbackify(fs.lchownSync, args);\n}, link = function link2(...args) {\n  callbackify(fs.linkSync, args);\n}, mkdir = function mkdir2(...args) {\n  callbackify(fs.mkdirSync, args);\n}, mkdtemp = function mkdtemp2(...args) {\n  callbackify(fs.mkdtempSync, args);\n}, open = function open2(...args) {\n  callbackify(fs.openSync, args);\n}, read = function read2(fd, buffer, offsetOrOptions, length, position, callback) {\n  let offset = offsetOrOptions, params = null;\n  if (arguments.length <= 4) {\n    if (arguments.length === 4)\n      callback = length, params = offsetOrOptions;\n    else if (arguments.length === 3) {\n      if (!isArrayBufferView(buffer))\n        params = buffer, { buffer = Buffer.alloc(16384) } = params \?\? {};\n      callback = offsetOrOptions;\n    } else\n      callback = buffer, buffer = Buffer.alloc(16384);\n    ({ offset = 0, length = buffer\?.byteLength - offset, position = null } = params \?\? {});\n  }\n  queueMicrotask(() => {\n    try {\n      var bytesRead = fs.readSync(fd, buffer, offset, length, position);\n    } catch (e) {\n      callback(e);\n    }\n    callback(null, bytesRead, buffer);\n  });\n}, write = function write2(...args) {\n  callbackify(fs.writeSync, args);\n}, readdir = function readdir2(...args) {\n  const callback = args[args.length - 1];\n  if (typeof callback !== \"function\")\n    @throwTypeError(\"Callback must be a function\");\n  fs.readdir(...args).then((result) => callback(null, result), callback);\n}, readFile = function readFile2(...args) {\n  const callback = args[args.length - 1];\n  if (typeof callback !== \"function\")\n    @throwTypeError(\"Callback must be a function\");\n  fs.readFile(...args).then((result) => callback(null, result), callback);\n}, writeFile = function writeFile2(...args) {\n  callbackify(fs.writeFileSync, args);\n}, readlink = function readlink2(...args) {\n  callbackify(fs.readlinkSync, args);\n}, realpath = function realpath2(...args) {\n  const callback = args[args.length - 1];\n  if (typeof callback !== \"function\")\n    @throwTypeError(\"Callback must be a function\");\n  fs.realpath(...args).then((result) => callback(null, result), callback);\n}, rename = function rename2(...args) {\n  callbackify(fs.renameSync, args);\n}, lstat = function lstat2(...args) {\n  const callback = args[args.length - 1];\n  if (typeof callback !== \"function\")\n    @throwTypeError(\"Callback must be a function\");\n  fs.lstat(...args).then((result) => callback(null, result), callback);\n}, stat = function stat2(...args) {\n  const callback = args[args.length - 1];\n  if (typeof callback !== \"function\")\n    @throwTypeError(\"Callback must be a function\");\n  fs.stat(...args).then((result) => callback(null, result), callback);\n}, symlink = function symlink2(...args) {\n  callbackify(fs.symlinkSync, args);\n}, truncate = function truncate2(...args) {\n  callbackify(fs.truncateSync, args);\n}, unlink = function unlink2(...args) {\n  callbackify(fs.unlinkSync, args);\n}, utimes = function utimes2(...args) {\n  callbackify(fs.utimesSync, args);\n}, lutimes = function lutimes2(...args) {\n  callbackify(fs.lutimesSync, args);\n}, accessSync = fs.accessSync.bind(fs), appendFileSync = fs.appendFileSync.bind(fs), closeSync = fs.closeSync.bind(fs), copyFileSync = fs.copyFileSync.bind(fs), existsSync = fs.existsSync.bind(fs), chownSync = fs.chownSync.bind(fs), chmodSync = fs.chmodSync.bind(fs), fchmodSync = fs.fchmodSync.bind(fs), fchownSync = fs.fchownSync.bind(fs), fstatSync = fs.fstatSync.bind(fs), fsyncSync = fs.fsyncSync.bind(fs), ftruncateSync = fs.ftruncateSync.bind(fs), futimesSync = fs.futimesSync.bind(fs), lchmodSync = fs.lchmodSync.bind(fs), lchownSync = fs.lchownSync.bind(fs), linkSync = fs.linkSync.bind(fs), lstatSync = fs.lstatSync.bind(fs), mkdirSync = fs.mkdirSync.bind(fs), mkdtempSync = fs.mkdtempSync.bind(fs), openSync = fs.openSync.bind(fs), readSync = fs.readSync.bind(fs), writeSync = fs.writeSync.bind(fs), readdirSync = fs.readdirSync.bind(fs), readFileSync = fs.readFileSync.bind(fs), writeFileSync = fs.writeFileSync.bind(fs), readlinkSync = fs.readlinkSync.bind(fs), realpathSync = fs.realpathSync.bind(fs), renameSync = fs.renameSync.bind(fs), statSync = fs.statSync.bind(fs), symlinkSync = fs.symlinkSync.bind(fs), truncateSync = fs.truncateSync.bind(fs), unlinkSync = fs.unlinkSync.bind(fs), utimesSync = fs.utimesSync.bind(fs), lutimesSync = fs.lutimesSync.bind(fs), rmSync = fs.rmSync.bind(fs), rmdirSync = fs.rmdirSync.bind(fs), writev = (fd, buffers, position, callback) => {\n  if (typeof position === \"function\")\n    callback = position, position = null;\n  queueMicrotask(() => {\n    try {\n      var written = fs.writevSync(fd, buffers, position);\n    } catch (e) {\n      callback(e);\n    }\n    callback(null, written, buffers);\n  });\n}, writevSync = fs.writevSync.bind(fs), readv = (fd, buffers, position, callback) => {\n  if (typeof position === \"function\")\n    callback = position, position = null;\n  queueMicrotask(() => {\n    try {\n      var written = fs.readvSync(fd, buffers, position);\n    } catch (e) {\n      callback(e);\n    }\n    callback(null, written, buffers);\n  });\n}, readvSync = fs.readvSync.bind(fs), Dirent = fs.Dirent, Stats = fs.Stats, watch = function watch2(path, options, listener) {\n  return new FSWatcher(path, options, listener);\n}, readStreamPathFastPathSymbol = Symbol.for(\"Bun.Node.readStreamPathFastPath\"), readStreamSymbol = Symbol.for(\"Bun.NodeReadStream\"), readStreamPathOrFdSymbol = Symbol.for(\"Bun.NodeReadStreamPathOrFd\"), writeStreamSymbol = Symbol.for(\"Bun.NodeWriteStream\"), writeStreamPathFastPathSymbol = Symbol.for(\"Bun.NodeWriteStreamFastPath\"), writeStreamPathFastPathCallSymbol = Symbol.for(\"Bun.NodeWriteStreamFastPathCall\"), kIoDone = Symbol.for(\"kIoDone\"), defaultReadStreamOptions = {\n  file: void 0,\n  fd: void 0,\n  flags: \"r\",\n  encoding: void 0,\n  mode: 438,\n  autoClose: !0,\n  emitClose: !0,\n  start: 0,\n  end: Infinity,\n  highWaterMark: 65536,\n  fs: {\n    read,\n    open: (path, flags, mode, cb) => {\n      var fd;\n      try {\n        fd = openSync(path, flags, mode);\n      } catch (e) {\n        cb(e);\n        return;\n      }\n      cb(null, fd);\n    },\n    openSync,\n    close\n  },\n  autoDestroy: !0\n}, ReadStreamClass;\nReadStream = function(InternalReadStream) {\n  ReadStreamClass = InternalReadStream, Object.defineProperty(ReadStreamClass.prototype, Symbol.toStringTag, {\n    value: \"ReadStream\",\n    enumerable: !1\n  });\n  function ReadStream3(path, options) {\n    return new InternalReadStream(path, options);\n  }\n  return ReadStream3.prototype = InternalReadStream.prototype, Object.defineProperty(ReadStream3, Symbol.hasInstance, {\n    value(instance) {\n      return instance instanceof InternalReadStream;\n    }\n  });\n}(class ReadStream2 extends Stream._getNativeReadableStreamPrototype(2, Stream.Readable) {\n  constructor(pathOrFd, options = defaultReadStreamOptions) {\n    if (typeof options !== \"object\" || !options)\n      @throwTypeError(\"Expected options to be an object\");\n    var {\n      flags = defaultReadStreamOptions.flags,\n      encoding = defaultReadStreamOptions.encoding,\n      mode = defaultReadStreamOptions.mode,\n      autoClose = defaultReadStreamOptions.autoClose,\n      emitClose = defaultReadStreamOptions.emitClose,\n      start = defaultReadStreamOptions.start,\n      end = defaultReadStreamOptions.end,\n      autoDestroy = defaultReadStreamOptions.autoClose,\n      fs: fs2 = defaultReadStreamOptions.fs,\n      highWaterMark = defaultReadStreamOptions.highWaterMark\n    } = options;\n    if (pathOrFd\?.constructor\?.name === \"URL\")\n      pathOrFd = Bun.fileURLToPath(pathOrFd);\n    var tempThis = {};\n    if (typeof pathOrFd === \"string\") {\n      if (pathOrFd.startsWith(\"file://\"))\n        pathOrFd = Bun.fileURLToPath(pathOrFd);\n      if (pathOrFd.length === 0)\n        @throwTypeError(\"Expected path to be a non-empty string\");\n      tempThis.path = tempThis.file = tempThis[readStreamPathOrFdSymbol] = pathOrFd;\n    } else if (typeof pathOrFd === \"number\") {\n      if (pathOrFd |= 0, pathOrFd < 0)\n        @throwTypeError(\"Expected fd to be a positive integer\");\n      tempThis.fd = tempThis[readStreamPathOrFdSymbol] = pathOrFd, tempThis.autoClose = !1;\n    } else\n      @throwTypeError(\"Expected a path or file descriptor\");\n    if (!tempThis.fd)\n      tempThis.fd = fs2.openSync(pathOrFd, flags, mode);\n    var fileRef = Bun.file(tempThis.fd), stream = fileRef.stream(), native = @direct(stream);\n    if (!native)\n      throw new Error(\"no native readable stream\");\n    var { stream: ptr } = native;\n    super(ptr, {\n      ...options,\n      encoding,\n      autoDestroy,\n      autoClose,\n      emitClose,\n      highWaterMark\n    });\n    if (Object.assign(this, tempThis), this.#fileRef = fileRef, this.end = end, this._read = this.#internalRead, this.start = start, this.flags = flags, this.mode = mode, this.emitClose = emitClose, this[readStreamPathFastPathSymbol] = start === 0 && end === Infinity && autoClose && fs2 === defaultReadStreamOptions.fs && (encoding === \"buffer\" || encoding === \"binary\" || encoding == null || encoding === \"utf-8\" || encoding === \"utf8\"), this._readableState.autoClose = autoDestroy = autoClose, this._readableState.highWaterMark = highWaterMark, start !== void 0)\n      this.pos = start;\n  }\n  #fileRef;\n  #fs;\n  file;\n  path;\n  fd = null;\n  flags;\n  mode;\n  start;\n  end;\n  pos;\n  bytesRead = 0;\n  #fileSize = -1;\n  _read;\n  [readStreamSymbol] = !0;\n  [readStreamPathOrFdSymbol];\n  [readStreamPathFastPathSymbol];\n  _construct(callback) {\n    if (super._construct)\n      super._construct(callback);\n    else\n      callback();\n    this.emit(\"open\", this.fd), this.emit(\"ready\");\n  }\n  _destroy(err, cb) {\n    super._destroy(err, cb);\n    try {\n      var fd = this.fd;\n      if (this[readStreamPathFastPathSymbol] = !1, !fd)\n        cb(err);\n      else\n        this.#fs.close(fd, (er) => {\n          cb(er || err);\n        }), this.fd = null;\n    } catch (e) {\n      throw e;\n    }\n  }\n  close(cb) {\n    if (typeof cb === \"function\")\n      eos_()(this, cb);\n    this.destroy();\n  }\n  push(chunk) {\n    var bytesRead = chunk\?.length \?\? 0;\n    if (bytesRead > 0) {\n      this.bytesRead += bytesRead;\n      var currPos = this.pos;\n      if (currPos !== void 0) {\n        if (this.bytesRead < currPos)\n          return !0;\n        if (currPos === this.start) {\n          var n = this.bytesRead - currPos;\n          chunk = chunk.slice(-n);\n          var [_, ...rest] = arguments;\n          if (this.pos = this.bytesRead, this.end !== void 0 && this.bytesRead > this.end)\n            chunk = chunk.slice(0, this.end - this.start + 1);\n          return super.push(chunk, ...rest);\n        }\n        var end = this.end;\n        if (end !== void 0 && this.bytesRead > end) {\n          chunk = chunk.slice(0, end - currPos + 1);\n          var [_, ...rest] = arguments;\n          return this.pos = this.bytesRead, super.push(chunk, ...rest);\n        }\n        this.pos = this.bytesRead;\n      }\n    }\n    return super.push(...arguments);\n  }\n  #internalRead(n) {\n    var { pos, end, bytesRead, fd, encoding } = this;\n    if (n = pos !== void 0 \? Math.min(end - pos + 1, n) : Math.min(end - bytesRead + 1, n), n <= 0) {\n      this.push(null);\n      return;\n    }\n    if (this.#fileSize === -1 && bytesRead === 0 && pos === void 0) {\n      var stat3 = fstatSync(fd);\n      if (this.#fileSize = stat3.size, this.#fileSize > 0 && n > this.#fileSize)\n        n = this.#fileSize + 1;\n    }\n    this[kIoDone] = !1;\n    var res = super._read(n);\n    if (@isPromise(res)) {\n      var then = res\?.then;\n      if (then && @isCallable(then))\n        res.then(() => {\n          if (this[kIoDone] = !0, this.destroyed)\n            this.emit(kIoDone);\n        }, (er) => {\n          this[kIoDone] = !0, this.#errorOrDestroy(er);\n        });\n    } else if (this[kIoDone] = !0, this.destroyed)\n      this.emit(kIoDone), this.#errorOrDestroy(new Error(\"ERR_STREAM_PREMATURE_CLOSE\"));\n  }\n  #errorOrDestroy(err, sync = null) {\n    var {\n      _readableState: r = { destroyed: !1, autoDestroy: !1 },\n      _writableState: w = { destroyed: !1, autoDestroy: !1 }\n    } = this;\n    if (w\?.destroyed || r\?.destroyed)\n      return this;\n    if (r\?.autoDestroy || w\?.autoDestroy)\n      this.destroy(err);\n    else if (err)\n      this.emit(\"error\", err);\n  }\n  pause() {\n    return this[readStreamPathFastPathSymbol] = !1, super.pause();\n  }\n  resume() {\n    return this[readStreamPathFastPathSymbol] = !1, super.resume();\n  }\n  unshift(...args) {\n    return this[readStreamPathFastPathSymbol] = !1, super.unshift(...args);\n  }\n  pipe(dest, pipeOpts) {\n    if (this[readStreamPathFastPathSymbol] && (pipeOpts\?.end \?\? !0) && this._readableState\?.pipes\?.length === 0) {\n      if ((writeStreamPathFastPathSymbol in dest) && dest[writeStreamPathFastPathSymbol]) {\n        if (dest[writeStreamPathFastPathCallSymbol](this, pipeOpts))\n          return this;\n      }\n    }\n    return this[readStreamPathFastPathSymbol] = !1, super.pipe(dest, pipeOpts);\n  }\n});\nvar defaultWriteStreamOptions = {\n  fd: null,\n  start: void 0,\n  pos: void 0,\n  encoding: void 0,\n  flags: \"w\",\n  mode: 438,\n  fs: {\n    write,\n    close,\n    open,\n    openSync\n  }\n}, WriteStreamClass;\nWriteStream = function(InternalWriteStream) {\n  WriteStreamClass = InternalWriteStream, Object.defineProperty(WriteStreamClass.prototype, Symbol.toStringTag, {\n    value: \"WritesStream\",\n    enumerable: !1\n  });\n  function WriteStream3(path, options) {\n    return new InternalWriteStream(path, options);\n  }\n  return WriteStream3.prototype = InternalWriteStream.prototype, Object.defineProperty(WriteStream3, Symbol.hasInstance, {\n    value(instance) {\n      return instance instanceof InternalWriteStream;\n    }\n  });\n}(class WriteStream2 extends Stream.NativeWritable {\n  constructor(path, options = defaultWriteStreamOptions) {\n    if (!options)\n      @throwTypeError(\"Expected options to be an object\");\n    var {\n      fs: fs2 = defaultWriteStreamOptions.fs,\n      start = defaultWriteStreamOptions.start,\n      flags = defaultWriteStreamOptions.flags,\n      mode = defaultWriteStreamOptions.mode,\n      autoClose = !0,\n      emitClose = !1,\n      autoDestroy = autoClose,\n      encoding = defaultWriteStreamOptions.encoding,\n      fd = defaultWriteStreamOptions.fd,\n      pos = defaultWriteStreamOptions.pos\n    } = options, tempThis = {};\n    if (typeof path === \"string\") {\n      if (path.length === 0)\n        @throwTypeError(\"Expected a non-empty path\");\n      if (path.startsWith(\"file:\"))\n        path = Bun.fileURLToPath(path);\n      tempThis.path = path, tempThis.fd = null, tempThis[writeStreamPathFastPathSymbol] = autoClose && (start === void 0 || start === 0) && fs2.write === defaultWriteStreamOptions.fs.write && fs2.close === defaultWriteStreamOptions.fs.close;\n    } else\n      tempThis.fd = fd, tempThis[writeStreamPathFastPathSymbol] = !1;\n    if (!tempThis.fd)\n      tempThis.fd = fs2.openSync(path, flags, mode);\n    super(tempThis.fd, {\n      ...options,\n      decodeStrings: !1,\n      autoDestroy,\n      emitClose,\n      fd: tempThis\n    });\n    if (Object.assign(this, tempThis), typeof fs2\?.write !== \"function\")\n      @throwTypeError(\"Expected fs.write to be a function\");\n    if (typeof fs2\?.close !== \"function\")\n      @throwTypeError(\"Expected fs.close to be a function\");\n    if (typeof fs2\?.open !== \"function\")\n      @throwTypeError(\"Expected fs.open to be a function\");\n    if (typeof path === \"object\" && path) {\n      if (path instanceof URL)\n        path = Bun.fileURLToPath(path);\n    }\n    if (typeof path !== \"string\" && typeof fd !== \"number\")\n      @throwTypeError(\"Expected a path or file descriptor\");\n    if (this.start = start, this.#fs = fs2, this.flags = flags, this.mode = mode, this.start !== void 0)\n      this.pos = this.start;\n    if (encoding !== defaultWriteStreamOptions.encoding) {\n      if (this.setDefaultEncoding(encoding), encoding !== \"buffer\" && encoding !== \"utf8\" && encoding !== \"utf-8\" && encoding !== \"binary\")\n        this[writeStreamPathFastPathSymbol] = !1;\n    }\n  }\n  get autoClose() {\n    return this._writableState.autoDestroy;\n  }\n  set autoClose(val) {\n    this._writableState.autoDestroy = val;\n  }\n  destroySoon = this.end;\n  open() {\n  }\n  path;\n  fd;\n  flags;\n  mode;\n  #fs;\n  bytesWritten = 0;\n  pos;\n  [writeStreamPathFastPathSymbol];\n  [writeStreamSymbol] = !0;\n  start;\n  [writeStreamPathFastPathCallSymbol](readStream, pipeOpts) {\n    if (!this[writeStreamPathFastPathSymbol])\n      return !1;\n    if (this.fd !== null)\n      return this[writeStreamPathFastPathSymbol] = !1, !1;\n    return this[kIoDone] = !1, readStream[kIoDone] = !1, Bun.write(this[writeStreamPathFastPathSymbol], readStream[readStreamPathOrFdSymbol]).then((bytesWritten) => {\n      readStream[kIoDone] = this[kIoDone] = !0, this.bytesWritten += bytesWritten, readStream.bytesRead += bytesWritten, this.end(), readStream.close();\n    }, (err) => {\n      readStream[kIoDone] = this[kIoDone] = !0, this.#errorOrDestroy(err), readStream.emit(\"error\", err);\n    });\n  }\n  isBunFastPathEnabled() {\n    return this[writeStreamPathFastPathSymbol];\n  }\n  disableBunFastPath() {\n    this[writeStreamPathFastPathSymbol] = !1;\n  }\n  #handleWrite(er, bytes) {\n    if (er)\n      return this.#errorOrDestroy(er);\n    this.bytesWritten += bytes;\n  }\n  #internalClose(err, cb) {\n    this[writeStreamPathFastPathSymbol] = !1;\n    var fd = this.fd;\n    this.#fs.close(fd, (er) => {\n      this.fd = null, cb(err || er);\n    });\n  }\n  _construct(callback) {\n    if (typeof this.fd === \"number\") {\n      callback();\n      return;\n    }\n    callback(), this.emit(\"open\", this.fd), this.emit(\"ready\");\n  }\n  _destroy(err, cb) {\n    if (this.fd === null)\n      return cb(err);\n    if (this[kIoDone]) {\n      this.once(kIoDone, () => this.#internalClose(err, cb));\n      return;\n    }\n    this.#internalClose(err, cb);\n  }\n  [kIoDone] = !1;\n  close(cb) {\n    if (cb) {\n      if (this.closed) {\n        process.nextTick(cb);\n        return;\n      }\n      this.on(\"close\", cb);\n    }\n    if (!this.autoClose)\n      this.on(\"finish\", this.destroy);\n    this.end();\n  }\n  write(chunk, encoding = this._writableState.defaultEncoding, cb) {\n    if (this[writeStreamPathFastPathSymbol] = !1, typeof chunk === \"string\")\n      chunk = Buffer.from(chunk, encoding);\n    var native = this.pos === void 0;\n    return this[kIoDone] = !0, super.write(chunk, encoding, native \? (err, bytes) => {\n      if (this[kIoDone] = !1, this.#handleWrite(err, bytes), this.emit(kIoDone), cb)\n        !err \? cb() : cb(err);\n    } : () => {\n    }, native);\n  }\n  #internalWriteSlow(chunk, encoding, cb) {\n    this.#fs.write(this.fd, chunk, 0, chunk.length, this.pos, (err, bytes) => {\n      this[kIoDone] = !1, this.#handleWrite(err, bytes), this.emit(kIoDone), !err \? cb() : cb(err);\n    });\n  }\n  end(chunk, encoding, cb) {\n    var native = this.pos === void 0;\n    return super.end(chunk, encoding, cb, native);\n  }\n  _write = this.#internalWriteSlow;\n  _writev = void 0;\n  get pending() {\n    return this.fd === null;\n  }\n  _destroy(err, cb) {\n    this.close(err, cb);\n  }\n  #errorOrDestroy(err) {\n    var {\n      _readableState: r = { destroyed: !1, autoDestroy: !1 },\n      _writableState: w = { destroyed: !1, autoDestroy: !1 }\n    } = this;\n    if (w\?.destroyed || r\?.destroyed)\n      return this;\n    if (r\?.autoDestroy || w\?.autoDestroy)\n      this.destroy(err);\n    else if (err)\n      this.emit(\"error\", err);\n  }\n});\nObject.defineProperties(fs, {\n  createReadStream: {\n    value: createReadStream\n  },\n  createWriteStream: {\n    value: createWriteStream\n  },\n  ReadStream: {\n    value: ReadStream\n  },\n  WriteStream: {\n    value: WriteStream\n  }\n});\nrealpath.native = realpath;\nrealpathSync.native = realpathSync;\n$ = {\n  access,\n  accessSync,\n  appendFile,\n  appendFileSync,\n  chmod,\n  chmodSync,\n  chown,\n  chownSync,\n  close,\n  closeSync,\n  constants: promises.constants,\n  copyFile,\n  copyFileSync,\n  createReadStream,\n  createWriteStream,\n  Dirent,\n  exists,\n  existsSync,\n  fchmod,\n  fchmodSync,\n  fchown,\n  fchownSync,\n  fstat,\n  fstatSync,\n  fsync,\n  fsyncSync,\n  ftruncate,\n  ftruncateSync,\n  futimes,\n  futimesSync,\n  lchmod,\n  lchmodSync,\n  lchown,\n  lchownSync,\n  link,\n  linkSync,\n  lstat,\n  lstatSync,\n  lutimes,\n  lutimesSync,\n  mkdir,\n  mkdirSync,\n  mkdtemp,\n  mkdtempSync,\n  open,\n  openSync,\n  promises,\n  read,\n  readFile,\n  readFileSync,\n  readSync,\n  readdir,\n  readdirSync,\n  readlink,\n  readlinkSync,\n  realpath,\n  realpathSync,\n  rename,\n  renameSync,\n  rm,\n  rmSync,\n  rmdir,\n  rmdirSync,\n  stat,\n  statSync,\n  Stats,\n  symlink,\n  symlinkSync,\n  truncate,\n  truncateSync,\n  unlink,\n  unlinkSync,\n  utimes,\n  utimesSync,\n  write,\n  writeFile,\n  writeFileSync,\n  writeSync,\n  WriteStream,\n  ReadStream,\n  watch,\n  FSWatcher,\n  writev,\n  writevSync,\n  readv,\n  readvSync,\n  [Symbol.for(\"::bunternal::\")]: {\n    ReadStreamClass,\n    WriteStreamClass\n  }\n};\nreturn $})\n"_s;
//

//
static constexpr ASCIILiteral NodeFSPromisesCode = "(function (){\"use strict\";// src/js/out/tmp/node/fs.promises.ts\nvar watch = function(filename, options = {}) {\n  if (filename instanceof URL)\n    @throwTypeError(\"Watch URLs are not supported yet\");\n  else if (Buffer.isBuffer(filename))\n    filename = filename.toString();\n  else if (typeof filename !== \"string\")\n    @throwTypeError(\"Expected path to be a string or Buffer\");\n  let nextEventResolve = null;\n  if (typeof options === \"string\")\n    options = { encoding: options };\n  const queue = @createFIFO(), watcher = fs.watch(filename, options || {}, (eventType, filename2) => {\n    if (queue.push({ eventType, filename: filename2 }), nextEventResolve) {\n      const resolve = nextEventResolve;\n      nextEventResolve = null, resolve();\n    }\n  });\n  return {\n    [Symbol.asyncIterator]() {\n      let closed = !1;\n      return {\n        async next() {\n          while (!closed) {\n            let event;\n            while (event = queue.shift()) {\n              if (event.eventType === \"close\")\n                return closed = !0, { value: void 0, done: !0 };\n              if (event.eventType === \"error\")\n                throw closed = !0, event.filename;\n              return { value: event, done: !1 };\n            }\n            const { promise, resolve } = Promise.withResolvers();\n            nextEventResolve = resolve, await promise;\n          }\n          return { value: void 0, done: !0 };\n        },\n        return() {\n          if (!closed) {\n            if (watcher.close(), closed = !0, nextEventResolve) {\n              const resolve = nextEventResolve;\n              nextEventResolve = null, resolve();\n            }\n          }\n          return { value: void 0, done: !0 };\n        }\n      };\n    }\n  };\n}, $, constants = @processBindingConstants.fs, fs = Bun.fs(), notrace = \"::bunternal::\", promisify = {\n  [notrace]: (fsFunction) => {\n    return async function(...args) {\n      return await 1, fsFunction.apply(fs, args);\n    };\n  }\n}[notrace];\n$ = {\n  access: promisify(fs.accessSync),\n  appendFile: promisify(fs.appendFileSync),\n  close: promisify(fs.closeSync),\n  copyFile: promisify(fs.copyFileSync),\n  exists: promisify(fs.existsSync),\n  chown: promisify(fs.chownSync),\n  chmod: promisify(fs.chmodSync),\n  fchmod: promisify(fs.fchmodSync),\n  fchown: promisify(fs.fchownSync),\n  fstat: promisify(fs.fstatSync),\n  fsync: promisify(fs.fsyncSync),\n  ftruncate: promisify(fs.ftruncateSync),\n  futimes: promisify(fs.futimesSync),\n  lchmod: promisify(fs.lchmodSync),\n  lchown: promisify(fs.lchownSync),\n  link: promisify(fs.linkSync),\n  lstat: fs.lstat.bind(fs),\n  mkdir: promisify(fs.mkdirSync),\n  mkdtemp: promisify(fs.mkdtempSync),\n  open: promisify(fs.openSync),\n  read: promisify(fs.readSync),\n  write: promisify(fs.writeSync),\n  readdir: fs.readdir.bind(fs),\n  readFile: fs.readFile.bind(fs),\n  writeFile: promisify(fs.writeFileSync),\n  readlink: promisify(fs.readlinkSync),\n  realpath: fs.realpath.bind(fs),\n  rename: promisify(fs.renameSync),\n  stat: fs.stat.bind(fs),\n  symlink: promisify(fs.symlinkSync),\n  truncate: promisify(fs.truncateSync),\n  unlink: promisify(fs.unlinkSync),\n  utimes: promisify(fs.utimesSync),\n  lutimes: promisify(fs.lutimesSync),\n  rm: promisify(fs.rmSync),\n  rmdir: promisify(fs.rmdirSync),\n  writev: (fd, buffers, position) => {\n    return new Promise((resolve, reject) => {\n      try {\n        var bytesWritten = fs.writevSync(fd, buffers, position);\n      } catch (err) {\n        reject(err);\n        return;\n      }\n      resolve({\n        bytesWritten,\n        buffers\n      });\n    });\n  },\n  readv: (fd, buffers, position) => {\n    return new Promise((resolve, reject) => {\n      try {\n        var bytesRead = fs.readvSync(fd, buffers, position);\n      } catch (err) {\n        reject(err);\n        return;\n      }\n      resolve({\n        bytesRead,\n        buffers\n      });\n    });\n  },\n  constants,\n  watch\n};\nreturn $})\n"_s;
//

//
static constexpr ASCIILiteral NodeHttpCode = "(function (){\"use strict\";// src/js/out/tmp/node/http.ts\nvar checkInvalidHeaderChar = function(val) {\n  return RegExpPrototypeExec.call(headerCharRegex, val) !== null;\n}, isIPv6 = function(input) {\n  return new RegExp(\"^((\?:(\?:[0-9a-fA-F]{1,4}):){7}(\?:(\?:[0-9a-fA-F]{1,4})|:)|(\?:(\?:[0-9a-fA-F]{1,4}):){6}(\?:((\?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])[.]){3}(\?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])|:(\?:[0-9a-fA-F]{1,4})|:)|(\?:(\?:[0-9a-fA-F]{1,4}):){5}(\?::((\?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])[.]){3}(\?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])|(:(\?:[0-9a-fA-F]{1,4})){1,2}|:)|(\?:(\?:[0-9a-fA-F]{1,4}):){4}(\?:(:(\?:[0-9a-fA-F]{1,4})){0,1}:((\?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])[.]){3}(\?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])|(:(\?:[0-9a-fA-F]{1,4})){1,3}|:)|(\?:(\?:[0-9a-fA-F]{1,4}):){3}(\?:(:(\?:[0-9a-fA-F]{1,4})){0,2}:((\?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])[.]){3}(\?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])|(:(\?:[0-9a-fA-F]{1,4})){1,4}|:)|(\?:(\?:[0-9a-fA-F]{1,4}):){2}(\?:(:(\?:[0-9a-fA-F]{1,4})){0,3}:((\?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])[.]){3}(\?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])|(:(\?:[0-9a-fA-F]{1,4})){1,5}|:)|(\?:(\?:[0-9a-fA-F]{1,4}):){1}(\?:(:(\?:[0-9a-fA-F]{1,4})){0,4}:((\?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])[.]){3}(\?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])|(:(\?:[0-9a-fA-F]{1,4})){1,6}|:)|(\?::((\?::(\?:[0-9a-fA-F]{1,4})){0,5}:((\?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])[.]){3}(\?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])|(\?::(\?:[0-9a-fA-F]{1,4})){1,7}|:)))(%[0-9a-zA-Z-.:]{1,})\?$\").test(input);\n}, isValidTLSArray = function(obj) {\n  if (typeof obj === \"string\" || isTypedArray(obj) || obj instanceof ArrayBuffer || obj instanceof Blob)\n    return !0;\n  if (Array.isArray(obj)) {\n    for (var i = 0;i < obj.length; i++)\n      if (typeof obj !== \"string\" && !isTypedArray(obj) && !(obj instanceof ArrayBuffer) && !(obj instanceof Blob))\n        return !1;\n    return !0;\n  }\n}, validateMsecs = function(numberlike, field) {\n  if (typeof numberlike !== \"number\" || numberlike < 0)\n    throw new ERR_INVALID_ARG_TYPE(field, \"number\", numberlike);\n  return numberlike;\n}, validateFunction = function(callable, field) {\n  if (typeof callable !== \"function\")\n    throw new ERR_INVALID_ARG_TYPE(field, \"Function\", callable);\n  return callable;\n}, getHeader = function(headers, name) {\n  if (!headers)\n    return;\n  const result = headers.get(name);\n  return result == null \? void 0 : result;\n}, createServer = function(options, callback) {\n  return new Server(options, callback);\n}, emitListeningNextTick = function(self, onListen, err, hostname, port) {\n  if (typeof onListen === \"function\")\n    try {\n      onListen(err, hostname, port);\n    } catch (err2) {\n      self.emit(\"error\", err2);\n    }\n  if (self.listening = !err, err)\n    self.emit(\"error\", err);\n  else\n    self.emit(\"listening\", hostname, port);\n}, assignHeaders = function(object, req) {\n  var headers = req.headers.toJSON();\n  const rawHeaders = @newArrayWithSize(req.headers.count * 2);\n  var i = 0;\n  for (let key in headers)\n    rawHeaders[i++] = key, rawHeaders[i++] = headers[key];\n  object.headers = headers, object.rawHeaders = rawHeaders;\n};\nvar getDefaultHTTPSAgent = function() {\n  return _defaultHTTPSAgent \?\?= new Agent({ defaultPort: 443, protocol: \"https:\" });\n};\nvar urlToHttpOptions = function(url) {\n  var { protocol, hostname, hash, search, pathname, href, port, username, password } = url;\n  return {\n    protocol,\n    hostname: typeof hostname === \"string\" && StringPrototypeStartsWith.call(hostname, \"[\") \? StringPrototypeSlice.call(hostname, 1, -1) : hostname,\n    hash,\n    search,\n    pathname,\n    path: `${pathname || \"\"}${search || \"\"}`,\n    href,\n    port: port \? Number(port) : protocol === \"https:\" \? 443 : protocol === \"http:\" \? 80 : void 0,\n    auth: username || password \? `${decodeURIComponent(username)}:${decodeURIComponent(password)}` : void 0\n  };\n}, validateHost = function(host, name) {\n  if (host !== null && host !== void 0 && typeof host !== \"string\")\n    throw new Error(\"Invalid arg type in options\");\n  return host;\n}, checkIsHttpToken = function(val) {\n  return RegExpPrototypeExec.call(tokenRegExp, val) !== null;\n};\nvar _writeHead = function(statusCode, reason, obj, response) {\n  if (statusCode |= 0, statusCode < 100 || statusCode > 999)\n    throw new Error(\"status code must be between 100 and 999\");\n  if (typeof reason === \"string\")\n    response.statusMessage = reason;\n  else {\n    if (!response.statusMessage)\n      response.statusMessage = STATUS_CODES[statusCode] || \"unknown\";\n    obj = reason;\n  }\n  response.statusCode = statusCode;\n  {\n    let k;\n    if (Array.isArray(obj)) {\n      if (obj.length % 2 !== 0)\n        throw new Error(\"raw headers must have an even number of elements\");\n      for (let n = 0;n < obj.length; n += 2)\n        if (k = obj[n + 0], k)\n          response.setHeader(k, obj[n + 1]);\n    } else if (obj) {\n      const keys = Object.keys(obj);\n      for (let i = 0;i < keys.length; i++)\n        if (k = keys[i], k)\n          response.setHeader(k, obj[k]);\n    }\n  }\n  if (statusCode === 204 || statusCode === 304 || statusCode >= 100 && statusCode <= 199)\n    response._hasBody = !1;\n}, request = function(url, options, cb) {\n  return new ClientRequest(url, options, cb);\n}, get = function(url, options, cb) {\n  const req = request(url, options, cb);\n  return req.end(), req;\n}, $, EventEmitter = @getInternalField(@internalModuleRegistry, 16) || @createInternalModuleById(16), { isTypedArray } = @requireNativeModule(\"node:util/types\"), { Duplex, Readable, Writable } = @getInternalField(@internalModuleRegistry, 35) || @createInternalModuleById(35), headerCharRegex = /[^\\t\\x20-\\x7e\\x80-\\xff]/, validateHeaderName = (name, label) => {\n  if (typeof name !== \"string\" || !name || !checkIsHttpToken(name))\n    throw new Error(\"ERR_INVALID_HTTP_TOKEN\");\n}, validateHeaderValue = (name, value) => {\n  if (value === void 0)\n    throw new Error(\"ERR_HTTP_INVALID_HEADER_VALUE\");\n  if (checkInvalidHeaderChar(value))\n    throw new Error(\"ERR_INVALID_CHAR\");\n}, { URL } = globalThis, globalReportError = globalThis.reportError, setTimeout = globalThis.setTimeout, fetch = Bun.fetch;\nvar kEmptyObject = Object.freeze(Object.create(null)), kOutHeaders = Symbol.for(\"kOutHeaders\"), kEndCalled = Symbol.for(\"kEndCalled\"), kAbortController = Symbol.for(\"kAbortController\"), kClearTimeout = Symbol(\"kClearTimeout\"), kCorked = Symbol.for(\"kCorked\"), searchParamsSymbol = Symbol.for(\"query\"), StringPrototypeSlice = String.prototype.slice, StringPrototypeStartsWith = String.prototype.startsWith, StringPrototypeToUpperCase = String.prototype.toUpperCase, StringPrototypeIncludes = String.prototype.includes, StringPrototypeCharCodeAt = String.prototype.charCodeAt, StringPrototypeIndexOf = String.prototype.indexOf, ArrayIsArray = Array.isArray, RegExpPrototypeExec = RegExp.prototype.exec, ObjectAssign = Object.assign;\nvar INVALID_PATH_REGEX = /[^\\u0021-\\u00ff]/;\nvar _defaultHTTPSAgent, kInternalRequest = Symbol(\"kInternalRequest\"), kInternalSocketData = Symbol.for(\"::bunternal::\"), kEmptyBuffer = Buffer.alloc(0);\n\nclass ERR_INVALID_ARG_TYPE extends TypeError {\n  constructor(name, expected, actual) {\n    super(`The ${name} argument must be of type ${expected}. Received type ${typeof actual}`);\n    this.code = \"ERR_INVALID_ARG_TYPE\";\n  }\n}\nvar FakeSocket = class Socket extends Duplex {\n  bytesRead = 0;\n  bytesWritten = 0;\n  connecting = !1;\n  remoteAddress = null;\n  remotePort;\n  timeout = 0;\n  isServer = !1;\n  address() {\n    return {\n      address: this.localAddress,\n      family: this.localFamily,\n      port: this.localPort\n    };\n  }\n  get bufferSize() {\n    return this.writableLength;\n  }\n  connect(port, host, connectListener) {\n    return this;\n  }\n  _destroy(err, callback) {\n  }\n  _final(callback) {\n  }\n  get localAddress() {\n    return \"127.0.0.1\";\n  }\n  get localFamily() {\n    return \"IPv4\";\n  }\n  get localPort() {\n    return 80;\n  }\n  get pending() {\n    return this.connecting;\n  }\n  _read(size) {\n  }\n  get readyState() {\n    if (this.connecting)\n      return \"opening\";\n    if (this.readable)\n      return this.writable \? \"open\" : \"readOnly\";\n    else\n      return this.writable \? \"writeOnly\" : \"closed\";\n  }\n  ref() {\n  }\n  get remoteFamily() {\n    return \"IPv4\";\n  }\n  resetAndDestroy() {\n  }\n  setKeepAlive(enable = !1, initialDelay = 0) {\n  }\n  setNoDelay(noDelay = !0) {\n    return this;\n  }\n  setTimeout(timeout, callback) {\n    return this;\n  }\n  unref() {\n  }\n  _write(chunk, encoding, callback) {\n  }\n};\n\nclass Agent extends EventEmitter {\n  defaultPort = 80;\n  protocol = \"http:\";\n  options;\n  requests;\n  sockets;\n  freeSockets;\n  keepAliveMsecs;\n  keepAlive;\n  maxSockets;\n  maxFreeSockets;\n  scheduling;\n  maxTotalSockets;\n  totalSocketCount;\n  #fakeSocket;\n  static get globalAgent() {\n    return globalAgent;\n  }\n  static get defaultMaxSockets() {\n    return Infinity;\n  }\n  constructor(options = kEmptyObject) {\n    super();\n    if (this.options = options = { ...options, path: null }, options.noDelay === void 0)\n      options.noDelay = !0;\n    this.requests = kEmptyObject, this.sockets = kEmptyObject, this.freeSockets = kEmptyObject, this.keepAliveMsecs = options.keepAliveMsecs || 1000, this.keepAlive = options.keepAlive || !1, this.maxSockets = options.maxSockets || Agent.defaultMaxSockets, this.maxFreeSockets = options.maxFreeSockets || 256, this.scheduling = options.scheduling || \"lifo\", this.maxTotalSockets = options.maxTotalSockets, this.totalSocketCount = 0, this.defaultPort = options.defaultPort || 80, this.protocol = options.protocol || \"http:\";\n  }\n  createConnection() {\n    return this.#fakeSocket \?\?= new FakeSocket;\n  }\n  getName(options = kEmptyObject) {\n    let name = `http:${options.host || \"localhost\"}:`;\n    if (options.port)\n      name += options.port;\n    if (name += \":\", options.localAddress)\n      name += options.localAddress;\n    if (options.family === 4 || options.family === 6)\n      name += `:${options.family}`;\n    if (options.socketPath)\n      name += `:${options.socketPath}`;\n    return name;\n  }\n  addRequest() {\n  }\n  createSocket(req, options, cb) {\n    cb(null, this.#fakeSocket \?\?= new FakeSocket);\n  }\n  removeSocket() {\n  }\n  keepSocketAlive() {\n    return !0;\n  }\n  reuseSocket() {\n  }\n  destroy() {\n  }\n}\n\nclass Server extends EventEmitter {\n  #server;\n  #options;\n  #tls;\n  #is_tls = !1;\n  listening = !1;\n  serverName;\n  constructor(options, callback) {\n    super();\n    if (typeof options === \"function\")\n      callback = options, options = {};\n    else if (options == null || typeof options === \"object\") {\n      options = { ...options }, this.#tls = null;\n      let key = options.key;\n      if (key) {\n        if (!isValidTLSArray(key))\n          @throwTypeError(\"key argument must be an string, Buffer, TypedArray, BunFile or an array containing string, Buffer, TypedArray or BunFile\");\n        this.#is_tls = !0;\n      }\n      let cert = options.cert;\n      if (cert) {\n        if (!isValidTLSArray(cert))\n          @throwTypeError(\"cert argument must be an string, Buffer, TypedArray, BunFile or an array containing string, Buffer, TypedArray or BunFile\");\n        this.#is_tls = !0;\n      }\n      let ca = options.ca;\n      if (ca) {\n        if (!isValidTLSArray(ca))\n          @throwTypeError(\"ca argument must be an string, Buffer, TypedArray, BunFile or an array containing string, Buffer, TypedArray or BunFile\");\n        this.#is_tls = !0;\n      }\n      let passphrase = options.passphrase;\n      if (passphrase && typeof passphrase !== \"string\")\n        @throwTypeError(\"passphrase argument must be an string\");\n      let serverName = options.servername;\n      if (serverName && typeof serverName !== \"string\")\n        @throwTypeError(\"servername argument must be an string\");\n      let secureOptions = options.secureOptions || 0;\n      if (secureOptions && typeof secureOptions !== \"number\")\n        @throwTypeError(\"secureOptions argument must be an number\");\n      if (this.#is_tls)\n        this.#tls = {\n          serverName,\n          key,\n          cert,\n          ca,\n          passphrase,\n          secureOptions\n        };\n      else\n        this.#tls = null;\n    } else\n      throw new Error(\"bun-http-polyfill: invalid arguments\");\n    if (this.#options = options, callback)\n      this.on(\"request\", callback);\n  }\n  closeAllConnections() {\n    const server = this.#server;\n    if (!server)\n      return;\n    this.#server = void 0, server.stop(!0), this.emit(\"close\");\n  }\n  closeIdleConnections() {\n  }\n  close(optionalCallback) {\n    const server = this.#server;\n    if (!server) {\n      if (typeof optionalCallback === \"function\")\n        process.nextTick(optionalCallback, new Error(\"Server is not running\"));\n      return;\n    }\n    if (this.#server = void 0, typeof optionalCallback === \"function\")\n      this.once(\"close\", optionalCallback);\n    server.stop(), this.emit(\"close\");\n  }\n  address() {\n    if (!this.#server)\n      return null;\n    const address = this.#server.hostname;\n    return {\n      address,\n      family: isIPv6(address) \? \"IPv6\" : \"IPv4\",\n      port: this.#server.port\n    };\n  }\n  listen(port, host, backlog, onListen) {\n    const server = this;\n    if (typeof host === \"function\")\n      onListen = host, host = void 0;\n    if (typeof port === \"function\")\n      onListen = port;\n    else if (typeof port === \"object\") {\n      if (port\?.signal\?.addEventListener(\"abort\", () => {\n        this.close();\n      }), host = port\?.host, port = port\?.port, typeof port\?.callback === \"function\")\n        onListen = port\?.callback;\n    }\n    if (typeof backlog === \"function\")\n      onListen = backlog;\n    const ResponseClass = this.#options.ServerResponse || ServerResponse, RequestClass = this.#options.IncomingMessage || IncomingMessage;\n    try {\n      const tls = this.#tls;\n      if (tls)\n        this.serverName = tls.serverName || host || \"localhost\";\n      this.#server = Bun.serve({\n        tls,\n        port,\n        hostname: host,\n        websocket: {\n          open(ws) {\n            ws.data.open(ws);\n          },\n          message(ws, message) {\n            ws.data.message(ws, message);\n          },\n          close(ws, code, reason) {\n            ws.data.close(ws, code, reason);\n          },\n          drain(ws) {\n            ws.data.drain(ws);\n          }\n        },\n        fetch(req, _server) {\n          var pendingResponse, pendingError, rejectFunction, resolveFunction, reject = (err) => {\n            if (pendingError)\n              return;\n            if (pendingError = err, rejectFunction)\n              rejectFunction(err);\n          }, reply = function(resp) {\n            if (pendingResponse)\n              return;\n            if (pendingResponse = resp, resolveFunction)\n              resolveFunction(resp);\n          };\n          const http_req = new RequestClass(req), http_res = new ResponseClass({ reply, req: http_req });\n          if (http_req.once(\"error\", (err) => reject(err)), http_res.once(\"error\", (err) => reject(err)), req.headers.get(\"upgrade\")) {\n            const socket = new FakeSocket;\n            socket[kInternalSocketData] = [_server, http_res, req], server.emit(\"upgrade\", http_req, socket, kEmptyBuffer);\n          } else\n            server.emit(\"request\", http_req, http_res);\n          if (pendingError)\n            throw pendingError;\n          if (pendingResponse)\n            return pendingResponse;\n          return new Promise((resolve, reject2) => {\n            resolveFunction = resolve, rejectFunction = reject2;\n          });\n        }\n      }), setTimeout(emitListeningNextTick, 1, this, onListen, null, this.#server.hostname, this.#server.port);\n    } catch (err) {\n      setTimeout(emitListeningNextTick, 1, this, onListen, err);\n    }\n    return this;\n  }\n  setTimeout(msecs, callback) {\n  }\n}\nclass IncomingMessage extends Readable {\n  method;\n  complete;\n  constructor(req, defaultIncomingOpts) {\n    const method = req.method;\n    super();\n    const url = new URL(req.url);\n    var { type = \"request\", [kInternalRequest]: nodeReq } = defaultIncomingOpts || {};\n    this.#noBody = type === \"request\" \? method === \"GET\" || method === \"HEAD\" || method === \"TRACE\" || method === \"CONNECT\" || method === \"OPTIONS\" || (parseInt(req.headers.get(\"Content-Length\") || \"\") || 0) === 0 : !1, this.#req = req, this.method = method, this.#type = type, this.complete = !!this.#noBody, this.#bodyStream = void 0;\n    const socket = new FakeSocket;\n    socket.remoteAddress = url.hostname, socket.remotePort = url.port, this.#fakeSocket = socket, this.url = url.pathname + url.search, this.#nodeReq = this.req = nodeReq, assignHeaders(this, req);\n  }\n  headers;\n  rawHeaders;\n  _consuming = !1;\n  _dumped = !1;\n  #bodyStream;\n  #fakeSocket;\n  #noBody = !1;\n  #aborted = !1;\n  #req;\n  url;\n  #type;\n  #nodeReq;\n  _construct(callback) {\n    if (this.#type === \"response\" || this.#noBody) {\n      callback();\n      return;\n    }\n    const contentLength = this.#req.headers.get(\"content-length\");\n    if ((contentLength \? parseInt(contentLength, 10) : 0) === 0) {\n      this.#noBody = !0, callback();\n      return;\n    }\n    callback();\n  }\n  async#consumeStream(reader) {\n    while (!0) {\n      var { done, value } = await reader.readMany();\n      if (this.#aborted)\n        return;\n      if (done) {\n        this.push(null), this.destroy();\n        break;\n      }\n      for (var v of value)\n        this.push(v);\n    }\n  }\n  _read(size) {\n    if (this.#noBody)\n      this.push(null), this.complete = !0;\n    else if (this.#bodyStream == null) {\n      const reader = this.#req.body\?.getReader();\n      if (!reader) {\n        this.push(null);\n        return;\n      }\n      this.#bodyStream = reader, this.#consumeStream(reader);\n    }\n  }\n  get aborted() {\n    return this.#aborted;\n  }\n  #abort() {\n    if (this.#aborted)\n      return;\n    this.#aborted = !0;\n    var bodyStream = this.#bodyStream;\n    if (!bodyStream)\n      return;\n    bodyStream.cancel(), this.complete = !0, this.#bodyStream = void 0, this.push(null);\n  }\n  get connection() {\n    return this.#fakeSocket;\n  }\n  get statusCode() {\n    return this.#req.status;\n  }\n  get statusMessage() {\n    return STATUS_CODES[this.#req.status];\n  }\n  get httpVersion() {\n    return \"1.1\";\n  }\n  get rawTrailers() {\n    return [];\n  }\n  get httpVersionMajor() {\n    return 1;\n  }\n  get httpVersionMinor() {\n    return 1;\n  }\n  get trailers() {\n    return kEmptyObject;\n  }\n  get socket() {\n    return this.#fakeSocket \?\?= new FakeSocket;\n  }\n  set socket(val) {\n    this.#fakeSocket = val;\n  }\n  setTimeout(msecs, callback) {\n    throw new Error(\"not implemented\");\n  }\n}\n\nclass OutgoingMessage extends Writable {\n  constructor() {\n    super(...arguments);\n  }\n  #headers;\n  headersSent = !1;\n  sendDate = !0;\n  req;\n  timeout;\n  #finished = !1;\n  [kEndCalled] = !1;\n  #fakeSocket;\n  #timeoutTimer;\n  [kAbortController] = null;\n  _implicitHeader() {\n  }\n  get headers() {\n    if (!this.#headers)\n      return kEmptyObject;\n    return this.#headers.toJSON();\n  }\n  get shouldKeepAlive() {\n    return !0;\n  }\n  get chunkedEncoding() {\n    return !1;\n  }\n  set chunkedEncoding(value) {\n  }\n  set shouldKeepAlive(value) {\n  }\n  get useChunkedEncodingByDefault() {\n    return !0;\n  }\n  set useChunkedEncodingByDefault(value) {\n  }\n  get socket() {\n    return this.#fakeSocket \?\?= new FakeSocket;\n  }\n  set socket(val) {\n    this.#fakeSocket = val;\n  }\n  get connection() {\n    return this.socket;\n  }\n  get finished() {\n    return this.#finished;\n  }\n  appendHeader(name, value) {\n    var headers = this.#headers \?\?= new Headers;\n    headers.append(name, value);\n  }\n  flushHeaders() {\n  }\n  getHeader(name) {\n    return getHeader(this.#headers, name);\n  }\n  getHeaders() {\n    if (!this.#headers)\n      return kEmptyObject;\n    return this.#headers.toJSON();\n  }\n  getHeaderNames() {\n    var headers = this.#headers;\n    if (!headers)\n      return [];\n    return Array.from(headers.keys());\n  }\n  removeHeader(name) {\n    if (!this.#headers)\n      return;\n    this.#headers.delete(name);\n  }\n  setHeader(name, value) {\n    var headers = this.#headers \?\?= new Headers;\n    return headers.set(name, value), this;\n  }\n  hasHeader(name) {\n    if (!this.#headers)\n      return !1;\n    return this.#headers.has(name);\n  }\n  addTrailers(headers) {\n    throw new Error(\"not implemented\");\n  }\n  [kClearTimeout]() {\n    if (this.#timeoutTimer)\n      clearTimeout(this.#timeoutTimer), this.removeAllListeners(\"timeout\"), this.#timeoutTimer = void 0;\n  }\n  #onTimeout() {\n    this.#timeoutTimer = void 0, this[kAbortController]\?.abort(), this.emit(\"timeout\");\n  }\n  setTimeout(msecs, callback) {\n    if (this.destroyed)\n      return this;\n    if (this.timeout = msecs = validateMsecs(msecs, \"msecs\"), clearTimeout(this.#timeoutTimer), msecs === 0) {\n      if (callback !== void 0)\n        validateFunction(callback, \"callback\"), this.removeListener(\"timeout\", callback);\n      this.#timeoutTimer = void 0;\n    } else if (this.#timeoutTimer = setTimeout(this.#onTimeout.bind(this), msecs).unref(), callback !== void 0)\n      validateFunction(callback, \"callback\"), this.once(\"timeout\", callback);\n    return this;\n  }\n}\nvar OriginalWriteHeadFn, OriginalImplicitHeadFn;\n\nclass ServerResponse extends Writable {\n  constructor({ req, reply }) {\n    super();\n    if (this.req = req, this._reply = reply, this.sendDate = !0, this.statusCode = 200, this.headersSent = !1, this.statusMessage = void 0, this.#controller = void 0, this.#firstWrite = void 0, this._writableState.decodeStrings = !1, this.#deferred = void 0, req.method === \"HEAD\")\n      this._hasBody = !1;\n  }\n  req;\n  _reply;\n  sendDate;\n  statusCode;\n  #headers;\n  headersSent = !1;\n  statusMessage;\n  #controller;\n  #firstWrite;\n  _sent100 = !1;\n  _defaultKeepAlive = !1;\n  _removedConnection = !1;\n  _removedContLen = !1;\n  _hasBody = !0;\n  #deferred = void 0;\n  #finished = !1;\n  _implicitHeader() {\n    this.writeHead(this.statusCode);\n  }\n  _write(chunk, encoding, callback) {\n    if (!this.#firstWrite && !this.headersSent) {\n      this.#firstWrite = chunk, callback();\n      return;\n    }\n    this.#ensureReadableStreamController((controller) => {\n      controller.write(chunk), callback();\n    });\n  }\n  _writev(chunks, callback) {\n    if (chunks.length === 1 && !this.headersSent && !this.#firstWrite) {\n      this.#firstWrite = chunks[0].chunk, callback();\n      return;\n    }\n    this.#ensureReadableStreamController((controller) => {\n      for (let chunk of chunks)\n        controller.write(chunk.chunk);\n      callback();\n    });\n  }\n  #ensureReadableStreamController(run) {\n    var thisController = this.#controller;\n    if (thisController)\n      return run(thisController);\n    this.headersSent = !0;\n    var firstWrite = this.#firstWrite;\n    this.#firstWrite = void 0, this._reply(new Response(new ReadableStream({\n      type: \"direct\",\n      pull: (controller) => {\n        if (this.#controller = controller, firstWrite)\n          controller.write(firstWrite);\n        if (firstWrite = void 0, run(controller), !this.#finished)\n          return new Promise((resolve) => {\n            this.#deferred = resolve;\n          });\n      }\n    }), {\n      headers: this.#headers,\n      status: this.statusCode,\n      statusText: this.statusMessage \?\? STATUS_CODES[this.statusCode]\n    }));\n  }\n  #drainHeadersIfObservable() {\n    if (this._implicitHeader === OriginalImplicitHeadFn && this.writeHead === OriginalWriteHeadFn)\n      return;\n    this._implicitHeader();\n  }\n  _final(callback) {\n    if (!this.headersSent) {\n      var data = this.#firstWrite || \"\";\n      this.#firstWrite = void 0, this.#finished = !0, this.#drainHeadersIfObservable(), this._reply(new Response(data, {\n        headers: this.#headers,\n        status: this.statusCode,\n        statusText: this.statusMessage \?\? STATUS_CODES[this.statusCode]\n      })), callback && callback();\n      return;\n    }\n    this.#finished = !0, this.#ensureReadableStreamController((controller) => {\n      controller.end(), callback();\n      var deferred = this.#deferred;\n      if (deferred)\n        this.#deferred = void 0, deferred();\n    });\n  }\n  writeProcessing() {\n    throw new Error(\"not implemented\");\n  }\n  addTrailers(headers) {\n    throw new Error(\"not implemented\");\n  }\n  assignSocket(socket) {\n    throw new Error(\"not implemented\");\n  }\n  detachSocket(socket) {\n    throw new Error(\"not implemented\");\n  }\n  writeContinue(callback) {\n    throw new Error(\"not implemented\");\n  }\n  setTimeout(msecs, callback) {\n    throw new Error(\"not implemented\");\n  }\n  get shouldKeepAlive() {\n    return !0;\n  }\n  get chunkedEncoding() {\n    return !1;\n  }\n  set chunkedEncoding(value) {\n  }\n  set shouldKeepAlive(value) {\n  }\n  get useChunkedEncodingByDefault() {\n    return !0;\n  }\n  set useChunkedEncodingByDefault(value) {\n  }\n  appendHeader(name, value) {\n    var headers = this.#headers \?\?= new Headers;\n    headers.append(name, value);\n  }\n  flushHeaders() {\n  }\n  getHeader(name) {\n    return getHeader(this.#headers, name);\n  }\n  getHeaders() {\n    var headers = this.#headers;\n    if (!headers)\n      return kEmptyObject;\n    return headers.toJSON();\n  }\n  getHeaderNames() {\n    var headers = this.#headers;\n    if (!headers)\n      return [];\n    return Array.from(headers.keys());\n  }\n  removeHeader(name) {\n    if (!this.#headers)\n      return;\n    this.#headers.delete(name);\n  }\n  setHeader(name, value) {\n    var headers = this.#headers \?\?= new Headers;\n    return headers.set(name, value), this;\n  }\n  hasHeader(name) {\n    if (!this.#headers)\n      return !1;\n    return this.#headers.has(name);\n  }\n  writeHead(statusCode, statusMessage, headers) {\n    return _writeHead(statusCode, statusMessage, headers, this), this;\n  }\n}\nOriginalWriteHeadFn = ServerResponse.prototype.writeHead;\nOriginalImplicitHeadFn = ServerResponse.prototype._implicitHeader;\n\nclass ClientRequest extends OutgoingMessage {\n  #timeout;\n  #res = null;\n  #upgradeOrConnect = !1;\n  #parser = null;\n  #maxHeadersCount = null;\n  #reusedSocket = !1;\n  #host;\n  #protocol;\n  #method;\n  #port;\n  #useDefaultPort;\n  #joinDuplicateHeaders;\n  #maxHeaderSize;\n  #agent = globalAgent;\n  #path;\n  #socketPath;\n  #bodyChunks = null;\n  #fetchRequest;\n  #signal = null;\n  [kAbortController] = null;\n  #timeoutTimer = void 0;\n  #options;\n  #finished;\n  get path() {\n    return this.#path;\n  }\n  get port() {\n    return this.#port;\n  }\n  get method() {\n    return this.#method;\n  }\n  get host() {\n    return this.#host;\n  }\n  get protocol() {\n    return this.#protocol;\n  }\n  _write(chunk, encoding, callback) {\n    if (!this.#bodyChunks) {\n      this.#bodyChunks = [chunk], callback();\n      return;\n    }\n    this.#bodyChunks.push(chunk), callback();\n  }\n  _writev(chunks, callback) {\n    if (!this.#bodyChunks) {\n      this.#bodyChunks = chunks, callback();\n      return;\n    }\n    this.#bodyChunks.push(...chunks), callback();\n  }\n  _final(callback) {\n    if (this.#finished = !0, this[kAbortController] = new AbortController, this[kAbortController].signal.addEventListener(\"abort\", () => {\n      this[kClearTimeout]();\n    }), this.#signal\?.aborted)\n      this[kAbortController].abort();\n    var method = this.#method, body = this.#bodyChunks\?.length === 1 \? this.#bodyChunks[0] : Buffer.concat(this.#bodyChunks || []);\n    try {\n      this.#fetchRequest = fetch(`${this.#protocol}//${this.#host}${this.#useDefaultPort \? \"\" : \":\" + this.#port}${this.#path}`, {\n        method,\n        headers: this.getHeaders(),\n        body: body && method !== \"GET\" && method !== \"HEAD\" && method !== \"OPTIONS\" \? body : void 0,\n        redirect: \"manual\",\n        verbose: !1,\n        signal: this[kAbortController].signal,\n        timeout: !1\n      }).then((response) => {\n        var res = this.#res = new IncomingMessage(response, {\n          type: \"response\",\n          [kInternalRequest]: this\n        });\n        this.emit(\"response\", res);\n      }).catch((err) => {\n        this.emit(\"error\", err);\n      }).finally(() => {\n        this.#fetchRequest = null, this[kClearTimeout]();\n      });\n    } catch (err) {\n      this.emit(\"error\", err);\n    } finally {\n      callback();\n    }\n  }\n  get aborted() {\n    return this.#signal\?.aborted || !!this[kAbortController]\?.signal.aborted;\n  }\n  abort() {\n    if (this.aborted)\n      return;\n    this[kAbortController].abort();\n  }\n  constructor(input, options, cb) {\n    super();\n    if (typeof input === \"string\") {\n      const urlStr = input;\n      try {\n        var urlObject = new URL(urlStr);\n      } catch (e) {\n        @throwTypeError(`Invalid URL: ${urlStr}`);\n      }\n      input = urlToHttpOptions(urlObject);\n    } else if (input && typeof input === \"object\" && input instanceof URL)\n      input = urlToHttpOptions(input);\n    else\n      cb = options, options = input, input = null;\n    if (typeof options === \"function\")\n      cb = options, options = input || kEmptyObject;\n    else\n      options = ObjectAssign(input || {}, options);\n    var defaultAgent = options._defaultAgent || Agent.globalAgent;\n    let protocol = options.protocol;\n    if (!protocol)\n      if (options.port === 443)\n        protocol = \"https:\";\n      else\n        protocol = defaultAgent.protocol || \"http:\";\n    switch (this.#protocol = protocol, this.#agent\?.protocol) {\n      case void 0:\n        break;\n      case \"http:\":\n        if (protocol === \"https:\") {\n          defaultAgent = this.#agent = getDefaultHTTPSAgent();\n          break;\n        }\n      case \"https:\":\n        if (protocol === \"https\") {\n          defaultAgent = this.#agent = Agent.globalAgent;\n          break;\n        }\n      default:\n        break;\n    }\n    if (options.path) {\n      const path = String(options.path);\n      if (RegExpPrototypeExec.call(INVALID_PATH_REGEX, path) !== null)\n        throw new Error(\"Path contains unescaped characters\");\n    }\n    if (protocol !== \"http:\" && protocol !== \"https:\" && protocol) {\n      const expectedProtocol = defaultAgent\?.protocol \?\? \"http:\";\n      throw new Error(`Protocol mismatch. Expected: ${expectedProtocol}. Got: ${protocol}`);\n    }\n    const defaultPort = protocol === \"https:\" \? 443 : 80;\n    this.#port = options.port || options.defaultPort || this.#agent\?.defaultPort || defaultPort, this.#useDefaultPort = this.#port === defaultPort;\n    const host = this.#host = options.host = validateHost(options.hostname, \"hostname\") || validateHost(options.host, \"host\") || \"localhost\";\n    this.#socketPath = options.socketPath;\n    const signal = options.signal;\n    if (signal)\n      signal.addEventListener(\"abort\", () => {\n        this[kAbortController]\?.abort();\n      }), this.#signal = signal;\n    let method = options.method;\n    const methodIsString = typeof method === \"string\";\n    if (method !== null && method !== void 0 && !methodIsString)\n      throw new Error(\"ERR_INVALID_ARG_TYPE: options.method\");\n    if (methodIsString && method) {\n      if (!checkIsHttpToken(method))\n        throw new Error(\"ERR_INVALID_HTTP_TOKEN: Method\");\n      method = this.#method = StringPrototypeToUpperCase.call(method);\n    } else\n      method = this.#method = \"GET\";\n    const _maxHeaderSize = options.maxHeaderSize;\n    this.#maxHeaderSize = _maxHeaderSize;\n    var _joinDuplicateHeaders = options.joinDuplicateHeaders;\n    if (this.#joinDuplicateHeaders = _joinDuplicateHeaders, this.#path = options.path || \"/\", cb)\n      this.once(\"response\", cb);\n    this.#finished = !1, this.#res = null, this.#upgradeOrConnect = !1, this.#parser = null, this.#maxHeadersCount = null, this.#reusedSocket = !1, this.#host = host, this.#protocol = protocol;\n    var timeout = options.timeout;\n    if (timeout !== void 0 && timeout !== 0)\n      this.setTimeout(timeout, void 0);\n    if (!ArrayIsArray(headers)) {\n      var headers = options.headers;\n      if (headers)\n        for (let key in headers)\n          this.setHeader(key, headers[key]);\n      var auth = options.auth;\n      if (auth && !this.getHeader(\"Authorization\"))\n        this.setHeader(\"Authorization\", \"Basic \" + Buffer.from(auth).toString(\"base64\"));\n    }\n    var { signal: _signal, ...optsWithoutSignal } = options;\n    this.#options = optsWithoutSignal;\n  }\n  setSocketKeepAlive(enable = !0, initialDelay = 0) {\n  }\n  setNoDelay(noDelay = !0) {\n  }\n  [kClearTimeout]() {\n    if (this.#timeoutTimer)\n      clearTimeout(this.#timeoutTimer), this.#timeoutTimer = void 0, this.removeAllListeners(\"timeout\");\n  }\n  #onTimeout() {\n    this.#timeoutTimer = void 0, this[kAbortController]\?.abort(), this.emit(\"timeout\");\n  }\n  setTimeout(msecs, callback) {\n    if (this.destroyed)\n      return this;\n    if (this.timeout = msecs = validateMsecs(msecs, \"msecs\"), clearTimeout(this.#timeoutTimer), msecs === 0) {\n      if (callback !== void 0)\n        validateFunction(callback, \"callback\"), this.removeListener(\"timeout\", callback);\n      this.#timeoutTimer = void 0;\n    } else if (this.#timeoutTimer = setTimeout(this.#onTimeout.bind(this), msecs).unref(), callback !== void 0)\n      validateFunction(callback, \"callback\"), this.once(\"timeout\", callback);\n    return this;\n  }\n}\nvar tokenRegExp = /^[\\^_`a-zA-Z\\-0-9!#$%&'*+.|~]+$/, METHODS = [\n  \"ACL\",\n  \"BIND\",\n  \"CHECKOUT\",\n  \"CONNECT\",\n  \"COPY\",\n  \"DELETE\",\n  \"GET\",\n  \"HEAD\",\n  \"LINK\",\n  \"LOCK\",\n  \"M-SEARCH\",\n  \"MERGE\",\n  \"MKACTIVITY\",\n  \"MKCALENDAR\",\n  \"MKCOL\",\n  \"MOVE\",\n  \"NOTIFY\",\n  \"OPTIONS\",\n  \"PATCH\",\n  \"POST\",\n  \"PROPFIND\",\n  \"PROPPATCH\",\n  \"PURGE\",\n  \"PUT\",\n  \"REBIND\",\n  \"REPORT\",\n  \"SEARCH\",\n  \"SOURCE\",\n  \"SUBSCRIBE\",\n  \"TRACE\",\n  \"UNBIND\",\n  \"UNLINK\",\n  \"UNLOCK\",\n  \"UNSUBSCRIBE\"\n], STATUS_CODES = {\n  100: \"Continue\",\n  101: \"Switching Protocols\",\n  102: \"Processing\",\n  103: \"Early Hints\",\n  200: \"OK\",\n  201: \"Created\",\n  202: \"Accepted\",\n  203: \"Non-Authoritative Information\",\n  204: \"No Content\",\n  205: \"Reset Content\",\n  206: \"Partial Content\",\n  207: \"Multi-Status\",\n  208: \"Already Reported\",\n  226: \"IM Used\",\n  300: \"Multiple Choices\",\n  301: \"Moved Permanently\",\n  302: \"Found\",\n  303: \"See Other\",\n  304: \"Not Modified\",\n  305: \"Use Proxy\",\n  307: \"Temporary Redirect\",\n  308: \"Permanent Redirect\",\n  400: \"Bad Request\",\n  401: \"Unauthorized\",\n  402: \"Payment Required\",\n  403: \"Forbidden\",\n  404: \"Not Found\",\n  405: \"Method Not Allowed\",\n  406: \"Not Acceptable\",\n  407: \"Proxy Authentication Required\",\n  408: \"Request Timeout\",\n  409: \"Conflict\",\n  410: \"Gone\",\n  411: \"Length Required\",\n  412: \"Precondition Failed\",\n  413: \"Payload Too Large\",\n  414: \"URI Too Long\",\n  415: \"Unsupported Media Type\",\n  416: \"Range Not Satisfiable\",\n  417: \"Expectation Failed\",\n  418: \"I'm a Teapot\",\n  421: \"Misdirected Request\",\n  422: \"Unprocessable Entity\",\n  423: \"Locked\",\n  424: \"Failed Dependency\",\n  425: \"Too Early\",\n  426: \"Upgrade Required\",\n  428: \"Precondition Required\",\n  429: \"Too Many Requests\",\n  431: \"Request Header Fields Too Large\",\n  451: \"Unavailable For Legal Reasons\",\n  500: \"Internal Server Error\",\n  501: \"Not Implemented\",\n  502: \"Bad Gateway\",\n  503: \"Service Unavailable\",\n  504: \"Gateway Timeout\",\n  505: \"HTTP Version Not Supported\",\n  506: \"Variant Also Negotiates\",\n  507: \"Insufficient Storage\",\n  508: \"Loop Detected\",\n  509: \"Bandwidth Limit Exceeded\",\n  510: \"Not Extended\",\n  511: \"Network Authentication Required\"\n}, globalAgent = new Agent;\n$ = {\n  Agent,\n  Server,\n  METHODS,\n  STATUS_CODES,\n  createServer,\n  ServerResponse,\n  IncomingMessage,\n  request,\n  get,\n  maxHeaderSize: 16384,\n  validateHeaderName,\n  validateHeaderValue,\n  setMaxIdleHTTPParsers(max) {\n  },\n  globalAgent,\n  ClientRequest,\n  OutgoingMessage\n};\nreturn $})\n"_s;
//

//
static constexpr ASCIILiteral NodeHttp2Code = "(function (){\"use strict\";// src/js/out/tmp/node/http2.ts\nvar connect = function() {\n  throwNotImplemented(\"node:http2 connect\", 887);\n}, createServer = function() {\n  throwNotImplemented(\"node:http2 createServer\", 887);\n}, createSecureServer = function() {\n  throwNotImplemented(\"node:http2 createSecureServer\", 887);\n}, getDefaultSettings = function() {\n  return {\n    headerTableSize: 4096,\n    enablePush: !0,\n    initialWindowSize: 65535,\n    maxFrameSize: 16384,\n    maxConcurrentStreams: 4294967295,\n    maxHeaderSize: 65535,\n    maxHeaderListSize: 65535,\n    enableConnectProtocol: !1\n  };\n}, getPackedSettings = function() {\n  return Buffer.alloc(0);\n}, getUnpackedSettings = function() {\n  return Buffer.alloc(0);\n}, Http2ServerRequest = function() {\n  throwNotImplemented(\"node:http2 Http2ServerRequest\", 887);\n}, Http2ServerResponse = function() {\n  throwNotImplemented(\"node:http2 Http2ServerResponse\", 887);\n}, $, { hideFromStack, throwNotImplemented } = @getInternalField(@internalModuleRegistry, 3) || @createInternalModuleById(3), constants = {\n  NGHTTP2_ERR_FRAME_SIZE_ERROR: -522,\n  NGHTTP2_SESSION_SERVER: 0,\n  NGHTTP2_SESSION_CLIENT: 1,\n  NGHTTP2_STREAM_STATE_IDLE: 1,\n  NGHTTP2_STREAM_STATE_OPEN: 2,\n  NGHTTP2_STREAM_STATE_RESERVED_LOCAL: 3,\n  NGHTTP2_STREAM_STATE_RESERVED_REMOTE: 4,\n  NGHTTP2_STREAM_STATE_HALF_CLOSED_LOCAL: 5,\n  NGHTTP2_STREAM_STATE_HALF_CLOSED_REMOTE: 6,\n  NGHTTP2_STREAM_STATE_CLOSED: 7,\n  NGHTTP2_FLAG_NONE: 0,\n  NGHTTP2_FLAG_END_STREAM: 1,\n  NGHTTP2_FLAG_END_HEADERS: 4,\n  NGHTTP2_FLAG_ACK: 1,\n  NGHTTP2_FLAG_PADDED: 8,\n  NGHTTP2_FLAG_PRIORITY: 32,\n  DEFAULT_SETTINGS_HEADER_TABLE_SIZE: 4096,\n  DEFAULT_SETTINGS_ENABLE_PUSH: 1,\n  DEFAULT_SETTINGS_MAX_CONCURRENT_STREAMS: 4294967295,\n  DEFAULT_SETTINGS_INITIAL_WINDOW_SIZE: 65535,\n  DEFAULT_SETTINGS_MAX_FRAME_SIZE: 16384,\n  DEFAULT_SETTINGS_MAX_HEADER_LIST_SIZE: 65535,\n  DEFAULT_SETTINGS_ENABLE_CONNECT_PROTOCOL: 0,\n  MAX_MAX_FRAME_SIZE: 16777215,\n  MIN_MAX_FRAME_SIZE: 16384,\n  MAX_INITIAL_WINDOW_SIZE: 2147483647,\n  NGHTTP2_SETTINGS_HEADER_TABLE_SIZE: 1,\n  NGHTTP2_SETTINGS_ENABLE_PUSH: 2,\n  NGHTTP2_SETTINGS_MAX_CONCURRENT_STREAMS: 3,\n  NGHTTP2_SETTINGS_INITIAL_WINDOW_SIZE: 4,\n  NGHTTP2_SETTINGS_MAX_FRAME_SIZE: 5,\n  NGHTTP2_SETTINGS_MAX_HEADER_LIST_SIZE: 6,\n  NGHTTP2_SETTINGS_ENABLE_CONNECT_PROTOCOL: 8,\n  PADDING_STRATEGY_NONE: 0,\n  PADDING_STRATEGY_ALIGNED: 1,\n  PADDING_STRATEGY_MAX: 2,\n  PADDING_STRATEGY_CALLBACK: 1,\n  NGHTTP2_NO_ERROR: 0,\n  NGHTTP2_PROTOCOL_ERROR: 1,\n  NGHTTP2_INTERNAL_ERROR: 2,\n  NGHTTP2_FLOW_CONTROL_ERROR: 3,\n  NGHTTP2_SETTINGS_TIMEOUT: 4,\n  NGHTTP2_STREAM_CLOSED: 5,\n  NGHTTP2_FRAME_SIZE_ERROR: 6,\n  NGHTTP2_REFUSED_STREAM: 7,\n  NGHTTP2_CANCEL: 8,\n  NGHTTP2_COMPRESSION_ERROR: 9,\n  NGHTTP2_CONNECT_ERROR: 10,\n  NGHTTP2_ENHANCE_YOUR_CALM: 11,\n  NGHTTP2_INADEQUATE_SECURITY: 12,\n  NGHTTP2_HTTP_1_1_REQUIRED: 13,\n  NGHTTP2_DEFAULT_WEIGHT: 16,\n  HTTP2_HEADER_STATUS: \":status\",\n  HTTP2_HEADER_METHOD: \":method\",\n  HTTP2_HEADER_AUTHORITY: \":authority\",\n  HTTP2_HEADER_SCHEME: \":scheme\",\n  HTTP2_HEADER_PATH: \":path\",\n  HTTP2_HEADER_PROTOCOL: \":protocol\",\n  HTTP2_HEADER_ACCEPT_ENCODING: \"accept-encoding\",\n  HTTP2_HEADER_ACCEPT_LANGUAGE: \"accept-language\",\n  HTTP2_HEADER_ACCEPT_RANGES: \"accept-ranges\",\n  HTTP2_HEADER_ACCEPT: \"accept\",\n  HTTP2_HEADER_ACCESS_CONTROL_ALLOW_CREDENTIALS: \"access-control-allow-credentials\",\n  HTTP2_HEADER_ACCESS_CONTROL_ALLOW_HEADERS: \"access-control-allow-headers\",\n  HTTP2_HEADER_ACCESS_CONTROL_ALLOW_METHODS: \"access-control-allow-methods\",\n  HTTP2_HEADER_ACCESS_CONTROL_ALLOW_ORIGIN: \"access-control-allow-origin\",\n  HTTP2_HEADER_ACCESS_CONTROL_EXPOSE_HEADERS: \"access-control-expose-headers\",\n  HTTP2_HEADER_ACCESS_CONTROL_REQUEST_HEADERS: \"access-control-request-headers\",\n  HTTP2_HEADER_ACCESS_CONTROL_REQUEST_METHOD: \"access-control-request-method\",\n  HTTP2_HEADER_AGE: \"age\",\n  HTTP2_HEADER_AUTHORIZATION: \"authorization\",\n  HTTP2_HEADER_CACHE_CONTROL: \"cache-control\",\n  HTTP2_HEADER_CONNECTION: \"connection\",\n  HTTP2_HEADER_CONTENT_DISPOSITION: \"content-disposition\",\n  HTTP2_HEADER_CONTENT_ENCODING: \"content-encoding\",\n  HTTP2_HEADER_CONTENT_LENGTH: \"content-length\",\n  HTTP2_HEADER_CONTENT_TYPE: \"content-type\",\n  HTTP2_HEADER_COOKIE: \"cookie\",\n  HTTP2_HEADER_DATE: \"date\",\n  HTTP2_HEADER_ETAG: \"etag\",\n  HTTP2_HEADER_FORWARDED: \"forwarded\",\n  HTTP2_HEADER_HOST: \"host\",\n  HTTP2_HEADER_IF_MODIFIED_SINCE: \"if-modified-since\",\n  HTTP2_HEADER_IF_NONE_MATCH: \"if-none-match\",\n  HTTP2_HEADER_IF_RANGE: \"if-range\",\n  HTTP2_HEADER_LAST_MODIFIED: \"last-modified\",\n  HTTP2_HEADER_LINK: \"link\",\n  HTTP2_HEADER_LOCATION: \"location\",\n  HTTP2_HEADER_RANGE: \"range\",\n  HTTP2_HEADER_REFERER: \"referer\",\n  HTTP2_HEADER_SERVER: \"server\",\n  HTTP2_HEADER_SET_COOKIE: \"set-cookie\",\n  HTTP2_HEADER_STRICT_TRANSPORT_SECURITY: \"strict-transport-security\",\n  HTTP2_HEADER_TRANSFER_ENCODING: \"transfer-encoding\",\n  HTTP2_HEADER_TE: \"te\",\n  HTTP2_HEADER_UPGRADE_INSECURE_REQUESTS: \"upgrade-insecure-requests\",\n  HTTP2_HEADER_UPGRADE: \"upgrade\",\n  HTTP2_HEADER_USER_AGENT: \"user-agent\",\n  HTTP2_HEADER_VARY: \"vary\",\n  HTTP2_HEADER_X_CONTENT_TYPE_OPTIONS: \"x-content-type-options\",\n  HTTP2_HEADER_X_FRAME_OPTIONS: \"x-frame-options\",\n  HTTP2_HEADER_KEEP_ALIVE: \"keep-alive\",\n  HTTP2_HEADER_PROXY_CONNECTION: \"proxy-connection\",\n  HTTP2_HEADER_X_XSS_PROTECTION: \"x-xss-protection\",\n  HTTP2_HEADER_ALT_SVC: \"alt-svc\",\n  HTTP2_HEADER_CONTENT_SECURITY_POLICY: \"content-security-policy\",\n  HTTP2_HEADER_EARLY_DATA: \"early-data\",\n  HTTP2_HEADER_EXPECT_CT: \"expect-ct\",\n  HTTP2_HEADER_ORIGIN: \"origin\",\n  HTTP2_HEADER_PURPOSE: \"purpose\",\n  HTTP2_HEADER_TIMING_ALLOW_ORIGIN: \"timing-allow-origin\",\n  HTTP2_HEADER_X_FORWARDED_FOR: \"x-forwarded-for\",\n  HTTP2_HEADER_PRIORITY: \"priority\",\n  HTTP2_HEADER_ACCEPT_CHARSET: \"accept-charset\",\n  HTTP2_HEADER_ACCESS_CONTROL_MAX_AGE: \"access-control-max-age\",\n  HTTP2_HEADER_ALLOW: \"allow\",\n  HTTP2_HEADER_CONTENT_LANGUAGE: \"content-language\",\n  HTTP2_HEADER_CONTENT_LOCATION: \"content-location\",\n  HTTP2_HEADER_CONTENT_MD5: \"content-md5\",\n  HTTP2_HEADER_CONTENT_RANGE: \"content-range\",\n  HTTP2_HEADER_DNT: \"dnt\",\n  HTTP2_HEADER_EXPECT: \"expect\",\n  HTTP2_HEADER_EXPIRES: \"expires\",\n  HTTP2_HEADER_FROM: \"from\",\n  HTTP2_HEADER_IF_MATCH: \"if-match\",\n  HTTP2_HEADER_IF_UNMODIFIED_SINCE: \"if-unmodified-since\",\n  HTTP2_HEADER_MAX_FORWARDS: \"max-forwards\",\n  HTTP2_HEADER_PREFER: \"prefer\",\n  HTTP2_HEADER_PROXY_AUTHENTICATE: \"proxy-authenticate\",\n  HTTP2_HEADER_PROXY_AUTHORIZATION: \"proxy-authorization\",\n  HTTP2_HEADER_REFRESH: \"refresh\",\n  HTTP2_HEADER_RETRY_AFTER: \"retry-after\",\n  HTTP2_HEADER_TRAILER: \"trailer\",\n  HTTP2_HEADER_TK: \"tk\",\n  HTTP2_HEADER_VIA: \"via\",\n  HTTP2_HEADER_WARNING: \"warning\",\n  HTTP2_HEADER_WWW_AUTHENTICATE: \"www-authenticate\",\n  HTTP2_HEADER_HTTP2_SETTINGS: \"http2-settings\",\n  HTTP2_METHOD_ACL: \"ACL\",\n  HTTP2_METHOD_BASELINE_CONTROL: \"BASELINE-CONTROL\",\n  HTTP2_METHOD_BIND: \"BIND\",\n  HTTP2_METHOD_CHECKIN: \"CHECKIN\",\n  HTTP2_METHOD_CHECKOUT: \"CHECKOUT\",\n  HTTP2_METHOD_CONNECT: \"CONNECT\",\n  HTTP2_METHOD_COPY: \"COPY\",\n  HTTP2_METHOD_DELETE: \"DELETE\",\n  HTTP2_METHOD_GET: \"GET\",\n  HTTP2_METHOD_HEAD: \"HEAD\",\n  HTTP2_METHOD_LABEL: \"LABEL\",\n  HTTP2_METHOD_LINK: \"LINK\",\n  HTTP2_METHOD_LOCK: \"LOCK\",\n  HTTP2_METHOD_MERGE: \"MERGE\",\n  HTTP2_METHOD_MKACTIVITY: \"MKACTIVITY\",\n  HTTP2_METHOD_MKCALENDAR: \"MKCALENDAR\",\n  HTTP2_METHOD_MKCOL: \"MKCOL\",\n  HTTP2_METHOD_MKREDIRECTREF: \"MKREDIRECTREF\",\n  HTTP2_METHOD_MKWORKSPACE: \"MKWORKSPACE\",\n  HTTP2_METHOD_MOVE: \"MOVE\",\n  HTTP2_METHOD_OPTIONS: \"OPTIONS\",\n  HTTP2_METHOD_ORDERPATCH: \"ORDERPATCH\",\n  HTTP2_METHOD_PATCH: \"PATCH\",\n  HTTP2_METHOD_POST: \"POST\",\n  HTTP2_METHOD_PRI: \"PRI\",\n  HTTP2_METHOD_PROPFIND: \"PROPFIND\",\n  HTTP2_METHOD_PROPPATCH: \"PROPPATCH\",\n  HTTP2_METHOD_PUT: \"PUT\",\n  HTTP2_METHOD_REBIND: \"REBIND\",\n  HTTP2_METHOD_REPORT: \"REPORT\",\n  HTTP2_METHOD_SEARCH: \"SEARCH\",\n  HTTP2_METHOD_TRACE: \"TRACE\",\n  HTTP2_METHOD_UNBIND: \"UNBIND\",\n  HTTP2_METHOD_UNCHECKOUT: \"UNCHECKOUT\",\n  HTTP2_METHOD_UNLINK: \"UNLINK\",\n  HTTP2_METHOD_UNLOCK: \"UNLOCK\",\n  HTTP2_METHOD_UPDATE: \"UPDATE\",\n  HTTP2_METHOD_UPDATEREDIRECTREF: \"UPDATEREDIRECTREF\",\n  HTTP2_METHOD_VERSION_CONTROL: \"VERSION-CONTROL\",\n  HTTP_STATUS_CONTINUE: 100,\n  HTTP_STATUS_SWITCHING_PROTOCOLS: 101,\n  HTTP_STATUS_PROCESSING: 102,\n  HTTP_STATUS_EARLY_HINTS: 103,\n  HTTP_STATUS_OK: 200,\n  HTTP_STATUS_CREATED: 201,\n  HTTP_STATUS_ACCEPTED: 202,\n  HTTP_STATUS_NON_AUTHORITATIVE_INFORMATION: 203,\n  HTTP_STATUS_NO_CONTENT: 204,\n  HTTP_STATUS_RESET_CONTENT: 205,\n  HTTP_STATUS_PARTIAL_CONTENT: 206,\n  HTTP_STATUS_MULTI_STATUS: 207,\n  HTTP_STATUS_ALREADY_REPORTED: 208,\n  HTTP_STATUS_IM_USED: 226,\n  HTTP_STATUS_MULTIPLE_CHOICES: 300,\n  HTTP_STATUS_MOVED_PERMANENTLY: 301,\n  HTTP_STATUS_FOUND: 302,\n  HTTP_STATUS_SEE_OTHER: 303,\n  HTTP_STATUS_NOT_MODIFIED: 304,\n  HTTP_STATUS_USE_PROXY: 305,\n  HTTP_STATUS_TEMPORARY_REDIRECT: 307,\n  HTTP_STATUS_PERMANENT_REDIRECT: 308,\n  HTTP_STATUS_BAD_REQUEST: 400,\n  HTTP_STATUS_UNAUTHORIZED: 401,\n  HTTP_STATUS_PAYMENT_REQUIRED: 402,\n  HTTP_STATUS_FORBIDDEN: 403,\n  HTTP_STATUS_NOT_FOUND: 404,\n  HTTP_STATUS_METHOD_NOT_ALLOWED: 405,\n  HTTP_STATUS_NOT_ACCEPTABLE: 406,\n  HTTP_STATUS_PROXY_AUTHENTICATION_REQUIRED: 407,\n  HTTP_STATUS_REQUEST_TIMEOUT: 408,\n  HTTP_STATUS_CONFLICT: 409,\n  HTTP_STATUS_GONE: 410,\n  HTTP_STATUS_LENGTH_REQUIRED: 411,\n  HTTP_STATUS_PRECONDITION_FAILED: 412,\n  HTTP_STATUS_PAYLOAD_TOO_LARGE: 413,\n  HTTP_STATUS_URI_TOO_LONG: 414,\n  HTTP_STATUS_UNSUPPORTED_MEDIA_TYPE: 415,\n  HTTP_STATUS_RANGE_NOT_SATISFIABLE: 416,\n  HTTP_STATUS_EXPECTATION_FAILED: 417,\n  HTTP_STATUS_TEAPOT: 418,\n  HTTP_STATUS_MISDIRECTED_REQUEST: 421,\n  HTTP_STATUS_UNPROCESSABLE_ENTITY: 422,\n  HTTP_STATUS_LOCKED: 423,\n  HTTP_STATUS_FAILED_DEPENDENCY: 424,\n  HTTP_STATUS_TOO_EARLY: 425,\n  HTTP_STATUS_UPGRADE_REQUIRED: 426,\n  HTTP_STATUS_PRECONDITION_REQUIRED: 428,\n  HTTP_STATUS_TOO_MANY_REQUESTS: 429,\n  HTTP_STATUS_REQUEST_HEADER_FIELDS_TOO_LARGE: 431,\n  HTTP_STATUS_UNAVAILABLE_FOR_LEGAL_REASONS: 451,\n  HTTP_STATUS_INTERNAL_SERVER_ERROR: 500,\n  HTTP_STATUS_NOT_IMPLEMENTED: 501,\n  HTTP_STATUS_BAD_GATEWAY: 502,\n  HTTP_STATUS_SERVICE_UNAVAILABLE: 503,\n  HTTP_STATUS_GATEWAY_TIMEOUT: 504,\n  HTTP_STATUS_HTTP_VERSION_NOT_SUPPORTED: 505,\n  HTTP_STATUS_VARIANT_ALSO_NEGOTIATES: 506,\n  HTTP_STATUS_INSUFFICIENT_STORAGE: 507,\n  HTTP_STATUS_LOOP_DETECTED: 508,\n  HTTP_STATUS_BANDWIDTH_LIMIT_EXCEEDED: 509,\n  HTTP_STATUS_NOT_EXTENDED: 510,\n  HTTP_STATUS_NETWORK_AUTHENTICATION_REQUIRED: 511\n}, sensitiveHeaders = Symbol.for(\"nodejs.http2.sensitiveHeaders\");\n$ = {\n  constants,\n  createServer,\n  createSecureServer,\n  getDefaultSettings,\n  getPackedSettings,\n  getUnpackedSettings,\n  sensitiveHeaders,\n  Http2ServerRequest,\n  Http2ServerResponse,\n  connect\n};\nhideFromStack([\n  Http2ServerRequest,\n  Http2ServerResponse,\n  connect,\n  createServer,\n  createSecureServer,\n  getDefaultSettings,\n  getPackedSettings,\n  getUnpackedSettings\n]);\nreturn $})\n"_s;
//

//
static constexpr ASCIILiteral NodeHttpsCode = "(function (){\"use strict\";// src/js/out/tmp/node/https.ts\nvar request = function(input, options, cb) {\n  if (input && typeof input === \"object\" && !(input instanceof URL))\n    input.protocol \?\?= \"https:\";\n  else if (typeof options === \"object\")\n    options.protocol \?\?= \"https:\";\n  return http.request(input, options, cb);\n}, get = function(input, options, cb) {\n  const req = request(input, options, cb);\n  return req.end(), req;\n}, $, http = @getInternalField(@internalModuleRegistry, 19) || @createInternalModuleById(19);\n$ = {\n  ...http,\n  get,\n  request\n};\nreturn $})\n"_s;
//

//
static constexpr ASCIILiteral NodeInspectorCode = "(function (){\"use strict\";// src/js/out/tmp/node/inspector.ts\nvar open = function() {\n  throwNotImplemented(\"node:inspector open\", 2445);\n}, close = function() {\n  throwNotImplemented(\"node:inspector close\", 2445);\n}, url = function() {\n  throwNotImplemented(\"node:inspector url\", 2445);\n}, waitForDebugger = function() {\n  throwNotImplemented(\"node:inspector waitForDebugger\", 2445);\n}, $, { hideFromStack, throwNotImplemented } = @getInternalField(@internalModuleRegistry, 3) || @createInternalModuleById(3), EventEmitter = @getInternalField(@internalModuleRegistry, 16) || @createInternalModuleById(16);\n\nclass Session extends EventEmitter {\n  constructor() {\n    super();\n    throwNotImplemented(\"node:inspector Session\", 2445);\n  }\n}\nvar console = {\n  ...globalThis.console,\n  context: {\n    console: globalThis.console\n  }\n};\n$ = {\n  console,\n  open,\n  close,\n  url,\n  waitForDebugger,\n  Session\n};\nhideFromStack(open, close, url, waitForDebugger, Session.prototype.constructor);\nreturn $})\n"_s;
//

//
static constexpr ASCIILiteral NodeNetCode = "(function (){\"use strict\";// src/js/out/tmp/node/net.ts\nvar isIPv4 = function(s) {\n  return IPv4Reg.test(s);\n}, isIPv6 = function(s) {\n  return IPv6Reg.test(s);\n}, isIP = function(s) {\n  if (isIPv4(s))\n    return 4;\n  if (isIPv6(s))\n    return 6;\n  return 0;\n}, createConnection = function(port, host, connectListener) {\n  if (typeof port === \"object\")\n    return new Socket(port).connect(port, host, connectListener);\n  return new Socket().connect(port, host, connectListener);\n}, emitErrorNextTick = function(self, error) {\n  self.emit(\"error\", error);\n}, emitListeningNextTick = function(self, onListen) {\n  if (typeof onListen === \"function\")\n    try {\n      onListen();\n    } catch (err) {\n      self.emit(\"error\", err);\n    }\n  self.emit(\"listening\");\n}, createServer = function(options, connectionListener) {\n  return new Server(options, connectionListener);\n}, $, { Duplex } = @getInternalField(@internalModuleRegistry, 35) || @createInternalModuleById(35), EventEmitter = @getInternalField(@internalModuleRegistry, 16) || @createInternalModuleById(16);\nvar IPv4Reg = new RegExp(\"^((\?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])[.]){3}(\?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])$\");\nvar IPv6Reg = new RegExp(\"^((\?:(\?:[0-9a-fA-F]{1,4}):){7}(\?:(\?:[0-9a-fA-F]{1,4})|:)|(\?:(\?:[0-9a-fA-F]{1,4}):){6}(\?:((\?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])[.]){3}(\?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])|:(\?:[0-9a-fA-F]{1,4})|:)|(\?:(\?:[0-9a-fA-F]{1,4}):){5}(\?::((\?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])[.]){3}(\?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])|(:(\?:[0-9a-fA-F]{1,4})){1,2}|:)|(\?:(\?:[0-9a-fA-F]{1,4}):){4}(\?:(:(\?:[0-9a-fA-F]{1,4})){0,1}:((\?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])[.]){3}(\?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])|(:(\?:[0-9a-fA-F]{1,4})){1,3}|:)|(\?:(\?:[0-9a-fA-F]{1,4}):){3}(\?:(:(\?:[0-9a-fA-F]{1,4})){0,2}:((\?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])[.]){3}(\?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])|(:(\?:[0-9a-fA-F]{1,4})){1,4}|:)|(\?:(\?:[0-9a-fA-F]{1,4}):){2}(\?:(:(\?:[0-9a-fA-F]{1,4})){0,3}:((\?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])[.]){3}(\?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])|(:(\?:[0-9a-fA-F]{1,4})){1,5}|:)|(\?:(\?:[0-9a-fA-F]{1,4}):){1}(\?:(:(\?:[0-9a-fA-F]{1,4})){0,4}:((\?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])[.]){3}(\?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])|(:(\?:[0-9a-fA-F]{1,4})){1,6}|:)|(\?::((\?::(\?:[0-9a-fA-F]{1,4})){0,5}:((\?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])[.]){3}(\?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])|(\?::(\?:[0-9a-fA-F]{1,4})){1,7}|:)))(%[0-9a-zA-Z-.:]{1,})\?$\"), { connect: bunConnect } = Bun, { setTimeout } = globalThis, bunTlsSymbol = Symbol.for(\"::buntls::\"), bunSocketServerHandlers = Symbol.for(\"::bunsocket_serverhandlers::\"), bunSocketServerConnections = Symbol.for(\"::bunnetserverconnections::\"), bunSocketServerOptions = Symbol.for(\"::bunnetserveroptions::\"), bunSocketInternal = Symbol.for(\"::bunnetsocketinternal::\"), bunTLSConnectOptions = Symbol.for(\"::buntlsconnectoptions::\"), SocketClass, Socket = function(InternalSocket) {\n  return SocketClass = InternalSocket, Object.defineProperty(SocketClass.prototype, Symbol.toStringTag, {\n    value: \"Socket\",\n    enumerable: !1\n  }), Object.defineProperty(function Socket(options) {\n    return new InternalSocket(options);\n  }, Symbol.hasInstance, {\n    value(instance) {\n      return instance instanceof InternalSocket;\n    }\n  });\n}(class Socket2 extends Duplex {\n  static #Handlers = {\n    close: Socket2.#Close,\n    connectError(socket, error) {\n      socket.data.emit(\"error\", error);\n    },\n    data({ data: self }, buffer) {\n      self.bytesRead += buffer.length;\n      const queue = self.#readQueue;\n      if (queue.isEmpty()) {\n        if (self.push(buffer))\n          return;\n      }\n      queue.push(buffer);\n    },\n    drain: Socket2.#Drain,\n    end: Socket2.#Close,\n    error(socket, error) {\n      const self = socket.data, callback = self.#writeCallback;\n      if (callback)\n        self.#writeCallback = null, callback(error);\n      self.emit(\"error\", error);\n    },\n    open(socket) {\n      const self = socket.data;\n      socket.timeout(self.timeout), socket.ref(), self[bunSocketInternal] = socket, self.connecting = !1;\n      const options = self[bunTLSConnectOptions];\n      if (options) {\n        const { session } = options;\n        if (session)\n          self.setSession(session);\n      }\n      if (!self.#upgraded)\n        self.emit(\"connect\", self);\n      Socket2.#Drain(socket);\n    },\n    handshake(socket, success, verifyError) {\n      const { data: self } = socket;\n      self._securePending = !1, self.secureConnecting = !1, self._secureEstablished = !!success, self.emit(\"secure\", self);\n      const { checkServerIdentity } = self[bunTLSConnectOptions];\n      if (!verifyError && typeof checkServerIdentity === \"function\" && self.servername) {\n        const cert = self.getPeerCertificate(!0);\n        verifyError = checkServerIdentity(self.servername, cert);\n      }\n      if (self._requestCert || self._rejectUnauthorized) {\n        if (verifyError) {\n          if (self.authorized = !1, self.authorizationError = verifyError.code || verifyError.message, self._rejectUnauthorized) {\n            self.destroy(verifyError);\n            return;\n          }\n        }\n      } else\n        self.authorized = !0;\n      self.emit(\"secureConnect\", verifyError);\n    },\n    timeout(socket) {\n      const self = socket.data;\n      self.emit(\"timeout\", self);\n    },\n    binaryType: \"buffer\"\n  };\n  static #Close(socket) {\n    const self = socket.data;\n    if (self.#closed)\n      return;\n    self.#closed = !0, self[bunSocketInternal] = null;\n    const queue = self.#readQueue;\n    if (queue.isEmpty()) {\n      if (self.push(null))\n        return;\n    }\n    queue.push(null);\n  }\n  static #Drain(socket) {\n    const self = socket.data, callback = self.#writeCallback;\n    if (callback) {\n      const chunk = self.#writeChunk, written = socket.write(chunk);\n      if (self.bytesWritten += written, written < chunk.length)\n        self.#writeChunk = chunk.slice(written);\n      else\n        self.#writeCallback = null, self.#writeChunk = null, callback(null);\n    }\n  }\n  static [bunSocketServerHandlers] = {\n    data: Socket2.#Handlers.data,\n    close(socket) {\n      Socket2.#Handlers.close(socket), this.data[bunSocketServerConnections]--;\n    },\n    end(socket) {\n      Socket2.#Handlers.end(socket), this.data[bunSocketServerConnections]--;\n    },\n    open(socket) {\n      const self = this.data, options = self[bunSocketServerOptions], { pauseOnConnect, connectionListener, InternalSocketClass, requestCert, rejectUnauthorized } = options, _socket = new InternalSocketClass({});\n      if (_socket.isServer = !0, _socket._requestCert = requestCert, _socket._rejectUnauthorized = rejectUnauthorized, _socket.#attach(this.localPort, socket), self.maxConnections && self[bunSocketServerConnections] >= self.maxConnections) {\n        const data = {\n          localAddress: _socket.localAddress,\n          localPort: _socket.localPort,\n          localFamily: _socket.localFamily,\n          remoteAddress: _socket.remoteAddress,\n          remotePort: _socket.remotePort,\n          remoteFamily: _socket.remoteFamily || \"IPv4\"\n        };\n        socket.end(), self.emit(\"drop\", data);\n        return;\n      }\n      if (!pauseOnConnect)\n        _socket.resume();\n      if (self[bunSocketServerConnections]++, typeof connectionListener == \"function\")\n        if (InternalSocketClass.name === \"TLSSocket\")\n          self.once(\"secureConnection\", () => connectionListener(_socket));\n        else\n          connectionListener(_socket);\n      self.emit(\"connection\", _socket);\n    },\n    handshake(socket, success, verifyError) {\n      const { data: self } = socket;\n      if (self.emit(\"secure\", self), self._securePending = !1, self.secureConnecting = !1, self._secureEstablished = !!success, self._requestCert || self._rejectUnauthorized) {\n        if (verifyError) {\n          if (self.authorized = !1, self.authorizationError = verifyError.code || verifyError.message, self._rejectUnauthorized) {\n            self.destroy(verifyError);\n            return;\n          }\n        }\n      } else\n        self.authorized = !0;\n      self.emit(\"secureConnection\", verifyError);\n    },\n    error(socket, error) {\n      Socket2.#Handlers.error(socket, error), this.data.emit(\"error\", error);\n    },\n    timeout: Socket2.#Handlers.timeout,\n    connectError: Socket2.#Handlers.connectError,\n    drain: Socket2.#Handlers.drain,\n    binaryType: \"buffer\"\n  };\n  bytesRead = 0;\n  bytesWritten = 0;\n  #closed = !1;\n  connecting = !1;\n  localAddress = \"127.0.0.1\";\n  #readQueue = @createFIFO();\n  remotePort;\n  [bunSocketInternal] = null;\n  [bunTLSConnectOptions] = null;\n  timeout = 0;\n  #writeCallback;\n  #writeChunk;\n  #pendingRead;\n  isServer = !1;\n  _handle;\n  _parent;\n  _parentWrap;\n  #socket;\n  #upgraded;\n  constructor(options) {\n    const { socket, signal, write, read, allowHalfOpen = !1, ...opts } = options || {};\n    super({\n      ...opts,\n      allowHalfOpen,\n      readable: !0,\n      writable: !0\n    });\n    if (this._handle = this, this._parent = this, this._parentWrap = this, this.#pendingRead = void 0, this.#upgraded = !1, socket instanceof Socket2)\n      this.#socket = socket;\n    signal\?.once(\"abort\", () => this.destroy()), this.once(\"connect\", () => this.emit(\"ready\"));\n  }\n  address() {\n    return {\n      address: this.localAddress,\n      family: this.localFamily,\n      port: this.localPort\n    };\n  }\n  get bufferSize() {\n    return this.writableLength;\n  }\n  #attach(port, socket) {\n    if (this.remotePort = port, socket.data = this, socket.timeout(this.timeout), socket.ref(), this[bunSocketInternal] = socket, this.connecting = !1, !this.#upgraded)\n      this.emit(\"connect\", this);\n    Socket2.#Drain(socket);\n  }\n  connect(port, host, connectListener) {\n    var path, connection = this.#socket, _checkServerIdentity = void 0;\n    if (typeof port === \"string\") {\n      if (path = port, port = void 0, typeof host === \"function\")\n        connectListener = host, host = void 0;\n    } else if (typeof host == \"function\") {\n      if (typeof port === \"string\")\n        path = port, port = void 0;\n      connectListener = host, host = void 0;\n    }\n    if (typeof port == \"object\") {\n      var {\n        port,\n        host,\n        path,\n        socket,\n        localAddress,\n        localPort,\n        family,\n        hints,\n        lookup,\n        noDelay,\n        keepAlive,\n        keepAliveInitialDelay,\n        requestCert,\n        rejectUnauthorized,\n        pauseOnConnect,\n        servername,\n        checkServerIdentity,\n        session\n      } = port;\n      if (_checkServerIdentity = checkServerIdentity, this.servername = servername, socket)\n        connection = socket;\n    }\n    if (!pauseOnConnect)\n      this.resume();\n    this.connecting = !0, this.remotePort = port;\n    const bunTLS = this[bunTlsSymbol];\n    var tls = void 0;\n    if (typeof bunTLS === \"function\") {\n      if (tls = bunTLS.call(this, port, host, !0), this._requestCert = !0, this._rejectUnauthorized = rejectUnauthorized, tls) {\n        if (tls.rejectUnauthorized = rejectUnauthorized, tls.requestCert = !0, tls.session = session || tls.session, this.servername = tls.servername, tls.checkServerIdentity = _checkServerIdentity || tls.checkServerIdentity, this[bunTLSConnectOptions] = tls, !connection && tls.socket)\n          connection = tls.socket;\n      }\n      if (connection) {\n        if (typeof connection !== \"object\" || !(connection instanceof Socket2) || typeof connection[bunTlsSymbol] === \"function\")\n          @throwTypeError(\"socket must be an instance of net.Socket\");\n      }\n      if (this.authorized = !1, this.secureConnecting = !0, this._secureEstablished = !1, this._securePending = !0, connectListener)\n        this.on(\"secureConnect\", connectListener);\n    } else if (connectListener)\n      this.on(\"connect\", connectListener);\n    if (connection) {\n      const socket2 = connection[bunSocketInternal];\n      if (socket2) {\n        this.connecting = !0, this.#upgraded = !0;\n        const result = socket2.upgradeTLS({\n          data: this,\n          tls,\n          socket: Socket2.#Handlers\n        });\n        if (result) {\n          const [raw, tls2] = result;\n          connection[bunSocketInternal] = raw, raw.timeout(raw.timeout), raw.connecting = !1, this[bunSocketInternal] = tls2;\n        } else\n          throw this[bunSocketInternal] = null, new Error(\"Invalid socket\");\n      } else\n        connection.once(\"connect\", () => {\n          const socket3 = connection[bunSocketInternal];\n          if (!socket3)\n            return;\n          this.connecting = !0, this.#upgraded = !0;\n          const result = socket3.upgradeTLS({\n            data: this,\n            tls,\n            socket: Socket2.#Handlers\n          });\n          if (result) {\n            const [raw, tls2] = result;\n            connection[bunSocketInternal] = raw, raw.timeout(raw.timeout), raw.connecting = !1, this[bunSocketInternal] = tls2;\n          } else\n            throw this[bunSocketInternal] = null, new Error(\"Invalid socket\");\n        });\n    } else if (path)\n      bunConnect({\n        data: this,\n        unix: path,\n        socket: Socket2.#Handlers,\n        tls\n      }).catch((error) => {\n        this.emit(\"error\", error);\n      });\n    else\n      bunConnect({\n        data: this,\n        hostname: host || \"localhost\",\n        port,\n        socket: Socket2.#Handlers,\n        tls\n      }).catch((error) => {\n        this.emit(\"error\", error);\n      });\n    return this;\n  }\n  _destroy(err, callback) {\n    this[bunSocketInternal]\?.end(), callback(err);\n  }\n  _final(callback) {\n    this[bunSocketInternal]\?.end(), callback();\n  }\n  get localAddress() {\n    return \"127.0.0.1\";\n  }\n  get localFamily() {\n    return \"IPv4\";\n  }\n  get localPort() {\n    return this[bunSocketInternal]\?.localPort;\n  }\n  get pending() {\n    return this.connecting;\n  }\n  _read(size) {\n    const queue = this.#readQueue;\n    let chunk;\n    while (chunk = queue.peek()) {\n      if (!this.push(chunk))\n        return;\n      queue.shift();\n    }\n  }\n  get readyState() {\n    if (this.connecting)\n      return \"opening\";\n    if (this.readable)\n      return this.writable \? \"open\" : \"readOnly\";\n    else\n      return this.writable \? \"writeOnly\" : \"closed\";\n  }\n  ref() {\n    this[bunSocketInternal]\?.ref();\n  }\n  get remoteAddress() {\n    return this[bunSocketInternal]\?.remoteAddress;\n  }\n  get remoteFamily() {\n    return \"IPv4\";\n  }\n  resetAndDestroy() {\n    this[bunSocketInternal]\?.end();\n  }\n  setKeepAlive(enable = !1, initialDelay = 0) {\n    return this;\n  }\n  setNoDelay(noDelay = !0) {\n    return this;\n  }\n  setTimeout(timeout, callback) {\n    if (this[bunSocketInternal]\?.timeout(timeout), this.timeout = timeout, callback)\n      this.once(\"timeout\", callback);\n    return this;\n  }\n  unref() {\n    this[bunSocketInternal]\?.unref();\n  }\n  _write(chunk, encoding, callback) {\n    if (typeof chunk == \"string\" && encoding !== \"ascii\")\n      chunk = Buffer.from(chunk, encoding);\n    var written = this[bunSocketInternal]\?.write(chunk);\n    if (written == chunk.length)\n      callback();\n    else if (this.#writeCallback)\n      callback(new Error(\"overlapping _write()\"));\n    else {\n      if (written > 0)\n        if (typeof chunk == \"string\")\n          chunk = chunk.slice(written);\n        else\n          chunk = chunk.subarray(written);\n      this.#writeCallback = callback, this.#writeChunk = chunk;\n    }\n  }\n}), connect = createConnection;\n\nclass Server extends EventEmitter {\n  #server;\n  #listening = !1;\n  [bunSocketServerConnections] = 0;\n  [bunSocketServerOptions];\n  maxConnections = 0;\n  constructor(options, connectionListener) {\n    super();\n    if (typeof options === \"function\")\n      connectionListener = options, options = {};\n    else if (options == null || typeof options === \"object\")\n      options = { ...options };\n    else\n      throw new Error(\"bun-net-polyfill: invalid arguments\");\n    const { maxConnections } = options;\n    this.maxConnections = Number.isSafeInteger(maxConnections) && maxConnections > 0 \? maxConnections : 0, options.connectionListener = connectionListener, this[bunSocketServerOptions] = options;\n  }\n  ref() {\n    return this.#server\?.ref(), this;\n  }\n  unref() {\n    return this.#server\?.unref(), this;\n  }\n  close(callback) {\n    if (this.#server) {\n      if (this.#server.stop(!0), this.#server = null, this.#listening = !1, this[bunSocketServerConnections] = 0, this.emit(\"close\"), typeof callback === \"function\")\n        callback();\n      return this;\n    }\n    if (typeof callback === \"function\") {\n      const error = new Error(\"Server is not running\");\n      error.code = \"ERR_SERVER_NOT_RUNNING\", callback(error);\n    }\n    return this;\n  }\n  address() {\n    const server = this.#server;\n    if (server) {\n      const unix = server.unix;\n      if (unix)\n        return unix;\n      let address = server.hostname;\n      const type = isIP(address), port = server.port;\n      if (typeof port === \"number\")\n        return {\n          port,\n          address,\n          family: type \? `IPv${type}` : void 0\n        };\n      if (type)\n        return {\n          address,\n          family: type \? `IPv${type}` : void 0\n        };\n      return address;\n    }\n    return null;\n  }\n  getConnections(callback) {\n    if (typeof callback === \"function\")\n      callback(null, this.#server \? this[bunSocketServerConnections] : 0);\n    return this;\n  }\n  listen(port, hostname, onListen) {\n    let backlog, path, exclusive = !1;\n    if (typeof port === \"string\") {\n      if (Number.isSafeInteger(hostname)) {\n        if (hostname > 0)\n          backlog = hostname;\n      } else if (typeof hostname === \"function\")\n        onListen = hostname;\n      path = port, hostname = void 0, port = void 0;\n    } else {\n      if (typeof hostname === \"function\")\n        onListen = hostname, hostname = void 0;\n      if (typeof port === \"function\")\n        onListen = port, port = 0;\n      else if (typeof port === \"object\") {\n        const options = port;\n        options.signal\?.addEventListener(\"abort\", () => this.close()), hostname = options.host, exclusive = options.exclusive === !0;\n        const path2 = options.path;\n        if (port = options.port, !Number.isSafeInteger(port) || port < 0)\n          if (path2)\n            hostname = path2, port = void 0;\n          else {\n            let message = 'The argument \\'options\\' must have the property \"port\" or \"path\"';\n            try {\n              message = `${message}. Received ${JSON.stringify(options)}`;\n            } catch {\n            }\n            const error = @makeTypeError(message);\n            throw error.code = \"ERR_INVALID_ARG_VALUE\", error;\n          }\n        else if (!Number.isSafeInteger(port) || port < 0)\n          port = 0;\n        if (typeof port.callback === \"function\")\n          onListen = port\?.callback;\n      } else if (!Number.isSafeInteger(port) || port < 0)\n        port = 0;\n      hostname = hostname || \"::\";\n    }\n    try {\n      var tls = void 0, TLSSocketClass = void 0;\n      const bunTLS = this[bunTlsSymbol], options = this[bunSocketServerOptions];\n      if (typeof bunTLS === \"function\")\n        [tls, TLSSocketClass] = bunTLS.call(this, port, hostname, !1), options.servername = tls.serverName, options.InternalSocketClass = TLSSocketClass;\n      else\n        options.InternalSocketClass = SocketClass;\n      this.#server = Bun.listen(path \? {\n        exclusive,\n        unix: path,\n        tls,\n        socket: SocketClass[bunSocketServerHandlers]\n      } : {\n        exclusive,\n        port,\n        hostname,\n        tls,\n        socket: SocketClass[bunSocketServerHandlers]\n      }), this.#server.data = this, this.#listening = !0, setTimeout(emitListeningNextTick, 1, this, onListen);\n    } catch (err) {\n      this.#listening = !1, setTimeout(emitErrorNextTick, 1, this, err);\n    }\n    return this;\n  }\n}\n$ = {\n  createServer,\n  Server,\n  createConnection,\n  connect,\n  isIP,\n  isIPv4,\n  isIPv6,\n  Socket,\n  [Symbol.for(\"::bunternal::\")]: SocketClass\n};\nreturn $})\n"_s;
//

//
static constexpr ASCIILiteral NodeOSCode = "(function (){\"use strict\";// src/js/out/tmp/node/os.ts\nvar lazyCpus = function({ cpus }) {\n  return () => {\n    const array = new Array(navigator.hardwareConcurrency);\n    function populate() {\n      const results = cpus(), length = results.length;\n      array.length = length;\n      for (let i = 0;i < length; i++)\n        array[i] = results[i];\n    }\n    for (let i = 0;i < array.length; i++) {\n      const instance = {\n        get model() {\n          if (array[i] === instance)\n            populate();\n          return array[i].model;\n        },\n        set model(value) {\n          if (array[i] === instance)\n            populate();\n          array[i].model = value;\n        },\n        get speed() {\n          if (array[i] === instance)\n            populate();\n          return array[i].speed;\n        },\n        set speed(value) {\n          if (array[i] === instance)\n            populate();\n          array[i].speed = value;\n        },\n        get times() {\n          if (array[i] === instance)\n            populate();\n          return array[i].times;\n        },\n        set times(value) {\n          if (array[i] === instance)\n            populate();\n          array[i].times = value;\n        },\n        toJSON() {\n          if (array[i] === instance)\n            populate();\n          return array[i];\n        }\n      };\n      array[i] = instance;\n    }\n    return array;\n  };\n}, bound = function(obj) {\n  return {\n    arch: obj.arch.bind(obj),\n    cpus: lazyCpus(obj),\n    endianness: obj.endianness.bind(obj),\n    freemem: obj.freemem.bind(obj),\n    getPriority: obj.getPriority.bind(obj),\n    homedir: obj.homedir.bind(obj),\n    hostname: obj.hostname.bind(obj),\n    loadavg: obj.loadavg.bind(obj),\n    networkInterfaces: obj.networkInterfaces.bind(obj),\n    platform: obj.platform.bind(obj),\n    release: obj.release.bind(obj),\n    setPriority: obj.setPriority.bind(obj),\n    get tmpdir() {\n      return tmpdir;\n    },\n    totalmem: obj.totalmem.bind(obj),\n    type: obj.type.bind(obj),\n    uptime: obj.uptime.bind(obj),\n    userInfo: obj.userInfo.bind(obj),\n    version: obj.version.bind(obj),\n    machine: obj.machine.bind(obj),\n    devNull: obj.devNull,\n    EOL: obj.EOL,\n    constants: @processBindingConstants.os\n  };\n}, tmpdir = function() {\n  var env = Bun.env;\n  return tmpdir = function() {\n    var path = env.TMPDIR || env.TMP || env.TEMP || \"/tmp\";\n    const length = path.length;\n    if (length > 1 && path[length - 1] === \"/\")\n      path = path.slice(0, -1);\n    return path;\n  }, tmpdir();\n};\nreturn bound(Bun._Os())})\n"_s;
//

//
static constexpr ASCIILiteral NodePathPosixCode = "(function (){\"use strict\";// src/js/out/tmp/node/path.posix.ts\nreturn (@getInternalField(@internalModuleRegistry, 26) || @createInternalModuleById(26)).posix})\n"_s;
//

//
static constexpr ASCIILiteral NodePathCode = "(function (){\"use strict\";// src/js/out/tmp/node/path.ts\nvar bound = function(obj) {\n  const toNamespacedPath = obj.toNamespacedPath.bind(obj);\n  return {\n    resolve: obj.resolve.bind(obj),\n    normalize: obj.normalize.bind(obj),\n    isAbsolute: obj.isAbsolute.bind(obj),\n    join: obj.join.bind(obj),\n    relative: obj.relative.bind(obj),\n    toNamespacedPath,\n    dirname: obj.dirname.bind(obj),\n    basename: obj.basename.bind(obj),\n    extname: obj.extname.bind(obj),\n    format: obj.format.bind(obj),\n    parse: obj.parse.bind(obj),\n    sep: obj.sep,\n    delimiter: obj.delimiter,\n    win32: void 0,\n    posix: void 0,\n    _makeLong: toNamespacedPath\n  };\n}, posix = bound(Bun._Path(!1)), win32 = bound(Bun._Path(!0));\nposix.win32 = win32.win32 = win32;\nposix.posix = win32.posix = posix;\nreturn posix})\n"_s;
//

//
static constexpr ASCIILiteral NodePathWin32Code = "(function (){\"use strict\";// src/js/out/tmp/node/path.win32.ts\nreturn (@getInternalField(@internalModuleRegistry, 26) || @createInternalModuleById(26)).win32})\n"_s;
//

//
static constexpr ASCIILiteral NodePerfHooksCode = "(function (){\"use strict\";// src/js/out/tmp/node/perf_hooks.ts\nvar $, { throwNotImplemented } = @getInternalField(@internalModuleRegistry, 3) || @createInternalModuleById(3), constants = {\n  NODE_PERFORMANCE_GC_MAJOR: 4,\n  NODE_PERFORMANCE_GC_MINOR: 1,\n  NODE_PERFORMANCE_GC_INCREMENTAL: 8,\n  NODE_PERFORMANCE_GC_WEAKCB: 16,\n  NODE_PERFORMANCE_GC_FLAGS_NO: 0,\n  NODE_PERFORMANCE_GC_FLAGS_CONSTRUCT_RETAINED: 2,\n  NODE_PERFORMANCE_GC_FLAGS_FORCED: 4,\n  NODE_PERFORMANCE_GC_FLAGS_SYNCHRONOUS_PHANTOM_PROCESSING: 8,\n  NODE_PERFORMANCE_GC_FLAGS_ALL_AVAILABLE_GARBAGE: 16,\n  NODE_PERFORMANCE_GC_FLAGS_ALL_EXTERNAL_MEMORY: 32,\n  NODE_PERFORMANCE_GC_FLAGS_SCHEDULE_IDLE: 64\n}, performance = globalThis.performance;\n\nclass PerformanceObserver {\n  constructor() {\n    throwNotImplemented(\"PerformanceObserver\");\n  }\n}\n\nclass PerformanceEntry {\n  constructor() {\n    throwNotImplemented(\"PerformanceEntry\");\n  }\n}\n$ = {\n  performance,\n  constants,\n  PerformanceEntry,\n  PerformanceObserver\n};\nreturn $})\n"_s;
//

//
static constexpr ASCIILiteral NodePunycodeCode = "(function (){\"use strict\";// src/js/out/tmp/node/punycode.ts\nvar error = function(type) {\n  @throwRangeError(errors[type]);\n}, map = function(array, callback) {\n  const result = [];\n  let length = array.length;\n  while (length--)\n    result[length] = callback(array[length]);\n  return result;\n}, mapDomain = function(domain, callback) {\n  const parts = domain.split(\"@\");\n  let result = \"\";\n  if (parts.length > 1)\n    result = parts[0] + \"@\", domain = parts[1];\n  domain = domain.replace(regexSeparators, \".\");\n  const labels = domain.split(\".\"), encoded = map(labels, callback).join(\".\");\n  return result + encoded;\n}, ucs2decode = function(string) {\n  const output = [];\n  let counter = 0;\n  const length = string.length;\n  while (counter < length) {\n    const value = string.charCodeAt(counter++);\n    if (value >= 55296 && value <= 56319 && counter < length) {\n      const extra = string.charCodeAt(counter++);\n      if ((extra & 64512) == 56320)\n        output.push(((value & 1023) << 10) + (extra & 1023) + 65536);\n      else\n        output.push(value), counter--;\n    } else\n      output.push(value);\n  }\n  return output;\n}, $, maxInt = 2147483647, base = 36, tMin = 1, tMax = 26, skew = 38, damp = 700, initialBias = 72, initialN = 128, delimiter = \"-\", regexPunycode = /^xn--/, regexNonASCII = /[^\\0-\\x7F]/, regexSeparators = /[\\x2E\\u3002\\uFF0E\\uFF61]/g, errors = {\n  overflow: \"Overflow: input needs wider integers to process\",\n  \"not-basic\": \"Illegal input >= 0x80 (not a basic code point)\",\n  \"invalid-input\": \"Invalid input\"\n}, baseMinusTMin = base - tMin, floor = Math.floor, stringFromCharCode = String.fromCharCode, ucs2encode = (codePoints) => String.fromCodePoint(...codePoints), basicToDigit = function(codePoint) {\n  if (codePoint >= 48 && codePoint < 58)\n    return 26 + (codePoint - 48);\n  if (codePoint >= 65 && codePoint < 91)\n    return codePoint - 65;\n  if (codePoint >= 97 && codePoint < 123)\n    return codePoint - 97;\n  return base;\n}, digitToBasic = function(digit, flag) {\n  return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);\n}, adapt = function(delta, numPoints, firstTime) {\n  let k = 0;\n  delta = firstTime \? floor(delta / damp) : delta >> 1, delta += floor(delta / numPoints);\n  for (;delta > baseMinusTMin * tMax >> 1; k += base)\n    delta = floor(delta / baseMinusTMin);\n  return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));\n}, decode = function(input) {\n  const output = [], inputLength = input.length;\n  let i = 0, n = initialN, bias = initialBias, basic = input.lastIndexOf(delimiter);\n  if (basic < 0)\n    basic = 0;\n  for (let j = 0;j < basic; ++j) {\n    if (input.charCodeAt(j) >= 128)\n      error(\"not-basic\");\n    output.push(input.charCodeAt(j));\n  }\n  for (let index = basic > 0 \? basic + 1 : 0;index < inputLength; ) {\n    const oldi = i;\n    for (let w = 1, k = base;; k += base) {\n      if (index >= inputLength)\n        error(\"invalid-input\");\n      const digit = basicToDigit(input.charCodeAt(index++));\n      if (digit >= base)\n        error(\"invalid-input\");\n      if (digit > floor((maxInt - i) / w))\n        error(\"overflow\");\n      i += digit * w;\n      const t = k <= bias \? tMin : k >= bias + tMax \? tMax : k - bias;\n      if (digit < t)\n        break;\n      const baseMinusT = base - t;\n      if (w > floor(maxInt / baseMinusT))\n        error(\"overflow\");\n      w *= baseMinusT;\n    }\n    const out = output.length + 1;\n    if (bias = adapt(i - oldi, out, oldi == 0), floor(i / out) > maxInt - n)\n      error(\"overflow\");\n    n += floor(i / out), i %= out, output.splice(i++, 0, n);\n  }\n  return String.fromCodePoint(...output);\n}, encode = function(input) {\n  const output = [];\n  input = ucs2decode(input);\n  const inputLength = input.length;\n  let n = initialN, delta = 0, bias = initialBias;\n  for (let currentValue of input)\n    if (currentValue < 128)\n      output.push(stringFromCharCode(currentValue));\n  const basicLength = output.length;\n  let handledCPCount = basicLength;\n  if (basicLength)\n    output.push(delimiter);\n  while (handledCPCount < inputLength) {\n    let m = maxInt;\n    for (let currentValue of input)\n      if (currentValue >= n && currentValue < m)\n        m = currentValue;\n    const handledCPCountPlusOne = handledCPCount + 1;\n    if (m - n > floor((maxInt - delta) / handledCPCountPlusOne))\n      error(\"overflow\");\n    delta += (m - n) * handledCPCountPlusOne, n = m;\n    for (let currentValue of input) {\n      if (currentValue < n && ++delta > maxInt)\n        error(\"overflow\");\n      if (currentValue === n) {\n        let q = delta;\n        for (let k = base;; k += base) {\n          const t = k <= bias \? tMin : k >= bias + tMax \? tMax : k - bias;\n          if (q < t)\n            break;\n          const qMinusT = q - t, baseMinusT = base - t;\n          output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))), q = floor(qMinusT / baseMinusT);\n        }\n        output.push(stringFromCharCode(digitToBasic(q, 0))), bias = adapt(delta, handledCPCountPlusOne, handledCPCount === basicLength), delta = 0, ++handledCPCount;\n      }\n    }\n    ++delta, ++n;\n  }\n  return output.join(\"\");\n}, toUnicode = function(input) {\n  return mapDomain(input, function(string) {\n    return regexPunycode.test(string) \? decode(string.slice(4).toLowerCase()) : string;\n  });\n}, toASCII = function(input) {\n  return mapDomain(input, function(string) {\n    return regexNonASCII.test(string) \? \"xn--\" + encode(string) : string;\n  });\n};\n$ = {\n  version: \"2.1.0\",\n  ucs2: {\n    decode: ucs2decode,\n    encode: ucs2encode\n  },\n  decode,\n  encode,\n  toASCII,\n  toUnicode\n};\nreturn $})\n"_s;
//

//
static constexpr ASCIILiteral NodeQuerystringCode = "(function (){\"use strict\";// src/js/out/tmp/node/querystring.ts\nvar __commonJS = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports), Buffer = @requireNativeModule(\"node:buffer\").Buffer, require_object_keys = __commonJS((exports, module) => {\n  var objectKeys = Object.keys || function() {\n    var hasOwnProperty = Object.prototype.hasOwnProperty, hasDontEnumBug = !{ toString: null }.propertyIsEnumerable(\"toString\"), dontEnums = [\n      \"toString\",\n      \"toLocaleString\",\n      \"valueOf\",\n      \"hasOwnProperty\",\n      \"isPrototypeOf\",\n      \"propertyIsEnumerable\",\n      \"constructor\"\n    ], dontEnumsLength = dontEnums.length;\n    return function(obj) {\n      if (typeof obj !== \"function\" && (typeof obj !== \"object\" || obj === null))\n        @throwTypeError(\"Object.keys called on non-object\");\n      var result = [], prop, i;\n      for (prop in obj)\n        if (hasOwnProperty.call(obj, prop))\n          result.push(prop);\n      if (hasDontEnumBug) {\n        for (i = 0;i < dontEnumsLength; i++)\n          if (hasOwnProperty.call(obj, dontEnums[i]))\n            result.push(dontEnums[i]);\n      }\n      return result;\n    };\n  }();\n  module.exports = objectKeys;\n}), require_src = __commonJS((exports, module) => {\n  var ParsedQueryString = function() {\n  }, unescapeBuffer = function(s, decodeSpaces) {\n    var out = Buffer.allocUnsafe(s.length), state = 0, n, m, hexchar, c;\n    for (var inIndex = 0, outIndex = 0;; inIndex++) {\n      if (inIndex < s.length)\n        c = s.charCodeAt(inIndex);\n      else {\n        if (state > 0) {\n          if (out[outIndex++] = 37, state === 2)\n            out[outIndex++] = hexchar;\n        }\n        break;\n      }\n      switch (state) {\n        case 0:\n          switch (c) {\n            case 37:\n              n = 0, m = 0, state = 1;\n              break;\n            case 43:\n              if (decodeSpaces)\n                c = 32;\n            default:\n              out[outIndex++] = c;\n              break;\n          }\n          break;\n        case 1:\n          if (hexchar = c, n = unhexTable[c], !(n >= 0)) {\n            out[outIndex++] = 37, out[outIndex++] = c, state = 0;\n            break;\n          }\n          state = 2;\n          break;\n        case 2:\n          if (state = 0, m = unhexTable[c], !(m >= 0)) {\n            out[outIndex++] = 37, out[outIndex++] = hexchar, out[outIndex++] = c;\n            break;\n          }\n          out[outIndex++] = 16 * n + m;\n          break;\n      }\n    }\n    return out.slice(0, outIndex);\n  }, qsUnescape = function(s, decodeSpaces) {\n    try {\n      return decodeURIComponent(s);\n    } catch (e) {\n      return QueryString.unescapeBuffer(s, decodeSpaces).toString();\n    }\n  }, qsEscape = function(str) {\n    if (typeof str !== \"string\")\n      if (typeof str === \"object\")\n        str = String(str);\n      else\n        str += \"\";\n    var out = \"\", lastPos = 0;\n    for (var i2 = 0;i2 < str.length; ++i2) {\n      var c = str.charCodeAt(i2);\n      if (c < 128) {\n        if (noEscape[c] === 1)\n          continue;\n        if (lastPos < i2)\n          out += str.slice(lastPos, i2);\n        lastPos = i2 + 1, out += hexTable[c];\n        continue;\n      }\n      if (lastPos < i2)\n        out += str.slice(lastPos, i2);\n      if (c < 2048) {\n        lastPos = i2 + 1, out += hexTable[192 | c >> 6] + hexTable[128 | c & 63];\n        continue;\n      }\n      if (c < 55296 || c >= 57344) {\n        lastPos = i2 + 1, out += hexTable[224 | c >> 12] + hexTable[128 | c >> 6 & 63] + hexTable[128 | c & 63];\n        continue;\n      }\n      ++i2;\n      var c2;\n      if (i2 < str.length)\n        c2 = str.charCodeAt(i2) & 1023;\n      else\n        throw new URIError(\"URI malformed\");\n      lastPos = i2 + 1, c = 65536 + ((c & 1023) << 10 | c2), out += hexTable[240 | c >> 18] + hexTable[128 | c >> 12 & 63] + hexTable[128 | c >> 6 & 63] + hexTable[128 | c & 63];\n    }\n    if (lastPos === 0)\n      return str;\n    if (lastPos < str.length)\n      return out + str.slice(lastPos);\n    return out;\n  }, stringifyPrimitive = function(v) {\n    if (typeof v === \"string\")\n      return v;\n    if (typeof v === \"number\" && isFinite(v))\n      return \"\" + v;\n    if (typeof v === \"boolean\")\n      return v \? \"true\" : \"false\";\n    return \"\";\n  }, stringify = function(obj, sep, eq, options) {\n    sep = sep || \"&\", eq = eq || \"=\";\n    var encode = QueryString.escape;\n    if (options && typeof options.encodeURIComponent === \"function\")\n      encode = options.encodeURIComponent;\n    if (obj !== null && typeof obj === \"object\") {\n      var keys = objectKeys(obj), len = keys.length, flast = len - 1, fields = \"\";\n      for (var i2 = 0;i2 < len; ++i2) {\n        var k = keys[i2], v = obj[k], ks = encode(stringifyPrimitive(k)) + eq;\n        if (isArray(v)) {\n          var vlen = v.length, vlast = vlen - 1;\n          for (var j = 0;j < vlen; ++j)\n            if (fields += ks + encode(stringifyPrimitive(v[j])), j < vlast)\n              fields += sep;\n          if (vlen && i2 < flast)\n            fields += sep;\n        } else if (fields += ks + encode(stringifyPrimitive(v)), i2 < flast)\n          fields += sep;\n      }\n      return fields;\n    }\n    return \"\";\n  }, charCodes = function(str) {\n    if (str.length === 0)\n      return [];\n    if (str.length === 1)\n      return [str.charCodeAt(0)];\n    const ret = [];\n    for (var i2 = 0;i2 < str.length; ++i2)\n      ret[ret.length] = str.charCodeAt(i2);\n    return ret;\n  }, parse = function(qs, sep, eq, options) {\n    const obj = new ParsedQueryString;\n    if (typeof qs !== \"string\" || qs.length === 0)\n      return obj;\n    var sepCodes = !sep \? defSepCodes : charCodes(sep + \"\"), eqCodes = !eq \? defEqCodes : charCodes(eq + \"\");\n    const sepLen = sepCodes.length, eqLen = eqCodes.length;\n    var pairs = 1000;\n    if (options && typeof options.maxKeys === \"number\")\n      pairs = options.maxKeys > 0 \? options.maxKeys : -1;\n    var decode = QueryString.unescape;\n    if (options && typeof options.decodeURIComponent === \"function\")\n      decode = options.decodeURIComponent;\n    const customDecode = decode !== qsUnescape, keys = [];\n    var posIdx = 0, lastPos = 0, sepIdx = 0, eqIdx = 0, key = \"\", value = \"\", keyEncoded = customDecode, valEncoded = customDecode, encodeCheck = 0;\n    for (var i2 = 0;i2 < qs.length; ++i2) {\n      const code = qs.charCodeAt(i2);\n      if (code === sepCodes[sepIdx]) {\n        if (++sepIdx === sepLen) {\n          const end = i2 - sepIdx + 1;\n          if (eqIdx < eqLen) {\n            if (lastPos < end)\n              key += qs.slice(lastPos, end);\n          } else if (lastPos < end)\n            value += qs.slice(lastPos, end);\n          if (keyEncoded)\n            key = decodeStr(key, decode);\n          if (valEncoded)\n            value = decodeStr(value, decode);\n          if (key || value || lastPos - posIdx > sepLen || i2 === 0)\n            if (indexOf(keys, key) === -1)\n              obj[key] = value, keys[keys.length] = key;\n            else {\n              const curValue = obj[key] || \"\";\n              if (curValue.pop)\n                curValue[curValue.length] = value;\n              else if (curValue)\n                obj[key] = [curValue, value];\n            }\n          else if (i2 === 1)\n            delete obj[key];\n          if (--pairs === 0)\n            break;\n          keyEncoded = valEncoded = customDecode, encodeCheck = 0, key = value = \"\", posIdx = lastPos, lastPos = i2 + 1, sepIdx = eqIdx = 0;\n        }\n        continue;\n      } else if (sepIdx = 0, !valEncoded)\n        if (code === 37)\n          encodeCheck = 1;\n        else if (encodeCheck > 0 && (code >= 48 && code <= 57 || code >= 65 && code <= 70 || code >= 97 && code <= 102)) {\n          if (++encodeCheck === 3)\n            valEncoded = !0;\n        } else\n          encodeCheck = 0;\n      if (eqIdx < eqLen) {\n        if (code === eqCodes[eqIdx]) {\n          if (++eqIdx === eqLen) {\n            const end = i2 - eqIdx + 1;\n            if (lastPos < end)\n              key += qs.slice(lastPos, end);\n            encodeCheck = 0, lastPos = i2 + 1;\n          }\n          continue;\n        } else if (eqIdx = 0, !keyEncoded)\n          if (code === 37)\n            encodeCheck = 1;\n          else if (encodeCheck > 0 && (code >= 48 && code <= 57 || code >= 65 && code <= 70 || code >= 97 && code <= 102)) {\n            if (++encodeCheck === 3)\n              keyEncoded = !0;\n          } else\n            encodeCheck = 0;\n      }\n      if (code === 43) {\n        if (eqIdx < eqLen) {\n          if (lastPos < i2)\n            key += qs.slice(lastPos, i2);\n          key += \"%20\", keyEncoded = !0;\n        } else {\n          if (lastPos < i2)\n            value += qs.slice(lastPos, i2);\n          value += \"%20\", valEncoded = !0;\n        }\n        lastPos = i2 + 1;\n      }\n    }\n    if (pairs !== 0 && (lastPos < qs.length || eqIdx > 0)) {\n      if (lastPos < qs.length) {\n        if (eqIdx < eqLen)\n          key += qs.slice(lastPos);\n        else if (sepIdx < sepLen)\n          value += qs.slice(lastPos);\n      }\n      if (keyEncoded)\n        key = decodeStr(key, decode);\n      if (valEncoded)\n        value = decodeStr(value, decode);\n      if (indexOf(keys, key) === -1)\n        obj[key] = value, keys[keys.length] = key;\n      else {\n        const curValue = obj[key];\n        if (curValue.pop)\n          curValue[curValue.length] = value;\n        else\n          obj[key] = [curValue, value];\n      }\n    }\n    return obj;\n  }, decodeStr = function(s, decoder) {\n    try {\n      return decoder(s);\n    } catch (e) {\n      return QueryString.unescape(s, !0);\n    }\n  }, QueryString = module.exports = {\n    unescapeBuffer,\n    unescape: qsUnescape,\n    escape: qsEscape,\n    stringify,\n    encode: stringify,\n    parse,\n    decode: parse\n  }, objectKeys = require_object_keys(), isArray = (arg) => Object.prototype.toString.call(arg) === \"[object Array]\", indexOf = (arr, searchElement, fromIndex) => {\n    var k;\n    if (arr == null)\n      @throwTypeError('\"arr\" is null or not defined');\n    var o = Object(arr), len = o.length >>> 0;\n    if (len === 0)\n      return -1;\n    var n = fromIndex | 0;\n    if (n >= len)\n      return -1;\n    k = Math.max(n >= 0 \? n : len - Math.abs(n), 0);\n    while (k < len) {\n      if ((k in o) && o[k] === searchElement)\n        return k;\n      k++;\n    }\n    return -1;\n  };\n  ParsedQueryString.prototype = Object.create \? Object.create(null) : {};\n  var unhexTable = [\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    0,\n    1,\n    2,\n    3,\n    4,\n    5,\n    6,\n    7,\n    8,\n    9,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    10,\n    11,\n    12,\n    13,\n    14,\n    15,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    10,\n    11,\n    12,\n    13,\n    14,\n    15,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1\n  ], hexTable = [];\n  for (i = 0;i < 256; ++i)\n    hexTable[i] = \"%\" + ((i < 16 \? \"0\" : \"\") + i.toString(16)).toUpperCase();\n  var i, noEscape = [\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    1,\n    0,\n    0,\n    0,\n    0,\n    0,\n    1,\n    1,\n    1,\n    1,\n    0,\n    0,\n    1,\n    1,\n    0,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    0,\n    0,\n    0,\n    0,\n    1,\n    0,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    0,\n    0,\n    0,\n    1,\n    0\n  ], defSepCodes = [38], defEqCodes = [61];\n});\nreturn require_src()})\n"_s;
//

//
static constexpr ASCIILiteral NodeReadlineCode = "(function (){\"use strict\";// src/js/out/tmp/node/readline.ts\nvar stripVTControlCharacters = function(str) {\n  return validateString(str, \"str\"), RegExpPrototypeSymbolReplace.call(ansi, str, \"\");\n}, promisify = function(original) {\n  if (validateFunction(original, \"original\"), original[kCustomPromisifiedSymbol]) {\n    var fn = original[kCustomPromisifiedSymbol];\n    return validateFunction(fn, \"util.promisify.custom\"), ObjectDefineProperty(fn, kCustomPromisifiedSymbol, {\n      __proto__: null,\n      value: fn,\n      enumerable: !1,\n      writable: !1,\n      configurable: !0\n    });\n  }\n  var argumentNames = original[kCustomPromisifyArgsSymbol];\n  function fn(...args) {\n    return new Promise((resolve, reject) => {\n      ArrayPrototypePush.call(args, (err, ...values) => {\n        if (err)\n          return reject(err);\n        if (argumentNames !== void 0 && values.length > 1) {\n          var obj = {};\n          for (var i2 = 0;i2 < argumentNames.length; i2++)\n            obj[argumentNames[i2]] = values[i2];\n          resolve(obj);\n        } else\n          resolve(values[0]);\n      }), ReflectApply(original, this, args);\n    });\n  }\n  ObjectSetPrototypeOf(fn, ObjectGetPrototypeOf(original)), ObjectDefineProperty(fn, kCustomPromisifiedSymbol, {\n    __proto__: null,\n    value: fn,\n    enumerable: !1,\n    writable: !1,\n    configurable: !0\n  });\n  var descriptors = ObjectGetOwnPropertyDescriptors(original), propertiesValues = ObjectValues(descriptors);\n  for (var i = 0;i < propertiesValues.length; i++)\n    ObjectSetPrototypeOf(propertiesValues[i], null);\n  return ObjectDefineProperties(fn, descriptors);\n}, getNodeErrorByName = function(typeName) {\n  var base = errorBases[typeName];\n  if (base)\n    return base;\n  if (!ObjectKeys(VALID_NODE_ERROR_BASES).includes(typeName))\n    throw new Error(\"Invalid NodeError type\");\n  var Base = VALID_NODE_ERROR_BASES[typeName];\n\n  class NodeError extends Base {\n    [kIsNodeError] = !0;\n    code;\n    constructor(msg, opts) {\n      super(msg, opts);\n      this.code = opts\?.code || \"ERR_GENERIC\";\n    }\n    toString() {\n      return `${this.name} [${this.code}]: ${this.message}`;\n    }\n  }\n  return errorBases[typeName] = NodeError, NodeError;\n}, validateFunction = function(value, name) {\n  if (typeof value !== \"function\")\n    throw new ERR_INVALID_ARG_TYPE(name, \"Function\", value);\n}, validateAbortSignal = function(signal, name) {\n  if (signal !== void 0 && (signal === null || typeof signal !== \"object\" || !(\"aborted\" in signal)))\n    throw new ERR_INVALID_ARG_TYPE(name, \"AbortSignal\", signal);\n}, validateArray = function(value, name, minLength = 0) {\n  if (!ArrayIsArray(value))\n    throw new ERR_INVALID_ARG_TYPE(name, \"Array\", value);\n  if (value.length < minLength) {\n    var reason = `must be longer than ${minLength}`;\n    throw new ERR_INVALID_ARG_VALUE(name, value, reason);\n  }\n}, validateString = function(value, name) {\n  if (typeof value !== \"string\")\n    throw new ERR_INVALID_ARG_TYPE(name, \"string\", value);\n}, validateBoolean = function(value, name) {\n  if (typeof value !== \"boolean\")\n    throw new ERR_INVALID_ARG_TYPE(name, \"boolean\", value);\n};\nvar validateInteger = function(value, name, min = NumberMIN_SAFE_INTEGER, max = NumberMAX_SAFE_INTEGER) {\n  if (typeof value !== \"number\")\n    throw new ERR_INVALID_ARG_TYPE(name, \"number\", value);\n  if (!NumberIsInteger(value))\n    throw new ERR_OUT_OF_RANGE(name, \"an integer\", value);\n  if (value < min || value > max)\n    throw new ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value);\n}, validateUint32 = function(value, name, positive = !1) {\n  if (typeof value !== \"number\")\n    throw new ERR_INVALID_ARG_TYPE(name, \"number\", value);\n  if (!NumberIsInteger(value))\n    throw new ERR_OUT_OF_RANGE(name, \"an integer\", value);\n  var min = positive \? 1 : 0, max = 4294967295;\n  if (value < min || value > max)\n    throw new ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value);\n}, CSI = function(strings, ...args) {\n  var ret = `${kEscape}[`;\n  for (var n = 0;n < strings.length; n++)\n    if (ret += strings[n], n < args.length)\n      ret += args[n];\n  return ret;\n}, charLengthLeft = function(str, i) {\n  if (i <= 0)\n    return 0;\n  if (i > 1 && StringPrototypeCodePointAt.call(str, i - 2) >= kUTF16SurrogateThreshold || StringPrototypeCodePointAt.call(str, i - 1) >= kUTF16SurrogateThreshold)\n    return 2;\n  return 1;\n}, charLengthAt = function(str, i) {\n  if (str.length <= i)\n    return 1;\n  return StringPrototypeCodePointAt.call(str, i) >= kUTF16SurrogateThreshold \? 2 : 1;\n};\nfunction* emitKeys(stream) {\n  while (!0) {\n    var ch = yield, s = ch, escaped = !1, keySeq = null, keyName, keyCtrl2 = !1, keyMeta = !1, keyShift = !1;\n    if (ch === kEscape) {\n      if (escaped = !0, s += ch = yield, ch === kEscape)\n        s += ch = yield;\n    }\n    if (escaped && (ch === \"O\" || ch === \"[\")) {\n      var code = ch, modifier = 0;\n      if (ch === \"O\") {\n        if (s += ch = yield, ch >= \"0\" && ch <= \"9\")\n          modifier = (ch >> 0) - 1, s += ch = yield;\n        code += ch;\n      } else if (ch === \"[\") {\n        if (s += ch = yield, ch === \"[\")\n          code += ch, s += ch = yield;\n        var cmdStart = s.length - 1;\n        if (ch >= \"0\" && ch <= \"9\") {\n          if (s += ch = yield, ch >= \"0\" && ch <= \"9\")\n            s += ch = yield;\n        }\n        if (ch === \";\") {\n          if (s += ch = yield, ch >= \"0\" && ch <= \"9\")\n            s += yield;\n        }\n        var cmd = StringPrototypeSlice.call(s, cmdStart), match;\n        if (match = RegExpPrototypeExec.call(/^(\\d\\d\?)(;(\\d))\?([~^$])$/, cmd))\n          code += match[1] + match[4], modifier = (match[3] || 1) - 1;\n        else if (match = RegExpPrototypeExec.call(/^((\\d;)\?(\\d))\?([A-Za-z])$/, cmd))\n          code += match[4], modifier = (match[3] || 1) - 1;\n        else\n          code += cmd;\n      }\n      switch (keyCtrl2 = !!(modifier & 4), keyMeta = !!(modifier & 10), keyShift = !!(modifier & 1), code) {\n        case \"[P\":\n          keyName = \"f1\";\n          break;\n        case \"[Q\":\n          keyName = \"f2\";\n          break;\n        case \"[R\":\n          keyName = \"f3\";\n          break;\n        case \"[S\":\n          keyName = \"f4\";\n          break;\n        case \"OP\":\n          keyName = \"f1\";\n          break;\n        case \"OQ\":\n          keyName = \"f2\";\n          break;\n        case \"OR\":\n          keyName = \"f3\";\n          break;\n        case \"OS\":\n          keyName = \"f4\";\n          break;\n        case \"[11~\":\n          keyName = \"f1\";\n          break;\n        case \"[12~\":\n          keyName = \"f2\";\n          break;\n        case \"[13~\":\n          keyName = \"f3\";\n          break;\n        case \"[14~\":\n          keyName = \"f4\";\n          break;\n        case \"[[A\":\n          keyName = \"f1\";\n          break;\n        case \"[[B\":\n          keyName = \"f2\";\n          break;\n        case \"[[C\":\n          keyName = \"f3\";\n          break;\n        case \"[[D\":\n          keyName = \"f4\";\n          break;\n        case \"[[E\":\n          keyName = \"f5\";\n          break;\n        case \"[15~\":\n          keyName = \"f5\";\n          break;\n        case \"[17~\":\n          keyName = \"f6\";\n          break;\n        case \"[18~\":\n          keyName = \"f7\";\n          break;\n        case \"[19~\":\n          keyName = \"f8\";\n          break;\n        case \"[20~\":\n          keyName = \"f9\";\n          break;\n        case \"[21~\":\n          keyName = \"f10\";\n          break;\n        case \"[23~\":\n          keyName = \"f11\";\n          break;\n        case \"[24~\":\n          keyName = \"f12\";\n          break;\n        case \"[A\":\n          keyName = \"up\";\n          break;\n        case \"[B\":\n          keyName = \"down\";\n          break;\n        case \"[C\":\n          keyName = \"right\";\n          break;\n        case \"[D\":\n          keyName = \"left\";\n          break;\n        case \"[E\":\n          keyName = \"clear\";\n          break;\n        case \"[F\":\n          keyName = \"end\";\n          break;\n        case \"[H\":\n          keyName = \"home\";\n          break;\n        case \"OA\":\n          keyName = \"up\";\n          break;\n        case \"OB\":\n          keyName = \"down\";\n          break;\n        case \"OC\":\n          keyName = \"right\";\n          break;\n        case \"OD\":\n          keyName = \"left\";\n          break;\n        case \"OE\":\n          keyName = \"clear\";\n          break;\n        case \"OF\":\n          keyName = \"end\";\n          break;\n        case \"OH\":\n          keyName = \"home\";\n          break;\n        case \"[1~\":\n          keyName = \"home\";\n          break;\n        case \"[2~\":\n          keyName = \"insert\";\n          break;\n        case \"[3~\":\n          keyName = \"delete\";\n          break;\n        case \"[4~\":\n          keyName = \"end\";\n          break;\n        case \"[5~\":\n          keyName = \"pageup\";\n          break;\n        case \"[6~\":\n          keyName = \"pagedown\";\n          break;\n        case \"[[5~\":\n          keyName = \"pageup\";\n          break;\n        case \"[[6~\":\n          keyName = \"pagedown\";\n          break;\n        case \"[7~\":\n          keyName = \"home\";\n          break;\n        case \"[8~\":\n          keyName = \"end\";\n          break;\n        case \"[a\":\n          keyName = \"up\", keyShift = !0;\n          break;\n        case \"[b\":\n          keyName = \"down\", keyShift = !0;\n          break;\n        case \"[c\":\n          keyName = \"right\", keyShift = !0;\n          break;\n        case \"[d\":\n          keyName = \"left\", keyShift = !0;\n          break;\n        case \"[e\":\n          keyName = \"clear\", keyShift = !0;\n          break;\n        case \"[2$\":\n          keyName = \"insert\", keyShift = !0;\n          break;\n        case \"[3$\":\n          keyName = \"delete\", keyShift = !0;\n          break;\n        case \"[5$\":\n          keyName = \"pageup\", keyShift = !0;\n          break;\n        case \"[6$\":\n          keyName = \"pagedown\", keyShift = !0;\n          break;\n        case \"[7$\":\n          keyName = \"home\", keyShift = !0;\n          break;\n        case \"[8$\":\n          keyName = \"end\", keyShift = !0;\n          break;\n        case \"Oa\":\n          keyName = \"up\", keyCtrl2 = !0;\n          break;\n        case \"Ob\":\n          keyName = \"down\", keyCtrl2 = !0;\n          break;\n        case \"Oc\":\n          keyName = \"right\", keyCtrl2 = !0;\n          break;\n        case \"Od\":\n          keyName = \"left\", keyCtrl2 = !0;\n          break;\n        case \"Oe\":\n          keyName = \"clear\", keyCtrl2 = !0;\n          break;\n        case \"[2^\":\n          keyName = \"insert\", keyCtrl2 = !0;\n          break;\n        case \"[3^\":\n          keyName = \"delete\", keyCtrl2 = !0;\n          break;\n        case \"[5^\":\n          keyName = \"pageup\", keyCtrl2 = !0;\n          break;\n        case \"[6^\":\n          keyName = \"pagedown\", keyCtrl2 = !0;\n          break;\n        case \"[7^\":\n          keyName = \"home\", keyCtrl2 = !0;\n          break;\n        case \"[8^\":\n          keyName = \"end\", keyCtrl2 = !0;\n          break;\n        case \"[Z\":\n          keyName = \"tab\", keyShift = !0;\n          break;\n        default:\n          keyName = \"undefined\";\n          break;\n      }\n    } else if (ch === \"\\r\")\n      keyName = \"return\", keyMeta = escaped;\n    else if (ch === \"\\n\")\n      keyName = \"enter\", keyMeta = escaped;\n    else if (ch === \"\\t\")\n      keyName = \"tab\", keyMeta = escaped;\n    else if (ch === \"\\b\" || ch === \"\\x7F\")\n      keyName = \"backspace\", keyMeta = escaped;\n    else if (ch === kEscape)\n      keyName = \"escape\", keyMeta = escaped;\n    else if (ch === \" \")\n      keyName = \"space\", keyMeta = escaped;\n    else if (!escaped && ch <= \"\\x1A\")\n      keyName = StringFromCharCode(StringPrototypeCharCodeAt.call(ch) + StringPrototypeCharCodeAt.call(\"a\") - 1), keyCtrl2 = !0;\n    else if (RegExpPrototypeExec.call(/^[0-9A-Za-z]$/, ch) !== null)\n      keyName = StringPrototypeToLowerCase.call(ch), keyShift = RegExpPrototypeExec.call(/^[A-Z]$/, ch) !== null, keyMeta = escaped;\n    else if (escaped)\n      keyName = ch.length \? void 0 : \"escape\", keyMeta = !0;\n    if (keySeq = s, s.length !== 0 && (keyName !== void 0 || escaped))\n      stream.emit(\"keypress\", escaped \? void 0 : s, {\n        sequence: keySeq,\n        name: keyName,\n        ctrl: keyCtrl2,\n        meta: keyMeta,\n        shift: keyShift\n      });\n    else if (charLengthAt(s, 0) === s.length)\n      stream.emit(\"keypress\", s, {\n        sequence: keySeq,\n        name: keyName,\n        ctrl: keyCtrl2,\n        meta: keyMeta,\n        shift: keyShift\n      });\n  }\n}\nvar commonPrefix = function(strings) {\n  if (strings.length === 0)\n    return \"\";\n  if (strings.length === 1)\n    return strings[0];\n  var sorted = ArrayPrototypeSort.call(ArrayPrototypeSlice.call(strings)), min = sorted[0], max = sorted[sorted.length - 1];\n  for (var i = 0;i < min.length; i++)\n    if (min[i] !== max[i])\n      return StringPrototypeSlice.call(min, 0, i);\n  return min;\n}, cursorTo = function(stream, x, y, callback) {\n  if (callback !== void 0)\n    validateFunction(callback, \"callback\");\n  if (typeof y === \"function\")\n    callback = y, y = void 0;\n  if (NumberIsNaN(x))\n    throw new ERR_INVALID_ARG_VALUE(\"x\", x);\n  if (NumberIsNaN(y))\n    throw new ERR_INVALID_ARG_VALUE(\"y\", y);\n  if (stream == null || typeof x !== \"number\" && typeof y !== \"number\") {\n    if (typeof callback === \"function\")\n      process.nextTick(callback, null);\n    return !0;\n  }\n  if (typeof x !== \"number\")\n    throw new ERR_INVALID_CURSOR_POS;\n  var data = typeof y !== \"number\" \? CSI`${x + 1}G` : CSI`${y + 1};${x + 1}H`;\n  return stream.write(data, callback);\n}, moveCursor = function(stream, dx, dy, callback) {\n  if (callback !== void 0)\n    validateFunction(callback, \"callback\");\n  if (stream == null || !(dx || dy)) {\n    if (typeof callback === \"function\")\n      process.nextTick(callback, null);\n    return !0;\n  }\n  var data = \"\";\n  if (dx < 0)\n    data += CSI`${-dx}D`;\n  else if (dx > 0)\n    data += CSI`${dx}C`;\n  if (dy < 0)\n    data += CSI`${-dy}A`;\n  else if (dy > 0)\n    data += CSI`${dy}B`;\n  return stream.write(data, callback);\n}, clearLine = function(stream, dir, callback) {\n  if (callback !== void 0)\n    validateFunction(callback, \"callback\");\n  if (stream === null || stream === void 0) {\n    if (typeof callback === \"function\")\n      process.nextTick(callback, null);\n    return !0;\n  }\n  var type = dir < 0 \? kClearToLineBeginning : dir > 0 \? kClearToLineEnd : kClearLine;\n  return stream.write(type, callback);\n}, clearScreenDown = function(stream, callback) {\n  if (callback !== void 0)\n    validateFunction(callback, \"callback\");\n  if (stream === null || stream === void 0) {\n    if (typeof callback === \"function\")\n      process.nextTick(callback, null);\n    return !0;\n  }\n  return stream.write(kClearScreenDown, callback);\n}, emitKeypressEvents = function(stream, iface = {}) {\n  if (stream[KEYPRESS_DECODER])\n    return;\n  stream[KEYPRESS_DECODER] = new StringDecoder(\"utf8\"), stream[ESCAPE_DECODER] = emitKeys(stream), stream[ESCAPE_DECODER].next();\n  var triggerEscape = () => stream[ESCAPE_DECODER].next(\"\"), { escapeCodeTimeout = ESCAPE_CODE_TIMEOUT } = iface, timeoutId;\n  function onData(input) {\n    if (stream.listenerCount(\"keypress\") > 0) {\n      var string = stream[KEYPRESS_DECODER].write(input);\n      if (string) {\n        clearTimeout(timeoutId), iface[kSawKeyPress] = charLengthAt(string, 0) === string.length, iface.isCompletionEnabled = !1;\n        var length = 0;\n        for (var character of new SafeStringIterator(string)) {\n          if (length += character.length, length === string.length)\n            iface.isCompletionEnabled = !0;\n          try {\n            if (stream[ESCAPE_DECODER].next(character), length === string.length && character === kEscape)\n              timeoutId = setTimeout(triggerEscape, escapeCodeTimeout);\n          } catch (err) {\n            throw stream[ESCAPE_DECODER] = emitKeys(stream), stream[ESCAPE_DECODER].next(), err;\n          }\n        }\n      }\n    } else\n      stream.removeListener(\"data\", onData), stream.on(\"newListener\", onNewListener);\n  }\n  function onNewListener(event) {\n    if (event === \"keypress\")\n      stream.on(\"data\", onData), stream.removeListener(\"newListener\", onNewListener);\n  }\n  if (stream.listenerCount(\"keypress\") > 0)\n    stream.on(\"data\", onData);\n  else\n    stream.on(\"newListener\", onNewListener);\n}, onSelfCloseWithTerminal = function() {\n  var input = this.input, output = this.output;\n  if (!input)\n    throw new Error(\"Input not set, invalid state for readline!\");\n  if (input.removeListener(\"keypress\", this[kOnKeyPress]), input.removeListener(\"error\", this[kOnError]), input.removeListener(\"end\", this[kOnTermEnd]), output !== null && output !== void 0)\n    output.removeListener(\"resize\", this[kOnResize]);\n}, onSelfCloseWithoutTerminal = function() {\n  var input = this.input;\n  if (!input)\n    throw new Error(\"Input not set, invalid state for readline!\");\n  input.removeListener(\"data\", this[kOnData]), input.removeListener(\"error\", this[kOnError]), input.removeListener(\"end\", this[kOnEnd]);\n}, onError = function(err) {\n  this.emit(\"error\", err);\n}, onData = function(data) {\n  debug(\"onData\"), this[kNormalWrite](data);\n}, onEnd = function() {\n  if (debug(\"onEnd\"), typeof this[kLine_buffer] === \"string\" && this[kLine_buffer].length > 0)\n    this.emit(\"line\", this[kLine_buffer]);\n  this.close();\n}, onTermEnd = function() {\n  if (debug(\"onTermEnd\"), typeof this.line === \"string\" && this.line.length > 0)\n    this.emit(\"line\", this.line);\n  this.close();\n}, onKeyPress = function(s, key) {\n  if (this[kTtyWrite](s, key), key && key.sequence) {\n    var ch = StringPrototypeCodePointAt.call(key.sequence, 0);\n    if (ch >= 55296 && ch <= 57343)\n      this[kRefreshLine]();\n  }\n}, onResize = function() {\n  this[kRefreshLine]();\n}, InterfaceConstructor = function(input, output, completer, terminal) {\n  if (!(this instanceof InterfaceConstructor))\n    return new InterfaceConstructor(input, output, completer, terminal);\n  EventEmitter.call(this), this[kOnSelfCloseWithoutTerminal] = onSelfCloseWithoutTerminal.bind(this), this[kOnSelfCloseWithTerminal] = onSelfCloseWithTerminal.bind(this), this[kOnError] = onError.bind(this), this[kOnData] = onData.bind(this), this[kOnEnd] = onEnd.bind(this), this[kOnTermEnd] = onTermEnd.bind(this), this[kOnKeyPress] = onKeyPress.bind(this), this[kOnResize] = onResize.bind(this), this[kSawReturnAt] = 0, this.isCompletionEnabled = !0, this[kSawKeyPress] = !1, this[kPreviousKey] = null, this.escapeCodeTimeout = ESCAPE_CODE_TIMEOUT, this.tabSize = 8;\n  var history, historySize, removeHistoryDuplicates = !1, crlfDelay, prompt = \"> \", signal;\n  if (input\?.input) {\n    output = input.output, completer = input.completer, terminal = input.terminal, history = input.history, historySize = input.historySize, signal = input.signal;\n    var tabSize = input.tabSize;\n    if (tabSize !== void 0)\n      validateUint32(tabSize, \"tabSize\", !0), this.tabSize = tabSize;\n    removeHistoryDuplicates = input.removeHistoryDuplicates;\n    var inputPrompt = input.prompt;\n    if (inputPrompt !== void 0)\n      prompt = inputPrompt;\n    var inputEscapeCodeTimeout = input.escapeCodeTimeout;\n    if (inputEscapeCodeTimeout !== void 0)\n      if (NumberIsFinite(inputEscapeCodeTimeout))\n        this.escapeCodeTimeout = inputEscapeCodeTimeout;\n      else\n        throw new ERR_INVALID_ARG_VALUE(\"input.escapeCodeTimeout\", this.escapeCodeTimeout);\n    if (signal)\n      validateAbortSignal(signal, \"options.signal\");\n    crlfDelay = input.crlfDelay, input = input.input;\n  }\n  if (completer !== void 0 && typeof completer !== \"function\")\n    throw new ERR_INVALID_ARG_VALUE(\"completer\", completer);\n  if (history === void 0)\n    history = [];\n  else\n    validateArray(history, \"history\");\n  if (historySize === void 0)\n    historySize = kHistorySize;\n  if (typeof historySize !== \"number\" || NumberIsNaN(historySize) || historySize < 0)\n    throw new ERR_INVALID_ARG_VALUE(\"historySize\", historySize);\n  if (terminal === void 0 && !(output === null || output === void 0))\n    terminal = !!output.isTTY;\n  if (this.line = \"\", this[kSubstringSearch] = null, this.output = output, this.input = input, this[kUndoStack] = [], this[kRedoStack] = [], this.history = history, this.historySize = historySize, this[kKillRing] = [], this[kKillRingCursor] = 0, this.removeHistoryDuplicates = !!removeHistoryDuplicates, this.crlfDelay = crlfDelay \? MathMax(kMincrlfDelay, crlfDelay) : kMincrlfDelay, this.completer = completer, this.setPrompt(prompt), this.terminal = !!terminal, this[kLineObjectStream] = void 0, input.on(\"error\", this[kOnError]), !this.terminal)\n    input.on(\"data\", this[kOnData]), input.on(\"end\", this[kOnEnd]), this.once(\"close\", this[kOnSelfCloseWithoutTerminal]), this[kDecoder] = new StringDecoder(\"utf8\");\n  else {\n    if (emitKeypressEvents(input, this), input.on(\"keypress\", this[kOnKeyPress]), input.on(\"end\", this[kOnTermEnd]), this[kSetRawMode](!0), this.terminal = !0, this.cursor = 0, this.historyIndex = -1, output !== null && output !== void 0)\n      output.on(\"resize\", this[kOnResize]);\n    this.once(\"close\", this[kOnSelfCloseWithTerminal]);\n  }\n  if (signal) {\n    var onAborted = (() => this.close()).bind(this);\n    if (signal.aborted)\n      process.nextTick(onAborted);\n    else\n      signal.addEventListener(\"abort\", onAborted, { once: !0 }), this.once(\"close\", () => signal.removeEventListener(\"abort\", onAborted));\n  }\n  this.line = \"\", input.resume();\n}, Interface = function(input, output, completer, terminal) {\n  if (!(this instanceof Interface))\n    return new Interface(input, output, completer, terminal);\n  if (input\?.input && typeof input.completer === \"function\" && input.completer.length !== 2) {\n    var { completer } = input;\n    input.completer = (v, cb) => cb(null, completer(v));\n  } else if (typeof completer === \"function\" && completer.length !== 2) {\n    var realCompleter = completer;\n    completer = (v, cb) => cb(null, realCompleter(v));\n  }\n  InterfaceConstructor.call(this, input, output, completer, terminal);\n}, createInterface = function(input, output, completer, terminal) {\n  return new Interface(input, output, completer, terminal);\n};\nvar $, EventEmitter = @getInternalField(@internalModuleRegistry, 16) || @createInternalModuleById(16), { StringDecoder } = @requireNativeModule(\"node:string_decoder\"), isWritable, { inspect } = Bun, debug = process.env.BUN_JS_DEBUG \? console.log : () => {\n}, SymbolAsyncIterator = Symbol.asyncIterator, SymbolIterator = Symbol.iterator, SymbolFor = Symbol.for, SymbolReplace = Symbol.replace, ArrayFrom = Array.from, ArrayIsArray = Array.isArray, ArrayPrototypeFilter = Array.prototype.filter, ArrayPrototypeSort = Array.prototype.sort, ArrayPrototypeIndexOf = Array.prototype.indexOf, ArrayPrototypeJoin = Array.prototype.join, ArrayPrototypeMap = Array.prototype.map, ArrayPrototypePop = Array.prototype.pop, ArrayPrototypePush = Array.prototype.push, ArrayPrototypeSlice = Array.prototype.slice, ArrayPrototypeSplice = Array.prototype.splice, ArrayPrototypeReverse = Array.prototype.reverse, ArrayPrototypeShift = Array.prototype.shift, ArrayPrototypeUnshift = Array.prototype.unshift, RegExpPrototypeExec = RegExp.prototype.exec, RegExpPrototypeSymbolReplace = RegExp.prototype[SymbolReplace], StringFromCharCode = String.fromCharCode, StringPrototypeCharCodeAt = String.prototype.charCodeAt, StringPrototypeCodePointAt = String.prototype.codePointAt, StringPrototypeSlice = String.prototype.slice, StringPrototypeToLowerCase = String.prototype.toLowerCase, StringPrototypeEndsWith = String.prototype.endsWith, StringPrototypeRepeat = String.prototype.repeat, StringPrototypeStartsWith = String.prototype.startsWith, StringPrototypeTrim = String.prototype.trim, StringPrototypeNormalize = String.prototype.normalize, NumberIsNaN = Number.isNaN, NumberIsFinite = Number.isFinite, NumberIsInteger = Number.isInteger, NumberMAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER, NumberMIN_SAFE_INTEGER = Number.MIN_SAFE_INTEGER, MathCeil = Math.ceil, MathFloor = Math.floor, MathMax = Math.max, MathMaxApply = Math.max.apply, DateNow = Date.now, FunctionPrototype = Function.prototype, StringPrototype = String.prototype, StringPrototypeSymbolIterator = StringPrototype[SymbolIterator], StringIteratorPrototypeNext = StringPrototypeSymbolIterator.call(\"\").next, ObjectSetPrototypeOf = Object.setPrototypeOf, ObjectDefineProperty = Object.defineProperty, ObjectDefineProperties = Object.defineProperties, ObjectFreeze = Object.freeze;\nvar { create: ObjectCreate, keys: ObjectKeys } = Object;\nvar createSafeIterator = (factory, next) => {\n  class SafeIterator {\n    #iterator;\n    constructor(iterable) {\n      this.#iterator = factory.call(iterable);\n    }\n    next() {\n      return next.call(this.#iterator);\n    }\n    [SymbolIterator]() {\n      return this;\n    }\n  }\n  return ObjectSetPrototypeOf(SafeIterator.prototype, null), ObjectFreeze(SafeIterator.prototype), ObjectFreeze(SafeIterator), SafeIterator;\n}, SafeStringIterator = createSafeIterator(StringPrototypeSymbolIterator, StringIteratorPrototypeNext), isFullWidthCodePoint = (code) => {\n  return code >= 4352 && (code <= 4447 || code === 9001 || code === 9002 || code >= 11904 && code <= 12871 && code !== 12351 || code >= 12880 && code <= 19903 || code >= 19968 && code <= 42182 || code >= 43360 && code <= 43388 || code >= 44032 && code <= 55203 || code >= 63744 && code <= 64255 || code >= 65040 && code <= 65049 || code >= 65072 && code <= 65131 || code >= 65281 && code <= 65376 || code >= 65504 && code <= 65510 || code >= 110592 && code <= 110593 || code >= 127488 && code <= 127569 || code >= 127744 && code <= 128591 || code >= 131072 && code <= 262141);\n}, isZeroWidthCodePoint = (code) => {\n  return code <= 31 || code >= 127 && code <= 159 || code >= 768 && code <= 879 || code >= 8203 && code <= 8207 || code >= 8400 && code <= 8447 || code >= 65024 && code <= 65039 || code >= 65056 && code <= 65071 || code >= 917760 && code <= 917999;\n}, getStringWidth = function getStringWidth2(str, removeControlChars = !0) {\n  var width = 0;\n  if (removeControlChars)\n    str = stripVTControlCharacters(str);\n  str = StringPrototypeNormalize.call(str, \"NFC\");\n  for (var char of new SafeStringIterator(str)) {\n    var code = StringPrototypeCodePointAt.call(char, 0);\n    if (isFullWidthCodePoint(code))\n      width += 2;\n    else if (!isZeroWidthCodePoint(code))\n      width++;\n  }\n  return width;\n}, ansiPattern = \"[\\\\u001B\\\\u009B][[\\\\]()#;\?]*(\?:(\?:(\?:(\?:;[-a-zA-Z\\\\d\\\\/#&.:=\?%@~_]+)*|[a-zA-Z\\\\d]+(\?:;[-a-zA-Z\\\\d\\\\/#&.:=\?%@~_]*)*)\?\\\\u0007)|(\?:(\?:\\\\d{1,4}(\?:;\\\\d{0,4})*)\?[\\\\dA-PR-TZcf-ntqry=><~]))\", ansi = new RegExp(ansiPattern, \"g\"), kCustomPromisifiedSymbol = SymbolFor(\"nodejs.util.promisify.custom\"), kCustomPromisifyArgsSymbol = Symbol(\"customPromisifyArgs\");\npromisify.custom = kCustomPromisifiedSymbol;\nvar kUTF16SurrogateThreshold = 65536, kEscape = \"\\x1B\", kSubstringSearch = Symbol(\"kSubstringSearch\"), kIsNodeError = Symbol(\"kIsNodeError\"), errorBases = {}, VALID_NODE_ERROR_BASES = {\n  TypeError,\n  RangeError,\n  Error\n}, NodeError = getNodeErrorByName(\"Error\"), NodeTypeError = getNodeErrorByName(\"TypeError\"), NodeRangeError = getNodeErrorByName(\"RangeError\");\n\nclass ERR_INVALID_ARG_TYPE extends NodeTypeError {\n  constructor(name, type, value) {\n    super(`The \"${name}\" argument must be of type ${type}. Received type ${typeof value}`, {\n      code: \"ERR_INVALID_ARG_TYPE\"\n    });\n  }\n}\n\nclass ERR_INVALID_ARG_VALUE extends NodeTypeError {\n  constructor(name, value, reason = \"not specified\") {\n    super(`The value \"${String(value)}\" is invalid for argument '${name}'. Reason: ${reason}`, {\n      code: \"ERR_INVALID_ARG_VALUE\"\n    });\n  }\n}\n\nclass ERR_INVALID_CURSOR_POS extends NodeTypeError {\n  constructor() {\n    super(\"Cannot set cursor row without setting its column\", {\n      code: \"ERR_INVALID_CURSOR_POS\"\n    });\n  }\n}\n\nclass ERR_OUT_OF_RANGE extends NodeRangeError {\n  constructor(name, range, received) {\n    super(`The value of \"${name}\" is out of range. It must be ${range}. Received ${received}`, {\n      code: \"ERR_OUT_OF_RANGE\"\n    });\n  }\n}\n\nclass ERR_USE_AFTER_CLOSE extends NodeError {\n  constructor() {\n    super(\"This socket has been ended by the other party\", {\n      code: \"ERR_USE_AFTER_CLOSE\"\n    });\n  }\n}\n\nclass AbortError extends Error {\n  code;\n  constructor() {\n    super(\"The operation was aborted\");\n    this.code = \"ABORT_ERR\";\n  }\n}\nvar kClearLine, kClearScreenDown, kClearToLineBeginning, kClearToLineEnd;\nCSI.kEscape = kEscape;\nCSI.kClearLine = kClearLine = CSI`2K`;\nCSI.kClearScreenDown = kClearScreenDown = CSI`0J`;\nCSI.kClearToLineBeginning = kClearToLineBeginning = CSI`1K`;\nCSI.kClearToLineEnd = kClearToLineEnd = CSI`0K`;\nvar KEYPRESS_DECODER = Symbol(\"keypress-decoder\"), ESCAPE_DECODER = Symbol(\"escape-decoder\"), ESCAPE_CODE_TIMEOUT = 500, kEmptyObject = ObjectFreeze(ObjectCreate(null)), kHistorySize = 30, kMaxUndoRedoStackSize = 2048, kMincrlfDelay = 100, lineEnding = /\\r\?\\n|\\r(\?!\\n)/g, kMaxLengthOfKillRing = 32, kLineObjectStream = Symbol(\"line object stream\"), kQuestionCancel = Symbol(\"kQuestionCancel\"), kQuestion = Symbol(\"kQuestion\"), kAddHistory = Symbol(\"_addHistory\"), kBeforeEdit = Symbol(\"_beforeEdit\"), kDecoder = Symbol(\"_decoder\"), kDeleteLeft = Symbol(\"_deleteLeft\"), kDeleteLineLeft = Symbol(\"_deleteLineLeft\"), kDeleteLineRight = Symbol(\"_deleteLineRight\"), kDeleteRight = Symbol(\"_deleteRight\"), kDeleteWordLeft = Symbol(\"_deleteWordLeft\"), kDeleteWordRight = Symbol(\"_deleteWordRight\"), kGetDisplayPos = Symbol(\"_getDisplayPos\"), kHistoryNext = Symbol(\"_historyNext\"), kHistoryPrev = Symbol(\"_historyPrev\"), kInsertString = Symbol(\"_insertString\"), kLine = Symbol(\"_line\"), kLine_buffer = Symbol(\"_line_buffer\"), kKillRing = Symbol(\"_killRing\"), kKillRingCursor = Symbol(\"_killRingCursor\"), kMoveCursor = Symbol(\"_moveCursor\"), kNormalWrite = Symbol(\"_normalWrite\"), kOldPrompt = Symbol(\"_oldPrompt\"), kOnLine = Symbol(\"_onLine\"), kPreviousKey = Symbol(\"_previousKey\"), kPrompt = Symbol(\"_prompt\"), kPushToKillRing = Symbol(\"_pushToKillRing\"), kPushToUndoStack = Symbol(\"_pushToUndoStack\"), kQuestionCallback = Symbol(\"_questionCallback\"), kRedo = Symbol(\"_redo\"), kRedoStack = Symbol(\"_redoStack\"), kRefreshLine = Symbol(\"_refreshLine\"), kSawKeyPress = Symbol(\"_sawKeyPress\"), kSawReturnAt = Symbol(\"_sawReturnAt\"), kSetRawMode = Symbol(\"_setRawMode\"), kTabComplete = Symbol(\"_tabComplete\"), kTabCompleter = Symbol(\"_tabCompleter\"), kTtyWrite = Symbol(\"_ttyWrite\"), kUndo = Symbol(\"_undo\"), kUndoStack = Symbol(\"_undoStack\"), kWordLeft = Symbol(\"_wordLeft\"), kWordRight = Symbol(\"_wordRight\"), kWriteToOutput = Symbol(\"_writeToOutput\"), kYank = Symbol(\"_yank\"), kYanking = Symbol(\"_yanking\"), kYankPop = Symbol(\"_yankPop\"), kFirstEventParam = Symbol(\"nodejs.kFirstEventParam\"), kOnSelfCloseWithTerminal = Symbol(\"_onSelfCloseWithTerminal\"), kOnSelfCloseWithoutTerminal = Symbol(\"_onSelfCloseWithoutTerminal\"), kOnKeyPress = Symbol(\"_onKeyPress\"), kOnError = Symbol(\"_onError\"), kOnData = Symbol(\"_onData\"), kOnEnd = Symbol(\"_onEnd\"), kOnTermEnd = Symbol(\"_onTermEnd\"), kOnResize = Symbol(\"_onResize\");\nInterfaceConstructor.prototype = {};\nObjectSetPrototypeOf(InterfaceConstructor.prototype, EventEmitter.prototype);\nvar _Interface = class Interface2 extends InterfaceConstructor {\n  constructor(input, output, completer, terminal) {\n    super(input, output, completer, terminal);\n  }\n  get columns() {\n    var output = this.output;\n    if (output && output.columns)\n      return output.columns;\n    return Infinity;\n  }\n  setPrompt(prompt) {\n    this[kPrompt] = prompt;\n  }\n  getPrompt() {\n    return this[kPrompt];\n  }\n  [kSetRawMode](mode) {\n    var input = this.input, { setRawMode, wasInRawMode } = input;\n    return debug(\"setRawMode\", mode, \"set!\"), wasInRawMode;\n  }\n  prompt(preserveCursor) {\n    if (this.paused)\n      this.resume();\n    if (this.terminal) {\n      if (!preserveCursor)\n        this.cursor = 0;\n      this[kRefreshLine]();\n    } else\n      this[kWriteToOutput](this[kPrompt]);\n  }\n  [kQuestion](query, cb) {\n    if (this.closed)\n      throw new ERR_USE_AFTER_CLOSE(\"readline\");\n    if (this[kQuestionCallback])\n      this.prompt();\n    else\n      this[kOldPrompt] = this[kPrompt], this.setPrompt(query), this[kQuestionCallback] = cb, this.prompt();\n  }\n  [kOnLine](line) {\n    if (this[kQuestionCallback]) {\n      var cb = this[kQuestionCallback];\n      this[kQuestionCallback] = null, this.setPrompt(this[kOldPrompt]), cb(line);\n    } else\n      this.emit(\"line\", line);\n  }\n  [kBeforeEdit](oldText, oldCursor) {\n    this[kPushToUndoStack](oldText, oldCursor);\n  }\n  [kQuestionCancel]() {\n    if (this[kQuestionCallback])\n      this[kQuestionCallback] = null, this.setPrompt(this[kOldPrompt]), this.clearLine();\n  }\n  [kWriteToOutput](stringToWrite) {\n    if (validateString(stringToWrite, \"stringToWrite\"), this.output !== null && this.output !== void 0)\n      this.output.write(stringToWrite);\n  }\n  [kAddHistory]() {\n    if (this.line.length === 0)\n      return \"\";\n    if (this.historySize === 0)\n      return this.line;\n    if (StringPrototypeTrim.call(this.line).length === 0)\n      return this.line;\n    if (this.history.length === 0 || this.history[0] !== this.line) {\n      if (this.removeHistoryDuplicates) {\n        var dupIndex = ArrayPrototypeIndexOf.call(this.history, this.line);\n        if (dupIndex !== -1)\n          ArrayPrototypeSplice.call(this.history, dupIndex, 1);\n      }\n      if (ArrayPrototypeUnshift.call(this.history, this.line), this.history.length > this.historySize)\n        ArrayPrototypePop.call(this.history);\n    }\n    this.historyIndex = -1;\n    var line = this.history[0];\n    return this.emit(\"history\", this.history), line;\n  }\n  [kRefreshLine]() {\n    var line = this[kPrompt] + this.line, dispPos = this[kGetDisplayPos](line), lineCols = dispPos.cols, lineRows = dispPos.rows, cursorPos = this.getCursorPos(), prevRows = this.prevRows || 0;\n    if (prevRows > 0)\n      moveCursor(this.output, 0, -prevRows);\n    if (cursorTo(this.output, 0), clearScreenDown(this.output), this[kWriteToOutput](line), lineCols === 0)\n      this[kWriteToOutput](\" \");\n    cursorTo(this.output, cursorPos.cols);\n    var diff = lineRows - cursorPos.rows;\n    if (diff > 0)\n      moveCursor(this.output, 0, -diff);\n    this.prevRows = cursorPos.rows;\n  }\n  close() {\n    if (this.closed)\n      return;\n    if (this.pause(), this.terminal)\n      this[kSetRawMode](!1);\n    this.closed = !0, this.emit(\"close\");\n  }\n  pause() {\n    if (this.paused)\n      return;\n    return this.input.pause(), this.paused = !0, this.emit(\"pause\"), this;\n  }\n  resume() {\n    if (!this.paused)\n      return;\n    return this.input.resume(), this.paused = !1, this.emit(\"resume\"), this;\n  }\n  write(d, key) {\n    if (this.paused)\n      this.resume();\n    if (this.terminal)\n      this[kTtyWrite](d, key);\n    else\n      this[kNormalWrite](d);\n  }\n  [kNormalWrite](b) {\n    if (b === void 0)\n      return;\n    var string = this[kDecoder].write(b);\n    if (this[kSawReturnAt] && DateNow() - this[kSawReturnAt] <= this.crlfDelay) {\n      if (StringPrototypeCodePointAt.call(string) === 10)\n        string = StringPrototypeSlice.call(string, 1);\n      this[kSawReturnAt] = 0;\n    }\n    var newPartContainsEnding = RegExpPrototypeExec.call(lineEnding, string);\n    if (newPartContainsEnding !== null) {\n      if (this[kLine_buffer])\n        string = this[kLine_buffer] + string, this[kLine_buffer] = null, newPartContainsEnding = RegExpPrototypeExec.call(lineEnding, string);\n      this[kSawReturnAt] = StringPrototypeEndsWith.call(string, \"\\r\") \? DateNow() : 0;\n      var indexes = [0, newPartContainsEnding.index, lineEnding.lastIndex], nextMatch;\n      while ((nextMatch = RegExpPrototypeExec.call(lineEnding, string)) !== null)\n        ArrayPrototypePush.call(indexes, nextMatch.index, lineEnding.lastIndex);\n      var lastIndex = indexes.length - 1;\n      this[kLine_buffer] = StringPrototypeSlice.call(string, indexes[lastIndex]);\n      for (var i = 1;i < lastIndex; i += 2)\n        this[kOnLine](StringPrototypeSlice.call(string, indexes[i - 1], indexes[i]));\n    } else if (string)\n      if (this[kLine_buffer])\n        this[kLine_buffer] += string;\n      else\n        this[kLine_buffer] = string;\n  }\n  [kInsertString](c) {\n    if (this[kBeforeEdit](this.line, this.cursor), this.cursor < this.line.length) {\n      var beg = StringPrototypeSlice.call(this.line, 0, this.cursor), end = StringPrototypeSlice.call(this.line, this.cursor, this.line.length);\n      this.line = beg + c + end, this.cursor += c.length, this[kRefreshLine]();\n    } else {\n      var oldPos = this.getCursorPos();\n      this.line += c, this.cursor += c.length;\n      var newPos = this.getCursorPos();\n      if (oldPos.rows < newPos.rows)\n        this[kRefreshLine]();\n      else\n        this[kWriteToOutput](c);\n    }\n  }\n  async[kTabComplete](lastKeypressWasTab) {\n    this.pause();\n    var string = StringPrototypeSlice.call(this.line, 0, this.cursor), value;\n    try {\n      value = await this.completer(string);\n    } catch (err) {\n      this[kWriteToOutput](`Tab completion error: ${inspect(err)}`);\n      return;\n    } finally {\n      this.resume();\n    }\n    this[kTabCompleter](lastKeypressWasTab, value);\n  }\n  [kTabCompleter](lastKeypressWasTab, { 0: completions, 1: completeOn }) {\n    if (!completions || completions.length === 0)\n      return;\n    var prefix = commonPrefix(ArrayPrototypeFilter.call(completions, (e) => e !== \"\"));\n    if (StringPrototypeStartsWith.call(prefix, completeOn) && prefix.length > completeOn.length) {\n      this[kInsertString](StringPrototypeSlice.call(prefix, completeOn.length));\n      return;\n    } else if (!StringPrototypeStartsWith.call(completeOn, prefix)) {\n      this.line = StringPrototypeSlice.call(this.line, 0, this.cursor - completeOn.length) + prefix + StringPrototypeSlice.call(this.line, this.cursor, this.line.length), this.cursor = this.cursor - completeOn.length + prefix.length, this._refreshLine();\n      return;\n    }\n    if (!lastKeypressWasTab)\n      return;\n    this[kBeforeEdit](this.line, this.cursor);\n    var completionsWidth = ArrayPrototypeMap.call(completions, (e) => getStringWidth(e)), width = MathMaxApply(completionsWidth) + 2, maxColumns = MathFloor(this.columns / width) || 1;\n    if (maxColumns === Infinity)\n      maxColumns = 1;\n    var output = \"\\r\\n\", lineIndex = 0, whitespace = 0;\n    for (var i = 0;i < completions.length; i++) {\n      var completion = completions[i];\n      if (completion === \"\" || lineIndex === maxColumns)\n        output += \"\\r\\n\", lineIndex = 0, whitespace = 0;\n      else\n        output += StringPrototypeRepeat.call(\" \", whitespace);\n      if (completion !== \"\")\n        output += completion, whitespace = width - completionsWidth[i], lineIndex++;\n      else\n        output += \"\\r\\n\";\n    }\n    if (lineIndex !== 0)\n      output += \"\\r\\n\\r\\n\";\n    this[kWriteToOutput](output), this[kRefreshLine]();\n  }\n  [kWordLeft]() {\n    if (this.cursor > 0) {\n      var leading = StringPrototypeSlice.call(this.line, 0, this.cursor), reversed = ArrayPrototypeJoin.call(ArrayPrototypeReverse.call(ArrayFrom(leading)), \"\"), match = RegExpPrototypeExec.call(/^\\s*(\?:[^\\w\\s]+|\\w+)\?/, reversed);\n      this[kMoveCursor](-match[0].length);\n    }\n  }\n  [kWordRight]() {\n    if (this.cursor < this.line.length) {\n      var trailing = StringPrototypeSlice.call(this.line, this.cursor), match = RegExpPrototypeExec.call(/^(\?:\\s+|[^\\w\\s]+|\\w+)\\s*/, trailing);\n      this[kMoveCursor](match[0].length);\n    }\n  }\n  [kDeleteLeft]() {\n    if (this.cursor > 0 && this.line.length > 0) {\n      this[kBeforeEdit](this.line, this.cursor);\n      var charSize = charLengthLeft(this.line, this.cursor);\n      this.line = StringPrototypeSlice.call(this.line, 0, this.cursor - charSize) + StringPrototypeSlice.call(this.line, this.cursor, this.line.length), this.cursor -= charSize, this[kRefreshLine]();\n    }\n  }\n  [kDeleteRight]() {\n    if (this.cursor < this.line.length) {\n      this[kBeforeEdit](this.line, this.cursor);\n      var charSize = charLengthAt(this.line, this.cursor);\n      this.line = StringPrototypeSlice.call(this.line, 0, this.cursor) + StringPrototypeSlice.call(this.line, this.cursor + charSize, this.line.length), this[kRefreshLine]();\n    }\n  }\n  [kDeleteWordLeft]() {\n    if (this.cursor > 0) {\n      this[kBeforeEdit](this.line, this.cursor);\n      var leading = StringPrototypeSlice.call(this.line, 0, this.cursor), reversed = ArrayPrototypeJoin.call(ArrayPrototypeReverse.call(ArrayFrom(leading)), \"\"), match = RegExpPrototypeExec.call(/^\\s*(\?:[^\\w\\s]+|\\w+)\?/, reversed);\n      leading = StringPrototypeSlice.call(leading, 0, leading.length - match[0].length), this.line = leading + StringPrototypeSlice.call(this.line, this.cursor, this.line.length), this.cursor = leading.length, this[kRefreshLine]();\n    }\n  }\n  [kDeleteWordRight]() {\n    if (this.cursor < this.line.length) {\n      this[kBeforeEdit](this.line, this.cursor);\n      var trailing = StringPrototypeSlice.call(this.line, this.cursor), match = RegExpPrototypeExec.call(/^(\?:\\s+|\\W+|\\w+)\\s*/, trailing);\n      this.line = StringPrototypeSlice.call(this.line, 0, this.cursor) + StringPrototypeSlice.call(trailing, match[0].length), this[kRefreshLine]();\n    }\n  }\n  [kDeleteLineLeft]() {\n    this[kBeforeEdit](this.line, this.cursor);\n    var del = StringPrototypeSlice.call(this.line, 0, this.cursor);\n    this.line = StringPrototypeSlice.call(this.line, this.cursor), this.cursor = 0, this[kPushToKillRing](del), this[kRefreshLine]();\n  }\n  [kDeleteLineRight]() {\n    this[kBeforeEdit](this.line, this.cursor);\n    var del = StringPrototypeSlice.call(this.line, this.cursor);\n    this.line = StringPrototypeSlice.call(this.line, 0, this.cursor), this[kPushToKillRing](del), this[kRefreshLine]();\n  }\n  [kPushToKillRing](del) {\n    if (!del || del === this[kKillRing][0])\n      return;\n    ArrayPrototypeUnshift.call(this[kKillRing], del), this[kKillRingCursor] = 0;\n    while (this[kKillRing].length > kMaxLengthOfKillRing)\n      ArrayPrototypePop.call(this[kKillRing]);\n  }\n  [kYank]() {\n    if (this[kKillRing].length > 0)\n      this[kYanking] = !0, this[kInsertString](this[kKillRing][this[kKillRingCursor]]);\n  }\n  [kYankPop]() {\n    if (!this[kYanking])\n      return;\n    if (this[kKillRing].length > 1) {\n      var lastYank = this[kKillRing][this[kKillRingCursor]];\n      if (this[kKillRingCursor]++, this[kKillRingCursor] >= this[kKillRing].length)\n        this[kKillRingCursor] = 0;\n      var currentYank = this[kKillRing][this[kKillRingCursor]], head = StringPrototypeSlice.call(this.line, 0, this.cursor - lastYank.length), tail = StringPrototypeSlice.call(this.line, this.cursor);\n      this.line = head + currentYank + tail, this.cursor = head.length + currentYank.length, this[kRefreshLine]();\n    }\n  }\n  clearLine() {\n    this[kMoveCursor](Infinity), this[kWriteToOutput](\"\\r\\n\"), this.line = \"\", this.cursor = 0, this.prevRows = 0;\n  }\n  [kLine]() {\n    var line = this[kAddHistory]();\n    this[kUndoStack] = [], this[kRedoStack] = [], this.clearLine(), this[kOnLine](line);\n  }\n  [kPushToUndoStack](text, cursor) {\n    if (ArrayPrototypePush.call(this[kUndoStack], { text, cursor }) > kMaxUndoRedoStackSize)\n      ArrayPrototypeShift.call(this[kUndoStack]);\n  }\n  [kUndo]() {\n    if (this[kUndoStack].length <= 0)\n      return;\n    ArrayPrototypePush.call(this[kRedoStack], {\n      text: this.line,\n      cursor: this.cursor\n    });\n    var entry = ArrayPrototypePop.call(this[kUndoStack]);\n    this.line = entry.text, this.cursor = entry.cursor, this[kRefreshLine]();\n  }\n  [kRedo]() {\n    if (this[kRedoStack].length <= 0)\n      return;\n    ArrayPrototypePush.call(this[kUndoStack], {\n      text: this.line,\n      cursor: this.cursor\n    });\n    var entry = ArrayPrototypePop.call(this[kRedoStack]);\n    this.line = entry.text, this.cursor = entry.cursor, this[kRefreshLine]();\n  }\n  [kHistoryNext]() {\n    if (this.historyIndex >= 0) {\n      this[kBeforeEdit](this.line, this.cursor);\n      var search = this[kSubstringSearch] || \"\", index = this.historyIndex - 1;\n      while (index >= 0 && (!StringPrototypeStartsWith.call(this.history[index], search) || this.line === this.history[index]))\n        index--;\n      if (index === -1)\n        this.line = search;\n      else\n        this.line = this.history[index];\n      this.historyIndex = index, this.cursor = this.line.length, this[kRefreshLine]();\n    }\n  }\n  [kHistoryPrev]() {\n    if (this.historyIndex < this.history.length && this.history.length) {\n      this[kBeforeEdit](this.line, this.cursor);\n      var search = this[kSubstringSearch] || \"\", index = this.historyIndex + 1;\n      while (index < this.history.length && (!StringPrototypeStartsWith.call(this.history[index], search) || this.line === this.history[index]))\n        index++;\n      if (index === this.history.length)\n        this.line = search;\n      else\n        this.line = this.history[index];\n      this.historyIndex = index, this.cursor = this.line.length, this[kRefreshLine]();\n    }\n  }\n  [kGetDisplayPos](str) {\n    var offset = 0, col = this.columns, rows = 0;\n    str = stripVTControlCharacters(str);\n    for (var char of new SafeStringIterator(str)) {\n      if (char === \"\\n\") {\n        rows += MathCeil(offset / col) || 1, offset = 0;\n        continue;\n      }\n      if (char === \"\\t\") {\n        offset += this.tabSize - offset % this.tabSize;\n        continue;\n      }\n      var width = getStringWidth(char, !1);\n      if (width === 0 || width === 1)\n        offset += width;\n      else {\n        if ((offset + 1) % col === 0)\n          offset++;\n        offset += 2;\n      }\n    }\n    var cols = offset % col;\n    return rows += (offset - cols) / col, { cols, rows };\n  }\n  getCursorPos() {\n    var strBeforeCursor = this[kPrompt] + StringPrototypeSlice.call(this.line, 0, this.cursor);\n    return this[kGetDisplayPos](strBeforeCursor);\n  }\n  [kMoveCursor](dx) {\n    if (dx === 0)\n      return;\n    var oldPos = this.getCursorPos();\n    if (this.cursor += dx, this.cursor < 0)\n      this.cursor = 0;\n    else if (this.cursor > this.line.length)\n      this.cursor = this.line.length;\n    var newPos = this.getCursorPos();\n    if (oldPos.rows === newPos.rows) {\n      var diffWidth = newPos.cols - oldPos.cols;\n      moveCursor(this.output, diffWidth, 0);\n    } else\n      this[kRefreshLine]();\n  }\n  [kTtyWrite](s, key) {\n    var previousKey = this[kPreviousKey];\n    key = key || kEmptyObject, this[kPreviousKey] = key;\n    var { name: keyName, meta: keyMeta, ctrl: keyCtrl2, shift: keyShift, sequence: keySeq } = key;\n    if (!keyMeta || keyName !== \"y\")\n      this[kYanking] = !1;\n    if ((keyName === \"up\" || keyName === \"down\") && !keyCtrl2 && !keyMeta && !keyShift) {\n      if (this[kSubstringSearch] === null)\n        this[kSubstringSearch] = StringPrototypeSlice.call(this.line, 0, this.cursor);\n    } else if (this[kSubstringSearch] !== null) {\n      if (this[kSubstringSearch] = null, this.history.length === this.historyIndex)\n        this.historyIndex = -1;\n    }\n    if (typeof keySeq === \"string\")\n      switch (StringPrototypeCodePointAt.call(keySeq, 0)) {\n        case 31:\n          this[kUndo]();\n          return;\n        case 30:\n          this[kRedo]();\n          return;\n        default:\n          break;\n      }\n    if (keyName === \"escape\")\n      return;\n    if (keyCtrl2 && keyShift)\n      switch (keyName) {\n        case \"backspace\":\n          this[kDeleteLineLeft]();\n          break;\n        case \"delete\":\n          this[kDeleteLineRight]();\n          break;\n      }\n    else if (keyCtrl2)\n      switch (keyName) {\n        case \"c\":\n          if (this.listenerCount(\"SIGINT\") > 0)\n            this.emit(\"SIGINT\");\n          else\n            this.close();\n          break;\n        case \"h\":\n          this[kDeleteLeft]();\n          break;\n        case \"d\":\n          if (this.cursor === 0 && this.line.length === 0)\n            this.close();\n          else if (this.cursor < this.line.length)\n            this[kDeleteRight]();\n          break;\n        case \"u\":\n          this[kDeleteLineLeft]();\n          break;\n        case \"k\":\n          this[kDeleteLineRight]();\n          break;\n        case \"a\":\n          this[kMoveCursor]((-Infinity));\n          break;\n        case \"e\":\n          this[kMoveCursor](Infinity);\n          break;\n        case \"b\":\n          this[kMoveCursor](-charLengthLeft(this.line, this.cursor));\n          break;\n        case \"f\":\n          this[kMoveCursor](+charLengthAt(this.line, this.cursor));\n          break;\n        case \"l\":\n          cursorTo(this.output, 0, 0), clearScreenDown(this.output), this[kRefreshLine]();\n          break;\n        case \"n\":\n          this[kHistoryNext]();\n          break;\n        case \"p\":\n          this[kHistoryPrev]();\n          break;\n        case \"y\":\n          this[kYank]();\n          break;\n        case \"z\":\n          if (this.listenerCount(\"SIGTSTP\") > 0)\n            this.emit(\"SIGTSTP\");\n          else\n            process.once(\"SIGCONT\", () => {\n              if (!this.paused)\n                this.pause(), this.emit(\"SIGCONT\");\n              this[kSetRawMode](!0), this[kRefreshLine]();\n            }), this[kSetRawMode](!1), process.kill(process.pid, \"SIGTSTP\");\n          break;\n        case \"w\":\n        case \"backspace\":\n          this[kDeleteWordLeft]();\n          break;\n        case \"delete\":\n          this[kDeleteWordRight]();\n          break;\n        case \"left\":\n          this[kWordLeft]();\n          break;\n        case \"right\":\n          this[kWordRight]();\n          break;\n      }\n    else if (keyMeta)\n      switch (keyName) {\n        case \"b\":\n          this[kWordLeft]();\n          break;\n        case \"f\":\n          this[kWordRight]();\n          break;\n        case \"d\":\n        case \"delete\":\n          this[kDeleteWordRight]();\n          break;\n        case \"backspace\":\n          this[kDeleteWordLeft]();\n          break;\n        case \"y\":\n          this[kYankPop]();\n          break;\n      }\n    else {\n      if (this[kSawReturnAt] && keyName !== \"enter\")\n        this[kSawReturnAt] = 0;\n      switch (keyName) {\n        case \"return\":\n          this[kSawReturnAt] = DateNow(), this[kLine]();\n          break;\n        case \"enter\":\n          if (this[kSawReturnAt] === 0 || DateNow() - this[kSawReturnAt] > this.crlfDelay)\n            this[kLine]();\n          this[kSawReturnAt] = 0;\n          break;\n        case \"backspace\":\n          this[kDeleteLeft]();\n          break;\n        case \"delete\":\n          this[kDeleteRight]();\n          break;\n        case \"left\":\n          this[kMoveCursor](-charLengthLeft(this.line, this.cursor));\n          break;\n        case \"right\":\n          this[kMoveCursor](+charLengthAt(this.line, this.cursor));\n          break;\n        case \"home\":\n          this[kMoveCursor]((-Infinity));\n          break;\n        case \"end\":\n          this[kMoveCursor](Infinity);\n          break;\n        case \"up\":\n          this[kHistoryPrev]();\n          break;\n        case \"down\":\n          this[kHistoryNext]();\n          break;\n        case \"tab\":\n          if (typeof this.completer === \"function\" && this.isCompletionEnabled) {\n            var lastKeypressWasTab = previousKey && previousKey.name === \"tab\";\n            this[kTabComplete](lastKeypressWasTab);\n            break;\n          }\n        default:\n          if (typeof s === \"string\" && s) {\n            var nextMatch = RegExpPrototypeExec.call(lineEnding, s);\n            if (nextMatch !== null) {\n              this[kInsertString](StringPrototypeSlice.call(s, 0, nextMatch.index));\n              var { lastIndex } = lineEnding;\n              while ((nextMatch = RegExpPrototypeExec.call(lineEnding, s)) !== null)\n                this[kLine](), this[kInsertString](StringPrototypeSlice.call(s, lastIndex, nextMatch.index)), { lastIndex } = lineEnding;\n              if (lastIndex === s.length)\n                this[kLine]();\n            } else\n              this[kInsertString](s);\n          }\n      }\n    }\n  }\n  [SymbolAsyncIterator]() {\n    if (this[kLineObjectStream] === void 0)\n      this[kLineObjectStream] = EventEmitter.on(this, \"line\", {\n        close: [\"close\"],\n        highWatermark: 1024,\n        [kFirstEventParam]: !0\n      });\n    return this[kLineObjectStream];\n  }\n};\nInterface.prototype = {};\nObjectSetPrototypeOf(Interface.prototype, _Interface.prototype);\nObjectSetPrototypeOf(Interface, _Interface);\nInterface.prototype.question = function question(query, options, cb) {\n  if (cb = typeof options === \"function\" \? options : cb, options === null || typeof options !== \"object\")\n    options = kEmptyObject;\n  var signal = options\?.signal;\n  if (signal) {\n    if (validateAbortSignal(signal, \"options.signal\"), signal.aborted)\n      return;\n    var onAbort = () => {\n      this[kQuestionCancel]();\n    };\n    signal.addEventListener(\"abort\", onAbort, { once: !0 });\n    var cleanup = () => {\n      signal.removeEventListener(\"abort\", onAbort);\n    }, originalCb = cb;\n    cb = typeof cb === \"function\" \? (answer) => {\n      return cleanup(), originalCb(answer);\n    } : cleanup;\n  }\n  if (typeof cb === \"function\")\n    this[kQuestion](query, cb);\n};\nInterface.prototype.question[promisify.custom] = function question2(query, options) {\n  if (options === null || typeof options !== \"object\")\n    options = kEmptyObject;\n  var signal = options\?.signal;\n  if (signal && signal.aborted)\n    return PromiseReject(new AbortError(void 0, { cause: signal.reason }));\n  return new Promise((resolve, reject) => {\n    var cb = resolve;\n    if (signal) {\n      var onAbort = () => {\n        reject(new AbortError(void 0, { cause: signal.reason }));\n      };\n      signal.addEventListener(\"abort\", onAbort, { once: !0 }), cb = (answer) => {\n        signal.removeEventListener(\"abort\", onAbort), resolve(answer);\n      };\n    }\n    this.question(query, options, cb);\n  });\n};\nObjectDefineProperties(Interface.prototype, {\n  [kSetRawMode]: {\n    __proto__: null,\n    get() {\n      return this._setRawMode;\n    }\n  },\n  [kOnLine]: {\n    __proto__: null,\n    get() {\n      return this._onLine;\n    }\n  },\n  [kWriteToOutput]: {\n    __proto__: null,\n    get() {\n      return this._writeToOutput;\n    }\n  },\n  [kAddHistory]: {\n    __proto__: null,\n    get() {\n      return this._addHistory;\n    }\n  },\n  [kRefreshLine]: {\n    __proto__: null,\n    get() {\n      return this._refreshLine;\n    }\n  },\n  [kNormalWrite]: {\n    __proto__: null,\n    get() {\n      return this._normalWrite;\n    }\n  },\n  [kInsertString]: {\n    __proto__: null,\n    get() {\n      return this._insertString;\n    }\n  },\n  [kTabComplete]: {\n    __proto__: null,\n    get() {\n      return this._tabComplete;\n    }\n  },\n  [kWordLeft]: {\n    __proto__: null,\n    get() {\n      return this._wordLeft;\n    }\n  },\n  [kWordRight]: {\n    __proto__: null,\n    get() {\n      return this._wordRight;\n    }\n  },\n  [kDeleteLeft]: {\n    __proto__: null,\n    get() {\n      return this._deleteLeft;\n    }\n  },\n  [kDeleteRight]: {\n    __proto__: null,\n    get() {\n      return this._deleteRight;\n    }\n  },\n  [kDeleteWordLeft]: {\n    __proto__: null,\n    get() {\n      return this._deleteWordLeft;\n    }\n  },\n  [kDeleteWordRight]: {\n    __proto__: null,\n    get() {\n      return this._deleteWordRight;\n    }\n  },\n  [kDeleteLineLeft]: {\n    __proto__: null,\n    get() {\n      return this._deleteLineLeft;\n    }\n  },\n  [kDeleteLineRight]: {\n    __proto__: null,\n    get() {\n      return this._deleteLineRight;\n    }\n  },\n  [kLine]: {\n    __proto__: null,\n    get() {\n      return this._line;\n    }\n  },\n  [kHistoryNext]: {\n    __proto__: null,\n    get() {\n      return this._historyNext;\n    }\n  },\n  [kHistoryPrev]: {\n    __proto__: null,\n    get() {\n      return this._historyPrev;\n    }\n  },\n  [kGetDisplayPos]: {\n    __proto__: null,\n    get() {\n      return this._getDisplayPos;\n    }\n  },\n  [kMoveCursor]: {\n    __proto__: null,\n    get() {\n      return this._moveCursor;\n    }\n  },\n  [kTtyWrite]: {\n    __proto__: null,\n    get() {\n      return this._ttyWrite;\n    }\n  },\n  _decoder: {\n    __proto__: null,\n    get() {\n      return this[kDecoder];\n    },\n    set(value) {\n      this[kDecoder] = value;\n    }\n  },\n  _line_buffer: {\n    __proto__: null,\n    get() {\n      return this[kLine_buffer];\n    },\n    set(value) {\n      this[kLine_buffer] = value;\n    }\n  },\n  _oldPrompt: {\n    __proto__: null,\n    get() {\n      return this[kOldPrompt];\n    },\n    set(value) {\n      this[kOldPrompt] = value;\n    }\n  },\n  _previousKey: {\n    __proto__: null,\n    get() {\n      return this[kPreviousKey];\n    },\n    set(value) {\n      this[kPreviousKey] = value;\n    }\n  },\n  _prompt: {\n    __proto__: null,\n    get() {\n      return this[kPrompt];\n    },\n    set(value) {\n      this[kPrompt] = value;\n    }\n  },\n  _questionCallback: {\n    __proto__: null,\n    get() {\n      return this[kQuestionCallback];\n    },\n    set(value) {\n      this[kQuestionCallback] = value;\n    }\n  },\n  _sawKeyPress: {\n    __proto__: null,\n    get() {\n      return this[kSawKeyPress];\n    },\n    set(value) {\n      this[kSawKeyPress] = value;\n    }\n  },\n  _sawReturnAt: {\n    __proto__: null,\n    get() {\n      return this[kSawReturnAt];\n    },\n    set(value) {\n      this[kSawReturnAt] = value;\n    }\n  }\n});\nInterface.prototype._setRawMode = _Interface.prototype[kSetRawMode];\nInterface.prototype._onLine = _Interface.prototype[kOnLine];\nInterface.prototype._writeToOutput = _Interface.prototype[kWriteToOutput];\nInterface.prototype._addHistory = _Interface.prototype[kAddHistory];\nInterface.prototype._refreshLine = _Interface.prototype[kRefreshLine];\nInterface.prototype._normalWrite = _Interface.prototype[kNormalWrite];\nInterface.prototype._insertString = _Interface.prototype[kInsertString];\nInterface.prototype._tabComplete = function(lastKeypressWasTab) {\n  this.pause();\n  var string = StringPrototypeSlice.call(this.line, 0, this.cursor);\n  this.completer(string, (err, value) => {\n    if (this.resume(), err) {\n      this._writeToOutput(`Tab completion error: ${inspect(err)}`);\n      return;\n    }\n    this[kTabCompleter](lastKeypressWasTab, value);\n  });\n};\nInterface.prototype._wordLeft = _Interface.prototype[kWordLeft];\nInterface.prototype._wordRight = _Interface.prototype[kWordRight];\nInterface.prototype._deleteLeft = _Interface.prototype[kDeleteLeft];\nInterface.prototype._deleteRight = _Interface.prototype[kDeleteRight];\nInterface.prototype._deleteWordLeft = _Interface.prototype[kDeleteWordLeft];\nInterface.prototype._deleteWordRight = _Interface.prototype[kDeleteWordRight];\nInterface.prototype._deleteLineLeft = _Interface.prototype[kDeleteLineLeft];\nInterface.prototype._deleteLineRight = _Interface.prototype[kDeleteLineRight];\nInterface.prototype._line = _Interface.prototype[kLine];\nInterface.prototype._historyNext = _Interface.prototype[kHistoryNext];\nInterface.prototype._historyPrev = _Interface.prototype[kHistoryPrev];\nInterface.prototype._getDisplayPos = _Interface.prototype[kGetDisplayPos];\nInterface.prototype._getCursorPos = _Interface.prototype.getCursorPos;\nInterface.prototype._moveCursor = _Interface.prototype[kMoveCursor];\nInterface.prototype._ttyWrite = _Interface.prototype[kTtyWrite];\n\nclass Readline {\n  #autoCommit = !1;\n  #stream;\n  #todo = [];\n  constructor(stream, options = void 0) {\n    if (isWritable \?\?= (@getInternalField(@internalModuleRegistry, 35) || @createInternalModuleById(35)).isWritable, !isWritable(stream))\n      throw new ERR_INVALID_ARG_TYPE(\"stream\", \"Writable\", stream);\n    if (this.#stream = stream, options\?.autoCommit != null)\n      validateBoolean(options.autoCommit, \"options.autoCommit\"), this.#autoCommit = options.autoCommit;\n  }\n  cursorTo(x, y = void 0) {\n    if (validateInteger(x, \"x\"), y != null)\n      validateInteger(y, \"y\");\n    var data = y == null \? CSI`${x + 1}G` : CSI`${y + 1};${x + 1}H`;\n    if (this.#autoCommit)\n      process.nextTick(() => this.#stream.write(data));\n    else\n      ArrayPrototypePush.call(this.#todo, data);\n    return this;\n  }\n  moveCursor(dx, dy) {\n    if (dx || dy) {\n      validateInteger(dx, \"dx\"), validateInteger(dy, \"dy\");\n      var data = \"\";\n      if (dx < 0)\n        data += CSI`${-dx}D`;\n      else if (dx > 0)\n        data += CSI`${dx}C`;\n      if (dy < 0)\n        data += CSI`${-dy}A`;\n      else if (dy > 0)\n        data += CSI`${dy}B`;\n      if (this.#autoCommit)\n        process.nextTick(() => this.#stream.write(data));\n      else\n        ArrayPrototypePush.call(this.#todo, data);\n    }\n    return this;\n  }\n  clearLine(dir) {\n    validateInteger(dir, \"dir\", -1, 1);\n    var data = dir < 0 \? kClearToLineBeginning : dir > 0 \? kClearToLineEnd : kClearLine;\n    if (this.#autoCommit)\n      process.nextTick(() => this.#stream.write(data));\n    else\n      ArrayPrototypePush.call(this.#todo, data);\n    return this;\n  }\n  clearScreenDown() {\n    if (this.#autoCommit)\n      process.nextTick(() => this.#stream.write(kClearScreenDown));\n    else\n      ArrayPrototypePush.call(this.#todo, kClearScreenDown);\n    return this;\n  }\n  commit() {\n    return new Promise((resolve) => {\n      this.#stream.write(ArrayPrototypeJoin.call(this.#todo, \"\"), resolve), this.#todo = [];\n    });\n  }\n  rollback() {\n    return this.#todo = [], this;\n  }\n}\nvar PromisesInterface = class Interface3 extends _Interface {\n  constructor(input, output, completer, terminal) {\n    super(input, output, completer, terminal);\n  }\n  question(query, options = kEmptyObject) {\n    var signal = options\?.signal;\n    if (signal) {\n      if (validateAbortSignal(signal, \"options.signal\"), signal.aborted)\n        return PromiseReject(new AbortError(void 0, { cause: signal.reason }));\n    }\n    return new Promise((resolve, reject) => {\n      var cb = resolve;\n      if (options\?.signal) {\n        var onAbort = () => {\n          this[kQuestionCancel](), reject(new AbortError(void 0, { cause: signal.reason }));\n        };\n        signal.addEventListener(\"abort\", onAbort, { once: !0 }), cb = (answer) => {\n          signal.removeEventListener(\"abort\", onAbort), resolve(answer);\n        };\n      }\n      this[kQuestion](query, cb);\n    });\n  }\n};\n$ = {\n  Interface,\n  clearLine,\n  clearScreenDown,\n  createInterface,\n  cursorTo,\n  emitKeypressEvents,\n  moveCursor,\n  promises: {\n    Readline,\n    Interface: PromisesInterface,\n    createInterface(input, output, completer, terminal) {\n      return new PromisesInterface(input, output, completer, terminal);\n    }\n  },\n  [SymbolFor(\"__BUN_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED__\")]: {\n    CSI,\n    utils: {\n      getStringWidth,\n      stripVTControlCharacters\n    }\n  }\n};\nreturn $})\n"_s;
//

//
static constexpr ASCIILiteral NodeReadlinePromisesCode = "(function (){\"use strict\";// src/js/out/tmp/node/readline.promises.ts\nreturn (@getInternalField(@internalModuleRegistry, 31) || @createInternalModuleById(31)).promises})\n"_s;
//

//
static constexpr ASCIILiteral NodeReplCode = "(function (){\"use strict\";// src/js/out/tmp/node/repl.ts\nvar $, { throwNotImplemented } = @getInternalField(@internalModuleRegistry, 3) || @createInternalModuleById(3);\n$ = {\n  lines: [],\n  context: globalThis,\n  historyIndex: -1,\n  cursor: 0,\n  historySize: 1000,\n  removeHistoryDuplicates: !1,\n  crlfDelay: 100,\n  completer: () => {\n    throwNotImplemented(\"node:repl\");\n  },\n  history: [],\n  _initialPrompt: \"> \",\n  terminal: !0,\n  input: new Proxy({}, {\n    get() {\n      throwNotImplemented(\"node:repl\");\n    },\n    has: () => !1,\n    ownKeys: () => [],\n    getOwnPropertyDescriptor: () => {\n      return;\n    },\n    set() {\n      throwNotImplemented(\"node:repl\");\n    }\n  }),\n  line: \"\",\n  eval: () => {\n    throwNotImplemented(\"node:repl\");\n  },\n  isCompletionEnabled: !0,\n  escapeCodeTimeout: 500,\n  tabSize: 8,\n  breakEvalOnSigint: !0,\n  useGlobal: !0,\n  underscoreAssigned: !1,\n  last: void 0,\n  _domain: void 0,\n  allowBlockingCompletions: !1,\n  useColors: !0,\n  output: new Proxy({}, {\n    get() {\n      throwNotImplemented(\"node:repl\");\n    },\n    has: () => !1,\n    ownKeys: () => [],\n    getOwnPropertyDescriptor: () => {\n      return;\n    },\n    set() {\n      throwNotImplemented(\"node:repl\");\n    }\n  }),\n  _builtinLibs: [\n    \"bun\",\n    \"ffi\",\n    \"assert\",\n    \"assert/strict\",\n    \"async_hooks\",\n    \"buffer\",\n    \"child_process\",\n    \"cluster\",\n    \"console\",\n    \"constants\",\n    \"crypto\",\n    \"dgram\",\n    \"diagnostics_channel\",\n    \"dns\",\n    \"dns/promises\",\n    \"domain\",\n    \"events\",\n    \"fs\",\n    \"fs/promises\",\n    \"http\",\n    \"http2\",\n    \"https\",\n    \"inspector\",\n    \"inspector/promises\",\n    \"module\",\n    \"net\",\n    \"os\",\n    \"path\",\n    \"path/posix\",\n    \"path/win32\",\n    \"perf_hooks\",\n    \"process\",\n    \"punycode\",\n    \"querystring\",\n    \"readline\",\n    \"readline/promises\",\n    \"repl\",\n    \"stream\",\n    \"stream/consumers\",\n    \"stream/promises\",\n    \"stream/web\",\n    \"string_decoder\",\n    \"sys\",\n    \"timers\",\n    \"timers/promises\",\n    \"tls\",\n    \"trace_events\",\n    \"tty\",\n    \"url\",\n    \"util\",\n    \"util/types\",\n    \"v8\",\n    \"vm\",\n    \"wasi\",\n    \"worker_threads\",\n    \"zlib\"\n  ]\n};\nreturn $})\n"_s;
//

//
static constexpr ASCIILiteral NodeStreamConsumersCode = "(function (){\"use strict\";// src/js/out/tmp/node/stream.consumers.ts\nvar $, arrayBuffer = Bun.readableStreamToArrayBuffer, text = Bun.readableStreamToText, json = (stream) => Bun.readableStreamToText(stream).then(JSON.parse), buffer = async (readableStream) => {\n  return new Buffer(await arrayBuffer(readableStream));\n}, blob = Bun.readableStreamToBlob;\n$ = {\n  arrayBuffer,\n  text,\n  json,\n  buffer,\n  blob\n};\nreturn $})\n"_s;
//

//
static constexpr ASCIILiteral NodeStreamCode = "(function (){\"use strict\";// src/js/out/tmp/node/stream.ts\nvar isReadableStream = function(value) {\n  return typeof value === \"object\" && value !== null && value instanceof ReadableStream;\n}, validateBoolean = function(value, name) {\n  if (typeof value !== \"boolean\")\n    throw new ERR_INVALID_ARG_TYPE(name, \"boolean\", value);\n};\nvar ERR_INVALID_ARG_TYPE = function(name, type, value) {\n  return new Error(`The argument '${name}' is invalid. Received '${value}' for type '${type}'`);\n}, ERR_INVALID_ARG_VALUE = function(name, value, reason) {\n  return new Error(`The value '${value}' is invalid for argument '${name}'. Reason: ${reason}`);\n}, createNativeStreamReadable = function(nativeType, Readable) {\n  var [pull, start, cancel, setClose, deinit, updateRef, drainFn] = globalThis[globalThis.Symbol.for('Bun.lazy')](nativeType), closer = [!1], handleNumberResult = function(nativeReadable, result, view, isClosed) {\n    if (result > 0) {\n      const slice = view.subarray(0, result), remainder = view.subarray(result);\n      if (slice.byteLength > 0)\n        nativeReadable.push(slice);\n      if (isClosed)\n        nativeReadable.push(null);\n      return remainder.byteLength > 0 \? remainder : void 0;\n    }\n    if (isClosed)\n      nativeReadable.push(null);\n    return view;\n  }, handleArrayBufferViewResult = function(nativeReadable, result, view, isClosed) {\n    if (result.byteLength > 0)\n      nativeReadable.push(result);\n    if (isClosed)\n      nativeReadable.push(null);\n    return view;\n  }, DYNAMICALLY_ADJUST_CHUNK_SIZE = process.env.BUN_DISABLE_DYNAMIC_CHUNK_SIZE !== \"1\";\n  const finalizer = new FinalizationRegistry((ptr) => ptr && deinit(ptr)), MIN_BUFFER_SIZE = 512;\n  var NativeReadable = class NativeReadable2 extends Readable {\n    #bunNativePtr;\n    #refCount = 1;\n    #constructed = !1;\n    #remainingChunk = void 0;\n    #highWaterMark;\n    #pendingRead = !1;\n    #hasResized = !DYNAMICALLY_ADJUST_CHUNK_SIZE;\n    #unregisterToken;\n    constructor(ptr, options = {}) {\n      super(options);\n      if (typeof options.highWaterMark === \"number\")\n        this.#highWaterMark = options.highWaterMark;\n      else\n        this.#highWaterMark = 262144;\n      this.#bunNativePtr = ptr, this.#constructed = !1, this.#remainingChunk = void 0, this.#pendingRead = !1, this.#unregisterToken = {}, finalizer.register(this, this.#bunNativePtr, this.#unregisterToken);\n    }\n    _read(maxToRead) {\n      if (this.#pendingRead)\n        return;\n      var ptr = this.#bunNativePtr;\n      if (ptr === 0) {\n        this.push(null);\n        return;\n      }\n      if (!this.#constructed)\n        this.#internalConstruct(ptr);\n      return this.#internalRead(this.#getRemainingChunk(maxToRead), ptr);\n    }\n    #internalConstruct(ptr) {\n      this.#constructed = !0;\n      const result = start(ptr, this.#highWaterMark);\n      if (typeof result === \"number\" && result > 1)\n        this.#hasResized = !0, this.#highWaterMark = Math.min(this.#highWaterMark, result);\n      if (drainFn) {\n        const drainResult = drainFn(ptr);\n        if ((drainResult\?.byteLength \?\? 0) > 0)\n          this.push(drainResult);\n      }\n    }\n    #getRemainingChunk(maxToRead = this.#highWaterMark) {\n      var chunk = this.#remainingChunk;\n      if (chunk\?.byteLength \?\? 0 < MIN_BUFFER_SIZE) {\n        var size = maxToRead > MIN_BUFFER_SIZE \? maxToRead : MIN_BUFFER_SIZE;\n        this.#remainingChunk = chunk = new Buffer(size);\n      }\n      return chunk;\n    }\n    #handleResult(result, view, isClosed) {\n      if (typeof result === \"number\") {\n        if (result >= this.#highWaterMark && !this.#hasResized && !isClosed)\n          this.#highWaterMark *= 2, this.#hasResized = !0;\n        return handleNumberResult(this, result, view, isClosed);\n      } else if (typeof result === \"boolean\")\n        return process.nextTick(() => {\n          this.push(null);\n        }), view\?.byteLength \?\? 0 > 0 \? view : void 0;\n      else if (ArrayBuffer.isView(result)) {\n        if (result.byteLength >= this.#highWaterMark && !this.#hasResized && !isClosed)\n          this.#highWaterMark *= 2, this.#hasResized = !0;\n        return handleArrayBufferViewResult(this, result, view, isClosed);\n      } else\n        throw new Error(\"Invalid result from pull\");\n    }\n    #internalRead(view, ptr) {\n      closer[0] = !1;\n      var result = pull(ptr, view, closer);\n      if (@isPromise(result))\n        return this.#pendingRead = !0, result.then((result2) => {\n          this.#pendingRead = !1, this.#remainingChunk = this.#handleResult(result2, view, closer[0]);\n        }, (reason) => {\n          errorOrDestroy(this, reason);\n        });\n      else\n        this.#remainingChunk = this.#handleResult(result, view, closer[0]);\n    }\n    _destroy(error, callback) {\n      var ptr = this.#bunNativePtr;\n      if (ptr === 0) {\n        callback(error);\n        return;\n      }\n      if (finalizer.unregister(this.#unregisterToken), this.#bunNativePtr = 0, updateRef)\n        updateRef(ptr, !1);\n      cancel(ptr, error), callback(error);\n    }\n    ref() {\n      var ptr = this.#bunNativePtr;\n      if (ptr === 0)\n        return;\n      if (this.#refCount++ === 0)\n        updateRef(ptr, !0);\n    }\n    unref() {\n      var ptr = this.#bunNativePtr;\n      if (ptr === 0)\n        return;\n      if (this.#refCount-- === 1)\n        updateRef(ptr, !1);\n    }\n  };\n  if (!updateRef)\n    NativeReadable.prototype.ref = void 0, NativeReadable.prototype.unref = void 0;\n  return NativeReadable;\n}, getNativeReadableStreamPrototype = function(nativeType, Readable) {\n  return nativeReadableStreamPrototypes[nativeType] ||= createNativeStreamReadable(nativeType, Readable);\n}, getNativeReadableStream = function(Readable, stream, options) {\n  if (!(stream && typeof stream === \"object\" && stream instanceof ReadableStream))\n    return;\n  const native = @direct(stream);\n  if (!native)\n    return;\n  const { stream: ptr, data: type } = native;\n  return new (getNativeReadableStreamPrototype(type, Readable))(ptr, options);\n}, EE = globalThis[globalThis.Symbol.for('Bun.lazy')](\"events\"), StringDecoder = @requireNativeModule(\"node:string_decoder\").StringDecoder, __getOwnPropNames = Object.getOwnPropertyNames, __commonJS = (cb, mod) => function __require2() {\n  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;\n}, runOnNextTick = process.nextTick;\nvar ArrayIsArray = Array.isArray, require_primordials = __commonJS({\n  \"node_modules/readable-stream/lib/ours/primordials.js\"(exports, module) {\n    module.exports = {\n      ArrayIsArray(self) {\n        return Array.isArray(self);\n      },\n      ArrayPrototypeIncludes(self, el) {\n        return self.includes(el);\n      },\n      ArrayPrototypeIndexOf(self, el) {\n        return self.indexOf(el);\n      },\n      ArrayPrototypeJoin(self, sep) {\n        return self.join(sep);\n      },\n      ArrayPrototypeMap(self, fn) {\n        return self.map(fn);\n      },\n      ArrayPrototypePop(self, el) {\n        return self.pop(el);\n      },\n      ArrayPrototypePush(self, el) {\n        return self.push(el);\n      },\n      ArrayPrototypeSlice(self, start, end) {\n        return self.slice(start, end);\n      },\n      Error,\n      FunctionPrototypeCall(fn, thisArgs, ...args) {\n        return fn.call(thisArgs, ...args);\n      },\n      FunctionPrototypeSymbolHasInstance(self, instance) {\n        return Function.prototype[Symbol.hasInstance].call(self, instance);\n      },\n      MathFloor: Math.floor,\n      Number,\n      NumberIsInteger: Number.isInteger,\n      NumberIsNaN: Number.isNaN,\n      NumberMAX_SAFE_INTEGER: Number.MAX_SAFE_INTEGER,\n      NumberMIN_SAFE_INTEGER: Number.MIN_SAFE_INTEGER,\n      NumberParseInt: Number.parseInt,\n      ObjectDefineProperties(self, props) {\n        return Object.defineProperties(self, props);\n      },\n      ObjectDefineProperty(self, name, prop) {\n        return Object.defineProperty(self, name, prop);\n      },\n      ObjectGetOwnPropertyDescriptor(self, name) {\n        return Object.getOwnPropertyDescriptor(self, name);\n      },\n      ObjectKeys(obj) {\n        return Object.keys(obj);\n      },\n      ObjectSetPrototypeOf(target, proto) {\n        return Object.setPrototypeOf(target, proto);\n      },\n      Promise,\n      PromisePrototypeCatch(self, fn) {\n        return self.catch(fn);\n      },\n      PromisePrototypeThen(self, thenFn, catchFn) {\n        return self.then(thenFn, catchFn);\n      },\n      PromiseReject(err) {\n        return Promise.reject(err);\n      },\n      ReflectApply: Reflect.apply,\n      RegExpPrototypeTest(self, value) {\n        return self.test(value);\n      },\n      SafeSet: Set,\n      String,\n      StringPrototypeSlice(self, start, end) {\n        return self.slice(start, end);\n      },\n      StringPrototypeToLowerCase(self) {\n        return self.toLowerCase();\n      },\n      StringPrototypeToUpperCase(self) {\n        return self.toUpperCase();\n      },\n      StringPrototypeTrim(self) {\n        return self.trim();\n      },\n      Symbol,\n      SymbolAsyncIterator: Symbol.asyncIterator,\n      SymbolHasInstance: Symbol.hasInstance,\n      SymbolIterator: Symbol.iterator,\n      TypedArrayPrototypeSet(self, buf, len) {\n        return self.set(buf, len);\n      },\n      Uint8Array\n    };\n  }\n}), require_util = __commonJS({\n  \"node_modules/readable-stream/lib/ours/util.js\"(exports, module) {\n    var AsyncFunction = Object.getPrototypeOf(async function() {\n    }).constructor, isBlob = typeof Blob !== \"undefined\" \? function isBlob2(b) {\n      return b instanceof Blob;\n    } : function isBlob2(b) {\n      return !1;\n    }, AggregateError = class extends Error {\n      constructor(errors) {\n        if (!Array.isArray(errors))\n          @throwTypeError(`Expected input to be an Array, got ${typeof errors}`);\n        let message = \"\";\n        for (let i = 0;i < errors.length; i++)\n          message += `    ${errors[i].stack}\n`;\n        super(message);\n        this.name = \"AggregateError\", this.errors = errors;\n      }\n    };\n    module.exports = {\n      AggregateError,\n      once(callback) {\n        let called = !1;\n        return function(...args) {\n          if (called)\n            return;\n          called = !0, callback.apply(this, args);\n        };\n      },\n      createDeferredPromise: function() {\n        let resolve, reject;\n        return {\n          promise: new Promise((res, rej) => {\n            resolve = res, reject = rej;\n          }),\n          resolve,\n          reject\n        };\n      },\n      promisify(fn) {\n        return new Promise((resolve, reject) => {\n          fn((err, ...args) => {\n            if (err)\n              return reject(err);\n            return resolve(...args);\n          });\n        });\n      },\n      debuglog() {\n        return function() {\n        };\n      },\n      format(format, ...args) {\n        return format.replace(/%([sdifj])/g, function(...[_unused, type]) {\n          const replacement = args.shift();\n          if (type === \"f\")\n            return replacement.toFixed(6);\n          else if (type === \"j\")\n            return JSON.stringify(replacement);\n          else if (type === \"s\" && typeof replacement === \"object\")\n            return `${replacement.constructor !== Object \? replacement.constructor.name : \"\"} {}`.trim();\n          else\n            return replacement.toString();\n        });\n      },\n      inspect(value) {\n        switch (typeof value) {\n          case \"string\":\n            if (value.includes(\"'\")) {\n              if (!value.includes('\"'))\n                return `\"${value}\"`;\n              else if (!value.includes(\"`\") && !value.includes(\"${\"))\n                return `\\`${value}\\``;\n            }\n            return `'${value}'`;\n          case \"number\":\n            if (isNaN(value))\n              return \"NaN\";\n            else if (Object.is(value, -0))\n              return String(value);\n            return value;\n          case \"bigint\":\n            return `${String(value)}n`;\n          case \"boolean\":\n          case \"undefined\":\n            return String(value);\n          case \"object\":\n            return \"{}\";\n        }\n      },\n      types: {\n        isAsyncFunction(fn) {\n          return fn instanceof AsyncFunction;\n        },\n        isArrayBufferView(arr) {\n          return ArrayBuffer.isView(arr);\n        }\n      },\n      isBlob\n    }, module.exports.promisify.custom = Symbol.for(\"nodejs.util.promisify.custom\");\n  }\n}), require_errors = __commonJS({\n  \"node_modules/readable-stream/lib/ours/errors.js\"(exports, module) {\n    var { format, inspect, AggregateError: CustomAggregateError } = require_util(), AggregateError = globalThis.AggregateError || CustomAggregateError, kIsNodeError = Symbol(\"kIsNodeError\"), kTypes = [\"string\", \"function\", \"number\", \"object\", \"Function\", \"Object\", \"boolean\", \"bigint\", \"symbol\"], classRegExp = /^([A-Z][a-z0-9]*)+$/, nodeInternalPrefix = \"__node_internal_\", codes = {};\n    function assert(value, message) {\n      if (!value)\n        throw new codes.ERR_INTERNAL_ASSERTION(message);\n    }\n    function addNumericalSeparator(val) {\n      let res = \"\", i = val.length;\n      const start = val[0] === \"-\" \? 1 : 0;\n      for (;i >= start + 4; i -= 3)\n        res = `_${val.slice(i - 3, i)}${res}`;\n      return `${val.slice(0, i)}${res}`;\n    }\n    function getMessage(key, msg, args) {\n      if (typeof msg === \"function\")\n        return assert(msg.length <= args.length, `Code: ${key}; The provided arguments length (${args.length}) does not match the required ones (${msg.length}).`), msg(...args);\n      const expectedLength = (msg.match(/%[dfijoOs]/g) || []).length;\n      if (assert(expectedLength === args.length, `Code: ${key}; The provided arguments length (${args.length}) does not match the required ones (${expectedLength}).`), args.length === 0)\n        return msg;\n      return format(msg, ...args);\n    }\n    function E(code, message, Base) {\n      if (!Base)\n        Base = Error;\n\n      class NodeError extends Base {\n        constructor(...args) {\n          super(getMessage(code, message, args));\n        }\n        toString() {\n          return `${this.name} [${code}]: ${this.message}`;\n        }\n      }\n      Object.defineProperties(NodeError.prototype, {\n        name: {\n          value: Base.name,\n          writable: !0,\n          enumerable: !1,\n          configurable: !0\n        },\n        toString: {\n          value() {\n            return `${this.name} [${code}]: ${this.message}`;\n          },\n          writable: !0,\n          enumerable: !1,\n          configurable: !0\n        }\n      }), NodeError.prototype.code = code, NodeError.prototype[kIsNodeError] = !0, codes[code] = NodeError;\n    }\n    function hideStackFrames(fn) {\n      const hidden = nodeInternalPrefix + fn.name;\n      return Object.defineProperty(fn, \"name\", {\n        value: hidden\n      }), fn;\n    }\n    function aggregateTwoErrors(innerError, outerError) {\n      if (innerError && outerError && innerError !== outerError) {\n        if (Array.isArray(outerError.errors))\n          return outerError.errors.push(innerError), outerError;\n        const err = new AggregateError([outerError, innerError], outerError.message);\n        return err.code = outerError.code, err;\n      }\n      return innerError || outerError;\n    }\n    var AbortError2 = class extends Error {\n      constructor(message = \"The operation was aborted\", options = void 0) {\n        if (options !== void 0 && typeof options !== \"object\")\n          throw new codes.ERR_INVALID_ARG_TYPE(\"options\", \"Object\", options);\n        super(message, options);\n        this.code = \"ABORT_ERR\", this.name = \"AbortError\";\n      }\n    };\n    E(\"ERR_ASSERTION\", \"%s\", Error), E(\"ERR_INVALID_ARG_TYPE\", (name, expected, actual) => {\n      if (assert(typeof name === \"string\", \"'name' must be a string\"), !Array.isArray(expected))\n        expected = [expected];\n      let msg = \"The \";\n      if (name.endsWith(\" argument\"))\n        msg += `${name} `;\n      else\n        msg += `\"${name}\" ${name.includes(\".\") \? \"property\" : \"argument\"} `;\n      msg += \"must be \";\n      const types = [], instances = [], other = [];\n      for (let value of expected)\n        if (assert(typeof value === \"string\", \"All expected entries have to be of type string\"), kTypes.includes(value))\n          types.push(value.toLowerCase());\n        else if (classRegExp.test(value))\n          instances.push(value);\n        else\n          assert(value !== \"object\", 'The value \"object\" should be written as \"Object\"'), other.push(value);\n      if (instances.length > 0) {\n        const pos = types.indexOf(\"object\");\n        if (pos !== -1)\n          types.splice(types, pos, 1), instances.push(\"Object\");\n      }\n      if (types.length > 0) {\n        switch (types.length) {\n          case 1:\n            msg += `of type ${types[0]}`;\n            break;\n          case 2:\n            msg += `one of type ${types[0]} or ${types[1]}`;\n            break;\n          default: {\n            const last = types.pop();\n            msg += `one of type ${types.join(\", \")}, or ${last}`;\n          }\n        }\n        if (instances.length > 0 || other.length > 0)\n          msg += \" or \";\n      }\n      if (instances.length > 0) {\n        switch (instances.length) {\n          case 1:\n            msg += `an instance of ${instances[0]}`;\n            break;\n          case 2:\n            msg += `an instance of ${instances[0]} or ${instances[1]}`;\n            break;\n          default: {\n            const last = instances.pop();\n            msg += `an instance of ${instances.join(\", \")}, or ${last}`;\n          }\n        }\n        if (other.length > 0)\n          msg += \" or \";\n      }\n      switch (other.length) {\n        case 0:\n          break;\n        case 1:\n          if (other[0].toLowerCase() !== other[0])\n            msg += \"an \";\n          msg += `${other[0]}`;\n          break;\n        case 2:\n          msg += `one of ${other[0]} or ${other[1]}`;\n          break;\n        default: {\n          const last = other.pop();\n          msg += `one of ${other.join(\", \")}, or ${last}`;\n        }\n      }\n      if (actual == null)\n        msg += `. Received ${actual}`;\n      else if (typeof actual === \"function\" && actual.name)\n        msg += `. Received function ${actual.name}`;\n      else if (typeof actual === \"object\") {\n        var _actual$constructor;\n        if ((_actual$constructor = actual.constructor) !== null && _actual$constructor !== void 0 && _actual$constructor.name)\n          msg += `. Received an instance of ${actual.constructor.name}`;\n        else {\n          const inspected = inspect(actual, {\n            depth: -1\n          });\n          msg += `. Received ${inspected}`;\n        }\n      } else {\n        let inspected = inspect(actual, {\n          colors: !1\n        });\n        if (inspected.length > 25)\n          inspected = `${inspected.slice(0, 25)}...`;\n        msg += `. Received type ${typeof actual} (${inspected})`;\n      }\n      return msg;\n    }, TypeError), E(\"ERR_INVALID_ARG_VALUE\", (name, value, reason = \"is invalid\") => {\n      let inspected = inspect(value);\n      if (inspected.length > 128)\n        inspected = inspected.slice(0, 128) + \"...\";\n      return `The ${name.includes(\".\") \? \"property\" : \"argument\"} '${name}' ${reason}. Received ${inspected}`;\n    }, TypeError), E(\"ERR_INVALID_RETURN_VALUE\", (input, name, value) => {\n      var _value$constructor;\n      const type = value !== null && value !== void 0 && (_value$constructor = value.constructor) !== null && _value$constructor !== void 0 && _value$constructor.name \? `instance of ${value.constructor.name}` : `type ${typeof value}`;\n      return `Expected ${input} to be returned from the \"${name}\" function but got ${type}.`;\n    }, TypeError), E(\"ERR_MISSING_ARGS\", (...args) => {\n      assert(args.length > 0, \"At least one arg needs to be specified\");\n      let msg;\n      const len = args.length;\n      switch (args = (Array.isArray(args) \? args : [args]).map((a) => `\"${a}\"`).join(\" or \"), len) {\n        case 1:\n          msg += `The ${args[0]} argument`;\n          break;\n        case 2:\n          msg += `The ${args[0]} and ${args[1]} arguments`;\n          break;\n        default:\n          {\n            const last = args.pop();\n            msg += `The ${args.join(\", \")}, and ${last} arguments`;\n          }\n          break;\n      }\n      return `${msg} must be specified`;\n    }, TypeError), E(\"ERR_OUT_OF_RANGE\", (str, range, input) => {\n      assert(range, 'Missing \"range\" argument');\n      let received;\n      if (Number.isInteger(input) && Math.abs(input) > 4294967296)\n        received = addNumericalSeparator(String(input));\n      else if (typeof input === \"bigint\") {\n        if (received = String(input), input > 2n ** 32n || input < -(2n ** 32n))\n          received = addNumericalSeparator(received);\n        received += \"n\";\n      } else\n        received = inspect(input);\n      return `The value of \"${str}\" is out of range. It must be ${range}. Received ${received}`;\n    }, RangeError), E(\"ERR_MULTIPLE_CALLBACK\", \"Callback called multiple times\", Error), E(\"ERR_METHOD_NOT_IMPLEMENTED\", \"The %s method is not implemented\", Error), E(\"ERR_STREAM_ALREADY_FINISHED\", \"Cannot call %s after a stream was finished\", Error), E(\"ERR_STREAM_CANNOT_PIPE\", \"Cannot pipe, not readable\", Error), E(\"ERR_STREAM_DESTROYED\", \"Cannot call %s after a stream was destroyed\", Error), E(\"ERR_STREAM_NULL_VALUES\", \"May not write null values to stream\", TypeError), E(\"ERR_STREAM_PREMATURE_CLOSE\", \"Premature close\", Error), E(\"ERR_STREAM_PUSH_AFTER_EOF\", \"stream.push() after EOF\", Error), E(\"ERR_STREAM_UNSHIFT_AFTER_END_EVENT\", \"stream.unshift() after end event\", Error), E(\"ERR_STREAM_WRITE_AFTER_END\", \"write after end\", Error), E(\"ERR_UNKNOWN_ENCODING\", \"Unknown encoding: %s\", TypeError), module.exports = {\n      AbortError: AbortError2,\n      aggregateTwoErrors: hideStackFrames(aggregateTwoErrors),\n      hideStackFrames,\n      codes\n    };\n  }\n}), require_validators = __commonJS({\n  \"node_modules/readable-stream/lib/internal/validators.js\"(exports, module) {\n    var {\n      ArrayIsArray: ArrayIsArray2,\n      ArrayPrototypeIncludes,\n      ArrayPrototypeJoin,\n      ArrayPrototypeMap,\n      NumberIsInteger,\n      NumberMAX_SAFE_INTEGER,\n      NumberMIN_SAFE_INTEGER,\n      NumberParseInt,\n      RegExpPrototypeTest,\n      String: String2,\n      StringPrototypeToUpperCase,\n      StringPrototypeTrim\n    } = require_primordials(), {\n      hideStackFrames,\n      codes: { ERR_SOCKET_BAD_PORT, ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE2, ERR_INVALID_ARG_VALUE: ERR_INVALID_ARG_VALUE2, ERR_OUT_OF_RANGE, ERR_UNKNOWN_SIGNAL }\n    } = require_errors(), { normalizeEncoding } = require_util(), { isAsyncFunction, isArrayBufferView } = require_util().types, signals = {};\n    function isInt32(value) {\n      return value === (value | 0);\n    }\n    function isUint32(value) {\n      return value === value >>> 0;\n    }\n    var octalReg = /^[0-7]+$/, modeDesc = \"must be a 32-bit unsigned integer or an octal string\";\n    function parseFileMode(value, name, def) {\n      if (typeof value === \"undefined\")\n        value = def;\n      if (typeof value === \"string\") {\n        if (!RegExpPrototypeTest(octalReg, value))\n          throw new ERR_INVALID_ARG_VALUE2(name, value, modeDesc);\n        value = NumberParseInt(value, 8);\n      }\n      return validateInt32(value, name, 0, 4294967295), value;\n    }\n    var validateInteger = hideStackFrames((value, name, min = NumberMIN_SAFE_INTEGER, max = NumberMAX_SAFE_INTEGER) => {\n      if (typeof value !== \"number\")\n        throw new ERR_INVALID_ARG_TYPE2(name, \"number\", value);\n      if (!NumberIsInteger(value))\n        throw new ERR_OUT_OF_RANGE(name, \"an integer\", value);\n      if (value < min || value > max)\n        throw new ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value);\n    }), validateInt32 = hideStackFrames((value, name, min = -2147483648, max = 2147483647) => {\n      if (typeof value !== \"number\")\n        throw new ERR_INVALID_ARG_TYPE2(name, \"number\", value);\n      if (!isInt32(value)) {\n        if (!NumberIsInteger(value))\n          throw new ERR_OUT_OF_RANGE(name, \"an integer\", value);\n        throw new ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value);\n      }\n      if (value < min || value > max)\n        throw new ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value);\n    }), validateUint32 = hideStackFrames((value, name, positive) => {\n      if (typeof value !== \"number\")\n        throw new ERR_INVALID_ARG_TYPE2(name, \"number\", value);\n      if (!isUint32(value)) {\n        if (!NumberIsInteger(value))\n          throw new ERR_OUT_OF_RANGE(name, \"an integer\", value);\n        throw new ERR_OUT_OF_RANGE(name, `>= ${positive \? 1 : 0} && < 4294967296`, value);\n      }\n      if (positive && value === 0)\n        throw new ERR_OUT_OF_RANGE(name, \">= 1 && < 4294967296\", value);\n    });\n    function validateString(value, name) {\n      if (typeof value !== \"string\")\n        throw new ERR_INVALID_ARG_TYPE2(name, \"string\", value);\n    }\n    function validateNumber(value, name) {\n      if (typeof value !== \"number\")\n        throw new ERR_INVALID_ARG_TYPE2(name, \"number\", value);\n    }\n    var validateOneOf = hideStackFrames((value, name, oneOf) => {\n      if (!ArrayPrototypeIncludes(oneOf, value)) {\n        const reason = \"must be one of: \" + ArrayPrototypeJoin(ArrayPrototypeMap(oneOf, (v) => typeof v === \"string\" \? `'${v}'` : String2(v)), \", \");\n        throw new ERR_INVALID_ARG_VALUE2(name, value, reason);\n      }\n    });\n    function validateBoolean2(value, name) {\n      if (typeof value !== \"boolean\")\n        throw new ERR_INVALID_ARG_TYPE2(name, \"boolean\", value);\n    }\n    var validateObject = hideStackFrames((value, name, options) => {\n      const useDefaultOptions = options == null, allowArray = useDefaultOptions \? !1 : options.allowArray, allowFunction = useDefaultOptions \? !1 : options.allowFunction;\n      if (!(useDefaultOptions \? !1 : options.nullable) && value === null || !allowArray && ArrayIsArray2(value) || typeof value !== \"object\" && (!allowFunction || typeof value !== \"function\"))\n        throw new ERR_INVALID_ARG_TYPE2(name, \"Object\", value);\n    }), validateArray = hideStackFrames((value, name, minLength = 0) => {\n      if (!ArrayIsArray2(value))\n        throw new ERR_INVALID_ARG_TYPE2(name, \"Array\", value);\n      if (value.length < minLength) {\n        const reason = `must be longer than ${minLength}`;\n        throw new ERR_INVALID_ARG_VALUE2(name, value, reason);\n      }\n    });\n    function validateSignalName(signal, name = \"signal\") {\n      if (validateString(signal, name), signals[signal] === void 0) {\n        if (signals[StringPrototypeToUpperCase(signal)] !== void 0)\n          throw new ERR_UNKNOWN_SIGNAL(signal + \" (signals must use all capital letters)\");\n        throw new ERR_UNKNOWN_SIGNAL(signal);\n      }\n    }\n    var validateBuffer = hideStackFrames((buffer, name = \"buffer\") => {\n      if (!isArrayBufferView(buffer))\n        throw new ERR_INVALID_ARG_TYPE2(name, [\"Buffer\", \"TypedArray\", \"DataView\"], buffer);\n    });\n    function validateEncoding(data, encoding) {\n      const normalizedEncoding = normalizeEncoding(encoding), length = data.length;\n      if (normalizedEncoding === \"hex\" && length % 2 !== 0)\n        throw new ERR_INVALID_ARG_VALUE2(\"encoding\", encoding, `is invalid for data of length ${length}`);\n    }\n    function validatePort(port, name = \"Port\", allowZero = !0) {\n      if (typeof port !== \"number\" && typeof port !== \"string\" || typeof port === \"string\" && StringPrototypeTrim(port).length === 0 || +port !== +port >>> 0 || port > 65535 || port === 0 && !allowZero)\n        throw new ERR_SOCKET_BAD_PORT(name, port, allowZero);\n      return port | 0;\n    }\n    var validateAbortSignal = hideStackFrames((signal, name) => {\n      if (signal !== void 0 && (signal === null || typeof signal !== \"object\" || !(\"aborted\" in signal)))\n        throw new ERR_INVALID_ARG_TYPE2(name, \"AbortSignal\", signal);\n    }), validateFunction = hideStackFrames((value, name) => {\n      if (typeof value !== \"function\")\n        throw new ERR_INVALID_ARG_TYPE2(name, \"Function\", value);\n    }), validatePlainFunction = hideStackFrames((value, name) => {\n      if (typeof value !== \"function\" || isAsyncFunction(value))\n        throw new ERR_INVALID_ARG_TYPE2(name, \"Function\", value);\n    }), validateUndefined = hideStackFrames((value, name) => {\n      if (value !== void 0)\n        throw new ERR_INVALID_ARG_TYPE2(name, \"undefined\", value);\n    });\n    module.exports = {\n      isInt32,\n      isUint32,\n      parseFileMode,\n      validateArray,\n      validateBoolean: validateBoolean2,\n      validateBuffer,\n      validateEncoding,\n      validateFunction,\n      validateInt32,\n      validateInteger,\n      validateNumber,\n      validateObject,\n      validateOneOf,\n      validatePlainFunction,\n      validatePort,\n      validateSignalName,\n      validateString,\n      validateUint32,\n      validateUndefined,\n      validateAbortSignal\n    };\n  }\n}), require_utils = __commonJS({\n  \"node_modules/readable-stream/lib/internal/streams/utils.js\"(exports, module) {\n    var { Symbol: Symbol2, SymbolAsyncIterator, SymbolIterator } = require_primordials(), kDestroyed = Symbol2(\"kDestroyed\"), kIsErrored = Symbol2(\"kIsErrored\"), kIsReadable = Symbol2(\"kIsReadable\"), kIsDisturbed = Symbol2(\"kIsDisturbed\");\n    function isReadableNodeStream(obj, strict = !1) {\n      var _obj$_readableState;\n      return !!(obj && typeof obj.pipe === \"function\" && typeof obj.on === \"function\" && (!strict || typeof obj.pause === \"function\" && typeof obj.resume === \"function\") && (!obj._writableState || ((_obj$_readableState = obj._readableState) === null || _obj$_readableState === void 0 \? void 0 : _obj$_readableState.readable) !== !1) && (!obj._writableState || obj._readableState));\n    }\n    function isWritableNodeStream(obj) {\n      var _obj$_writableState;\n      return !!(obj && typeof obj.write === \"function\" && typeof obj.on === \"function\" && (!obj._readableState || ((_obj$_writableState = obj._writableState) === null || _obj$_writableState === void 0 \? void 0 : _obj$_writableState.writable) !== !1));\n    }\n    function isDuplexNodeStream(obj) {\n      return !!(obj && typeof obj.pipe === \"function\" && obj._readableState && typeof obj.on === \"function\" && typeof obj.write === \"function\");\n    }\n    function isNodeStream(obj) {\n      return obj && (obj._readableState || obj._writableState || typeof obj.write === \"function\" && typeof obj.on === \"function\" || typeof obj.pipe === \"function\" && typeof obj.on === \"function\");\n    }\n    function isIterable(obj, isAsync) {\n      if (obj == null)\n        return !1;\n      if (isAsync === !0)\n        return typeof obj[SymbolAsyncIterator] === \"function\";\n      if (isAsync === !1)\n        return typeof obj[SymbolIterator] === \"function\";\n      return typeof obj[SymbolAsyncIterator] === \"function\" || typeof obj[SymbolIterator] === \"function\";\n    }\n    function isDestroyed(stream) {\n      if (!isNodeStream(stream))\n        return null;\n      const { _writableState: wState, _readableState: rState } = stream, state = wState || rState;\n      return !!(stream.destroyed || stream[kDestroyed] || state !== null && state !== void 0 && state.destroyed);\n    }\n    function isWritableEnded(stream) {\n      if (!isWritableNodeStream(stream))\n        return null;\n      if (stream.writableEnded === !0)\n        return !0;\n      const wState = stream._writableState;\n      if (wState !== null && wState !== void 0 && wState.errored)\n        return !1;\n      if (typeof (wState === null || wState === void 0 \? void 0 : wState.ended) !== \"boolean\")\n        return null;\n      return wState.ended;\n    }\n    function isWritableFinished(stream, strict) {\n      if (!isWritableNodeStream(stream))\n        return null;\n      if (stream.writableFinished === !0)\n        return !0;\n      const wState = stream._writableState;\n      if (wState !== null && wState !== void 0 && wState.errored)\n        return !1;\n      if (typeof (wState === null || wState === void 0 \? void 0 : wState.finished) !== \"boolean\")\n        return null;\n      return !!(wState.finished || strict === !1 && wState.ended === !0 && wState.length === 0);\n    }\n    function isReadableEnded(stream) {\n      if (!isReadableNodeStream(stream))\n        return null;\n      if (stream.readableEnded === !0)\n        return !0;\n      const rState = stream._readableState;\n      if (!rState || rState.errored)\n        return !1;\n      if (typeof (rState === null || rState === void 0 \? void 0 : rState.ended) !== \"boolean\")\n        return null;\n      return rState.ended;\n    }\n    function isReadableFinished(stream, strict) {\n      if (!isReadableNodeStream(stream))\n        return null;\n      const rState = stream._readableState;\n      if (rState !== null && rState !== void 0 && rState.errored)\n        return !1;\n      if (typeof (rState === null || rState === void 0 \? void 0 : rState.endEmitted) !== \"boolean\")\n        return null;\n      return !!(rState.endEmitted || strict === !1 && rState.ended === !0 && rState.length === 0);\n    }\n    function isReadable(stream) {\n      if (stream && stream[kIsReadable] != null)\n        return stream[kIsReadable];\n      if (typeof (stream === null || stream === void 0 \? void 0 : stream.readable) !== \"boolean\")\n        return null;\n      if (isDestroyed(stream))\n        return !1;\n      return isReadableNodeStream(stream) && stream.readable && !isReadableFinished(stream);\n    }\n    function isWritable(stream) {\n      if (typeof (stream === null || stream === void 0 \? void 0 : stream.writable) !== \"boolean\")\n        return null;\n      if (isDestroyed(stream))\n        return !1;\n      return isWritableNodeStream(stream) && stream.writable && !isWritableEnded(stream);\n    }\n    function isFinished(stream, opts) {\n      if (!isNodeStream(stream))\n        return null;\n      if (isDestroyed(stream))\n        return !0;\n      if ((opts === null || opts === void 0 \? void 0 : opts.readable) !== !1 && isReadable(stream))\n        return !1;\n      if ((opts === null || opts === void 0 \? void 0 : opts.writable) !== !1 && isWritable(stream))\n        return !1;\n      return !0;\n    }\n    function isWritableErrored(stream) {\n      var _stream$_writableStat, _stream$_writableStat2;\n      if (!isNodeStream(stream))\n        return null;\n      if (stream.writableErrored)\n        return stream.writableErrored;\n      return (_stream$_writableStat = (_stream$_writableStat2 = stream._writableState) === null || _stream$_writableStat2 === void 0 \? void 0 : _stream$_writableStat2.errored) !== null && _stream$_writableStat !== void 0 \? _stream$_writableStat : null;\n    }\n    function isReadableErrored(stream) {\n      var _stream$_readableStat, _stream$_readableStat2;\n      if (!isNodeStream(stream))\n        return null;\n      if (stream.readableErrored)\n        return stream.readableErrored;\n      return (_stream$_readableStat = (_stream$_readableStat2 = stream._readableState) === null || _stream$_readableStat2 === void 0 \? void 0 : _stream$_readableStat2.errored) !== null && _stream$_readableStat !== void 0 \? _stream$_readableStat : null;\n    }\n    function isClosed(stream) {\n      if (!isNodeStream(stream))\n        return null;\n      if (typeof stream.closed === \"boolean\")\n        return stream.closed;\n      const { _writableState: wState, _readableState: rState } = stream;\n      if (typeof (wState === null || wState === void 0 \? void 0 : wState.closed) === \"boolean\" || typeof (rState === null || rState === void 0 \? void 0 : rState.closed) === \"boolean\")\n        return (wState === null || wState === void 0 \? void 0 : wState.closed) || (rState === null || rState === void 0 \? void 0 : rState.closed);\n      if (typeof stream._closed === \"boolean\" && isOutgoingMessage(stream))\n        return stream._closed;\n      return null;\n    }\n    function isOutgoingMessage(stream) {\n      return typeof stream._closed === \"boolean\" && typeof stream._defaultKeepAlive === \"boolean\" && typeof stream._removedConnection === \"boolean\" && typeof stream._removedContLen === \"boolean\";\n    }\n    function isServerResponse(stream) {\n      return typeof stream._sent100 === \"boolean\" && isOutgoingMessage(stream);\n    }\n    function isServerRequest(stream) {\n      var _stream$req;\n      return typeof stream._consuming === \"boolean\" && typeof stream._dumped === \"boolean\" && ((_stream$req = stream.req) === null || _stream$req === void 0 \? void 0 : _stream$req.upgradeOrConnect) === void 0;\n    }\n    function willEmitClose(stream) {\n      if (!isNodeStream(stream))\n        return null;\n      const { _writableState: wState, _readableState: rState } = stream, state = wState || rState;\n      return !state && isServerResponse(stream) || !!(state && state.autoDestroy && state.emitClose && state.closed === !1);\n    }\n    function isDisturbed(stream) {\n      var _stream$kIsDisturbed;\n      return !!(stream && ((_stream$kIsDisturbed = stream[kIsDisturbed]) !== null && _stream$kIsDisturbed !== void 0 \? _stream$kIsDisturbed : stream.readableDidRead || stream.readableAborted));\n    }\n    function isErrored(stream) {\n      var _ref, _ref2, _ref3, _ref4, _ref5, _stream$kIsErrored, _stream$_readableStat3, _stream$_writableStat3, _stream$_readableStat4, _stream$_writableStat4;\n      return !!(stream && ((_ref = (_ref2 = (_ref3 = (_ref4 = (_ref5 = (_stream$kIsErrored = stream[kIsErrored]) !== null && _stream$kIsErrored !== void 0 \? _stream$kIsErrored : stream.readableErrored) !== null && _ref5 !== void 0 \? _ref5 : stream.writableErrored) !== null && _ref4 !== void 0 \? _ref4 : (_stream$_readableStat3 = stream._readableState) === null || _stream$_readableStat3 === void 0 \? void 0 : _stream$_readableStat3.errorEmitted) !== null && _ref3 !== void 0 \? _ref3 : (_stream$_writableStat3 = stream._writableState) === null || _stream$_writableStat3 === void 0 \? void 0 : _stream$_writableStat3.errorEmitted) !== null && _ref2 !== void 0 \? _ref2 : (_stream$_readableStat4 = stream._readableState) === null || _stream$_readableStat4 === void 0 \? void 0 : _stream$_readableStat4.errored) !== null && _ref !== void 0 \? _ref : (_stream$_writableStat4 = stream._writableState) === null || _stream$_writableStat4 === void 0 \? void 0 : _stream$_writableStat4.errored));\n    }\n    module.exports = {\n      kDestroyed,\n      isDisturbed,\n      kIsDisturbed,\n      isErrored,\n      kIsErrored,\n      isReadable,\n      kIsReadable,\n      isClosed,\n      isDestroyed,\n      isDuplexNodeStream,\n      isFinished,\n      isIterable,\n      isReadableNodeStream,\n      isReadableEnded,\n      isReadableFinished,\n      isReadableErrored,\n      isNodeStream,\n      isWritable,\n      isWritableNodeStream,\n      isWritableEnded,\n      isWritableFinished,\n      isWritableErrored,\n      isServerRequest,\n      isServerResponse,\n      willEmitClose\n    };\n  }\n}), require_end_of_stream = __commonJS({\n  \"node_modules/readable-stream/lib/internal/streams/end-of-stream.js\"(exports, module) {\n    var { AbortError: AbortError2, codes } = require_errors(), { ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE2, ERR_STREAM_PREMATURE_CLOSE } = codes, { once } = require_util(), { validateAbortSignal, validateFunction, validateObject } = require_validators(), { Promise: Promise2 } = require_primordials(), {\n      isClosed,\n      isReadable,\n      isReadableNodeStream,\n      isReadableFinished,\n      isReadableErrored,\n      isWritable,\n      isWritableNodeStream,\n      isWritableFinished,\n      isWritableErrored,\n      isNodeStream,\n      willEmitClose: _willEmitClose\n    } = require_utils();\n    function isRequest(stream) {\n      return stream.setHeader && typeof stream.abort === \"function\";\n    }\n    var nop = () => {\n    };\n    function eos(stream, options, callback) {\n      var _options$readable, _options$writable;\n      if (arguments.length === 2)\n        callback = options, options = {};\n      else if (options == null)\n        options = {};\n      else\n        validateObject(options, \"options\");\n      validateFunction(callback, \"callback\"), validateAbortSignal(options.signal, \"options.signal\"), callback = once(callback);\n      const readable = (_options$readable = options.readable) !== null && _options$readable !== void 0 \? _options$readable : isReadableNodeStream(stream), writable = (_options$writable = options.writable) !== null && _options$writable !== void 0 \? _options$writable : isWritableNodeStream(stream);\n      if (!isNodeStream(stream))\n        throw new ERR_INVALID_ARG_TYPE2(\"stream\", \"Stream\", stream);\n      const { _writableState: wState, _readableState: rState } = stream, onlegacyfinish = () => {\n        if (!stream.writable)\n          onfinish();\n      };\n      let willEmitClose = _willEmitClose(stream) && isReadableNodeStream(stream) === readable && isWritableNodeStream(stream) === writable, writableFinished = isWritableFinished(stream, !1);\n      const onfinish = () => {\n        if (writableFinished = !0, stream.destroyed)\n          willEmitClose = !1;\n        if (willEmitClose && (!stream.readable || readable))\n          return;\n        if (!readable || readableFinished)\n          callback.call(stream);\n      };\n      let readableFinished = isReadableFinished(stream, !1);\n      const onend = () => {\n        if (readableFinished = !0, stream.destroyed)\n          willEmitClose = !1;\n        if (willEmitClose && (!stream.writable || writable))\n          return;\n        if (!writable || writableFinished)\n          callback.call(stream);\n      }, onerror = (err) => {\n        callback.call(stream, err);\n      };\n      let closed = isClosed(stream);\n      const onclose = () => {\n        closed = !0;\n        const errored = isWritableErrored(stream) || isReadableErrored(stream);\n        if (errored && typeof errored !== \"boolean\")\n          return callback.call(stream, errored);\n        if (readable && !readableFinished && isReadableNodeStream(stream, !0)) {\n          if (!isReadableFinished(stream, !1))\n            return callback.call(stream, new ERR_STREAM_PREMATURE_CLOSE);\n        }\n        if (writable && !writableFinished) {\n          if (!isWritableFinished(stream, !1))\n            return callback.call(stream, new ERR_STREAM_PREMATURE_CLOSE);\n        }\n        callback.call(stream);\n      }, onrequest = () => {\n        stream.req.on(\"finish\", onfinish);\n      };\n      if (isRequest(stream)) {\n        if (stream.on(\"complete\", onfinish), !willEmitClose)\n          stream.on(\"abort\", onclose);\n        if (stream.req)\n          onrequest();\n        else\n          stream.on(\"request\", onrequest);\n      } else if (writable && !wState)\n        stream.on(\"end\", onlegacyfinish), stream.on(\"close\", onlegacyfinish);\n      if (!willEmitClose && typeof stream.aborted === \"boolean\")\n        stream.on(\"aborted\", onclose);\n      if (stream.on(\"end\", onend), stream.on(\"finish\", onfinish), options.error !== !1)\n        stream.on(\"error\", onerror);\n      if (stream.on(\"close\", onclose), closed)\n        runOnNextTick(onclose);\n      else if (wState !== null && wState !== void 0 && wState.errorEmitted || rState !== null && rState !== void 0 && rState.errorEmitted) {\n        if (!willEmitClose)\n          runOnNextTick(onclose);\n      } else if (!readable && (!willEmitClose || isReadable(stream)) && (writableFinished || isWritable(stream) === !1))\n        runOnNextTick(onclose);\n      else if (!writable && (!willEmitClose || isWritable(stream)) && (readableFinished || isReadable(stream) === !1))\n        runOnNextTick(onclose);\n      else if (rState && stream.req && stream.aborted)\n        runOnNextTick(onclose);\n      const cleanup = () => {\n        if (callback = nop, stream.removeListener(\"aborted\", onclose), stream.removeListener(\"complete\", onfinish), stream.removeListener(\"abort\", onclose), stream.removeListener(\"request\", onrequest), stream.req)\n          stream.req.removeListener(\"finish\", onfinish);\n        stream.removeListener(\"end\", onlegacyfinish), stream.removeListener(\"close\", onlegacyfinish), stream.removeListener(\"finish\", onfinish), stream.removeListener(\"end\", onend), stream.removeListener(\"error\", onerror), stream.removeListener(\"close\", onclose);\n      };\n      if (options.signal && !closed) {\n        const abort = () => {\n          const endCallback = callback;\n          cleanup(), endCallback.call(stream, new AbortError2(void 0, {\n            cause: options.signal.reason\n          }));\n        };\n        if (options.signal.aborted)\n          runOnNextTick(abort);\n        else {\n          const originalCallback = callback;\n          callback = once((...args) => {\n            options.signal.removeEventListener(\"abort\", abort), originalCallback.apply(stream, args);\n          }), options.signal.addEventListener(\"abort\", abort);\n        }\n      }\n      return cleanup;\n    }\n    function finished2(stream, opts) {\n      return new Promise2((resolve, reject) => {\n        eos(stream, opts, (err) => {\n          if (err)\n            reject(err);\n          else\n            resolve();\n        });\n      });\n    }\n    module.exports = eos, module.exports.finished = finished2;\n  }\n}), require_operators = __commonJS({\n  \"node_modules/readable-stream/lib/internal/streams/operators.js\"(exports, module) {\n    var {\n      codes: { ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE2, ERR_MISSING_ARGS, ERR_OUT_OF_RANGE },\n      AbortError: AbortError2\n    } = require_errors(), { validateAbortSignal, validateInteger, validateObject } = require_validators(), kWeakHandler = require_primordials().Symbol(\"kWeak\"), { finished: finished2 } = require_end_of_stream(), {\n      ArrayPrototypePush,\n      MathFloor,\n      Number: Number2,\n      NumberIsNaN,\n      Promise: Promise2,\n      PromiseReject,\n      PromisePrototypeCatch,\n      Symbol: Symbol2\n    } = require_primordials(), kEmpty = Symbol2(\"kEmpty\"), kEof = Symbol2(\"kEof\");\n    function map(fn, options) {\n      if (typeof fn !== \"function\")\n        throw new ERR_INVALID_ARG_TYPE2(\"fn\", [\"Function\", \"AsyncFunction\"], fn);\n      if (options != null)\n        validateObject(options, \"options\");\n      if ((options === null || options === void 0 \? void 0 : options.signal) != null)\n        validateAbortSignal(options.signal, \"options.signal\");\n      let concurrency = 1;\n      if ((options === null || options === void 0 \? void 0 : options.concurrency) != null)\n        concurrency = MathFloor(options.concurrency);\n      return validateInteger(concurrency, \"concurrency\", 1), async function* map2() {\n        var _options$signal, _options$signal2;\n        const ac = new AbortController, stream = this, queue = [], signal = ac.signal, signalOpt = {\n          signal\n        }, abort = () => ac.abort();\n        if (options !== null && options !== void 0 && (_options$signal = options.signal) !== null && _options$signal !== void 0 && _options$signal.aborted)\n          abort();\n        options === null || options === void 0 || (_options$signal2 = options.signal) === null || _options$signal2 === void 0 || _options$signal2.addEventListener(\"abort\", abort);\n        let next, resume, done = !1;\n        function onDone() {\n          done = !0;\n        }\n        async function pump() {\n          try {\n            for await (let val of stream) {\n              var _val;\n              if (done)\n                return;\n              if (signal.aborted)\n                throw new AbortError2;\n              try {\n                val = fn(val, signalOpt);\n              } catch (err) {\n                val = PromiseReject(err);\n              }\n              if (val === kEmpty)\n                continue;\n              if (typeof ((_val = val) === null || _val === void 0 \? void 0 : _val.catch) === \"function\")\n                val.catch(onDone);\n              if (queue.push(val), next)\n                next(), next = null;\n              if (!done && queue.length && queue.length >= concurrency)\n                await new Promise2((resolve) => {\n                  resume = resolve;\n                });\n            }\n            queue.push(kEof);\n          } catch (err) {\n            const val = PromiseReject(err);\n            PromisePrototypeCatch(val, onDone), queue.push(val);\n          } finally {\n            var _options$signal3;\n            if (done = !0, next)\n              next(), next = null;\n            options === null || options === void 0 || (_options$signal3 = options.signal) === null || _options$signal3 === void 0 || _options$signal3.removeEventListener(\"abort\", abort);\n          }\n        }\n        pump();\n        try {\n          while (!0) {\n            while (queue.length > 0) {\n              const val = await queue[0];\n              if (val === kEof)\n                return;\n              if (signal.aborted)\n                throw new AbortError2;\n              if (val !== kEmpty)\n                yield val;\n              if (queue.shift(), resume)\n                resume(), resume = null;\n            }\n            await new Promise2((resolve) => {\n              next = resolve;\n            });\n          }\n        } finally {\n          if (ac.abort(), done = !0, resume)\n            resume(), resume = null;\n        }\n      }.call(this);\n    }\n    function asIndexedPairs(options = void 0) {\n      if (options != null)\n        validateObject(options, \"options\");\n      if ((options === null || options === void 0 \? void 0 : options.signal) != null)\n        validateAbortSignal(options.signal, \"options.signal\");\n      return async function* asIndexedPairs2() {\n        let index = 0;\n        for await (let val of this) {\n          var _options$signal4;\n          if (options !== null && options !== void 0 && (_options$signal4 = options.signal) !== null && _options$signal4 !== void 0 && _options$signal4.aborted)\n            throw new AbortError2({\n              cause: options.signal.reason\n            });\n          yield [index++, val];\n        }\n      }.call(this);\n    }\n    async function some(fn, options = void 0) {\n      for await (let unused of filter.call(this, fn, options))\n        return !0;\n      return !1;\n    }\n    async function every(fn, options = void 0) {\n      if (typeof fn !== \"function\")\n        throw new ERR_INVALID_ARG_TYPE2(\"fn\", [\"Function\", \"AsyncFunction\"], fn);\n      return !await some.call(this, async (...args) => {\n        return !await fn(...args);\n      }, options);\n    }\n    async function find(fn, options) {\n      for await (let result of filter.call(this, fn, options))\n        return result;\n      return;\n    }\n    async function forEach(fn, options) {\n      if (typeof fn !== \"function\")\n        throw new ERR_INVALID_ARG_TYPE2(\"fn\", [\"Function\", \"AsyncFunction\"], fn);\n      async function forEachFn(value, options2) {\n        return await fn(value, options2), kEmpty;\n      }\n      for await (let unused of map.call(this, forEachFn, options))\n        ;\n    }\n    function filter(fn, options) {\n      if (typeof fn !== \"function\")\n        throw new ERR_INVALID_ARG_TYPE2(\"fn\", [\"Function\", \"AsyncFunction\"], fn);\n      async function filterFn(value, options2) {\n        if (await fn(value, options2))\n          return value;\n        return kEmpty;\n      }\n      return map.call(this, filterFn, options);\n    }\n    var ReduceAwareErrMissingArgs = class extends ERR_MISSING_ARGS {\n      constructor() {\n        super(\"reduce\");\n        this.message = \"Reduce of an empty stream requires an initial value\";\n      }\n    };\n    async function reduce(reducer, initialValue, options) {\n      var _options$signal5;\n      if (typeof reducer !== \"function\")\n        throw new ERR_INVALID_ARG_TYPE2(\"reducer\", [\"Function\", \"AsyncFunction\"], reducer);\n      if (options != null)\n        validateObject(options, \"options\");\n      if ((options === null || options === void 0 \? void 0 : options.signal) != null)\n        validateAbortSignal(options.signal, \"options.signal\");\n      let hasInitialValue = arguments.length > 1;\n      if (options !== null && options !== void 0 && (_options$signal5 = options.signal) !== null && _options$signal5 !== void 0 && _options$signal5.aborted) {\n        const err = new AbortError2(void 0, {\n          cause: options.signal.reason\n        });\n        throw this.once(\"error\", () => {\n        }), await finished2(this.destroy(err)), err;\n      }\n      const ac = new AbortController, signal = ac.signal;\n      if (options !== null && options !== void 0 && options.signal) {\n        const opts = {\n          once: !0,\n          [kWeakHandler]: this\n        };\n        options.signal.addEventListener(\"abort\", () => ac.abort(), opts);\n      }\n      let gotAnyItemFromStream = !1;\n      try {\n        for await (let value of this) {\n          var _options$signal6;\n          if (gotAnyItemFromStream = !0, options !== null && options !== void 0 && (_options$signal6 = options.signal) !== null && _options$signal6 !== void 0 && _options$signal6.aborted)\n            throw new AbortError2;\n          if (!hasInitialValue)\n            initialValue = value, hasInitialValue = !0;\n          else\n            initialValue = await reducer(initialValue, value, {\n              signal\n            });\n        }\n        if (!gotAnyItemFromStream && !hasInitialValue)\n          throw new ReduceAwareErrMissingArgs;\n      } finally {\n        ac.abort();\n      }\n      return initialValue;\n    }\n    async function toArray(options) {\n      if (options != null)\n        validateObject(options, \"options\");\n      if ((options === null || options === void 0 \? void 0 : options.signal) != null)\n        validateAbortSignal(options.signal, \"options.signal\");\n      const result = [];\n      for await (let val of this) {\n        var _options$signal7;\n        if (options !== null && options !== void 0 && (_options$signal7 = options.signal) !== null && _options$signal7 !== void 0 && _options$signal7.aborted)\n          throw new AbortError2(void 0, {\n            cause: options.signal.reason\n          });\n        ArrayPrototypePush(result, val);\n      }\n      return result;\n    }\n    function flatMap(fn, options) {\n      const values = map.call(this, fn, options);\n      return async function* flatMap2() {\n        for await (let val of values)\n          yield* val;\n      }.call(this);\n    }\n    function toIntegerOrInfinity(number) {\n      if (number = Number2(number), NumberIsNaN(number))\n        return 0;\n      if (number < 0)\n        throw new ERR_OUT_OF_RANGE(\"number\", \">= 0\", number);\n      return number;\n    }\n    function drop(number, options = void 0) {\n      if (options != null)\n        validateObject(options, \"options\");\n      if ((options === null || options === void 0 \? void 0 : options.signal) != null)\n        validateAbortSignal(options.signal, \"options.signal\");\n      return number = toIntegerOrInfinity(number), async function* drop2() {\n        var _options$signal8;\n        if (options !== null && options !== void 0 && (_options$signal8 = options.signal) !== null && _options$signal8 !== void 0 && _options$signal8.aborted)\n          throw new AbortError2;\n        for await (let val of this) {\n          var _options$signal9;\n          if (options !== null && options !== void 0 && (_options$signal9 = options.signal) !== null && _options$signal9 !== void 0 && _options$signal9.aborted)\n            throw new AbortError2;\n          if (number-- <= 0)\n            yield val;\n        }\n      }.call(this);\n    }\n    function take(number, options = void 0) {\n      if (options != null)\n        validateObject(options, \"options\");\n      if ((options === null || options === void 0 \? void 0 : options.signal) != null)\n        validateAbortSignal(options.signal, \"options.signal\");\n      return number = toIntegerOrInfinity(number), async function* take2() {\n        var _options$signal10;\n        if (options !== null && options !== void 0 && (_options$signal10 = options.signal) !== null && _options$signal10 !== void 0 && _options$signal10.aborted)\n          throw new AbortError2;\n        for await (let val of this) {\n          var _options$signal11;\n          if (options !== null && options !== void 0 && (_options$signal11 = options.signal) !== null && _options$signal11 !== void 0 && _options$signal11.aborted)\n            throw new AbortError2;\n          if (number-- > 0)\n            yield val;\n          else\n            return;\n        }\n      }.call(this);\n    }\n    module.exports.streamReturningOperators = {\n      asIndexedPairs,\n      drop,\n      filter,\n      flatMap,\n      map,\n      take\n    }, module.exports.promiseReturningOperators = {\n      every,\n      forEach,\n      reduce,\n      toArray,\n      some,\n      find\n    };\n  }\n}), require_destroy = __commonJS({\n  \"node_modules/readable-stream/lib/internal/streams/destroy.js\"(exports, module) {\n    var {\n      aggregateTwoErrors,\n      codes: { ERR_MULTIPLE_CALLBACK },\n      AbortError: AbortError2\n    } = require_errors(), { Symbol: Symbol2 } = require_primordials(), { kDestroyed, isDestroyed, isFinished, isServerRequest } = require_utils(), kDestroy = \"#kDestroy\", kConstruct = \"#kConstruct\";\n    function checkError(err, w, r) {\n      if (err) {\n        if (err.stack, w && !w.errored)\n          w.errored = err;\n        if (r && !r.errored)\n          r.errored = err;\n      }\n    }\n    function destroy2(err, cb) {\n      const r = this._readableState, w = this._writableState, s = w || r;\n      if (w && w.destroyed || r && r.destroyed) {\n        if (typeof cb === \"function\")\n          cb();\n        return this;\n      }\n      if (checkError(err, w, r), w)\n        w.destroyed = !0;\n      if (r)\n        r.destroyed = !0;\n      if (!s.constructed)\n        this.once(kDestroy, (er) => {\n          _destroy(this, aggregateTwoErrors(er, err), cb);\n        });\n      else\n        _destroy(this, err, cb);\n      return this;\n    }\n    function _destroy(self, err, cb) {\n      let called = !1;\n      function onDestroy(err2) {\n        if (called)\n          return;\n        called = !0;\n        const { _readableState: r, _writableState: w } = self;\n        if (checkError(err2, w, r), w)\n          w.closed = !0;\n        if (r)\n          r.closed = !0;\n        if (typeof cb === \"function\")\n          cb(err2);\n        if (err2)\n          runOnNextTick(emitErrorCloseNT, self, err2);\n        else\n          runOnNextTick(emitCloseNT, self);\n      }\n      try {\n        self._destroy(err || null, onDestroy);\n      } catch (err2) {\n        onDestroy(err2);\n      }\n    }\n    function emitErrorCloseNT(self, err) {\n      emitErrorNT(self, err), emitCloseNT(self);\n    }\n    function emitCloseNT(self) {\n      const { _readableState: r, _writableState: w } = self;\n      if (w)\n        w.closeEmitted = !0;\n      if (r)\n        r.closeEmitted = !0;\n      if (w && w.emitClose || r && r.emitClose)\n        self.emit(\"close\");\n    }\n    function emitErrorNT(self, err) {\n      const r = self\?._readableState, w = self\?._writableState;\n      if (w\?.errorEmitted || r\?.errorEmitted)\n        return;\n      if (w)\n        w.errorEmitted = !0;\n      if (r)\n        r.errorEmitted = !0;\n      self\?.emit\?.(\"error\", err);\n    }\n    function undestroy() {\n      const r = this._readableState, w = this._writableState;\n      if (r)\n        r.constructed = !0, r.closed = !1, r.closeEmitted = !1, r.destroyed = !1, r.errored = null, r.errorEmitted = !1, r.reading = !1, r.ended = r.readable === !1, r.endEmitted = r.readable === !1;\n      if (w)\n        w.constructed = !0, w.destroyed = !1, w.closed = !1, w.closeEmitted = !1, w.errored = null, w.errorEmitted = !1, w.finalCalled = !1, w.prefinished = !1, w.ended = w.writable === !1, w.ending = w.writable === !1, w.finished = w.writable === !1;\n    }\n    function errorOrDestroy2(stream, err, sync) {\n      const r = stream\?._readableState, w = stream\?._writableState;\n      if (w && w.destroyed || r && r.destroyed)\n        return this;\n      if (r && r.autoDestroy || w && w.autoDestroy)\n        stream.destroy(err);\n      else if (err) {\n        if (Error.captureStackTrace(err), w && !w.errored)\n          w.errored = err;\n        if (r && !r.errored)\n          r.errored = err;\n        if (sync)\n          runOnNextTick(emitErrorNT, stream, err);\n        else\n          emitErrorNT(stream, err);\n      }\n    }\n    function construct(stream, cb) {\n      if (typeof stream._construct !== \"function\")\n        return;\n      const { _readableState: r, _writableState: w } = stream;\n      if (r)\n        r.constructed = !1;\n      if (w)\n        w.constructed = !1;\n      if (stream.once(kConstruct, cb), stream.listenerCount(kConstruct) > 1)\n        return;\n      runOnNextTick(constructNT, stream);\n    }\n    function constructNT(stream) {\n      let called = !1;\n      function onConstruct(err) {\n        if (called) {\n          errorOrDestroy2(stream, err !== null && err !== void 0 \? err : new ERR_MULTIPLE_CALLBACK);\n          return;\n        }\n        called = !0;\n        const { _readableState: r, _writableState: w } = stream, s = w || r;\n        if (r)\n          r.constructed = !0;\n        if (w)\n          w.constructed = !0;\n        if (s.destroyed)\n          stream.emit(kDestroy, err);\n        else if (err)\n          errorOrDestroy2(stream, err, !0);\n        else\n          runOnNextTick(emitConstructNT, stream);\n      }\n      try {\n        stream._construct(onConstruct);\n      } catch (err) {\n        onConstruct(err);\n      }\n    }\n    function emitConstructNT(stream) {\n      stream.emit(kConstruct);\n    }\n    function isRequest(stream) {\n      return stream && stream.setHeader && typeof stream.abort === \"function\";\n    }\n    function emitCloseLegacy(stream) {\n      stream.emit(\"close\");\n    }\n    function emitErrorCloseLegacy(stream, err) {\n      stream.emit(\"error\", err), runOnNextTick(emitCloseLegacy, stream);\n    }\n    function destroyer(stream, err) {\n      if (!stream || isDestroyed(stream))\n        return;\n      if (!err && !isFinished(stream))\n        err = new AbortError2;\n      if (isServerRequest(stream))\n        stream.socket = null, stream.destroy(err);\n      else if (isRequest(stream))\n        stream.abort();\n      else if (isRequest(stream.req))\n        stream.req.abort();\n      else if (typeof stream.destroy === \"function\")\n        stream.destroy(err);\n      else if (typeof stream.close === \"function\")\n        stream.close();\n      else if (err)\n        runOnNextTick(emitErrorCloseLegacy, stream);\n      else\n        runOnNextTick(emitCloseLegacy, stream);\n      if (!stream.destroyed)\n        stream[kDestroyed] = !0;\n    }\n    module.exports = {\n      construct,\n      destroyer,\n      destroy: destroy2,\n      undestroy,\n      errorOrDestroy: errorOrDestroy2\n    };\n  }\n}), require_legacy = __commonJS({\n  \"node_modules/readable-stream/lib/internal/streams/legacy.js\"(exports, module) {\n    var { ArrayIsArray: ArrayIsArray2, ObjectSetPrototypeOf } = require_primordials();\n    function Stream(options) {\n      if (!(this instanceof Stream))\n        return new Stream(options);\n      EE.call(this, options);\n    }\n    Stream.prototype = {}, ObjectSetPrototypeOf(Stream.prototype, EE.prototype), ObjectSetPrototypeOf(Stream, EE), Stream.prototype.pipe = function(dest, options) {\n      const source = this;\n      function ondata(chunk) {\n        if (dest.writable && dest.write(chunk) === !1 && source.pause)\n          source.pause();\n      }\n      source.on(\"data\", ondata);\n      function ondrain() {\n        if (source.readable && source.resume)\n          source.resume();\n      }\n      if (dest.on(\"drain\", ondrain), !dest._isStdio && (!options || options.end !== !1))\n        source.on(\"end\", onend), source.on(\"close\", onclose);\n      let didOnEnd = !1;\n      function onend() {\n        if (didOnEnd)\n          return;\n        didOnEnd = !0, dest.end();\n      }\n      function onclose() {\n        if (didOnEnd)\n          return;\n        if (didOnEnd = !0, typeof dest.destroy === \"function\")\n          dest.destroy();\n      }\n      function onerror(er) {\n        if (cleanup(), EE.listenerCount(this, \"error\") === 0)\n          this.emit(\"error\", er);\n      }\n      prependListener(source, \"error\", onerror), prependListener(dest, \"error\", onerror);\n      function cleanup() {\n        source.removeListener(\"data\", ondata), dest.removeListener(\"drain\", ondrain), source.removeListener(\"end\", onend), source.removeListener(\"close\", onclose), source.removeListener(\"error\", onerror), dest.removeListener(\"error\", onerror), source.removeListener(\"end\", cleanup), source.removeListener(\"close\", cleanup), dest.removeListener(\"close\", cleanup);\n      }\n      return source.on(\"end\", cleanup), source.on(\"close\", cleanup), dest.on(\"close\", cleanup), dest.emit(\"pipe\", source), dest;\n    };\n    function prependListener(emitter, event, fn) {\n      if (typeof emitter.prependListener === \"function\")\n        return emitter.prependListener(event, fn);\n      if (!emitter._events || !emitter._events[event])\n        emitter.on(event, fn);\n      else if (ArrayIsArray2(emitter._events[event]))\n        emitter._events[event].unshift(fn);\n      else\n        emitter._events[event] = [fn, emitter._events[event]];\n    }\n    module.exports = {\n      Stream,\n      prependListener\n    };\n  }\n}), require_add_abort_signal = __commonJS({\n  \"node_modules/readable-stream/lib/internal/streams/add-abort-signal.js\"(exports, module) {\n    var { AbortError: AbortError2, codes } = require_errors(), eos = require_end_of_stream(), { ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE2 } = codes, validateAbortSignal = (signal, name) => {\n      if (typeof signal !== \"object\" || !(\"aborted\" in signal))\n        throw new ERR_INVALID_ARG_TYPE2(name, \"AbortSignal\", signal);\n    };\n    function isNodeStream(obj) {\n      return !!(obj && typeof obj.pipe === \"function\");\n    }\n    module.exports.addAbortSignal = function addAbortSignal(signal, stream) {\n      if (validateAbortSignal(signal, \"signal\"), !isNodeStream(stream))\n        throw new ERR_INVALID_ARG_TYPE2(\"stream\", \"stream.Stream\", stream);\n      return module.exports.addAbortSignalNoValidate(signal, stream);\n    }, module.exports.addAbortSignalNoValidate = function(signal, stream) {\n      if (typeof signal !== \"object\" || !(\"aborted\" in signal))\n        return stream;\n      const onAbort = () => {\n        stream.destroy(new AbortError2(void 0, {\n          cause: signal.reason\n        }));\n      };\n      if (signal.aborted)\n        onAbort();\n      else\n        signal.addEventListener(\"abort\", onAbort), eos(stream, () => signal.removeEventListener(\"abort\", onAbort));\n      return stream;\n    };\n  }\n}), require_state = __commonJS({\n  \"node_modules/readable-stream/lib/internal/streams/state.js\"(exports, module) {\n    var { MathFloor, NumberIsInteger } = require_primordials(), { ERR_INVALID_ARG_VALUE: ERR_INVALID_ARG_VALUE2 } = require_errors().codes;\n    function highWaterMarkFrom(options, isDuplex, duplexKey) {\n      return options.highWaterMark != null \? options.highWaterMark : isDuplex \? options[duplexKey] : null;\n    }\n    function getDefaultHighWaterMark(objectMode) {\n      return objectMode \? 16 : 16384;\n    }\n    function getHighWaterMark(state, options, duplexKey, isDuplex) {\n      const hwm = highWaterMarkFrom(options, isDuplex, duplexKey);\n      if (hwm != null) {\n        if (!NumberIsInteger(hwm) || hwm < 0) {\n          const name = isDuplex \? `options.${duplexKey}` : \"options.highWaterMark\";\n          throw new ERR_INVALID_ARG_VALUE2(name, hwm);\n        }\n        return MathFloor(hwm);\n      }\n      return getDefaultHighWaterMark(state.objectMode);\n    }\n    module.exports = {\n      getHighWaterMark,\n      getDefaultHighWaterMark\n    };\n  }\n}), require_from = __commonJS({\n  \"node_modules/readable-stream/lib/internal/streams/from.js\"(exports, module) {\n    var { PromisePrototypeThen, SymbolAsyncIterator, SymbolIterator } = require_primordials(), { ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE2, ERR_STREAM_NULL_VALUES } = require_errors().codes;\n    function from(Readable, iterable, opts) {\n      let iterator;\n      if (typeof iterable === \"string\" || iterable instanceof Buffer)\n        return new Readable({\n          objectMode: !0,\n          ...opts,\n          read() {\n            this.push(iterable), this.push(null);\n          }\n        });\n      let isAsync;\n      if (iterable && iterable[SymbolAsyncIterator])\n        isAsync = !0, iterator = iterable[SymbolAsyncIterator]();\n      else if (iterable && iterable[SymbolIterator])\n        isAsync = !1, iterator = iterable[SymbolIterator]();\n      else\n        throw new ERR_INVALID_ARG_TYPE2(\"iterable\", [\"Iterable\"], iterable);\n      const readable = new Readable({\n        objectMode: !0,\n        highWaterMark: 1,\n        ...opts\n      });\n      let reading = !1;\n      readable._read = function() {\n        if (!reading)\n          reading = !0, next();\n      }, readable._destroy = function(error, cb) {\n        PromisePrototypeThen(close(error), () => runOnNextTick(cb, error), (e) => runOnNextTick(cb, e || error));\n      };\n      async function close(error) {\n        const hadError = error !== void 0 && error !== null, hasThrow = typeof iterator.throw === \"function\";\n        if (hadError && hasThrow) {\n          const { value, done } = await iterator.throw(error);\n          if (await value, done)\n            return;\n        }\n        if (typeof iterator.return === \"function\") {\n          const { value } = await iterator.return();\n          await value;\n        }\n      }\n      async function next() {\n        for (;; ) {\n          try {\n            const { value, done } = isAsync \? await iterator.next() : iterator.next();\n            if (done)\n              readable.push(null);\n            else {\n              const res = value && typeof value.then === \"function\" \? await value : value;\n              if (res === null)\n                throw reading = !1, new ERR_STREAM_NULL_VALUES;\n              else if (readable.push(res))\n                continue;\n              else\n                reading = !1;\n            }\n          } catch (err) {\n            readable.destroy(err);\n          }\n          break;\n        }\n      }\n      return readable;\n    }\n    module.exports = from;\n  }\n}), _ReadableFromWeb, _ReadableFromWebForUndici, require_readable = __commonJS({\n  \"node_modules/readable-stream/lib/internal/streams/readable.js\"(exports, module) {\n    var {\n      ArrayPrototypeIndexOf,\n      NumberIsInteger,\n      NumberIsNaN,\n      NumberParseInt,\n      ObjectDefineProperties,\n      ObjectKeys,\n      ObjectSetPrototypeOf,\n      Promise: Promise2,\n      SafeSet,\n      SymbolAsyncIterator,\n      Symbol: Symbol2\n    } = require_primordials(), ReadableState = globalThis[globalThis.Symbol.for('Bun.lazy')](\"bun:stream\").ReadableState, { Stream, prependListener } = require_legacy();\n    function Readable(options) {\n      if (!(this instanceof Readable))\n        return new Readable(options);\n      const isDuplex = this instanceof require_duplex();\n      if (this._readableState = new ReadableState(options, this, isDuplex), options) {\n        const { read, destroy: destroy2, construct, signal } = options;\n        if (typeof read === \"function\")\n          this._read = read;\n        if (typeof destroy2 === \"function\")\n          this._destroy = destroy2;\n        if (typeof construct === \"function\")\n          this._construct = construct;\n        if (signal && !isDuplex)\n          addAbortSignal(signal, this);\n      }\n      Stream.call(this, options), destroyImpl.construct(this, () => {\n        if (this._readableState.needReadable)\n          maybeReadMore(this, this._readableState);\n      });\n    }\n    Readable.prototype = {}, ObjectSetPrototypeOf(Readable.prototype, Stream.prototype), ObjectSetPrototypeOf(Readable, Stream), Readable.prototype.on = function(ev, fn) {\n      const res = Stream.prototype.on.call(this, ev, fn), state = this._readableState;\n      if (ev === \"data\") {\n        if (state.readableListening = this.listenerCount(\"readable\") > 0, state.flowing !== !1)\n          this.resume();\n      } else if (ev === \"readable\") {\n        if (!state.endEmitted && !state.readableListening) {\n          if (state.readableListening = state.needReadable = !0, state.flowing = !1, state.emittedReadable = !1, state.length)\n            emitReadable(this, state);\n          else if (!state.reading)\n            runOnNextTick(nReadingNextTick, this);\n        } else if (state.endEmitted)\n          ;\n      }\n      return res;\n    };\n\n    class ReadableFromWeb extends Readable {\n      #reader;\n      #closed;\n      #pendingChunks;\n      #stream;\n      constructor(options, stream) {\n        const { objectMode, highWaterMark, encoding, signal } = options;\n        super({\n          objectMode,\n          highWaterMark,\n          encoding,\n          signal\n        });\n        this.#pendingChunks = [], this.#reader = void 0, this.#stream = stream, this.#closed = !1;\n      }\n      #drainPending() {\n        var pendingChunks = this.#pendingChunks, pendingChunksI = 0, pendingChunksCount = pendingChunks.length;\n        for (;pendingChunksI < pendingChunksCount; pendingChunksI++) {\n          const chunk = pendingChunks[pendingChunksI];\n          if (pendingChunks[pendingChunksI] = void 0, !this.push(chunk, void 0))\n            return this.#pendingChunks = pendingChunks.slice(pendingChunksI + 1), !0;\n        }\n        if (pendingChunksCount > 0)\n          this.#pendingChunks = [];\n        return !1;\n      }\n      #handleDone(reader) {\n        reader.releaseLock(), this.#reader = void 0, this.#closed = !0, this.push(null);\n        return;\n      }\n      async _read() {\n        var stream = this.#stream, reader = this.#reader;\n        if (stream)\n          reader = this.#reader = stream.getReader(), this.#stream = void 0;\n        else if (this.#drainPending())\n          return;\n        var deferredError;\n        try {\n          do {\n            var done = !1, value;\n            const firstResult = reader.readMany();\n            if (@isPromise(firstResult)) {\n              if ({ done, value } = await firstResult, this.#closed) {\n                this.#pendingChunks.push(...value);\n                return;\n              }\n            } else\n              ({ done, value } = firstResult);\n            if (done) {\n              this.#handleDone(reader);\n              return;\n            }\n            if (!this.push(value[0])) {\n              this.#pendingChunks = value.slice(1);\n              return;\n            }\n            for (let i = 1, count = value.length;i < count; i++)\n              if (!this.push(value[i])) {\n                this.#pendingChunks = value.slice(i + 1);\n                return;\n              }\n          } while (!this.#closed);\n        } catch (e) {\n          deferredError = e;\n        } finally {\n          if (deferredError)\n            throw deferredError;\n        }\n      }\n      _destroy(error, callback) {\n        if (!this.#closed) {\n          var reader = this.#reader;\n          if (reader)\n            this.#reader = void 0, reader.cancel(error).finally(() => {\n              this.#closed = !0, callback(error);\n            });\n          return;\n        }\n        try {\n          callback(error);\n        } catch (error2) {\n          globalThis.reportError(error2);\n        }\n      }\n    }\n    _ReadableFromWebForUndici = ReadableFromWeb;\n    function newStreamReadableFromReadableStream(readableStream, options = {}) {\n      if (!isReadableStream(readableStream))\n        throw new ERR_INVALID_ARG_TYPE2(\"readableStream\", \"ReadableStream\", readableStream);\n      validateObject(options, \"options\");\n      const {\n        highWaterMark,\n        encoding,\n        objectMode = !1,\n        signal\n      } = options;\n      if (encoding !== void 0 && !Buffer.isEncoding(encoding))\n        throw new ERR_INVALID_ARG_VALUE(encoding, \"options.encoding\");\n      return validateBoolean(objectMode, \"options.objectMode\"), getNativeReadableStream(Readable, readableStream, options) || new ReadableFromWeb({\n        highWaterMark,\n        encoding,\n        objectMode,\n        signal\n      }, readableStream);\n    }\n    module.exports = Readable, _ReadableFromWeb = newStreamReadableFromReadableStream;\n    var { addAbortSignal } = require_add_abort_signal(), eos = require_end_of_stream();\n    const { maybeReadMore: _maybeReadMore, resume, emitReadable: _emitReadable, onEofChunk } = globalThis[globalThis.Symbol.for('Bun.lazy')](\"bun:stream\");\n    function maybeReadMore(stream, state) {\n      process.nextTick(_maybeReadMore, stream, state);\n    }\n    function emitReadable(stream, state) {\n      _emitReadable(stream, state);\n    }\n    var destroyImpl = require_destroy(), {\n      aggregateTwoErrors,\n      codes: {\n        ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE2,\n        ERR_METHOD_NOT_IMPLEMENTED,\n        ERR_OUT_OF_RANGE,\n        ERR_STREAM_PUSH_AFTER_EOF,\n        ERR_STREAM_UNSHIFT_AFTER_END_EVENT\n      }\n    } = require_errors(), { validateObject } = require_validators(), from = require_from(), nop = () => {\n    }, { errorOrDestroy: errorOrDestroy2 } = destroyImpl;\n    Readable.prototype.destroy = destroyImpl.destroy, Readable.prototype._undestroy = destroyImpl.undestroy, Readable.prototype._destroy = function(err, cb) {\n      cb(err);\n    }, Readable.prototype[EE.captureRejectionSymbol] = function(err) {\n      this.destroy(err);\n    }, Readable.prototype.push = function(chunk, encoding) {\n      return readableAddChunk(this, chunk, encoding, !1);\n    }, Readable.prototype.unshift = function(chunk, encoding) {\n      return readableAddChunk(this, chunk, encoding, !0);\n    };\n    function readableAddChunk(stream, chunk, encoding, addToFront) {\n      const state = stream._readableState;\n      let err;\n      if (!state.objectMode) {\n        if (typeof chunk === \"string\") {\n          if (encoding = encoding || state.defaultEncoding, state.encoding !== encoding)\n            if (addToFront && state.encoding)\n              chunk = Buffer.from(chunk, encoding).toString(state.encoding);\n            else\n              chunk = Buffer.from(chunk, encoding), encoding = \"\";\n        } else if (chunk instanceof Buffer)\n          encoding = \"\";\n        else if (Stream._isUint8Array(chunk)) {\n          if (addToFront || !state.decoder)\n            chunk = Stream._uint8ArrayToBuffer(chunk);\n          encoding = \"\";\n        } else if (chunk != null)\n          err = new ERR_INVALID_ARG_TYPE2(\"chunk\", [\"string\", \"Buffer\", \"Uint8Array\"], chunk);\n      }\n      if (err)\n        errorOrDestroy2(stream, err);\n      else if (chunk === null)\n        state.reading = !1, onEofChunk(stream, state);\n      else if (state.objectMode || chunk && chunk.length > 0)\n        if (addToFront)\n          if (state.endEmitted)\n            errorOrDestroy2(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT);\n          else if (state.destroyed || state.errored)\n            return !1;\n          else\n            addChunk(stream, state, chunk, !0);\n        else if (state.ended)\n          errorOrDestroy2(stream, new ERR_STREAM_PUSH_AFTER_EOF);\n        else if (state.destroyed || state.errored)\n          return !1;\n        else if (state.reading = !1, state.decoder && !encoding)\n          if (chunk = state.decoder.write(chunk), state.objectMode || chunk.length !== 0)\n            addChunk(stream, state, chunk, !1);\n          else\n            maybeReadMore(stream, state);\n        else\n          addChunk(stream, state, chunk, !1);\n      else if (!addToFront)\n        state.reading = !1, maybeReadMore(stream, state);\n      return !state.ended && (state.length < state.highWaterMark || state.length === 0);\n    }\n    function addChunk(stream, state, chunk, addToFront) {\n      if (state.flowing && state.length === 0 && !state.sync && stream.listenerCount(\"data\") > 0) {\n        if (state.multiAwaitDrain)\n          state.awaitDrainWriters.clear();\n        else\n          state.awaitDrainWriters = null;\n        state.dataEmitted = !0, stream.emit(\"data\", chunk);\n      } else {\n        if (state.length += state.objectMode \? 1 : chunk.length, addToFront)\n          state.buffer.unshift(chunk);\n        else\n          state.buffer.push(chunk);\n        if (state.needReadable)\n          emitReadable(stream, state);\n      }\n      maybeReadMore(stream, state);\n    }\n    Readable.prototype.isPaused = function() {\n      const state = this._readableState;\n      return state.paused === !0 || state.flowing === !1;\n    }, Readable.prototype.setEncoding = function(enc) {\n      const decoder = new StringDecoder(enc);\n      this._readableState.decoder = decoder, this._readableState.encoding = this._readableState.decoder.encoding;\n      const buffer = this._readableState.buffer;\n      let content = \"\";\n      for (let i = buffer.length;i > 0; i--)\n        content += decoder.write(buffer.shift());\n      if (content !== \"\")\n        buffer.push(content);\n      return this._readableState.length = content.length, this;\n    };\n    var MAX_HWM = 1073741824;\n    function computeNewHighWaterMark(n) {\n      if (n > MAX_HWM)\n        throw new ERR_OUT_OF_RANGE(\"size\", \"<= 1GiB\", n);\n      else\n        n--, n |= n >>> 1, n |= n >>> 2, n |= n >>> 4, n |= n >>> 8, n |= n >>> 16, n++;\n      return n;\n    }\n    function howMuchToRead(n, state) {\n      if (n <= 0 || state.length === 0 && state.ended)\n        return 0;\n      if (state.objectMode)\n        return 1;\n      if (NumberIsNaN(n)) {\n        if (state.flowing && state.length)\n          return state.buffer.first().length;\n        return state.length;\n      }\n      if (n <= state.length)\n        return n;\n      return state.ended \? state.length : 0;\n    }\n    Readable.prototype.read = function(n) {\n      if (!NumberIsInteger(n))\n        n = NumberParseInt(n, 10);\n      const state = this._readableState, nOrig = n;\n      if (n > state.highWaterMark)\n        state.highWaterMark = computeNewHighWaterMark(n);\n      if (n !== 0)\n        state.emittedReadable = !1;\n      if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 \? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {\n        if (state.length === 0 && state.ended)\n          endReadable(this);\n        else\n          emitReadable(this, state);\n        return null;\n      }\n      if (n = howMuchToRead(n, state), n === 0 && state.ended) {\n        if (state.length === 0)\n          endReadable(this);\n        return null;\n      }\n      let doRead = state.needReadable;\n      if (state.length === 0 || state.length - n < state.highWaterMark)\n        doRead = !0;\n      if (state.ended || state.reading || state.destroyed || state.errored || !state.constructed)\n        doRead = !1;\n      else if (doRead) {\n        if (state.reading = !0, state.sync = !0, state.length === 0)\n          state.needReadable = !0;\n        try {\n          var result = this._read(state.highWaterMark);\n          if (@isPromise(result)) {\n            const peeked = Bun.peek(result);\n            if (peeked !== result)\n              result = peeked;\n          }\n          if (@isPromise(result) && result\?.then && @isCallable(result.then))\n            result.then(nop, function(err) {\n              errorOrDestroy2(this, err);\n            });\n        } catch (err) {\n          errorOrDestroy2(this, err);\n        }\n        if (state.sync = !1, !state.reading)\n          n = howMuchToRead(nOrig, state);\n      }\n      let ret;\n      if (n > 0)\n        ret = fromList(n, state);\n      else\n        ret = null;\n      if (ret === null)\n        state.needReadable = state.length <= state.highWaterMark, n = 0;\n      else if (state.length -= n, state.multiAwaitDrain)\n        state.awaitDrainWriters.clear();\n      else\n        state.awaitDrainWriters = null;\n      if (state.length === 0) {\n        if (!state.ended)\n          state.needReadable = !0;\n        if (nOrig !== n && state.ended)\n          endReadable(this);\n      }\n      if (ret !== null && !state.errorEmitted && !state.closeEmitted)\n        state.dataEmitted = !0, this.emit(\"data\", ret);\n      return ret;\n    }, Readable.prototype._read = function(n) {\n      throw new ERR_METHOD_NOT_IMPLEMENTED(\"_read()\");\n    }, Readable.prototype.pipe = function(dest, pipeOpts) {\n      const src = this, state = this._readableState;\n      if (state.pipes.length === 1) {\n        if (!state.multiAwaitDrain)\n          state.multiAwaitDrain = !0, state.awaitDrainWriters = new SafeSet(state.awaitDrainWriters \? [state.awaitDrainWriters] : []);\n      }\n      state.pipes.push(dest);\n      const endFn = (!pipeOpts || pipeOpts.end !== !1) && dest !== process.stdout && dest !== process.stderr \? onend : unpipe;\n      if (state.endEmitted)\n        runOnNextTick(endFn);\n      else\n        src.once(\"end\", endFn);\n      dest.on(\"unpipe\", onunpipe);\n      function onunpipe(readable, unpipeInfo) {\n        if (readable === src) {\n          if (unpipeInfo && unpipeInfo.hasUnpiped === !1)\n            unpipeInfo.hasUnpiped = !0, cleanup();\n        }\n      }\n      function onend() {\n        dest.end();\n      }\n      let ondrain, cleanedUp = !1;\n      function cleanup() {\n        if (dest.removeListener(\"close\", onclose), dest.removeListener(\"finish\", onfinish), ondrain)\n          dest.removeListener(\"drain\", ondrain);\n        if (dest.removeListener(\"error\", onerror), dest.removeListener(\"unpipe\", onunpipe), src.removeListener(\"end\", onend), src.removeListener(\"end\", unpipe), src.removeListener(\"data\", ondata), cleanedUp = !0, ondrain && state.awaitDrainWriters && (!dest._writableState || dest._writableState.needDrain))\n          ondrain();\n      }\n      function pause() {\n        if (!cleanedUp) {\n          if (state.pipes.length === 1 && state.pipes[0] === dest)\n            state.awaitDrainWriters = dest, state.multiAwaitDrain = !1;\n          else if (state.pipes.length > 1 && state.pipes.includes(dest))\n            state.awaitDrainWriters.add(dest);\n          src.pause();\n        }\n        if (!ondrain)\n          ondrain = pipeOnDrain(src, dest), dest.on(\"drain\", ondrain);\n      }\n      src.on(\"data\", ondata);\n      function ondata(chunk) {\n        if (dest.write(chunk) === !1)\n          pause();\n      }\n      function onerror(er) {\n        if (unpipe(), dest.removeListener(\"error\", onerror), dest.listenerCount(\"error\") === 0) {\n          const s = dest._writableState || dest._readableState;\n          if (s && !s.errorEmitted)\n            errorOrDestroy2(dest, er);\n          else\n            dest.emit(\"error\", er);\n        }\n      }\n      prependListener(dest, \"error\", onerror);\n      function onclose() {\n        dest.removeListener(\"finish\", onfinish), unpipe();\n      }\n      dest.once(\"close\", onclose);\n      function onfinish() {\n        dest.removeListener(\"close\", onclose), unpipe();\n      }\n      dest.once(\"finish\", onfinish);\n      function unpipe() {\n        src.unpipe(dest);\n      }\n      if (dest.emit(\"pipe\", src), dest.writableNeedDrain === !0) {\n        if (state.flowing)\n          pause();\n      } else if (!state.flowing)\n        src.resume();\n      return dest;\n    };\n    function pipeOnDrain(src, dest) {\n      return function pipeOnDrainFunctionResult() {\n        const state = src._readableState;\n        if (state.awaitDrainWriters === dest)\n          state.awaitDrainWriters = null;\n        else if (state.multiAwaitDrain)\n          state.awaitDrainWriters.delete(dest);\n        if ((!state.awaitDrainWriters || state.awaitDrainWriters.size === 0) && src.listenerCount(\"data\"))\n          src.resume();\n      };\n    }\n    Readable.prototype.unpipe = function(dest) {\n      const state = this._readableState, unpipeInfo = {\n        hasUnpiped: !1\n      };\n      if (state.pipes.length === 0)\n        return this;\n      if (!dest) {\n        const dests = state.pipes;\n        state.pipes = [], this.pause();\n        for (let i = 0;i < dests.length; i++)\n          dests[i].emit(\"unpipe\", this, {\n            hasUnpiped: !1\n          });\n        return this;\n      }\n      const index = ArrayPrototypeIndexOf(state.pipes, dest);\n      if (index === -1)\n        return this;\n      if (state.pipes.splice(index, 1), state.pipes.length === 0)\n        this.pause();\n      return dest.emit(\"unpipe\", this, unpipeInfo), this;\n    }, Readable.prototype.addListener = Readable.prototype.on, Readable.prototype.removeListener = function(ev, fn) {\n      const res = Stream.prototype.removeListener.call(this, ev, fn);\n      if (ev === \"readable\")\n        runOnNextTick(updateReadableListening, this);\n      return res;\n    }, Readable.prototype.off = Readable.prototype.removeListener, Readable.prototype.removeAllListeners = function(ev) {\n      const res = Stream.prototype.removeAllListeners.apply(this, arguments);\n      if (ev === \"readable\" || ev === void 0)\n        runOnNextTick(updateReadableListening, this);\n      return res;\n    };\n    function updateReadableListening(self) {\n      const state = self._readableState;\n      if (state.readableListening = self.listenerCount(\"readable\") > 0, state.resumeScheduled && state.paused === !1)\n        state.flowing = !0;\n      else if (self.listenerCount(\"data\") > 0)\n        self.resume();\n      else if (!state.readableListening)\n        state.flowing = null;\n    }\n    function nReadingNextTick(self) {\n      self.read(0);\n    }\n    Readable.prototype.resume = function() {\n      const state = this._readableState;\n      if (!state.flowing)\n        state.flowing = !state.readableListening, resume(this, state);\n      return state.paused = !1, this;\n    }, Readable.prototype.pause = function() {\n      if (this._readableState.flowing !== !1)\n        this._readableState.flowing = !1, this.emit(\"pause\");\n      return this._readableState.paused = !0, this;\n    }, Readable.prototype.wrap = function(stream) {\n      let paused = !1;\n      stream.on(\"data\", (chunk) => {\n        if (!this.push(chunk) && stream.pause)\n          paused = !0, stream.pause();\n      }), stream.on(\"end\", () => {\n        this.push(null);\n      }), stream.on(\"error\", (err) => {\n        errorOrDestroy2(this, err);\n      }), stream.on(\"close\", () => {\n        this.destroy();\n      }), stream.on(\"destroy\", () => {\n        this.destroy();\n      }), this._read = () => {\n        if (paused && stream.resume)\n          paused = !1, stream.resume();\n      };\n      const streamKeys = ObjectKeys(stream);\n      for (let j = 1;j < streamKeys.length; j++) {\n        const i = streamKeys[j];\n        if (this[i] === void 0 && typeof stream[i] === \"function\")\n          this[i] = stream[i].bind(stream);\n      }\n      return this;\n    }, Readable.prototype[SymbolAsyncIterator] = function() {\n      return streamToAsyncIterator(this);\n    }, Readable.prototype.iterator = function(options) {\n      if (options !== void 0)\n        validateObject(options, \"options\");\n      return streamToAsyncIterator(this, options);\n    };\n    function streamToAsyncIterator(stream, options) {\n      if (typeof stream.read !== \"function\")\n        stream = Readable.wrap(stream, {\n          objectMode: !0\n        });\n      const iter = createAsyncIterator(stream, options);\n      return iter.stream = stream, iter;\n    }\n    async function* createAsyncIterator(stream, options) {\n      let callback = nop;\n      function next(resolve) {\n        if (this === stream)\n          callback(), callback = nop;\n        else\n          callback = resolve;\n      }\n      stream.on(\"readable\", next);\n      let error;\n      const cleanup = eos(stream, {\n        writable: !1\n      }, (err) => {\n        error = err \? aggregateTwoErrors(error, err) : null, callback(), callback = nop;\n      });\n      try {\n        while (!0) {\n          const chunk = stream.destroyed \? null : stream.read();\n          if (chunk !== null)\n            yield chunk;\n          else if (error)\n            throw error;\n          else if (error === null)\n            return;\n          else\n            await new Promise2(next);\n        }\n      } catch (err) {\n        throw error = aggregateTwoErrors(error, err), error;\n      } finally {\n        if ((error || (options === null || options === void 0 \? void 0 : options.destroyOnReturn) !== !1) && (error === void 0 || stream._readableState.autoDestroy))\n          destroyImpl.destroyer(stream, null);\n        else\n          stream.off(\"readable\", next), cleanup();\n      }\n    }\n    ObjectDefineProperties(Readable.prototype, {\n      readable: {\n        get() {\n          const r = this._readableState;\n          return !!r && r.readable !== !1 && !r.destroyed && !r.errorEmitted && !r.endEmitted;\n        },\n        set(val) {\n          if (this._readableState)\n            this._readableState.readable = !!val;\n        }\n      },\n      readableDidRead: {\n        enumerable: !1,\n        get: function() {\n          return this._readableState.dataEmitted;\n        }\n      },\n      readableAborted: {\n        enumerable: !1,\n        get: function() {\n          return !!(this._readableState.readable !== !1 && (this._readableState.destroyed || this._readableState.errored) && !this._readableState.endEmitted);\n        }\n      },\n      readableHighWaterMark: {\n        enumerable: !1,\n        get: function() {\n          return this._readableState.highWaterMark;\n        }\n      },\n      readableBuffer: {\n        enumerable: !1,\n        get: function() {\n          return this._readableState && this._readableState.buffer;\n        }\n      },\n      readableFlowing: {\n        enumerable: !1,\n        get: function() {\n          return this._readableState.flowing;\n        },\n        set: function(state) {\n          if (this._readableState)\n            this._readableState.flowing = state;\n        }\n      },\n      readableLength: {\n        enumerable: !1,\n        get() {\n          return this._readableState.length;\n        }\n      },\n      readableObjectMode: {\n        enumerable: !1,\n        get() {\n          return this._readableState \? this._readableState.objectMode : !1;\n        }\n      },\n      readableEncoding: {\n        enumerable: !1,\n        get() {\n          return this._readableState \? this._readableState.encoding : null;\n        }\n      },\n      errored: {\n        enumerable: !1,\n        get() {\n          return this._readableState \? this._readableState.errored : null;\n        }\n      },\n      closed: {\n        get() {\n          return this._readableState \? this._readableState.closed : !1;\n        }\n      },\n      destroyed: {\n        enumerable: !1,\n        get() {\n          return this._readableState \? this._readableState.destroyed : !1;\n        },\n        set(value) {\n          if (!this._readableState)\n            return;\n          this._readableState.destroyed = value;\n        }\n      },\n      readableEnded: {\n        enumerable: !1,\n        get() {\n          return this._readableState \? this._readableState.endEmitted : !1;\n        }\n      }\n    }), Readable._fromList = fromList;\n    function fromList(n, state) {\n      if (state.length === 0)\n        return null;\n      let ret;\n      if (state.objectMode)\n        ret = state.buffer.shift();\n      else if (!n || n >= state.length) {\n        if (state.decoder)\n          ret = state.buffer.join(\"\");\n        else if (state.buffer.length === 1)\n          ret = state.buffer.first();\n        else\n          ret = state.buffer.concat(state.length);\n        state.buffer.clear();\n      } else\n        ret = state.buffer.consume(n, state.decoder);\n      return ret;\n    }\n    function endReadable(stream) {\n      const state = stream._readableState;\n      if (!state.endEmitted)\n        state.ended = !0, runOnNextTick(endReadableNT, state, stream);\n    }\n    function endReadableNT(state, stream) {\n      if (!state.errored && !state.closeEmitted && !state.endEmitted && state.length === 0) {\n        if (state.endEmitted = !0, stream.emit(\"end\"), stream.writable && stream.allowHalfOpen === !1)\n          runOnNextTick(endWritableNT, stream);\n        else if (state.autoDestroy) {\n          const wState = stream._writableState;\n          if (!wState || wState.autoDestroy && (wState.finished || wState.writable === !1))\n            stream.destroy();\n        }\n      }\n    }\n    function endWritableNT(stream) {\n      if (stream.writable && !stream.writableEnded && !stream.destroyed)\n        stream.end();\n    }\n    Readable.from = function(iterable, opts) {\n      return from(Readable, iterable, opts);\n    };\n    var webStreamsAdapters = {\n      newStreamReadableFromReadableStream,\n      newReadableStreamFromStreamReadable(streamReadable, options = {}) {\n        if (typeof streamReadable\?._readableState !== \"object\")\n          throw new ERR_INVALID_ARG_TYPE2(\"streamReadable\", \"stream.Readable\", streamReadable);\n        var { isDestroyed, isReadable } = require_utils();\n        if (isDestroyed(streamReadable) || !isReadable(streamReadable)) {\n          const readable = new ReadableStream;\n          return readable.cancel(), readable;\n        }\n        const { readableObjectMode: objectMode, readableHighWaterMark: highWaterMark } = streamReadable, strategy = ((strategy2) => {\n          if (strategy2)\n            return strategy2;\n          if (objectMode)\n            return new CountQueuingStrategy({ highWaterMark });\n          return { highWaterMark };\n        })(options\?.strategy);\n        let controller;\n        function onData(chunk) {\n          if (controller.enqueue(chunk), controller.desiredSize <= 0)\n            streamReadable.pause();\n        }\n        streamReadable.pause();\n        const cleanup = finished(streamReadable, (error) => {\n          if (error\?.code === \"ERR_STREAM_PREMATURE_CLOSE\")\n            error = new AbortError(void 0, { cause: error });\n          if (cleanup(), streamReadable.on(\"error\", () => {\n          }), error)\n            return controller.error(error);\n          controller.close();\n        });\n        return streamReadable.on(\"data\", onData), new ReadableStream({\n          start(c) {\n            controller = c;\n          },\n          pull() {\n            streamReadable.resume();\n          },\n          cancel(reason) {\n            destroy(streamReadable, reason);\n          }\n        }, strategy);\n      }\n    };\n    Readable.fromWeb = function(readableStream, options) {\n      return webStreamsAdapters.newStreamReadableFromReadableStream(readableStream, options);\n    }, Readable.toWeb = function(streamReadable, options) {\n      return webStreamsAdapters.newReadableStreamFromStreamReadable(streamReadable, options);\n    }, Readable.wrap = function(src, options) {\n      var _ref, _src$readableObjectMo;\n      return new Readable({\n        objectMode: (_ref = (_src$readableObjectMo = src.readableObjectMode) !== null && _src$readableObjectMo !== void 0 \? _src$readableObjectMo : src.objectMode) !== null && _ref !== void 0 \? _ref : !0,\n        ...options,\n        destroy(err, callback) {\n          destroyImpl.destroyer(src, err), callback(err);\n        }\n      }).wrap(src);\n    };\n  }\n}), require_writable = __commonJS({\n  \"node_modules/readable-stream/lib/internal/streams/writable.js\"(exports, module) {\n    var {\n      ArrayPrototypeSlice,\n      Error: Error2,\n      FunctionPrototypeSymbolHasInstance,\n      ObjectDefineProperty,\n      ObjectDefineProperties,\n      ObjectSetPrototypeOf,\n      StringPrototypeToLowerCase,\n      Symbol: Symbol2,\n      SymbolHasInstance\n    } = require_primordials(), Stream = require_legacy().Stream, destroyImpl = require_destroy(), { addAbortSignal } = require_add_abort_signal(), { getHighWaterMark, getDefaultHighWaterMark } = require_state(), {\n      ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE2,\n      ERR_METHOD_NOT_IMPLEMENTED,\n      ERR_MULTIPLE_CALLBACK,\n      ERR_STREAM_CANNOT_PIPE,\n      ERR_STREAM_DESTROYED,\n      ERR_STREAM_ALREADY_FINISHED,\n      ERR_STREAM_NULL_VALUES,\n      ERR_STREAM_WRITE_AFTER_END,\n      ERR_UNKNOWN_ENCODING\n    } = require_errors().codes, { errorOrDestroy: errorOrDestroy2 } = destroyImpl;\n    function Writable(options = {}) {\n      const isDuplex = this instanceof require_duplex();\n      if (!isDuplex && !FunctionPrototypeSymbolHasInstance(Writable, this))\n        return new Writable(options);\n      if (this._writableState = new WritableState(options, this, isDuplex), options) {\n        if (typeof options.write === \"function\")\n          this._write = options.write;\n        if (typeof options.writev === \"function\")\n          this._writev = options.writev;\n        if (typeof options.destroy === \"function\")\n          this._destroy = options.destroy;\n        if (typeof options.final === \"function\")\n          this._final = options.final;\n        if (typeof options.construct === \"function\")\n          this._construct = options.construct;\n        if (options.signal)\n          addAbortSignal(options.signal, this);\n      }\n      Stream.call(this, options), destroyImpl.construct(this, () => {\n        const state = this._writableState;\n        if (!state.writing)\n          clearBuffer(this, state);\n        finishMaybe(this, state);\n      });\n    }\n    Writable.prototype = {}, ObjectSetPrototypeOf(Writable.prototype, Stream.prototype), ObjectSetPrototypeOf(Writable, Stream), module.exports = Writable;\n    function nop() {\n    }\n    var kOnFinished = Symbol2(\"kOnFinished\");\n    function WritableState(options, stream, isDuplex) {\n      if (typeof isDuplex !== \"boolean\")\n        isDuplex = stream instanceof require_duplex();\n      if (this.objectMode = !!(options && options.objectMode), isDuplex)\n        this.objectMode = this.objectMode || !!(options && options.writableObjectMode);\n      this.highWaterMark = options \? getHighWaterMark(this, options, \"writableHighWaterMark\", isDuplex) : getDefaultHighWaterMark(!1), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;\n      const noDecode = !!(options && options.decodeStrings === !1);\n      this.decodeStrings = !noDecode, this.defaultEncoding = options && options.defaultEncoding || \"utf8\", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = onwrite.bind(void 0, stream), this.writecb = null, this.writelen = 0, this.afterWriteTickInfo = null, resetBuffer(this), this.pendingcb = 0, this.constructed = !0, this.prefinished = !1, this.errorEmitted = !1, this.emitClose = !options || options.emitClose !== !1, this.autoDestroy = !options || options.autoDestroy !== !1, this.errored = null, this.closed = !1, this.closeEmitted = !1, this[kOnFinished] = [];\n    }\n    WritableState.prototype = {};\n    function resetBuffer(state) {\n      state.buffered = [], state.bufferedIndex = 0, state.allBuffers = !0, state.allNoop = !0;\n    }\n    WritableState.prototype.getBuffer = function getBuffer() {\n      return ArrayPrototypeSlice(this.buffered, this.bufferedIndex);\n    }, ObjectDefineProperty(WritableState.prototype, \"bufferedRequestCount\", {\n      get() {\n        return this.buffered.length - this.bufferedIndex;\n      }\n    }), ObjectDefineProperty(Writable, SymbolHasInstance, {\n      value: function(object) {\n        if (FunctionPrototypeSymbolHasInstance(this, object))\n          return !0;\n        if (this !== Writable)\n          return !1;\n        return object && object._writableState instanceof WritableState;\n      }\n    }), Writable.prototype.pipe = function() {\n      errorOrDestroy2(this, new ERR_STREAM_CANNOT_PIPE);\n    };\n    function _write(stream, chunk, encoding, cb) {\n      const state = stream._writableState;\n      if (typeof encoding === \"function\")\n        cb = encoding, encoding = state.defaultEncoding;\n      else {\n        if (!encoding)\n          encoding = state.defaultEncoding;\n        else if (encoding !== \"buffer\" && !Buffer.isEncoding(encoding))\n          throw new ERR_UNKNOWN_ENCODING(encoding);\n        if (typeof cb !== \"function\")\n          cb = nop;\n      }\n      if (chunk === null)\n        throw new ERR_STREAM_NULL_VALUES;\n      else if (!state.objectMode)\n        if (typeof chunk === \"string\") {\n          if (state.decodeStrings !== !1)\n            chunk = Buffer.from(chunk, encoding), encoding = \"buffer\";\n        } else if (chunk instanceof Buffer)\n          encoding = \"buffer\";\n        else if (Stream._isUint8Array(chunk))\n          chunk = Stream._uint8ArrayToBuffer(chunk), encoding = \"buffer\";\n        else\n          throw new ERR_INVALID_ARG_TYPE2(\"chunk\", [\"string\", \"Buffer\", \"Uint8Array\"], chunk);\n      let err;\n      if (state.ending)\n        err = new ERR_STREAM_WRITE_AFTER_END;\n      else if (state.destroyed)\n        err = new ERR_STREAM_DESTROYED(\"write\");\n      if (err)\n        return runOnNextTick(cb, err), errorOrDestroy2(stream, err, !0), err;\n      return state.pendingcb++, writeOrBuffer(stream, state, chunk, encoding, cb);\n    }\n    Writable.prototype.write = function(chunk, encoding, cb) {\n      return _write(this, chunk, encoding, cb) === !0;\n    }, Writable.prototype.cork = function() {\n      this._writableState.corked++;\n    }, Writable.prototype.uncork = function() {\n      const state = this._writableState;\n      if (state.corked) {\n        if (state.corked--, !state.writing)\n          clearBuffer(this, state);\n      }\n    }, Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {\n      if (typeof encoding === \"string\")\n        encoding = StringPrototypeToLowerCase(encoding);\n      if (!Buffer.isEncoding(encoding))\n        throw new ERR_UNKNOWN_ENCODING(encoding);\n      return this._writableState.defaultEncoding = encoding, this;\n    };\n    function writeOrBuffer(stream, state, chunk, encoding, callback) {\n      const len = state.objectMode \? 1 : chunk.length;\n      state.length += len;\n      const ret = state.length < state.highWaterMark;\n      if (!ret)\n        state.needDrain = !0;\n      if (state.writing || state.corked || state.errored || !state.constructed) {\n        if (state.buffered.push({\n          chunk,\n          encoding,\n          callback\n        }), state.allBuffers && encoding !== \"buffer\")\n          state.allBuffers = !1;\n        if (state.allNoop && callback !== nop)\n          state.allNoop = !1;\n      } else\n        state.writelen = len, state.writecb = callback, state.writing = !0, state.sync = !0, stream._write(chunk, encoding, state.onwrite), state.sync = !1;\n      return ret && !state.errored && !state.destroyed;\n    }\n    function doWrite(stream, state, writev, len, chunk, encoding, cb) {\n      if (state.writelen = len, state.writecb = cb, state.writing = !0, state.sync = !0, state.destroyed)\n        state.onwrite(new ERR_STREAM_DESTROYED(\"write\"));\n      else if (writev)\n        stream._writev(chunk, state.onwrite);\n      else\n        stream._write(chunk, encoding, state.onwrite);\n      state.sync = !1;\n    }\n    function onwriteError(stream, state, er, cb) {\n      --state.pendingcb, cb(er), errorBuffer(state), errorOrDestroy2(stream, er);\n    }\n    function onwrite(stream, er) {\n      const state = stream._writableState, sync = state.sync, cb = state.writecb;\n      if (typeof cb !== \"function\") {\n        errorOrDestroy2(stream, new ERR_MULTIPLE_CALLBACK);\n        return;\n      }\n      if (state.writing = !1, state.writecb = null, state.length -= state.writelen, state.writelen = 0, er) {\n        if (Error.captureStackTrace(er), !state.errored)\n          state.errored = er;\n        if (stream._readableState && !stream._readableState.errored)\n          stream._readableState.errored = er;\n        if (sync)\n          runOnNextTick(onwriteError, stream, state, er, cb);\n        else\n          onwriteError(stream, state, er, cb);\n      } else {\n        if (state.buffered.length > state.bufferedIndex)\n          clearBuffer(stream, state);\n        if (sync)\n          if (state.afterWriteTickInfo !== null && state.afterWriteTickInfo.cb === cb)\n            state.afterWriteTickInfo.count++;\n          else\n            state.afterWriteTickInfo = {\n              count: 1,\n              cb,\n              stream,\n              state\n            }, runOnNextTick(afterWriteTick, state.afterWriteTickInfo);\n        else\n          afterWrite(stream, state, 1, cb);\n      }\n    }\n    function afterWriteTick({ stream, state, count, cb }) {\n      return state.afterWriteTickInfo = null, afterWrite(stream, state, count, cb);\n    }\n    function afterWrite(stream, state, count, cb) {\n      if (!state.ending && !stream.destroyed && state.length === 0 && state.needDrain)\n        state.needDrain = !1, stream.emit(\"drain\");\n      while (count-- > 0)\n        state.pendingcb--, cb();\n      if (state.destroyed)\n        errorBuffer(state);\n      finishMaybe(stream, state);\n    }\n    function errorBuffer(state) {\n      if (state.writing)\n        return;\n      for (let n = state.bufferedIndex;n < state.buffered.length; ++n) {\n        var _state$errored;\n        const { chunk, callback } = state.buffered[n], len = state.objectMode \? 1 : chunk.length;\n        state.length -= len, callback((_state$errored = state.errored) !== null && _state$errored !== void 0 \? _state$errored : new ERR_STREAM_DESTROYED(\"write\"));\n      }\n      const onfinishCallbacks = state[kOnFinished].splice(0);\n      for (let i = 0;i < onfinishCallbacks.length; i++) {\n        var _state$errored2;\n        onfinishCallbacks[i]((_state$errored2 = state.errored) !== null && _state$errored2 !== void 0 \? _state$errored2 : new ERR_STREAM_DESTROYED(\"end\"));\n      }\n      resetBuffer(state);\n    }\n    function clearBuffer(stream, state) {\n      if (state.corked || state.bufferProcessing || state.destroyed || !state.constructed)\n        return;\n      const { buffered, bufferedIndex, objectMode } = state, bufferedLength = buffered.length - bufferedIndex;\n      if (!bufferedLength)\n        return;\n      let i = bufferedIndex;\n      if (state.bufferProcessing = !0, bufferedLength > 1 && stream._writev) {\n        state.pendingcb -= bufferedLength - 1;\n        const callback = state.allNoop \? nop : (err) => {\n          for (let n = i;n < buffered.length; ++n)\n            buffered[n].callback(err);\n        }, chunks = state.allNoop && i === 0 \? buffered : ArrayPrototypeSlice(buffered, i);\n        chunks.allBuffers = state.allBuffers, doWrite(stream, state, !0, state.length, chunks, \"\", callback), resetBuffer(state);\n      } else {\n        do {\n          const { chunk, encoding, callback } = buffered[i];\n          buffered[i++] = null;\n          const len = objectMode \? 1 : chunk.length;\n          doWrite(stream, state, !1, len, chunk, encoding, callback);\n        } while (i < buffered.length && !state.writing);\n        if (i === buffered.length)\n          resetBuffer(state);\n        else if (i > 256)\n          buffered.splice(0, i), state.bufferedIndex = 0;\n        else\n          state.bufferedIndex = i;\n      }\n      state.bufferProcessing = !1;\n    }\n    Writable.prototype._write = function(chunk, encoding, cb) {\n      if (this._writev)\n        this._writev([\n          {\n            chunk,\n            encoding\n          }\n        ], cb);\n      else\n        throw new ERR_METHOD_NOT_IMPLEMENTED(\"_write()\");\n    }, Writable.prototype._writev = null, Writable.prototype.end = function(chunk, encoding, cb, native = !1) {\n      const state = this._writableState;\n      if (typeof chunk === \"function\")\n        cb = chunk, chunk = null, encoding = null;\n      else if (typeof encoding === \"function\")\n        cb = encoding, encoding = null;\n      let err;\n      if (chunk !== null && chunk !== void 0) {\n        let ret;\n        if (!native)\n          ret = _write(this, chunk, encoding);\n        else\n          ret = this.write(chunk, encoding);\n        if (ret instanceof Error2)\n          err = ret;\n      }\n      if (state.corked)\n        state.corked = 1, this.uncork();\n      if (err)\n        this.emit(\"error\", err);\n      else if (!state.errored && !state.ending)\n        state.ending = !0, finishMaybe(this, state, !0), state.ended = !0;\n      else if (state.finished)\n        err = new ERR_STREAM_ALREADY_FINISHED(\"end\");\n      else if (state.destroyed)\n        err = new ERR_STREAM_DESTROYED(\"end\");\n      if (typeof cb === \"function\")\n        if (err || state.finished)\n          runOnNextTick(cb, err);\n        else\n          state[kOnFinished].push(cb);\n      return this;\n    };\n    function needFinish(state, tag) {\n      var needFinish2 = state.ending && !state.destroyed && state.constructed && state.length === 0 && !state.errored && state.buffered.length === 0 && !state.finished && !state.writing && !state.errorEmitted && !state.closeEmitted;\n      return needFinish2;\n    }\n    function callFinal(stream, state) {\n      let called = !1;\n      function onFinish(err) {\n        if (called) {\n          errorOrDestroy2(stream, err !== null && err !== void 0 \? err : ERR_MULTIPLE_CALLBACK());\n          return;\n        }\n        if (called = !0, state.pendingcb--, err) {\n          const onfinishCallbacks = state[kOnFinished].splice(0);\n          for (let i = 0;i < onfinishCallbacks.length; i++)\n            onfinishCallbacks[i](err);\n          errorOrDestroy2(stream, err, state.sync);\n        } else if (needFinish(state))\n          state.prefinished = !0, stream.emit(\"prefinish\"), state.pendingcb++, runOnNextTick(finish, stream, state);\n      }\n      state.sync = !0, state.pendingcb++;\n      try {\n        stream._final(onFinish);\n      } catch (err) {\n        onFinish(err);\n      }\n      state.sync = !1;\n    }\n    function prefinish(stream, state) {\n      if (!state.prefinished && !state.finalCalled)\n        if (typeof stream._final === \"function\" && !state.destroyed)\n          state.finalCalled = !0, callFinal(stream, state);\n        else\n          state.prefinished = !0, stream.emit(\"prefinish\");\n    }\n    function finishMaybe(stream, state, sync) {\n      if (!needFinish(state, stream.__id))\n        return;\n      if (prefinish(stream, state), state.pendingcb === 0) {\n        if (sync)\n          state.pendingcb++, runOnNextTick((stream2, state2) => {\n            if (needFinish(state2))\n              finish(stream2, state2);\n            else\n              state2.pendingcb--;\n          }, stream, state);\n        else if (needFinish(state))\n          state.pendingcb++, finish(stream, state);\n      }\n    }\n    function finish(stream, state) {\n      state.pendingcb--, state.finished = !0;\n      const onfinishCallbacks = state[kOnFinished].splice(0);\n      for (let i = 0;i < onfinishCallbacks.length; i++)\n        onfinishCallbacks[i]();\n      if (stream.emit(\"finish\"), state.autoDestroy) {\n        const rState = stream._readableState;\n        if (!rState || rState.autoDestroy && (rState.endEmitted || rState.readable === !1))\n          stream.destroy();\n      }\n    }\n    ObjectDefineProperties(Writable.prototype, {\n      closed: {\n        get() {\n          return this._writableState \? this._writableState.closed : !1;\n        }\n      },\n      destroyed: {\n        get() {\n          return this._writableState \? this._writableState.destroyed : !1;\n        },\n        set(value) {\n          if (this._writableState)\n            this._writableState.destroyed = value;\n        }\n      },\n      writable: {\n        get() {\n          const w = this._writableState;\n          return !!w && w.writable !== !1 && !w.destroyed && !w.errored && !w.ending && !w.ended;\n        },\n        set(val) {\n          if (this._writableState)\n            this._writableState.writable = !!val;\n        }\n      },\n      writableFinished: {\n        get() {\n          return this._writableState \? this._writableState.finished : !1;\n        }\n      },\n      writableObjectMode: {\n        get() {\n          return this._writableState \? this._writableState.objectMode : !1;\n        }\n      },\n      writableBuffer: {\n        get() {\n          return this._writableState && this._writableState.getBuffer();\n        }\n      },\n      writableEnded: {\n        get() {\n          return this._writableState \? this._writableState.ending : !1;\n        }\n      },\n      writableNeedDrain: {\n        get() {\n          const wState = this._writableState;\n          if (!wState)\n            return !1;\n          return !wState.destroyed && !wState.ending && wState.needDrain;\n        }\n      },\n      writableHighWaterMark: {\n        get() {\n          return this._writableState && this._writableState.highWaterMark;\n        }\n      },\n      writableCorked: {\n        get() {\n          return this._writableState \? this._writableState.corked : 0;\n        }\n      },\n      writableLength: {\n        get() {\n          return this._writableState && this._writableState.length;\n        }\n      },\n      errored: {\n        enumerable: !1,\n        get() {\n          return this._writableState \? this._writableState.errored : null;\n        }\n      },\n      writableAborted: {\n        enumerable: !1,\n        get: function() {\n          return !!(this._writableState.writable !== !1 && (this._writableState.destroyed || this._writableState.errored) && !this._writableState.finished);\n        }\n      }\n    });\n    var destroy2 = destroyImpl.destroy;\n    Writable.prototype.destroy = function(err, cb) {\n      const state = this._writableState;\n      if (!state.destroyed && (state.bufferedIndex < state.buffered.length || state[kOnFinished].length))\n        runOnNextTick(errorBuffer, state);\n      return destroy2.call(this, err, cb), this;\n    }, Writable.prototype._undestroy = destroyImpl.undestroy, Writable.prototype._destroy = function(err, cb) {\n      cb(err);\n    }, Writable.prototype[EE.captureRejectionSymbol] = function(err) {\n      this.destroy(err);\n    };\n    var webStreamsAdapters;\n    function lazyWebStreams() {\n      if (webStreamsAdapters === void 0)\n        webStreamsAdapters = {};\n      return webStreamsAdapters;\n    }\n    Writable.fromWeb = function(writableStream, options) {\n      return lazyWebStreams().newStreamWritableFromWritableStream(writableStream, options);\n    }, Writable.toWeb = function(streamWritable) {\n      return lazyWebStreams().newWritableStreamFromStreamWritable(streamWritable);\n    };\n  }\n}), require_duplexify = __commonJS({\n  \"node_modules/readable-stream/lib/internal/streams/duplexify.js\"(exports, module) {\n    var {\n      isReadable,\n      isWritable,\n      isIterable,\n      isNodeStream,\n      isReadableNodeStream,\n      isWritableNodeStream,\n      isDuplexNodeStream\n    } = require_utils(), eos = require_end_of_stream(), {\n      AbortError: AbortError2,\n      codes: { ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE2, ERR_INVALID_RETURN_VALUE }\n    } = require_errors(), { destroyer } = require_destroy(), Duplex = require_duplex(), Readable = require_readable(), { createDeferredPromise } = require_util(), from = require_from(), isBlob = typeof Blob !== \"undefined\" \? function isBlob2(b) {\n      return b instanceof Blob;\n    } : function isBlob2(b) {\n      return !1;\n    }, { FunctionPrototypeCall } = require_primordials();\n\n    class Duplexify extends Duplex {\n      constructor(options) {\n        super(options);\n        if ((options === null || options === void 0 \? void 0 : options.readable) === !1)\n          this._readableState.readable = !1, this._readableState.ended = !0, this._readableState.endEmitted = !0;\n        if ((options === null || options === void 0 \? void 0 : options.writable) === !1)\n          this._writableState.writable = !1, this._writableState.ending = !0, this._writableState.ended = !0, this._writableState.finished = !0;\n      }\n    }\n    module.exports = function duplexify(body, name) {\n      if (isDuplexNodeStream(body))\n        return body;\n      if (isReadableNodeStream(body))\n        return _duplexify({\n          readable: body\n        });\n      if (isWritableNodeStream(body))\n        return _duplexify({\n          writable: body\n        });\n      if (isNodeStream(body))\n        return _duplexify({\n          writable: !1,\n          readable: !1\n        });\n      if (typeof body === \"function\") {\n        const { value, write, final, destroy: destroy2 } = fromAsyncGen(body);\n        if (isIterable(value))\n          return from(Duplexify, value, {\n            objectMode: !0,\n            write,\n            final,\n            destroy: destroy2\n          });\n        const then2 = value === null || value === void 0 \? void 0 : value.then;\n        if (typeof then2 === \"function\") {\n          let d;\n          const promise = FunctionPrototypeCall(then2, value, (val) => {\n            if (val != null)\n              throw new ERR_INVALID_RETURN_VALUE(\"nully\", \"body\", val);\n          }, (err) => {\n            destroyer(d, err);\n          });\n          return d = new Duplexify({\n            objectMode: !0,\n            readable: !1,\n            write,\n            final(cb) {\n              final(async () => {\n                try {\n                  await promise, runOnNextTick(cb, null);\n                } catch (err) {\n                  runOnNextTick(cb, err);\n                }\n              });\n            },\n            destroy: destroy2\n          });\n        }\n        throw new ERR_INVALID_RETURN_VALUE(\"Iterable, AsyncIterable or AsyncFunction\", name, value);\n      }\n      if (isBlob(body))\n        return duplexify(body.arrayBuffer());\n      if (isIterable(body))\n        return from(Duplexify, body, {\n          objectMode: !0,\n          writable: !1\n        });\n      if (typeof (body === null || body === void 0 \? void 0 : body.writable) === \"object\" || typeof (body === null || body === void 0 \? void 0 : body.readable) === \"object\") {\n        const readable = body !== null && body !== void 0 && body.readable \? isReadableNodeStream(body === null || body === void 0 \? void 0 : body.readable) \? body === null || body === void 0 \? void 0 : body.readable : duplexify(body.readable) : void 0, writable = body !== null && body !== void 0 && body.writable \? isWritableNodeStream(body === null || body === void 0 \? void 0 : body.writable) \? body === null || body === void 0 \? void 0 : body.writable : duplexify(body.writable) : void 0;\n        return _duplexify({\n          readable,\n          writable\n        });\n      }\n      const then = body === null || body === void 0 \? void 0 : body.then;\n      if (typeof then === \"function\") {\n        let d;\n        return FunctionPrototypeCall(then, body, (val) => {\n          if (val != null)\n            d.push(val);\n          d.push(null);\n        }, (err) => {\n          destroyer(d, err);\n        }), d = new Duplexify({\n          objectMode: !0,\n          writable: !1,\n          read() {\n          }\n        });\n      }\n      throw new ERR_INVALID_ARG_TYPE2(name, [\n        \"Blob\",\n        \"ReadableStream\",\n        \"WritableStream\",\n        \"Stream\",\n        \"Iterable\",\n        \"AsyncIterable\",\n        \"Function\",\n        \"{ readable, writable } pair\",\n        \"Promise\"\n      ], body);\n    };\n    function fromAsyncGen(fn) {\n      let { promise, resolve } = createDeferredPromise();\n      const ac = new AbortController, signal = ac.signal;\n      return {\n        value: fn(async function* () {\n          while (!0) {\n            const _promise = promise;\n            promise = null;\n            const { chunk, done, cb } = await _promise;\n            if (runOnNextTick(cb), done)\n              return;\n            if (signal.aborted)\n              throw new AbortError2(void 0, {\n                cause: signal.reason\n              });\n            ({ promise, resolve } = createDeferredPromise()), yield chunk;\n          }\n        }(), {\n          signal\n        }),\n        write(chunk, encoding, cb) {\n          const _resolve = resolve;\n          resolve = null, _resolve({\n            chunk,\n            done: !1,\n            cb\n          });\n        },\n        final(cb) {\n          const _resolve = resolve;\n          resolve = null, _resolve({\n            done: !0,\n            cb\n          });\n        },\n        destroy(err, cb) {\n          ac.abort(), cb(err);\n        }\n      };\n    }\n    function _duplexify(pair) {\n      const r = pair.readable && typeof pair.readable.read !== \"function\" \? Readable.wrap(pair.readable) : pair.readable, w = pair.writable;\n      let readable = !!isReadable(r), writable = !!isWritable(w), ondrain, onfinish, onreadable, onclose, d;\n      function onfinished(err) {\n        const cb = onclose;\n        if (onclose = null, cb)\n          cb(err);\n        else if (err)\n          d.destroy(err);\n        else if (!readable && !writable)\n          d.destroy();\n      }\n      if (d = new Duplexify({\n        readableObjectMode: !!(r !== null && r !== void 0 && r.readableObjectMode),\n        writableObjectMode: !!(w !== null && w !== void 0 && w.writableObjectMode),\n        readable,\n        writable\n      }), writable)\n        eos(w, (err) => {\n          if (writable = !1, err)\n            destroyer(r, err);\n          onfinished(err);\n        }), d._write = function(chunk, encoding, callback) {\n          if (w.write(chunk, encoding))\n            callback();\n          else\n            ondrain = callback;\n        }, d._final = function(callback) {\n          w.end(), onfinish = callback;\n        }, w.on(\"drain\", function() {\n          if (ondrain) {\n            const cb = ondrain;\n            ondrain = null, cb();\n          }\n        }), w.on(\"finish\", function() {\n          if (onfinish) {\n            const cb = onfinish;\n            onfinish = null, cb();\n          }\n        });\n      if (readable)\n        eos(r, (err) => {\n          if (readable = !1, err)\n            destroyer(r, err);\n          onfinished(err);\n        }), r.on(\"readable\", function() {\n          if (onreadable) {\n            const cb = onreadable;\n            onreadable = null, cb();\n          }\n        }), r.on(\"end\", function() {\n          d.push(null);\n        }), d._read = function() {\n          while (!0) {\n            const buf = r.read();\n            if (buf === null) {\n              onreadable = d._read;\n              return;\n            }\n            if (!d.push(buf))\n              return;\n          }\n        };\n      return d._destroy = function(err, callback) {\n        if (!err && onclose !== null)\n          err = new AbortError2;\n        if (onreadable = null, ondrain = null, onfinish = null, onclose === null)\n          callback(err);\n        else\n          onclose = callback, destroyer(w, err), destroyer(r, err);\n      }, d;\n    }\n  }\n}), require_duplex = __commonJS({\n  \"node_modules/readable-stream/lib/internal/streams/duplex.js\"(exports, module) {\n    var { ObjectDefineProperties, ObjectGetOwnPropertyDescriptor, ObjectKeys, ObjectSetPrototypeOf } = require_primordials(), Readable = require_readable();\n    function Duplex(options) {\n      if (!(this instanceof Duplex))\n        return new Duplex(options);\n      if (Readable.call(this, options), Writable.call(this, options), options) {\n        if (this.allowHalfOpen = options.allowHalfOpen !== !1, options.readable === !1)\n          this._readableState.readable = !1, this._readableState.ended = !0, this._readableState.endEmitted = !0;\n        if (options.writable === !1)\n          this._writableState.writable = !1, this._writableState.ending = !0, this._writableState.ended = !0, this._writableState.finished = !0;\n      } else\n        this.allowHalfOpen = !0;\n    }\n    Duplex.prototype = {}, module.exports = Duplex, ObjectSetPrototypeOf(Duplex.prototype, Readable.prototype), ObjectSetPrototypeOf(Duplex, Readable);\n    for (var method in Writable.prototype)\n      if (!Duplex.prototype[method])\n        Duplex.prototype[method] = Writable.prototype[method];\n    ObjectDefineProperties(Duplex.prototype, {\n      writable: ObjectGetOwnPropertyDescriptor(Writable.prototype, \"writable\"),\n      writableHighWaterMark: ObjectGetOwnPropertyDescriptor(Writable.prototype, \"writableHighWaterMark\"),\n      writableObjectMode: ObjectGetOwnPropertyDescriptor(Writable.prototype, \"writableObjectMode\"),\n      writableBuffer: ObjectGetOwnPropertyDescriptor(Writable.prototype, \"writableBuffer\"),\n      writableLength: ObjectGetOwnPropertyDescriptor(Writable.prototype, \"writableLength\"),\n      writableFinished: ObjectGetOwnPropertyDescriptor(Writable.prototype, \"writableFinished\"),\n      writableCorked: ObjectGetOwnPropertyDescriptor(Writable.prototype, \"writableCorked\"),\n      writableEnded: ObjectGetOwnPropertyDescriptor(Writable.prototype, \"writableEnded\"),\n      writableNeedDrain: ObjectGetOwnPropertyDescriptor(Writable.prototype, \"writableNeedDrain\"),\n      destroyed: {\n        get() {\n          if (this._readableState === void 0 || this._writableState === void 0)\n            return !1;\n          return this._readableState.destroyed && this._writableState.destroyed;\n        },\n        set(value) {\n          if (this._readableState && this._writableState)\n            this._readableState.destroyed = value, this._writableState.destroyed = value;\n        }\n      }\n    });\n    var webStreamsAdapters;\n    function lazyWebStreams() {\n      if (webStreamsAdapters === void 0)\n        webStreamsAdapters = {};\n      return webStreamsAdapters;\n    }\n    Duplex.fromWeb = function(pair, options) {\n      return lazyWebStreams().newStreamDuplexFromReadableWritablePair(pair, options);\n    }, Duplex.toWeb = function(duplex) {\n      return lazyWebStreams().newReadableWritablePairFromDuplex(duplex);\n    };\n    var duplexify;\n    Duplex.from = function(body) {\n      if (!duplexify)\n        duplexify = require_duplexify();\n      return duplexify(body, \"body\");\n    };\n  }\n}), require_transform = __commonJS({\n  \"node_modules/readable-stream/lib/internal/streams/transform.js\"(exports, module) {\n    var { ObjectSetPrototypeOf, Symbol: Symbol2 } = require_primordials(), { ERR_METHOD_NOT_IMPLEMENTED } = require_errors().codes, Duplex = require_duplex();\n    function Transform(options) {\n      if (!(this instanceof Transform))\n        return new Transform(options);\n      if (Duplex.call(this, options), this._readableState.sync = !1, this[kCallback] = null, options) {\n        if (typeof options.transform === \"function\")\n          this._transform = options.transform;\n        if (typeof options.flush === \"function\")\n          this._flush = options.flush;\n      }\n      this.on(\"prefinish\", prefinish.bind(this));\n    }\n    Transform.prototype = {}, ObjectSetPrototypeOf(Transform.prototype, Duplex.prototype), ObjectSetPrototypeOf(Transform, Duplex), module.exports = Transform;\n    var kCallback = Symbol2(\"kCallback\");\n    function final(cb) {\n      if (typeof this._flush === \"function\" && !this.destroyed)\n        this._flush((er, data) => {\n          if (er) {\n            if (cb)\n              cb(er);\n            else\n              this.destroy(er);\n            return;\n          }\n          if (data != null)\n            this.push(data);\n          if (this.push(null), cb)\n            cb();\n        });\n      else if (this.push(null), cb)\n        cb();\n    }\n    function prefinish() {\n      if (this._final !== final)\n        final.call(this);\n    }\n    Transform.prototype._final = final, Transform.prototype._transform = function(chunk, encoding, callback) {\n      throw new ERR_METHOD_NOT_IMPLEMENTED(\"_transform()\");\n    }, Transform.prototype._write = function(chunk, encoding, callback) {\n      const rState = this._readableState, wState = this._writableState, length = rState.length;\n      this._transform(chunk, encoding, (err, val) => {\n        if (err) {\n          callback(err);\n          return;\n        }\n        if (val != null)\n          this.push(val);\n        if (wState.ended || length === rState.length || rState.length < rState.highWaterMark || rState.highWaterMark === 0 || rState.length === 0)\n          callback();\n        else\n          this[kCallback] = callback;\n      });\n    }, Transform.prototype._read = function() {\n      if (this[kCallback]) {\n        const callback = this[kCallback];\n        this[kCallback] = null, callback();\n      }\n    };\n  }\n}), require_passthrough = __commonJS({\n  \"node_modules/readable-stream/lib/internal/streams/passthrough.js\"(exports, module) {\n    var { ObjectSetPrototypeOf } = require_primordials(), Transform = require_transform();\n    function PassThrough(options) {\n      if (!(this instanceof PassThrough))\n        return new PassThrough(options);\n      Transform.call(this, options);\n    }\n    PassThrough.prototype = {}, ObjectSetPrototypeOf(PassThrough.prototype, Transform.prototype), ObjectSetPrototypeOf(PassThrough, Transform), PassThrough.prototype._transform = function(chunk, encoding, cb) {\n      cb(null, chunk);\n    }, module.exports = PassThrough;\n  }\n}), require_pipeline = __commonJS({\n  \"node_modules/readable-stream/lib/internal/streams/pipeline.js\"(exports, module) {\n    var { ArrayIsArray: ArrayIsArray2, Promise: Promise2, SymbolAsyncIterator } = require_primordials(), eos = require_end_of_stream(), { once } = require_util(), destroyImpl = require_destroy(), Duplex = require_duplex(), {\n      aggregateTwoErrors,\n      codes: { ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE2, ERR_INVALID_RETURN_VALUE, ERR_MISSING_ARGS, ERR_STREAM_DESTROYED },\n      AbortError: AbortError2\n    } = require_errors(), { validateFunction, validateAbortSignal } = require_validators(), { isIterable, isReadable, isReadableNodeStream, isNodeStream } = require_utils(), PassThrough, Readable;\n    function destroyer(stream, reading, writing) {\n      let finished2 = !1;\n      stream.on(\"close\", () => {\n        finished2 = !0;\n      });\n      const cleanup = eos(stream, {\n        readable: reading,\n        writable: writing\n      }, (err) => {\n        finished2 = !err;\n      });\n      return {\n        destroy: (err) => {\n          if (finished2)\n            return;\n          finished2 = !0, destroyImpl.destroyer(stream, err || new ERR_STREAM_DESTROYED(\"pipe\"));\n        },\n        cleanup\n      };\n    }\n    function popCallback(streams) {\n      return validateFunction(streams[streams.length - 1], \"streams[stream.length - 1]\"), streams.pop();\n    }\n    function makeAsyncIterable(val) {\n      if (isIterable(val))\n        return val;\n      else if (isReadableNodeStream(val))\n        return fromReadable(val);\n      throw new ERR_INVALID_ARG_TYPE2(\"val\", [\"Readable\", \"Iterable\", \"AsyncIterable\"], val);\n    }\n    async function* fromReadable(val) {\n      if (!Readable)\n        Readable = require_readable();\n      yield* Readable.prototype[SymbolAsyncIterator].call(val);\n    }\n    async function pump(iterable, writable, finish, { end }) {\n      let error, onresolve = null;\n      const resume = (err) => {\n        if (err)\n          error = err;\n        if (onresolve) {\n          const callback = onresolve;\n          onresolve = null, callback();\n        }\n      }, wait = () => new Promise2((resolve, reject) => {\n        if (error)\n          reject(error);\n        else\n          onresolve = () => {\n            if (error)\n              reject(error);\n            else\n              resolve();\n          };\n      });\n      writable.on(\"drain\", resume);\n      const cleanup = eos(writable, {\n        readable: !1\n      }, resume);\n      try {\n        if (writable.writableNeedDrain)\n          await wait();\n        for await (let chunk of iterable)\n          if (!writable.write(chunk))\n            await wait();\n        if (end)\n          writable.end();\n        await wait(), finish();\n      } catch (err) {\n        finish(error !== err \? aggregateTwoErrors(error, err) : err);\n      } finally {\n        cleanup(), writable.off(\"drain\", resume);\n      }\n    }\n    function pipeline(...streams) {\n      return pipelineImpl(streams, once(popCallback(streams)));\n    }\n    function pipelineImpl(streams, callback, opts) {\n      if (streams.length === 1 && ArrayIsArray2(streams[0]))\n        streams = streams[0];\n      if (streams.length < 2)\n        throw new ERR_MISSING_ARGS(\"streams\");\n      const ac = new AbortController, signal = ac.signal, outerSignal = opts === null || opts === void 0 \? void 0 : opts.signal, lastStreamCleanup = [];\n      validateAbortSignal(outerSignal, \"options.signal\");\n      function abort() {\n        finishImpl(new AbortError2);\n      }\n      outerSignal === null || outerSignal === void 0 || outerSignal.addEventListener(\"abort\", abort);\n      let error, value;\n      const destroys = [];\n      let finishCount = 0;\n      function finish(err) {\n        finishImpl(err, --finishCount === 0);\n      }\n      function finishImpl(err, final) {\n        if (err && (!error || error.code === \"ERR_STREAM_PREMATURE_CLOSE\"))\n          error = err;\n        if (!error && !final)\n          return;\n        while (destroys.length)\n          destroys.shift()(error);\n        if (outerSignal === null || outerSignal === void 0 || outerSignal.removeEventListener(\"abort\", abort), ac.abort(), final) {\n          if (!error)\n            lastStreamCleanup.forEach((fn) => fn());\n          runOnNextTick(callback, error, value);\n        }\n      }\n      let ret;\n      for (let i = 0;i < streams.length; i++) {\n        const stream = streams[i], reading = i < streams.length - 1, writing = i > 0, end = reading || (opts === null || opts === void 0 \? void 0 : opts.end) !== !1, isLastStream = i === streams.length - 1;\n        if (isNodeStream(stream)) {\n          let onError = function(err) {\n            if (err && err.name !== \"AbortError\" && err.code !== \"ERR_STREAM_PREMATURE_CLOSE\")\n              finish(err);\n          };\n          if (end) {\n            const { destroy: destroy2, cleanup } = destroyer(stream, reading, writing);\n            if (destroys.push(destroy2), isReadable(stream) && isLastStream)\n              lastStreamCleanup.push(cleanup);\n          }\n          if (stream.on(\"error\", onError), isReadable(stream) && isLastStream)\n            lastStreamCleanup.push(() => {\n              stream.removeListener(\"error\", onError);\n            });\n        }\n        if (i === 0)\n          if (typeof stream === \"function\") {\n            if (ret = stream({\n              signal\n            }), !isIterable(ret))\n              throw new ERR_INVALID_RETURN_VALUE(\"Iterable, AsyncIterable or Stream\", \"source\", ret);\n          } else if (isIterable(stream) || isReadableNodeStream(stream))\n            ret = stream;\n          else\n            ret = Duplex.from(stream);\n        else if (typeof stream === \"function\")\n          if (ret = makeAsyncIterable(ret), ret = stream(ret, {\n            signal\n          }), reading) {\n            if (!isIterable(ret, !0))\n              throw new ERR_INVALID_RETURN_VALUE(\"AsyncIterable\", `transform[${i - 1}]`, ret);\n          } else {\n            var _ret;\n            if (!PassThrough)\n              PassThrough = require_passthrough();\n            const pt = new PassThrough({\n              objectMode: !0\n            }), then = (_ret = ret) === null || _ret === void 0 \? void 0 : _ret.then;\n            if (typeof then === \"function\")\n              finishCount++, then.call(ret, (val) => {\n                if (value = val, val != null)\n                  pt.write(val);\n                if (end)\n                  pt.end();\n                runOnNextTick(finish);\n              }, (err) => {\n                pt.destroy(err), runOnNextTick(finish, err);\n              });\n            else if (isIterable(ret, !0))\n              finishCount++, pump(ret, pt, finish, {\n                end\n              });\n            else\n              throw new ERR_INVALID_RETURN_VALUE(\"AsyncIterable or Promise\", \"destination\", ret);\n            ret = pt;\n            const { destroy: destroy2, cleanup } = destroyer(ret, !1, !0);\n            if (destroys.push(destroy2), isLastStream)\n              lastStreamCleanup.push(cleanup);\n          }\n        else if (isNodeStream(stream)) {\n          if (isReadableNodeStream(ret)) {\n            finishCount += 2;\n            const cleanup = pipe(ret, stream, finish, {\n              end\n            });\n            if (isReadable(stream) && isLastStream)\n              lastStreamCleanup.push(cleanup);\n          } else if (isIterable(ret))\n            finishCount++, pump(ret, stream, finish, {\n              end\n            });\n          else\n            throw new ERR_INVALID_ARG_TYPE2(\"val\", [\"Readable\", \"Iterable\", \"AsyncIterable\"], ret);\n          ret = stream;\n        } else\n          ret = Duplex.from(stream);\n      }\n      if (signal !== null && signal !== void 0 && signal.aborted || outerSignal !== null && outerSignal !== void 0 && outerSignal.aborted)\n        runOnNextTick(abort);\n      return ret;\n    }\n    function pipe(src, dst, finish, { end }) {\n      if (src.pipe(dst, {\n        end\n      }), end)\n        src.once(\"end\", () => dst.end());\n      else\n        finish();\n      return eos(src, {\n        readable: !0,\n        writable: !1\n      }, (err) => {\n        const rState = src._readableState;\n        if (err && err.code === \"ERR_STREAM_PREMATURE_CLOSE\" && rState && rState.ended && !rState.errored && !rState.errorEmitted)\n          src.once(\"end\", finish).once(\"error\", finish);\n        else\n          finish(err);\n      }), eos(dst, {\n        readable: !1,\n        writable: !0\n      }, finish);\n    }\n    module.exports = {\n      pipelineImpl,\n      pipeline\n    };\n  }\n}), require_compose = __commonJS({\n  \"node_modules/readable-stream/lib/internal/streams/compose.js\"(exports, module) {\n    var { pipeline } = require_pipeline(), Duplex = require_duplex(), { destroyer } = require_destroy(), { isNodeStream, isReadable, isWritable } = require_utils(), {\n      AbortError: AbortError2,\n      codes: { ERR_INVALID_ARG_VALUE: ERR_INVALID_ARG_VALUE2, ERR_MISSING_ARGS }\n    } = require_errors();\n    module.exports = function compose(...streams) {\n      if (streams.length === 0)\n        throw new ERR_MISSING_ARGS(\"streams\");\n      if (streams.length === 1)\n        return Duplex.from(streams[0]);\n      const orgStreams = [...streams];\n      if (typeof streams[0] === \"function\")\n        streams[0] = Duplex.from(streams[0]);\n      if (typeof streams[streams.length - 1] === \"function\") {\n        const idx = streams.length - 1;\n        streams[idx] = Duplex.from(streams[idx]);\n      }\n      for (let n = 0;n < streams.length; ++n) {\n        if (!isNodeStream(streams[n]))\n          continue;\n        if (n < streams.length - 1 && !isReadable(streams[n]))\n          throw new ERR_INVALID_ARG_VALUE2(`streams[${n}]`, orgStreams[n], \"must be readable\");\n        if (n > 0 && !isWritable(streams[n]))\n          throw new ERR_INVALID_ARG_VALUE2(`streams[${n}]`, orgStreams[n], \"must be writable\");\n      }\n      let ondrain, onfinish, onreadable, onclose, d;\n      function onfinished(err) {\n        const cb = onclose;\n        if (onclose = null, cb)\n          cb(err);\n        else if (err)\n          d.destroy(err);\n        else if (!readable && !writable)\n          d.destroy();\n      }\n      const head = streams[0], tail = pipeline(streams, onfinished), writable = !!isWritable(head), readable = !!isReadable(tail);\n      if (d = new Duplex({\n        writableObjectMode: !!(head !== null && head !== void 0 && head.writableObjectMode),\n        readableObjectMode: !!(tail !== null && tail !== void 0 && tail.writableObjectMode),\n        writable,\n        readable\n      }), writable)\n        d._write = function(chunk, encoding, callback) {\n          if (head.write(chunk, encoding))\n            callback();\n          else\n            ondrain = callback;\n        }, d._final = function(callback) {\n          head.end(), onfinish = callback;\n        }, head.on(\"drain\", function() {\n          if (ondrain) {\n            const cb = ondrain;\n            ondrain = null, cb();\n          }\n        }), tail.on(\"finish\", function() {\n          if (onfinish) {\n            const cb = onfinish;\n            onfinish = null, cb();\n          }\n        });\n      if (readable)\n        tail.on(\"readable\", function() {\n          if (onreadable) {\n            const cb = onreadable;\n            onreadable = null, cb();\n          }\n        }), tail.on(\"end\", function() {\n          d.push(null);\n        }), d._read = function() {\n          while (!0) {\n            const buf = tail.read();\n            if (buf === null) {\n              onreadable = d._read;\n              return;\n            }\n            if (!d.push(buf))\n              return;\n          }\n        };\n      return d._destroy = function(err, callback) {\n        if (!err && onclose !== null)\n          err = new AbortError2;\n        if (onreadable = null, ondrain = null, onfinish = null, onclose === null)\n          callback(err);\n        else\n          onclose = callback, destroyer(tail, err);\n      }, d;\n    };\n  }\n}), require_promises = __commonJS({\n  \"node_modules/readable-stream/lib/stream/promises.js\"(exports, module) {\n    var { ArrayPrototypePop, Promise: Promise2 } = require_primordials(), { isIterable, isNodeStream } = require_utils(), { pipelineImpl: pl } = require_pipeline(), { finished: finished2 } = require_end_of_stream();\n    function pipeline(...streams) {\n      return new Promise2((resolve, reject) => {\n        let signal, end;\n        const lastArg = streams[streams.length - 1];\n        if (lastArg && typeof lastArg === \"object\" && !isNodeStream(lastArg) && !isIterable(lastArg)) {\n          const options = ArrayPrototypePop(streams);\n          signal = options.signal, end = options.end;\n        }\n        pl(streams, (err, value) => {\n          if (err)\n            reject(err);\n          else\n            resolve(value);\n        }, {\n          signal,\n          end\n        });\n      });\n    }\n    module.exports = {\n      finished: finished2,\n      pipeline\n    };\n  }\n}), require_stream = __commonJS({\n  \"node_modules/readable-stream/lib/stream.js\"(exports, module) {\n    var { ObjectDefineProperty, ObjectKeys, ReflectApply } = require_primordials(), {\n      promisify: { custom: customPromisify }\n    } = require_util(), { streamReturningOperators, promiseReturningOperators } = require_operators(), {\n      codes: { ERR_ILLEGAL_CONSTRUCTOR }\n    } = require_errors(), compose = require_compose(), { pipeline } = require_pipeline(), { destroyer } = require_destroy(), eos = require_end_of_stream(), promises = require_promises(), utils = require_utils(), Stream = module.exports = require_legacy().Stream;\n    Stream.isDisturbed = utils.isDisturbed, Stream.isErrored = utils.isErrored, Stream.isWritable = utils.isWritable, Stream.isReadable = utils.isReadable, Stream.Readable = require_readable();\n    for (let key of ObjectKeys(streamReturningOperators)) {\n      let fn = function(...args) {\n        if (new.target)\n          throw ERR_ILLEGAL_CONSTRUCTOR();\n        return Stream.Readable.from(ReflectApply(op, this, args));\n      };\n      const op = streamReturningOperators[key];\n      ObjectDefineProperty(fn, \"name\", {\n        value: op.name\n      }), ObjectDefineProperty(fn, \"length\", {\n        value: op.length\n      }), ObjectDefineProperty(Stream.Readable.prototype, key, {\n        value: fn,\n        enumerable: !1,\n        configurable: !0,\n        writable: !0\n      });\n    }\n    for (let key of ObjectKeys(promiseReturningOperators)) {\n      let fn = function(...args) {\n        if (new.target)\n          throw ERR_ILLEGAL_CONSTRUCTOR();\n        return ReflectApply(op, this, args);\n      };\n      const op = promiseReturningOperators[key];\n      ObjectDefineProperty(fn, \"name\", {\n        value: op.name\n      }), ObjectDefineProperty(fn, \"length\", {\n        value: op.length\n      }), ObjectDefineProperty(Stream.Readable.prototype, key, {\n        value: fn,\n        enumerable: !1,\n        configurable: !0,\n        writable: !0\n      });\n    }\n    Stream.Writable = require_writable(), Stream.Duplex = require_duplex(), Stream.Transform = require_transform(), Stream.PassThrough = require_passthrough(), Stream.pipeline = pipeline;\n    var { addAbortSignal } = require_add_abort_signal();\n    Stream.addAbortSignal = addAbortSignal, Stream.finished = eos, Stream.destroy = destroyer, Stream.compose = compose, ObjectDefineProperty(Stream, \"promises\", {\n      configurable: !0,\n      enumerable: !0,\n      get() {\n        return promises;\n      }\n    }), ObjectDefineProperty(pipeline, customPromisify, {\n      enumerable: !0,\n      get() {\n        return promises.pipeline;\n      }\n    }), ObjectDefineProperty(eos, customPromisify, {\n      enumerable: !0,\n      get() {\n        return promises.finished;\n      }\n    }), Stream.Stream = Stream, Stream._isUint8Array = function isUint8Array(value) {\n      return value instanceof Uint8Array;\n    }, Stream._uint8ArrayToBuffer = function _uint8ArrayToBuffer(chunk) {\n      return new Buffer(chunk.buffer, chunk.byteOffset, chunk.byteLength);\n    };\n  }\n}), nativeReadableStreamPrototypes = {\n  0: void 0,\n  1: void 0,\n  2: void 0,\n  3: void 0,\n  4: void 0,\n  5: void 0\n}, Writable = require_writable(), NativeWritable = class NativeWritable2 extends Writable {\n  #pathOrFdOrSink;\n  #fileSink;\n  #native = !0;\n  _construct;\n  _destroy;\n  _final;\n  constructor(pathOrFdOrSink, options = {}) {\n    super(options);\n    this._construct = this.#internalConstruct, this._destroy = this.#internalDestroy, this._final = this.#internalFinal, this.#pathOrFdOrSink = pathOrFdOrSink;\n  }\n  #internalConstruct(cb) {\n    this._writableState.constructed = !0, this.constructed = !0, cb();\n  }\n  #lazyConstruct() {\n    if (typeof this.#pathOrFdOrSink === \"object\")\n      if (typeof this.#pathOrFdOrSink.write === \"function\")\n        this.#fileSink = this.#pathOrFdOrSink;\n      else\n        throw new Error(\"Invalid FileSink\");\n    else\n      this.#fileSink = Bun.file(this.#pathOrFdOrSink).writer();\n  }\n  write(chunk, encoding, cb, native = this.#native) {\n    if (!native)\n      return this.#native = !1, super.write(chunk, encoding, cb);\n    if (!this.#fileSink)\n      this.#lazyConstruct();\n    var fileSink = this.#fileSink, result = fileSink.write(chunk);\n    if (@isPromise(result))\n      return result.then(() => {\n        this.emit(\"drain\"), fileSink.flush(!0);\n      }), !1;\n    if (fileSink.flush(!0), cb)\n      cb(null, chunk.byteLength);\n    return !0;\n  }\n  end(chunk, encoding, cb, native = this.#native) {\n    return super.end(chunk, encoding, cb, native);\n  }\n  #internalDestroy(error, cb) {\n    if (this._writableState.destroyed = !0, cb)\n      cb(error);\n  }\n  #internalFinal(cb) {\n    if (this.#fileSink)\n      this.#fileSink.end();\n    if (cb)\n      cb();\n  }\n  ref() {\n    if (!this.#fileSink)\n      this.#lazyConstruct();\n    this.#fileSink.ref();\n  }\n  unref() {\n    if (!this.#fileSink)\n      return;\n    this.#fileSink.unref();\n  }\n}, exports = require_stream(), promises = require_promises();\nexports._getNativeReadableStreamPrototype = getNativeReadableStreamPrototype;\nexports.NativeWritable = NativeWritable;\nObject.defineProperty(exports, \"promises\", {\n  configurable: !0,\n  enumerable: !0,\n  get() {\n    return promises;\n  }\n});\nexports[Symbol.for(\"::bunternal::\")] = { _ReadableFromWeb, _ReadableFromWebForUndici };\nexports.eos = require_end_of_stream();\nreturn exports})\n"_s;
//

//
static constexpr ASCIILiteral NodeStreamPromisesCode = "(function (){\"use strict\";// src/js/out/tmp/node/stream.promises.ts\nreturn (@getInternalField(@internalModuleRegistry, 35) || @createInternalModuleById(35)).promises})\n"_s;
//

//
static constexpr ASCIILiteral NodeStreamWebCode = "(function (){\"use strict\";// src/js/out/tmp/node/stream.web.ts\nvar $;\n$ = {\n  ReadableStream,\n  ReadableStreamDefaultReader,\n  ReadableStreamBYOBReader,\n  ReadableStreamBYOBRequest,\n  ReadableByteStreamController,\n  ReadableStreamDefaultController,\n  TransformStream,\n  TransformStreamDefaultController,\n  WritableStream,\n  WritableStreamDefaultWriter,\n  WritableStreamDefaultController,\n  ByteLengthQueuingStrategy,\n  CountQueuingStrategy\n};\nreturn $})\n"_s;
//

//
static constexpr ASCIILiteral NodeTimersCode = "(function (){\"use strict\";// src/js/out/tmp/node/timers.ts\nvar $;\n$ = {\n  setTimeout,\n  clearTimeout,\n  setInterval,\n  setImmediate,\n  clearInterval,\n  clearImmediate\n};\nreturn $})\n"_s;
//

//
static constexpr ASCIILiteral NodeTimersPromisesCode = "(function (){\"use strict\";// src/js/out/tmp/node/timers.promises.ts\nvar validateObject = function(object, name) {\n  if (object === null || typeof object !== \"object\")\n    throw new ERR_INVALID_ARG_TYPE(name, \"Object\", object);\n}, validateBoolean = function(value, name) {\n  if (typeof value !== \"boolean\")\n    throw new ERR_INVALID_ARG_TYPE(name, \"boolean\", value);\n}, validateAbortSignal = function(signal, name) {\n  if (typeof signal !== \"undefined\" && (signal === null || typeof signal !== \"object\" || !(\"aborted\" in signal)))\n    throw new ERR_INVALID_ARG_TYPE(name, \"AbortSignal\", signal);\n}, asyncIterator = function({ next: nextFunction, return: returnFunction }) {\n  const result = {};\n  if (typeof nextFunction === \"function\")\n    result.next = nextFunction;\n  if (typeof returnFunction === \"function\")\n    result.return = returnFunction;\n  return result[symbolAsyncIterator] = function() {\n    return this;\n  }, result;\n}, setTimeoutPromise = function(after = 1, value, options = {}) {\n  const arguments_ = [].concat(value \?\? []);\n  try {\n    validateObject(options, \"options\");\n  } catch (error) {\n    return Promise.reject(error);\n  }\n  const { signal, ref: reference = !0 } = options;\n  try {\n    validateAbortSignal(signal, \"options.signal\");\n  } catch (error) {\n    return Promise.reject(error);\n  }\n  try {\n    validateBoolean(reference, \"options.ref\");\n  } catch (error) {\n    return Promise.reject(error);\n  }\n  if (signal\?.aborted)\n    return Promise.reject(new AbortError);\n  let onCancel;\n  const returnValue = new Promise((resolve, reject) => {\n    const timeout = setTimeout(() => resolve(value), after, ...arguments_);\n    if (!reference)\n      timeout\?.unref\?.();\n    if (signal)\n      onCancel = () => {\n        clearTimeout(timeout), reject(new AbortError);\n      }, signal.addEventListener(\"abort\", onCancel);\n  });\n  if (typeof onCancel !== \"undefined\")\n    returnValue.finally(() => signal.removeEventListener(\"abort\", onCancel));\n  return returnValue;\n}, setImmediatePromise = function(value, options = {}) {\n  try {\n    validateObject(options, \"options\");\n  } catch (error) {\n    return Promise.reject(error);\n  }\n  const { signal, ref: reference = !0 } = options;\n  try {\n    validateAbortSignal(signal, \"options.signal\");\n  } catch (error) {\n    return Promise.reject(error);\n  }\n  try {\n    validateBoolean(reference, \"options.ref\");\n  } catch (error) {\n    return Promise.reject(error);\n  }\n  if (signal\?.aborted)\n    return Promise.reject(new AbortError);\n  let onCancel;\n  const returnValue = new Promise((resolve, reject) => {\n    const immediate = setImmediate(() => resolve(value));\n    if (!reference)\n      immediate\?.unref\?.();\n    if (signal)\n      onCancel = () => {\n        clearImmediate(immediate), reject(new AbortError);\n      }, signal.addEventListener(\"abort\", onCancel);\n  });\n  if (typeof onCancel !== \"undefined\")\n    returnValue.finally(() => signal.removeEventListener(\"abort\", onCancel));\n  return returnValue;\n}, setIntervalPromise = function(after = 1, value, options = {}) {\n  try {\n    validateObject(options, \"options\");\n  } catch (error) {\n    return asyncIterator({\n      next: function() {\n        return Promise.reject(error);\n      }\n    });\n  }\n  const { signal, ref: reference = !0 } = options;\n  try {\n    validateAbortSignal(signal, \"options.signal\");\n  } catch (error) {\n    return asyncIterator({\n      next: function() {\n        return Promise.reject(error);\n      }\n    });\n  }\n  try {\n    validateBoolean(reference, \"options.ref\");\n  } catch (error) {\n    return asyncIterator({\n      next: function() {\n        return Promise.reject(error);\n      }\n    });\n  }\n  if (signal\?.aborted)\n    return asyncIterator({\n      next: function() {\n        return Promise.reject(new AbortError);\n      }\n    });\n  let onCancel, interval;\n  try {\n    let notYielded = 0, callback;\n    if (interval = setInterval(() => {\n      if (notYielded++, callback)\n        callback(), callback = void 0;\n    }, after), !reference)\n      interval\?.unref\?.();\n    if (signal)\n      onCancel = () => {\n        if (clearInterval(interval), callback)\n          callback(), callback = void 0;\n      }, signal.addEventListener(\"abort\", onCancel);\n    return asyncIterator({\n      next: function() {\n        return new Promise((resolve, reject) => {\n          if (!signal\?.aborted)\n            if (notYielded === 0)\n              callback = resolve;\n            else\n              resolve();\n          else if (notYielded === 0)\n            reject(new AbortError);\n          else\n            resolve();\n        }).then(() => {\n          if (notYielded > 0)\n            return notYielded = notYielded - 1, { done: !1, value };\n          return { done: !0 };\n        });\n      },\n      return: function() {\n        return clearInterval(interval), signal\?.removeEventListener(\"abort\", onCancel), Promise.resolve({});\n      }\n    });\n  } catch (error) {\n    return asyncIterator({\n      next: function() {\n        clearInterval(interval), signal\?.removeEventListener(\"abort\", onCancel);\n      }\n    });\n  }\n}, $, symbolAsyncIterator = Symbol.asyncIterator;\n\nclass ERR_INVALID_ARG_TYPE extends Error {\n  constructor(name, expected, actual) {\n    super(`${name} must be ${expected}, ${typeof actual} given`);\n    this.code = \"ERR_INVALID_ARG_TYPE\";\n  }\n}\n\nclass AbortError extends Error {\n  constructor() {\n    super(\"The operation was aborted\");\n    this.code = \"ABORT_ERR\";\n  }\n}\n$ = {\n  setTimeout: setTimeoutPromise,\n  setImmediate: setImmediatePromise,\n  setInterval: setIntervalPromise,\n  scheduler: {\n    wait: (delay, options) => setTimeoutPromise(delay, void 0, options),\n    yield: setImmediatePromise\n  }\n};\nreturn $})\n"_s;
//

//
static constexpr ASCIILiteral NodeTLSCode = "(function (){\"use strict\";// src/js/out/tmp/node/tls.ts\nvar parseCertString = function() {\n  throwNotImplemented(\"Not implemented\");\n}, isValidTLSArray = function(obj) {\n  if (typeof obj === \"string\" || isTypedArray(obj) || obj instanceof ArrayBuffer || obj instanceof Blob)\n    return !0;\n  if (Array.isArray(obj)) {\n    for (var i = 0;i < obj.length; i++)\n      if (typeof obj !== \"string\" && !isTypedArray(obj) && !(obj instanceof ArrayBuffer) && !(obj instanceof Blob))\n        return !1;\n    return !0;\n  }\n}, unfqdn = function(host2) {\n  return RegExpPrototypeSymbolReplace.call(/[.]$/, host2, \"\");\n}, toLowerCase = function(c) {\n  return StringFromCharCode.call(32 + StringPrototypeCharCodeAt.call(c, 0));\n}, splitHost = function(host2) {\n  return StringPrototypeSplit.call(RegExpPrototypeSymbolReplace.call(/[A-Z]/g, unfqdn(host2), toLowerCase), \".\");\n}, check = function(hostParts, pattern, wildcards) {\n  if (!pattern)\n    return !1;\n  const patternParts = splitHost(pattern);\n  if (hostParts.length !== patternParts.length)\n    return !1;\n  if (ArrayPrototypeIncludes.call(patternParts, \"\"))\n    return !1;\n  const isBad = (s) => RegExpPrototypeExec.call(/[^\\u0021-\\u007F]/u, s) !== null;\n  if (ArrayPrototypeSome.call(patternParts, isBad))\n    return !1;\n  for (let i = hostParts.length - 1;i > 0; i -= 1)\n    if (hostParts[i] !== patternParts[i])\n      return !1;\n  const hostSubdomain = hostParts[0], patternSubdomain = patternParts[0], patternSubdomainParts = StringPrototypeSplit.call(patternSubdomain, \"*\");\n  if (patternSubdomainParts.length === 1 || StringPrototypeIncludes.call(patternSubdomain, \"xn--\"))\n    return hostSubdomain === patternSubdomain;\n  if (!wildcards)\n    return !1;\n  if (patternSubdomainParts.length > 2)\n    return !1;\n  if (patternParts.length <= 2)\n    return !1;\n  const { 0: prefix, 1: suffix } = patternSubdomainParts;\n  if (prefix.length + suffix.length > hostSubdomain.length)\n    return !1;\n  if (!StringPrototypeStartsWith.call(hostSubdomain, prefix))\n    return !1;\n  if (!StringPrototypeEndsWith.call(hostSubdomain, suffix))\n    return !1;\n  return !0;\n}, splitEscapedAltNames = function(altNames) {\n  const result = [];\n  let currentToken = \"\", offset = 0;\n  while (offset !== altNames.length) {\n    const nextSep = StringPrototypeIndexOf.call(altNames, \", \", offset), nextQuote = StringPrototypeIndexOf.call(altNames, '\"', offset);\n    if (nextQuote !== -1 && (nextSep === -1 || nextQuote < nextSep)) {\n      currentToken += StringPrototypeSubstring.call(altNames, offset, nextQuote);\n      const match = RegExpPrototypeExec.call(jsonStringPattern, StringPrototypeSubstring.call(altNames, nextQuote));\n      if (!match) {\n        let error = new SyntaxError(\"ERR_TLS_CERT_ALTNAME_FORMAT: Invalid subject alternative name string\");\n        throw error.name = ERR_TLS_CERT_ALTNAME_FORMAT, error;\n      }\n      currentToken += JSON.parse(match[0]), offset = nextQuote + match[0].length;\n    } else if (nextSep !== -1)\n      currentToken += StringPrototypeSubstring.call(altNames, offset, nextSep), ArrayPrototypePush.call(result, currentToken), currentToken = \"\", offset = nextSep + 2;\n    else\n      currentToken += StringPrototypeSubstring.call(altNames, offset), offset = altNames.length;\n  }\n  return ArrayPrototypePush.call(result, currentToken), result;\n}, checkServerIdentity = function(hostname, cert) {\n  const { subject, subjectaltname: altNames } = cert, dnsNames = [], ips = [];\n  if (hostname = \"\" + hostname, altNames) {\n    const splitAltNames = StringPrototypeIncludes.call(altNames, '\"') \? splitEscapedAltNames(altNames) : StringPrototypeSplit.call(altNames, \", \");\n    ArrayPrototypeForEach.call(splitAltNames, (name) => {\n      if (StringPrototypeStartsWith.call(name, \"DNS:\"))\n        ArrayPrototypePush.call(dnsNames, StringPrototypeSlice.call(name, 4));\n      else if (StringPrototypeStartsWith.call(name, \"IP Address:\"))\n        ArrayPrototypePush.call(ips, canonicalizeIP(StringPrototypeSlice.call(name, 11)));\n    });\n  }\n  let valid = !1, reason = \"Unknown reason\";\n  if (hostname = unfqdn(hostname), net.isIP(hostname)) {\n    if (valid = ArrayPrototypeIncludes.call(ips, canonicalizeIP(hostname)), !valid)\n      reason = `IP: ${hostname} is not in the cert's list: ` + ArrayPrototypeJoin.call(ips, \", \");\n  } else if (dnsNames.length > 0 || subject\?.CN) {\n    const hostParts = splitHost(hostname), wildcard = (pattern) => check(hostParts, pattern, !0);\n    if (dnsNames.length > 0) {\n      if (valid = ArrayPrototypeSome.call(dnsNames, wildcard), !valid)\n        reason = `Host: ${hostname}. is not in the cert's altnames: ${altNames}`;\n    } else {\n      const cn = subject.CN;\n      if (Array.isArray(cn))\n        valid = ArrayPrototypeSome.call(cn, wildcard);\n      else if (cn)\n        valid = wildcard(cn);\n      if (!valid)\n        reason = `Host: ${hostname}. is not cert's CN: ${cn}`;\n    }\n  } else\n    reason = \"Cert does not contain a DNS name\";\n  if (!valid) {\n    let error = new Error(`ERR_TLS_CERT_ALTNAME_INVALID: Hostname/IP does not match certificate's altnames: ${reason}`);\n    return error.name = \"ERR_TLS_CERT_ALTNAME_INVALID\", error.reason = reason, error.host = host, error.cert = cert, error;\n  }\n}, SecureContext = function(options) {\n  return new InternalSecureContext(options);\n}, createSecureContext = function(options) {\n  return new SecureContext(options);\n}, translatePeerCertificate = function(c) {\n  if (!c)\n    return null;\n  if (c.issuerCertificate != null && c.issuerCertificate !== c)\n    c.issuerCertificate = translatePeerCertificate(c.issuerCertificate);\n  if (c.infoAccess != null) {\n    const info = c.infoAccess;\n    c.infoAccess = { __proto__: null }, RegExpPrototypeSymbolReplace.call(/([^\\n:]*):([^\\n]*)(\?:\\n|$)/g, info, (all, key, val) => {\n      if (val.charCodeAt(0) === 34)\n        val = JSONParse(val);\n      if (key in c.infoAccess)\n        ArrayPrototypePush.call(c.infoAccess[key], val);\n      else\n        c.infoAccess[key] = [val];\n    });\n  }\n  return c;\n}, createServer = function(options, connectionListener) {\n  return new Server(options, connectionListener);\n}, getCiphers = function() {\n  return DEFAULT_CIPHERS.split(\":\");\n}, convertProtocols = function(protocols) {\n  const lens = new Array(protocols.length), buff = Buffer.allocUnsafe(ArrayPrototypeReduce.call(protocols, (p, c, i) => {\n    const len = Buffer.byteLength(c);\n    if (len > 255)\n      @throwRangeError(\"The byte length of the protocol at index \" + `${i} exceeds the maximum length.`, \"<= 255\", len, !0);\n    return lens[i] = len, p + 1 + len;\n  }, 0));\n  let offset = 0;\n  for (let i = 0, c = protocols.length;i < c; i++)\n    buff[offset++] = lens[i], buff.write(protocols[i], offset), offset += lens[i];\n  return buff;\n}, convertALPNProtocols = function(protocols, out) {\n  if (Array.isArray(protocols))\n    out.ALPNProtocols = convertProtocols(protocols);\n  else if (isTypedArray(protocols))\n    out.ALPNProtocols = Buffer.from(protocols);\n  else if (isArrayBufferView(protocols))\n    out.ALPNProtocols = Buffer.from(protocols.buffer.slice(protocols.byteOffset, protocols.byteOffset + protocols.byteLength));\n  else if (Buffer.isBuffer(protocols))\n    out.ALPNProtocols = protocols;\n}, $, { isArrayBufferView, isTypedArray } = @requireNativeModule(\"node:util/types\"), net = @getInternalField(@internalModuleRegistry, 23) || @createInternalModuleById(23), { Server: NetServer, [Symbol.for(\"::bunternal::\")]: InternalTCPSocket } = net, bunSocketInternal = Symbol.for(\"::bunnetsocketinternal::\"), { rootCertificates, canonicalizeIP } = globalThis[globalThis.Symbol.for('Bun.lazy')](\"internal/tls\"), SymbolReplace = Symbol.replace, RegExpPrototypeSymbolReplace = RegExp.prototype[SymbolReplace], RegExpPrototypeExec = RegExp.prototype.exec, StringPrototypeStartsWith = String.prototype.startsWith, StringPrototypeSlice = String.prototype.slice, StringPrototypeIncludes = String.prototype.includes, StringPrototypeSplit = String.prototype.split, StringPrototypeIndexOf = String.prototype.indexOf, StringPrototypeSubstring = String.prototype.substring, StringPrototypeEndsWith = String.prototype.endsWith, StringFromCharCode = String.fromCharCode, StringPrototypeCharCodeAt = String.prototype.charCodeAt, ArrayPrototypeIncludes = Array.prototype.includes, ArrayPrototypeJoin = Array.prototype.join, ArrayPrototypeForEach = Array.prototype.forEach, ArrayPrototypePush = Array.prototype.push, ArrayPrototypeSome = Array.prototype.some, ArrayPrototypeReduce = Array.prototype.reduce, jsonStringPattern = /^\"(\?:[^\"\\\\\\u0000-\\u001f]|\\\\(\?:[\"\\\\/bfnrt]|u[0-9a-fA-F]{4}))*\"/, InternalSecureContext = class SecureContext2 {\n  context;\n  constructor(options) {\n    const context = {};\n    if (options) {\n      let key = options.key;\n      if (key) {\n        if (!isValidTLSArray(key))\n          @throwTypeError(\"key argument must be an string, Buffer, TypedArray, BunFile or an array containing string, Buffer, TypedArray or BunFile\");\n        this.key = key;\n      }\n      let cert = options.cert;\n      if (cert) {\n        if (!isValidTLSArray(cert))\n          @throwTypeError(\"cert argument must be an string, Buffer, TypedArray, BunFile or an array containing string, Buffer, TypedArray or BunFile\");\n        this.cert = cert;\n      }\n      let ca = options.ca;\n      if (ca) {\n        if (!isValidTLSArray(ca))\n          @throwTypeError(\"ca argument must be an string, Buffer, TypedArray, BunFile or an array containing string, Buffer, TypedArray or BunFile\");\n        this.ca = ca;\n      }\n      let passphrase = options.passphrase;\n      if (passphrase && typeof passphrase !== \"string\")\n        @throwTypeError(\"passphrase argument must be an string\");\n      this.passphrase = passphrase;\n      let servername = options.servername;\n      if (servername && typeof servername !== \"string\")\n        @throwTypeError(\"servername argument must be an string\");\n      this.servername = servername;\n      let secureOptions = options.secureOptions || 0;\n      if (secureOptions && typeof secureOptions !== \"number\")\n        @throwTypeError(\"secureOptions argument must be an number\");\n      this.secureOptions = secureOptions;\n    }\n    this.context = context;\n  }\n}, buntls = Symbol.for(\"::buntls::\"), SocketClass, TLSSocket = function(InternalTLSSocket) {\n  return SocketClass = InternalTLSSocket, Object.defineProperty(SocketClass.prototype, Symbol.toStringTag, {\n    value: \"TLSSocket\",\n    enumerable: !1\n  }), Object.defineProperty(function Socket(options) {\n    return new InternalTLSSocket(options);\n  }, Symbol.hasInstance, {\n    value(instance) {\n      return instance instanceof InternalTLSSocket;\n    }\n  });\n}(class TLSSocket2 extends InternalTCPSocket {\n  #secureContext;\n  ALPNProtocols;\n  #socket;\n  #checkServerIdentity;\n  #session;\n  constructor(socket, options) {\n    super(socket instanceof InternalTCPSocket \? options : options || socket);\n    if (options = options || socket || {}, typeof options === \"object\") {\n      const { ALPNProtocols } = options;\n      if (ALPNProtocols)\n        convertALPNProtocols(ALPNProtocols, this);\n      if (socket instanceof InternalTCPSocket)\n        this.#socket = socket;\n    }\n    this.#secureContext = options.secureContext || createSecureContext(options), this.authorized = !1, this.secureConnecting = !0, this._secureEstablished = !1, this._securePending = !0, this.#checkServerIdentity = options.checkServerIdentity || checkServerIdentity, this.#session = options.session || null;\n  }\n  _secureEstablished = !1;\n  _securePending = !0;\n  _newSessionPending;\n  _controlReleased;\n  secureConnecting = !1;\n  _SNICallback;\n  servername;\n  authorized = !1;\n  authorizationError;\n  #renegotiationDisabled = !1;\n  encrypted = !0;\n  _start() {\n    this.connect();\n  }\n  getSession() {\n    return this[bunSocketInternal]\?.getSession();\n  }\n  getEphemeralKeyInfo() {\n    return this[bunSocketInternal]\?.getEphemeralKeyInfo();\n  }\n  getCipher() {\n    return this[bunSocketInternal]\?.getCipher();\n  }\n  getSharedSigalgs() {\n    return this[bunSocketInternal]\?.getSharedSigalgs();\n  }\n  getProtocol() {\n    return this[bunSocketInternal]\?.getTLSVersion();\n  }\n  getFinished() {\n    return this[bunSocketInternal]\?.getTLSFinishedMessage() || void 0;\n  }\n  getPeerFinished() {\n    return this[bunSocketInternal]\?.getTLSPeerFinishedMessage() || void 0;\n  }\n  isSessionReused() {\n    return !!this.#session;\n  }\n  renegotiate() {\n    if (this.#renegotiationDisabled) {\n      const error = new Error(\"ERR_TLS_RENEGOTIATION_DISABLED: TLS session renegotiation disabled for this socket\");\n      throw error.name = \"ERR_TLS_RENEGOTIATION_DISABLED\", error;\n    }\n    throw Error(\"Not implented in Bun yet\");\n  }\n  disableRenegotiation() {\n    this.#renegotiationDisabled = !0;\n  }\n  getTLSTicket() {\n    return this[bunSocketInternal]\?.getTLSTicket();\n  }\n  exportKeyingMaterial(length, label, context) {\n    if (context)\n      return this[bunSocketInternal]\?.exportKeyingMaterial(length, label, context);\n    return this[bunSocketInternal]\?.exportKeyingMaterial(length, label);\n  }\n  setMaxSendFragment(size) {\n    return this[bunSocketInternal]\?.setMaxSendFragment(size) || !1;\n  }\n  enableTrace() {\n  }\n  setServername(name) {\n    if (this.isServer) {\n      let error = new Error(\"ERR_TLS_SNI_FROM_SERVER: Cannot issue SNI from a TLS server-side socket\");\n      throw error.name = \"ERR_TLS_SNI_FROM_SERVER\", error;\n    }\n    this.servername = name, this[bunSocketInternal]\?.setServername(name);\n  }\n  setSession(session) {\n    if (this.#session = session, typeof session === \"string\")\n      session = Buffer.from(session, \"latin1\");\n    return this[bunSocketInternal]\?.setSession(session);\n  }\n  getPeerCertificate(abbreviated) {\n    const cert = arguments.length < 1 \? this[bunSocketInternal]\?.getPeerCertificate() : this[bunSocketInternal]\?.getPeerCertificate(abbreviated);\n    if (cert)\n      return translatePeerCertificate(cert);\n  }\n  getCertificate() {\n    const cert = this[bunSocketInternal]\?.getCertificate();\n    if (cert)\n      return translatePeerCertificate(cert);\n  }\n  getPeerX509Certificate() {\n    throw Error(\"Not implented in Bun yet\");\n  }\n  getX509Certificate() {\n    throw Error(\"Not implented in Bun yet\");\n  }\n  get alpnProtocol() {\n    return this[bunSocketInternal]\?.alpnProtocol;\n  }\n  [buntls](port, host2) {\n    return {\n      socket: this.#socket,\n      ALPNProtocols: this.ALPNProtocols,\n      serverName: this.servername || host2 || \"localhost\",\n      checkServerIdentity: this.#checkServerIdentity,\n      session: this.#session,\n      ...this.#secureContext\n    };\n  }\n});\n\nclass Server extends NetServer {\n  key;\n  cert;\n  ca;\n  passphrase;\n  secureOptions;\n  _rejectUnauthorized;\n  _requestCert;\n  servername;\n  ALPNProtocols;\n  constructor(options, secureConnectionListener) {\n    super(options, secureConnectionListener);\n    this.setSecureContext(options);\n  }\n  setSecureContext(options) {\n    if (options instanceof InternalSecureContext)\n      options = options.context;\n    if (options) {\n      const { ALPNProtocols } = options;\n      if (ALPNProtocols)\n        convertALPNProtocols(ALPNProtocols, this);\n      let key = options.key;\n      if (key) {\n        if (!isValidTLSArray(key))\n          @throwTypeError(\"key argument must be an string, Buffer, TypedArray, BunFile or an array containing string, Buffer, TypedArray or BunFile\");\n        this.key = key;\n      }\n      let cert = options.cert;\n      if (cert) {\n        if (!isValidTLSArray(cert))\n          @throwTypeError(\"cert argument must be an string, Buffer, TypedArray, BunFile or an array containing string, Buffer, TypedArray or BunFile\");\n        this.cert = cert;\n      }\n      let ca = options.ca;\n      if (ca) {\n        if (!isValidTLSArray(ca))\n          @throwTypeError(\"ca argument must be an string, Buffer, TypedArray, BunFile or an array containing string, Buffer, TypedArray or BunFile\");\n        this.ca = ca;\n      }\n      let passphrase = options.passphrase;\n      if (passphrase && typeof passphrase !== \"string\")\n        @throwTypeError(\"passphrase argument must be an string\");\n      this.passphrase = passphrase;\n      let servername = options.servername;\n      if (servername && typeof servername !== \"string\")\n        @throwTypeError(\"servername argument must be an string\");\n      this.servername = servername;\n      let secureOptions = options.secureOptions || 0;\n      if (secureOptions && typeof secureOptions !== \"number\")\n        @throwTypeError(\"secureOptions argument must be an number\");\n      this.secureOptions = secureOptions;\n      const requestCert = options.requestCert || !1;\n      if (requestCert)\n        this._requestCert = requestCert;\n      else\n        this._requestCert = void 0;\n      const rejectUnauthorized = options.rejectUnauthorized || !1;\n      if (rejectUnauthorized)\n        this._rejectUnauthorized = rejectUnauthorized;\n      else\n        this._rejectUnauthorized = void 0;\n    }\n  }\n  getTicketKeys() {\n    throw Error(\"Not implented in Bun yet\");\n  }\n  setTicketKeys() {\n    throw Error(\"Not implented in Bun yet\");\n  }\n  [buntls](port, host2, isClient) {\n    return [\n      {\n        serverName: this.servername || host2 || \"localhost\",\n        key: this.key,\n        cert: this.cert,\n        ca: this.ca,\n        passphrase: this.passphrase,\n        secureOptions: this.secureOptions,\n        rejectUnauthorized: isClient \? !1 : this._rejectUnauthorized,\n        requestCert: isClient \? !1 : this._requestCert,\n        ALPNProtocols: this.ALPNProtocols\n      },\n      SocketClass\n    ];\n  }\n}\nvar CLIENT_RENEG_LIMIT = 3, CLIENT_RENEG_WINDOW = 600, DEFAULT_ECDH_CURVE = \"auto\", DEFAULT_CIPHERS = \"DHE-RSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-RSA-AES128-GCM-SHA256\", DEFAULT_MIN_VERSION = \"TLSv1.2\", DEFAULT_MAX_VERSION = \"TLSv1.3\", createConnection = (port, host2, connectListener) => {\n  if (typeof port === \"object\") {\n    port.checkServerIdentity;\n    const { ALPNProtocols } = port;\n    if (ALPNProtocols)\n      convertALPNProtocols(ALPNProtocols, port);\n    return new TLSSocket(port).connect(port, host2, connectListener);\n  }\n  return new TLSSocket().connect(port, host2, connectListener);\n}, connect = createConnection;\n$ = {\n  CLIENT_RENEG_LIMIT,\n  CLIENT_RENEG_WINDOW,\n  connect,\n  convertALPNProtocols,\n  createConnection,\n  createSecureContext,\n  createServer,\n  DEFAULT_CIPHERS,\n  DEFAULT_ECDH_CURVE,\n  DEFAULT_MAX_VERSION,\n  DEFAULT_MIN_VERSION,\n  getCiphers,\n  parseCertString,\n  SecureContext,\n  Server,\n  TLSSocket,\n  checkServerIdentity,\n  rootCertificates\n};\nreturn $})\n"_s;
//

//
static constexpr ASCIILiteral NodeTraceEventsCode = "(function (){\"use strict\";// src/js/out/tmp/node/trace_events.ts\nvar ERR_INVALID_ARG_TYPE = function(name, type, value) {\n  const err = @makeTypeError(`The \"${name}\" argument must be of type ${type}. Received ${value}`);\n  return err.code = \"ERR_INVALID_ARG_TYPE\", err;\n}, createTracing = function(opts) {\n  if (typeof opts !== \"object\" || opts == null)\n    throw new ERR_INVALID_ARG_TYPE(\"options\", \"Object\", opts);\n  return new Tracing(opts);\n}, getEnabledCategories = function() {\n  return \"\";\n}, $;\n\nclass Tracing {\n  enabled = !1;\n  categories = \"\";\n}\n$ = {\n  createTracing,\n  getEnabledCategories\n};\nreturn $})\n"_s;
//

//
static constexpr ASCIILiteral NodeUrlCode = "(function (){\"use strict\";// src/js/out/tmp/node/url.ts\nvar Url = function() {\n  this.protocol = null, this.slashes = null, this.auth = null, this.host = null, this.port = null, this.hostname = null, this.hash = null, this.search = null, this.query = null, this.pathname = null, this.path = null, this.href = null;\n}, urlParse = function(url, parseQueryString, slashesDenoteHost) {\n  if (url && typeof url === \"object\" && url instanceof Url)\n    return url;\n  var u = new Url;\n  return u.parse(url, parseQueryString, slashesDenoteHost), u;\n}, urlFormat = function(obj) {\n  if (typeof obj === \"string\")\n    obj = urlParse(obj);\n  if (!(obj instanceof Url))\n    return Url.prototype.format.call(obj);\n  return obj.format();\n}, urlResolve = function(source, relative) {\n  return urlParse(source, !1, !0).resolve(relative);\n}, urlResolveObject = function(source, relative) {\n  if (!source)\n    return relative;\n  return urlParse(source, !1, !0).resolveObject(relative);\n}, urlToHttpOptions = function(url) {\n  const options = {\n    protocol: url.protocol,\n    hostname: typeof url.hostname === \"string\" && url.hostname.startsWith(\"[\") \? url.hostname.slice(1, -1) : url.hostname,\n    hash: url.hash,\n    search: url.search,\n    pathname: url.pathname,\n    path: `${url.pathname || \"\"}${url.search || \"\"}`,\n    href: url.href\n  };\n  if (url.port !== \"\")\n    options.port = Number(url.port);\n  if (url.username || url.password)\n    options.auth = `${decodeURIComponent(url.username)}:${decodeURIComponent(url.password)}`;\n  return options;\n}, $, { URL, URLSearchParams } = globalThis;\nUrl.prototype = {};\nvar protocolPattern = /^([a-z0-9.+-]+:)/i, portPattern = /:[0-9]*$/, simplePathPattern = /^(\\/\\/\?(\?!\\/)[^\?\\s]*)(\\\?[^\\s]*)\?$/, delims = [\"<\", \">\", '\"', \"`\", \" \", \"\\r\", \"\\n\", \"\\t\"], unwise = [\"{\", \"}\", \"|\", \"\\\\\", \"^\", \"`\"].concat(delims), autoEscape = [\"'\"].concat(unwise), nonHostChars = [\"%\", \"/\", \"\?\", \";\", \"#\"].concat(autoEscape), hostEndingChars = [\"/\", \"\?\", \"#\"], hostnameMaxLen = 255, hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/, hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/, unsafeProtocol = {\n  javascript: !0,\n  \"javascript:\": !0\n}, hostlessProtocol = {\n  javascript: !0,\n  \"javascript:\": !0\n}, slashedProtocol = {\n  http: !0,\n  https: !0,\n  ftp: !0,\n  gopher: !0,\n  file: !0,\n  \"http:\": !0,\n  \"https:\": !0,\n  \"ftp:\": !0,\n  \"gopher:\": !0,\n  \"file:\": !0\n};\nUrl.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {\n  if (typeof url !== \"string\")\n    @throwTypeError(\"Parameter 'url' must be a string, not \" + typeof url);\n  var queryIndex = url.indexOf(\"\?\"), splitter = queryIndex !== -1 && queryIndex < url.indexOf(\"#\") \? \"\?\" : \"#\", uSplit = url.split(splitter), slashRegex = /\\\\/g;\n  uSplit[0] = uSplit[0].replace(slashRegex, \"/\"), url = uSplit.join(splitter);\n  var rest = url;\n  if (rest = rest.trim(), !slashesDenoteHost && url.split(\"#\").length === 1) {\n    var simplePath = simplePathPattern.exec(rest);\n    if (simplePath) {\n      if (this.path = rest, this.href = rest, this.pathname = simplePath[1], simplePath[2])\n        if (this.search = simplePath[2], parseQueryString)\n          this.query = new URLSearchParams(this.search.substr(1)).toJSON();\n        else\n          this.query = this.search.substr(1);\n      else if (parseQueryString)\n        this.search = \"\", this.query = {};\n      return this;\n    }\n  }\n  var proto = protocolPattern.exec(rest);\n  if (proto) {\n    proto = proto[0];\n    var lowerProto = proto.toLowerCase();\n    this.protocol = lowerProto, rest = rest.substr(proto.length);\n  }\n  if (slashesDenoteHost || proto || rest.match(/^\\/\\/[^@/]+@[^@/]+/)) {\n    var slashes = rest.substr(0, 2) === \"//\";\n    if (slashes && !(proto && hostlessProtocol[proto]))\n      rest = rest.substr(2), this.slashes = !0;\n  }\n  if (!hostlessProtocol[proto] && (slashes || proto && !slashedProtocol[proto])) {\n    var hostEnd = -1;\n    for (var i = 0;i < hostEndingChars.length; i++) {\n      var hec = rest.indexOf(hostEndingChars[i]);\n      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))\n        hostEnd = hec;\n    }\n    var auth, atSign;\n    if (hostEnd === -1)\n      atSign = rest.lastIndexOf(\"@\");\n    else\n      atSign = rest.lastIndexOf(\"@\", hostEnd);\n    if (atSign !== -1)\n      auth = rest.slice(0, atSign), rest = rest.slice(atSign + 1), this.auth = decodeURIComponent(auth);\n    hostEnd = -1;\n    for (var i = 0;i < nonHostChars.length; i++) {\n      var hec = rest.indexOf(nonHostChars[i]);\n      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))\n        hostEnd = hec;\n    }\n    if (hostEnd === -1)\n      hostEnd = rest.length;\n    this.host = rest.slice(0, hostEnd), rest = rest.slice(hostEnd), this.parseHost(), this.hostname = this.hostname || \"\";\n    var ipv6Hostname = this.hostname[0] === \"[\" && this.hostname[this.hostname.length - 1] === \"]\";\n    if (!ipv6Hostname) {\n      var hostparts = this.hostname.split(/\\./);\n      for (var i = 0, l = hostparts.length;i < l; i++) {\n        var part = hostparts[i];\n        if (!part)\n          continue;\n        if (!part.match(hostnamePartPattern)) {\n          var newpart = \"\";\n          for (var j = 0, k = part.length;j < k; j++)\n            if (part.charCodeAt(j) > 127)\n              newpart += \"x\";\n            else\n              newpart += part[j];\n          if (!newpart.match(hostnamePartPattern)) {\n            var validParts = hostparts.slice(0, i), notHost = hostparts.slice(i + 1), bit = part.match(hostnamePartStart);\n            if (bit)\n              validParts.push(bit[1]), notHost.unshift(bit[2]);\n            if (notHost.length)\n              rest = \"/\" + notHost.join(\".\") + rest;\n            this.hostname = validParts.join(\".\");\n            break;\n          }\n        }\n      }\n    }\n    if (this.hostname.length > hostnameMaxLen)\n      this.hostname = \"\";\n    else\n      this.hostname = this.hostname.toLowerCase();\n    if (!ipv6Hostname)\n      this.hostname = new URL(\"http://\" + this.hostname).hostname;\n    var p = this.port \? \":\" + this.port : \"\", h = this.hostname || \"\";\n    if (this.host = h + p, this.href += this.host, ipv6Hostname) {\n      if (this.hostname = this.hostname.substr(1, this.hostname.length - 2), rest[0] !== \"/\")\n        rest = \"/\" + rest;\n    }\n  }\n  if (!unsafeProtocol[lowerProto])\n    for (var i = 0, l = autoEscape.length;i < l; i++) {\n      var ae = autoEscape[i];\n      if (rest.indexOf(ae) === -1)\n        continue;\n      var esc = encodeURIComponent(ae);\n      if (esc === ae)\n        esc = escape(ae);\n      rest = rest.split(ae).join(esc);\n    }\n  var hash = rest.indexOf(\"#\");\n  if (hash !== -1)\n    this.hash = rest.substr(hash), rest = rest.slice(0, hash);\n  var qm = rest.indexOf(\"\?\");\n  if (qm !== -1) {\n    if (this.search = rest.substr(qm), this.query = rest.substr(qm + 1), parseQueryString)\n      this.query = new URLSearchParams(this.query);\n    rest = rest.slice(0, qm);\n  } else if (parseQueryString)\n    this.search = \"\", this.query = {};\n  if (rest)\n    this.pathname = rest;\n  if (slashedProtocol[lowerProto] && this.hostname && !this.pathname)\n    this.pathname = \"/\";\n  if (this.pathname || this.search) {\n    var p = this.pathname || \"\", s = this.search || \"\";\n    this.path = p + s;\n  }\n  return this.href = this.format(), this;\n};\nUrl.prototype.format = function() {\n  var auth = this.auth || \"\";\n  if (auth)\n    auth = encodeURIComponent(auth), auth = auth.replace(/%3A/i, \":\"), auth += \"@\";\n  var protocol = this.protocol || \"\", pathname = this.pathname || \"\", hash = this.hash || \"\", host = !1, query = \"\";\n  if (this.host)\n    host = auth + this.host;\n  else if (this.hostname) {\n    if (host = auth + (this.hostname.indexOf(\":\") === -1 \? this.hostname : \"[\" + this.hostname + \"]\"), this.port)\n      host += \":\" + this.port;\n  }\n  if (this.query && typeof this.query === \"object\" && Object.keys(this.query).length)\n    query = new URLSearchParams(this.query).toString();\n  var search = this.search || query && \"\?\" + query || \"\";\n  if (protocol && protocol.substr(-1) !== \":\")\n    protocol += \":\";\n  if (this.slashes || (!protocol || slashedProtocol[protocol]) && host !== !1) {\n    if (host = \"//\" + (host || \"\"), pathname && pathname.charAt(0) !== \"/\")\n      pathname = \"/\" + pathname;\n  } else if (!host)\n    host = \"\";\n  if (hash && hash.charAt(0) !== \"#\")\n    hash = \"#\" + hash;\n  if (search && search.charAt(0) !== \"\?\")\n    search = \"\?\" + search;\n  return pathname = pathname.replace(/[\?#]/g, function(match) {\n    return encodeURIComponent(match);\n  }), search = search.replace(\"#\", \"%23\"), protocol + host + pathname + search + hash;\n};\nUrl.prototype.resolve = function(relative) {\n  return this.resolveObject(urlParse(relative, !1, !0)).format();\n};\nUrl.prototype.resolveObject = function(relative) {\n  if (typeof relative === \"string\") {\n    var rel = new Url;\n    rel.parse(relative, !1, !0), relative = rel;\n  }\n  var result = new Url, tkeys = Object.keys(this);\n  for (var tk = 0;tk < tkeys.length; tk++) {\n    var tkey = tkeys[tk];\n    result[tkey] = this[tkey];\n  }\n  if (result.hash = relative.hash, relative.href === \"\")\n    return result.href = result.format(), result;\n  if (relative.slashes && !relative.protocol) {\n    var rkeys = Object.keys(relative);\n    for (var rk = 0;rk < rkeys.length; rk++) {\n      var rkey = rkeys[rk];\n      if (rkey !== \"protocol\")\n        result[rkey] = relative[rkey];\n    }\n    if (slashedProtocol[result.protocol] && result.hostname && !result.pathname)\n      result.pathname = \"/\", result.path = result.pathname;\n    return result.href = result.format(), result;\n  }\n  if (relative.protocol && relative.protocol !== result.protocol) {\n    if (!slashedProtocol[relative.protocol]) {\n      var keys = Object.keys(relative);\n      for (var v = 0;v < keys.length; v++) {\n        var k = keys[v];\n        result[k] = relative[k];\n      }\n      return result.href = result.format(), result;\n    }\n    if (result.protocol = relative.protocol, !relative.host && !hostlessProtocol[relative.protocol]) {\n      var relPath = (relative.pathname || \"\").split(\"/\");\n      while (relPath.length && !(relative.host = relPath.shift()))\n        ;\n      if (!relative.host)\n        relative.host = \"\";\n      if (!relative.hostname)\n        relative.hostname = \"\";\n      if (relPath[0] !== \"\")\n        relPath.unshift(\"\");\n      if (relPath.length < 2)\n        relPath.unshift(\"\");\n      result.pathname = relPath.join(\"/\");\n    } else\n      result.pathname = relative.pathname;\n    if (result.search = relative.search, result.query = relative.query, result.host = relative.host || \"\", result.auth = relative.auth, result.hostname = relative.hostname || relative.host, result.port = relative.port, result.pathname || result.search) {\n      var p = result.pathname || \"\", s = result.search || \"\";\n      result.path = p + s;\n    }\n    return result.slashes = result.slashes || relative.slashes, result.href = result.format(), result;\n  }\n  var isSourceAbs = result.pathname && result.pathname.charAt(0) === \"/\", isRelAbs = relative.host || relative.pathname && relative.pathname.charAt(0) === \"/\", mustEndAbs = isRelAbs || isSourceAbs || result.host && relative.pathname, removeAllDots = mustEndAbs, srcPath = result.pathname && result.pathname.split(\"/\") || [], relPath = relative.pathname && relative.pathname.split(\"/\") || [], psychotic = result.protocol && !slashedProtocol[result.protocol];\n  if (psychotic) {\n    if (result.hostname = \"\", result.port = null, result.host)\n      if (srcPath[0] === \"\")\n        srcPath[0] = result.host;\n      else\n        srcPath.unshift(result.host);\n    if (result.host = \"\", relative.protocol) {\n      if (relative.hostname = null, relative.port = null, relative.host)\n        if (relPath[0] === \"\")\n          relPath[0] = relative.host;\n        else\n          relPath.unshift(relative.host);\n      relative.host = null;\n    }\n    mustEndAbs = mustEndAbs && (relPath[0] === \"\" || srcPath[0] === \"\");\n  }\n  if (isRelAbs)\n    result.host = relative.host || relative.host === \"\" \? relative.host : result.host, result.hostname = relative.hostname || relative.hostname === \"\" \? relative.hostname : result.hostname, result.search = relative.search, result.query = relative.query, srcPath = relPath;\n  else if (relPath.length) {\n    if (!srcPath)\n      srcPath = [];\n    srcPath.pop(), srcPath = srcPath.concat(relPath), result.search = relative.search, result.query = relative.query;\n  } else if (relative.search != null) {\n    if (psychotic) {\n      result.host = srcPath.shift(), result.hostname = result.host;\n      var authInHost = result.host && result.host.indexOf(\"@\") > 0 \? result.host.split(\"@\") : !1;\n      if (authInHost)\n        result.auth = authInHost.shift(), result.hostname = authInHost.shift(), result.host = result.hostname;\n    }\n    if (result.search = relative.search, result.query = relative.query, result.pathname !== null || result.search !== null)\n      result.path = (result.pathname \? result.pathname : \"\") + (result.search \? result.search : \"\");\n    return result.href = result.format(), result;\n  }\n  if (!srcPath.length) {\n    if (result.pathname = null, result.search)\n      result.path = \"/\" + result.search;\n    else\n      result.path = null;\n    return result.href = result.format(), result;\n  }\n  var last = srcPath.slice(-1)[0], hasTrailingSlash = (result.host || relative.host || srcPath.length > 1) && (last === \".\" || last === \"..\") || last === \"\", up = 0;\n  for (var i = srcPath.length;i >= 0; i--)\n    if (last = srcPath[i], last === \".\")\n      srcPath.splice(i, 1);\n    else if (last === \"..\")\n      srcPath.splice(i, 1), up++;\n    else if (up)\n      srcPath.splice(i, 1), up--;\n  if (!mustEndAbs && !removeAllDots)\n    for (;up--; up)\n      srcPath.unshift(\"..\");\n  if (mustEndAbs && srcPath[0] !== \"\" && (!srcPath[0] || srcPath[0].charAt(0) !== \"/\"))\n    srcPath.unshift(\"\");\n  if (hasTrailingSlash && srcPath.join(\"/\").substr(-1) !== \"/\")\n    srcPath.push(\"\");\n  var isAbsolute = srcPath[0] === \"\" || srcPath[0] && srcPath[0].charAt(0) === \"/\";\n  if (psychotic) {\n    result.hostname = isAbsolute \? \"\" : srcPath.length \? srcPath.shift() : \"\", result.host = result.hostname;\n    var authInHost = result.host && result.host.indexOf(\"@\") > 0 \? result.host.split(\"@\") : !1;\n    if (authInHost)\n      result.auth = authInHost.shift(), result.hostname = authInHost.shift(), result.host = result.hostname;\n  }\n  if (mustEndAbs = mustEndAbs || result.host && srcPath.length, mustEndAbs && !isAbsolute)\n    srcPath.unshift(\"\");\n  if (srcPath.length > 0)\n    result.pathname = srcPath.join(\"/\");\n  else\n    result.pathname = null, result.path = null;\n  if (result.pathname !== null || result.search !== null)\n    result.path = (result.pathname \? result.pathname : \"\") + (result.search \? result.search : \"\");\n  return result.auth = relative.auth || result.auth, result.slashes = result.slashes || relative.slashes, result.href = result.format(), result;\n};\nUrl.prototype.parseHost = function() {\n  var host = this.host, port = portPattern.exec(host);\n  if (port) {\n    if (port = port[0], port !== \":\")\n      this.port = port.substr(1);\n    host = host.substr(0, host.length - port.length);\n  }\n  if (host)\n    this.hostname = host;\n};\nvar pathToFileURL = globalThis[globalThis.Symbol.for('Bun.lazy')](\"pathToFileURL\"), fileURLToPath = globalThis[globalThis.Symbol.for('Bun.lazy')](\"fileURLToPath\");\n$ = {\n  parse: urlParse,\n  resolve: urlResolve,\n  resolveObject: urlResolveObject,\n  format: urlFormat,\n  Url,\n  URLSearchParams,\n  URL,\n  pathToFileURL,\n  fileURLToPath,\n  urlToHttpOptions\n};\nreturn $})\n"_s;
//

//
static constexpr ASCIILiteral NodeUtilCode = "(function (){\"use strict\";// src/js/out/tmp/node/util.ts\nvar isBufferInterface = function({ copy, fill, readUint8 }) {\n  return typeof copy === \"function\" && typeof fill === \"function\" && typeof readUint8 === \"function\";\n}, isBuffer = function(value) {\n  return Buffer.isBuffer(value) || typeof value === \"object\" && isBufferInterface(value || {});\n}, isFunction = function(value) {\n  return typeof value === \"function\";\n}, formatWithOptions = function(inspectOptions, f) {\n  if (!isString(f)) {\n    var objects = [];\n    for (var i = 0;i < arguments.length; i++)\n      objects.push(inspect(arguments[i], inspectOptions));\n    return objects.join(\" \");\n  }\n  var i = 2, args = arguments, len = args.length, str = String(f).replace(formatRegExp, function(x2) {\n    if (x2 === \"%%\")\n      return \"%\";\n    if (i >= len)\n      return x2;\n    switch (x2) {\n      case \"%s\":\n        return String(args[i++]);\n      case \"%f\":\n        return Number(args[i++]);\n      case \"%d\":\n        return Math.round(Number(args[i++]));\n      case \"%j\":\n        try {\n          return JSON.stringify(args[i++]);\n        } catch (_) {\n          return \"[Circular]\";\n        }\n      case \"%o\":\n        return inspect(args[i++], { showHidden: !0, showProxy: !0, ...inspectOptions });\n      case \"%O\":\n        return inspect(args[i++], { showHidden: !0, showProxy: !0, ...inspectOptions });\n      default:\n        return x2;\n    }\n  });\n  for (var x = args[i];i < len; x = args[++i])\n    if (isNull(x) || !isObject(x))\n      str += \" \" + x;\n    else\n      str += \" \" + inspect(x, inspectOptions);\n  return str;\n}, format = function(...args) {\n  return formatWithOptions({}, ...args);\n}, deprecate = function(fn, msg, code) {\n  if (process.noDeprecation === !0)\n    return fn;\n  var warned = !1;\n  function deprecated() {\n    if (!warned) {\n      if (process.throwDeprecation) {\n        var err = new Error(msg);\n        if (code)\n          err.code = code;\n        throw err;\n      } else if (process.traceDeprecation)\n        console.trace(msg);\n      else\n        console.error(msg);\n      warned = !0;\n    }\n    return fn.apply(this, arguments);\n  }\n  return deprecated;\n}, debuglog = function(set) {\n  if (set = set.toUpperCase(), !debugs[set])\n    if (debugEnvRegex.test(set)) {\n      var pid = process.pid;\n      debugs[set] = function() {\n        var msg = format.apply(cjs_exports, arguments);\n        console.error(\"%s %d: %s\", set, pid, msg);\n      };\n    } else\n      debugs[set] = function() {\n      };\n  return debugs[set];\n}, inspect = function(obj, opts) {\n  var ctx = {\n    seen: [],\n    stylize: stylizeNoColor\n  };\n  if (arguments.length >= 3)\n    ctx.depth = arguments[2];\n  if (arguments.length >= 4)\n    ctx.colors = arguments[3];\n  if (isBoolean(opts))\n    ctx.showHidden = opts;\n  else if (opts)\n    _extend(ctx, opts);\n  if (isUndefined(ctx.showHidden))\n    ctx.showHidden = !1;\n  if (isUndefined(ctx.depth))\n    ctx.depth = 2;\n  if (isUndefined(ctx.colors))\n    ctx.colors = !1;\n  if (isUndefined(ctx.customInspect))\n    ctx.customInspect = !0;\n  if (ctx.colors)\n    ctx.stylize = stylizeWithColor;\n  return formatValue(ctx, obj, ctx.depth);\n}, stylizeWithColor = function(str, styleType) {\n  const style = inspect.styles[styleType];\n  if (style !== void 0) {\n    const color = inspect.colors[style];\n    if (color !== void 0)\n      return `\\x1B[${color[0]}m${str}\\x1B[${color[1]}m`;\n  }\n  return str;\n}, stylizeNoColor = function(str, styleType) {\n  return str;\n}, arrayToHash = function(array) {\n  var hash = {};\n  return array.forEach(function(val, idx) {\n    hash[val] = !0;\n  }), hash;\n}, formatValue = function(ctx, value, recurseTimes) {\n  if (ctx.customInspect && value) {\n    const customInspect = value[kInspectCustom];\n    if (isFunction(customInspect)) {\n      var ret = customInspect.call(value, recurseTimes, ctx, inspect);\n      if (!isString(ret))\n        ret = formatValue(ctx, ret, recurseTimes);\n      return ret;\n    }\n  }\n  var primitive = formatPrimitive(ctx, value);\n  if (primitive)\n    return primitive;\n  var keys = Object.keys(value).concat(Object.getOwnPropertySymbols(value)), visibleKeys = arrayToHash(keys);\n  if (ctx.showHidden)\n    keys = Object.getOwnPropertyNames(value);\n  if (isError(value) && (keys.indexOf(\"message\") >= 0 || keys.indexOf(\"description\") >= 0))\n    return formatError(value);\n  if (keys.length === 0) {\n    if (isFunction(value)) {\n      var name = value.name \? \": \" + value.name : \"\";\n      return ctx.stylize(\"[Function\" + name + \"]\", \"special\");\n    }\n    if (isRegExp(value))\n      return ctx.stylize(RegExp.prototype.toString.call(value), \"regexp\");\n    if (isDate(value))\n      return ctx.stylize(Date.prototype.toString.call(value), \"date\");\n    if (isError(value))\n      return formatError(value);\n  }\n  var base = \"\", array = !1, braces = [\"{\", \"}\"];\n  if (@isArray(value))\n    array = !0, braces = [\"[\", \"]\"];\n  if (isFunction(value)) {\n    var n = value.name \? \": \" + value.name : \"\";\n    base = \" [Function\" + n + \"]\";\n  }\n  if (isRegExp(value))\n    base = \" \" + RegExp.prototype.toString.call(value);\n  if (isDate(value))\n    base = \" \" + Date.prototype.toUTCString.call(value);\n  if (isError(value))\n    base = \" \" + formatError(value);\n  if (keys.length === 0 && (!array || value.length == 0))\n    return braces[0] + base + braces[1];\n  if (recurseTimes < 0)\n    if (isRegExp(value))\n      return ctx.stylize(RegExp.prototype.toString.call(value), \"regexp\");\n    else\n      return ctx.stylize(\"[Object]\", \"special\");\n  ctx.seen.push(value);\n  var output;\n  if (array)\n    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);\n  else\n    output = keys.map(function(key) {\n      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);\n    });\n  return ctx.seen.pop(), reduceToSingleString(output, base, braces);\n}, formatPrimitive = function(ctx, value) {\n  if (isUndefined(value))\n    return ctx.stylize(\"undefined\", \"undefined\");\n  if (isString(value)) {\n    var simple = \"'\" + JSON.stringify(value).replace(/^\"|\"$/g, \"\").replace(/'/g, \"\\\\'\").replace(/\\\\\"/g, '\"') + \"'\";\n    return ctx.stylize(simple, \"string\");\n  }\n  if (isNumber(value))\n    return ctx.stylize(\"\" + value, \"number\");\n  if (isBoolean(value))\n    return ctx.stylize(\"\" + value, \"boolean\");\n  if (isNull(value))\n    return ctx.stylize(\"null\", \"null\");\n}, formatError = function(value) {\n  return \"[\" + Error.prototype.toString.call(value) + \"]\";\n}, formatArray = function(ctx, value, recurseTimes, visibleKeys, keys) {\n  var output = [];\n  for (var i = 0, l = value.length;i < l; ++i)\n    if (hasOwnProperty(value, String(i)))\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i), !0));\n    else\n      output.push(\"\");\n  return keys.forEach(function(key) {\n    if (!key.match(/^\\d+$/))\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, !0));\n  }), output;\n}, formatProperty = function(ctx, value, recurseTimes, visibleKeys, key, array) {\n  var name, str, desc;\n  if (desc = Object.getOwnPropertyDescriptor(value, key) || {\n    value: value[key]\n  }, desc.get)\n    if (desc.set)\n      str = ctx.stylize(\"[Getter/Setter]\", \"special\");\n    else\n      str = ctx.stylize(\"[Getter]\", \"special\");\n  else if (desc.set)\n    str = ctx.stylize(\"[Setter]\", \"special\");\n  if (!hasOwnProperty(visibleKeys, key))\n    name = \"[\" + (typeof key === \"symbol\" \? key.description : key) + \"]\";\n  if (typeof key === \"symbol\")\n    name = \"[\" + ctx.stylize(`Symbol(${key.description})`, \"string\") + \"]\";\n  if (!str)\n    if (ctx.seen.indexOf(desc.value) < 0) {\n      if (isNull(recurseTimes))\n        str = formatValue(ctx, desc.value, null);\n      else\n        str = formatValue(ctx, desc.value, recurseTimes - 1);\n      if (str.indexOf(\"\\n\") > -1)\n        if (array)\n          str = str.split(\"\\n\").map(function(line) {\n            return \"  \" + line;\n          }).join(\"\\n\").substr(2);\n        else\n          str = \"\\n\" + str.split(\"\\n\").map(function(line) {\n            return \"   \" + line;\n          }).join(\"\\n\");\n    } else\n      str = ctx.stylize(\"[Circular]\", \"special\");\n  if (isUndefined(name)) {\n    if (array && key.match(/^\\d+$/))\n      return str;\n    if (name = JSON.stringify(\"\" + key), name.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/))\n      name = name.substr(1, name.length - 2), name = ctx.stylize(name, \"name\");\n    else\n      name = name.replace(/'/g, \"\\\\'\").replace(/\\\\\"/g, '\"').replace(/(^\"|\"$)/g, \"'\"), name = ctx.stylize(name, \"string\");\n  }\n  return name + \": \" + str;\n}, reduceToSingleString = function(output, base, braces) {\n  var numLinesEst = 0, length = output.reduce(function(prev, cur) {\n    if (numLinesEst++, cur.indexOf(\"\\n\") >= 0)\n      numLinesEst++;\n    return prev + cur.replace(/\\u001b\\[\\d\\d\?m/g, \"\").length + 1;\n  }, 0);\n  if (length > 60)\n    return braces[0] + (base === \"\" \? \"\" : base + \"\\n \") + \" \" + output.join(\",\\n  \") + \" \" + braces[1];\n  return braces[0] + base + \" \" + output.join(\", \") + \" \" + braces[1];\n}, isBoolean = function(arg) {\n  return typeof arg === \"boolean\";\n}, isNull = function(arg) {\n  return arg === null;\n}, isNullOrUndefined = function(arg) {\n  return arg == null;\n}, isNumber = function(arg) {\n  return typeof arg === \"number\";\n}, isString = function(arg) {\n  return typeof arg === \"string\";\n}, isSymbol = function(arg) {\n  return typeof arg === \"symbol\";\n}, isUndefined = function(arg) {\n  return arg === void 0;\n}, isObject = function(arg) {\n  return typeof arg === \"object\" && arg !== null;\n}, isPrimitive = function(arg) {\n  return arg === null || typeof arg === \"boolean\" || typeof arg === \"number\" || typeof arg === \"string\" || typeof arg === \"symbol\" || typeof arg === \"undefined\";\n}, pad = function(n) {\n  return n < 10 \? \"0\" + n.toString(10) : n.toString(10);\n}, timestamp = function() {\n  var d = new Date, time = [pad(d.getHours()), pad(d.getMinutes()), pad(d.getSeconds())].join(\":\");\n  return [d.getDate(), months[d.getMonth()], time].join(\" \");\n}, hasOwnProperty = function(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}, callbackifyOnRejected = function(reason, cb) {\n  if (!reason) {\n    var newReason = new Error(\"Promise was rejected with a falsy value\");\n    newReason.reason = reason, newReason.code = \"ERR_FALSY_VALUE_REJECTION\", reason = newReason;\n  }\n  return cb(reason);\n}, callbackify = function(original) {\n  if (typeof original !== \"function\")\n    @throwTypeError('The \"original\" argument must be of type Function');\n  function callbackified() {\n    var args = Array.prototype.slice.call(arguments), maybeCb = args.pop();\n    if (typeof maybeCb !== \"function\")\n      @throwTypeError(\"The last argument must be of type Function\");\n    var self = this, cb = function() {\n      return maybeCb.apply(self, arguments);\n    };\n    original.apply(this, args).then(function(ret) {\n      process.nextTick(cb, null, ret);\n    }, function(rej) {\n      process.nextTick(callbackifyOnRejected, rej, cb);\n    });\n  }\n  return Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original)), Object.defineProperties(callbackified, getOwnPropertyDescriptors(original)), callbackified;\n}, $, types = @requireNativeModule(\"node:util/types\"), cjs_exports = {}, deepEquals = Bun.deepEquals, isDeepStrictEqual = (a, b) => deepEquals(a, b, !0), getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors, formatRegExp = /%[sdjfoc%]/g, debugs = {}, debugEnvRegex = /^$/;\nif (process.env.NODE_DEBUG)\n  debugEnv = process.env.NODE_DEBUG, debugEnv = debugEnv.replace(/[|\\\\{}()[\\]^$+\?.]/g, \"\\\\$&\").replace(/\\*/g, \".*\").replace(/,/g, \"$|^\").toUpperCase(), debugEnvRegex = new RegExp(\"^\" + debugEnv + \"$\", \"i\");\nvar debugEnv, kInspectCustom = Symbol.for(\"nodejs.util.inspect.custom\");\ninspect.colors = {\n  bold: [1, 22],\n  italic: [3, 23],\n  underline: [4, 24],\n  inverse: [7, 27],\n  white: [37, 39],\n  grey: [90, 39],\n  black: [30, 39],\n  blue: [34, 39],\n  cyan: [36, 39],\n  green: [32, 39],\n  magenta: [35, 39],\n  red: [31, 39],\n  yellow: [33, 39]\n};\ninspect.styles = {\n  special: \"cyan\",\n  number: \"yellow\",\n  boolean: \"yellow\",\n  undefined: \"grey\",\n  null: \"bold\",\n  string: \"green\",\n  date: \"magenta\",\n  regexp: \"red\"\n};\ninspect.custom = kInspectCustom;\ninspect.defaultOptions = {\n  showHidden: !1,\n  depth: 2,\n  colors: !1,\n  customInspect: !0,\n  showProxy: !1,\n  maxArrayLength: 100,\n  maxStringLength: 1e4,\n  breakLength: 80,\n  compact: 3,\n  sorted: !1,\n  getters: !1,\n  numericSeparator: !1\n};\nvar { isRegExp, isDate, isNativeError: isError } = types, months = [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"], log = function log2() {\n  console.log(\"%s - %s\", timestamp(), format.apply(cjs_exports, arguments));\n}, inherits = function inherits2(ctor, superCtor) {\n  ctor.super_ = superCtor, ctor.prototype = Object.create(superCtor.prototype, {\n    constructor: {\n      value: ctor,\n      enumerable: !1,\n      writable: !0,\n      configurable: !0\n    }\n  });\n}, _extend = function(origin, add) {\n  if (!add || !isObject(add))\n    return origin;\n  var keys = Object.keys(add), i = keys.length;\n  while (i--)\n    origin[keys[i]] = add[keys[i]];\n  return origin;\n}, kCustomPromisifiedSymbol = Symbol.for(\"util.promisify.custom\"), promisify = function promisify2(original) {\n  if (typeof original !== \"function\")\n    @throwTypeError('The \"original\" argument must be of type Function');\n  if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {\n    var fn = original[kCustomPromisifiedSymbol];\n    if (typeof fn !== \"function\")\n      @throwTypeError('The \"util.promisify.custom\" argument must be of type Function');\n    return Object.defineProperty(fn, kCustomPromisifiedSymbol, {\n      value: fn,\n      enumerable: !1,\n      writable: !1,\n      configurable: !0\n    }), fn;\n  }\n  function fn() {\n    var promiseResolve, promiseReject, promise = new Promise(function(resolve, reject) {\n      promiseResolve = resolve, promiseReject = reject;\n    }), args = [];\n    for (var i = 0;i < arguments.length; i++)\n      args.push(arguments[i]);\n    args.push(function(err, value) {\n      if (err)\n        promiseReject(err);\n      else\n        promiseResolve(value);\n    });\n    try {\n      original.apply(this, args);\n    } catch (err) {\n      promiseReject(err);\n    }\n    return promise;\n  }\n  if (Object.setPrototypeOf(fn, Object.getPrototypeOf(original)), kCustomPromisifiedSymbol)\n    Object.defineProperty(fn, kCustomPromisifiedSymbol, {\n      value: fn,\n      enumerable: !1,\n      writable: !1,\n      configurable: !0\n    });\n  return Object.defineProperties(fn, getOwnPropertyDescriptors(original));\n};\npromisify.custom = kCustomPromisifiedSymbol;\nvar toUSVString = (input) => {\n  return (input + \"\").toWellFormed();\n};\n$ = Object.assign(cjs_exports, {\n  format,\n  formatWithOptions,\n  deprecate,\n  debuglog,\n  _extend,\n  inspect,\n  types,\n  isArray: @isArray,\n  isBoolean,\n  isNull,\n  isNullOrUndefined,\n  isNumber,\n  isString,\n  isSymbol,\n  isUndefined,\n  isRegExp,\n  isObject,\n  isDate,\n  isFunction,\n  isError,\n  isPrimitive,\n  isBuffer,\n  log,\n  inherits,\n  toUSVString,\n  promisify,\n  callbackify,\n  isDeepStrictEqual,\n  TextDecoder,\n  TextEncoder\n});\nreturn $})\n"_s;
//

//
static constexpr ASCIILiteral NodeV8Code = "(function (){\"use strict\";// src/js/out/tmp/node/v8.ts\nvar notimpl = function(message) {\n  throwNotImplemented(\"node:v8 \" + message);\n}, cachedDataVersionTag = function() {\n  notimpl(\"cachedDataVersionTag\");\n}, getHeapSnapshot = function() {\n  notimpl(\"getHeapSnapshot\");\n}, getHeapStatistics = function() {\n  notimpl(\"getHeapStatistics\");\n}, getHeapSpaceStatistics = function() {\n  notimpl(\"getHeapSpaceStatistics\");\n}, getHeapCodeStatistics = function() {\n  notimpl(\"getHeapCodeStatistics\");\n}, setFlagsFromString = function() {\n  notimpl(\"setFlagsFromString\");\n}, deserialize = function(value) {\n  return jsc.deserialize(value);\n}, takeCoverage = function() {\n  notimpl(\"takeCoverage\");\n}, stopCoverage = function() {\n  notimpl(\"stopCoverage\");\n}, serialize = function(arg1) {\n  return jsc.serialize(arg1, { binaryType: \"nodebuffer\" });\n}, writeHeapSnapshot = function() {\n  notimpl(\"writeHeapSnapshot\");\n}, setHeapSnapshotNearHeapLimit = function() {\n  notimpl(\"setHeapSnapshotNearHeapLimit\");\n}, $, { hideFromStack, throwNotImplemented } = @getInternalField(@internalModuleRegistry, 3) || @createInternalModuleById(3), jsc = @requireNativeModule(\"bun:jsc\");\n\nclass Deserializer {\n  constructor() {\n    notimpl(\"Deserializer\");\n  }\n}\n\nclass Serializer {\n  constructor() {\n    notimpl(\"Serializer\");\n  }\n}\n\nclass DefaultDeserializer extends Deserializer {\n  constructor() {\n    super(...arguments);\n  }\n}\n\nclass DefaultSerializer extends Serializer {\n  constructor() {\n    super(...arguments);\n  }\n}\n\nclass GCProfiler {\n  constructor() {\n    notimpl(\"GCProfiler\");\n  }\n}\nvar promiseHooks = {\n  createHook: () => {\n    notimpl(\"createHook\");\n  },\n  onInit: () => {\n    notimpl(\"onInit\");\n  },\n  onBefore: () => {\n    notimpl(\"onBefore\");\n  },\n  onAfter: () => {\n    notimpl(\"onAfter\");\n  },\n  onSettled: () => {\n    notimpl(\"onSettled\");\n  }\n}, startupSnapshot = {\n  addDeserializeCallback: () => notimpl(\"addDeserializeCallback\"),\n  addSerializeCallback: () => notimpl(\"addSerializeCallback\"),\n  setDeserializeMainFunction: () => notimpl(\"setDeserializeMainFunction\"),\n  isBuildingSnapshot: () => notimpl(\"isBuildingSnapshot\")\n};\n$ = {\n  cachedDataVersionTag,\n  getHeapSnapshot,\n  getHeapStatistics,\n  getHeapSpaceStatistics,\n  getHeapCodeStatistics,\n  setFlagsFromString,\n  deserialize,\n  takeCoverage,\n  stopCoverage,\n  serialize,\n  writeHeapSnapshot,\n  setHeapSnapshotNearHeapLimit,\n  promiseHooks,\n  startupSnapshot,\n  Deserializer,\n  Serializer\n};\nhideFromStack(notimpl, cachedDataVersionTag, getHeapSnapshot, getHeapStatistics, getHeapSpaceStatistics, getHeapCodeStatistics, setFlagsFromString, deserialize, takeCoverage, stopCoverage, serialize, writeHeapSnapshot, setHeapSnapshotNearHeapLimit, Deserializer, Serializer, DefaultDeserializer, DefaultSerializer, GCProfiler);\nreturn $})\n"_s;
//

//
static constexpr ASCIILiteral NodeVMCode = "(function (){\"use strict\";// src/js/out/tmp/node/vm.ts\nvar runInContext = function(code, context, options) {\n  return new Script(code, options).runInContext(context);\n}, compileFunction = function() {\n  throwNotImplemented(\"node:vm compileFunction\");\n}, measureMemory = function() {\n  throwNotImplemented(\"node:vm measureMemory\");\n}, $, { throwNotImplemented } = @getInternalField(@internalModuleRegistry, 3) || @createInternalModuleById(3), vm = globalThis[globalThis.Symbol.for('Bun.lazy')](\"vm\"), { createContext, isContext, Script, runInNewContext, runInThisContext } = vm;\n\nclass Module {\n  constructor() {\n    throwNotImplemented(\"node:vm Module\");\n  }\n}\n\nclass SourceTextModule {\n  constructor() {\n    throwNotImplemented(\"node:vm Module\");\n  }\n}\n\nclass SyntheticModule {\n  constructor() {\n    throwNotImplemented(\"node:vm Module\");\n  }\n}\n$ = {\n  createContext,\n  runInContext,\n  runInNewContext,\n  runInThisContext,\n  isContext,\n  compileFunction,\n  measureMemory,\n  Script,\n  Module,\n  SourceTextModule,\n  SyntheticModule\n};\nreturn $})\n"_s;
//

//
static constexpr ASCIILiteral NodeWasiCode = "(function (){\"use strict\";// src/js/out/tmp/node/wasi.ts\nvar nodeFsConstants = @processBindingConstants.fs, __getOwnPropNames = Object.getOwnPropertyNames, __commonJS = (cb, mod) => function __require2() {\n  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;\n}, require_types = __commonJS({\n  \"node_modules/wasi-js/dist/types.js\"(exports) {\n    Object.defineProperty(exports, \"__esModule\", { value: !0 }), exports.WASIKillError = exports.WASIExitError = exports.WASIError = void 0;\n    var WASIError = class extends Error {\n      constructor(errno) {\n        super();\n        this.errno = errno, Object.setPrototypeOf(this, WASIError.prototype);\n      }\n    };\n    exports.WASIError = WASIError;\n    var WASIExitError = class extends Error {\n      constructor(code) {\n        super(`WASI Exit error: ${code}`);\n        this.code = code, Object.setPrototypeOf(this, WASIExitError.prototype);\n      }\n    };\n    exports.WASIExitError = WASIExitError;\n    var WASIKillError = class extends Error {\n      constructor(signal) {\n        super(`WASI Kill signal: ${signal}`);\n        this.signal = signal, Object.setPrototypeOf(this, WASIKillError.prototype);\n      }\n    };\n    exports.WASIKillError = WASIKillError;\n  }\n}), require_constants = __commonJS({\n  \"node_modules/wasi-js/dist/constants.js\"(exports) {\n    Object.defineProperty(exports, \"__esModule\", { value: !0 }), exports.WASI_ENOMSG = exports.WASI_ENOMEM = exports.WASI_ENOLINK = exports.WASI_ENOLCK = exports.WASI_ENOEXEC = exports.WASI_ENOENT = exports.WASI_ENODEV = exports.WASI_ENOBUFS = exports.WASI_ENFILE = exports.WASI_ENETUNREACH = exports.WASI_ENETRESET = exports.WASI_ENETDOWN = exports.WASI_ENAMETOOLONG = exports.WASI_EMULTIHOP = exports.WASI_EMSGSIZE = exports.WASI_EMLINK = exports.WASI_EMFILE = exports.WASI_ELOOP = exports.WASI_EISDIR = exports.WASI_EISCONN = exports.WASI_EIO = exports.WASI_EINVAL = exports.WASI_EINTR = exports.WASI_EINPROGRESS = exports.WASI_EILSEQ = exports.WASI_EIDRM = exports.WASI_EHOSTUNREACH = exports.WASI_EFBIG = exports.WASI_EFAULT = exports.WASI_EEXIST = exports.WASI_EDQUOT = exports.WASI_EDOM = exports.WASI_EDESTADDRREQ = exports.WASI_EDEADLK = exports.WASI_ECONNRESET = exports.WASI_ECONNREFUSED = exports.WASI_ECONNABORTED = exports.WASI_ECHILD = exports.WASI_ECANCELED = exports.WASI_EBUSY = exports.WASI_EBADMSG = exports.WASI_EBADF = exports.WASI_EALREADY = exports.WASI_EAGAIN = exports.WASI_EAFNOSUPPORT = exports.WASI_EADDRNOTAVAIL = exports.WASI_EADDRINUSE = exports.WASI_EACCES = exports.WASI_E2BIG = exports.WASI_ESUCCESS = void 0, exports.WASI_SIGVTALRM = exports.WASI_SIGUSR2 = exports.WASI_SIGUSR1 = exports.WASI_SIGURG = exports.WASI_SIGTTOU = exports.WASI_SIGTTIN = exports.WASI_SIGTSTP = exports.WASI_SIGTRAP = exports.WASI_SIGTERM = exports.WASI_SIGSTOP = exports.WASI_SIGSEGV = exports.WASI_SIGQUIT = exports.WASI_SIGPIPE = exports.WASI_SIGKILL = exports.WASI_SIGINT = exports.WASI_SIGILL = exports.WASI_SIGHUP = exports.WASI_SIGFPE = exports.WASI_SIGCONT = exports.WASI_SIGCHLD = exports.WASI_SIGBUS = exports.WASI_SIGALRM = exports.WASI_SIGABRT = exports.WASI_ENOTCAPABLE = exports.WASI_EXDEV = exports.WASI_ETXTBSY = exports.WASI_ETIMEDOUT = exports.WASI_ESTALE = exports.WASI_ESRCH = exports.WASI_ESPIPE = exports.WASI_EROFS = exports.WASI_ERANGE = exports.WASI_EPROTOTYPE = exports.WASI_EPROTONOSUPPORT = exports.WASI_EPROTO = exports.WASI_EPIPE = exports.WASI_EPERM = exports.WASI_EOWNERDEAD = exports.WASI_EOVERFLOW = exports.WASI_ENXIO = exports.WASI_ENOTTY = exports.WASI_ENOTSUP = exports.WASI_ENOTSOCK = exports.WASI_ENOTRECOVERABLE = exports.WASI_ENOTEMPTY = exports.WASI_ENOTDIR = exports.WASI_ENOTCONN = exports.WASI_ENOSYS = exports.WASI_ENOSPC = exports.WASI_ENOPROTOOPT = void 0, exports.RIGHTS_REGULAR_FILE_BASE = exports.RIGHTS_CHARACTER_DEVICE_INHERITING = exports.RIGHTS_CHARACTER_DEVICE_BASE = exports.RIGHTS_BLOCK_DEVICE_INHERITING = exports.RIGHTS_BLOCK_DEVICE_BASE = exports.RIGHTS_ALL = exports.WASI_RIGHT_SOCK_SHUTDOWN = exports.WASI_RIGHT_POLL_FD_READWRITE = exports.WASI_RIGHT_PATH_UNLINK_FILE = exports.WASI_RIGHT_PATH_REMOVE_DIRECTORY = exports.WASI_RIGHT_PATH_SYMLINK = exports.WASI_RIGHT_FD_FILESTAT_SET_TIMES = exports.WASI_RIGHT_FD_FILESTAT_SET_SIZE = exports.WASI_RIGHT_FD_FILESTAT_GET = exports.WASI_RIGHT_PATH_FILESTAT_SET_TIMES = exports.WASI_RIGHT_PATH_FILESTAT_SET_SIZE = exports.WASI_RIGHT_PATH_FILESTAT_GET = exports.WASI_RIGHT_PATH_RENAME_TARGET = exports.WASI_RIGHT_PATH_RENAME_SOURCE = exports.WASI_RIGHT_PATH_READLINK = exports.WASI_RIGHT_FD_READDIR = exports.WASI_RIGHT_PATH_OPEN = exports.WASI_RIGHT_PATH_LINK_TARGET = exports.WASI_RIGHT_PATH_LINK_SOURCE = exports.WASI_RIGHT_PATH_CREATE_FILE = exports.WASI_RIGHT_PATH_CREATE_DIRECTORY = exports.WASI_RIGHT_FD_ALLOCATE = exports.WASI_RIGHT_FD_ADVISE = exports.WASI_RIGHT_FD_WRITE = exports.WASI_RIGHT_FD_TELL = exports.WASI_RIGHT_FD_SYNC = exports.WASI_RIGHT_FD_FDSTAT_SET_FLAGS = exports.WASI_RIGHT_FD_SEEK = exports.WASI_RIGHT_FD_READ = exports.WASI_RIGHT_FD_DATASYNC = exports.WASI_FDFLAG_SYNC = exports.WASI_FDFLAG_RSYNC = exports.WASI_FDFLAG_NONBLOCK = exports.WASI_FDFLAG_DSYNC = exports.WASI_FDFLAG_APPEND = exports.WASI_FILETYPE_SYMBOLIC_LINK = exports.WASI_FILETYPE_SOCKET_STREAM = exports.WASI_FILETYPE_SOCKET_DGRAM = exports.WASI_FILETYPE_REGULAR_FILE = exports.WASI_FILETYPE_DIRECTORY = exports.WASI_FILETYPE_CHARACTER_DEVICE = exports.WASI_FILETYPE_BLOCK_DEVICE = exports.WASI_FILETYPE_UNKNOWN = exports.WASI_SIGXFSZ = exports.WASI_SIGXCPU = void 0, exports.SIGNAL_MAP = exports.ERROR_MAP = exports.WASI_WHENCE_END = exports.WASI_WHENCE_CUR = exports.WASI_WHENCE_SET = exports.WASI_STDERR_FILENO = exports.WASI_STDOUT_FILENO = exports.WASI_STDIN_FILENO = exports.WASI_DIRCOOKIE_START = exports.WASI_PREOPENTYPE_DIR = exports.WASI_O_TRUNC = exports.WASI_O_EXCL = exports.WASI_O_DIRECTORY = exports.WASI_O_CREAT = exports.WASI_FILESTAT_SET_MTIM_NOW = exports.WASI_FILESTAT_SET_MTIM = exports.WASI_FILESTAT_SET_ATIM_NOW = exports.WASI_FILESTAT_SET_ATIM = exports.WASI_EVENTTYPE_FD_WRITE = exports.WASI_EVENTTYPE_FD_READ = exports.WASI_EVENTTYPE_CLOCK = exports.WASI_CLOCK_THREAD_CPUTIME_ID = exports.WASI_CLOCK_PROCESS_CPUTIME_ID = exports.WASI_CLOCK_MONOTONIC = exports.WASI_CLOCK_REALTIME = exports.RIGHTS_TTY_INHERITING = exports.RIGHTS_TTY_BASE = exports.RIGHTS_SOCKET_INHERITING = exports.RIGHTS_SOCKET_BASE = exports.RIGHTS_DIRECTORY_INHERITING = exports.RIGHTS_DIRECTORY_BASE = exports.RIGHTS_REGULAR_FILE_INHERITING = void 0, exports.WASI_ESUCCESS = 0, exports.WASI_E2BIG = 1, exports.WASI_EACCES = 2, exports.WASI_EADDRINUSE = 3, exports.WASI_EADDRNOTAVAIL = 4, exports.WASI_EAFNOSUPPORT = 5, exports.WASI_EAGAIN = 6, exports.WASI_EALREADY = 7, exports.WASI_EBADF = 8, exports.WASI_EBADMSG = 9, exports.WASI_EBUSY = 10, exports.WASI_ECANCELED = 11, exports.WASI_ECHILD = 12, exports.WASI_ECONNABORTED = 13, exports.WASI_ECONNREFUSED = 14, exports.WASI_ECONNRESET = 15, exports.WASI_EDEADLK = 16, exports.WASI_EDESTADDRREQ = 17, exports.WASI_EDOM = 18, exports.WASI_EDQUOT = 19, exports.WASI_EEXIST = 20, exports.WASI_EFAULT = 21, exports.WASI_EFBIG = 22, exports.WASI_EHOSTUNREACH = 23, exports.WASI_EIDRM = 24, exports.WASI_EILSEQ = 25, exports.WASI_EINPROGRESS = 26, exports.WASI_EINTR = 27, exports.WASI_EINVAL = 28, exports.WASI_EIO = 29, exports.WASI_EISCONN = 30, exports.WASI_EISDIR = 31, exports.WASI_ELOOP = 32, exports.WASI_EMFILE = 33, exports.WASI_EMLINK = 34, exports.WASI_EMSGSIZE = 35, exports.WASI_EMULTIHOP = 36, exports.WASI_ENAMETOOLONG = 37, exports.WASI_ENETDOWN = 38, exports.WASI_ENETRESET = 39, exports.WASI_ENETUNREACH = 40, exports.WASI_ENFILE = 41, exports.WASI_ENOBUFS = 42, exports.WASI_ENODEV = 43, exports.WASI_ENOENT = 44, exports.WASI_ENOEXEC = 45, exports.WASI_ENOLCK = 46, exports.WASI_ENOLINK = 47, exports.WASI_ENOMEM = 48, exports.WASI_ENOMSG = 49, exports.WASI_ENOPROTOOPT = 50, exports.WASI_ENOSPC = 51, exports.WASI_ENOSYS = 52, exports.WASI_ENOTCONN = 53, exports.WASI_ENOTDIR = 54, exports.WASI_ENOTEMPTY = 55, exports.WASI_ENOTRECOVERABLE = 56, exports.WASI_ENOTSOCK = 57, exports.WASI_ENOTSUP = 58, exports.WASI_ENOTTY = 59, exports.WASI_ENXIO = 60, exports.WASI_EOVERFLOW = 61, exports.WASI_EOWNERDEAD = 62, exports.WASI_EPERM = 63, exports.WASI_EPIPE = 64, exports.WASI_EPROTO = 65, exports.WASI_EPROTONOSUPPORT = 66, exports.WASI_EPROTOTYPE = 67, exports.WASI_ERANGE = 68, exports.WASI_EROFS = 69, exports.WASI_ESPIPE = 70, exports.WASI_ESRCH = 71, exports.WASI_ESTALE = 72, exports.WASI_ETIMEDOUT = 73, exports.WASI_ETXTBSY = 74, exports.WASI_EXDEV = 75, exports.WASI_ENOTCAPABLE = 76, exports.WASI_SIGABRT = 0, exports.WASI_SIGALRM = 1, exports.WASI_SIGBUS = 2, exports.WASI_SIGCHLD = 3, exports.WASI_SIGCONT = 4, exports.WASI_SIGFPE = 5, exports.WASI_SIGHUP = 6, exports.WASI_SIGILL = 7, exports.WASI_SIGINT = 8, exports.WASI_SIGKILL = 9, exports.WASI_SIGPIPE = 10, exports.WASI_SIGQUIT = 11, exports.WASI_SIGSEGV = 12, exports.WASI_SIGSTOP = 13, exports.WASI_SIGTERM = 14, exports.WASI_SIGTRAP = 15, exports.WASI_SIGTSTP = 16, exports.WASI_SIGTTIN = 17, exports.WASI_SIGTTOU = 18, exports.WASI_SIGURG = 19, exports.WASI_SIGUSR1 = 20, exports.WASI_SIGUSR2 = 21, exports.WASI_SIGVTALRM = 22, exports.WASI_SIGXCPU = 23, exports.WASI_SIGXFSZ = 24, exports.WASI_FILETYPE_UNKNOWN = 0, exports.WASI_FILETYPE_BLOCK_DEVICE = 1, exports.WASI_FILETYPE_CHARACTER_DEVICE = 2, exports.WASI_FILETYPE_DIRECTORY = 3, exports.WASI_FILETYPE_REGULAR_FILE = 4, exports.WASI_FILETYPE_SOCKET_DGRAM = 5, exports.WASI_FILETYPE_SOCKET_STREAM = 6, exports.WASI_FILETYPE_SYMBOLIC_LINK = 7, exports.WASI_FDFLAG_APPEND = 1, exports.WASI_FDFLAG_DSYNC = 2, exports.WASI_FDFLAG_NONBLOCK = 4, exports.WASI_FDFLAG_RSYNC = 8, exports.WASI_FDFLAG_SYNC = 16, exports.WASI_RIGHT_FD_DATASYNC = BigInt(1), exports.WASI_RIGHT_FD_READ = BigInt(2), exports.WASI_RIGHT_FD_SEEK = BigInt(4), exports.WASI_RIGHT_FD_FDSTAT_SET_FLAGS = BigInt(8), exports.WASI_RIGHT_FD_SYNC = BigInt(16), exports.WASI_RIGHT_FD_TELL = BigInt(32), exports.WASI_RIGHT_FD_WRITE = BigInt(64), exports.WASI_RIGHT_FD_ADVISE = BigInt(128), exports.WASI_RIGHT_FD_ALLOCATE = BigInt(256), exports.WASI_RIGHT_PATH_CREATE_DIRECTORY = BigInt(512), exports.WASI_RIGHT_PATH_CREATE_FILE = BigInt(1024), exports.WASI_RIGHT_PATH_LINK_SOURCE = BigInt(2048), exports.WASI_RIGHT_PATH_LINK_TARGET = BigInt(4096), exports.WASI_RIGHT_PATH_OPEN = BigInt(8192), exports.WASI_RIGHT_FD_READDIR = BigInt(16384), exports.WASI_RIGHT_PATH_READLINK = BigInt(32768), exports.WASI_RIGHT_PATH_RENAME_SOURCE = BigInt(65536), exports.WASI_RIGHT_PATH_RENAME_TARGET = BigInt(131072), exports.WASI_RIGHT_PATH_FILESTAT_GET = BigInt(262144), exports.WASI_RIGHT_PATH_FILESTAT_SET_SIZE = BigInt(524288), exports.WASI_RIGHT_PATH_FILESTAT_SET_TIMES = BigInt(1048576), exports.WASI_RIGHT_FD_FILESTAT_GET = BigInt(2097152), exports.WASI_RIGHT_FD_FILESTAT_SET_SIZE = BigInt(4194304), exports.WASI_RIGHT_FD_FILESTAT_SET_TIMES = BigInt(8388608), exports.WASI_RIGHT_PATH_SYMLINK = BigInt(16777216), exports.WASI_RIGHT_PATH_REMOVE_DIRECTORY = BigInt(33554432), exports.WASI_RIGHT_PATH_UNLINK_FILE = BigInt(67108864), exports.WASI_RIGHT_POLL_FD_READWRITE = BigInt(134217728), exports.WASI_RIGHT_SOCK_SHUTDOWN = BigInt(268435456), exports.RIGHTS_ALL = exports.WASI_RIGHT_FD_DATASYNC | exports.WASI_RIGHT_FD_READ | exports.WASI_RIGHT_FD_SEEK | exports.WASI_RIGHT_FD_FDSTAT_SET_FLAGS | exports.WASI_RIGHT_FD_SYNC | exports.WASI_RIGHT_FD_TELL | exports.WASI_RIGHT_FD_WRITE | exports.WASI_RIGHT_FD_ADVISE | exports.WASI_RIGHT_FD_ALLOCATE | exports.WASI_RIGHT_PATH_CREATE_DIRECTORY | exports.WASI_RIGHT_PATH_CREATE_FILE | exports.WASI_RIGHT_PATH_LINK_SOURCE | exports.WASI_RIGHT_PATH_LINK_TARGET | exports.WASI_RIGHT_PATH_OPEN | exports.WASI_RIGHT_FD_READDIR | exports.WASI_RIGHT_PATH_READLINK | exports.WASI_RIGHT_PATH_RENAME_SOURCE | exports.WASI_RIGHT_PATH_RENAME_TARGET | exports.WASI_RIGHT_PATH_FILESTAT_GET | exports.WASI_RIGHT_PATH_FILESTAT_SET_SIZE | exports.WASI_RIGHT_PATH_FILESTAT_SET_TIMES | exports.WASI_RIGHT_FD_FILESTAT_GET | exports.WASI_RIGHT_FD_FILESTAT_SET_TIMES | exports.WASI_RIGHT_FD_FILESTAT_SET_SIZE | exports.WASI_RIGHT_PATH_SYMLINK | exports.WASI_RIGHT_PATH_UNLINK_FILE | exports.WASI_RIGHT_PATH_REMOVE_DIRECTORY | exports.WASI_RIGHT_POLL_FD_READWRITE | exports.WASI_RIGHT_SOCK_SHUTDOWN, exports.RIGHTS_BLOCK_DEVICE_BASE = exports.RIGHTS_ALL, exports.RIGHTS_BLOCK_DEVICE_INHERITING = exports.RIGHTS_ALL, exports.RIGHTS_CHARACTER_DEVICE_BASE = exports.RIGHTS_ALL, exports.RIGHTS_CHARACTER_DEVICE_INHERITING = exports.RIGHTS_ALL, exports.RIGHTS_REGULAR_FILE_BASE = exports.WASI_RIGHT_FD_DATASYNC | exports.WASI_RIGHT_FD_READ | exports.WASI_RIGHT_FD_SEEK | exports.WASI_RIGHT_FD_FDSTAT_SET_FLAGS | exports.WASI_RIGHT_FD_SYNC | exports.WASI_RIGHT_FD_TELL | exports.WASI_RIGHT_FD_WRITE | exports.WASI_RIGHT_FD_ADVISE | exports.WASI_RIGHT_FD_ALLOCATE | exports.WASI_RIGHT_FD_FILESTAT_GET | exports.WASI_RIGHT_FD_FILESTAT_SET_SIZE | exports.WASI_RIGHT_FD_FILESTAT_SET_TIMES | exports.WASI_RIGHT_POLL_FD_READWRITE, exports.RIGHTS_REGULAR_FILE_INHERITING = BigInt(0), exports.RIGHTS_DIRECTORY_BASE = exports.WASI_RIGHT_FD_FDSTAT_SET_FLAGS | exports.WASI_RIGHT_FD_SYNC | exports.WASI_RIGHT_FD_ADVISE | exports.WASI_RIGHT_PATH_CREATE_DIRECTORY | exports.WASI_RIGHT_PATH_CREATE_FILE | exports.WASI_RIGHT_PATH_LINK_SOURCE | exports.WASI_RIGHT_PATH_LINK_TARGET | exports.WASI_RIGHT_PATH_OPEN | exports.WASI_RIGHT_FD_READDIR | exports.WASI_RIGHT_PATH_READLINK | exports.WASI_RIGHT_PATH_RENAME_SOURCE | exports.WASI_RIGHT_PATH_RENAME_TARGET | exports.WASI_RIGHT_PATH_FILESTAT_GET | exports.WASI_RIGHT_PATH_FILESTAT_SET_SIZE | exports.WASI_RIGHT_PATH_FILESTAT_SET_TIMES | exports.WASI_RIGHT_FD_FILESTAT_GET | exports.WASI_RIGHT_FD_FILESTAT_SET_TIMES | exports.WASI_RIGHT_PATH_SYMLINK | exports.WASI_RIGHT_PATH_UNLINK_FILE | exports.WASI_RIGHT_PATH_REMOVE_DIRECTORY | exports.WASI_RIGHT_POLL_FD_READWRITE, exports.RIGHTS_DIRECTORY_INHERITING = exports.RIGHTS_DIRECTORY_BASE | exports.RIGHTS_REGULAR_FILE_BASE, exports.RIGHTS_SOCKET_BASE = exports.WASI_RIGHT_FD_READ | exports.WASI_RIGHT_FD_FDSTAT_SET_FLAGS | exports.WASI_RIGHT_FD_WRITE | exports.WASI_RIGHT_FD_FILESTAT_GET | exports.WASI_RIGHT_POLL_FD_READWRITE | exports.WASI_RIGHT_SOCK_SHUTDOWN, exports.RIGHTS_SOCKET_INHERITING = exports.RIGHTS_ALL, exports.RIGHTS_TTY_BASE = exports.WASI_RIGHT_FD_READ | exports.WASI_RIGHT_FD_FDSTAT_SET_FLAGS | exports.WASI_RIGHT_FD_WRITE | exports.WASI_RIGHT_FD_FILESTAT_GET | exports.WASI_RIGHT_POLL_FD_READWRITE, exports.RIGHTS_TTY_INHERITING = BigInt(0), exports.WASI_CLOCK_REALTIME = 0, exports.WASI_CLOCK_MONOTONIC = 1, exports.WASI_CLOCK_PROCESS_CPUTIME_ID = 2, exports.WASI_CLOCK_THREAD_CPUTIME_ID = 3, exports.WASI_EVENTTYPE_CLOCK = 0, exports.WASI_EVENTTYPE_FD_READ = 1, exports.WASI_EVENTTYPE_FD_WRITE = 2, exports.WASI_FILESTAT_SET_ATIM = 1 << 0, exports.WASI_FILESTAT_SET_ATIM_NOW = 1 << 1, exports.WASI_FILESTAT_SET_MTIM = 1 << 2, exports.WASI_FILESTAT_SET_MTIM_NOW = 1 << 3, exports.WASI_O_CREAT = 1 << 0, exports.WASI_O_DIRECTORY = 1 << 1, exports.WASI_O_EXCL = 1 << 2, exports.WASI_O_TRUNC = 1 << 3, exports.WASI_PREOPENTYPE_DIR = 0, exports.WASI_DIRCOOKIE_START = 0, exports.WASI_STDIN_FILENO = 0, exports.WASI_STDOUT_FILENO = 1, exports.WASI_STDERR_FILENO = 2, exports.WASI_WHENCE_SET = 0, exports.WASI_WHENCE_CUR = 1, exports.WASI_WHENCE_END = 2, exports.ERROR_MAP = {\n      E2BIG: exports.WASI_E2BIG,\n      EACCES: exports.WASI_EACCES,\n      EADDRINUSE: exports.WASI_EADDRINUSE,\n      EADDRNOTAVAIL: exports.WASI_EADDRNOTAVAIL,\n      EAFNOSUPPORT: exports.WASI_EAFNOSUPPORT,\n      EALREADY: exports.WASI_EALREADY,\n      EAGAIN: exports.WASI_EAGAIN,\n      EBADF: exports.WASI_EBADF,\n      EBADMSG: exports.WASI_EBADMSG,\n      EBUSY: exports.WASI_EBUSY,\n      ECANCELED: exports.WASI_ECANCELED,\n      ECHILD: exports.WASI_ECHILD,\n      ECONNABORTED: exports.WASI_ECONNABORTED,\n      ECONNREFUSED: exports.WASI_ECONNREFUSED,\n      ECONNRESET: exports.WASI_ECONNRESET,\n      EDEADLOCK: exports.WASI_EDEADLK,\n      EDESTADDRREQ: exports.WASI_EDESTADDRREQ,\n      EDOM: exports.WASI_EDOM,\n      EDQUOT: exports.WASI_EDQUOT,\n      EEXIST: exports.WASI_EEXIST,\n      EFAULT: exports.WASI_EFAULT,\n      EFBIG: exports.WASI_EFBIG,\n      EHOSTDOWN: exports.WASI_EHOSTUNREACH,\n      EHOSTUNREACH: exports.WASI_EHOSTUNREACH,\n      EIDRM: exports.WASI_EIDRM,\n      EILSEQ: exports.WASI_EILSEQ,\n      EINPROGRESS: exports.WASI_EINPROGRESS,\n      EINTR: exports.WASI_EINTR,\n      EINVAL: exports.WASI_EINVAL,\n      EIO: exports.WASI_EIO,\n      EISCONN: exports.WASI_EISCONN,\n      EISDIR: exports.WASI_EISDIR,\n      ELOOP: exports.WASI_ELOOP,\n      EMFILE: exports.WASI_EMFILE,\n      EMLINK: exports.WASI_EMLINK,\n      EMSGSIZE: exports.WASI_EMSGSIZE,\n      EMULTIHOP: exports.WASI_EMULTIHOP,\n      ENAMETOOLONG: exports.WASI_ENAMETOOLONG,\n      ENETDOWN: exports.WASI_ENETDOWN,\n      ENETRESET: exports.WASI_ENETRESET,\n      ENETUNREACH: exports.WASI_ENETUNREACH,\n      ENFILE: exports.WASI_ENFILE,\n      ENOBUFS: exports.WASI_ENOBUFS,\n      ENODEV: exports.WASI_ENODEV,\n      ENOENT: exports.WASI_ENOENT,\n      ENOEXEC: exports.WASI_ENOEXEC,\n      ENOLCK: exports.WASI_ENOLCK,\n      ENOLINK: exports.WASI_ENOLINK,\n      ENOMEM: exports.WASI_ENOMEM,\n      ENOMSG: exports.WASI_ENOMSG,\n      ENOPROTOOPT: exports.WASI_ENOPROTOOPT,\n      ENOSPC: exports.WASI_ENOSPC,\n      ENOSYS: exports.WASI_ENOSYS,\n      ENOTCONN: exports.WASI_ENOTCONN,\n      ENOTDIR: exports.WASI_ENOTDIR,\n      ENOTEMPTY: exports.WASI_ENOTEMPTY,\n      ENOTRECOVERABLE: exports.WASI_ENOTRECOVERABLE,\n      ENOTSOCK: exports.WASI_ENOTSOCK,\n      ENOTTY: exports.WASI_ENOTTY,\n      ENXIO: exports.WASI_ENXIO,\n      EOVERFLOW: exports.WASI_EOVERFLOW,\n      EOWNERDEAD: exports.WASI_EOWNERDEAD,\n      EPERM: exports.WASI_EPERM,\n      EPIPE: exports.WASI_EPIPE,\n      EPROTO: exports.WASI_EPROTO,\n      EPROTONOSUPPORT: exports.WASI_EPROTONOSUPPORT,\n      EPROTOTYPE: exports.WASI_EPROTOTYPE,\n      ERANGE: exports.WASI_ERANGE,\n      EROFS: exports.WASI_EROFS,\n      ESPIPE: exports.WASI_ESPIPE,\n      ESRCH: exports.WASI_ESRCH,\n      ESTALE: exports.WASI_ESTALE,\n      ETIMEDOUT: exports.WASI_ETIMEDOUT,\n      ETXTBSY: exports.WASI_ETXTBSY,\n      EXDEV: exports.WASI_EXDEV\n    }, exports.SIGNAL_MAP = {\n      [exports.WASI_SIGHUP]: \"SIGHUP\",\n      [exports.WASI_SIGINT]: \"SIGINT\",\n      [exports.WASI_SIGQUIT]: \"SIGQUIT\",\n      [exports.WASI_SIGILL]: \"SIGILL\",\n      [exports.WASI_SIGTRAP]: \"SIGTRAP\",\n      [exports.WASI_SIGABRT]: \"SIGABRT\",\n      [exports.WASI_SIGBUS]: \"SIGBUS\",\n      [exports.WASI_SIGFPE]: \"SIGFPE\",\n      [exports.WASI_SIGKILL]: \"SIGKILL\",\n      [exports.WASI_SIGUSR1]: \"SIGUSR1\",\n      [exports.WASI_SIGSEGV]: \"SIGSEGV\",\n      [exports.WASI_SIGUSR2]: \"SIGUSR2\",\n      [exports.WASI_SIGPIPE]: \"SIGPIPE\",\n      [exports.WASI_SIGALRM]: \"SIGALRM\",\n      [exports.WASI_SIGTERM]: \"SIGTERM\",\n      [exports.WASI_SIGCHLD]: \"SIGCHLD\",\n      [exports.WASI_SIGCONT]: \"SIGCONT\",\n      [exports.WASI_SIGSTOP]: \"SIGSTOP\",\n      [exports.WASI_SIGTSTP]: \"SIGTSTP\",\n      [exports.WASI_SIGTTIN]: \"SIGTTIN\",\n      [exports.WASI_SIGTTOU]: \"SIGTTOU\",\n      [exports.WASI_SIGURG]: \"SIGURG\",\n      [exports.WASI_SIGXCPU]: \"SIGXCPU\",\n      [exports.WASI_SIGXFSZ]: \"SIGXFSZ\",\n      [exports.WASI_SIGVTALRM]: \"SIGVTALRM\"\n    };\n  }\n}), require_wasi = __commonJS({\n  \"node_modules/wasi-js/dist/wasi.js\"(exports) {\n    var __importDefault = exports && exports.__importDefault || function(mod) {\n      return mod && mod.__esModule \? mod : { default: mod };\n    };\n    let fs;\n    Object.defineProperty(exports, \"__esModule\", { value: !0 }), exports.SOCKET_DEFAULT_RIGHTS = void 0;\n    var log = () => {\n    }, logOpen = () => {\n    }, SC_OPEN_MAX = 32768, types_1 = require_types(), constants_1 = require_constants(), STDIN_DEFAULT_RIGHTS = constants_1.WASI_RIGHT_FD_DATASYNC | constants_1.WASI_RIGHT_FD_READ | constants_1.WASI_RIGHT_FD_SYNC | constants_1.WASI_RIGHT_FD_ADVISE | constants_1.WASI_RIGHT_FD_FILESTAT_GET | constants_1.WASI_RIGHT_POLL_FD_READWRITE, STDOUT_DEFAULT_RIGHTS = constants_1.WASI_RIGHT_FD_DATASYNC | constants_1.WASI_RIGHT_FD_WRITE | constants_1.WASI_RIGHT_FD_SYNC | constants_1.WASI_RIGHT_FD_ADVISE | constants_1.WASI_RIGHT_FD_FILESTAT_GET | constants_1.WASI_RIGHT_POLL_FD_READWRITE, STDERR_DEFAULT_RIGHTS = STDOUT_DEFAULT_RIGHTS;\n    exports.SOCKET_DEFAULT_RIGHTS = constants_1.WASI_RIGHT_FD_DATASYNC | constants_1.WASI_RIGHT_FD_READ | constants_1.WASI_RIGHT_FD_WRITE | constants_1.WASI_RIGHT_FD_ADVISE | constants_1.WASI_RIGHT_FD_FILESTAT_GET | constants_1.WASI_RIGHT_POLL_FD_READWRITE | constants_1.WASI_RIGHT_FD_FDSTAT_SET_FLAGS;\n    var msToNs = (ms) => {\n      const msInt = Math.trunc(ms), decimal = BigInt(Math.round((ms - msInt) * 1e6));\n      return BigInt(msInt) * BigInt(1e6) + decimal;\n    }, nsToMs = (ns) => {\n      if (typeof ns === \"number\")\n        ns = Math.trunc(ns);\n      const nsInt = BigInt(ns);\n      return Number(nsInt / BigInt(1e6));\n    }, wrap = (f) => (...args) => {\n      try {\n        return f(...args);\n      } catch (err) {\n        let e = err;\n        while (e.prev != null)\n          e = e.prev;\n        if (e\?.code && typeof e\?.code === \"string\")\n          return constants_1.ERROR_MAP[e.code] || constants_1.WASI_EINVAL;\n        if (e instanceof types_1.WASIError)\n          return e.errno;\n        throw e;\n      }\n    }, stat = (wasi, fd) => {\n      const entry = wasi.FD_MAP.get(fd);\n      if (!entry)\n        throw new types_1.WASIError(constants_1.WASI_EBADF);\n      if (entry.filetype === void 0) {\n        const stats = wasi.fstatSync(entry.real), { filetype, rightsBase, rightsInheriting } = translateFileAttributes(wasi, fd, stats);\n        if (entry.filetype = filetype, !entry.rights)\n          entry.rights = {\n            base: rightsBase,\n            inheriting: rightsInheriting\n          };\n      }\n      return entry;\n    }, translateFileAttributes = (wasi, fd, stats) => {\n      switch (!0) {\n        case stats.isBlockDevice():\n          return {\n            filetype: constants_1.WASI_FILETYPE_BLOCK_DEVICE,\n            rightsBase: constants_1.RIGHTS_BLOCK_DEVICE_BASE,\n            rightsInheriting: constants_1.RIGHTS_BLOCK_DEVICE_INHERITING\n          };\n        case stats.isCharacterDevice(): {\n          const filetype = constants_1.WASI_FILETYPE_CHARACTER_DEVICE;\n          if (fd !== void 0 && wasi.bindings.isTTY(fd))\n            return {\n              filetype,\n              rightsBase: constants_1.RIGHTS_TTY_BASE,\n              rightsInheriting: constants_1.RIGHTS_TTY_INHERITING\n            };\n          return {\n            filetype,\n            rightsBase: constants_1.RIGHTS_CHARACTER_DEVICE_BASE,\n            rightsInheriting: constants_1.RIGHTS_CHARACTER_DEVICE_INHERITING\n          };\n        }\n        case stats.isDirectory():\n          return {\n            filetype: constants_1.WASI_FILETYPE_DIRECTORY,\n            rightsBase: constants_1.RIGHTS_DIRECTORY_BASE,\n            rightsInheriting: constants_1.RIGHTS_DIRECTORY_INHERITING\n          };\n        case stats.isFIFO():\n          return {\n            filetype: constants_1.WASI_FILETYPE_SOCKET_STREAM,\n            rightsBase: constants_1.RIGHTS_SOCKET_BASE,\n            rightsInheriting: constants_1.RIGHTS_SOCKET_INHERITING\n          };\n        case stats.isFile():\n          return {\n            filetype: constants_1.WASI_FILETYPE_REGULAR_FILE,\n            rightsBase: constants_1.RIGHTS_REGULAR_FILE_BASE,\n            rightsInheriting: constants_1.RIGHTS_REGULAR_FILE_INHERITING\n          };\n        case stats.isSocket():\n          return {\n            filetype: constants_1.WASI_FILETYPE_SOCKET_STREAM,\n            rightsBase: constants_1.RIGHTS_SOCKET_BASE,\n            rightsInheriting: constants_1.RIGHTS_SOCKET_INHERITING\n          };\n        case stats.isSymbolicLink():\n          return {\n            filetype: constants_1.WASI_FILETYPE_SYMBOLIC_LINK,\n            rightsBase: BigInt(0),\n            rightsInheriting: BigInt(0)\n          };\n        default:\n          return {\n            filetype: constants_1.WASI_FILETYPE_UNKNOWN,\n            rightsBase: BigInt(0),\n            rightsInheriting: BigInt(0)\n          };\n      }\n    }, warnedAboutSleep = !1, defaultConfig;\n    function getDefaults() {\n      if (defaultConfig)\n        return defaultConfig;\n      const defaultBindings = {\n        hrtime: () => process.hrtime.bigint(),\n        exit: (code) => {\n          process.exit(code);\n        },\n        kill: (signal) => {\n          process.kill(process.pid, signal);\n        },\n        randomFillSync: (array) => crypto.getRandomValues(array),\n        isTTY: (fd) => @requireNativeModule(\"node:tty\").isatty(fd),\n        fs: Bun.fs(),\n        path: @getInternalField(@internalModuleRegistry, 26) || @createInternalModuleById(26)\n      };\n      return defaultConfig = {\n        args: [],\n        env: {},\n        preopens: {},\n        bindings: defaultBindings,\n        sleep: (ms) => {\n          Bun.sleepSync(ms);\n        }\n      };\n    }\n    var WASI = class WASI2 {\n      constructor(wasiConfig = {}) {\n        const defaultConfig2 = getDefaults();\n        this.lastStdin = 0, this.sleep = wasiConfig.sleep || defaultConfig2.sleep, this.getStdin = wasiConfig.getStdin, this.sendStdout = wasiConfig.sendStdout, this.sendStderr = wasiConfig.sendStderr;\n        let preopens = wasiConfig.preopens \?\? defaultConfig2.preopens;\n        this.env = wasiConfig.env \?\? defaultConfig2.env;\n        const args = wasiConfig.args \?\? defaultConfig2.args;\n        this.memory = void 0, this.view = void 0, this.bindings = wasiConfig.bindings || defaultConfig2.bindings;\n        const bindings2 = this.bindings;\n        fs = bindings2.fs, this.FD_MAP = new Map([\n          [\n            constants_1.WASI_STDIN_FILENO,\n            {\n              real: 0,\n              filetype: constants_1.WASI_FILETYPE_CHARACTER_DEVICE,\n              rights: {\n                base: STDIN_DEFAULT_RIGHTS,\n                inheriting: BigInt(0)\n              },\n              path: \"/dev/stdin\"\n            }\n          ],\n          [\n            constants_1.WASI_STDOUT_FILENO,\n            {\n              real: 1,\n              filetype: constants_1.WASI_FILETYPE_CHARACTER_DEVICE,\n              rights: {\n                base: STDOUT_DEFAULT_RIGHTS,\n                inheriting: BigInt(0)\n              },\n              path: \"/dev/stdout\"\n            }\n          ],\n          [\n            constants_1.WASI_STDERR_FILENO,\n            {\n              real: 2,\n              filetype: constants_1.WASI_FILETYPE_CHARACTER_DEVICE,\n              rights: {\n                base: STDERR_DEFAULT_RIGHTS,\n                inheriting: BigInt(0)\n              },\n              path: \"/dev/stderr\"\n            }\n          ]\n        ]);\n        const path = bindings2.path;\n        for (let [k, v] of Object.entries(preopens)) {\n          const real = fs.openSync(v, nodeFsConstants.O_RDONLY), newfd = this.getUnusedFileDescriptor();\n          this.FD_MAP.set(newfd, {\n            real,\n            filetype: constants_1.WASI_FILETYPE_DIRECTORY,\n            rights: {\n              base: constants_1.RIGHTS_DIRECTORY_BASE,\n              inheriting: constants_1.RIGHTS_DIRECTORY_INHERITING\n            },\n            fakePath: k,\n            path: v\n          });\n        }\n        const getiovs = (iovs, iovsLen) => {\n          this.refreshMemory();\n          const { view, memory } = this, { buffer } = memory, { byteLength } = buffer;\n          if (iovsLen === 1) {\n            const ptr = iovs, buf = view.getUint32(ptr, !0);\n            let bufLen = view.getUint32(ptr + 4, !0);\n            if (bufLen > byteLength - buf)\n              console.log({\n                buf,\n                bufLen,\n                total_memory: byteLength\n              }), log(\"getiovs: warning -- truncating buffer to fit in memory\"), bufLen = Math.min(bufLen, Math.max(0, byteLength - buf));\n            try {\n              return [new Uint8Array(buffer, buf, bufLen)];\n            } catch (err) {\n              throw console.warn(\"WASI.getiovs -- invalid buffer\", err), new types_1.WASIError(constants_1.WASI_EINVAL);\n            }\n          }\n          const buffers = [];\n          buffers.length = iovsLen;\n          for (let i = 0, ptr = iovs;i < iovsLen; i++, ptr += 8) {\n            const buf = view.getUint32(ptr, !0);\n            let bufLen = view.getUint32(ptr + 4, !0);\n            if (bufLen > byteLength - buf)\n              console.log({\n                buf,\n                bufLen,\n                total_memory: byteLength\n              }), log(\"getiovs: warning -- truncating buffer to fit in memory\"), bufLen = Math.min(bufLen, Math.max(0, byteLength - buf));\n            try {\n              buffers[i] = new Uint8Array(buffer, buf, bufLen);\n            } catch (err) {\n              throw console.warn(\"WASI.getiovs -- invalid buffer\", err), new types_1.WASIError(constants_1.WASI_EINVAL);\n            }\n          }\n          return buffers;\n        }, CHECK_FD = (fd, rights) => {\n          const stats = stat(this, fd);\n          if (rights !== BigInt(0) && (stats.rights.base & rights) === BigInt(0))\n            throw new types_1.WASIError(constants_1.WASI_EPERM);\n          return stats;\n        }, CPUTIME_START = Bun.nanoseconds(), timeOrigin = Math.trunc(performance.timeOrigin * 1e6), now = (clockId) => {\n          switch (clockId) {\n            case constants_1.WASI_CLOCK_MONOTONIC:\n              return Bun.nanoseconds();\n            case constants_1.WASI_CLOCK_REALTIME:\n              return Bun.nanoseconds() + timeOrigin;\n            case constants_1.WASI_CLOCK_PROCESS_CPUTIME_ID:\n            case constants_1.WASI_CLOCK_THREAD_CPUTIME_ID:\n              return Bun.nanoseconds() - CPUTIME_START;\n            default:\n              return null;\n          }\n        };\n        if (this.wasiImport = {\n          args_get: (argv, argvBuf) => {\n            this.refreshMemory();\n            let coffset = argv, offset = argvBuf;\n            return args.forEach((a) => {\n              this.view.setUint32(coffset, offset, !0), coffset += 4, offset += Buffer.from(this.memory.buffer).write(`${a}\\0`, offset);\n            }), constants_1.WASI_ESUCCESS;\n          },\n          args_sizes_get: (argc, argvBufSize) => {\n            this.refreshMemory(), this.view.setUint32(argc, args.length, !0);\n            const size = args.reduce((acc, a) => acc + Buffer.byteLength(a) + 1, 0);\n            return this.view.setUint32(argvBufSize, size, !0), constants_1.WASI_ESUCCESS;\n          },\n          environ_get: (environ, environBuf) => {\n            this.refreshMemory();\n            let coffset = environ, offset = environBuf;\n            return Object.entries(this.env).forEach(([key, value]) => {\n              this.view.setUint32(coffset, offset, !0), coffset += 4, offset += Buffer.from(this.memory.buffer).write(`${key}=${value}\\0`, offset);\n            }), constants_1.WASI_ESUCCESS;\n          },\n          environ_sizes_get: (environCount, environBufSize) => {\n            this.refreshMemory();\n            const envProcessed = Object.entries(this.env).map(([key, value]) => `${key}=${value}\\0`), size = envProcessed.reduce((acc, e) => acc + Buffer.byteLength(e), 0);\n            return this.view.setUint32(environCount, envProcessed.length, !0), this.view.setUint32(environBufSize, size, !0), constants_1.WASI_ESUCCESS;\n          },\n          clock_res_get: (clockId, resolution) => {\n            let res;\n            switch (clockId) {\n              case constants_1.WASI_CLOCK_MONOTONIC:\n              case constants_1.WASI_CLOCK_PROCESS_CPUTIME_ID:\n              case constants_1.WASI_CLOCK_THREAD_CPUTIME_ID: {\n                res = BigInt(1);\n                break;\n              }\n              case constants_1.WASI_CLOCK_REALTIME: {\n                res = BigInt(1000);\n                break;\n              }\n            }\n            if (!res)\n              throw Error(\"invalid clockId\");\n            return this.view.setBigUint64(resolution, res), constants_1.WASI_ESUCCESS;\n          },\n          clock_time_get: (clockId, _precision, time) => {\n            this.refreshMemory();\n            const n = now(clockId);\n            if (n === null)\n              return constants_1.WASI_EINVAL;\n            return this.view.setBigUint64(time, BigInt(n), !0), constants_1.WASI_ESUCCESS;\n          },\n          fd_advise: wrap((fd, _offset, _len, _advice) => {\n            return CHECK_FD(fd, constants_1.WASI_RIGHT_FD_ADVISE), constants_1.WASI_ENOSYS;\n          }),\n          fd_allocate: wrap((fd, _offset, _len) => {\n            return CHECK_FD(fd, constants_1.WASI_RIGHT_FD_ALLOCATE), constants_1.WASI_ENOSYS;\n          }),\n          fd_close: wrap((fd) => {\n            const stats = CHECK_FD(fd, BigInt(0));\n            return fs.closeSync(stats.real), this.FD_MAP.delete(fd), constants_1.WASI_ESUCCESS;\n          }),\n          fd_datasync: wrap((fd) => {\n            const stats = CHECK_FD(fd, constants_1.WASI_RIGHT_FD_DATASYNC);\n            return fs.fdatasyncSync(stats.real), constants_1.WASI_ESUCCESS;\n          }),\n          fd_fdstat_get: wrap((fd, bufPtr) => {\n            const stats = CHECK_FD(fd, BigInt(0));\n            if (this.refreshMemory(), stats.filetype == null)\n              throw Error(\"stats.filetype must be set\");\n            return this.view.setUint8(bufPtr, stats.filetype), this.view.setUint16(bufPtr + 2, 0, !0), this.view.setUint16(bufPtr + 4, 0, !0), this.view.setBigUint64(bufPtr + 8, BigInt(stats.rights.base), !0), this.view.setBigUint64(bufPtr + 8 + 8, BigInt(stats.rights.inheriting), !0), constants_1.WASI_ESUCCESS;\n          }),\n          fd_fdstat_set_flags: wrap((fd, flags) => {\n            if (CHECK_FD(fd, constants_1.WASI_RIGHT_FD_FDSTAT_SET_FLAGS), this.wasiImport.sock_fcntlSetFlags(fd, flags) == 0)\n              return constants_1.WASI_ESUCCESS;\n            return constants_1.WASI_ENOSYS;\n          }),\n          fd_fdstat_set_rights: wrap((fd, fsRightsBase, fsRightsInheriting) => {\n            const stats = CHECK_FD(fd, BigInt(0));\n            if ((stats.rights.base | fsRightsBase) > stats.rights.base)\n              return constants_1.WASI_EPERM;\n            if ((stats.rights.inheriting | fsRightsInheriting) > stats.rights.inheriting)\n              return constants_1.WASI_EPERM;\n            return stats.rights.base = fsRightsBase, stats.rights.inheriting = fsRightsInheriting, constants_1.WASI_ESUCCESS;\n          }),\n          fd_filestat_get: wrap((fd, bufPtr) => {\n            const stats = CHECK_FD(fd, constants_1.WASI_RIGHT_FD_FILESTAT_GET), rstats = this.fstatSync(stats.real);\n            if (this.refreshMemory(), this.view.setBigUint64(bufPtr, BigInt(rstats.dev), !0), bufPtr += 8, this.view.setBigUint64(bufPtr, BigInt(rstats.ino), !0), bufPtr += 8, stats.filetype == null)\n              throw Error(\"stats.filetype must be set\");\n            return this.view.setUint8(bufPtr, stats.filetype), bufPtr += 8, this.view.setBigUint64(bufPtr, BigInt(rstats.nlink), !0), bufPtr += 8, this.view.setBigUint64(bufPtr, BigInt(rstats.size), !0), bufPtr += 8, this.view.setBigUint64(bufPtr, msToNs(rstats.atimeMs), !0), bufPtr += 8, this.view.setBigUint64(bufPtr, msToNs(rstats.mtimeMs), !0), bufPtr += 8, this.view.setBigUint64(bufPtr, msToNs(rstats.ctimeMs), !0), constants_1.WASI_ESUCCESS;\n          }),\n          fd_filestat_set_size: wrap((fd, stSize) => {\n            const stats = CHECK_FD(fd, constants_1.WASI_RIGHT_FD_FILESTAT_SET_SIZE);\n            return fs.ftruncateSync(stats.real, Number(stSize)), constants_1.WASI_ESUCCESS;\n          }),\n          fd_filestat_set_times: wrap((fd, stAtim, stMtim, fstflags) => {\n            const stats = CHECK_FD(fd, constants_1.WASI_RIGHT_FD_FILESTAT_SET_TIMES), rstats = this.fstatSync(stats.real);\n            let { atime: atim, mtime: mtim } = rstats;\n            const n = nsToMs(now(constants_1.WASI_CLOCK_REALTIME)), atimflags = constants_1.WASI_FILESTAT_SET_ATIM | constants_1.WASI_FILESTAT_SET_ATIM_NOW;\n            if ((fstflags & atimflags) === atimflags)\n              return constants_1.WASI_EINVAL;\n            const mtimflags = constants_1.WASI_FILESTAT_SET_MTIM | constants_1.WASI_FILESTAT_SET_MTIM_NOW;\n            if ((fstflags & mtimflags) === mtimflags)\n              return constants_1.WASI_EINVAL;\n            if ((fstflags & constants_1.WASI_FILESTAT_SET_ATIM) === constants_1.WASI_FILESTAT_SET_ATIM)\n              atim = nsToMs(stAtim);\n            else if ((fstflags & constants_1.WASI_FILESTAT_SET_ATIM_NOW) === constants_1.WASI_FILESTAT_SET_ATIM_NOW)\n              atim = n;\n            if ((fstflags & constants_1.WASI_FILESTAT_SET_MTIM) === constants_1.WASI_FILESTAT_SET_MTIM)\n              mtim = nsToMs(stMtim);\n            else if ((fstflags & constants_1.WASI_FILESTAT_SET_MTIM_NOW) === constants_1.WASI_FILESTAT_SET_MTIM_NOW)\n              mtim = n;\n            return fs.futimesSync(stats.real, new Date(atim), new Date(mtim)), constants_1.WASI_ESUCCESS;\n          }),\n          fd_prestat_get: wrap((fd, bufPtr) => {\n            const stats = CHECK_FD(fd, BigInt(0));\n            return this.refreshMemory(), this.view.setUint8(bufPtr, constants_1.WASI_PREOPENTYPE_DIR), this.view.setUint32(bufPtr + 4, Buffer.byteLength(stats.fakePath \?\? stats.path \?\? \"\"), !0), constants_1.WASI_ESUCCESS;\n          }),\n          fd_prestat_dir_name: wrap((fd, pathPtr, pathLen) => {\n            const stats = CHECK_FD(fd, BigInt(0));\n            return this.refreshMemory(), Buffer.from(this.memory.buffer).write(stats.fakePath \?\? stats.path \?\? \"\", pathPtr, pathLen, \"utf8\"), constants_1.WASI_ESUCCESS;\n          }),\n          fd_pwrite: wrap((fd, iovs, iovsLen, offset, nwritten) => {\n            const stats = CHECK_FD(fd, constants_1.WASI_RIGHT_FD_WRITE | constants_1.WASI_RIGHT_FD_SEEK);\n            let written = 0;\n            return getiovs(iovs, iovsLen).forEach((iov) => {\n              let w = 0;\n              while (w < iov.byteLength)\n                w += fs.writeSync(stats.real, iov, w, iov.byteLength - w, Number(offset) + written + w);\n              written += w;\n            }), this.view.setUint32(nwritten, written, !0), constants_1.WASI_ESUCCESS;\n          }),\n          fd_write: wrap((fd, iovs, iovsLen, nwritten) => {\n            const stats = CHECK_FD(fd, constants_1.WASI_RIGHT_FD_WRITE), IS_STDOUT = fd == constants_1.WASI_STDOUT_FILENO, IS_STDERR = fd == constants_1.WASI_STDERR_FILENO;\n            let written = 0;\n            return getiovs(iovs, iovsLen).forEach((iov) => {\n              if (iov.byteLength == 0)\n                return;\n              if (IS_STDOUT && this.sendStdout != null)\n                this.sendStdout(iov), written += iov.byteLength;\n              else if (IS_STDERR && this.sendStderr != null)\n                this.sendStderr(iov), written += iov.byteLength;\n              else {\n                let w = 0;\n                while (w < iov.byteLength) {\n                  const i = fs.writeSync(stats.real, iov, w, iov.byteLength - w, stats.offset \? Number(stats.offset) : null);\n                  if (stats.offset)\n                    stats.offset += BigInt(i);\n                  w += i;\n                }\n                written += w;\n              }\n            }), this.view.setUint32(nwritten, written, !0), constants_1.WASI_ESUCCESS;\n          }),\n          fd_pread: wrap((fd, iovs, iovsLen, offset, nread) => {\n            const stats = CHECK_FD(fd, constants_1.WASI_RIGHT_FD_READ | constants_1.WASI_RIGHT_FD_SEEK);\n            let read = 0;\n            outer:\n              for (let iov of getiovs(iovs, iovsLen)) {\n                let r = 0;\n                while (r < iov.byteLength) {\n                  const length = iov.byteLength - r, rr = fs.readSync(stats.real, iov, r, iov.byteLength - r, Number(offset) + read + r);\n                  if (r += rr, read += rr, rr === 0 || rr < length)\n                    break outer;\n                }\n                read += r;\n              }\n            return this.view.setUint32(nread, read, !0), constants_1.WASI_ESUCCESS;\n          }),\n          fd_read: wrap((fd, iovs, iovsLen, nread) => {\n            const stats = CHECK_FD(fd, constants_1.WASI_RIGHT_FD_READ), IS_STDIN = fd == constants_1.WASI_STDIN_FILENO;\n            let read = 0;\n            outer:\n              for (let iov of getiovs(iovs, iovsLen)) {\n                let r = 0;\n                while (r < iov.byteLength) {\n                  let length = iov.byteLength - r, position = IS_STDIN || stats.offset === void 0 \? null : Number(stats.offset), rr = 0;\n                  if (IS_STDIN)\n                    if (this.getStdin != null) {\n                      if (this.stdinBuffer == null)\n                        this.stdinBuffer = this.getStdin();\n                      if (this.stdinBuffer != null) {\n                        if (rr = this.stdinBuffer.copy(iov), rr == this.stdinBuffer.length)\n                          this.stdinBuffer = void 0;\n                        else\n                          this.stdinBuffer = this.stdinBuffer.slice(rr);\n                        if (rr > 0)\n                          this.lastStdin = (new Date()).valueOf();\n                      }\n                    } else {\n                      if (this.sleep == null && !warnedAboutSleep)\n                        warnedAboutSleep = !0, console.log(\"(cpu waiting for stdin: please define a way to sleep!) \");\n                      try {\n                        rr = fs.readSync(stats.real, iov, r, length, position);\n                      } catch (_err) {\n                      }\n                      if (rr == 0)\n                        this.shortPause();\n                      else\n                        this.lastStdin = (new Date()).valueOf();\n                    }\n                  else\n                    rr = fs.readSync(stats.real, iov, r, length, position);\n                  if (stats.filetype == constants_1.WASI_FILETYPE_REGULAR_FILE)\n                    stats.offset = (stats.offset \? stats.offset : BigInt(0)) + BigInt(rr);\n                  if (r += rr, read += rr, rr === 0 || rr < length)\n                    break outer;\n                }\n              }\n            return this.view.setUint32(nread, read, !0), constants_1.WASI_ESUCCESS;\n          }),\n          fd_readdir: wrap((fd, bufPtr, bufLen, cookie, bufusedPtr) => {\n            const stats = CHECK_FD(fd, constants_1.WASI_RIGHT_FD_READDIR);\n            this.refreshMemory();\n            const entries = fs.readdirSync(stats.path, { withFileTypes: !0 }), startPtr = bufPtr;\n            for (let i = Number(cookie);i < entries.length; i += 1) {\n              const entry = entries[i];\n              let nameLength = Buffer.byteLength(entry.name);\n              if (bufPtr - startPtr > bufLen)\n                break;\n              if (this.view.setBigUint64(bufPtr, BigInt(i + 1), !0), bufPtr += 8, bufPtr - startPtr > bufLen)\n                break;\n              const rstats = fs.lstatSync(path.resolve(stats.path, entry.name));\n              if (this.view.setBigUint64(bufPtr, BigInt(rstats.ino), !0), bufPtr += 8, bufPtr - startPtr > bufLen)\n                break;\n              if (this.view.setUint32(bufPtr, nameLength, !0), bufPtr += 4, bufPtr - startPtr > bufLen)\n                break;\n              let filetype;\n              switch (!0) {\n                case rstats.isBlockDevice():\n                  filetype = constants_1.WASI_FILETYPE_BLOCK_DEVICE;\n                  break;\n                case rstats.isCharacterDevice():\n                  filetype = constants_1.WASI_FILETYPE_CHARACTER_DEVICE;\n                  break;\n                case rstats.isDirectory():\n                  filetype = constants_1.WASI_FILETYPE_DIRECTORY;\n                  break;\n                case rstats.isFIFO():\n                  filetype = constants_1.WASI_FILETYPE_SOCKET_STREAM;\n                  break;\n                case rstats.isFile():\n                  filetype = constants_1.WASI_FILETYPE_REGULAR_FILE;\n                  break;\n                case rstats.isSocket():\n                  filetype = constants_1.WASI_FILETYPE_SOCKET_STREAM;\n                  break;\n                case rstats.isSymbolicLink():\n                  filetype = constants_1.WASI_FILETYPE_SYMBOLIC_LINK;\n                  break;\n                default:\n                  filetype = constants_1.WASI_FILETYPE_UNKNOWN;\n                  break;\n              }\n              if (this.view.setUint8(bufPtr, filetype), bufPtr += 1, bufPtr += 3, bufPtr + nameLength >= startPtr + bufLen)\n                break;\n              Buffer.from(this.memory.buffer).write(entry.name, bufPtr), bufPtr += nameLength;\n            }\n            const bufused = bufPtr - startPtr;\n            return this.view.setUint32(bufusedPtr, Math.min(bufused, bufLen), !0), constants_1.WASI_ESUCCESS;\n          }),\n          fd_renumber: wrap((from, to) => {\n            return CHECK_FD(from, BigInt(0)), CHECK_FD(to, BigInt(0)), fs.closeSync(this.FD_MAP.get(from).real), this.FD_MAP.set(from, this.FD_MAP.get(to)), this.FD_MAP.delete(to), constants_1.WASI_ESUCCESS;\n          }),\n          fd_seek: wrap((fd, offset, whence, newOffsetPtr) => {\n            const stats = CHECK_FD(fd, constants_1.WASI_RIGHT_FD_SEEK);\n            switch (this.refreshMemory(), whence) {\n              case constants_1.WASI_WHENCE_CUR:\n                stats.offset = (stats.offset \? stats.offset : BigInt(0)) + BigInt(offset);\n                break;\n              case constants_1.WASI_WHENCE_END:\n                const { size } = this.fstatSync(stats.real);\n                stats.offset = BigInt(size) + BigInt(offset);\n                break;\n              case constants_1.WASI_WHENCE_SET:\n                stats.offset = BigInt(offset);\n                break;\n            }\n            if (stats.offset == null)\n              throw Error(\"stats.offset must be defined\");\n            return this.view.setBigUint64(newOffsetPtr, stats.offset, !0), constants_1.WASI_ESUCCESS;\n          }),\n          fd_tell: wrap((fd, offsetPtr) => {\n            const stats = CHECK_FD(fd, constants_1.WASI_RIGHT_FD_TELL);\n            if (this.refreshMemory(), !stats.offset)\n              stats.offset = BigInt(0);\n            return this.view.setBigUint64(offsetPtr, stats.offset, !0), constants_1.WASI_ESUCCESS;\n          }),\n          fd_sync: wrap((fd) => {\n            const stats = CHECK_FD(fd, constants_1.WASI_RIGHT_FD_SYNC);\n            return fs.fsyncSync(stats.real), constants_1.WASI_ESUCCESS;\n          }),\n          path_create_directory: wrap((fd, pathPtr, pathLen) => {\n            const stats = CHECK_FD(fd, constants_1.WASI_RIGHT_PATH_CREATE_DIRECTORY);\n            if (!stats.path)\n              return constants_1.WASI_EINVAL;\n            this.refreshMemory();\n            const p = Buffer.from(this.memory.buffer, pathPtr, pathLen).toString();\n            return fs.mkdirSync(path.resolve(stats.path, p)), constants_1.WASI_ESUCCESS;\n          }),\n          path_filestat_get: wrap((fd, flags, pathPtr, pathLen, bufPtr) => {\n            const stats = CHECK_FD(fd, constants_1.WASI_RIGHT_PATH_FILESTAT_GET);\n            if (!stats.path)\n              return constants_1.WASI_EINVAL;\n            this.refreshMemory();\n            const p = Buffer.from(this.memory.buffer, pathPtr, pathLen).toString();\n            let rstats;\n            if (flags)\n              rstats = fs.statSync(path.resolve(stats.path, p));\n            else\n              rstats = fs.lstatSync(path.resolve(stats.path, p));\n            return this.view.setBigUint64(bufPtr, BigInt(rstats.dev), !0), bufPtr += 8, this.view.setBigUint64(bufPtr, BigInt(rstats.ino), !0), bufPtr += 8, this.view.setUint8(bufPtr, translateFileAttributes(this, void 0, rstats).filetype), bufPtr += 8, this.view.setBigUint64(bufPtr, BigInt(rstats.nlink), !0), bufPtr += 8, this.view.setBigUint64(bufPtr, BigInt(rstats.size), !0), bufPtr += 8, this.view.setBigUint64(bufPtr, BigInt(rstats.atime.getTime() * 1e6), !0), bufPtr += 8, this.view.setBigUint64(bufPtr, BigInt(rstats.mtime.getTime() * 1e6), !0), bufPtr += 8, this.view.setBigUint64(bufPtr, BigInt(rstats.ctime.getTime() * 1e6), !0), constants_1.WASI_ESUCCESS;\n          }),\n          path_filestat_set_times: wrap((fd, _dirflags, pathPtr, pathLen, stAtim, stMtim, fstflags) => {\n            const stats = CHECK_FD(fd, constants_1.WASI_RIGHT_PATH_FILESTAT_SET_TIMES);\n            if (!stats.path)\n              return constants_1.WASI_EINVAL;\n            this.refreshMemory();\n            const rstats = this.fstatSync(stats.real);\n            let { atime: atim, mtime: mtim } = rstats;\n            const n = nsToMs(now(constants_1.WASI_CLOCK_REALTIME)), atimflags = constants_1.WASI_FILESTAT_SET_ATIM | constants_1.WASI_FILESTAT_SET_ATIM_NOW;\n            if ((fstflags & atimflags) === atimflags)\n              return constants_1.WASI_EINVAL;\n            const mtimflags = constants_1.WASI_FILESTAT_SET_MTIM | constants_1.WASI_FILESTAT_SET_MTIM_NOW;\n            if ((fstflags & mtimflags) === mtimflags)\n              return constants_1.WASI_EINVAL;\n            if ((fstflags & constants_1.WASI_FILESTAT_SET_ATIM) === constants_1.WASI_FILESTAT_SET_ATIM)\n              atim = nsToMs(stAtim);\n            else if ((fstflags & constants_1.WASI_FILESTAT_SET_ATIM_NOW) === constants_1.WASI_FILESTAT_SET_ATIM_NOW)\n              atim = n;\n            if ((fstflags & constants_1.WASI_FILESTAT_SET_MTIM) === constants_1.WASI_FILESTAT_SET_MTIM)\n              mtim = nsToMs(stMtim);\n            else if ((fstflags & constants_1.WASI_FILESTAT_SET_MTIM_NOW) === constants_1.WASI_FILESTAT_SET_MTIM_NOW)\n              mtim = n;\n            const p = Buffer.from(this.memory.buffer, pathPtr, pathLen).toString();\n            return fs.utimesSync(path.resolve(stats.path, p), new Date(atim), new Date(mtim)), constants_1.WASI_ESUCCESS;\n          }),\n          path_link: wrap((oldFd, _oldFlags, oldPath, oldPathLen, newFd, newPath, newPathLen) => {\n            const ostats = CHECK_FD(oldFd, constants_1.WASI_RIGHT_PATH_LINK_SOURCE), nstats = CHECK_FD(newFd, constants_1.WASI_RIGHT_PATH_LINK_TARGET);\n            if (!ostats.path || !nstats.path)\n              return constants_1.WASI_EINVAL;\n            this.refreshMemory();\n            const op = Buffer.from(this.memory.buffer, oldPath, oldPathLen).toString(), np = Buffer.from(this.memory.buffer, newPath, newPathLen).toString();\n            return fs.linkSync(path.resolve(ostats.path, op), path.resolve(nstats.path, np)), constants_1.WASI_ESUCCESS;\n          }),\n          path_open: wrap((dirfd, _dirflags, pathPtr, pathLen, oflags, fsRightsBase, fsRightsInheriting, fsFlags, fdPtr) => {\n            try {\n              const stats = CHECK_FD(dirfd, constants_1.WASI_RIGHT_PATH_OPEN);\n              fsRightsBase = BigInt(fsRightsBase), fsRightsInheriting = BigInt(fsRightsInheriting);\n              const read = (fsRightsBase & (constants_1.WASI_RIGHT_FD_READ | constants_1.WASI_RIGHT_FD_READDIR)) !== BigInt(0), write = (fsRightsBase & (constants_1.WASI_RIGHT_FD_DATASYNC | constants_1.WASI_RIGHT_FD_WRITE | constants_1.WASI_RIGHT_FD_ALLOCATE | constants_1.WASI_RIGHT_FD_FILESTAT_SET_SIZE)) !== BigInt(0);\n              let noflags;\n              if (write && read)\n                noflags = nodeFsConstants.O_RDWR;\n              else if (read)\n                noflags = nodeFsConstants.O_RDONLY;\n              else if (write)\n                noflags = nodeFsConstants.O_WRONLY;\n              let neededBase = fsRightsBase | constants_1.WASI_RIGHT_PATH_OPEN, neededInheriting = fsRightsBase | fsRightsInheriting;\n              if ((oflags & constants_1.WASI_O_CREAT) !== 0)\n                noflags |= nodeFsConstants.O_CREAT, neededBase |= constants_1.WASI_RIGHT_PATH_CREATE_FILE;\n              if ((oflags & constants_1.WASI_O_DIRECTORY) !== 0)\n                noflags |= nodeFsConstants.O_DIRECTORY;\n              if ((oflags & constants_1.WASI_O_EXCL) !== 0)\n                noflags |= nodeFsConstants.O_EXCL;\n              if ((oflags & constants_1.WASI_O_TRUNC) !== 0)\n                noflags |= nodeFsConstants.O_TRUNC, neededBase |= constants_1.WASI_RIGHT_PATH_FILESTAT_SET_SIZE;\n              if ((fsFlags & constants_1.WASI_FDFLAG_APPEND) !== 0)\n                noflags |= nodeFsConstants.O_APPEND;\n              if ((fsFlags & constants_1.WASI_FDFLAG_DSYNC) !== 0) {\n                if (nodeFsConstants.O_DSYNC)\n                  noflags |= nodeFsConstants.O_DSYNC;\n                else\n                  noflags |= nodeFsConstants.O_SYNC;\n                neededInheriting |= constants_1.WASI_RIGHT_FD_DATASYNC;\n              }\n              if ((fsFlags & constants_1.WASI_FDFLAG_NONBLOCK) !== 0)\n                noflags |= nodeFsConstants.O_NONBLOCK;\n              if ((fsFlags & constants_1.WASI_FDFLAG_RSYNC) !== 0) {\n                if (nodeFsConstants.O_RSYNC)\n                  noflags |= nodeFsConstants.O_RSYNC;\n                else\n                  noflags |= nodeFsConstants.O_SYNC;\n                neededInheriting |= constants_1.WASI_RIGHT_FD_SYNC;\n              }\n              if ((fsFlags & constants_1.WASI_FDFLAG_SYNC) !== 0)\n                noflags |= nodeFsConstants.O_SYNC, neededInheriting |= constants_1.WASI_RIGHT_FD_SYNC;\n              if (write && (noflags & (nodeFsConstants.O_APPEND | nodeFsConstants.O_TRUNC)) === 0)\n                neededInheriting |= constants_1.WASI_RIGHT_FD_SEEK;\n              this.refreshMemory();\n              const p = Buffer.from(this.memory.buffer, pathPtr, pathLen).toString();\n              if (p == \"dev/tty\")\n                return this.view.setUint32(fdPtr, constants_1.WASI_STDIN_FILENO, !0), constants_1.WASI_ESUCCESS;\n              if (logOpen(\"path_open\", p), p.startsWith(\"proc/\"))\n                throw new types_1.WASIError(constants_1.WASI_EBADF);\n              const fullUnresolved = path.resolve(p);\n              let full;\n              try {\n                full = fs.realpathSync(fullUnresolved);\n              } catch (e) {\n                if (e\?.code === \"ENOENT\")\n                  full = fullUnresolved;\n                else\n                  throw e;\n              }\n              let isDirectory;\n              if (write)\n                try {\n                  isDirectory = fs.statSync(full).isDirectory();\n                } catch (_err) {\n                }\n              let realfd;\n              if (!write && isDirectory)\n                realfd = fs.openSync(full, nodeFsConstants.O_RDONLY);\n              else\n                realfd = fs.openSync(full, noflags);\n              const newfd = this.getUnusedFileDescriptor();\n              this.FD_MAP.set(newfd, {\n                real: realfd,\n                filetype: void 0,\n                rights: {\n                  base: neededBase,\n                  inheriting: neededInheriting\n                },\n                path: full\n              }), stat(this, newfd), this.view.setUint32(fdPtr, newfd, !0);\n            } catch (e) {\n              console.error(e);\n            }\n            return constants_1.WASI_ESUCCESS;\n          }),\n          path_readlink: wrap((fd, pathPtr, pathLen, buf, bufLen, bufused) => {\n            const stats = CHECK_FD(fd, constants_1.WASI_RIGHT_PATH_READLINK);\n            if (!stats.path)\n              return constants_1.WASI_EINVAL;\n            this.refreshMemory();\n            const p = Buffer.from(this.memory.buffer, pathPtr, pathLen).toString(), full = path.resolve(stats.path, p), r = fs.readlinkSync(full), used = Buffer.from(this.memory.buffer).write(r, buf, bufLen);\n            return this.view.setUint32(bufused, used, !0), constants_1.WASI_ESUCCESS;\n          }),\n          path_remove_directory: wrap((fd, pathPtr, pathLen) => {\n            const stats = CHECK_FD(fd, constants_1.WASI_RIGHT_PATH_REMOVE_DIRECTORY);\n            if (!stats.path)\n              return constants_1.WASI_EINVAL;\n            this.refreshMemory();\n            const p = Buffer.from(this.memory.buffer, pathPtr, pathLen).toString();\n            return fs.rmdirSync(path.resolve(stats.path, p)), constants_1.WASI_ESUCCESS;\n          }),\n          path_rename: wrap((oldFd, oldPath, oldPathLen, newFd, newPath, newPathLen) => {\n            const ostats = CHECK_FD(oldFd, constants_1.WASI_RIGHT_PATH_RENAME_SOURCE), nstats = CHECK_FD(newFd, constants_1.WASI_RIGHT_PATH_RENAME_TARGET);\n            if (!ostats.path || !nstats.path)\n              return constants_1.WASI_EINVAL;\n            this.refreshMemory();\n            const op = Buffer.from(this.memory.buffer, oldPath, oldPathLen).toString(), np = Buffer.from(this.memory.buffer, newPath, newPathLen).toString();\n            return fs.renameSync(path.resolve(ostats.path, op), path.resolve(nstats.path, np)), constants_1.WASI_ESUCCESS;\n          }),\n          path_symlink: wrap((oldPath, oldPathLen, fd, newPath, newPathLen) => {\n            const stats = CHECK_FD(fd, constants_1.WASI_RIGHT_PATH_SYMLINK);\n            if (!stats.path)\n              return constants_1.WASI_EINVAL;\n            this.refreshMemory();\n            const op = Buffer.from(this.memory.buffer, oldPath, oldPathLen).toString(), np = Buffer.from(this.memory.buffer, newPath, newPathLen).toString();\n            return fs.symlinkSync(op, path.resolve(stats.path, np)), constants_1.WASI_ESUCCESS;\n          }),\n          path_unlink_file: wrap((fd, pathPtr, pathLen) => {\n            const stats = CHECK_FD(fd, constants_1.WASI_RIGHT_PATH_UNLINK_FILE);\n            if (!stats.path)\n              return constants_1.WASI_EINVAL;\n            this.refreshMemory();\n            const p = Buffer.from(this.memory.buffer, pathPtr, pathLen).toString();\n            return fs.unlinkSync(path.resolve(stats.path, p)), constants_1.WASI_ESUCCESS;\n          }),\n          poll_oneoff: (sin, sout, nsubscriptions, neventsPtr) => {\n            let nevents = 0, name = \"\", waitTimeNs = BigInt(0), fd = -1, fd_type = \"read\", fd_timeout_ms = 0;\n            const startNs = BigInt(bindings2.hrtime());\n            this.refreshMemory();\n            let last_sin = sin;\n            for (let i = 0;i < nsubscriptions; i += 1) {\n              const userdata = this.view.getBigUint64(sin, !0);\n              sin += 8;\n              const type = this.view.getUint8(sin);\n              if (sin += 1, sin += 7, log.enabled) {\n                if (type == constants_1.WASI_EVENTTYPE_CLOCK)\n                  name = \"poll_oneoff (type=WASI_EVENTTYPE_CLOCK): \";\n                else if (type == constants_1.WASI_EVENTTYPE_FD_READ)\n                  name = \"poll_oneoff (type=WASI_EVENTTYPE_FD_READ): \";\n                else\n                  name = \"poll_oneoff (type=WASI_EVENTTYPE_FD_WRITE): \";\n                log(name);\n              }\n              switch (type) {\n                case constants_1.WASI_EVENTTYPE_CLOCK: {\n                  const clockid = this.view.getUint32(sin, !0);\n                  sin += 4, sin += 4;\n                  const timeout = this.view.getBigUint64(sin, !0);\n                  sin += 8, sin += 8;\n                  const subclockflags = this.view.getUint16(sin, !0);\n                  sin += 2, sin += 6;\n                  const absolute = subclockflags === 1;\n                  if (log.enabled)\n                    log(name, { clockid, timeout, absolute });\n                  if (!absolute)\n                    fd_timeout_ms = timeout / BigInt(1e6);\n                  let e = constants_1.WASI_ESUCCESS;\n                  const t = now(clockid);\n                  if (t == null)\n                    e = constants_1.WASI_EINVAL;\n                  else {\n                    const tNS = BigInt(t), waitNs = (absolute \? timeout : tNS + timeout) - tNS;\n                    if (waitNs > waitTimeNs)\n                      waitTimeNs = waitNs;\n                  }\n                  this.view.setBigUint64(sout, userdata, !0), sout += 8, this.view.setUint16(sout, e, !0), sout += 2, this.view.setUint8(sout, constants_1.WASI_EVENTTYPE_CLOCK), sout += 1, sout += 5, nevents += 1;\n                  break;\n                }\n                case constants_1.WASI_EVENTTYPE_FD_READ:\n                case constants_1.WASI_EVENTTYPE_FD_WRITE: {\n                  if (fd = this.view.getUint32(sin, !0), fd_type = type == constants_1.WASI_EVENTTYPE_FD_READ \? \"read\" : \"write\", sin += 4, log(name, \"fd =\", fd), sin += 28, this.view.setBigUint64(sout, userdata, !0), sout += 8, this.view.setUint16(sout, constants_1.WASI_ENOSYS, !0), sout += 2, this.view.setUint8(sout, type), sout += 1, sout += 5, nevents += 1, fd == constants_1.WASI_STDIN_FILENO && constants_1.WASI_EVENTTYPE_FD_READ == type)\n                    this.shortPause();\n                  break;\n                }\n                default:\n                  return constants_1.WASI_EINVAL;\n              }\n              if (sin - last_sin != 48)\n                console.warn(\"*** BUG in wasi-js in poll_oneoff \", {\n                  i,\n                  sin,\n                  last_sin,\n                  diff: sin - last_sin\n                });\n              last_sin = sin;\n            }\n            if (this.view.setUint32(neventsPtr, nevents, !0), nevents == 2 && fd >= 0) {\n              const r = this.wasiImport.sock_pollSocket(fd, fd_type, fd_timeout_ms);\n              if (r != constants_1.WASI_ENOSYS)\n                return r;\n            }\n            if (waitTimeNs > 0) {\n              if (waitTimeNs -= Bun.nanoseconds() - timeOrigin, waitTimeNs >= 1e6) {\n                if (this.sleep == null && !warnedAboutSleep)\n                  warnedAboutSleep = !0, console.log(\"(100% cpu burning waiting for stdin: please define a way to sleep!) \");\n                if (this.sleep != null) {\n                  const ms = nsToMs(waitTimeNs);\n                  this.sleep(ms);\n                } else {\n                  const end = BigInt(bindings2.hrtime()) + waitTimeNs;\n                  while (BigInt(bindings2.hrtime()) < end)\n                    ;\n                }\n              }\n            }\n            return constants_1.WASI_ESUCCESS;\n          },\n          proc_exit: (rval) => {\n            return bindings2.exit(rval), constants_1.WASI_ESUCCESS;\n          },\n          proc_raise: (sig) => {\n            if (!(sig in constants_1.SIGNAL_MAP))\n              return constants_1.WASI_EINVAL;\n            return bindings2.kill(constants_1.SIGNAL_MAP[sig]), constants_1.WASI_ESUCCESS;\n          },\n          random_get: (bufPtr, bufLen) => {\n            return this.refreshMemory(), crypto.getRandomValues(this.memory.buffer, bufPtr, bufLen), bufLen;\n          },\n          sched_yield() {\n            return constants_1.WASI_ESUCCESS;\n          },\n          sock_recv() {\n            return constants_1.WASI_ENOSYS;\n          },\n          sock_send() {\n            return constants_1.WASI_ENOSYS;\n          },\n          sock_shutdown() {\n            return constants_1.WASI_ENOSYS;\n          },\n          sock_fcntlSetFlags(_fd, _flags) {\n            return constants_1.WASI_ENOSYS;\n          },\n          sock_pollSocket(_fd, _eventtype, _timeout_ms) {\n            return constants_1.WASI_ENOSYS;\n          }\n        }, log.enabled)\n          Object.keys(this.wasiImport).forEach((key) => {\n            const prevImport = this.wasiImport[key];\n            this.wasiImport[key] = function(...args2) {\n              log(key, args2);\n              try {\n                let result = prevImport(...args2);\n                return log(\"result\", result), result;\n              } catch (e) {\n                throw log(\"error: \", e), e;\n              }\n            };\n          });\n      }\n      getState() {\n        return { env: this.env, FD_MAP: this.FD_MAP, bindings };\n      }\n      setState(state) {\n        this.env = state.env, this.FD_MAP = state.FD_MAP, bindings = state.bindings;\n      }\n      fstatSync(real_fd) {\n        if (real_fd <= 2)\n          try {\n            return fs.fstatSync(real_fd);\n          } catch (_) {\n            const now = new Date;\n            return {\n              dev: 0,\n              mode: 8592,\n              nlink: 1,\n              uid: 0,\n              gid: 0,\n              rdev: 0,\n              blksize: 65536,\n              ino: 0,\n              size: 0,\n              blocks: 0,\n              atimeMs: now.valueOf(),\n              mtimeMs: now.valueOf(),\n              ctimeMs: now.valueOf(),\n              birthtimeMs: 0,\n              atime: new Date,\n              mtime: new Date,\n              ctime: new Date,\n              birthtime: new Date(0)\n            };\n          }\n        return fs.fstatSync(real_fd);\n      }\n      shortPause() {\n        if (this.sleep == null)\n          return;\n        if ((new Date()).valueOf() - this.lastStdin > 2000)\n          this.sleep(50);\n      }\n      getUnusedFileDescriptor(start = 3) {\n        let fd = start;\n        while (this.FD_MAP.has(fd))\n          fd += 1;\n        if (fd > SC_OPEN_MAX)\n          throw Error(\"no available file descriptors\");\n        return fd;\n      }\n      refreshMemory() {\n        if (!this.view || this.view.buffer.byteLength === 0)\n          this.view = new DataView(this.memory.buffer);\n      }\n      setMemory(memory) {\n        this.memory = memory;\n      }\n      start(instance, memory) {\n        const exports2 = instance.exports;\n        if (exports2 === null || typeof exports2 !== \"object\")\n          throw new Error(`instance.exports must be an Object. Received ${exports2}.`);\n        if (memory == null) {\n          if (memory = exports2.memory, !(memory instanceof WebAssembly.Memory))\n            throw new Error(`instance.exports.memory must be a WebAssembly.Memory. Recceived ${memory}.`);\n        }\n        if (this.setMemory(memory), exports2._start)\n          exports2._start();\n      }\n      getImports(module2) {\n        let namespace = null;\n        const imports = WebAssembly.Module.imports(module2);\n        for (let imp of imports) {\n          if (imp.kind !== \"function\")\n            continue;\n          if (!imp.module.startsWith(\"wasi_\"))\n            continue;\n          namespace = imp.module;\n          break;\n        }\n        switch (namespace) {\n          case \"wasi_unstable\":\n            return {\n              wasi_unstable: this.wasiImport\n            };\n          case \"wasi_snapshot_preview1\":\n            return {\n              wasi_snapshot_preview1: this.wasiImport\n            };\n          default:\n            throw new Error(\"No WASI namespace found. Only wasi_unstable and wasi_snapshot_preview1 are supported.\\n\\nList of imports:\\n\\n\" + imports.map(({ name, kind, module }) => `${module}:${name} (${kind})`).join(\"\\n\") + \"\\n\");\n        }\n      }\n      initWasiFdInfo() {\n        if (this.env.WASI_FD_INFO != null) {\n          const fdInfo = JSON.parse(this.env.WASI_FD_INFO);\n          for (let wasi_fd in fdInfo) {\n            console.log(wasi_fd);\n            const fd = parseInt(wasi_fd);\n            if (this.FD_MAP.has(fd))\n              continue;\n            const real = fdInfo[wasi_fd];\n            try {\n              this.fstatSync(real);\n            } catch (_err) {\n              console.log(\"discarding \", { wasi_fd, real });\n              continue;\n            }\n            const file = {\n              real,\n              filetype: constants_1.WASI_FILETYPE_SOCKET_STREAM,\n              rights: {\n                base: STDIN_DEFAULT_RIGHTS,\n                inheriting: BigInt(0)\n              }\n            };\n            this.FD_MAP.set(fd, file);\n          }\n          console.log(\"after initWasiFdInfo: \", this.FD_MAP), console.log(\"fdInfo = \", fdInfo);\n        } else\n          console.log(\"no WASI_FD_INFO\");\n      }\n    };\n    exports.default = WASI;\n  }\n});\nreturn { WASI: require_wasi().default }})\n"_s;
//

//
static constexpr ASCIILiteral NodeWorkerThreadsCode = "(function (){\"use strict\";// src/js/out/tmp/node/worker_threads.ts\nvar emitWarning = function(type, message) {\n  if (emittedWarnings.has(type))\n    return;\n  emittedWarnings.add(type), console.warn(\"[bun] Warning:\", message);\n}, injectFakeEmitter = function(Class) {\n  function messageEventHandler(event) {\n    return event.data;\n  }\n  function errorEventHandler(event) {\n    return event.error;\n  }\n  const wrappedListener = Symbol(\"wrappedListener\");\n  function wrapped(run, listener) {\n    const callback = function(event) {\n      return listener(run(event));\n    };\n    return listener[wrappedListener] = callback, callback;\n  }\n  function functionForEventType(event, listener) {\n    switch (event) {\n      case \"error\":\n      case \"messageerror\":\n        return wrapped(errorEventHandler, listener);\n      default:\n        return wrapped(messageEventHandler, listener);\n    }\n  }\n  Class.prototype.on = function(event, listener) {\n    return this.addEventListener(event, functionForEventType(event, listener)), this;\n  }, Class.prototype.off = function(event, listener) {\n    if (listener)\n      this.removeEventListener(event, listener[wrappedListener] || listener);\n    else\n      this.removeEventListener(event);\n    return this;\n  }, Class.prototype.once = function(event, listener) {\n    return this.addEventListener(event, functionForEventType(event, listener), { once: !0 }), this;\n  };\n  function EventClass(eventName) {\n    if (eventName === \"error\" || eventName === \"messageerror\")\n      return ErrorEvent;\n    return MessageEvent;\n  }\n  Class.prototype.emit = function(event, ...args) {\n    return this.dispatchEvent(new (EventClass(event))(event, ...args)), this;\n  }, Class.prototype.prependListener = Class.prototype.on, Class.prototype.prependOnceListener = Class.prototype.once;\n}, receiveMessageOnPort = function(port) {\n  let res = _receiveMessageOnPort(port);\n  if (!res)\n    return;\n  return {\n    message: res\n  };\n}, fakeParentPort = function() {\n  const fake = Object.create(MessagePort.prototype);\n  return Object.defineProperty(fake, \"onmessage\", {\n    get() {\n      return self.onmessage;\n    },\n    set(value) {\n      self.onmessage = value;\n    }\n  }), Object.defineProperty(fake, \"onmessageerror\", {\n    get() {\n      return self.onmessageerror;\n    },\n    set(value) {\n    }\n  }), Object.defineProperty(fake, \"postMessage\", {\n    value(...args) {\n      return self.postMessage(...args);\n    }\n  }), Object.defineProperty(fake, \"close\", {\n    value() {\n      return process.exit(0);\n    }\n  }), Object.defineProperty(fake, \"start\", {\n    value() {\n    }\n  }), Object.defineProperty(fake, \"unref\", {\n    value() {\n    }\n  }), Object.defineProperty(fake, \"ref\", {\n    value() {\n    }\n  }), Object.defineProperty(fake, \"hasRef\", {\n    value() {\n      return !1;\n    }\n  }), Object.defineProperty(fake, \"setEncoding\", {\n    value() {\n    }\n  }), Object.defineProperty(fake, \"addEventListener\", {\n    value: self.addEventListener.bind(self)\n  }), Object.defineProperty(fake, \"removeEventListener\", {\n    value: self.removeEventListener.bind(self)\n  }), fake;\n}, getEnvironmentData = function() {\n  return process.env;\n}, setEnvironmentData = function(env) {\n  process.env = env;\n}, markAsUntransferable = function() {\n  throwNotImplemented(\"worker_threads.markAsUntransferable\");\n}, moveMessagePortToContext = function() {\n  throwNotImplemented(\"worker_threads.moveMessagePortToContext\");\n}, $, EventEmitter = @getInternalField(@internalModuleRegistry, 16) || @createInternalModuleById(16), { throwNotImplemented } = @getInternalField(@internalModuleRegistry, 3) || @createInternalModuleById(3), { MessageChannel, BroadcastChannel, Worker: WebWorker } = globalThis, SHARE_ENV = Symbol(\"nodejs.worker_threads.SHARE_ENV\"), isMainThread = Bun.isMainThread, [_workerData, _threadId, _receiveMessageOnPort] = globalThis[globalThis.Symbol.for('Bun.lazy')](\"worker_threads\"), emittedWarnings = new Set, _MessagePort = globalThis.MessagePort;\ninjectFakeEmitter(_MessagePort);\nvar MessagePort = _MessagePort, resourceLimits = {}, workerData = _workerData, threadId = _threadId, parentPort = isMainThread \? null : fakeParentPort(), unsupportedOptions = [\n  \"eval\",\n  \"argv\",\n  \"execArgv\",\n  \"stdin\",\n  \"stdout\",\n  \"stderr\",\n  \"trackedUnmanagedFds\",\n  \"resourceLimits\"\n];\n\nclass Worker extends EventEmitter {\n  #worker;\n  #performance;\n  #onExitPromise = void 0;\n  constructor(filename, options = {}) {\n    super();\n    for (let key of unsupportedOptions)\n      if (key in options)\n        emitWarning(\"option.\" + key, `worker_threads.Worker option \"${key}\" is not implemented.`);\n    this.#worker = new WebWorker(filename, options), this.#worker.addEventListener(\"close\", this.#onClose.bind(this)), this.#worker.addEventListener(\"error\", this.#onError.bind(this)), this.#worker.addEventListener(\"message\", this.#onMessage.bind(this)), this.#worker.addEventListener(\"messageerror\", this.#onMessageError.bind(this)), this.#worker.addEventListener(\"open\", this.#onOpen.bind(this));\n  }\n  ref() {\n    this.#worker.ref();\n  }\n  unref() {\n    this.#worker.unref();\n  }\n  get stdin() {\n    return null;\n  }\n  get stdout() {\n    return null;\n  }\n  get stderr() {\n    return null;\n  }\n  get performance() {\n    return this.#performance \?\?= {\n      eventLoopUtilization() {\n        return emitWarning(\"performance\", \"worker_threads.Worker.performance is not implemented.\"), {\n          idle: 0,\n          active: 0,\n          utilization: 0\n        };\n      }\n    };\n  }\n  terminate() {\n    var onExitPromise = this.#onExitPromise;\n    if (onExitPromise)\n      return @isPromise(onExitPromise) \? onExitPromise : Promise.resolve(onExitPromise);\n    const { resolve, promise } = Promise.withResolvers();\n    return this.#worker.addEventListener(\"close\", (event) => {\n      resolve(event.code);\n    }, { once: !0 }), this.#worker.terminate(), this.#onExitPromise = promise;\n  }\n  postMessage(...args) {\n    return this.#worker.postMessage(...args);\n  }\n  #onClose(e) {\n    this.#onExitPromise = e.code, this.emit(\"exit\", e.code);\n  }\n  #onError(error) {\n    this.emit(\"error\", error);\n  }\n  #onMessage(event) {\n    this.emit(\"message\", event.data);\n  }\n  #onMessageError(event) {\n    this.emit(\"messageerror\", event.error \?\? event.data \?\? event);\n  }\n  #onOpen() {\n    this.emit(\"online\");\n  }\n  async getHeapSnapshot() {\n    throwNotImplemented(\"worker_threads.Worker.getHeapSnapshot\");\n  }\n}\n$ = {\n  Worker,\n  workerData,\n  parentPort,\n  resourceLimits,\n  isMainThread,\n  MessageChannel,\n  BroadcastChannel,\n  MessagePort,\n  getEnvironmentData,\n  setEnvironmentData,\n  getHeapSnapshot() {\n    return {};\n  },\n  markAsUntransferable,\n  moveMessagePortToContext,\n  receiveMessageOnPort,\n  SHARE_ENV,\n  threadId\n};\nreturn $})\n"_s;
//

//
static constexpr ASCIILiteral NodeZlibCode = "(function (){\"use strict\";// src/js/out/tmp/node/zlib.ts\nvar assert = @getInternalField(@internalModuleRegistry, 4) || @createInternalModuleById(4), BufferModule = @requireNativeModule(\"node:buffer\"), StreamModule = @getInternalField(@internalModuleRegistry, 35) || @createInternalModuleById(35), Util = @getInternalField(@internalModuleRegistry, 43) || @createInternalModuleById(43), __getOwnPropNames = Object.getOwnPropertyNames, __commonJS = (cb, mod) => function __require() {\n  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;\n}, require_zstream = __commonJS({\n  \"node_modules/pako/lib/zlib/zstream.js\"(exports, module2) {\n    function ZStream() {\n      this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = \"\", this.state = null, this.data_type = 2, this.adler = 0;\n    }\n    module2.exports = ZStream;\n  }\n}), require_common = __commonJS({\n  \"node_modules/pako/lib/utils/common.js\"(exports) {\n    var TYPED_OK = typeof Uint8Array !== \"undefined\" && typeof Uint16Array !== \"undefined\" && typeof Int32Array !== \"undefined\";\n    function _has(obj, key) {\n      return Object.prototype.hasOwnProperty.call(obj, key);\n    }\n    exports.assign = function(obj) {\n      var sources = Array.prototype.slice.call(arguments, 1);\n      while (sources.length) {\n        var source = sources.shift();\n        if (!source)\n          continue;\n        if (typeof source !== \"object\")\n          @throwTypeError(source + \"must be non-object\");\n        for (var p in source)\n          if (_has(source, p))\n            obj[p] = source[p];\n      }\n      return obj;\n    }, exports.shrinkBuf = function(buf, size) {\n      if (buf.length === size)\n        return buf;\n      if (buf.subarray)\n        return buf.subarray(0, size);\n      return buf.length = size, buf;\n    };\n    var fnTyped = {\n      arraySet: function(dest, src, src_offs, len, dest_offs) {\n        if (src.subarray && dest.subarray) {\n          dest.set(src.subarray(src_offs, src_offs + len), dest_offs);\n          return;\n        }\n        for (var i = 0;i < len; i++)\n          dest[dest_offs + i] = src[src_offs + i];\n      },\n      flattenChunks: function(chunks) {\n        var i, l, len, pos, chunk, result;\n        len = 0;\n        for (i = 0, l = chunks.length;i < l; i++)\n          len += chunks[i].length;\n        result = new Uint8Array(len), pos = 0;\n        for (i = 0, l = chunks.length;i < l; i++)\n          chunk = chunks[i], result.set(chunk, pos), pos += chunk.length;\n        return result;\n      }\n    }, fnUntyped = {\n      arraySet: function(dest, src, src_offs, len, dest_offs) {\n        for (var i = 0;i < len; i++)\n          dest[dest_offs + i] = src[src_offs + i];\n      },\n      flattenChunks: function(chunks) {\n        return [].concat.apply([], chunks);\n      }\n    };\n    exports.setTyped = function(on) {\n      if (on)\n        exports.Buf8 = Uint8Array, exports.Buf16 = Uint16Array, exports.Buf32 = Int32Array, exports.assign(exports, fnTyped);\n      else\n        exports.Buf8 = Array, exports.Buf16 = Array, exports.Buf32 = Array, exports.assign(exports, fnUntyped);\n    }, exports.setTyped(TYPED_OK);\n  }\n}), require_trees = __commonJS({\n  \"node_modules/pako/lib/zlib/trees.js\"(exports) {\n    var utils = require_common(), Z_FIXED = 4, Z_BINARY = 0, Z_TEXT = 1, Z_UNKNOWN = 2;\n    function zero(buf) {\n      var len = buf.length;\n      while (--len >= 0)\n        buf[len] = 0;\n    }\n    var STORED_BLOCK = 0, STATIC_TREES = 1, DYN_TREES = 2, MIN_MATCH = 3, MAX_MATCH = 258, LENGTH_CODES = 29, LITERALS = 256, L_CODES = LITERALS + 1 + LENGTH_CODES, D_CODES = 30, BL_CODES = 19, HEAP_SIZE = 2 * L_CODES + 1, MAX_BITS = 15, Buf_size = 16, MAX_BL_BITS = 7, END_BLOCK = 256, REP_3_6 = 16, REPZ_3_10 = 17, REPZ_11_138 = 18, extra_lbits = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0], extra_dbits = [\n      0,\n      0,\n      0,\n      0,\n      1,\n      1,\n      2,\n      2,\n      3,\n      3,\n      4,\n      4,\n      5,\n      5,\n      6,\n      6,\n      7,\n      7,\n      8,\n      8,\n      9,\n      9,\n      10,\n      10,\n      11,\n      11,\n      12,\n      12,\n      13,\n      13\n    ], extra_blbits = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7], bl_order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], DIST_CODE_LEN = 512, static_ltree = new Array((L_CODES + 2) * 2);\n    zero(static_ltree);\n    var static_dtree = new Array(D_CODES * 2);\n    zero(static_dtree);\n    var _dist_code = new Array(DIST_CODE_LEN);\n    zero(_dist_code);\n    var _length_code = new Array(MAX_MATCH - MIN_MATCH + 1);\n    zero(_length_code);\n    var base_length = new Array(LENGTH_CODES);\n    zero(base_length);\n    var base_dist = new Array(D_CODES);\n    zero(base_dist);\n    function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {\n      this.static_tree = static_tree, this.extra_bits = extra_bits, this.extra_base = extra_base, this.elems = elems, this.max_length = max_length, this.has_stree = static_tree && static_tree.length;\n    }\n    var static_l_desc, static_d_desc, static_bl_desc;\n    function TreeDesc(dyn_tree, stat_desc) {\n      this.dyn_tree = dyn_tree, this.max_code = 0, this.stat_desc = stat_desc;\n    }\n    function d_code(dist) {\n      return dist < 256 \? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];\n    }\n    function put_short(s, w) {\n      s.pending_buf[s.pending++] = w & 255, s.pending_buf[s.pending++] = w >>> 8 & 255;\n    }\n    function send_bits(s, value, length) {\n      if (s.bi_valid > Buf_size - length)\n        s.bi_buf |= value << s.bi_valid & 65535, put_short(s, s.bi_buf), s.bi_buf = value >> Buf_size - s.bi_valid, s.bi_valid += length - Buf_size;\n      else\n        s.bi_buf |= value << s.bi_valid & 65535, s.bi_valid += length;\n    }\n    function send_code(s, c, tree) {\n      send_bits(s, tree[c * 2], tree[c * 2 + 1]);\n    }\n    function bi_reverse(code, len) {\n      var res = 0;\n      do\n        res |= code & 1, code >>>= 1, res <<= 1;\n      while (--len > 0);\n      return res >>> 1;\n    }\n    function bi_flush(s) {\n      if (s.bi_valid === 16)\n        put_short(s, s.bi_buf), s.bi_buf = 0, s.bi_valid = 0;\n      else if (s.bi_valid >= 8)\n        s.pending_buf[s.pending++] = s.bi_buf & 255, s.bi_buf >>= 8, s.bi_valid -= 8;\n    }\n    function gen_bitlen(s, desc) {\n      var { dyn_tree: tree, max_code } = desc, stree = desc.stat_desc.static_tree, has_stree = desc.stat_desc.has_stree, extra = desc.stat_desc.extra_bits, base = desc.stat_desc.extra_base, max_length = desc.stat_desc.max_length, h, n, m, bits, xbits, f, overflow = 0;\n      for (bits = 0;bits <= MAX_BITS; bits++)\n        s.bl_count[bits] = 0;\n      tree[s.heap[s.heap_max] * 2 + 1] = 0;\n      for (h = s.heap_max + 1;h < HEAP_SIZE; h++) {\n        if (n = s.heap[h], bits = tree[tree[n * 2 + 1] * 2 + 1] + 1, bits > max_length)\n          bits = max_length, overflow++;\n        if (tree[n * 2 + 1] = bits, n > max_code)\n          continue;\n        if (s.bl_count[bits]++, xbits = 0, n >= base)\n          xbits = extra[n - base];\n        if (f = tree[n * 2], s.opt_len += f * (bits + xbits), has_stree)\n          s.static_len += f * (stree[n * 2 + 1] + xbits);\n      }\n      if (overflow === 0)\n        return;\n      do {\n        bits = max_length - 1;\n        while (s.bl_count[bits] === 0)\n          bits--;\n        s.bl_count[bits]--, s.bl_count[bits + 1] += 2, s.bl_count[max_length]--, overflow -= 2;\n      } while (overflow > 0);\n      for (bits = max_length;bits !== 0; bits--) {\n        n = s.bl_count[bits];\n        while (n !== 0) {\n          if (m = s.heap[--h], m > max_code)\n            continue;\n          if (tree[m * 2 + 1] !== bits)\n            s.opt_len += (bits - tree[m * 2 + 1]) * tree[m * 2], tree[m * 2 + 1] = bits;\n          n--;\n        }\n      }\n    }\n    function gen_codes(tree, max_code, bl_count) {\n      var next_code = new Array(MAX_BITS + 1), code = 0, bits, n;\n      for (bits = 1;bits <= MAX_BITS; bits++)\n        next_code[bits] = code = code + bl_count[bits - 1] << 1;\n      for (n = 0;n <= max_code; n++) {\n        var len = tree[n * 2 + 1];\n        if (len === 0)\n          continue;\n        tree[n * 2] = bi_reverse(next_code[len]++, len);\n      }\n    }\n    function tr_static_init() {\n      var n, bits, length, code, dist, bl_count = new Array(MAX_BITS + 1);\n      length = 0;\n      for (code = 0;code < LENGTH_CODES - 1; code++) {\n        base_length[code] = length;\n        for (n = 0;n < 1 << extra_lbits[code]; n++)\n          _length_code[length++] = code;\n      }\n      _length_code[length - 1] = code, dist = 0;\n      for (code = 0;code < 16; code++) {\n        base_dist[code] = dist;\n        for (n = 0;n < 1 << extra_dbits[code]; n++)\n          _dist_code[dist++] = code;\n      }\n      dist >>= 7;\n      for (;code < D_CODES; code++) {\n        base_dist[code] = dist << 7;\n        for (n = 0;n < 1 << extra_dbits[code] - 7; n++)\n          _dist_code[256 + dist++] = code;\n      }\n      for (bits = 0;bits <= MAX_BITS; bits++)\n        bl_count[bits] = 0;\n      n = 0;\n      while (n <= 143)\n        static_ltree[n * 2 + 1] = 8, n++, bl_count[8]++;\n      while (n <= 255)\n        static_ltree[n * 2 + 1] = 9, n++, bl_count[9]++;\n      while (n <= 279)\n        static_ltree[n * 2 + 1] = 7, n++, bl_count[7]++;\n      while (n <= 287)\n        static_ltree[n * 2 + 1] = 8, n++, bl_count[8]++;\n      gen_codes(static_ltree, L_CODES + 1, bl_count);\n      for (n = 0;n < D_CODES; n++)\n        static_dtree[n * 2 + 1] = 5, static_dtree[n * 2] = bi_reverse(n, 5);\n      static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS), static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES, MAX_BITS), static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES, MAX_BL_BITS);\n    }\n    function init_block(s) {\n      var n;\n      for (n = 0;n < L_CODES; n++)\n        s.dyn_ltree[n * 2] = 0;\n      for (n = 0;n < D_CODES; n++)\n        s.dyn_dtree[n * 2] = 0;\n      for (n = 0;n < BL_CODES; n++)\n        s.bl_tree[n * 2] = 0;\n      s.dyn_ltree[END_BLOCK * 2] = 1, s.opt_len = s.static_len = 0, s.last_lit = s.matches = 0;\n    }\n    function bi_windup(s) {\n      if (s.bi_valid > 8)\n        put_short(s, s.bi_buf);\n      else if (s.bi_valid > 0)\n        s.pending_buf[s.pending++] = s.bi_buf;\n      s.bi_buf = 0, s.bi_valid = 0;\n    }\n    function copy_block(s, buf, len, header) {\n      if (bi_windup(s), header)\n        put_short(s, len), put_short(s, ~len);\n      utils.arraySet(s.pending_buf, s.window, buf, len, s.pending), s.pending += len;\n    }\n    function smaller(tree, n, m, depth) {\n      var _n2 = n * 2, _m2 = m * 2;\n      return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n] <= depth[m];\n    }\n    function pqdownheap(s, tree, k) {\n      var v = s.heap[k], j = k << 1;\n      while (j <= s.heap_len) {\n        if (j < s.heap_len && smaller(tree, s.heap[j + 1], s.heap[j], s.depth))\n          j++;\n        if (smaller(tree, v, s.heap[j], s.depth))\n          break;\n        s.heap[k] = s.heap[j], k = j, j <<= 1;\n      }\n      s.heap[k] = v;\n    }\n    function compress_block(s, ltree, dtree) {\n      var dist, lc, lx = 0, code, extra;\n      if (s.last_lit !== 0)\n        do\n          if (dist = s.pending_buf[s.d_buf + lx * 2] << 8 | s.pending_buf[s.d_buf + lx * 2 + 1], lc = s.pending_buf[s.l_buf + lx], lx++, dist === 0)\n            send_code(s, lc, ltree);\n          else {\n            if (code = _length_code[lc], send_code(s, code + LITERALS + 1, ltree), extra = extra_lbits[code], extra !== 0)\n              lc -= base_length[code], send_bits(s, lc, extra);\n            if (dist--, code = d_code(dist), send_code(s, code, dtree), extra = extra_dbits[code], extra !== 0)\n              dist -= base_dist[code], send_bits(s, dist, extra);\n          }\n        while (lx < s.last_lit);\n      send_code(s, END_BLOCK, ltree);\n    }\n    function build_tree(s, desc) {\n      var tree = desc.dyn_tree, stree = desc.stat_desc.static_tree, has_stree = desc.stat_desc.has_stree, elems = desc.stat_desc.elems, n, m, max_code = -1, node;\n      s.heap_len = 0, s.heap_max = HEAP_SIZE;\n      for (n = 0;n < elems; n++)\n        if (tree[n * 2] !== 0)\n          s.heap[++s.heap_len] = max_code = n, s.depth[n] = 0;\n        else\n          tree[n * 2 + 1] = 0;\n      while (s.heap_len < 2)\n        if (node = s.heap[++s.heap_len] = max_code < 2 \? ++max_code : 0, tree[node * 2] = 1, s.depth[node] = 0, s.opt_len--, has_stree)\n          s.static_len -= stree[node * 2 + 1];\n      desc.max_code = max_code;\n      for (n = s.heap_len >> 1;n >= 1; n--)\n        pqdownheap(s, tree, n);\n      node = elems;\n      do\n        n = s.heap[1], s.heap[1] = s.heap[s.heap_len--], pqdownheap(s, tree, 1), m = s.heap[1], s.heap[--s.heap_max] = n, s.heap[--s.heap_max] = m, tree[node * 2] = tree[n * 2] + tree[m * 2], s.depth[node] = (s.depth[n] >= s.depth[m] \? s.depth[n] : s.depth[m]) + 1, tree[n * 2 + 1] = tree[m * 2 + 1] = node, s.heap[1] = node++, pqdownheap(s, tree, 1);\n      while (s.heap_len >= 2);\n      s.heap[--s.heap_max] = s.heap[1], gen_bitlen(s, desc), gen_codes(tree, max_code, s.bl_count);\n    }\n    function scan_tree(s, tree, max_code) {\n      var n, prevlen = -1, curlen, nextlen = tree[1], count = 0, max_count = 7, min_count = 4;\n      if (nextlen === 0)\n        max_count = 138, min_count = 3;\n      tree[(max_code + 1) * 2 + 1] = 65535;\n      for (n = 0;n <= max_code; n++) {\n        if (curlen = nextlen, nextlen = tree[(n + 1) * 2 + 1], ++count < max_count && curlen === nextlen)\n          continue;\n        else if (count < min_count)\n          s.bl_tree[curlen * 2] += count;\n        else if (curlen !== 0) {\n          if (curlen !== prevlen)\n            s.bl_tree[curlen * 2]++;\n          s.bl_tree[REP_3_6 * 2]++;\n        } else if (count <= 10)\n          s.bl_tree[REPZ_3_10 * 2]++;\n        else\n          s.bl_tree[REPZ_11_138 * 2]++;\n        if (count = 0, prevlen = curlen, nextlen === 0)\n          max_count = 138, min_count = 3;\n        else if (curlen === nextlen)\n          max_count = 6, min_count = 3;\n        else\n          max_count = 7, min_count = 4;\n      }\n    }\n    function send_tree(s, tree, max_code) {\n      var n, prevlen = -1, curlen, nextlen = tree[1], count = 0, max_count = 7, min_count = 4;\n      if (nextlen === 0)\n        max_count = 138, min_count = 3;\n      for (n = 0;n <= max_code; n++) {\n        if (curlen = nextlen, nextlen = tree[(n + 1) * 2 + 1], ++count < max_count && curlen === nextlen)\n          continue;\n        else if (count < min_count)\n          do\n            send_code(s, curlen, s.bl_tree);\n          while (--count !== 0);\n        else if (curlen !== 0) {\n          if (curlen !== prevlen)\n            send_code(s, curlen, s.bl_tree), count--;\n          send_code(s, REP_3_6, s.bl_tree), send_bits(s, count - 3, 2);\n        } else if (count <= 10)\n          send_code(s, REPZ_3_10, s.bl_tree), send_bits(s, count - 3, 3);\n        else\n          send_code(s, REPZ_11_138, s.bl_tree), send_bits(s, count - 11, 7);\n        if (count = 0, prevlen = curlen, nextlen === 0)\n          max_count = 138, min_count = 3;\n        else if (curlen === nextlen)\n          max_count = 6, min_count = 3;\n        else\n          max_count = 7, min_count = 4;\n      }\n    }\n    function build_bl_tree(s) {\n      var max_blindex;\n      scan_tree(s, s.dyn_ltree, s.l_desc.max_code), scan_tree(s, s.dyn_dtree, s.d_desc.max_code), build_tree(s, s.bl_desc);\n      for (max_blindex = BL_CODES - 1;max_blindex >= 3; max_blindex--)\n        if (s.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0)\n          break;\n      return s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4, max_blindex;\n    }\n    function send_all_trees(s, lcodes, dcodes, blcodes) {\n      var rank;\n      send_bits(s, lcodes - 257, 5), send_bits(s, dcodes - 1, 5), send_bits(s, blcodes - 4, 4);\n      for (rank = 0;rank < blcodes; rank++)\n        send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1], 3);\n      send_tree(s, s.dyn_ltree, lcodes - 1), send_tree(s, s.dyn_dtree, dcodes - 1);\n    }\n    function detect_data_type(s) {\n      var black_mask = 4093624447, n;\n      for (n = 0;n <= 31; n++, black_mask >>>= 1)\n        if (black_mask & 1 && s.dyn_ltree[n * 2] !== 0)\n          return Z_BINARY;\n      if (s.dyn_ltree[18] !== 0 || s.dyn_ltree[20] !== 0 || s.dyn_ltree[26] !== 0)\n        return Z_TEXT;\n      for (n = 32;n < LITERALS; n++)\n        if (s.dyn_ltree[n * 2] !== 0)\n          return Z_TEXT;\n      return Z_BINARY;\n    }\n    var static_init_done = !1;\n    function _tr_init(s) {\n      if (!static_init_done)\n        tr_static_init(), static_init_done = !0;\n      s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc), s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc), s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc), s.bi_buf = 0, s.bi_valid = 0, init_block(s);\n    }\n    function _tr_stored_block(s, buf, stored_len, last) {\n      send_bits(s, (STORED_BLOCK << 1) + (last \? 1 : 0), 3), copy_block(s, buf, stored_len, !0);\n    }\n    function _tr_align(s) {\n      send_bits(s, STATIC_TREES << 1, 3), send_code(s, END_BLOCK, static_ltree), bi_flush(s);\n    }\n    function _tr_flush_block(s, buf, stored_len, last) {\n      var opt_lenb, static_lenb, max_blindex = 0;\n      if (s.level > 0) {\n        if (s.strm.data_type === Z_UNKNOWN)\n          s.strm.data_type = detect_data_type(s);\n        if (build_tree(s, s.l_desc), build_tree(s, s.d_desc), max_blindex = build_bl_tree(s), opt_lenb = s.opt_len + 3 + 7 >>> 3, static_lenb = s.static_len + 3 + 7 >>> 3, static_lenb <= opt_lenb)\n          opt_lenb = static_lenb;\n      } else\n        opt_lenb = static_lenb = stored_len + 5;\n      if (stored_len + 4 <= opt_lenb && buf !== -1)\n        _tr_stored_block(s, buf, stored_len, last);\n      else if (s.strategy === Z_FIXED || static_lenb === opt_lenb)\n        send_bits(s, (STATIC_TREES << 1) + (last \? 1 : 0), 3), compress_block(s, static_ltree, static_dtree);\n      else\n        send_bits(s, (DYN_TREES << 1) + (last \? 1 : 0), 3), send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1), compress_block(s, s.dyn_ltree, s.dyn_dtree);\n      if (init_block(s), last)\n        bi_windup(s);\n    }\n    function _tr_tally(s, dist, lc) {\n      if (s.pending_buf[s.d_buf + s.last_lit * 2] = dist >>> 8 & 255, s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 255, s.pending_buf[s.l_buf + s.last_lit] = lc & 255, s.last_lit++, dist === 0)\n        s.dyn_ltree[lc * 2]++;\n      else\n        s.matches++, dist--, s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]++, s.dyn_dtree[d_code(dist) * 2]++;\n      return s.last_lit === s.lit_bufsize - 1;\n    }\n    exports._tr_init = _tr_init, exports._tr_stored_block = _tr_stored_block, exports._tr_flush_block = _tr_flush_block, exports._tr_tally = _tr_tally, exports._tr_align = _tr_align;\n  }\n}), require_adler32 = __commonJS({\n  \"node_modules/pako/lib/zlib/adler32.js\"(exports, module2) {\n    function adler32(adler, buf, len, pos) {\n      var s1 = adler & 65535 | 0, s2 = adler >>> 16 & 65535 | 0, n = 0;\n      while (len !== 0) {\n        n = len > 2000 \? 2000 : len, len -= n;\n        do\n          s1 = s1 + buf[pos++] | 0, s2 = s2 + s1 | 0;\n        while (--n);\n        s1 %= 65521, s2 %= 65521;\n      }\n      return s1 | s2 << 16 | 0;\n    }\n    module2.exports = adler32;\n  }\n}), require_crc32 = __commonJS({\n  \"node_modules/pako/lib/zlib/crc32.js\"(exports, module2) {\n    function makeTable() {\n      var c, table = [];\n      for (var n = 0;n < 256; n++) {\n        c = n;\n        for (var k = 0;k < 8; k++)\n          c = c & 1 \? 3988292384 ^ c >>> 1 : c >>> 1;\n        table[n] = c;\n      }\n      return table;\n    }\n    var crcTable = makeTable();\n    function crc32(crc, buf, len, pos) {\n      var t = crcTable, end = pos + len;\n      crc ^= -1;\n      for (var i = pos;i < end; i++)\n        crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 255];\n      return crc ^ -1;\n    }\n    module2.exports = crc32;\n  }\n}), require_messages = __commonJS({\n  \"node_modules/pako/lib/zlib/messages.js\"(exports, module2) {\n    module2.exports = {\n      2: \"need dictionary\",\n      1: \"stream end\",\n      0: \"\",\n      \"-1\": \"file error\",\n      \"-2\": \"stream error\",\n      \"-3\": \"data error\",\n      \"-4\": \"insufficient memory\",\n      \"-5\": \"buffer error\",\n      \"-6\": \"incompatible version\"\n    };\n  }\n}), require_deflate = __commonJS({\n  \"node_modules/pako/lib/zlib/deflate.js\"(exports) {\n    var utils = require_common(), trees = require_trees(), adler32 = require_adler32(), crc32 = require_crc32(), msg = require_messages(), Z_NO_FLUSH = 0, Z_PARTIAL_FLUSH = 1, Z_FULL_FLUSH = 3, Z_FINISH = 4, Z_BLOCK = 5, Z_OK = 0, Z_STREAM_END = 1, Z_STREAM_ERROR = -2, Z_DATA_ERROR = -3, Z_BUF_ERROR = -5, Z_DEFAULT_COMPRESSION = -1, Z_FILTERED = 1, Z_HUFFMAN_ONLY = 2, Z_RLE = 3, Z_FIXED = 4, Z_DEFAULT_STRATEGY = 0, Z_UNKNOWN = 2, Z_DEFLATED = 8, MAX_MEM_LEVEL = 9, MAX_WBITS = 15, DEF_MEM_LEVEL = 8, LENGTH_CODES = 29, LITERALS = 256, L_CODES = LITERALS + 1 + LENGTH_CODES, D_CODES = 30, BL_CODES = 19, HEAP_SIZE = 2 * L_CODES + 1, MAX_BITS = 15, MIN_MATCH = 3, MAX_MATCH = 258, MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1, PRESET_DICT = 32, INIT_STATE = 42, EXTRA_STATE = 69, NAME_STATE = 73, COMMENT_STATE = 91, HCRC_STATE = 103, BUSY_STATE = 113, FINISH_STATE = 666, BS_NEED_MORE = 1, BS_BLOCK_DONE = 2, BS_FINISH_STARTED = 3, BS_FINISH_DONE = 4, OS_CODE = 3;\n    function err(strm, errorCode) {\n      return strm.msg = msg[errorCode], errorCode;\n    }\n    function rank(f) {\n      return (f << 1) - (f > 4 \? 9 : 0);\n    }\n    function zero(buf) {\n      var len = buf.length;\n      while (--len >= 0)\n        buf[len] = 0;\n    }\n    function flush_pending(strm) {\n      var s = strm.state, len = s.pending;\n      if (len > strm.avail_out)\n        len = strm.avail_out;\n      if (len === 0)\n        return;\n      if (utils.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out), strm.next_out += len, s.pending_out += len, strm.total_out += len, strm.avail_out -= len, s.pending -= len, s.pending === 0)\n        s.pending_out = 0;\n    }\n    function flush_block_only(s, last) {\n      trees._tr_flush_block(s, s.block_start >= 0 \? s.block_start : -1, s.strstart - s.block_start, last), s.block_start = s.strstart, flush_pending(s.strm);\n    }\n    function put_byte(s, b) {\n      s.pending_buf[s.pending++] = b;\n    }\n    function putShortMSB(s, b) {\n      s.pending_buf[s.pending++] = b >>> 8 & 255, s.pending_buf[s.pending++] = b & 255;\n    }\n    function read_buf(strm, buf, start, size) {\n      var len = strm.avail_in;\n      if (len > size)\n        len = size;\n      if (len === 0)\n        return 0;\n      if (strm.avail_in -= len, utils.arraySet(buf, strm.input, strm.next_in, len, start), strm.state.wrap === 1)\n        strm.adler = adler32(strm.adler, buf, len, start);\n      else if (strm.state.wrap === 2)\n        strm.adler = crc32(strm.adler, buf, len, start);\n      return strm.next_in += len, strm.total_in += len, len;\n    }\n    function longest_match(s, cur_match) {\n      var { max_chain_length: chain_length, strstart: scan } = s, match, len, best_len = s.prev_length, nice_match = s.nice_match, limit = s.strstart > s.w_size - MIN_LOOKAHEAD \? s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0, _win = s.window, wmask = s.w_mask, prev = s.prev, strend = s.strstart + MAX_MATCH, scan_end1 = _win[scan + best_len - 1], scan_end = _win[scan + best_len];\n      if (s.prev_length >= s.good_match)\n        chain_length >>= 2;\n      if (nice_match > s.lookahead)\n        nice_match = s.lookahead;\n      do {\n        if (match = cur_match, _win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1])\n          continue;\n        scan += 2, match++;\n        do\n          ;\n        while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);\n        if (len = MAX_MATCH - (strend - scan), scan = strend - MAX_MATCH, len > best_len) {\n          if (s.match_start = cur_match, best_len = len, len >= nice_match)\n            break;\n          scan_end1 = _win[scan + best_len - 1], scan_end = _win[scan + best_len];\n        }\n      } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);\n      if (best_len <= s.lookahead)\n        return best_len;\n      return s.lookahead;\n    }\n    function fill_window(s) {\n      var _w_size = s.w_size, p, n, m, more, str;\n      do {\n        if (more = s.window_size - s.lookahead - s.strstart, s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {\n          utils.arraySet(s.window, s.window, _w_size, _w_size, 0), s.match_start -= _w_size, s.strstart -= _w_size, s.block_start -= _w_size, n = s.hash_size, p = n;\n          do\n            m = s.head[--p], s.head[p] = m >= _w_size \? m - _w_size : 0;\n          while (--n);\n          n = _w_size, p = n;\n          do\n            m = s.prev[--p], s.prev[p] = m >= _w_size \? m - _w_size : 0;\n          while (--n);\n          more += _w_size;\n        }\n        if (s.strm.avail_in === 0)\n          break;\n        if (n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more), s.lookahead += n, s.lookahead + s.insert >= MIN_MATCH) {\n          str = s.strstart - s.insert, s.ins_h = s.window[str], s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + 1]) & s.hash_mask;\n          while (s.insert)\n            if (s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask, s.prev[str & s.w_mask] = s.head[s.ins_h], s.head[s.ins_h] = str, str++, s.insert--, s.lookahead + s.insert < MIN_MATCH)\n              break;\n        }\n      } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);\n    }\n    function deflate_stored(s, flush) {\n      var max_block_size = 65535;\n      if (max_block_size > s.pending_buf_size - 5)\n        max_block_size = s.pending_buf_size - 5;\n      for (;; ) {\n        if (s.lookahead <= 1) {\n          if (fill_window(s), s.lookahead === 0 && flush === Z_NO_FLUSH)\n            return BS_NEED_MORE;\n          if (s.lookahead === 0)\n            break;\n        }\n        s.strstart += s.lookahead, s.lookahead = 0;\n        var max_start = s.block_start + max_block_size;\n        if (s.strstart === 0 || s.strstart >= max_start) {\n          if (s.lookahead = s.strstart - max_start, s.strstart = max_start, flush_block_only(s, !1), s.strm.avail_out === 0)\n            return BS_NEED_MORE;\n        }\n        if (s.strstart - s.block_start >= s.w_size - MIN_LOOKAHEAD) {\n          if (flush_block_only(s, !1), s.strm.avail_out === 0)\n            return BS_NEED_MORE;\n        }\n      }\n      if (s.insert = 0, flush === Z_FINISH) {\n        if (flush_block_only(s, !0), s.strm.avail_out === 0)\n          return BS_FINISH_STARTED;\n        return BS_FINISH_DONE;\n      }\n      if (s.strstart > s.block_start) {\n        if (flush_block_only(s, !1), s.strm.avail_out === 0)\n          return BS_NEED_MORE;\n      }\n      return BS_NEED_MORE;\n    }\n    function deflate_fast(s, flush) {\n      var hash_head, bflush;\n      for (;; ) {\n        if (s.lookahead < MIN_LOOKAHEAD) {\n          if (fill_window(s), s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH)\n            return BS_NEED_MORE;\n          if (s.lookahead === 0)\n            break;\n        }\n        if (hash_head = 0, s.lookahead >= MIN_MATCH)\n          s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask, hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h], s.head[s.ins_h] = s.strstart;\n        if (hash_head !== 0 && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD)\n          s.match_length = longest_match(s, hash_head);\n        if (s.match_length >= MIN_MATCH)\n          if (bflush = trees._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH), s.lookahead -= s.match_length, s.match_length <= s.max_lazy_match && s.lookahead >= MIN_MATCH) {\n            s.match_length--;\n            do\n              s.strstart++, s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask, hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h], s.head[s.ins_h] = s.strstart;\n            while (--s.match_length !== 0);\n            s.strstart++;\n          } else\n            s.strstart += s.match_length, s.match_length = 0, s.ins_h = s.window[s.strstart], s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + 1]) & s.hash_mask;\n        else\n          bflush = trees._tr_tally(s, 0, s.window[s.strstart]), s.lookahead--, s.strstart++;\n        if (bflush) {\n          if (flush_block_only(s, !1), s.strm.avail_out === 0)\n            return BS_NEED_MORE;\n        }\n      }\n      if (s.insert = s.strstart < MIN_MATCH - 1 \? s.strstart : MIN_MATCH - 1, flush === Z_FINISH) {\n        if (flush_block_only(s, !0), s.strm.avail_out === 0)\n          return BS_FINISH_STARTED;\n        return BS_FINISH_DONE;\n      }\n      if (s.last_lit) {\n        if (flush_block_only(s, !1), s.strm.avail_out === 0)\n          return BS_NEED_MORE;\n      }\n      return BS_BLOCK_DONE;\n    }\n    function deflate_slow(s, flush) {\n      var hash_head, bflush, max_insert;\n      for (;; ) {\n        if (s.lookahead < MIN_LOOKAHEAD) {\n          if (fill_window(s), s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH)\n            return BS_NEED_MORE;\n          if (s.lookahead === 0)\n            break;\n        }\n        if (hash_head = 0, s.lookahead >= MIN_MATCH)\n          s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask, hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h], s.head[s.ins_h] = s.strstart;\n        if (s.prev_length = s.match_length, s.prev_match = s.match_start, s.match_length = MIN_MATCH - 1, hash_head !== 0 && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {\n          if (s.match_length = longest_match(s, hash_head), s.match_length <= 5 && (s.strategy === Z_FILTERED || s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096))\n            s.match_length = MIN_MATCH - 1;\n        }\n        if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {\n          max_insert = s.strstart + s.lookahead - MIN_MATCH, bflush = trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH), s.lookahead -= s.prev_length - 1, s.prev_length -= 2;\n          do\n            if (++s.strstart <= max_insert)\n              s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask, hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h], s.head[s.ins_h] = s.strstart;\n          while (--s.prev_length !== 0);\n          if (s.match_available = 0, s.match_length = MIN_MATCH - 1, s.strstart++, bflush) {\n            if (flush_block_only(s, !1), s.strm.avail_out === 0)\n              return BS_NEED_MORE;\n          }\n        } else if (s.match_available) {\n          if (bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]), bflush)\n            flush_block_only(s, !1);\n          if (s.strstart++, s.lookahead--, s.strm.avail_out === 0)\n            return BS_NEED_MORE;\n        } else\n          s.match_available = 1, s.strstart++, s.lookahead--;\n      }\n      if (s.match_available)\n        bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]), s.match_available = 0;\n      if (s.insert = s.strstart < MIN_MATCH - 1 \? s.strstart : MIN_MATCH - 1, flush === Z_FINISH) {\n        if (flush_block_only(s, !0), s.strm.avail_out === 0)\n          return BS_FINISH_STARTED;\n        return BS_FINISH_DONE;\n      }\n      if (s.last_lit) {\n        if (flush_block_only(s, !1), s.strm.avail_out === 0)\n          return BS_NEED_MORE;\n      }\n      return BS_BLOCK_DONE;\n    }\n    function deflate_rle(s, flush) {\n      var bflush, prev, scan, strend, _win = s.window;\n      for (;; ) {\n        if (s.lookahead <= MAX_MATCH) {\n          if (fill_window(s), s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH)\n            return BS_NEED_MORE;\n          if (s.lookahead === 0)\n            break;\n        }\n        if (s.match_length = 0, s.lookahead >= MIN_MATCH && s.strstart > 0) {\n          if (scan = s.strstart - 1, prev = _win[scan], prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {\n            strend = s.strstart + MAX_MATCH;\n            do\n              ;\n            while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);\n            if (s.match_length = MAX_MATCH - (strend - scan), s.match_length > s.lookahead)\n              s.match_length = s.lookahead;\n          }\n        }\n        if (s.match_length >= MIN_MATCH)\n          bflush = trees._tr_tally(s, 1, s.match_length - MIN_MATCH), s.lookahead -= s.match_length, s.strstart += s.match_length, s.match_length = 0;\n        else\n          bflush = trees._tr_tally(s, 0, s.window[s.strstart]), s.lookahead--, s.strstart++;\n        if (bflush) {\n          if (flush_block_only(s, !1), s.strm.avail_out === 0)\n            return BS_NEED_MORE;\n        }\n      }\n      if (s.insert = 0, flush === Z_FINISH) {\n        if (flush_block_only(s, !0), s.strm.avail_out === 0)\n          return BS_FINISH_STARTED;\n        return BS_FINISH_DONE;\n      }\n      if (s.last_lit) {\n        if (flush_block_only(s, !1), s.strm.avail_out === 0)\n          return BS_NEED_MORE;\n      }\n      return BS_BLOCK_DONE;\n    }\n    function deflate_huff(s, flush) {\n      var bflush;\n      for (;; ) {\n        if (s.lookahead === 0) {\n          if (fill_window(s), s.lookahead === 0) {\n            if (flush === Z_NO_FLUSH)\n              return BS_NEED_MORE;\n            break;\n          }\n        }\n        if (s.match_length = 0, bflush = trees._tr_tally(s, 0, s.window[s.strstart]), s.lookahead--, s.strstart++, bflush) {\n          if (flush_block_only(s, !1), s.strm.avail_out === 0)\n            return BS_NEED_MORE;\n        }\n      }\n      if (s.insert = 0, flush === Z_FINISH) {\n        if (flush_block_only(s, !0), s.strm.avail_out === 0)\n          return BS_FINISH_STARTED;\n        return BS_FINISH_DONE;\n      }\n      if (s.last_lit) {\n        if (flush_block_only(s, !1), s.strm.avail_out === 0)\n          return BS_NEED_MORE;\n      }\n      return BS_BLOCK_DONE;\n    }\n    function Config(good_length, max_lazy, nice_length, max_chain, func) {\n      this.good_length = good_length, this.max_lazy = max_lazy, this.nice_length = nice_length, this.max_chain = max_chain, this.func = func;\n    }\n    var configuration_table = [\n      new Config(0, 0, 0, 0, deflate_stored),\n      new Config(4, 4, 8, 4, deflate_fast),\n      new Config(4, 5, 16, 8, deflate_fast),\n      new Config(4, 6, 32, 32, deflate_fast),\n      new Config(4, 4, 16, 16, deflate_slow),\n      new Config(8, 16, 32, 32, deflate_slow),\n      new Config(8, 16, 128, 128, deflate_slow),\n      new Config(8, 32, 128, 256, deflate_slow),\n      new Config(32, 128, 258, 1024, deflate_slow),\n      new Config(32, 258, 258, 4096, deflate_slow)\n    ];\n    function lm_init(s) {\n      s.window_size = 2 * s.w_size, zero(s.head), s.max_lazy_match = configuration_table[s.level].max_lazy, s.good_match = configuration_table[s.level].good_length, s.nice_match = configuration_table[s.level].nice_length, s.max_chain_length = configuration_table[s.level].max_chain, s.strstart = 0, s.block_start = 0, s.lookahead = 0, s.insert = 0, s.match_length = s.prev_length = MIN_MATCH - 1, s.match_available = 0, s.ins_h = 0;\n    }\n    function DeflateState() {\n      this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = Z_DEFLATED, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new utils.Buf16(HEAP_SIZE * 2), this.dyn_dtree = new utils.Buf16((2 * D_CODES + 1) * 2), this.bl_tree = new utils.Buf16((2 * BL_CODES + 1) * 2), zero(this.dyn_ltree), zero(this.dyn_dtree), zero(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new utils.Buf16(MAX_BITS + 1), this.heap = new utils.Buf16(2 * L_CODES + 1), zero(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new utils.Buf16(2 * L_CODES + 1), zero(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;\n    }\n    function deflateResetKeep(strm) {\n      var s;\n      if (!strm || !strm.state)\n        return err(strm, Z_STREAM_ERROR);\n      if (strm.total_in = strm.total_out = 0, strm.data_type = Z_UNKNOWN, s = strm.state, s.pending = 0, s.pending_out = 0, s.wrap < 0)\n        s.wrap = -s.wrap;\n      return s.status = s.wrap \? INIT_STATE : BUSY_STATE, strm.adler = s.wrap === 2 \? 0 : 1, s.last_flush = Z_NO_FLUSH, trees._tr_init(s), Z_OK;\n    }\n    function deflateReset(strm) {\n      var ret = deflateResetKeep(strm);\n      if (ret === Z_OK)\n        lm_init(strm.state);\n      return ret;\n    }\n    function deflateSetHeader(strm, head) {\n      if (!strm || !strm.state)\n        return Z_STREAM_ERROR;\n      if (strm.state.wrap !== 2)\n        return Z_STREAM_ERROR;\n      return strm.state.gzhead = head, Z_OK;\n    }\n    function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {\n      if (!strm)\n        return Z_STREAM_ERROR;\n      var wrap = 1;\n      if (level === Z_DEFAULT_COMPRESSION)\n        level = 6;\n      if (windowBits < 0)\n        wrap = 0, windowBits = -windowBits;\n      else if (windowBits > 15)\n        wrap = 2, windowBits -= 16;\n      if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED)\n        return err(strm, Z_STREAM_ERROR);\n      if (windowBits === 8)\n        windowBits = 9;\n      var s = new DeflateState;\n      return strm.state = s, s.strm = strm, s.wrap = wrap, s.gzhead = null, s.w_bits = windowBits, s.w_size = 1 << s.w_bits, s.w_mask = s.w_size - 1, s.hash_bits = memLevel + 7, s.hash_size = 1 << s.hash_bits, s.hash_mask = s.hash_size - 1, s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH), s.window = new utils.Buf8(s.w_size * 2), s.head = new utils.Buf16(s.hash_size), s.prev = new utils.Buf16(s.w_size), s.lit_bufsize = 1 << memLevel + 6, s.pending_buf_size = s.lit_bufsize * 4, s.pending_buf = new utils.Buf8(s.pending_buf_size), s.d_buf = 1 * s.lit_bufsize, s.l_buf = 3 * s.lit_bufsize, s.level = level, s.strategy = strategy, s.method = method, deflateReset(strm);\n    }\n    function deflateInit(strm, level) {\n      return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);\n    }\n    function deflate(strm, flush) {\n      var old_flush, s, beg, val;\n      if (!strm || !strm.state || flush > Z_BLOCK || flush < 0)\n        return strm \? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;\n      if (s = strm.state, !strm.output || !strm.input && strm.avail_in !== 0 || s.status === FINISH_STATE && flush !== Z_FINISH)\n        return err(strm, strm.avail_out === 0 \? Z_BUF_ERROR : Z_STREAM_ERROR);\n      if (s.strm = strm, old_flush = s.last_flush, s.last_flush = flush, s.status === INIT_STATE)\n        if (s.wrap === 2)\n          if (strm.adler = 0, put_byte(s, 31), put_byte(s, 139), put_byte(s, 8), !s.gzhead)\n            put_byte(s, 0), put_byte(s, 0), put_byte(s, 0), put_byte(s, 0), put_byte(s, 0), put_byte(s, s.level === 9 \? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 \? 4 : 0), put_byte(s, OS_CODE), s.status = BUSY_STATE;\n          else {\n            if (put_byte(s, (s.gzhead.text \? 1 : 0) + (s.gzhead.hcrc \? 2 : 0) + (!s.gzhead.extra \? 0 : 4) + (!s.gzhead.name \? 0 : 8) + (!s.gzhead.comment \? 0 : 16)), put_byte(s, s.gzhead.time & 255), put_byte(s, s.gzhead.time >> 8 & 255), put_byte(s, s.gzhead.time >> 16 & 255), put_byte(s, s.gzhead.time >> 24 & 255), put_byte(s, s.level === 9 \? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 \? 4 : 0), put_byte(s, s.gzhead.os & 255), s.gzhead.extra && s.gzhead.extra.length)\n              put_byte(s, s.gzhead.extra.length & 255), put_byte(s, s.gzhead.extra.length >> 8 & 255);\n            if (s.gzhead.hcrc)\n              strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);\n            s.gzindex = 0, s.status = EXTRA_STATE;\n          }\n        else {\n          var header = Z_DEFLATED + (s.w_bits - 8 << 4) << 8, level_flags = -1;\n          if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2)\n            level_flags = 0;\n          else if (s.level < 6)\n            level_flags = 1;\n          else if (s.level === 6)\n            level_flags = 2;\n          else\n            level_flags = 3;\n          if (header |= level_flags << 6, s.strstart !== 0)\n            header |= PRESET_DICT;\n          if (header += 31 - header % 31, s.status = BUSY_STATE, putShortMSB(s, header), s.strstart !== 0)\n            putShortMSB(s, strm.adler >>> 16), putShortMSB(s, strm.adler & 65535);\n          strm.adler = 1;\n        }\n      if (s.status === EXTRA_STATE)\n        if (s.gzhead.extra) {\n          beg = s.pending;\n          while (s.gzindex < (s.gzhead.extra.length & 65535)) {\n            if (s.pending === s.pending_buf_size) {\n              if (s.gzhead.hcrc && s.pending > beg)\n                strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n              if (flush_pending(strm), beg = s.pending, s.pending === s.pending_buf_size)\n                break;\n            }\n            put_byte(s, s.gzhead.extra[s.gzindex] & 255), s.gzindex++;\n          }\n          if (s.gzhead.hcrc && s.pending > beg)\n            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n          if (s.gzindex === s.gzhead.extra.length)\n            s.gzindex = 0, s.status = NAME_STATE;\n        } else\n          s.status = NAME_STATE;\n      if (s.status === NAME_STATE)\n        if (s.gzhead.name) {\n          beg = s.pending;\n          do {\n            if (s.pending === s.pending_buf_size) {\n              if (s.gzhead.hcrc && s.pending > beg)\n                strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n              if (flush_pending(strm), beg = s.pending, s.pending === s.pending_buf_size) {\n                val = 1;\n                break;\n              }\n            }\n            if (s.gzindex < s.gzhead.name.length)\n              val = s.gzhead.name.charCodeAt(s.gzindex++) & 255;\n            else\n              val = 0;\n            put_byte(s, val);\n          } while (val !== 0);\n          if (s.gzhead.hcrc && s.pending > beg)\n            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n          if (val === 0)\n            s.gzindex = 0, s.status = COMMENT_STATE;\n        } else\n          s.status = COMMENT_STATE;\n      if (s.status === COMMENT_STATE)\n        if (s.gzhead.comment) {\n          beg = s.pending;\n          do {\n            if (s.pending === s.pending_buf_size) {\n              if (s.gzhead.hcrc && s.pending > beg)\n                strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n              if (flush_pending(strm), beg = s.pending, s.pending === s.pending_buf_size) {\n                val = 1;\n                break;\n              }\n            }\n            if (s.gzindex < s.gzhead.comment.length)\n              val = s.gzhead.comment.charCodeAt(s.gzindex++) & 255;\n            else\n              val = 0;\n            put_byte(s, val);\n          } while (val !== 0);\n          if (s.gzhead.hcrc && s.pending > beg)\n            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n          if (val === 0)\n            s.status = HCRC_STATE;\n        } else\n          s.status = HCRC_STATE;\n      if (s.status === HCRC_STATE)\n        if (s.gzhead.hcrc) {\n          if (s.pending + 2 > s.pending_buf_size)\n            flush_pending(strm);\n          if (s.pending + 2 <= s.pending_buf_size)\n            put_byte(s, strm.adler & 255), put_byte(s, strm.adler >> 8 & 255), strm.adler = 0, s.status = BUSY_STATE;\n        } else\n          s.status = BUSY_STATE;\n      if (s.pending !== 0) {\n        if (flush_pending(strm), strm.avail_out === 0)\n          return s.last_flush = -1, Z_OK;\n      } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH)\n        return err(strm, Z_BUF_ERROR);\n      if (s.status === FINISH_STATE && strm.avail_in !== 0)\n        return err(strm, Z_BUF_ERROR);\n      if (strm.avail_in !== 0 || s.lookahead !== 0 || flush !== Z_NO_FLUSH && s.status !== FINISH_STATE) {\n        var bstate = s.strategy === Z_HUFFMAN_ONLY \? deflate_huff(s, flush) : s.strategy === Z_RLE \? deflate_rle(s, flush) : configuration_table[s.level].func(s, flush);\n        if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE)\n          s.status = FINISH_STATE;\n        if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {\n          if (strm.avail_out === 0)\n            s.last_flush = -1;\n          return Z_OK;\n        }\n        if (bstate === BS_BLOCK_DONE) {\n          if (flush === Z_PARTIAL_FLUSH)\n            trees._tr_align(s);\n          else if (flush !== Z_BLOCK) {\n            if (trees._tr_stored_block(s, 0, 0, !1), flush === Z_FULL_FLUSH) {\n              if (zero(s.head), s.lookahead === 0)\n                s.strstart = 0, s.block_start = 0, s.insert = 0;\n            }\n          }\n          if (flush_pending(strm), strm.avail_out === 0)\n            return s.last_flush = -1, Z_OK;\n        }\n      }\n      if (flush !== Z_FINISH)\n        return Z_OK;\n      if (s.wrap <= 0)\n        return Z_STREAM_END;\n      if (s.wrap === 2)\n        put_byte(s, strm.adler & 255), put_byte(s, strm.adler >> 8 & 255), put_byte(s, strm.adler >> 16 & 255), put_byte(s, strm.adler >> 24 & 255), put_byte(s, strm.total_in & 255), put_byte(s, strm.total_in >> 8 & 255), put_byte(s, strm.total_in >> 16 & 255), put_byte(s, strm.total_in >> 24 & 255);\n      else\n        putShortMSB(s, strm.adler >>> 16), putShortMSB(s, strm.adler & 65535);\n      if (flush_pending(strm), s.wrap > 0)\n        s.wrap = -s.wrap;\n      return s.pending !== 0 \? Z_OK : Z_STREAM_END;\n    }\n    function deflateEnd(strm) {\n      var status;\n      if (!strm || !strm.state)\n        return Z_STREAM_ERROR;\n      if (status = strm.state.status, status !== INIT_STATE && status !== EXTRA_STATE && status !== NAME_STATE && status !== COMMENT_STATE && status !== HCRC_STATE && status !== BUSY_STATE && status !== FINISH_STATE)\n        return err(strm, Z_STREAM_ERROR);\n      return strm.state = null, status === BUSY_STATE \? err(strm, Z_DATA_ERROR) : Z_OK;\n    }\n    function deflateSetDictionary(strm, dictionary) {\n      var dictLength = dictionary.length, s, str, n, wrap, avail, next, input, tmpDict;\n      if (!strm || !strm.state)\n        return Z_STREAM_ERROR;\n      if (s = strm.state, wrap = s.wrap, wrap === 2 || wrap === 1 && s.status !== INIT_STATE || s.lookahead)\n        return Z_STREAM_ERROR;\n      if (wrap === 1)\n        strm.adler = adler32(strm.adler, dictionary, dictLength, 0);\n      if (s.wrap = 0, dictLength >= s.w_size) {\n        if (wrap === 0)\n          zero(s.head), s.strstart = 0, s.block_start = 0, s.insert = 0;\n        tmpDict = new utils.Buf8(s.w_size), utils.arraySet(tmpDict, dictionary, dictLength - s.w_size, s.w_size, 0), dictionary = tmpDict, dictLength = s.w_size;\n      }\n      avail = strm.avail_in, next = strm.next_in, input = strm.input, strm.avail_in = dictLength, strm.next_in = 0, strm.input = dictionary, fill_window(s);\n      while (s.lookahead >= MIN_MATCH) {\n        str = s.strstart, n = s.lookahead - (MIN_MATCH - 1);\n        do\n          s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask, s.prev[str & s.w_mask] = s.head[s.ins_h], s.head[s.ins_h] = str, str++;\n        while (--n);\n        s.strstart = str, s.lookahead = MIN_MATCH - 1, fill_window(s);\n      }\n      return s.strstart += s.lookahead, s.block_start = s.strstart, s.insert = s.lookahead, s.lookahead = 0, s.match_length = s.prev_length = MIN_MATCH - 1, s.match_available = 0, strm.next_in = next, strm.input = input, strm.avail_in = avail, s.wrap = wrap, Z_OK;\n    }\n    exports.deflateInit = deflateInit, exports.deflateInit2 = deflateInit2, exports.deflateReset = deflateReset, exports.deflateResetKeep = deflateResetKeep, exports.deflateSetHeader = deflateSetHeader, exports.deflate = deflate, exports.deflateEnd = deflateEnd, exports.deflateSetDictionary = deflateSetDictionary, exports.deflateInfo = \"pako deflate (from Nodeca project)\";\n  }\n}), require_inffast = __commonJS({\n  \"node_modules/pako/lib/zlib/inffast.js\"(exports, module2) {\n    var BAD = 30, TYPE = 12;\n    module2.exports = function inflate_fast(strm, start) {\n      var state, _in, last, _out, beg, end, dmax, wsize, whave, wnext, s_window, hold, bits, lcode, dcode, lmask, dmask, here, op, len, dist, from, from_source, input, output;\n      state = strm.state, _in = strm.next_in, input = strm.input, last = _in + (strm.avail_in - 5), _out = strm.next_out, output = strm.output, beg = _out - (start - strm.avail_out), end = _out + (strm.avail_out - 257), dmax = state.dmax, wsize = state.wsize, whave = state.whave, wnext = state.wnext, s_window = state.window, hold = state.hold, bits = state.bits, lcode = state.lencode, dcode = state.distcode, lmask = (1 << state.lenbits) - 1, dmask = (1 << state.distbits) - 1;\n      top:\n        do {\n          if (bits < 15)\n            hold += input[_in++] << bits, bits += 8, hold += input[_in++] << bits, bits += 8;\n          here = lcode[hold & lmask];\n          dolen:\n            for (;; ) {\n              if (op = here >>> 24, hold >>>= op, bits -= op, op = here >>> 16 & 255, op === 0)\n                output[_out++] = here & 65535;\n              else if (op & 16) {\n                if (len = here & 65535, op &= 15, op) {\n                  if (bits < op)\n                    hold += input[_in++] << bits, bits += 8;\n                  len += hold & (1 << op) - 1, hold >>>= op, bits -= op;\n                }\n                if (bits < 15)\n                  hold += input[_in++] << bits, bits += 8, hold += input[_in++] << bits, bits += 8;\n                here = dcode[hold & dmask];\n                dodist:\n                  for (;; ) {\n                    if (op = here >>> 24, hold >>>= op, bits -= op, op = here >>> 16 & 255, op & 16) {\n                      if (dist = here & 65535, op &= 15, bits < op) {\n                        if (hold += input[_in++] << bits, bits += 8, bits < op)\n                          hold += input[_in++] << bits, bits += 8;\n                      }\n                      if (dist += hold & (1 << op) - 1, dist > dmax) {\n                        strm.msg = \"invalid distance too far back\", state.mode = BAD;\n                        break top;\n                      }\n                      if (hold >>>= op, bits -= op, op = _out - beg, dist > op) {\n                        if (op = dist - op, op > whave) {\n                          if (state.sane) {\n                            strm.msg = \"invalid distance too far back\", state.mode = BAD;\n                            break top;\n                          }\n                        }\n                        if (from = 0, from_source = s_window, wnext === 0) {\n                          if (from += wsize - op, op < len) {\n                            len -= op;\n                            do\n                              output[_out++] = s_window[from++];\n                            while (--op);\n                            from = _out - dist, from_source = output;\n                          }\n                        } else if (wnext < op) {\n                          if (from += wsize + wnext - op, op -= wnext, op < len) {\n                            len -= op;\n                            do\n                              output[_out++] = s_window[from++];\n                            while (--op);\n                            if (from = 0, wnext < len) {\n                              op = wnext, len -= op;\n                              do\n                                output[_out++] = s_window[from++];\n                              while (--op);\n                              from = _out - dist, from_source = output;\n                            }\n                          }\n                        } else if (from += wnext - op, op < len) {\n                          len -= op;\n                          do\n                            output[_out++] = s_window[from++];\n                          while (--op);\n                          from = _out - dist, from_source = output;\n                        }\n                        while (len > 2)\n                          output[_out++] = from_source[from++], output[_out++] = from_source[from++], output[_out++] = from_source[from++], len -= 3;\n                        if (len) {\n                          if (output[_out++] = from_source[from++], len > 1)\n                            output[_out++] = from_source[from++];\n                        }\n                      } else {\n                        from = _out - dist;\n                        do\n                          output[_out++] = output[from++], output[_out++] = output[from++], output[_out++] = output[from++], len -= 3;\n                        while (len > 2);\n                        if (len) {\n                          if (output[_out++] = output[from++], len > 1)\n                            output[_out++] = output[from++];\n                        }\n                      }\n                    } else if ((op & 64) === 0) {\n                      here = dcode[(here & 65535) + (hold & (1 << op) - 1)];\n                      continue dodist;\n                    } else {\n                      strm.msg = \"invalid distance code\", state.mode = BAD;\n                      break top;\n                    }\n                    break;\n                  }\n              } else if ((op & 64) === 0) {\n                here = lcode[(here & 65535) + (hold & (1 << op) - 1)];\n                continue dolen;\n              } else if (op & 32) {\n                state.mode = TYPE;\n                break top;\n              } else {\n                strm.msg = \"invalid literal/length code\", state.mode = BAD;\n                break top;\n              }\n              break;\n            }\n        } while (_in < last && _out < end);\n      len = bits >> 3, _in -= len, bits -= len << 3, hold &= (1 << bits) - 1, strm.next_in = _in, strm.next_out = _out, strm.avail_in = _in < last \? 5 + (last - _in) : 5 - (_in - last), strm.avail_out = _out < end \? 257 + (end - _out) : 257 - (_out - end), state.hold = hold, state.bits = bits;\n      return;\n    };\n  }\n}), require_inftrees = __commonJS({\n  \"node_modules/pako/lib/zlib/inftrees.js\"(exports, module2) {\n    var utils = require_common(), MAXBITS = 15, ENOUGH_LENS = 852, ENOUGH_DISTS = 592, CODES = 0, LENS = 1, DISTS = 2, lbase = [\n      3,\n      4,\n      5,\n      6,\n      7,\n      8,\n      9,\n      10,\n      11,\n      13,\n      15,\n      17,\n      19,\n      23,\n      27,\n      31,\n      35,\n      43,\n      51,\n      59,\n      67,\n      83,\n      99,\n      115,\n      131,\n      163,\n      195,\n      227,\n      258,\n      0,\n      0\n    ], lext = [\n      16,\n      16,\n      16,\n      16,\n      16,\n      16,\n      16,\n      16,\n      17,\n      17,\n      17,\n      17,\n      18,\n      18,\n      18,\n      18,\n      19,\n      19,\n      19,\n      19,\n      20,\n      20,\n      20,\n      20,\n      21,\n      21,\n      21,\n      21,\n      16,\n      72,\n      78\n    ], dbase = [\n      1,\n      2,\n      3,\n      4,\n      5,\n      7,\n      9,\n      13,\n      17,\n      25,\n      33,\n      49,\n      65,\n      97,\n      129,\n      193,\n      257,\n      385,\n      513,\n      769,\n      1025,\n      1537,\n      2049,\n      3073,\n      4097,\n      6145,\n      8193,\n      12289,\n      16385,\n      24577,\n      0,\n      0\n    ], dext = [\n      16,\n      16,\n      16,\n      16,\n      17,\n      17,\n      18,\n      18,\n      19,\n      19,\n      20,\n      20,\n      21,\n      21,\n      22,\n      22,\n      23,\n      23,\n      24,\n      24,\n      25,\n      25,\n      26,\n      26,\n      27,\n      27,\n      28,\n      28,\n      29,\n      29,\n      64,\n      64\n    ];\n    module2.exports = function inflate_table(type, lens, lens_index, codes, table, table_index, work, opts) {\n      var bits = opts.bits, len = 0, sym = 0, min = 0, max = 0, root = 0, curr = 0, drop = 0, left = 0, used = 0, huff = 0, incr, fill, low, mask, next, base = null, base_index = 0, end, count = new utils.Buf16(MAXBITS + 1), offs = new utils.Buf16(MAXBITS + 1), extra = null, extra_index = 0, here_bits, here_op, here_val;\n      for (len = 0;len <= MAXBITS; len++)\n        count[len] = 0;\n      for (sym = 0;sym < codes; sym++)\n        count[lens[lens_index + sym]]++;\n      root = bits;\n      for (max = MAXBITS;max >= 1; max--)\n        if (count[max] !== 0)\n          break;\n      if (root > max)\n        root = max;\n      if (max === 0)\n        return table[table_index++] = 1 << 24 | 64 << 16 | 0, table[table_index++] = 1 << 24 | 64 << 16 | 0, opts.bits = 1, 0;\n      for (min = 1;min < max; min++)\n        if (count[min] !== 0)\n          break;\n      if (root < min)\n        root = min;\n      left = 1;\n      for (len = 1;len <= MAXBITS; len++)\n        if (left <<= 1, left -= count[len], left < 0)\n          return -1;\n      if (left > 0 && (type === CODES || max !== 1))\n        return -1;\n      offs[1] = 0;\n      for (len = 1;len < MAXBITS; len++)\n        offs[len + 1] = offs[len] + count[len];\n      for (sym = 0;sym < codes; sym++)\n        if (lens[lens_index + sym] !== 0)\n          work[offs[lens[lens_index + sym]]++] = sym;\n      if (type === CODES)\n        base = extra = work, end = 19;\n      else if (type === LENS)\n        base = lbase, base_index -= 257, extra = lext, extra_index -= 257, end = 256;\n      else\n        base = dbase, extra = dext, end = -1;\n      if (huff = 0, sym = 0, len = min, next = table_index, curr = root, drop = 0, low = -1, used = 1 << root, mask = used - 1, type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS)\n        return 1;\n      for (;; ) {\n        if (here_bits = len - drop, work[sym] < end)\n          here_op = 0, here_val = work[sym];\n        else if (work[sym] > end)\n          here_op = extra[extra_index + work[sym]], here_val = base[base_index + work[sym]];\n        else\n          here_op = 96, here_val = 0;\n        incr = 1 << len - drop, fill = 1 << curr, min = fill;\n        do\n          fill -= incr, table[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;\n        while (fill !== 0);\n        incr = 1 << len - 1;\n        while (huff & incr)\n          incr >>= 1;\n        if (incr !== 0)\n          huff &= incr - 1, huff += incr;\n        else\n          huff = 0;\n        if (sym++, --count[len] === 0) {\n          if (len === max)\n            break;\n          len = lens[lens_index + work[sym]];\n        }\n        if (len > root && (huff & mask) !== low) {\n          if (drop === 0)\n            drop = root;\n          next += min, curr = len - drop, left = 1 << curr;\n          while (curr + drop < max) {\n            if (left -= count[curr + drop], left <= 0)\n              break;\n            curr++, left <<= 1;\n          }\n          if (used += 1 << curr, type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS)\n            return 1;\n          low = huff & mask, table[low] = root << 24 | curr << 16 | next - table_index | 0;\n        }\n      }\n      if (huff !== 0)\n        table[next + huff] = len - drop << 24 | 64 << 16 | 0;\n      return opts.bits = root, 0;\n    };\n  }\n}), require_inflate = __commonJS({\n  \"node_modules/pako/lib/zlib/inflate.js\"(exports) {\n    var utils = require_common(), adler32 = require_adler32(), crc32 = require_crc32(), inflate_fast = require_inffast(), inflate_table = require_inftrees(), CODES = 0, LENS = 1, DISTS = 2, Z_FINISH = 4, Z_BLOCK = 5, Z_TREES = 6, Z_OK = 0, Z_STREAM_END = 1, Z_NEED_DICT = 2, Z_STREAM_ERROR = -2, Z_DATA_ERROR = -3, Z_MEM_ERROR = -4, Z_BUF_ERROR = -5, Z_DEFLATED = 8, HEAD = 1, FLAGS = 2, TIME = 3, OS = 4, EXLEN = 5, EXTRA = 6, NAME = 7, COMMENT = 8, HCRC = 9, DICTID = 10, DICT = 11, TYPE = 12, TYPEDO = 13, STORED = 14, COPY_ = 15, COPY = 16, TABLE = 17, LENLENS = 18, CODELENS = 19, LEN_ = 20, LEN = 21, LENEXT = 22, DIST = 23, DISTEXT = 24, MATCH = 25, LIT = 26, CHECK = 27, LENGTH = 28, DONE = 29, BAD = 30, MEM = 31, SYNC = 32, ENOUGH_LENS = 852, ENOUGH_DISTS = 592, MAX_WBITS = 15, DEF_WBITS = MAX_WBITS;\n    function zswap32(q) {\n      return (q >>> 24 & 255) + (q >>> 8 & 65280) + ((q & 65280) << 8) + ((q & 255) << 24);\n    }\n    function InflateState() {\n      this.mode = 0, this.last = !1, this.wrap = 0, this.havedict = !1, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new utils.Buf16(320), this.work = new utils.Buf16(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;\n    }\n    function inflateResetKeep(strm) {\n      var state;\n      if (!strm || !strm.state)\n        return Z_STREAM_ERROR;\n      if (state = strm.state, strm.total_in = strm.total_out = state.total = 0, strm.msg = \"\", state.wrap)\n        strm.adler = state.wrap & 1;\n      return state.mode = HEAD, state.last = 0, state.havedict = 0, state.dmax = 32768, state.head = null, state.hold = 0, state.bits = 0, state.lencode = state.lendyn = new utils.Buf32(ENOUGH_LENS), state.distcode = state.distdyn = new utils.Buf32(ENOUGH_DISTS), state.sane = 1, state.back = -1, Z_OK;\n    }\n    function inflateReset(strm) {\n      var state;\n      if (!strm || !strm.state)\n        return Z_STREAM_ERROR;\n      return state = strm.state, state.wsize = 0, state.whave = 0, state.wnext = 0, inflateResetKeep(strm);\n    }\n    function inflateReset2(strm, windowBits) {\n      var wrap, state;\n      if (!strm || !strm.state)\n        return Z_STREAM_ERROR;\n      if (state = strm.state, windowBits < 0)\n        wrap = 0, windowBits = -windowBits;\n      else if (wrap = (windowBits >> 4) + 1, windowBits < 48)\n        windowBits &= 15;\n      if (windowBits && (windowBits < 8 || windowBits > 15))\n        return Z_STREAM_ERROR;\n      if (state.window !== null && state.wbits !== windowBits)\n        state.window = null;\n      return state.wrap = wrap, state.wbits = windowBits, inflateReset(strm);\n    }\n    function inflateInit2(strm, windowBits) {\n      var ret, state;\n      if (!strm)\n        return Z_STREAM_ERROR;\n      if (state = new InflateState, strm.state = state, state.window = null, ret = inflateReset2(strm, windowBits), ret !== Z_OK)\n        strm.state = null;\n      return ret;\n    }\n    function inflateInit(strm) {\n      return inflateInit2(strm, DEF_WBITS);\n    }\n    var virgin = !0, lenfix, distfix;\n    function fixedtables(state) {\n      if (virgin) {\n        var sym;\n        lenfix = new utils.Buf32(512), distfix = new utils.Buf32(32), sym = 0;\n        while (sym < 144)\n          state.lens[sym++] = 8;\n        while (sym < 256)\n          state.lens[sym++] = 9;\n        while (sym < 280)\n          state.lens[sym++] = 7;\n        while (sym < 288)\n          state.lens[sym++] = 8;\n        inflate_table(LENS, state.lens, 0, 288, lenfix, 0, state.work, {\n          bits: 9\n        }), sym = 0;\n        while (sym < 32)\n          state.lens[sym++] = 5;\n        inflate_table(DISTS, state.lens, 0, 32, distfix, 0, state.work, {\n          bits: 5\n        }), virgin = !1;\n      }\n      state.lencode = lenfix, state.lenbits = 9, state.distcode = distfix, state.distbits = 5;\n    }\n    function updatewindow(strm, src, end, copy) {\n      var dist, state = strm.state;\n      if (state.window === null)\n        state.wsize = 1 << state.wbits, state.wnext = 0, state.whave = 0, state.window = new utils.Buf8(state.wsize);\n      if (copy >= state.wsize)\n        utils.arraySet(state.window, src, end - state.wsize, state.wsize, 0), state.wnext = 0, state.whave = state.wsize;\n      else {\n        if (dist = state.wsize - state.wnext, dist > copy)\n          dist = copy;\n        if (utils.arraySet(state.window, src, end - copy, dist, state.wnext), copy -= dist, copy)\n          utils.arraySet(state.window, src, end - copy, copy, 0), state.wnext = copy, state.whave = state.wsize;\n        else {\n          if (state.wnext += dist, state.wnext === state.wsize)\n            state.wnext = 0;\n          if (state.whave < state.wsize)\n            state.whave += dist;\n        }\n      }\n      return 0;\n    }\n    function inflate(strm, flush) {\n      var state, input, output, next, put, have, left, hold, bits, _in, _out, copy, from, from_source, here = 0, here_bits, here_op, here_val, last_bits, last_op, last_val, len, ret, hbuf = new utils.Buf8(4), opts, n, order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];\n      if (!strm || !strm.state || !strm.output || !strm.input && strm.avail_in !== 0)\n        return Z_STREAM_ERROR;\n      if (state = strm.state, state.mode === TYPE)\n        state.mode = TYPEDO;\n      put = strm.next_out, output = strm.output, left = strm.avail_out, next = strm.next_in, input = strm.input, have = strm.avail_in, hold = state.hold, bits = state.bits, _in = have, _out = left, ret = Z_OK;\n      inf_leave:\n        for (;; )\n          switch (state.mode) {\n            case HEAD:\n              if (state.wrap === 0) {\n                state.mode = TYPEDO;\n                break;\n              }\n              while (bits < 16) {\n                if (have === 0)\n                  break inf_leave;\n                have--, hold += input[next++] << bits, bits += 8;\n              }\n              if (state.wrap & 2 && hold === 35615) {\n                state.check = 0, hbuf[0] = hold & 255, hbuf[1] = hold >>> 8 & 255, state.check = crc32(state.check, hbuf, 2, 0), hold = 0, bits = 0, state.mode = FLAGS;\n                break;\n              }\n              if (state.flags = 0, state.head)\n                state.head.done = !1;\n              if (!(state.wrap & 1) || (((hold & 255) << 8) + (hold >> 8)) % 31) {\n                strm.msg = \"incorrect header check\", state.mode = BAD;\n                break;\n              }\n              if ((hold & 15) !== Z_DEFLATED) {\n                strm.msg = \"unknown compression method\", state.mode = BAD;\n                break;\n              }\n              if (hold >>>= 4, bits -= 4, len = (hold & 15) + 8, state.wbits === 0)\n                state.wbits = len;\n              else if (len > state.wbits) {\n                strm.msg = \"invalid window size\", state.mode = BAD;\n                break;\n              }\n              state.dmax = 1 << len, strm.adler = state.check = 1, state.mode = hold & 512 \? DICTID : TYPE, hold = 0, bits = 0;\n              break;\n            case FLAGS:\n              while (bits < 16) {\n                if (have === 0)\n                  break inf_leave;\n                have--, hold += input[next++] << bits, bits += 8;\n              }\n              if (state.flags = hold, (state.flags & 255) !== Z_DEFLATED) {\n                strm.msg = \"unknown compression method\", state.mode = BAD;\n                break;\n              }\n              if (state.flags & 57344) {\n                strm.msg = \"unknown header flags set\", state.mode = BAD;\n                break;\n              }\n              if (state.head)\n                state.head.text = hold >> 8 & 1;\n              if (state.flags & 512)\n                hbuf[0] = hold & 255, hbuf[1] = hold >>> 8 & 255, state.check = crc32(state.check, hbuf, 2, 0);\n              hold = 0, bits = 0, state.mode = TIME;\n            case TIME:\n              while (bits < 32) {\n                if (have === 0)\n                  break inf_leave;\n                have--, hold += input[next++] << bits, bits += 8;\n              }\n              if (state.head)\n                state.head.time = hold;\n              if (state.flags & 512)\n                hbuf[0] = hold & 255, hbuf[1] = hold >>> 8 & 255, hbuf[2] = hold >>> 16 & 255, hbuf[3] = hold >>> 24 & 255, state.check = crc32(state.check, hbuf, 4, 0);\n              hold = 0, bits = 0, state.mode = OS;\n            case OS:\n              while (bits < 16) {\n                if (have === 0)\n                  break inf_leave;\n                have--, hold += input[next++] << bits, bits += 8;\n              }\n              if (state.head)\n                state.head.xflags = hold & 255, state.head.os = hold >> 8;\n              if (state.flags & 512)\n                hbuf[0] = hold & 255, hbuf[1] = hold >>> 8 & 255, state.check = crc32(state.check, hbuf, 2, 0);\n              hold = 0, bits = 0, state.mode = EXLEN;\n            case EXLEN:\n              if (state.flags & 1024) {\n                while (bits < 16) {\n                  if (have === 0)\n                    break inf_leave;\n                  have--, hold += input[next++] << bits, bits += 8;\n                }\n                if (state.length = hold, state.head)\n                  state.head.extra_len = hold;\n                if (state.flags & 512)\n                  hbuf[0] = hold & 255, hbuf[1] = hold >>> 8 & 255, state.check = crc32(state.check, hbuf, 2, 0);\n                hold = 0, bits = 0;\n              } else if (state.head)\n                state.head.extra = null;\n              state.mode = EXTRA;\n            case EXTRA:\n              if (state.flags & 1024) {\n                if (copy = state.length, copy > have)\n                  copy = have;\n                if (copy) {\n                  if (state.head) {\n                    if (len = state.head.extra_len - state.length, !state.head.extra)\n                      state.head.extra = new Array(state.head.extra_len);\n                    utils.arraySet(state.head.extra, input, next, copy, len);\n                  }\n                  if (state.flags & 512)\n                    state.check = crc32(state.check, input, copy, next);\n                  have -= copy, next += copy, state.length -= copy;\n                }\n                if (state.length)\n                  break inf_leave;\n              }\n              state.length = 0, state.mode = NAME;\n            case NAME:\n              if (state.flags & 2048) {\n                if (have === 0)\n                  break inf_leave;\n                copy = 0;\n                do\n                  if (len = input[next + copy++], state.head && len && state.length < 65536)\n                    state.head.name += String.fromCharCode(len);\n                while (len && copy < have);\n                if (state.flags & 512)\n                  state.check = crc32(state.check, input, copy, next);\n                if (have -= copy, next += copy, len)\n                  break inf_leave;\n              } else if (state.head)\n                state.head.name = null;\n              state.length = 0, state.mode = COMMENT;\n            case COMMENT:\n              if (state.flags & 4096) {\n                if (have === 0)\n                  break inf_leave;\n                copy = 0;\n                do\n                  if (len = input[next + copy++], state.head && len && state.length < 65536)\n                    state.head.comment += String.fromCharCode(len);\n                while (len && copy < have);\n                if (state.flags & 512)\n                  state.check = crc32(state.check, input, copy, next);\n                if (have -= copy, next += copy, len)\n                  break inf_leave;\n              } else if (state.head)\n                state.head.comment = null;\n              state.mode = HCRC;\n            case HCRC:\n              if (state.flags & 512) {\n                while (bits < 16) {\n                  if (have === 0)\n                    break inf_leave;\n                  have--, hold += input[next++] << bits, bits += 8;\n                }\n                if (hold !== (state.check & 65535)) {\n                  strm.msg = \"header crc mismatch\", state.mode = BAD;\n                  break;\n                }\n                hold = 0, bits = 0;\n              }\n              if (state.head)\n                state.head.hcrc = state.flags >> 9 & 1, state.head.done = !0;\n              strm.adler = state.check = 0, state.mode = TYPE;\n              break;\n            case DICTID:\n              while (bits < 32) {\n                if (have === 0)\n                  break inf_leave;\n                have--, hold += input[next++] << bits, bits += 8;\n              }\n              strm.adler = state.check = zswap32(hold), hold = 0, bits = 0, state.mode = DICT;\n            case DICT:\n              if (state.havedict === 0)\n                return strm.next_out = put, strm.avail_out = left, strm.next_in = next, strm.avail_in = have, state.hold = hold, state.bits = bits, Z_NEED_DICT;\n              strm.adler = state.check = 1, state.mode = TYPE;\n            case TYPE:\n              if (flush === Z_BLOCK || flush === Z_TREES)\n                break inf_leave;\n            case TYPEDO:\n              if (state.last) {\n                hold >>>= bits & 7, bits -= bits & 7, state.mode = CHECK;\n                break;\n              }\n              while (bits < 3) {\n                if (have === 0)\n                  break inf_leave;\n                have--, hold += input[next++] << bits, bits += 8;\n              }\n              switch (state.last = hold & 1, hold >>>= 1, bits -= 1, hold & 3) {\n                case 0:\n                  state.mode = STORED;\n                  break;\n                case 1:\n                  if (fixedtables(state), state.mode = LEN_, flush === Z_TREES) {\n                    hold >>>= 2, bits -= 2;\n                    break inf_leave;\n                  }\n                  break;\n                case 2:\n                  state.mode = TABLE;\n                  break;\n                case 3:\n                  strm.msg = \"invalid block type\", state.mode = BAD;\n              }\n              hold >>>= 2, bits -= 2;\n              break;\n            case STORED:\n              hold >>>= bits & 7, bits -= bits & 7;\n              while (bits < 32) {\n                if (have === 0)\n                  break inf_leave;\n                have--, hold += input[next++] << bits, bits += 8;\n              }\n              if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {\n                strm.msg = \"invalid stored block lengths\", state.mode = BAD;\n                break;\n              }\n              if (state.length = hold & 65535, hold = 0, bits = 0, state.mode = COPY_, flush === Z_TREES)\n                break inf_leave;\n            case COPY_:\n              state.mode = COPY;\n            case COPY:\n              if (copy = state.length, copy) {\n                if (copy > have)\n                  copy = have;\n                if (copy > left)\n                  copy = left;\n                if (copy === 0)\n                  break inf_leave;\n                utils.arraySet(output, input, next, copy, put), have -= copy, next += copy, left -= copy, put += copy, state.length -= copy;\n                break;\n              }\n              state.mode = TYPE;\n              break;\n            case TABLE:\n              while (bits < 14) {\n                if (have === 0)\n                  break inf_leave;\n                have--, hold += input[next++] << bits, bits += 8;\n              }\n              if (state.nlen = (hold & 31) + 257, hold >>>= 5, bits -= 5, state.ndist = (hold & 31) + 1, hold >>>= 5, bits -= 5, state.ncode = (hold & 15) + 4, hold >>>= 4, bits -= 4, state.nlen > 286 || state.ndist > 30) {\n                strm.msg = \"too many length or distance symbols\", state.mode = BAD;\n                break;\n              }\n              state.have = 0, state.mode = LENLENS;\n            case LENLENS:\n              while (state.have < state.ncode) {\n                while (bits < 3) {\n                  if (have === 0)\n                    break inf_leave;\n                  have--, hold += input[next++] << bits, bits += 8;\n                }\n                state.lens[order[state.have++]] = hold & 7, hold >>>= 3, bits -= 3;\n              }\n              while (state.have < 19)\n                state.lens[order[state.have++]] = 0;\n              if (state.lencode = state.lendyn, state.lenbits = 7, opts = { bits: state.lenbits }, ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts), state.lenbits = opts.bits, ret) {\n                strm.msg = \"invalid code lengths set\", state.mode = BAD;\n                break;\n              }\n              state.have = 0, state.mode = CODELENS;\n            case CODELENS:\n              while (state.have < state.nlen + state.ndist) {\n                for (;; ) {\n                  if (here = state.lencode[hold & (1 << state.lenbits) - 1], here_bits = here >>> 24, here_op = here >>> 16 & 255, here_val = here & 65535, here_bits <= bits)\n                    break;\n                  if (have === 0)\n                    break inf_leave;\n                  have--, hold += input[next++] << bits, bits += 8;\n                }\n                if (here_val < 16)\n                  hold >>>= here_bits, bits -= here_bits, state.lens[state.have++] = here_val;\n                else {\n                  if (here_val === 16) {\n                    n = here_bits + 2;\n                    while (bits < n) {\n                      if (have === 0)\n                        break inf_leave;\n                      have--, hold += input[next++] << bits, bits += 8;\n                    }\n                    if (hold >>>= here_bits, bits -= here_bits, state.have === 0) {\n                      strm.msg = \"invalid bit length repeat\", state.mode = BAD;\n                      break;\n                    }\n                    len = state.lens[state.have - 1], copy = 3 + (hold & 3), hold >>>= 2, bits -= 2;\n                  } else if (here_val === 17) {\n                    n = here_bits + 3;\n                    while (bits < n) {\n                      if (have === 0)\n                        break inf_leave;\n                      have--, hold += input[next++] << bits, bits += 8;\n                    }\n                    hold >>>= here_bits, bits -= here_bits, len = 0, copy = 3 + (hold & 7), hold >>>= 3, bits -= 3;\n                  } else {\n                    n = here_bits + 7;\n                    while (bits < n) {\n                      if (have === 0)\n                        break inf_leave;\n                      have--, hold += input[next++] << bits, bits += 8;\n                    }\n                    hold >>>= here_bits, bits -= here_bits, len = 0, copy = 11 + (hold & 127), hold >>>= 7, bits -= 7;\n                  }\n                  if (state.have + copy > state.nlen + state.ndist) {\n                    strm.msg = \"invalid bit length repeat\", state.mode = BAD;\n                    break;\n                  }\n                  while (copy--)\n                    state.lens[state.have++] = len;\n                }\n              }\n              if (state.mode === BAD)\n                break;\n              if (state.lens[256] === 0) {\n                strm.msg = \"invalid code -- missing end-of-block\", state.mode = BAD;\n                break;\n              }\n              if (state.lenbits = 9, opts = { bits: state.lenbits }, ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts), state.lenbits = opts.bits, ret) {\n                strm.msg = \"invalid literal/lengths set\", state.mode = BAD;\n                break;\n              }\n              if (state.distbits = 6, state.distcode = state.distdyn, opts = { bits: state.distbits }, ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts), state.distbits = opts.bits, ret) {\n                strm.msg = \"invalid distances set\", state.mode = BAD;\n                break;\n              }\n              if (state.mode = LEN_, flush === Z_TREES)\n                break inf_leave;\n            case LEN_:\n              state.mode = LEN;\n            case LEN:\n              if (have >= 6 && left >= 258) {\n                if (strm.next_out = put, strm.avail_out = left, strm.next_in = next, strm.avail_in = have, state.hold = hold, state.bits = bits, inflate_fast(strm, _out), put = strm.next_out, output = strm.output, left = strm.avail_out, next = strm.next_in, input = strm.input, have = strm.avail_in, hold = state.hold, bits = state.bits, state.mode === TYPE)\n                  state.back = -1;\n                break;\n              }\n              state.back = 0;\n              for (;; ) {\n                if (here = state.lencode[hold & (1 << state.lenbits) - 1], here_bits = here >>> 24, here_op = here >>> 16 & 255, here_val = here & 65535, here_bits <= bits)\n                  break;\n                if (have === 0)\n                  break inf_leave;\n                have--, hold += input[next++] << bits, bits += 8;\n              }\n              if (here_op && (here_op & 240) === 0) {\n                last_bits = here_bits, last_op = here_op, last_val = here_val;\n                for (;; ) {\n                  if (here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)], here_bits = here >>> 24, here_op = here >>> 16 & 255, here_val = here & 65535, last_bits + here_bits <= bits)\n                    break;\n                  if (have === 0)\n                    break inf_leave;\n                  have--, hold += input[next++] << bits, bits += 8;\n                }\n                hold >>>= last_bits, bits -= last_bits, state.back += last_bits;\n              }\n              if (hold >>>= here_bits, bits -= here_bits, state.back += here_bits, state.length = here_val, here_op === 0) {\n                state.mode = LIT;\n                break;\n              }\n              if (here_op & 32) {\n                state.back = -1, state.mode = TYPE;\n                break;\n              }\n              if (here_op & 64) {\n                strm.msg = \"invalid literal/length code\", state.mode = BAD;\n                break;\n              }\n              state.extra = here_op & 15, state.mode = LENEXT;\n            case LENEXT:\n              if (state.extra) {\n                n = state.extra;\n                while (bits < n) {\n                  if (have === 0)\n                    break inf_leave;\n                  have--, hold += input[next++] << bits, bits += 8;\n                }\n                state.length += hold & (1 << state.extra) - 1, hold >>>= state.extra, bits -= state.extra, state.back += state.extra;\n              }\n              state.was = state.length, state.mode = DIST;\n            case DIST:\n              for (;; ) {\n                if (here = state.distcode[hold & (1 << state.distbits) - 1], here_bits = here >>> 24, here_op = here >>> 16 & 255, here_val = here & 65535, here_bits <= bits)\n                  break;\n                if (have === 0)\n                  break inf_leave;\n                have--, hold += input[next++] << bits, bits += 8;\n              }\n              if ((here_op & 240) === 0) {\n                last_bits = here_bits, last_op = here_op, last_val = here_val;\n                for (;; ) {\n                  if (here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)], here_bits = here >>> 24, here_op = here >>> 16 & 255, here_val = here & 65535, last_bits + here_bits <= bits)\n                    break;\n                  if (have === 0)\n                    break inf_leave;\n                  have--, hold += input[next++] << bits, bits += 8;\n                }\n                hold >>>= last_bits, bits -= last_bits, state.back += last_bits;\n              }\n              if (hold >>>= here_bits, bits -= here_bits, state.back += here_bits, here_op & 64) {\n                strm.msg = \"invalid distance code\", state.mode = BAD;\n                break;\n              }\n              state.offset = here_val, state.extra = here_op & 15, state.mode = DISTEXT;\n            case DISTEXT:\n              if (state.extra) {\n                n = state.extra;\n                while (bits < n) {\n                  if (have === 0)\n                    break inf_leave;\n                  have--, hold += input[next++] << bits, bits += 8;\n                }\n                state.offset += hold & (1 << state.extra) - 1, hold >>>= state.extra, bits -= state.extra, state.back += state.extra;\n              }\n              if (state.offset > state.dmax) {\n                strm.msg = \"invalid distance too far back\", state.mode = BAD;\n                break;\n              }\n              state.mode = MATCH;\n            case MATCH:\n              if (left === 0)\n                break inf_leave;\n              if (copy = _out - left, state.offset > copy) {\n                if (copy = state.offset - copy, copy > state.whave) {\n                  if (state.sane) {\n                    strm.msg = \"invalid distance too far back\", state.mode = BAD;\n                    break;\n                  }\n                }\n                if (copy > state.wnext)\n                  copy -= state.wnext, from = state.wsize - copy;\n                else\n                  from = state.wnext - copy;\n                if (copy > state.length)\n                  copy = state.length;\n                from_source = state.window;\n              } else\n                from_source = output, from = put - state.offset, copy = state.length;\n              if (copy > left)\n                copy = left;\n              left -= copy, state.length -= copy;\n              do\n                output[put++] = from_source[from++];\n              while (--copy);\n              if (state.length === 0)\n                state.mode = LEN;\n              break;\n            case LIT:\n              if (left === 0)\n                break inf_leave;\n              output[put++] = state.length, left--, state.mode = LEN;\n              break;\n            case CHECK:\n              if (state.wrap) {\n                while (bits < 32) {\n                  if (have === 0)\n                    break inf_leave;\n                  have--, hold |= input[next++] << bits, bits += 8;\n                }\n                if (_out -= left, strm.total_out += _out, state.total += _out, _out)\n                  strm.adler = state.check = state.flags \? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out);\n                if (_out = left, (state.flags \? hold : zswap32(hold)) !== state.check) {\n                  strm.msg = \"incorrect data check\", state.mode = BAD;\n                  break;\n                }\n                hold = 0, bits = 0;\n              }\n              state.mode = LENGTH;\n            case LENGTH:\n              if (state.wrap && state.flags) {\n                while (bits < 32) {\n                  if (have === 0)\n                    break inf_leave;\n                  have--, hold += input[next++] << bits, bits += 8;\n                }\n                if (hold !== (state.total & 4294967295)) {\n                  strm.msg = \"incorrect length check\", state.mode = BAD;\n                  break;\n                }\n                hold = 0, bits = 0;\n              }\n              state.mode = DONE;\n            case DONE:\n              ret = Z_STREAM_END;\n              break inf_leave;\n            case BAD:\n              ret = Z_DATA_ERROR;\n              break inf_leave;\n            case MEM:\n              return Z_MEM_ERROR;\n            case SYNC:\n            default:\n              return Z_STREAM_ERROR;\n          }\n      if (strm.next_out = put, strm.avail_out = left, strm.next_in = next, strm.avail_in = have, state.hold = hold, state.bits = bits, state.wsize || _out !== strm.avail_out && state.mode < BAD && (state.mode < CHECK || flush !== Z_FINISH)) {\n        if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out))\n          return state.mode = MEM, Z_MEM_ERROR;\n      }\n      if (_in -= strm.avail_in, _out -= strm.avail_out, strm.total_in += _in, strm.total_out += _out, state.total += _out, state.wrap && _out)\n        strm.adler = state.check = state.flags \? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out);\n      if (strm.data_type = state.bits + (state.last \? 64 : 0) + (state.mode === TYPE \? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ \? 256 : 0), (_in === 0 && _out === 0 || flush === Z_FINISH) && ret === Z_OK)\n        ret = Z_BUF_ERROR;\n      return ret;\n    }\n    function inflateEnd(strm) {\n      if (!strm || !strm.state)\n        return Z_STREAM_ERROR;\n      var state = strm.state;\n      if (state.window)\n        state.window = null;\n      return strm.state = null, Z_OK;\n    }\n    function inflateGetHeader(strm, head) {\n      var state;\n      if (!strm || !strm.state)\n        return Z_STREAM_ERROR;\n      if (state = strm.state, (state.wrap & 2) === 0)\n        return Z_STREAM_ERROR;\n      return state.head = head, head.done = !1, Z_OK;\n    }\n    function inflateSetDictionary(strm, dictionary) {\n      var dictLength = dictionary.length, state, dictid, ret;\n      if (!strm || !strm.state)\n        return Z_STREAM_ERROR;\n      if (state = strm.state, state.wrap !== 0 && state.mode !== DICT)\n        return Z_STREAM_ERROR;\n      if (state.mode === DICT) {\n        if (dictid = 1, dictid = adler32(dictid, dictionary, dictLength, 0), dictid !== state.check)\n          return Z_DATA_ERROR;\n      }\n      if (ret = updatewindow(strm, dictionary, dictLength, dictLength), ret)\n        return state.mode = MEM, Z_MEM_ERROR;\n      return state.havedict = 1, Z_OK;\n    }\n    exports.inflateReset = inflateReset, exports.inflateReset2 = inflateReset2, exports.inflateResetKeep = inflateResetKeep, exports.inflateInit = inflateInit, exports.inflateInit2 = inflateInit2, exports.inflate = inflate, exports.inflateEnd = inflateEnd, exports.inflateGetHeader = inflateGetHeader, exports.inflateSetDictionary = inflateSetDictionary, exports.inflateInfo = \"pako inflate (from Nodeca project)\";\n  }\n}), require_constants = __commonJS({\n  \"node_modules/pako/lib/zlib/constants.js\"(exports, module2) {\n    module2.exports = {\n      Z_NO_FLUSH: 0,\n      Z_PARTIAL_FLUSH: 1,\n      Z_SYNC_FLUSH: 2,\n      Z_FULL_FLUSH: 3,\n      Z_FINISH: 4,\n      Z_BLOCK: 5,\n      Z_TREES: 6,\n      Z_OK: 0,\n      Z_STREAM_END: 1,\n      Z_NEED_DICT: 2,\n      Z_ERRNO: -1,\n      Z_STREAM_ERROR: -2,\n      Z_DATA_ERROR: -3,\n      Z_BUF_ERROR: -5,\n      Z_NO_COMPRESSION: 0,\n      Z_BEST_SPEED: 1,\n      Z_BEST_COMPRESSION: 9,\n      Z_DEFAULT_COMPRESSION: -1,\n      Z_FILTERED: 1,\n      Z_HUFFMAN_ONLY: 2,\n      Z_RLE: 3,\n      Z_FIXED: 4,\n      Z_DEFAULT_STRATEGY: 0,\n      Z_BINARY: 0,\n      Z_TEXT: 1,\n      Z_UNKNOWN: 2,\n      Z_DEFLATED: 8\n    };\n  }\n}), require_binding = __commonJS({\n  \"node_modules/browserify-zlib/lib/binding.js\"(exports) {\n    var Zstream = require_zstream(), zlib_deflate = require_deflate(), zlib_inflate = require_inflate(), constants = require_constants();\n    for (key in constants)\n      exports[key] = constants[key];\n    var key;\n    exports.NONE = 0, exports.DEFLATE = 1, exports.INFLATE = 2, exports.GZIP = 3, exports.GUNZIP = 4, exports.DEFLATERAW = 5, exports.INFLATERAW = 6, exports.UNZIP = 7;\n    var GZIP_HEADER_ID1 = 31, GZIP_HEADER_ID2 = 139;\n    function Zlib(mode) {\n      if (typeof mode !== \"number\" || mode < exports.DEFLATE || mode > exports.UNZIP)\n        @throwTypeError(\"Bad argument\");\n      this.dictionary = null, this.err = 0, this.flush = 0, this.init_done = !1, this.level = 0, this.memLevel = 0, this.mode = mode, this.strategy = 0, this.windowBits = 0, this.write_in_progress = !1, this.pending_close = !1, this.gzip_id_bytes_read = 0;\n    }\n    Zlib.prototype = {}, Zlib.prototype.close = function() {\n      if (this.write_in_progress) {\n        this.pending_close = !0;\n        return;\n      }\n      if (this.pending_close = !1, assert(this.init_done, \"close before init\"), assert(this.mode <= exports.UNZIP), this.mode === exports.DEFLATE || this.mode === exports.GZIP || this.mode === exports.DEFLATERAW)\n        zlib_deflate.deflateEnd(this.strm);\n      else if (this.mode === exports.INFLATE || this.mode === exports.GUNZIP || this.mode === exports.INFLATERAW || this.mode === exports.UNZIP)\n        zlib_inflate.inflateEnd(this.strm);\n      this.mode = exports.NONE, this.dictionary = null;\n    }, Zlib.prototype.write = function(flush, input, in_off, in_len, out, out_off, out_len) {\n      return this._write(!0, flush, input, in_off, in_len, out, out_off, out_len);\n    }, Zlib.prototype.writeSync = function(flush, input, in_off, in_len, out, out_off, out_len) {\n      return this._write(!1, flush, input, in_off, in_len, out, out_off, out_len);\n    }, Zlib.prototype._write = function(async, flush, input, in_off, in_len, out, out_off, out_len) {\n      if (assert.equal(arguments.length, 8), assert(this.init_done, \"write before init\"), assert(this.mode !== exports.NONE, \"already finalized\"), assert.equal(!1, this.write_in_progress, \"write already in progress\"), assert.equal(!1, this.pending_close, \"close is pending\"), this.write_in_progress = !0, assert.equal(!1, flush === void 0, \"must provide flush value\"), this.write_in_progress = !0, flush !== exports.Z_NO_FLUSH && flush !== exports.Z_PARTIAL_FLUSH && flush !== exports.Z_SYNC_FLUSH && flush !== exports.Z_FULL_FLUSH && flush !== exports.Z_FINISH && flush !== exports.Z_BLOCK)\n        throw new Error(\"Invalid flush value\");\n      if (input == null)\n        input = Buffer.alloc(0), in_len = 0, in_off = 0;\n      if (this.strm.avail_in = in_len, this.strm.input = input, this.strm.next_in = in_off, this.strm.avail_out = out_len, this.strm.output = out, this.strm.next_out = out_off, this.flush = flush, !async) {\n        if (this._process(), this._checkError())\n          return this._afterSync();\n        return;\n      }\n      var self = this;\n      return process.nextTick(function() {\n        self._process(), self._after();\n      }), this;\n    }, Zlib.prototype._afterSync = function() {\n      var avail_out = this.strm.avail_out, avail_in = this.strm.avail_in;\n      return this.write_in_progress = !1, [avail_in, avail_out];\n    }, Zlib.prototype._process = function() {\n      var next_expected_header_byte = null;\n      switch (this.mode) {\n        case exports.DEFLATE:\n        case exports.GZIP:\n        case exports.DEFLATERAW:\n          this.err = zlib_deflate.deflate(this.strm, this.flush);\n          break;\n        case exports.UNZIP:\n          if (this.strm.avail_in > 0)\n            next_expected_header_byte = this.strm.next_in;\n          switch (this.gzip_id_bytes_read) {\n            case 0:\n              if (next_expected_header_byte === null)\n                break;\n              if (this.strm.input[next_expected_header_byte] === GZIP_HEADER_ID1) {\n                if (this.gzip_id_bytes_read = 1, next_expected_header_byte++, this.strm.avail_in === 1)\n                  break;\n              } else {\n                this.mode = exports.INFLATE;\n                break;\n              }\n            case 1:\n              if (next_expected_header_byte === null)\n                break;\n              if (this.strm.input[next_expected_header_byte] === GZIP_HEADER_ID2)\n                this.gzip_id_bytes_read = 2, this.mode = exports.GUNZIP;\n              else\n                this.mode = exports.INFLATE;\n              break;\n            default:\n              throw new Error(\"invalid number of gzip magic number bytes read\");\n          }\n        case exports.INFLATE:\n        case exports.GUNZIP:\n        case exports.INFLATERAW:\n          if (this.err = zlib_inflate.inflate(this.strm, this.flush), this.err === exports.Z_NEED_DICT && this.dictionary) {\n            if (this.err = zlib_inflate.inflateSetDictionary(this.strm, this.dictionary), this.err === exports.Z_OK)\n              this.err = zlib_inflate.inflate(this.strm, this.flush);\n            else if (this.err === exports.Z_DATA_ERROR)\n              this.err = exports.Z_NEED_DICT;\n          }\n          while (this.strm.avail_in > 0 && this.mode === exports.GUNZIP && this.err === exports.Z_STREAM_END && this.strm.next_in[0] !== 0)\n            this.reset(), this.err = zlib_inflate.inflate(this.strm, this.flush);\n          break;\n        default:\n          throw new Error(\"Unknown mode \" + this.mode);\n      }\n    }, Zlib.prototype._checkError = function() {\n      switch (this.err) {\n        case exports.Z_OK:\n        case exports.Z_BUF_ERROR:\n          if (this.strm.avail_out !== 0 && this.flush === exports.Z_FINISH)\n            return this._error(\"unexpected end of file\"), !1;\n          break;\n        case exports.Z_STREAM_END:\n          break;\n        case exports.Z_NEED_DICT:\n          if (this.dictionary == null)\n            this._error(\"Missing dictionary\");\n          else\n            this._error(\"Bad dictionary\");\n          return !1;\n        default:\n          return this._error(\"Zlib error\"), !1;\n      }\n      return !0;\n    }, Zlib.prototype._after = function() {\n      if (!this._checkError())\n        return;\n      var avail_out = this.strm.avail_out, avail_in = this.strm.avail_in;\n      if (this.write_in_progress = !1, this.callback(avail_in, avail_out), this.pending_close)\n        this.close();\n    }, Zlib.prototype._error = function(message) {\n      if (this.strm.msg)\n        message = this.strm.msg;\n      if (this.onerror(message, this.err), this.write_in_progress = !1, this.pending_close)\n        this.close();\n    }, Zlib.prototype.init = function(windowBits, level, memLevel, strategy, dictionary) {\n      assert(arguments.length === 4 || arguments.length === 5, \"init(windowBits, level, memLevel, strategy, [dictionary])\"), assert(windowBits >= 8 && windowBits <= 15, \"invalid windowBits\"), assert(level >= -1 && level <= 9, \"invalid compression level\"), assert(memLevel >= 1 && memLevel <= 9, \"invalid memlevel\"), assert(strategy === exports.Z_FILTERED || strategy === exports.Z_HUFFMAN_ONLY || strategy === exports.Z_RLE || strategy === exports.Z_FIXED || strategy === exports.Z_DEFAULT_STRATEGY, \"invalid strategy\"), this._init(level, windowBits, memLevel, strategy, dictionary), this._setDictionary();\n    }, Zlib.prototype.params = function() {\n      throw new Error(\"deflateParams Not supported\");\n    }, Zlib.prototype.reset = function() {\n      this._reset(), this._setDictionary();\n    }, Zlib.prototype._init = function(level, windowBits, memLevel, strategy, dictionary) {\n      if (this.level = level, this.windowBits = windowBits, this.memLevel = memLevel, this.strategy = strategy, this.flush = exports.Z_NO_FLUSH, this.err = exports.Z_OK, this.mode === exports.GZIP || this.mode === exports.GUNZIP)\n        this.windowBits += 16;\n      if (this.mode === exports.UNZIP)\n        this.windowBits += 32;\n      if (this.mode === exports.DEFLATERAW || this.mode === exports.INFLATERAW)\n        this.windowBits = -1 * this.windowBits;\n      switch (this.strm = new Zstream, this.mode) {\n        case exports.DEFLATE:\n        case exports.GZIP:\n        case exports.DEFLATERAW:\n          this.err = zlib_deflate.deflateInit2(this.strm, this.level, exports.Z_DEFLATED, this.windowBits, this.memLevel, this.strategy);\n          break;\n        case exports.INFLATE:\n        case exports.GUNZIP:\n        case exports.INFLATERAW:\n        case exports.UNZIP:\n          this.err = zlib_inflate.inflateInit2(this.strm, this.windowBits);\n          break;\n        default:\n          throw new Error(\"Unknown mode \" + this.mode);\n      }\n      if (this.err !== exports.Z_OK)\n        this._error(\"Init error\");\n      this.dictionary = dictionary, this.write_in_progress = !1, this.init_done = !0;\n    }, Zlib.prototype._setDictionary = function() {\n      if (this.dictionary == null)\n        return;\n      switch (this.err = exports.Z_OK, this.mode) {\n        case exports.DEFLATE:\n        case exports.DEFLATERAW:\n          this.err = zlib_deflate.deflateSetDictionary(this.strm, this.dictionary);\n          break;\n        default:\n          break;\n      }\n      if (this.err !== exports.Z_OK)\n        this._error(\"Failed to set dictionary\");\n    }, Zlib.prototype._reset = function() {\n      switch (this.err = exports.Z_OK, this.mode) {\n        case exports.DEFLATE:\n        case exports.DEFLATERAW:\n        case exports.GZIP:\n          this.err = zlib_deflate.deflateReset(this.strm);\n          break;\n        case exports.INFLATE:\n        case exports.INFLATERAW:\n        case exports.GUNZIP:\n          this.err = zlib_inflate.inflateReset(this.strm);\n          break;\n        default:\n          break;\n      }\n      if (this.err !== exports.Z_OK)\n        this._error(\"Failed to reset stream\");\n    }, exports.Zlib = Zlib;\n  }\n}), require_lib = __commonJS({\n  \"node_modules/browserify-zlib/lib/index.js\"(exports) {\n    var Buffer2 = BufferModule.Buffer, Transform = StreamModule.Transform, binding = require_binding(), util = Util, kMaxLength = BufferModule.kMaxLength, kRangeErrorMessage = \"Cannot create final Buffer. It would be larger than 0x\" + kMaxLength.toString(16) + \" bytes\";\n    binding.Z_MIN_WINDOWBITS = 8, binding.Z_MAX_WINDOWBITS = 15, binding.Z_DEFAULT_WINDOWBITS = 15, binding.Z_MIN_CHUNK = 64, binding.Z_MAX_CHUNK = Infinity, binding.Z_DEFAULT_CHUNK = 16384, binding.Z_MIN_MEMLEVEL = 1, binding.Z_MAX_MEMLEVEL = 9, binding.Z_DEFAULT_MEMLEVEL = 8, binding.Z_MIN_LEVEL = -1, binding.Z_MAX_LEVEL = 9, binding.Z_DEFAULT_LEVEL = binding.Z_DEFAULT_COMPRESSION;\n    var bkeys = Object.keys(binding);\n    for (bk = 0;bk < bkeys.length; bk++)\n      if (bkey = bkeys[bk], bkey.match(/^Z/))\n        Object.defineProperty(exports, bkey, {\n          enumerable: !0,\n          value: binding[bkey],\n          writable: !1\n        });\n    var bkey, bk, codes = {\n      Z_OK: binding.Z_OK,\n      Z_STREAM_END: binding.Z_STREAM_END,\n      Z_NEED_DICT: binding.Z_NEED_DICT,\n      Z_ERRNO: binding.Z_ERRNO,\n      Z_STREAM_ERROR: binding.Z_STREAM_ERROR,\n      Z_DATA_ERROR: binding.Z_DATA_ERROR,\n      Z_MEM_ERROR: binding.Z_MEM_ERROR,\n      Z_BUF_ERROR: binding.Z_BUF_ERROR,\n      Z_VERSION_ERROR: binding.Z_VERSION_ERROR\n    }, ckeys = Object.keys(codes);\n    for (ck = 0;ck < ckeys.length; ck++)\n      ckey = ckeys[ck], codes[codes[ckey]] = ckey;\n    var ckey, ck;\n    Object.defineProperty(exports, \"codes\", {\n      enumerable: !0,\n      value: Object.freeze(codes),\n      writable: !1\n    }), exports.constants = require_constants(), exports.Deflate = Deflate, exports.Inflate = Inflate, exports.Gzip = Gzip, exports.Gunzip = Gunzip, exports.DeflateRaw = DeflateRaw, exports.InflateRaw = InflateRaw, exports.Unzip = Unzip, exports.createDeflate = function(o) {\n      return new Deflate(o);\n    }, exports.createInflate = function(o) {\n      return new Inflate(o);\n    }, exports.createDeflateRaw = function(o) {\n      return new DeflateRaw(o);\n    }, exports.createInflateRaw = function(o) {\n      return new InflateRaw(o);\n    }, exports.createGzip = function(o) {\n      return new Gzip(o);\n    }, exports.createGunzip = function(o) {\n      return new Gunzip(o);\n    }, exports.createUnzip = function(o) {\n      return new Unzip(o);\n    }, exports.deflate = function(buffer, opts, callback) {\n      if (typeof opts === \"function\")\n        callback = opts, opts = {};\n      return zlibBuffer(new Deflate(opts), buffer, callback);\n    }, exports.deflateSync = function(buffer, opts) {\n      return zlibBufferSync(new Deflate(opts), buffer);\n    }, exports.gzip = function(buffer, opts, callback) {\n      if (typeof opts === \"function\")\n        callback = opts, opts = {};\n      return zlibBuffer(new Gzip(opts), buffer, callback);\n    }, exports.gzipSync = function(buffer, opts) {\n      return zlibBufferSync(new Gzip(opts), buffer);\n    }, exports.deflateRaw = function(buffer, opts, callback) {\n      if (typeof opts === \"function\")\n        callback = opts, opts = {};\n      return zlibBuffer(new DeflateRaw(opts), buffer, callback);\n    }, exports.deflateRawSync = function(buffer, opts) {\n      return zlibBufferSync(new DeflateRaw(opts), buffer);\n    }, exports.unzip = function(buffer, opts, callback) {\n      if (typeof opts === \"function\")\n        callback = opts, opts = {};\n      return zlibBuffer(new Unzip(opts), buffer, callback);\n    }, exports.unzipSync = function(buffer, opts) {\n      return zlibBufferSync(new Unzip(opts), buffer);\n    }, exports.inflate = function(buffer, opts, callback) {\n      if (typeof opts === \"function\")\n        callback = opts, opts = {};\n      return zlibBuffer(new Inflate(opts), buffer, callback);\n    }, exports.inflateSync = function(buffer, opts) {\n      return zlibBufferSync(new Inflate(opts), buffer);\n    }, exports.gunzip = function(buffer, opts, callback) {\n      if (typeof opts === \"function\")\n        callback = opts, opts = {};\n      return zlibBuffer(new Gunzip(opts), buffer, callback);\n    }, exports.gunzipSync = function(buffer, opts) {\n      return zlibBufferSync(new Gunzip(opts), buffer);\n    }, exports.inflateRaw = function(buffer, opts, callback) {\n      if (typeof opts === \"function\")\n        callback = opts, opts = {};\n      return zlibBuffer(new InflateRaw(opts), buffer, callback);\n    }, exports.inflateRawSync = function(buffer, opts) {\n      return zlibBufferSync(new InflateRaw(opts), buffer);\n    }, exports.brotliCompress = function(buffer, opts, callback) {\n      throw new Error(\"zlib.brotliCompress is not implemented\");\n    };\n    function zlibBuffer(engine, buffer, callback) {\n      var buffers = [], nread = 0;\n      engine.on(\"error\", onError), engine.on(\"end\", onEnd), engine.end(buffer), flow();\n      function flow() {\n        var chunk;\n        while ((chunk = engine.read()) !== null)\n          buffers.push(chunk), nread += chunk.length;\n        engine.once(\"readable\", flow);\n      }\n      function onError(err) {\n        engine.removeListener(\"end\", onEnd), engine.removeListener(\"readable\", flow), callback(err);\n      }\n      function onEnd() {\n        var buf, err = null;\n        if (nread >= kMaxLength)\n          err = new RangeError(kRangeErrorMessage);\n        else\n          buf = Buffer2.concat(buffers, nread);\n        buffers = [], engine.close(), callback(err, buf);\n      }\n    }\n    function zlibBufferSync(engine, buffer) {\n      if (typeof buffer === \"string\")\n        buffer = Buffer2.from(buffer);\n      if (!Buffer2.isBuffer(buffer))\n        @throwTypeError(\"Not a string or buffer\");\n      var flushFlag = engine._finishFlushFlag;\n      return engine._processChunk(buffer, flushFlag);\n    }\n    function Deflate(opts) {\n      if (!(this instanceof Deflate))\n        return new Deflate(opts);\n      Zlib.call(this, opts, binding.DEFLATE);\n    }\n    function Inflate(opts) {\n      if (!(this instanceof Inflate))\n        return new Inflate(opts);\n      Zlib.call(this, opts, binding.INFLATE);\n    }\n    function Gzip(opts) {\n      if (!(this instanceof Gzip))\n        return new Gzip(opts);\n      Zlib.call(this, opts, binding.GZIP);\n    }\n    function Gunzip(opts) {\n      if (!(this instanceof Gunzip))\n        return new Gunzip(opts);\n      Zlib.call(this, opts, binding.GUNZIP);\n    }\n    function DeflateRaw(opts) {\n      if (!(this instanceof DeflateRaw))\n        return new DeflateRaw(opts);\n      Zlib.call(this, opts, binding.DEFLATERAW);\n    }\n    function InflateRaw(opts) {\n      if (!(this instanceof InflateRaw))\n        return new InflateRaw(opts);\n      Zlib.call(this, opts, binding.INFLATERAW);\n    }\n    function Unzip(opts) {\n      if (!(this instanceof Unzip))\n        return new Unzip(opts);\n      Zlib.call(this, opts, binding.UNZIP);\n    }\n    function isValidFlushFlag(flag) {\n      return flag === binding.Z_NO_FLUSH || flag === binding.Z_PARTIAL_FLUSH || flag === binding.Z_SYNC_FLUSH || flag === binding.Z_FULL_FLUSH || flag === binding.Z_FINISH || flag === binding.Z_BLOCK;\n    }\n    function Zlib(opts, mode) {\n      var _this = this;\n      if (this._opts = opts = opts || {}, this._chunkSize = opts.chunkSize || exports.Z_DEFAULT_CHUNK, Transform.call(this, opts), opts.flush && !isValidFlushFlag(opts.flush))\n        throw new Error(\"Invalid flush flag: \" + opts.flush);\n      if (opts.finishFlush && !isValidFlushFlag(opts.finishFlush))\n        throw new Error(\"Invalid flush flag: \" + opts.finishFlush);\n      if (this._flushFlag = opts.flush || binding.Z_NO_FLUSH, this._finishFlushFlag = typeof opts.finishFlush !== \"undefined\" \? opts.finishFlush : binding.Z_FINISH, opts.chunkSize) {\n        if (opts.chunkSize < exports.Z_MIN_CHUNK || opts.chunkSize > exports.Z_MAX_CHUNK)\n          throw new Error(\"Invalid chunk size: \" + opts.chunkSize);\n      }\n      if (opts.windowBits) {\n        if (opts.windowBits < exports.Z_MIN_WINDOWBITS || opts.windowBits > exports.Z_MAX_WINDOWBITS)\n          throw new Error(\"Invalid windowBits: \" + opts.windowBits);\n      }\n      if (opts.level) {\n        if (opts.level < exports.Z_MIN_LEVEL || opts.level > exports.Z_MAX_LEVEL)\n          throw new Error(\"Invalid compression level: \" + opts.level);\n      }\n      if (opts.memLevel) {\n        if (opts.memLevel < exports.Z_MIN_MEMLEVEL || opts.memLevel > exports.Z_MAX_MEMLEVEL)\n          throw new Error(\"Invalid memLevel: \" + opts.memLevel);\n      }\n      if (opts.strategy) {\n        if (opts.strategy != exports.Z_FILTERED && opts.strategy != exports.Z_HUFFMAN_ONLY && opts.strategy != exports.Z_RLE && opts.strategy != exports.Z_FIXED && opts.strategy != exports.Z_DEFAULT_STRATEGY)\n          throw new Error(\"Invalid strategy: \" + opts.strategy);\n      }\n      if (opts.dictionary) {\n        if (!Buffer2.isBuffer(opts.dictionary))\n          throw new Error(\"Invalid dictionary: it should be a Buffer instance\");\n      }\n      this._handle = new binding.Zlib(mode);\n      var self = this;\n      this._hadError = !1, this._handle.onerror = function(message, errno) {\n        _close(self), self._hadError = !0;\n        var error = new Error(message);\n        error.errno = errno, error.code = exports.codes[errno], self.emit(\"error\", error);\n      };\n      var level = exports.Z_DEFAULT_COMPRESSION;\n      if (typeof opts.level === \"number\")\n        level = opts.level;\n      var strategy = exports.Z_DEFAULT_STRATEGY;\n      if (typeof opts.strategy === \"number\")\n        strategy = opts.strategy;\n      this._handle.init(opts.windowBits || exports.Z_DEFAULT_WINDOWBITS, level, opts.memLevel || exports.Z_DEFAULT_MEMLEVEL, strategy, opts.dictionary), this._buffer = Buffer2.allocUnsafe(this._chunkSize), this._offset = 0, this._level = level, this._strategy = strategy, this.once(\"end\", this.close), Object.defineProperty(this, \"_closed\", {\n        get: function() {\n          return !_this._handle;\n        },\n        configurable: !0,\n        enumerable: !0\n      });\n    }\n    util.inherits(Zlib, Transform), Zlib.prototype.params = function(level, strategy, callback) {\n      if (level < exports.Z_MIN_LEVEL || level > exports.Z_MAX_LEVEL)\n        @throwRangeError(\"Invalid compression level: \" + level);\n      if (strategy != exports.Z_FILTERED && strategy != exports.Z_HUFFMAN_ONLY && strategy != exports.Z_RLE && strategy != exports.Z_FIXED && strategy != exports.Z_DEFAULT_STRATEGY)\n        @throwTypeError(\"Invalid strategy: \" + strategy);\n      if (this._level !== level || this._strategy !== strategy) {\n        var self = this;\n        this.flush(binding.Z_SYNC_FLUSH, function() {\n          if (assert(self._handle, \"zlib binding closed\"), self._handle.params(level, strategy), !self._hadError) {\n            if (self._level = level, self._strategy = strategy, callback)\n              callback();\n          }\n        });\n      } else\n        process.nextTick(callback);\n    }, Zlib.prototype.reset = function() {\n      return assert(this._handle, \"zlib binding closed\"), this._handle.reset();\n    }, Zlib.prototype._flush = function(callback) {\n      this._transform(Buffer2.alloc(0), \"\", callback);\n    }, Zlib.prototype.flush = function(kind, callback) {\n      var _this2 = this, ws = this._writableState;\n      if (typeof kind === \"function\" || kind === void 0 && !callback)\n        callback = kind, kind = binding.Z_FULL_FLUSH;\n      if (ws.ended) {\n        if (callback)\n          process.nextTick(callback);\n      } else if (ws.ending) {\n        if (callback)\n          this.once(\"end\", callback);\n      } else if (ws.needDrain) {\n        if (callback)\n          this.once(\"drain\", function() {\n            return _this2.flush(kind, callback);\n          });\n      } else\n        this._flushFlag = kind, this.write(Buffer2.alloc(0), \"\", callback);\n    }, Zlib.prototype.close = function(callback) {\n      _close(this, callback), process.nextTick(emitCloseNT, this);\n    };\n    function _close(engine, callback) {\n      if (callback)\n        process.nextTick(callback);\n      if (!engine._handle)\n        return;\n      engine._handle.close(), engine._handle = null;\n    }\n    function emitCloseNT(self) {\n      self.emit(\"close\");\n    }\n    Zlib.prototype._transform = function(chunk, encoding, cb) {\n      var flushFlag, ws = this._writableState, ending = ws.ending || ws.ended, last = ending && (!chunk || ws.length === chunk.length);\n      if (chunk !== null && !Buffer2.isBuffer(chunk))\n        return cb(new Error(\"invalid input\"));\n      if (!this._handle)\n        return cb(new Error(\"zlib binding closed\"));\n      if (last)\n        flushFlag = this._finishFlushFlag;\n      else if (flushFlag = this._flushFlag, chunk.length >= ws.length)\n        this._flushFlag = this._opts.flush || binding.Z_NO_FLUSH;\n      this._processChunk(chunk, flushFlag, cb);\n    }, Zlib.prototype._processChunk = function(chunk, flushFlag, cb) {\n      var availInBefore = chunk && chunk.length, availOutBefore = this._chunkSize - this._offset, inOff = 0, self = this, async = typeof cb === \"function\";\n      if (!async) {\n        var buffers = [], nread = 0, error;\n        this.on(\"error\", function(er) {\n          error = er;\n        }), assert(this._handle, \"zlib binding closed\");\n        do\n          var res = this._handle.writeSync(flushFlag, chunk, inOff, availInBefore, this._buffer, this._offset, availOutBefore);\n        while (!this._hadError && callback(res[0], res[1]));\n        if (this._hadError)\n          throw error;\n        if (nread >= kMaxLength)\n          _close(this), @throwRangeError(kRangeErrorMessage);\n        var buf = Buffer2.concat(buffers, nread);\n        return _close(this), buf;\n      }\n      assert(this._handle, \"zlib binding closed\");\n      var req = this._handle.write(flushFlag, chunk, inOff, availInBefore, this._buffer, this._offset, availOutBefore);\n      req.buffer = chunk, req.callback = callback;\n      function callback(availInAfter, availOutAfter) {\n        if (this)\n          this.buffer = null, this.callback = null;\n        if (self._hadError)\n          return;\n        var have = availOutBefore - availOutAfter;\n        if (assert(have >= 0, \"have should not go down\"), have > 0) {\n          var out = self._buffer.slice(self._offset, self._offset + have);\n          if (self._offset += have, async)\n            self.push(out);\n          else\n            buffers.push(out), nread += out.length;\n        }\n        if (availOutAfter === 0 || self._offset >= self._chunkSize)\n          availOutBefore = self._chunkSize, self._offset = 0, self._buffer = Buffer2.allocUnsafe(self._chunkSize);\n        if (availOutAfter === 0) {\n          if (inOff += availInBefore - availInAfter, availInBefore = availInAfter, !async)\n            return !0;\n          var newReq = self._handle.write(flushFlag, chunk, inOff, availInBefore, self._buffer, self._offset, self._chunkSize);\n          newReq.callback = callback, newReq.buffer = chunk;\n          return;\n        }\n        if (!async)\n          return !1;\n        cb();\n      }\n    }, util.inherits(Deflate, Zlib), util.inherits(Inflate, Zlib), util.inherits(Gzip, Zlib), util.inherits(Gunzip, Zlib), util.inherits(DeflateRaw, Zlib), util.inherits(InflateRaw, Zlib), util.inherits(Unzip, Zlib);\n  }\n});\nreturn require_lib()})\n"_s;
//

//
static constexpr ASCIILiteral ThirdpartyDepdCode = "(function (){\"use strict\";// src/js/out/tmp/thirdparty/depd.ts\nvar wrapfunction = function(fn, message) {\n  if (typeof fn !== \"function\")\n    @throwTypeError(\"argument fn must be a function\");\n  return fn;\n}, wrapproperty = function(obj, prop, message) {\n  if (!obj || typeof obj !== \"object\" && typeof obj !== \"function\")\n    @throwTypeError(\"argument obj must be object\");\n  var descriptor = Object.getOwnPropertyDescriptor(obj, prop);\n  if (!descriptor)\n    @throwTypeError(\"must call property on owner object\");\n  if (!descriptor.configurable)\n    @throwTypeError(\"property must be configurable\");\n}, $;\n$ = function depd(namespace) {\n  if (!namespace)\n    @throwTypeError(\"argument namespace is required\");\n  function deprecate(message) {\n  }\n  return deprecate._file = void 0, deprecate._ignored = !0, deprecate._namespace = namespace, deprecate._traced = !1, deprecate._warned = Object.create(null), deprecate.function = wrapfunction, deprecate.property = wrapproperty, deprecate;\n};\nreturn $})\n"_s;
//

//
static constexpr ASCIILiteral ThirdpartyDetectLibcCode = "(function (){\"use strict\";// src/js/out/tmp/thirdparty/detect-libc.ts\nvar family = function() {\n  return Promise.resolve(familySync());\n}, familySync = function() {\n  return null;\n}, versionAsync = function() {\n  return Promise.resolve(version());\n}, version = function() {\n  return null;\n}, isNonGlibcLinuxSync = function() {\n  return !1;\n}, isNonGlibcLinux = function() {\n  return Promise.resolve(isNonGlibcLinuxSync());\n}, $, GLIBC = \"glibc\", MUSL = \"musl\";\n$ = {\n  GLIBC,\n  MUSL,\n  family,\n  familySync,\n  isNonGlibcLinux,\n  isNonGlibcLinuxSync,\n  version,\n  versionAsync\n};\nreturn $})\n"_s;
//

//
static constexpr ASCIILiteral ThirdpartyDetectLibcLinuxCode = "(function (){\"use strict\";// src/js/out/tmp/thirdparty/detect-libc.linux.ts\nvar family = function() {\n  return Promise.resolve(familySync());\n}, familySync = function() {\n  return GLIBC;\n}, versionAsync = function() {\n  return Promise.resolve(version());\n}, version = function() {\n  return \"2.29\";\n}, isNonGlibcLinuxSync = function() {\n  return !1;\n}, isNonGlibcLinux = function() {\n  return Promise.resolve(isNonGlibcLinuxSync());\n}, $, GLIBC = \"glibc\", MUSL = \"musl\";\n$ = {\n  GLIBC,\n  MUSL,\n  family,\n  familySync,\n  isNonGlibcLinux,\n  isNonGlibcLinuxSync,\n  version,\n  versionAsync\n};\nreturn $})\n"_s;
//

//
static constexpr ASCIILiteral ThirdpartyIsomorphicFetchCode = "(function (){\"use strict\";// src/js/out/tmp/thirdparty/isomorphic-fetch.ts\nvar bunFetch = Bun.fetch, fetch = (...args) => bunFetch(...args);\nfetch.default = fetch;\nfetch.fetch = fetch;\nreturn fetch})\n"_s;
//

//
static constexpr ASCIILiteral ThirdpartyNodeFetchCode = "(function (){\"use strict\";// src/js/out/tmp/thirdparty/node-fetch.ts\nvar fetch = function(...args) {\n  return realFetch(...args);\n}, blobFrom = function(path, options) {\n  return Promise.resolve(Bun.file(data));\n}, blobFromSync = function(path, options) {\n  return Bun.file(data);\n}, isRedirect = function(code) {\n  return code === 301 || code === 302 || code === 303 || code === 307 || code === 308;\n}, $, { Headers, Request, Response, Blob, File = Blob, FormData } = globalThis, realFetch = Bun.fetch;\n\nclass AbortError extends DOMException {\n  constructor(message) {\n    super(message, \"AbortError\");\n  }\n}\n\nclass FetchBaseError extends Error {\n  constructor(message, type) {\n    super(message);\n    this.type = type;\n  }\n}\n\nclass FetchError extends FetchBaseError {\n  constructor(message, type, systemError) {\n    super(message, type);\n    this.code = systemError\?.code;\n  }\n}\nvar fileFrom = blobFrom, fileFromSync = blobFromSync;\n$ = Object.assign(fetch, {\n  AbortError,\n  Blob,\n  FetchBaseError,\n  FetchError,\n  File,\n  FormData,\n  Headers,\n  Request,\n  Response,\n  blobFrom,\n  blobFromSync,\n  fileFrom,\n  fileFromSync,\n  isRedirect,\n  fetch,\n  default: fetch\n});\nreturn $})\n"_s;
//

//
static constexpr ASCIILiteral ThirdpartyUndiciCode = "(function (){\"use strict\";// src/js/out/tmp/thirdparty/undici.ts\nvar notImplemented = function() {\n  throw new Error(\"Not implemented in bun\");\n};\nasync function request(url, options = {\n  method: \"GET\",\n  signal: null,\n  headers: null,\n  query: null,\n  reset: !1,\n  throwOnError: !1,\n  body: null\n}) {\n  let {\n    method = \"GET\",\n    headers: inputHeaders,\n    query,\n    signal,\n    reset = !1,\n    throwOnError = !1,\n    body: inputBody,\n    maxRedirections\n  } = options;\n  if (typeof url === \"string\") {\n    if (query)\n      url = new URL(url);\n  } else if (typeof url === \"object\" && url !== null) {\n    if (!(url instanceof URL))\n      throw new Error(\"not implemented\");\n  } else\n    @throwTypeError(\"url must be a string, URL, or UrlObject\");\n  if (typeof url === \"string\" && query)\n    url = new URL(url);\n  if (typeof url === \"object\" && url !== null && query) {\n    if (query)\n      url.search = new URLSearchParams(query).toString();\n  }\n  if (method = method && typeof method === \"string\" \? method.toUpperCase() : null, inputBody && (method === \"GET\" || method === \"HEAD\"))\n    throw new Error(\"Body not allowed for GET or HEAD requests\");\n  if (inputBody && inputBody.read && inputBody instanceof Readable) {\n    let data = \"\";\n    inputBody.setEncoding(\"utf8\");\n    for await (let chunk of stream)\n      data += chunk;\n    inputBody = (new TextEncoder()).encode(data);\n  }\n  if (maxRedirections !== void 0 && Number.isNaN(maxRedirections))\n    throw new Error(\"maxRedirections must be a number if defined\");\n  if (signal && !(signal instanceof AbortSignal))\n    throw new Error(\"signal must be an instance of AbortSignal\");\n  let resp;\n  const {\n    status: statusCode,\n    headers,\n    trailers\n  } = resp = await fetch(url, {\n    signal,\n    mode: \"cors\",\n    method,\n    headers: inputHeaders || kEmptyObject,\n    body: inputBody,\n    redirect: maxRedirections === \"undefined\" || maxRedirections > 0 \? \"follow\" : \"manual\",\n    keepalive: !reset\n  });\n  if (throwOnError && statusCode >= 400 && statusCode < 600)\n    throw new Error(`Request failed with status code ${statusCode}`);\n  const body = resp.body \? new BodyReadable(resp) : null;\n  return { statusCode, headers: headers.toJSON(), body, trailers, opaque: kEmptyObject, context: kEmptyObject };\n}\nvar stream = function() {\n  throw new Error(\"Not implemented in bun\");\n}, pipeline = function() {\n  throw new Error(\"Not implemented in bun\");\n}, connect = function() {\n  throw new Error(\"Not implemented in bun\");\n}, upgrade = function() {\n  throw new Error(\"Not implemented in bun\");\n}, mockErrors = function() {\n  throw new Error(\"Not implemented in bun\");\n}, Undici = function() {\n  throw new Error(\"Not implemented in bun\");\n}, $, EventEmitter = @getInternalField(@internalModuleRegistry, 16) || @createInternalModuleById(16), StreamModule = @getInternalField(@internalModuleRegistry, 35) || @createInternalModuleById(35), { Readable } = StreamModule, { _ReadableFromWebForUndici: ReadableFromWeb } = StreamModule[Symbol.for(\"::bunternal::\")], ObjectCreate = Object.create, kEmptyObject = ObjectCreate(null), fetch = Bun.fetch, Response = globalThis.Response, Headers = globalThis.Headers, Request = globalThis.Request, URLSearchParams = globalThis.URLSearchParams, URL = globalThis.URL;\n\nclass File extends Blob {\n  constructor() {\n    super(...arguments);\n  }\n}\n\nclass FileReader extends EventTarget {\n  constructor() {\n    throw new Error(\"Not implemented yet!\");\n  }\n}\nvar FormData = globalThis.FormData;\n\nclass BodyReadable extends ReadableFromWeb {\n  #response;\n  #bodyUsed;\n  constructor(response, options = {}) {\n    var { body } = response;\n    if (!body)\n      throw new Error(\"Response body is null\");\n    super(options, body);\n    this.#response = response, this.#bodyUsed = response.bodyUsed;\n  }\n  get bodyUsed() {\n    return this.#bodyUsed;\n  }\n  #consume() {\n    if (this.#bodyUsed)\n      @throwTypeError(\"unusable\");\n    this.#bodyUsed = !0;\n  }\n  async arrayBuffer() {\n    return this.#consume(), await this.#response.arrayBuffer();\n  }\n  async blob() {\n    return this.#consume(), await this.#response.blob();\n  }\n  async formData() {\n    return this.#consume(), await this.#response.formData();\n  }\n  async json() {\n    return this.#consume(), await this.#response.json();\n  }\n  async text() {\n    return this.#consume(), await this.#response.text();\n  }\n}\n\nclass MockClient {\n  constructor() {\n    throw new Error(\"Not implemented in bun\");\n  }\n}\n\nclass MockPool {\n  constructor() {\n    throw new Error(\"Not implemented in bun\");\n  }\n}\n\nclass MockAgent {\n  constructor() {\n    throw new Error(\"Not implemented in bun\");\n  }\n}\n\nclass Dispatcher extends EventEmitter {\n  constructor() {\n    super(...arguments);\n  }\n}\n\nclass Agent extends Dispatcher {\n  constructor() {\n    super(...arguments);\n  }\n}\n\nclass Pool extends Dispatcher {\n  constructor() {\n    super(...arguments);\n  }\n  request() {\n    throw new Error(\"Not implemented in bun\");\n  }\n}\n\nclass BalancedPool extends Dispatcher {\n  constructor() {\n    super(...arguments);\n  }\n}\n\nclass Client extends Dispatcher {\n  constructor() {\n    super(...arguments);\n  }\n  request() {\n    throw new Error(\"Not implemented in bun\");\n  }\n}\nUndici.Dispatcher = Dispatcher;\nUndici.Pool = Pool;\nUndici.BalancedPool = BalancedPool;\nUndici.Client = Client;\nUndici.Agent = Agent;\nUndici.buildConnector = Undici.errors = Undici.setGlobalDispatcher = Undici.getGlobalDispatcher = Undici.request = Undici.stream = Undici.pipeline = Undici.connect = Undici.upgrade = Undici.MockClient = Undici.MockPool = Undici.MockAgent = Undici.mockErrors = notImplemented;\nUndici.fetch = fetch;\n$ = {\n  fetch,\n  Response,\n  Headers,\n  Request,\n  URLSearchParams,\n  URL,\n  File,\n  FileReader,\n  FormData,\n  request,\n  stream,\n  pipeline,\n  connect,\n  upgrade,\n  MockClient,\n  MockPool,\n  MockAgent,\n  mockErrors,\n  Dispatcher,\n  Pool,\n  BalancedPool,\n  Client,\n  Agent,\n  Undici\n};\nreturn $})\n"_s;
//

//
static constexpr ASCIILiteral ThirdpartyVercelFetchCode = "(function (){\"use strict\";// src/js/out/tmp/thirdparty/vercel_fetch.ts\nvar $;\n$ = (wrapper = Bun.fetch) => {\n  async function vercelFetch(url, opts = {}) {\n    if (opts.body && typeof opts.body === \"object\" && (!(\"buffer\" in opts.body) || typeof opts.body.buffer !== \"object\" || !(opts.body.buffer instanceof ArrayBuffer))) {\n      if (opts.body = JSON.stringify(opts.body), !opts.headers)\n        opts.headers = new Headers;\n      opts.headers.set(\"Content-Type\", \"application/json\");\n    }\n    try {\n      return await wrapper(url, opts);\n    } catch (err) {\n      if (typeof err === \"string\")\n        err = new Error(err);\n      throw err.url = url, err.opts = opts, err;\n    }\n  }\n  return vercelFetch.default = vercelFetch, vercelFetch;\n};\nreturn $})\n"_s;
//

//
static constexpr ASCIILiteral ThirdpartyWSCode = "(function (){\"use strict\";// src/js/out/tmp/thirdparty/ws.ts\nvar emitWarning = function(type, message) {\n  if (emittedWarnings.has(type))\n    return;\n  emittedWarnings.add(type), console.warn(\"[bun] Warning:\", message);\n}, subprotocolParse = function(header) {\n  const protocols = new Set;\n  let start = -1, end = -1, i = 0;\n  for (i;i < header.length; i++) {\n    const code = header.charCodeAt(i);\n    if (end === -1 && wsTokenChars[code] === 1) {\n      if (start === -1)\n        start = i;\n    } else if (i !== 0 && (code === 32 || code === 9)) {\n      if (end === -1 && start !== -1)\n        end = i;\n    } else if (code === 44) {\n      if (start === -1)\n        throw new SyntaxError(`Unexpected character at index ${i}`);\n      if (end === -1)\n        end = i;\n      const protocol2 = header.slice(start, end);\n      if (protocols.has(protocol2))\n        throw new SyntaxError(`The \"${protocol2}\" subprotocol is duplicated`);\n      protocols.add(protocol2), start = end = -1;\n    } else\n      throw new SyntaxError(`Unexpected character at index ${i}`);\n  }\n  if (start === -1 || end !== -1)\n    throw new SyntaxError(\"Unexpected end of input\");\n  const protocol = header.slice(start, i);\n  if (protocols.has(protocol))\n    throw new SyntaxError(`The \"${protocol}\" subprotocol is duplicated`);\n  return protocols.add(protocol), protocols;\n}, wsEmitClose = function(server) {\n  server._state = CLOSED, server.emit(\"close\");\n}, abortHandshake = function(response, code, message, headers) {\n  message = message || http.STATUS_CODES[code], headers = {\n    Connection: \"close\",\n    \"Content-Type\": \"text/html\",\n    \"Content-Length\": Buffer.byteLength(message),\n    ...headers\n  }, response.writeHead(code, headers), response.write(message), response.end();\n}, abortHandshakeOrEmitwsClientError = function(server, req, response, socket, code, message) {\n  if (server.listenerCount(\"wsClientError\")) {\n    const err = new Error(message);\n    Error.captureStackTrace(err, abortHandshakeOrEmitwsClientError), server.emit(\"wsClientError\", err, socket, req);\n  } else\n    abortHandshake(response, code, message);\n}, $, EventEmitter = @getInternalField(@internalModuleRegistry, 16) || @createInternalModuleById(16), http = @getInternalField(@internalModuleRegistry, 19) || @createInternalModuleById(19), kBunInternals = Symbol.for(\"::bunternal::\"), readyStates = [\"CONNECTING\", \"OPEN\", \"CLOSING\", \"CLOSED\"], encoder = new TextEncoder, eventIds = {\n  open: 1,\n  close: 2,\n  message: 3,\n  error: 4,\n  ping: 5,\n  pong: 6\n}, emittedWarnings = new Set;\n\nclass BunWebSocket extends EventEmitter {\n  static CONNECTING = 0;\n  static OPEN = 1;\n  static CLOSING = 2;\n  static CLOSED = 3;\n  #ws;\n  #paused = !1;\n  #fragments = !1;\n  #binaryType = \"nodebuffer\";\n  #eventId = 0;\n  constructor(url, protocols, options) {\n    super();\n    let ws = this.#ws = new WebSocket(url, protocols);\n    ws.binaryType = \"nodebuffer\";\n  }\n  on(event, listener) {\n    if (event === \"unexpected-response\" || event === \"upgrade\" || event === \"redirect\")\n      emitWarning(event, \"ws.WebSocket '\" + event + \"' event is not implemented in bun\");\n    const mask = 1 << eventIds[event];\n    if (mask && (this.#eventId & mask) !== mask) {\n      if (this.#eventId |= mask, event === \"open\")\n        this.#ws.addEventListener(\"open\", () => {\n          this.emit(\"open\");\n        });\n      else if (event === \"close\")\n        this.#ws.addEventListener(\"close\", ({ code, reason, wasClean }) => {\n          this.emit(\"close\", code, reason, wasClean);\n        });\n      else if (event === \"message\")\n        this.#ws.addEventListener(\"message\", ({ data }) => {\n          const isBinary = typeof data !== \"string\";\n          if (isBinary)\n            this.emit(\"message\", this.#fragments \? [data] : data, isBinary);\n          else {\n            let encoded = encoder.encode(data);\n            if (this.#binaryType !== \"arraybuffer\")\n              encoded = Buffer.from(encoded.buffer, encoded.byteOffset, encoded.byteLength);\n            this.emit(\"message\", this.#fragments \? [encoded] : encoded, isBinary);\n          }\n        });\n      else if (event === \"error\")\n        this.#ws.addEventListener(\"error\", (err) => {\n          this.emit(\"error\", err);\n        });\n      else if (event === \"ping\")\n        this.#ws.addEventListener(\"ping\", ({ data }) => {\n          this.emit(\"ping\", data);\n        });\n      else if (event === \"pong\")\n        this.#ws.addEventListener(\"pong\", ({ data }) => {\n          this.emit(\"pong\", data);\n        });\n    }\n    return super.on(event, listener);\n  }\n  send(data, opts, cb) {\n    try {\n      this.#ws.send(data, opts\?.compress);\n    } catch (error) {\n      typeof cb === \"function\" && cb(error);\n      return;\n    }\n    typeof cb === \"function\" && cb();\n  }\n  close(code, reason) {\n    this.#ws.close(code, reason);\n  }\n  terminate() {\n    this.#ws.terminate();\n  }\n  get url() {\n    return this.#ws.url;\n  }\n  get readyState() {\n    return this.#ws.readyState;\n  }\n  get binaryType() {\n    return this.#binaryType;\n  }\n  set binaryType(value) {\n    if (value === \"nodebuffer\" || value === \"arraybuffer\")\n      this.#ws.binaryType = this.#binaryType = value, this.#fragments = !1;\n    else if (value === \"fragments\")\n      this.#ws.binaryType = \"nodebuffer\", this.#binaryType = \"fragments\", this.#fragments = !0;\n    else\n      throw new Error(`Invalid binaryType: ${value}`);\n  }\n  get protocol() {\n    return this.#ws.protocol;\n  }\n  get extensions() {\n    return this.#ws.extensions;\n  }\n  addEventListener(type, listener, options) {\n    this.#ws.addEventListener(type, listener, options);\n  }\n  removeEventListener(type, listener) {\n    this.#ws.removeEventListener(type, listener);\n  }\n  get onopen() {\n    return this.#ws.onopen;\n  }\n  set onopen(value) {\n    this.#ws.onopen = value;\n  }\n  get onerror() {\n    return this.#ws.onerror;\n  }\n  set onerror(value) {\n    this.#ws.onerror = value;\n  }\n  get onclose() {\n    return this.#ws.onclose;\n  }\n  set onclose(value) {\n    this.#ws.onclose = value;\n  }\n  get onmessage() {\n    return this.#ws.onmessage;\n  }\n  set onmessage(value) {\n    this.#ws.onmessage = value;\n  }\n  get bufferedAmount() {\n    return this.#ws.bufferedAmount;\n  }\n  get isPaused() {\n    return this.#paused;\n  }\n  ping(data, mask, cb) {\n    if (typeof data === \"function\")\n      cb = data, data = mask = void 0;\n    else if (typeof mask === \"function\")\n      cb = mask, mask = void 0;\n    if (typeof data === \"number\")\n      data = data.toString();\n    try {\n      this.#ws.ping(data);\n    } catch (error) {\n      typeof cb === \"function\" && cb(error);\n      return;\n    }\n    typeof cb === \"function\" && cb();\n  }\n  pong(data, mask, cb) {\n    if (typeof data === \"function\")\n      cb = data, data = mask = void 0;\n    else if (typeof mask === \"function\")\n      cb = mask, mask = void 0;\n    if (typeof data === \"number\")\n      data = data.toString();\n    try {\n      this.#ws.pong(data);\n    } catch (error) {\n      typeof cb === \"function\" && cb(error);\n      return;\n    }\n    typeof cb === \"function\" && cb();\n  }\n  pause() {\n    switch (this.readyState) {\n      case WebSocket.CONNECTING:\n      case WebSocket.CLOSED:\n        return;\n    }\n    this.#paused = !0, emitWarning(\"pause()\", \"ws.WebSocket.pause() is not implemented in bun\");\n  }\n  resume() {\n    switch (this.readyState) {\n      case WebSocket.CONNECTING:\n      case WebSocket.CLOSED:\n        return;\n    }\n    this.#paused = !1, emitWarning(\"resume()\", \"ws.WebSocket.resume() is not implemented in bun\");\n  }\n}\nObject.defineProperty(BunWebSocket, \"name\", { value: \"WebSocket\" });\nvar wsKeyRegex = /^[+/0-9A-Za-z]{22}==$/, wsTokenChars = [\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  1,\n  0,\n  1,\n  1,\n  1,\n  1,\n  1,\n  0,\n  0,\n  1,\n  1,\n  0,\n  1,\n  1,\n  0,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  0,\n  0,\n  0,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  0,\n  1,\n  0,\n  1,\n  0\n], RUNNING = 0, CLOSING = 1, CLOSED = 2;\n\nclass BunWebSocketMocked extends EventEmitter {\n  #ws;\n  #state;\n  #enquedMessages = [];\n  #url;\n  #protocol;\n  #extensions;\n  #bufferedAmount = 0;\n  #binaryType = \"arraybuffer\";\n  #onclose;\n  #onerror;\n  #onmessage;\n  #onopen;\n  constructor(url, protocol, extensions, binaryType) {\n    super();\n    if (this.#ws = null, this.#state = 0, this.#url = url, this.#bufferedAmount = 0, binaryType = binaryType || \"arraybuffer\", binaryType !== \"nodebuffer\" && binaryType !== \"blob\" && binaryType !== \"arraybuffer\")\n      @throwTypeError(\"binaryType must be either 'blob', 'arraybuffer' or 'nodebuffer'\");\n    this.#binaryType = binaryType, this.#protocol = protocol, this.#extensions = extensions;\n    const message = this.#message.bind(this), open = this.#open.bind(this), close = this.#close.bind(this), drain = this.#drain.bind(this);\n    this[kBunInternals] = {\n      message,\n      open,\n      close,\n      drain\n    };\n  }\n  #message(ws, message) {\n    if (this.#ws = ws, typeof message === \"string\")\n      if (this.#binaryType === \"arraybuffer\")\n        message = encoder.encode(message).buffer;\n      else if (this.#binaryType === \"blob\")\n        message = new Blob([message], { type: \"text/plain\" });\n      else\n        message = Buffer.from(message);\n    else if (this.#binaryType !== \"nodebuffer\") {\n      if (this.#binaryType === \"arraybuffer\")\n        message = new Uint8Array(message);\n      else if (this.#binaryType === \"blob\")\n        message = new Blob([message]);\n    }\n    this.emit(\"message\", message);\n  }\n  #open(ws) {\n    this.#ws = ws, this.#state = 1, this.emit(\"open\", this), this.#drain(ws);\n  }\n  #close(ws, code, reason) {\n    this.#state = 3, this.#ws = null, this.emit(\"close\", code, reason);\n  }\n  #drain(ws) {\n    const chunk = this.#enquedMessages[0];\n    if (chunk) {\n      const [data, compress, cb] = chunk;\n      if (ws.send(data, compress) == -1)\n        return;\n      typeof cb === \"function\" && cb(), this.#bufferedAmount -= chunk.length, this.#enquedMessages.shift();\n    }\n  }\n  send(data, opts, cb) {\n    if (this.#state === 1) {\n      const compress = opts\?.compress;\n      if (this.#ws.send(data, compress) == -1) {\n        this.#enquedMessages.push([data, compress, cb]), this.#bufferedAmount += data.length;\n        return;\n      }\n      typeof cb === \"function\" && cb();\n    } else if (this.#state === 0)\n      this.#enquedMessages.push([data, opts\?.compress, cb]), this.#bufferedAmount += data.length;\n  }\n  close(code, reason) {\n    if (this.#state === 1)\n      this.#state = 2, this.#ws.close(code, reason);\n  }\n  get binaryType() {\n    return this.#binaryType;\n  }\n  set binaryType(type) {\n    if (type !== \"nodebuffer\" && type !== \"blob\" && type !== \"arraybuffer\")\n      @throwTypeError(\"binaryType must be either 'blob', 'arraybuffer' or 'nodebuffer'\");\n    this.#binaryType = type;\n  }\n  get readyState() {\n    return this.#state;\n  }\n  get url() {\n    return this.#url;\n  }\n  get protocol() {\n    return this.#protocol;\n  }\n  get extensions() {\n    return this.#extensions;\n  }\n  get bufferedAmount() {\n    return this.#bufferedAmount \?\? 0;\n  }\n  setSocket(socket, head, options) {\n    throw new Error(\"Not implemented\");\n  }\n  set onclose(cb) {\n    if (this.#onclose)\n      this.removeListener(\"close\", this.#onclose);\n    this.on(\"close\", cb), this.#onclose = cb;\n  }\n  set onerror(cb) {\n    if (this.#onerror)\n      this.removeListener(\"error\", this.#onerror);\n    this.on(\"error\", cb), this.#onerror = cb;\n  }\n  set onmessage(cb) {\n    if (this.#onmessage)\n      this.removeListener(\"message\", this.#onmessage);\n    this.on(\"message\", cb), this.#onmessage = cb;\n  }\n  set onopen(cb) {\n    if (this.#onopen)\n      this.removeListener(\"open\", this.#onopen);\n    this.on(\"open\", cb), this.#onopen = cb;\n  }\n  get onclose() {\n    return this.#onclose;\n  }\n  get onerror() {\n    return this.#onerror;\n  }\n  get onmessage() {\n    return this.#onmessage;\n  }\n  get onopen() {\n    return this.#onopen;\n  }\n}\n\nclass WebSocketServer extends EventEmitter {\n  _server;\n  options;\n  clients;\n  _shouldEmitClose;\n  _state;\n  _removeListeners;\n  constructor(options, callback) {\n    super();\n    if (options = {\n      maxPayload: 104857600,\n      skipUTF8Validation: !1,\n      perMessageDeflate: !1,\n      handleProtocols: null,\n      clientTracking: !0,\n      verifyClient: null,\n      noServer: !1,\n      backlog: null,\n      server: null,\n      host: null,\n      path: null,\n      port: null,\n      ...options\n    }, options.port == null && !options.server && !options.noServer || options.port != null && (options.server || options.noServer) || options.server && options.noServer)\n      @throwTypeError('One and only one of the \"port\", \"server\", or \"noServer\" options must be specified');\n    if (options.port != null)\n      this._server = http.createServer((req, res) => {\n        const body = http.STATUS_CODES[426];\n        res.writeHead(426, {\n          \"Content-Length\": body.length,\n          \"Content-Type\": \"text/plain\"\n        }), res.end(body);\n      }), this._server.listen(options.port, options.host, options.backlog, callback);\n    else if (options.server)\n      this._server = options.server;\n    if (this._server) {\n      const emitConnection = this.emit.bind(this, \"connection\"), emitListening = this.emit.bind(this, \"listening\"), emitError = this.emit.bind(this, \"error\"), doUpgrade = (req, socket, head) => {\n        this.handleUpgrade(req, socket, head, emitConnection);\n      };\n      this._server.on(\"listening\", emitListening), this._server.on(\"error\", emitError), this._server.on(\"upgrade\", doUpgrade), this._removeListeners = () => {\n        this._server.removeListener(\"upgrade\", doUpgrade), this._server.removeListener(\"listening\", emitListening), this._server.removeListener(\"error\", emitError);\n      };\n    }\n    if (options.perMessageDeflate === !0)\n      options.perMessageDeflate = {};\n    if (options.clientTracking)\n      this.clients = new Set, this._shouldEmitClose = !1;\n    this.options = options, this._state = RUNNING;\n  }\n  address() {\n    if (this.options.noServer)\n      throw new Error('The server is operating in \"noServer\" mode');\n    if (!this._server)\n      return null;\n    return this._server.address();\n  }\n  close(cb) {\n    if (this._state === CLOSED) {\n      if (cb)\n        this.once(\"close\", () => {\n          cb(new Error(\"The server is not running\"));\n        });\n      process.nextTick((server) => {\n        server._state = CLOSED, server.emit(\"close\");\n      }, this);\n      return;\n    }\n    if (cb)\n      this.once(\"close\", cb);\n    if (this._state === CLOSING)\n      return;\n    if (this._state = CLOSING, this.options.noServer || this.options.server) {\n      if (this._server)\n        this._removeListeners(), this._removeListeners = this._server = null;\n      if (this.clients)\n        if (!this.clients.size)\n          process.nextTick((server) => {\n            server._state = CLOSED, server.emit(\"close\");\n          }, this);\n        else\n          this._shouldEmitClose = !0;\n      else\n        process.nextTick((server) => {\n          server._state = CLOSED, server.emit(\"close\");\n        }, this);\n    } else {\n      const server = this._server;\n      this._removeListeners(), this._removeListeners = this._server = null, server.close(() => {\n        this._state = CLOSED, this.emit(\"close\");\n      });\n    }\n  }\n  shouldHandle(req) {\n    if (this.options.path) {\n      const index = req.url.indexOf(\"\?\");\n      if ((index !== -1 \? req.url.slice(0, index) : req.url) !== this.options.path)\n        return !1;\n    }\n    return !0;\n  }\n  completeUpgrade(extensions, key, protocols, request, socket, head, cb) {\n    const [server, response, req] = socket[kBunInternals];\n    if (this._state > RUNNING)\n      return abortHandshake(response, 503);\n    let protocol = \"\";\n    if (protocols.size)\n      protocol = this.options.handleProtocols \? this.options.handleProtocols(protocols, request) : protocols.values().next().value;\n    const ws = new BunWebSocketMocked(request.url, protocol, extensions, \"nodebuffer\"), headers = [\"HTTP/1.1 101 Switching Protocols\", \"Upgrade: websocket\", \"Connection: Upgrade\"];\n    if (this.emit(\"headers\", headers, request), server.upgrade(req, {\n      data: ws[kBunInternals]\n    })) {\n      if (response._reply(void 0), this.clients)\n        this.clients.add(ws), ws.on(\"close\", () => {\n          if (this.clients.delete(ws), this._shouldEmitClose && !this.clients.size)\n            process.nextTick(wsEmitClose, this);\n        });\n      cb(ws, request);\n    } else\n      abortHandshake(response, 500);\n  }\n  handleUpgrade(req, socket, head, cb) {\n    const [_, response] = socket[kBunInternals], key = req.headers[\"sec-websocket-key\"], version = +req.headers[\"sec-websocket-version\"];\n    if (req.method !== \"GET\") {\n      abortHandshakeOrEmitwsClientError(this, req, response, socket, 405, \"Invalid HTTP method\");\n      return;\n    }\n    if (req.headers.upgrade.toLowerCase() !== \"websocket\") {\n      abortHandshakeOrEmitwsClientError(this, req, response, socket, 400, \"Invalid Upgrade header\");\n      return;\n    }\n    if (!key || !wsKeyRegex.test(key)) {\n      abortHandshakeOrEmitwsClientError(this, req, response, socket, 400, \"Missing or invalid Sec-WebSocket-Key header\");\n      return;\n    }\n    if (version !== 8 && version !== 13) {\n      abortHandshakeOrEmitwsClientError(this, req, response, socket, 400, \"Missing or invalid Sec-WebSocket-Version header\");\n      return;\n    }\n    if (!this.shouldHandle(req)) {\n      abortHandshake(response, 400);\n      return;\n    }\n    const secWebSocketProtocol = req.headers[\"sec-websocket-protocol\"];\n    let protocols = new Set;\n    if (secWebSocketProtocol !== void 0)\n      try {\n        protocols = subprotocolParse(secWebSocketProtocol);\n      } catch (err) {\n        abortHandshakeOrEmitwsClientError(this, req, response, socket, 400, \"Invalid Sec-WebSocket-Protocol header\");\n        return;\n      }\n    const extensions = {};\n    if (this.options.verifyClient) {\n      const info = {\n        origin: req.headers[`${version === 8 \? \"sec-websocket-origin\" : \"origin\"}`],\n        secure: !!(req.socket.authorized || req.socket.encrypted),\n        req\n      };\n      if (this.options.verifyClient.length === 2) {\n        this.options.verifyClient(info, (verified, code, message, headers) => {\n          if (!verified)\n            return abortHandshake(response, code || 401, message, headers);\n          this.completeUpgrade(extensions, key, protocols, req, socket, head, cb);\n        });\n        return;\n      }\n      if (!this.options.verifyClient(info))\n        return abortHandshake(response, 401);\n    }\n    this.completeUpgrade(extensions, key, protocols, req, socket, head, cb);\n  }\n}\nObject.defineProperty(BunWebSocket, \"CONNECTING\", {\n  enumerable: !0,\n  value: readyStates.indexOf(\"CONNECTING\")\n});\nObject.defineProperty(BunWebSocket.prototype, \"CONNECTING\", {\n  enumerable: !0,\n  value: readyStates.indexOf(\"CONNECTING\")\n});\nObject.defineProperty(BunWebSocket, \"OPEN\", {\n  enumerable: !0,\n  value: readyStates.indexOf(\"OPEN\")\n});\nObject.defineProperty(BunWebSocket.prototype, \"OPEN\", {\n  enumerable: !0,\n  value: readyStates.indexOf(\"OPEN\")\n});\nObject.defineProperty(BunWebSocket, \"CLOSING\", {\n  enumerable: !0,\n  value: readyStates.indexOf(\"CLOSING\")\n});\nObject.defineProperty(BunWebSocket.prototype, \"CLOSING\", {\n  enumerable: !0,\n  value: readyStates.indexOf(\"CLOSING\")\n});\nObject.defineProperty(BunWebSocket, \"CLOSED\", {\n  enumerable: !0,\n  value: readyStates.indexOf(\"CLOSED\")\n});\nObject.defineProperty(BunWebSocket.prototype, \"CLOSED\", {\n  enumerable: !0,\n  value: readyStates.indexOf(\"CLOSED\")\n});\n\nclass Sender {\n  constructor() {\n    throw new Error(\"Not supported yet in Bun\");\n  }\n}\n\nclass Receiver {\n  constructor() {\n    throw new Error(\"Not supported yet in Bun\");\n  }\n}\nvar createWebSocketStream = (ws) => {\n  throw new Error(\"Not supported yet in Bun\");\n};\n$ = Object.assign(BunWebSocket, {\n  createWebSocketStream,\n  Receiver,\n  Sender,\n  WebSocket: BunWebSocket,\n  Server: WebSocketServer,\n  WebSocketServer\n});\nreturn $})\n"_s;
//

#endif

}
}