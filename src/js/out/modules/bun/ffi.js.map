{
  "version": 3,
  "sources": ["src/js/bun/ffi.js"],
  "sourcesContent": [
    "// --- FFIType ---\n\nexport const suffix =\n  process.platform === \"darwin\"\n    ? \"dylib\"\n    : process.platform === \"linux\"\n    ? \"so\"\n    : process.platform === \"win32\"\n    ? \"dll\"\n    : $bundleError(\"Unsupported platform\");\n\nvar ffi = globalThis.Bun.FFI;\nexport const ptr = (arg1, arg2) => (typeof arg2 === \"undefined\" ? ffi.ptr(arg1) : ffi.ptr(arg1, arg2));\nexport const toBuffer = ffi.toBuffer;\nexport const toArrayBuffer = ffi.toArrayBuffer;\nexport const viewSource = ffi.viewSource;\n\nconst BunCString = ffi.CString;\nconst nativeLinkSymbols = ffi.linkSymbols;\nconst nativeDLOpen = ffi.dlopen;\nconst nativeCallback = ffi.callback;\nconst closeCallback = ffi.closeCallback;\ndelete ffi.callback;\ndelete ffi.closeCallback;\n\nexport class JSCallback {\n  constructor(cb, options) {\n    const { ctx, ptr } = nativeCallback(options, cb);\n    this.#ctx = ctx;\n    this.ptr = ptr;\n    this.#threadsafe = !!options?.threadsafe;\n  }\n\n  ptr;\n  #ctx;\n  #threadsafe;\n\n  get threadsafe() {\n    return this.#threadsafe;\n  }\n\n  [Symbol.toPrimitive]() {\n    const { ptr } = this;\n    return typeof ptr === \"number\" ? ptr : 0;\n  }\n\n  close() {\n    const ctx = this.#ctx;\n    this.ptr = null;\n    this.#ctx = null;\n\n    if (ctx) {\n      closeCallback(ctx);\n    }\n  }\n}\n\nexport class CString extends String {\n  constructor(ptr, byteOffset, byteLength) {\n    super(\n      ptr\n        ? typeof byteLength === \"number\" && Number.isSafeInteger(byteLength)\n          ? new BunCString(ptr, byteOffset || 0, byteLength)\n          : new BunCString(ptr)\n        : \"\",\n    );\n    this.ptr = typeof ptr === \"number\" ? ptr : 0;\n    if (typeof byteOffset !== \"undefined\") {\n      this.byteOffset = byteOffset;\n    }\n    if (typeof byteLength !== \"undefined\") {\n      this.byteLength = byteLength;\n    }\n  }\n\n  ptr;\n  byteOffset;\n  byteLength;\n  #cachedArrayBuffer;\n\n  get arrayBuffer() {\n    if (this.#cachedArrayBuffer) {\n      return this.#cachedArrayBuffer;\n    }\n\n    if (!this.ptr) {\n      return (this.#cachedArrayBuffer = new ArrayBuffer(0));\n    }\n\n    return (this.#cachedArrayBuffer = toArrayBuffer(this.ptr, this.byteOffset, this.byteLength));\n  }\n}\nObject.defineProperty(globalThis, \"__GlobalBunCString\", {\n  value: CString,\n  enumerable: false,\n  configurable: false,\n});\n\nconst ffiWrappers = new Array(18);\n\nvar char = val => val | 0;\nffiWrappers.fill(char);\nffiWrappers[FFIType.uint8_t] = function uint8(val) {\n  return val < 0 ? 0 : val >= 255 ? 255 : val | 0;\n};\nffiWrappers[FFIType.int16_t] = function int16(val) {\n  return val <= -32768 ? -32768 : val >= 32768 ? 32768 : val | 0;\n};\nffiWrappers[FFIType.uint16_t] = function uint16(val) {\n  return val <= 0 ? 0 : val >= 65536 ? 65536 : val | 0;\n};\nffiWrappers[FFIType.int32_t] = function int32(val) {\n  return val | 0;\n};\n// we never want to return NaN\nffiWrappers[FFIType.uint32_t] = function uint32(val) {\n  return val <= 0 ? 0 : val >= 0xffffffff ? 0xffffffff : +val || 0;\n};\nffiWrappers[FFIType.i64_fast] = function int64(val) {\n  if (typeof val === \"bigint\") {\n    if (val <= BigInt(Number.MAX_SAFE_INTEGER) && val >= BigInt(-Number.MAX_SAFE_INTEGER)) {\n      return Number(val).valueOf() || 0;\n    }\n\n    return val;\n  }\n\n  return !val ? 0 : +val || 0;\n};\n\nffiWrappers[FFIType.u64_fast] = function u64_fast(val) {\n  if (typeof val === \"bigint\") {\n    if (val <= BigInt(Number.MAX_SAFE_INTEGER) && val >= 0) {\n      return Number(val).valueOf() || 0;\n    }\n\n    return val;\n  }\n\n  return !val ? 0 : +val || 0;\n};\n\nffiWrappers[FFIType.int64_t] = function int64(val) {\n  if (typeof val === \"bigint\") {\n    return val;\n  }\n\n  if (typeof val === \"number\") {\n    return BigInt(val || 0);\n  }\n\n  return BigInt(+val || 0);\n};\n\nffiWrappers[FFIType.uint64_t] = function uint64(val) {\n  if (typeof val === \"bigint\") {\n    return val;\n  }\n\n  if (typeof val === \"number\") {\n    return val <= 0 ? BigInt(0) : BigInt(val || 0);\n  }\n\n  return BigInt(+val || 0);\n};\n\nffiWrappers[FFIType.u64_fast] = function u64_fast(val) {\n  if (typeof val === \"bigint\") {\n    if (val <= BigInt(Number.MAX_SAFE_INTEGER) && val >= BigInt(0)) return Number(val);\n    return val;\n  }\n\n  return typeof val === \"number\" ? (val <= 0 ? 0 : +val || 0) : +val || 0;\n};\n\nffiWrappers[FFIType.uint16_t] = function uint16(val) {\n  const ret = (typeof val === \"bigint\" ? Number(val) : val) | 0;\n  return ret <= 0 ? 0 : ret > 0xffff ? 0xffff : ret;\n};\n\nffiWrappers[FFIType.double] = function double(val) {\n  if (typeof val === \"bigint\") {\n    if (val.valueOf() < BigInt(Number.MAX_VALUE)) {\n      return Math.abs(Number(val).valueOf()) + 0.00000000000001 - 0.00000000000001;\n    }\n  }\n\n  if (!val) {\n    return 0 + 0.00000000000001 - 0.00000000000001;\n  }\n\n  return val + 0.00000000000001 - 0.00000000000001;\n};\n\nffiWrappers[FFIType.float] = ffiWrappers[10] = function float(val) {\n  return Math.fround(val);\n};\nffiWrappers[FFIType.bool] = function bool(val) {\n  return !!val;\n};\n\n// This prevents an extra property getter in potentially hot code\nObject.defineProperty(globalThis, \"__GlobalBunFFIPtrFunctionForWrapper\", {\n  value: ptr,\n  enumerable: false,\n  configurable: true,\n});\n\nffiWrappers[FFIType.cstring] = ffiWrappers[FFIType.pointer] = function pointer(val) {\n  if (typeof val === \"number\") return val;\n  if (!val) {\n    return null;\n  }\n\n  if (ArrayBuffer.isView(val) || val instanceof ArrayBuffer) {\n    return __GlobalBunFFIPtrFunctionForWrapper(val);\n  }\n\n  if (typeof val === \"string\") {\n    throw new TypeError(\"To convert a string to a pointer, encode it as a buffer\");\n  }\n\n  throw new TypeError(`Unable to convert ${val} to a pointer`);\n};\n\nfunction cstringReturnType(val) {\n  return new __GlobalBunCString(val);\n}\n\nffiWrappers[FFIType.function] = function functionType(val) {\n  if (typeof val === \"number\") {\n    return val;\n  }\n\n  if (typeof val === \"bigint\") {\n    return Number(val);\n  }\n\n  var ptr = val && val.ptr;\n\n  if (!ptr) {\n    throw new TypeError(\"Expected function to be a JSCallback or a number\");\n  }\n\n  return ptr;\n};\n\nfunction FFIBuilder(params, returnType, functionToCall, name) {\n  const hasReturnType = typeof FFIType[returnType] === \"number\" && FFIType[returnType] !== FFIType.void;\n  var paramNames = new Array(params.length);\n  var args = new Array(params.length);\n  for (let i = 0; i < params.length; i++) {\n    paramNames[i] = `p${i}`;\n    const wrapper = ffiWrappers[FFIType[params[i]]];\n    if (wrapper) {\n      // doing this inline benchmarked about 4x faster than referencing\n      args[i] = `(${wrapper.toString()})(p${i})`;\n    } else {\n      throw new TypeError(`Unsupported type ${params[i]}. Must be one of: ${Object.keys(FFIType).sort().join(\", \")}`);\n    }\n  }\n\n  var code = `functionToCall(${args.join(\", \")})`;\n  if (hasReturnType) {\n    if (FFIType[returnType] === FFIType.cstring) {\n      code = `return (${cstringReturnType.toString()})(${code})`;\n    } else {\n      code = `return ${code}`;\n    }\n  }\n\n  var func = new Function(\"functionToCall\", ...paramNames, code);\n  Object.defineProperty(func, \"name\", {\n    value: name,\n  });\n\n  // variadic arguments can be expensive\n  // most FFI functions are going to be < 5 arguments\n  // so we just inline it\n  var wrap;\n  switch (paramNames.length) {\n    case 0:\n      wrap = () => func(functionToCall);\n      break;\n    case 1:\n      wrap = arg1 => func(functionToCall, arg1);\n      break;\n    case 2:\n      wrap = (arg1, arg2) => func(functionToCall, arg1, arg2);\n      break;\n    case 3:\n      wrap = (arg1, arg2, arg3) => func(functionToCall, arg1, arg2, arg3);\n      break;\n    case 4:\n      wrap = (arg1, arg2, arg3, arg4) => func(functionToCall, arg1, arg2, arg3, arg4);\n      break;\n    case 5:\n      wrap = (arg1, arg2, arg3, arg4, arg5) => func(functionToCall, arg1, arg2, arg3, arg4, arg5);\n      break;\n    case 6:\n      wrap = (arg1, arg2, arg3, arg4, arg5, arg6) => func(functionToCall, arg1, arg2, arg3, arg4, arg5, arg6);\n      break;\n    case 7:\n      wrap = (arg1, arg2, arg3, arg4, arg5, arg6, arg7) =>\n        func(functionToCall, arg1, arg2, arg3, arg4, arg5, arg6, arg7);\n      break;\n    case 8:\n      wrap = (arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) =>\n        func(functionToCall, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);\n      break;\n    case 9:\n      wrap = (arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9) =>\n        func(functionToCall, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9);\n      break;\n    default: {\n      wrap = (...args) => func(functionToCall, ...args);\n      break;\n    }\n  }\n\n  wrap.native = functionToCall;\n  wrap.ptr = functionToCall.ptr;\n  return wrap;\n}\n\nexport const native = {\n  dlopen: nativeDLOpen,\n  callback: () => {\n    throw new Error(\"Deprecated. Use new JSCallback(options, fn) instead\");\n  },\n};\n\nexport function dlopen(path, options) {\n  const result = nativeDLOpen(path, options);\n\n  for (let key in result.symbols) {\n    var symbol = result.symbols[key];\n    if (options[key]?.args?.length || FFIType[options[key]?.returns] === FFIType.cstring) {\n      result.symbols[key] = FFIBuilder(\n        options[key].args ?? [],\n        options[key].returns ?? FFIType.void,\n        symbol,\n        // in stacktraces:\n        // instead of\n        //    \"/usr/lib/sqlite3.so\"\n        // we want\n        //    \"sqlite3_get_version() - sqlit3.so\"\n        path.includes(\"/\") ? `${key} (${path.split(\"/\").pop()})` : `${key} (${path})`,\n      );\n    } else {\n      // consistentcy\n      result.symbols[key].native = result.symbols[key];\n    }\n  }\n\n  return result;\n}\n\nexport function linkSymbols(options) {\n  const result = nativeLinkSymbols(options);\n\n  for (let key in result.symbols) {\n    var symbol = result.symbols[key];\n    if (options[key]?.args?.length || FFIType[options[key]?.returns] === FFIType.cstring) {\n      result.symbols[key] = FFIBuilder(options[key].args ?? [], options[key].returns ?? FFIType.void, symbol, key);\n    } else {\n      // consistentcy\n      result.symbols[key].native = result.symbols[key];\n    }\n  }\n\n  return result;\n}\n\nvar cFunctionI = 0;\nvar cFunctionRegistry;\nfunction onCloseCFunction(close) {\n  close();\n}\nexport function CFunction(options) {\n  const identifier = `CFunction${cFunctionI++}`;\n  var result = linkSymbols({\n    [identifier]: options,\n  });\n  var hasClosed = false;\n  var close = result.close;\n  result.symbols[identifier].close = () => {\n    if (hasClosed || !close) return;\n    hasClosed = true;\n    close();\n    close = undefined;\n  };\n\n  cFunctionRegistry ||= new FinalizationRegistry(onCloseCFunction);\n  cFunctionRegistry.register(result.symbols[identifier], result.symbols[identifier].close);\n\n  return result.symbols[identifier];\n}\n\nexport const read = ffi.read;\n"
  ],
  "mappings": "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",
  "debugId": "57507DFEA306791064756e2164756e21",
  "names": []
}