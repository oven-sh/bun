function Cq(q,Q,Z){Z=vq(q,Q,Z),dq(Z.timeout),aq(Z.signal,"options.signal");const $=bq(Z.killSignal),W=new Eq;if(R("spawn",Z),W.spawn(Z),Z.timeout>0){let X=setTimeout(()=>{if(X){try{W.kill($)}catch(J){W.emit("error",J)}X=null}});W.once("exit",()=>{if(X)clearTimeout(X),X=null})}if(Z.signal){let J=function(){mq(W,$)};const X=Z.signal;if(X.aborted)process.nextTick(J);else X.addEventListener("abort",J,{once:!0}),W.once("exit",()=>X.removeEventListener("abort",J))}return W}function Tq(q,Q,Z,$){({file:q,args:Q,options:Z,callback:$}=Iq(q,Q,Z,$)),Z={encoding:"utf8",timeout:0,maxBuffer:Dq,killSignal:"SIGTERM",cwd:null,env:null,shell:!1,...Z};const W=Z.maxBuffer;dq(Z.timeout),cq(W),Z.killSignal=bq(Z.killSignal);const X=Cq(q,Q,{cwd:Z.cwd,env:Z.env,shell:Z.shell,signal:Z.signal});let J;const K=[],H=[];if(Z.encoding!=="buffer"&&Zq(Z.encoding))J=Z.encoding;else J=null;let z=0,M=0,Y=!1,F=!1,j,w,D,G=null,V=q;function C(B,O){if(F)return;if(F=!0,j)clearTimeout(j),j=null;if(!$)return;const P=X?.stdout?.readableEncoding;let N,x;if(J||X.stdout&&P)N=S.call(K,"");else N=f(K);if(J||X.stderr&&P)x=S.call(H,"");else x=f(H);if(!G&&B===0&&O===null){$(null,N,x);return}if(Q?.length)V+=` ${S.call(Q," ")}`;if(!G){let b=`Command failed: ${V}`;if(x)b+=`\n${x}`;G=XQ(b,{code:B,killed:X.killed||Y,signal:O})}G.cmd=V,$(G,N,x)}function T(B){if(G=B,X.stdout)X.stdout.destroy();if(X.stderr)X.stderr.destroy();C()}function U(){if(X.stdout)X.stdout.destroy();if(X.stderr)X.stderr.destroy();Y=!0;try{X.kill(Z.killSignal)}catch(B){G=B,C()}}if(Z.timeout>0)j=setTimeout(function B(){U(),j=null},Z.timeout);if(X.stdout){if(J)X.stdout.setEncoding(J);X.stdout.on("data",W===Infinity?function B(O){y.call(K,O)}:J?function B(O){if(z+=O.length,z*4>W){const P=X.stdout.readableEncoding,N=L.byteLength(O,P);if(w===void 0)for(let b=0;b<K.length;b++)w+=L.byteLength(K[b],P);else w+=N;const x=W-(w-N);y.call(K,E.apply(O,0,x)),G=new v("stdout"),U()}else y.call(K,O)}:function B(O){if(z+=O.length,z>W){const P=W-(z-O.length);y.call(K,O.slice(0,P)),G=new v("stdout"),U()}else y.call(K,O)})}if(X.stderr){if(J)X.stderr.setEncoding(J);X.stderr.on("data",W===Infinity?function B(O){y.call(H,O)}:J?function B(O){if(M+=O.length,M*4>W){const P=X.stderr.readableEncoding,N=L.byteLength(O,P);if(D===void 0)for(let b=0;b<H.length;b++)D+=L.byteLength(H[b],P);else D+=N;const x=W-(D-N);y.call(H,E.call(O,0,x)),G=new v("stderr"),U()}else y.call(H,O)}:function B(O){if(M+=O.length,M>W){const P=W-(M-O.length);y.call(H,E.call(O,0,P)),G=new v("stderr"),U()}else y.call(H,O)})}return X.addListener("close",C),X.addListener("error",T),X}function m(q,Q,Z){const $=Lq(q,Q,Z);return Tq($.file,$.options,$.callback)}function Bq(q,Q,Z){Z={maxBuffer:Dq,...vq(q,Q,Z)};const{maxBuffer:$,encoding:W}=Z;R("spawnSync",Z),dq(Z.timeout),cq($),Z.killSignal=bq(Z.killSignal);const X=Z.stdio||"pipe",J=_q(X);var{input:K}=Z;if(K)if(Mq(K))J[0]=K;else if(typeof K==="string")J[0]=L.from(K,W||"utf8");else throw new g(`options.stdio[0]`,["Buffer","TypedArray","DataView","string"],K);const{stdout:H,stderr:z,success:M,exitCode:Y}=Bun.spawnSync({cmd:Z.args,env:Z.env||void 0,cwd:Z.cwd||void 0,stdin:J[0],stdout:J[1],stderr:J[2]}),F={signal:null,status:Y,output:[null,H,z]};if(H&&W&&W!=="buffer")F.output[1]=F.output[1]?.toString(W);if(z&&W&&W!=="buffer")F.output[2]=F.output[2]?.toString(W);if(F.stdout=F.output[1],F.stderr=F.output[2],!M)F.error=new zQ(F.output[2],Z.file,"spawnSync",-1,F.status),F.error.spawnargs=Hq.call(Z.args,1);return F}function Oq(q,Q,Z){({file:q,args:Q,options:Z}=Iq(q,Q,Z));const $=Bq(q,Q,Z),W=[Z.argv0||q];y.apply(W,Q);const X=Sq($,W);if(X)throw X;return $.stdout}function Pq(q,Q){const Z=Lq(q,Q,null),$=Bq(Z.file,Z.options),W=Sq($,void 0,q);if(W)throw W;return $.stdout}function Nq(){throw new QQ("Not implemented")}var xq=function(q){if(typeof q==="number"&&yq()[q])return q;if(typeof q==="string"){const Q=A[Fq.call(q)];if(Q)return Q}throw new KQ(q)},bq=function(q){if(typeof q==="string"||typeof q==="number")return xq(q);else if(q!=null)throw new g("options.killSignal",["string","number"],q)},yq=function(){if(I!==void 0)return I;I=o(null);for(let q in A)I[A[q]]=q;return I},Iq=function(q,Q,Z,$){if(zq(Q))Q=Hq.call(Q);else if(Q!=null&&typeof Q==="object")$=Z,Z=Q,Q=null;else if(typeof Q==="function")$=Q,Z=null,Q=null;if(Q==null)Q=[];if(typeof Z==="function")$=Z;else if(Z!=null)rq(Z,"options");if(Z==null)Z=$q;if($!=null)lq($,"callback");if(Z.argv0!=null)u(Z.argv0,"options.argv0"),_(Z.argv0,"options.argv0");return{file:q,args:Q,options:Z,callback:$}},Lq=function(q,Q,Z){if(u(q,"command"),_(q,"command"),typeof Q==="function")Z=Q,Q=void 0;return Q={...Q},Q.shell=typeof Q.shell==="string"?Q.shell:!0,{file:q,options:Q,callback:Z}},vq=function(q,Q,Z){if(u(q,"file"),_(q,"file"),q.length===0)throw new HQ("file",q,"cannot be empty");if(zq(Q))Q=Hq.call(Q);else if(Q==null)Q=[];else if(typeof Q!=="object")throw new g("args","object",Q);else Z=Q,Q=[];if(pq(Q,"args"),Z===void 0)Z={};else rq(Z,"options");let $=Z.cwd;if($!=null)$=tq($,"options.cwd");if(Z.shell!=null&&typeof Z.shell!=="boolean"&&typeof Z.shell!=="string")throw new g("options.shell",["boolean","string"],Z.shell);if(Z.argv0!=null)u(Z.argv0,"options.argv0"),_(Z.argv0,"options.argv0");if(Z.shell){_(Z.shell,"options.shell");const J=S.call([q,...Q]," ");if(typeof Z.shell==="string")q=Z.shell;else q="sh";Q=["-c",J]}if(typeof Z.argv0==="string")h.call(Q,Z.argv0);else h.call(Q,q);const X=Z.env||process.env;return{...Z,file:q,args:Q,cwd:$,envPairs:X}},Sq=function(q,Q,Z){let $;if(q.error)$=q.error,qq($,q);else if(q.status!==0){let W="Command failed: ";if(W+=Z||S.call(Q," "),q.stderr&&q.stderr.length>0)W+=`\n${q.stderr.toString()}`;$=XQ(W,q)}return $},kq=function(q){if(typeof q==="number")return q;else{const Q=Rq[q];if(Q===void 0)throw new QQ("Invalid stdio option");return Q}},k=function(q){switch(q){case 0:return"stdin";case 1:return"stdout";case 2:return"stderr";default:return null}},_q=function(q){return Aq(q).map(($)=>kq($))},Aq=function(q){if(typeof q==="string")switch(q){case"ignore":return["ignore","ignore","ignore"];case"pipe":return["pipe","pipe","pipe"];case"inherit":return["inherit","inherit","inherit"];default:throw new c("stdio",q)}else if(zq(q)){let Q;if(q.length===0)Q=["pipe","pipe","pipe"];else if(q.length===1)Q=[q[0],"pipe","pipe"];else if(q.length===2)Q=[q[0],q[1],"pipe"];else if(q.length>=3)Q=[q[0],q[1],q[2]];return Q.map((Z)=>!Z?"pipe":Z)}else throw new c("stdio",q)},fq=function(q){const Q=q.stdio;if(Q==null)return;for(let Z=0;Z<Q.length;Z++){const $=Q[Z];if(!$||!$.readable)continue;$.resume()}},hq=function(q){q.emit("spawn")},mq=function(q,Q){if(!q)return;try{if(q.kill(Q))q.emit("error",new WQ)}catch(Z){q.emit("error",Z)}},cq=function(q){if(q!=null&&!(typeof q==="number"&&q>=0))throw new JQ("options.maxBuffer","a positive number",q)},_=function(q,Q){if(typeof q==="string"&&jq.call(q,"\0"))throw new HQ(Q,q,"must be a string without null bytes")},pq=function(q,Q){for(let Z=0;Z<q.length;++Z)_(q[Z],`${Q}[${Z}]`)},dq=function(q){if(q!=null&&!(Yq(q)&&q>=0))throw new JQ("timeout","an unsigned integer",q)};var lq=function(q,Q){if(typeof q!=="function")throw new g(Q,"Function",q)},u=function(q,Q){if(typeof q!=="string")throw new g(Q,"string",q)},nq=function(q,Q,Z=!0){const $=typeof q==="string",W=eq(q);if(!$&&!W||$&&!jq.call(q,"\0")||W&&!wq.call(q,0))return;const X=new HQ(Q,q,"must be a string or Uint8Array without null bytes");if(Z)throw X;return X},iq=function(q,Q="path"){if(typeof q!=="string"&&!eq(q))throw new g(Q,["string","Buffer","URL"],q);const Z=nq(q,Q,!1);if(Z!==void 0)throw Z},tq=function(q,Q="path"){const Z=qQ(q);return iq(Z,Q),Z},eq=function(q){return typeof q==="object"&&q!==null&&q instanceof s},oq=function(q){return q!=null&&q.href&&q.origin},qQ=function(q){if(!oq(q))return q;return Bun.fileURLToPath(q)},XQ=function(q,Q){const Z=new QQ(q);return Z.code=Q.code,Z.killed=Q.killed,Z.signal=Q.signal,Z},JQ=function(q,Q,Z,$=!1){return new $Q(`The value of ${q} is out of range. It must be ${Q}. Received ${Z}`)},v=function(q){return QQ(`${q} maxBuffer length exceeded`)},KQ=function(q){const Q=new ZQ(`Unknown signal: ${q}`);return Q.code="ERR_UNKNOWN_SIGNAL",Q},g=function(q,Q,Z){const $=new ZQ(`The "${q}" argument must be of type ${Q}. Received ${Z}`);return $.code="ERR_INVALID_ARG_TYPE",$},c=function(q,Q){return new ZQ(`The value "${Q}" is invalid for option "${q}"`)},HQ=function(q,Q,Z){return new QQ(`The value "${Q}" is invalid for argument '${q}'. Reason: ${Z}`)},p=import.meta.require("node:events"),{Readable:{fromWeb:d},NativeWritable:l}=import.meta.require("node:stream"),{constants:{signals:A}}=import.meta.require("node:os"),{promisify:a}=import.meta.require("node:util"),{ArrayBuffer:r,Uint8Array:s,String:n,Object:i,Buffer:L,Promise:t}=import.meta.primordials,e=i.prototype.hasOwnProperty,o=i.create,qq=i.assign,Qq=i.defineProperty,f=L.concat,Zq=L.isEncoding,$q=o(null),y=Array.prototype.push,Wq=Array.prototype.reduce,Xq=Array.prototype.filter,S=Array.prototype.join,Jq=Array.prototype.map,Kq=Array.prototype.includes,Hq=Array.prototype.slice,h=Array.prototype.unshift,zq=Array.isArray,Mq=r.isView,Yq=Number.isInteger;var Fq=n.prototype.toUpperCase,jq=n.prototype.includes,E=n.prototype.slice,wq=s.prototype.includes,Dq=1048576,Gq=process.env.DEBUG||!1,Vq=process.env.DEBUG_STDIO,R=Gq?console.log:()=>{};if(Vq)R("child_process: debug mode on"),globalThis.__lastId=null,globalThis.__getId=()=>{return globalThis.__lastId!==null?globalThis.__lastId++:0};var Uq=(q)=>{return(...Q)=>{let Z,$;const W=new t((X,J)=>{Z=X,$=J});return W.child=q(...Q,(X,J,K)=>{if(X!==null)X.stdout=J,X.stderr=K,$(X);else Z({stdout:J,stderr:K})}),W}};Qq(m,a.custom,{__proto__:null,enumerable:!1,value:Uq(m)});var I;class Eq extends p{#q;#Q=!1;#Z=1;#$=0;connected=!1;signalCode=null;exitCode=null;spawnfile;spawnargs;pid;channel;get killed(){if(this.#q==null)return!1}#W(q,Q,Z){if(this.#Q)return;if(this.exitCode=this.#q.exitCode,this.signalCode=q>0?Q:null,this.#J)this.#J.destroy();if(this.#q)this.#q=null;if(q<0){const $=new zQ(`Spawned process exited with error code: ${q}`,void 0,"spawn","EUNKNOWN","ERR_CHILD_PROCESS_UNKNOWN_ERROR");if(this.spawnfile)$.path=this.spawnfile;$.spawnargs=Hq.call(this.spawnargs,1),this.emit("error",$)}else this.emit("exit",this.exitCode,this.signalCode);process.nextTick(fq,this),this.#j(),this.#Q=!0,this.#Y=["destroyed","destroyed","destroyed"]}#X(q,Q){if(Gq&&!this.#q)if(this.#q===null)R("ChildProcess: getBunSpawnIo: this.#handle is null. This means the subprocess already exited");else R("ChildProcess: getBunSpawnIo: this.#handle is undefined");const Z=this.#Y[q];switch(q){case 0:switch(Z){case"pipe":return new l(this.#q.stdin);case"inherit":return process.stdin||null;case"destroyed":return new uq;default:return null}case 2:case 1:switch(Z){case"pipe":return d(this.#q[k(q)],Vq?{encoding:Q,__id:`PARENT_${k(q).toUpperCase()}-${globalThis.__getId()}`}:{encoding:Q});case"inherit":return process[k(q)]||null;case"destroyed":return new gq;default:return null}}}#J;#K;#H;#z;#M;#Y;#F(){return i.create(null,{0:{get:()=>this.stdin},1:{get:()=>this.stdout},2:{get:()=>this.stderr}})}get stdin(){return this.#J??=this.#X(0,this.#M)}get stdout(){return this.#K??=this.#X(1,this.#M)}get stderr(){return this.#H??=this.#X(2,this.#M)}get stdio(){return this.#z??=this.#F()}spawn(q){rq(q,"options"),u(q.file,"options.file");var Q=this.spawnfile=q.file,Z;if(q.args==null)Z=this.spawnargs=[];else sq(q.args,"options.args"),Z=this.spawnargs=q.args;const $=q.stdio||["pipe","pipe","pipe"],W=_q($);var X=q.envPairs||void 0;this.#M=q.encoding||void 0,this.#Y=W,this.#q=Bun.spawn({cmd:Z,stdin:W[0],stdout:W[1],stderr:W[2],cwd:q.cwd||void 0,env:X||process.env,onExit:(J,K,H,z)=>{this.#q=J,this.pid=this.#q.pid,process.nextTick((M,Y,F)=>this.#W(M,Y,F),K,H,z)},lazy:!0}),this.pid=this.#q.pid,hq(this)}send(){console.log("ChildProcess.prototype.send() - Sorry! Not implemented yet")}disconnect(){console.log("ChildProcess.prototype.disconnect() - Sorry! Not implemented yet")}kill(q){const Q=q===0?q:xq(q===void 0?"SIGTERM":q);if(this.#q)this.#q.kill(Q);return this.#j(),!0}#j(){if(R("Attempting to maybe close..."),this.#$++,this.#$===this.#Z)this.emit("close",this.exitCode,this.signalCode)}ref(){if(this.#q)this.#q.ref()}unref(){if(this.#q)this.#q.unref()}}var Rq={ignore:null,pipe:"pipe",overlapped:"pipe",inherit:"inherit"};class uq extends p{constructor(){super()}write(){return!1}destroy(){}end(){}pipe(){}}class gq extends p{pipe(){}}var aq=(q,Q)=>{if(q!==void 0&&(q===null||typeof q!=="object"||!("aborted"in q)))throw new g(Q,"AbortSignal",q)};var rq=(q,Q,Z=null)=>{const $=Z?.allowArray??!1,W=Z?.allowFunction??!1;if(!(Z?.nullable??!1)&&q===null||!$&&zq.call(q)||typeof q!=="object"&&(!W||typeof q!=="function"))throw new g(Q,"object",q)},sq=(q,Q,Z=0)=>{if(!zq(q))throw new g(Q,"Array",q);if(q.length<Z){const $=`must be longer than ${Z}`;throw new HQ(Q,q,$)}},QQ=globalThis.Error,ZQ=globalThis.TypeError,$Q=globalThis.RangeError;class WQ extends QQ{code="ABORT_ERR";name="AbortError";constructor(q="The operation was aborted",Q=void 0){if(Q!==void 0&&typeof Q!=="object")throw new g("options","Object",Q);super(q,Q)}}class zQ extends QQ{path;syscall;errno;code;constructor(q,Q,Z,$,W){super(q);this.path=Q,this.syscall=Z,this.errno=$,this.code=W}get name(){return"SystemError"}}var MQ={ChildProcess:Eq,spawn:Cq,execFile:Tq,exec:m,fork:Nq,spawnSync:Bq,execFileSync:Oq,execSync:Pq,[Symbol.for("CommonJS")]:0};export{Bq as spawnSync,Cq as spawn,Nq as fork,Pq as execSync,Oq as execFileSync,Tq as execFile,m as exec,MQ as default,Eq as ChildProcess};
