{
  "version": 3,
  "sources": ["src/js/node/net.js"],
  "sourcesContent": [
    "// Hardcoded module \"node:net\"\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// IPv4 Segment\nconst v4Seg = \"(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\";\nconst v4Str = `(${v4Seg}[.]){3}${v4Seg}`;\nconst IPv4Reg = new RegExp(`^${v4Str}$`);\n\n// IPv6 Segment\nconst v6Seg = \"(?:[0-9a-fA-F]{1,4})\";\nconst IPv6Reg = new RegExp(\n  \"^(\" +\n    `(?:${v6Seg}:){7}(?:${v6Seg}|:)|` +\n    `(?:${v6Seg}:){6}(?:${v4Str}|:${v6Seg}|:)|` +\n    `(?:${v6Seg}:){5}(?::${v4Str}|(:${v6Seg}){1,2}|:)|` +\n    `(?:${v6Seg}:){4}(?:(:${v6Seg}){0,1}:${v4Str}|(:${v6Seg}){1,3}|:)|` +\n    `(?:${v6Seg}:){3}(?:(:${v6Seg}){0,2}:${v4Str}|(:${v6Seg}){1,4}|:)|` +\n    `(?:${v6Seg}:){2}(?:(:${v6Seg}){0,3}:${v4Str}|(:${v6Seg}){1,5}|:)|` +\n    `(?:${v6Seg}:){1}(?:(:${v6Seg}){0,4}:${v4Str}|(:${v6Seg}){1,6}|:)|` +\n    `(?::((?::${v6Seg}){0,5}:${v4Str}|(?::${v6Seg}){1,7}|:))` +\n    \")(%[0-9a-zA-Z-.:]{1,})?$\",\n);\n\nfunction isIPv4(s) {\n  return IPv4Reg.test(s);\n}\n\nfunction isIPv6(s) {\n  return IPv6Reg.test(s);\n}\n\nfunction isIP(s) {\n  if (isIPv4(s)) return 4;\n  if (isIPv6(s)) return 6;\n  return 0;\n}\n\nconst { Bun, createFIFO, Object } = import.meta.primordials;\nconst { connect: bunConnect } = Bun;\nconst { Duplex } = import.meta.require(\"node:stream\");\nconst { EventEmitter } = import.meta.require(\"node:events\");\nvar { setTimeout } = globalThis;\n\nconst bunTlsSymbol = Symbol.for(\"::buntls::\");\nconst bunSocketServerHandlers = Symbol.for(\"::bunsocket_serverhandlers::\");\nconst bunSocketServerConnections = Symbol.for(\"::bunnetserverconnections::\");\nconst bunSocketServerOptions = Symbol.for(\"::bunnetserveroptions::\");\n\nvar SocketClass;\nconst Socket = (function (InternalSocket) {\n  SocketClass = InternalSocket;\n  Object.defineProperty(SocketClass.prototype, Symbol.toStringTag, {\n    value: \"Socket\",\n    enumerable: false,\n  });\n\n  return Object.defineProperty(\n    function Socket(options) {\n      return new InternalSocket(options);\n    },\n    Symbol.hasInstance,\n    {\n      value(instance) {\n        return instance instanceof InternalSocket;\n      },\n    },\n  );\n})(\n  class Socket extends Duplex {\n    static #Handlers = {\n      close: Socket.#Close,\n      connectError(socket, error) {\n        const self = socket.data;\n\n        self.emit(\"error\", error);\n      },\n      data({ data: self }, buffer) {\n        self.bytesRead += buffer.length;\n        const queue = self.#readQueue;\n\n        if (queue.isEmpty()) {\n          if (self.push(buffer)) return;\n        }\n        queue.push(buffer);\n      },\n      drain: Socket.#Drain,\n      end: Socket.#Close,\n      error(socket, error) {\n        const self = socket.data;\n        const callback = self.#writeCallback;\n        if (callback) {\n          self.#writeCallback = null;\n          callback(error);\n        }\n        self.emit(\"error\", error);\n      },\n      open(socket) {\n        const self = socket.data;\n        socket.timeout(self.timeout);\n        socket.ref();\n        self.#socket = socket;\n        self.connecting = false;\n        self.emit(\"connect\", self);\n        Socket.#Drain(socket);\n      },\n      handshake(socket, success, verifyError) {\n        const { data: self } = socket;\n        self._securePending = false;\n        self.secureConnecting = false;\n        self._secureEstablished = !!success;\n\n        // Needs getPeerCertificate support (not implemented yet)\n        // if (!verifyError && !this.isSessionReused()) {\n        //   const hostname = options.servername ||\n        //                  options.host ||\n        //                  (options.socket && options.socket._host) ||\n        //                  'localhost';\n        //   const cert = this.getPeerCertificate(true);\n        //   verifyError = options.checkServerIdentity(hostname, cert);\n        // }\n\n        if (self._requestCert || self._rejectUnauthorized) {\n          if (verifyError) {\n            self.authorized = false;\n            self.authorizationError = verifyError.code || verifyError.message;\n            if (self._rejectUnauthorized) {\n              self.destroy(verifyError);\n              return;\n            }\n          }\n        } else {\n          self.authorized = true;\n        }\n        self.emit(\"secureConnect\", verifyError);\n      },\n      timeout(socket) {\n        const self = socket.data;\n        self.emit(\"timeout\", self);\n      },\n      binaryType: \"buffer\",\n    };\n\n    static #Close(socket) {\n      const self = socket.data;\n      if (self.#closed) return;\n      self.#closed = true;\n      //socket cannot be used after close\n      self.#socket = null;\n      const queue = self.#readQueue;\n      if (queue.isEmpty()) {\n        if (self.push(null)) return;\n      }\n      queue.push(null);\n    }\n\n    static #Drain(socket) {\n      const self = socket.data;\n\n      const callback = self.#writeCallback;\n      if (callback) {\n        const chunk = self.#writeChunk;\n        const written = socket.write(chunk);\n\n        self.bytesWritten += written;\n        if (written < chunk.length) {\n          self.#writeChunk = chunk.slice(written);\n        } else {\n          self.#writeCallback = null;\n          self.#writeChunk = null;\n          callback(null);\n        }\n      }\n    }\n\n    static [bunSocketServerHandlers] = {\n      data: Socket.#Handlers.data,\n      close(socket) {\n        Socket.#Handlers.close(socket);\n        this.data[bunSocketServerConnections]--;\n      },\n      end(socket) {\n        Socket.#Handlers.end(socket);\n        this.data[bunSocketServerConnections]--;\n      },\n      open(socket) {\n        const self = this.data;\n        const options = self[bunSocketServerOptions];\n        const { pauseOnConnect, connectionListener, InternalSocketClass, requestCert, rejectUnauthorized } = options;\n        const _socket = new InternalSocketClass({});\n        _socket.isServer = true;\n        _socket._requestCert = requestCert;\n        _socket._rejectUnauthorized = rejectUnauthorized;\n\n        _socket.#attach(this.localPort, socket);\n        if (self.maxConnections && self[bunSocketServerConnections] >= self.maxConnections) {\n          const data = {\n            localAddress: _socket.localAddress,\n            localPort: _socket.localPort,\n            localFamily: _socket.localFamily,\n            remoteAddress: _socket.remoteAddress,\n            remotePort: _socket.remotePort,\n            remoteFamily: _socket.remoteFamily || \"IPv4\",\n          };\n\n          socket.end();\n\n          self.emit(\"drop\", data);\n          return;\n        }\n        // the duplex implementation start paused, so we resume when pauseOnConnect is falsy\n        if (!pauseOnConnect) {\n          _socket.resume();\n        }\n\n        self[bunSocketServerConnections]++;\n\n        if (typeof connectionListener == \"function\") {\n          if (InternalSocketClass.name === \"TLSSocket\") {\n            // add secureConnection event handler\n            self.once(\"secureConnection\", () => connectionListener(_socket));\n          } else {\n            connectionListener(_socket);\n          }\n        }\n\n        self.emit(\"connection\", _socket);\n      },\n      handshake({ data: self }, success, verifyError) {\n        self._securePending = false;\n        self.secureConnecting = false;\n        self._secureEstablished = !!success;\n        // Needs getPeerCertificate support (not implemented yet)\n        // if (!verifyError && !this.isSessionReused()) {\n        //   const hostname = options.servername ||\n        //                  options.host ||\n        //                  (options.socket && options.socket._host) ||\n        //                  'localhost';\n        //   const cert = this.getPeerCertificate(true);\n        //   verifyError = options.checkServerIdentity(hostname, cert);\n        // }\n\n        if (self._requestCert || self._rejectUnauthorized) {\n          if (verifyError) {\n            self.authorized = false;\n            self.authorizationError = verifyError.code || verifyError.message;\n            if (self._rejectUnauthorized) {\n              self.destroy(verifyError);\n              return;\n            }\n          }\n        } else {\n          self.authorized = true;\n        }\n        self.emit(\"secureConnect\", verifyError);\n      },\n      error(socket, error) {\n        Socket.#Handlers.error(socket, error);\n        this.data.emit(\"error\", error);\n      },\n      timeout: Socket.#Handlers.timeout,\n      connectError: Socket.#Handlers.connectError,\n      drain: Socket.#Handlers.drain,\n      binaryType: \"buffer\",\n    };\n\n    bytesRead = 0;\n    bytesWritten = 0;\n    #closed = false;\n    connecting = false;\n    localAddress = \"127.0.0.1\";\n    #readQueue = createFIFO();\n    remotePort;\n    #socket;\n    timeout = 0;\n    #writeCallback;\n    #writeChunk;\n    #pendingRead;\n\n    isServer = false;\n\n    constructor(options) {\n      const { signal, write, read, allowHalfOpen = false, ...opts } = options || {};\n      super({\n        ...opts,\n        allowHalfOpen,\n        readable: true,\n        writable: true,\n      });\n      this.#pendingRead = undefined;\n      signal?.once(\"abort\", () => this.destroy());\n      this.once(\"connect\", () => this.emit(\"ready\"));\n    }\n\n    address() {\n      return {\n        address: this.localAddress,\n        family: this.localFamily,\n        port: this.localPort,\n      };\n    }\n\n    get bufferSize() {\n      return this.writableLength;\n    }\n\n    #attach(port, socket) {\n      this.remotePort = port;\n      socket.data = this;\n      socket.timeout(this.timeout);\n      socket.ref();\n      this.#socket = socket;\n      this.connecting = false;\n      this.emit(\"connect\", this);\n      Socket.#Drain(socket);\n    }\n\n    connect(port, host, connectListener) {\n      var path;\n      if (typeof port === \"string\") {\n        path = port;\n        port = undefined;\n\n        if (typeof host === \"function\") {\n          connectListener = host;\n          host = undefined;\n        }\n      } else if (typeof host == \"function\") {\n        if (typeof port === \"string\") {\n          path = port;\n          port = undefined;\n        }\n\n        connectListener = host;\n        host = undefined;\n      }\n      if (typeof port == \"object\") {\n        var {\n          port,\n          host,\n          path,\n          // TODOs\n          localAddress,\n          localPort,\n          family,\n          hints,\n          lookup,\n          noDelay,\n          keepAlive,\n          keepAliveInitialDelay,\n          requestCert,\n          rejectUnauthorized,\n          pauseOnConnect,\n          servername,\n        } = port;\n        this.servername = servername;\n      }\n\n      if (!pauseOnConnect) {\n        this.resume();\n      }\n      this.connecting = true;\n      this.remotePort = port;\n\n      const bunTLS = this[bunTlsSymbol];\n      var tls = undefined;\n\n      if (typeof bunTLS === \"function\") {\n        tls = bunTLS.call(this, port, host, true);\n        // Client always request Cert\n        this._requestCert = true;\n        this._rejectUnauthorized = rejectUnauthorized;\n\n        if (tls) {\n          // TLS can true/false or options\n          if (typeof tls !== \"object\") {\n            tls = {\n              rejectUnauthorized: rejectUnauthorized,\n              requestCert: true,\n            };\n          } else {\n            tls.rejectUnauthorized = rejectUnauthorized;\n            tls.requestCert = true;\n          }\n        }\n\n        this.authorized = false;\n        this.secureConnecting = true;\n        this._secureEstablished = false;\n        this._securePending = true;\n        if (connectListener) this.on(\"secureConnect\", connectListener);\n      } else if (connectListener) this.on(\"connect\", connectListener);\n      bunConnect(\n        path\n          ? {\n              data: this,\n              unix: path,\n              socket: Socket.#Handlers,\n              tls,\n            }\n          : {\n              data: this,\n              hostname: host || \"localhost\",\n              port: port,\n              socket: Socket.#Handlers,\n              tls,\n            },\n      );\n      return this;\n    }\n\n    _destroy(err, callback) {\n      this.#socket?.end();\n      callback(err);\n    }\n\n    _final(callback) {\n      this.#socket?.end();\n      callback();\n    }\n\n    get localAddress() {\n      return \"127.0.0.1\";\n    }\n\n    get localFamily() {\n      return \"IPv4\";\n    }\n\n    get localPort() {\n      return this.#socket?.localPort;\n    }\n\n    get pending() {\n      return this.connecting;\n    }\n\n    _read(size) {\n      const queue = this.#readQueue;\n      let chunk;\n      while ((chunk = queue.peek())) {\n        if (!this.push(chunk)) return;\n        queue.shift();\n      }\n    }\n\n    get readyState() {\n      if (this.connecting) return \"opening\";\n      if (this.readable) {\n        return this.writable ? \"open\" : \"readOnly\";\n      } else {\n        return this.writable ? \"writeOnly\" : \"closed\";\n      }\n    }\n\n    ref() {\n      this.#socket?.ref();\n    }\n\n    get remoteAddress() {\n      return this.#socket?.remoteAddress;\n    }\n\n    get remoteFamily() {\n      return \"IPv4\";\n    }\n\n    resetAndDestroy() {\n      this.#socket?.end();\n    }\n\n    setKeepAlive(enable = false, initialDelay = 0) {\n      // TODO\n      return this;\n    }\n\n    setNoDelay(noDelay = true) {\n      // TODO\n      return this;\n    }\n\n    setTimeout(timeout, callback) {\n      this.#socket?.timeout(timeout);\n      this.timeout = timeout;\n      if (callback) this.once(\"timeout\", callback);\n      return this;\n    }\n\n    unref() {\n      this.#socket?.unref();\n    }\n\n    _write(chunk, encoding, callback) {\n      if (typeof chunk == \"string\" && encoding !== \"utf8\") chunk = Buffer.from(chunk, encoding);\n      var written = this.#socket?.write(chunk);\n      if (written == chunk.length) {\n        callback();\n      } else if (this.#writeCallback) {\n        callback(new Error(\"overlapping _write()\"));\n      } else {\n        if (written > 0) {\n          if (typeof chunk == \"string\") {\n            chunk = chunk.slice(written);\n          } else {\n            chunk = chunk.subarray(written);\n          }\n        }\n\n        this.#writeCallback = callback;\n        this.#writeChunk = chunk;\n      }\n    }\n  },\n);\n\nfunction createConnection(port, host, connectListener) {\n  if (typeof host == \"function\") {\n    connectListener = host;\n    host = undefined;\n  }\n  var options =\n    typeof port == \"object\"\n      ? port\n      : {\n          host: host,\n          port: port,\n        };\n  return new Socket(options).connect(options, connectListener);\n}\n\nconst connect = createConnection;\n\nclass Server extends EventEmitter {\n  #server;\n  #listening = false;\n  [bunSocketServerConnections] = 0;\n  [bunSocketServerOptions];\n  maxConnections = 0;\n\n  constructor(options, connectionListener) {\n    super();\n\n    if (typeof options === \"function\") {\n      connectionListener = options;\n      options = {};\n    } else if (options == null || typeof options === \"object\") {\n      options = { ...options };\n    } else {\n      throw new Error(\"bun-net-polyfill: invalid arguments\");\n    }\n\n    const { maxConnections } = options;\n    this.maxConnections = Number.isSafeInteger(maxConnections) && maxConnections > 0 ? maxConnections : 0;\n\n    options.connectionListener = connectionListener;\n    this[bunSocketServerOptions] = options;\n  }\n\n  ref() {\n    this.#server?.ref();\n    return this;\n  }\n\n  unref() {\n    this.#server?.unref();\n    return this;\n  }\n\n  close(callback) {\n    if (this.#server) {\n      this.#server.stop(true);\n      this.#server = null;\n      this.#listening = false;\n      this[bunSocketServerConnections] = 0;\n      this.emit(\"close\");\n      if (typeof callback === \"function\") {\n        callback();\n      }\n\n      return this;\n    }\n\n    if (typeof callback === \"function\") {\n      const error = new Error(\"Server is not running\");\n      error.code = \"ERR_SERVER_NOT_RUNNING\";\n      callback(error);\n    }\n    return this;\n  }\n\n  address() {\n    const server = this.#server;\n    if (server) {\n      const unix = server.unix;\n      if (unix) {\n        return unix;\n      }\n\n      //TODO: fix adress when host is passed\n      let address = server.hostname;\n      const type = isIP(address);\n      const port = server.port;\n      if (typeof port === \"number\") {\n        return {\n          port,\n          address,\n          family: type ? `IPv${type}` : undefined,\n        };\n      }\n      if (type) {\n        return {\n          address,\n          family: type ? `IPv${type}` : undefined,\n        };\n      }\n\n      return address;\n    }\n    return null;\n  }\n\n  getConnections(callback) {\n    if (typeof callback === \"function\") {\n      //in Bun case we will never error on getConnections\n      //node only errors if in the middle of the couting the server got disconnected, what never happens in Bun\n      //if disconnected will only pass null as well and 0 connected\n      callback(null, this.#server ? this[bunSocketServerConnections] : 0);\n    }\n    return this;\n  }\n\n  listen(port, hostname, onListen) {\n    let backlog;\n    let path;\n    let exclusive = false;\n    //port is actually path\n    if (typeof port === \"string\") {\n      if (Number.isSafeInteger(hostname)) {\n        if (hostname > 0) {\n          //hostname is backlog\n          backlog = hostname;\n        }\n      } else if (typeof hostname === \"function\") {\n        //hostname is callback\n        onListen = hostname;\n      }\n\n      path = port;\n      hostname = undefined;\n      port = undefined;\n    } else {\n      if (typeof hostname === \"function\") {\n        onListen = hostname;\n        hostname = undefined;\n      }\n\n      if (typeof port === \"function\") {\n        onListen = port;\n        port = 0;\n      } else if (typeof port === \"object\") {\n        const options = port;\n        options.signal?.addEventListener(\"abort\", () => this.close());\n\n        hostname = options.host;\n        exclusive = options.exclusive === true;\n        const path = options.path;\n        port = options.port;\n\n        if (!Number.isSafeInteger(port) || port < 0) {\n          if (path) {\n            hostname = path;\n            port = undefined;\n          } else {\n            let message = 'The argument \\'options\\' must have the property \"port\" or \"path\"';\n            try {\n              message = `${message}. Received ${JSON.stringify(options)}`;\n            } catch {}\n\n            const error = new TypeError(message);\n            error.code = \"ERR_INVALID_ARG_VALUE\";\n            throw error;\n          }\n        } else if (!Number.isSafeInteger(port) || port < 0) {\n          port = 0;\n        }\n\n        // port <number>\n        // host <string>\n        // path <string> Will be ignored if port is specified. See Identifying paths for IPC connections.\n        // backlog <number> Common parameter of server.listen() functions.\n        // exclusive <boolean> Default: false\n        // readableAll <boolean> For IPC servers makes the pipe readable for all users. Default: false.\n        // writableAll <boolean> For IPC servers makes the pipe writable for all users. Default: false.\n        // ipv6Only <boolean> For TCP servers, setting ipv6Only to true will disable dual-stack support, i.e., binding to host :: won't make 0.0.0.0 be bound. Default: false.\n        // signal <AbortSignal> An AbortSignal that may be used to close a listening server.\n\n        if (typeof port.callback === \"function\") onListen = port?.callback;\n      } else if (!Number.isSafeInteger(port) || port < 0) {\n        port = 0;\n      }\n      hostname = hostname || \"::\";\n    }\n\n    try {\n      var tls = undefined;\n      var TLSSocketClass = undefined;\n      const bunTLS = this[bunTlsSymbol];\n      if (typeof bunTLS === \"function\") {\n        [tls, TLSSocketClass] = bunTLS.call(this, port, hostname, false);\n      }\n\n      this[bunSocketServerOptions].InternalSocketClass = TLSSocketClass || SocketClass;\n\n      this.#server = Bun.listen(\n        path\n          ? {\n              exclusive,\n              unix: path,\n              tls,\n              socket: SocketClass[bunSocketServerHandlers],\n            }\n          : {\n              exclusive,\n              port,\n              hostname,\n              tls,\n              socket: SocketClass[bunSocketServerHandlers],\n            },\n      );\n\n      //make this instance available on handlers\n      this.#server.data = this;\n\n      this.#listening = true;\n\n      // We must schedule the emitListeningNextTick() only after the next run of\n      // the event loop's IO queue. Otherwise, the server may not actually be listening\n      // when the 'listening' event is emitted.\n      //\n      // That leads to all sorts of confusion.\n      //\n      // process.nextTick() is not sufficient because it will run before the IO queue.\n      setTimeout(emitListeningNextTick, 1, this, onListen);\n    } catch (err) {\n      this.#listening = false;\n      setTimeout(emitErrorNextTick, 1, this, err);\n    }\n    return this;\n  }\n}\n\nfunction emitErrorNextTick(self, error) {\n  self.emit(\"error\", error);\n}\n\nfunction emitListeningNextTick(self, onListen) {\n  if (typeof onListen === \"function\") {\n    try {\n      onListen();\n    } catch (err) {\n      self.emit(\"error\", err);\n    }\n  }\n  self.emit(\"listening\");\n}\n\nfunction createServer(options, connectionListener) {\n  return new Server(options, connectionListener);\n}\n\nexport default {\n  createServer,\n  Server,\n  createConnection,\n  connect,\n  isIP,\n  isIPv4,\n  isIPv6,\n  Socket,\n  [Symbol.for(\"CommonJS\")]: 0,\n  [Symbol.for(\"::bunternal::\")]: SocketClass,\n};\n\nexport { createServer, Server, createConnection, connect, isIP, isIPv4, isIPv6, Socket };\n"
  ],
  "mappings": "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",
  "debugId": "213FB9A1EE2E018964756e2164756e21",
  "names": []
}