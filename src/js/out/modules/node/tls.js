var H=function(){throw Error("Not implemented")},X=function(f){if(typeof f==="string"||q(f)||f instanceof ArrayBuffer||f instanceof Blob)return!0;if(Array.isArray(f)){for(var w=0;w<f.length;w++)if(typeof f!=="string"&&!q(f)&&!(f instanceof ArrayBuffer)&&!(f instanceof Blob))return!1;return!0}},M=function(f){return new W(f)},P=function(f){return new M(f)},d=function(f,w){return new R(f,w)},{isTypedArray:q}=import.meta.require("util/types"),W=class f{context;constructor(w){const B={};if(w){let J=w.key;if(J){if(!X(J))throw new TypeError("key argument must be an string, Buffer, TypedArray, BunFile or an array containing string, Buffer, TypedArray or BunFile");this.key=J}let K=w.cert;if(K){if(!X(K))throw new TypeError("cert argument must be an string, Buffer, TypedArray, BunFile or an array containing string, Buffer, TypedArray or BunFile");this.cert=K}let Q=w.ca;if(Q){if(!X(Q))throw new TypeError("ca argument must be an string, Buffer, TypedArray, BunFile or an array containing string, Buffer, TypedArray or BunFile");this.ca=Q}let Y=w.passphrase;if(Y&&typeof Y!=="string")throw new TypeError("passphrase argument must be an string");this.passphrase=Y;let Z=w.servername;if(Z&&typeof Z!=="string")throw new TypeError("servername argument must be an string");this.servername=Z;let $=w.secureOptions||0;if($&&typeof $!=="number")throw new TypeError("secureOptions argument must be an number");this.secureOptions=$}this.context=B}},{[Symbol.for("::bunternal::")]:g,Server:F}=import.meta.require("net"),m=Symbol.for("::buntls::"),z,D=function(f){return z=f,Object.defineProperty(z.prototype,Symbol.toStringTag,{value:"TLSSocket",enumerable:!1}),Object.defineProperty(function w(B){return new f(B)},Symbol.hasInstance,{value(w){return w instanceof f}})}(class f extends g{#f;constructor(w){super(w);this.#f=w.secureContext||P(w),this.authorized=!1,this.secureConnecting=!0,this._secureEstablished=!1,this._securePending=!0}_secureEstablished=!1;_securePending=!0;_newSessionPending;_controlReleased;secureConnecting=!1;_SNICallback;servername;alpnProtocol;authorized=!1;authorizationError;encrypted=!0;exportKeyingMaterial(){throw Error("Not implented in Bun yet")}setMaxSendFragment(){throw Error("Not implented in Bun yet")}setServername(){throw Error("Not implented in Bun yet")}setSession(){throw Error("Not implented in Bun yet")}getPeerCertificate(){throw Error("Not implented in Bun yet")}getCertificate(){throw Error("Not implented in Bun yet")}getPeerX509Certificate(){throw Error("Not implented in Bun yet")}getX509Certificate(){throw Error("Not implented in Bun yet")}[m](w,B){var{servername:J}=this;if(J)return{serverName:typeof J==="string"?J:B,...this.#f};return!0}});class R extends F{key;cert;ca;passphrase;secureOptions;_rejectUnauthorized;_requestCert;servername;constructor(f,w){super(f,w);this.setSecureContext(f)}emit(f,w){if(super.emit(f,w),f==="connection")w.once("secureConnect",()=>{super.emit("secureConnection",w)})}setSecureContext(f){if(f instanceof W)f=f.context;if(f){let w=f.key;if(w){if(!X(w))throw new TypeError("key argument must be an string, Buffer, TypedArray, BunFile or an array containing string, Buffer, TypedArray or BunFile");this.key=w}let B=f.cert;if(B){if(!X(B))throw new TypeError("cert argument must be an string, Buffer, TypedArray, BunFile or an array containing string, Buffer, TypedArray or BunFile");this.cert=B}let J=f.ca;if(J){if(!X(J))throw new TypeError("ca argument must be an string, Buffer, TypedArray, BunFile or an array containing string, Buffer, TypedArray or BunFile");this.ca=J}let K=f.passphrase;if(K&&typeof K!=="string")throw new TypeError("passphrase argument must be an string");this.passphrase=K;let Q=f.servername;if(Q&&typeof Q!=="string")throw new TypeError("servername argument must be an string");this.servername=Q;let Y=f.secureOptions||0;if(Y&&typeof Y!=="number")throw new TypeError("secureOptions argument must be an number");this.secureOptions=Y;const Z=f.requestCert||!1;if(Z)this._requestCert=Z;else this._requestCert=void 0;const $=f.rejectUnauthorized||!1;if($)this._rejectUnauthorized=$;else this._rejectUnauthorized=void 0}}getTicketKeys(){throw Error("Not implented in Bun yet")}setTicketKeys(){throw Error("Not implented in Bun yet")}[m](f,w,B){return[{serverName:this.servername||w||"localhost",key:this.key,cert:this.cert,ca:this.ca,passphrase:this.passphrase,secureOptions:this.secureOptions,rejectUnauthorized:B?!1:this._rejectUnauthorized,requestCert:B?!1:this._requestCert},z]}}var U=3,N=600,O="auto",G="DHE-RSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-RSA-AES128-GCM-SHA256",V="TLSv1.2",_="TLSv1.3",x=(f,w,B)=>{if(typeof w=="function")B=w,w=void 0;var J=typeof f=="object"?f:{host:w,port:f};return new D(J).connect(J,B)},y=x,A={createSecureContext:P,parseCertString:H,getCiphers(){return G.split(":")},getCurves(){return},convertALPNProtocols(f,w){},TLSSocket:D,SecureContext:M,CLIENT_RENEG_LIMIT:U,CLIENT_RENEG_WINDOW:N,DEFAULT_ECDH_CURVE:O,DEFAULT_CIPHERS:G,DEFAULT_MIN_VERSION:V,DEFAULT_MAX_VERSION:_,[Symbol.for("CommonJS")]:0,connect:y,createConnection:x,Server:R,createServer:d},I=A;export{H as parseCertString,I as default,P as createSecureContext,x as createConnection,y as connect,D as TLSSocket,M as SecureContext,V as DEFAULT_MIN_VERSION,_ as DEFAULT_MAX_VERSION,O as DEFAULT_ECDH_CURVE,G as DEFAULT_CIPHERS,N as CLIENT_RENEG_WINDOW,U as CLIENT_RENEG_LIMIT};
