var b=function(){throw new Error("Not implemented in bun")};async function B(w,f={method:"GET",signal:null,headers:null,query:null,reset:!1,throwOnError:!1,body:null}){let{method:G="GET",headers:J,query:T,signal:z,reset:H=!1,throwOnError:I=!1,body:K,maxRedirections:N}=f;if(typeof w==="string"){if(T)w=new W(w)}else if(typeof w==="object"&&w!==null){if(!(w instanceof W))throw new Error("not implemented")}else throw new TypeError("url must be a string, URL, or UrlObject");if(typeof w==="string"&&T)w=new W(w);if(typeof w==="object"&&w!==null&&T){if(T)w.search=new M(T).toString()}if(G=G&&typeof G==="string"?G.toUpperCase():null,K&&(G==="GET"||G==="HEAD"))throw new Error("Body not allowed for GET or HEAD requests");if(K&&K.read&&K instanceof x){let Z="";K.setEncoding("utf8");for await(let $ of D)Z+=$;K=(new TextEncoder()).encode(Z)}if(N!==void 0&&Number.isNaN(N))throw new Error("maxRedirections must be a number if defined");if(z&&!(z instanceof AbortSignal))throw new Error("signal must be an instance of AbortSignal");let Q;const{status:S,headers:V,trailers:X}=Q=await q(w,{signal:z,mode:"cors",method:G,headers:J||O,body:K,redirect:N==="undefined"||N>0?"follow":"manual",keepalive:!H});if(I&&S>=400&&S<600)throw new Error(`Request failed with status code ${S}`);const Y=Q.body?new P(Q):null;return{statusCode:S,headers:V,body:Y,trailers:X,opaque:O,context:O}}function D(){throw new Error("Not implemented in bun")}function R(){throw new Error("Not implemented in bun")}function h(){throw new Error("Not implemented in bun")}function m(){throw new Error("Not implemented in bun")}function u(){throw new Error("Not implemented in bun")}function v(){throw new Error("Not implemented in bun")}var{EventEmitter:_}=import.meta.require("events"),{Readable:x,[Symbol.for("::bunternal::")]:{_ReadableFromWeb:E}}=import.meta.require("node:stream"),j=Object.create,O=j(null),q=Bun.fetch,A=globalThis.Response,F=globalThis.Headers,L=globalThis.Request,M=globalThis.URLSearchParams,W=globalThis.URL;class g extends Blob{}class k extends EventTarget{constructor(){throw new Error("Not implemented yet!")}}var C=globalThis.FormData;class P extends E{#w;#f;constructor(w,f={}){var{body:G}=w;if(!G)throw new Error("Response body is null");super(f,G);this.#w=w,this.#f=w.bodyUsed}get bodyUsed(){return this.#f}#G(){if(this.#f)throw new TypeError("unusable");this.#f=!0}async arrayBuffer(){return this.#G(),await this.#w.arrayBuffer()}async blob(){return this.#G(),await this.#w.blob()}async formData(){return this.#G(),await this.#w.formData()}async json(){return this.#G(),await this.#w.json()}async text(){return this.#G(),await this.#w.text()}}class y{constructor(){throw new Error("Not implemented in bun")}}class U{constructor(){throw new Error("Not implemented in bun")}}class p{constructor(){throw new Error("Not implemented in bun")}}class a extends _{}class l extends a{}class c extends a{request(){throw new Error("Not implemented in bun")}}class d extends a{}class n extends a{request(){throw new Error("Not implemented in bun")}}v.Dispatcher=a;v.Pool=c;v.BalancedPool=d;v.Client=n;v.Agent=l;v.buildConnector=v.errors=v.setGlobalDispatcher=v.getGlobalDispatcher=v.request=v.stream=v.pipeline=v.connect=v.upgrade=v.MockClient=v.MockPool=v.MockAgent=v.mockErrors=b;v.fetch=q;var o={fetch:q,Response:A,Headers:F,Request:L,URLSearchParams:M,URL:W,File:g,FileReader:k,FormData:C,request:B,stream:D,pipeline:R,connect:h,upgrade:m,MockClient:y,MockPool:U,MockAgent:p,mockErrors:u,Dispatcher:a,Pool:c,BalancedPool:d,Client:n,Agent:l,Undici:v,[Symbol.for("CommonJS")]:0};export{m as upgrade,D as stream,B as request,R as pipeline,u as mockErrors,q as fetch,o as default,h as connect,v as Undici,M as URLSearchParams,W as URL,A as Response,L as Request,U as MockPool,y as MockClient,p as MockAgent,F as Headers,C as FormData,k as FileReader,g as File};
