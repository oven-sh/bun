var N=import.meta.require("node:events");var A=import.meta.require("node:http");var B=function(j){const z=new Set;let D=-1,F=-1,J=0;for(J;J<j.length;J++){const Q=j.charCodeAt(J);if(F===-1&&h[Q]===1){if(D===-1)D=J}else if(J!==0&&(Q===32||Q===9)){if(F===-1&&D!==-1)F=J}else if(Q===44){if(D===-1)throw new SyntaxError(`Unexpected character at index ${J}`);if(F===-1)F=J;const V=j.slice(D,F);if(z.has(V))throw new SyntaxError(`The "${V}" subprotocol is duplicated`);z.add(V),D=F=-1}else throw new SyntaxError(`Unexpected character at index ${J}`)}if(D===-1||F!==-1)throw new SyntaxError("Unexpected end of input");const K=j.slice(D,J);if(z.has(K))throw new SyntaxError(`The "${K}" subprotocol is duplicated`);return z.add(K),z},W=function(j){j._state=L,j.emit("close")},G=function(j,z,D,F){D=D||A.STATUS_CODES[z],F={Connection:"close","Content-Type":"text/html","Content-Length":Buffer.byteLength(D),...F},j.writeHead(z,F),j.write(D),j.end()},I=function(j,z,D,F,J,K){if(j.listenerCount("wsClientError")){const Q=new Error(K);Error.captureStackTrace(Q,I),j.emit("wsClientError",Q,F,z)}else G(D,J,K)},U=Symbol.for("::bunternal::"),f=["CONNECTING","OPEN","CLOSING","CLOSED"],T=new TextEncoder;class H extends globalThis.WebSocket{constructor(j,...z){super(j,...z);this.#z=new WeakMap}#j;#z=new WeakMap;get binaryType(){return this.#j}set binaryType(j){if(j!=="nodebuffer"&&j!=="blob"&&j!=="arraybuffer")throw new TypeError("binaryType must be either 'blob', 'arraybuffer' or 'nodebuffer'");if(j!=="blob")super.binaryType=j;this.#j=j}send(j,z,D){super.send(j,z?.compress),typeof D==="function"&&D()}on(j,z){if(j==="message"){var D=({data:F})=>{try{if(this.#j=="blob")F=new Blob([F]);z(F)}catch(J){globalThis.reportError(J)}};this.#z.set(z,D),this.addEventListener(j,D)}else this.addEventListener(j,z)}once(j,z){if(j==="message"){var D=({data:F})=>{try{z(F)}catch(J){globalThis.reportError(J)}};this.#z.set(z,D),this.addEventListener(j,D,{once:!0})}else this.addEventListener(j,z,{once:!0})}emit(j,z){if(j==="message")this.dispatchEvent(new MessageEvent("message",{data:z}));else this.dispatchEvent(new CustomEvent(j,{detail:z}))}off(j,z){var D=this.#z.get(z);if(D)this.removeEventListener(j,D),this.#z.delete(z);else this.removeEventListener(j,z)}}H.WebSocket=H;var w=/^[+/0-9A-Za-z]{22}==$/,h=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,1,1,1,1,0,0,1,1,0,1,1,0,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,0,1,0],M=0,R=1,L=2;class q extends N{#j;#z;#D=[];#F;#J;#K;#Q=0;#V="arraybuffer";#X;#Y;#Z;#_;constructor(j,z,D,F){super();if(this.#j=null,this.#z=0,this.#F=j,this.#Q=0,F=F||"arraybuffer",F!=="nodebuffer"&&F!=="blob"&&F!=="arraybuffer")throw new TypeError("binaryType must be either 'blob', 'arraybuffer' or 'nodebuffer'");this.#V=F,this.#J=z,this.#K=D;const J=this.#$.bind(this),K=this.#O.bind(this),Q=this.#P.bind(this),V=this.#C.bind(this);this[U]={message:J,open:K,close:Q,drain:V}}#$(j,z){if(this.#j=j,typeof z==="string")if(this.#V==="arraybuffer")z=T.encode(z).buffer;else if(this.#V==="blob")z=new Blob([z],{type:"text/plain"});else z=Buffer.from(z);else if(this.#V!=="nodebuffer"){if(this.#V==="arraybuffer")z=new Uint8Array(z);else if(this.#V==="blob")z=new Blob([z])}this.emit("message",z)}#O(j){this.#j=j,this.#z=1,this.emit("open",this),this.#C(j)}#P(j,z,D){this.#z=3,this.#j=null,this.emit("close",z,D)}#C(j){const z=this.#D[0];if(z){const[D,F,J]=z;if(j.send(D,F)==-1)return;typeof J==="function"&&J(),this.#Q-=z.length,this.#D.shift()}}send(j,z,D){if(this.#z===1){const F=z?.compress;if(this.#j.send(j,F)==-1){this.#D.push([j,F,D]),this.#Q+=j.length;return}typeof D==="function"&&D()}else if(this.#z===0)this.#D.push([j,z?.compress,D]),this.#Q+=j.length}close(j,z){if(this.#z===1)this.#z=2,this.#j.close(j,z)}get binaryType(){return this.#V}set binaryType(j){if(j!=="nodebuffer"&&j!=="blob"&&j!=="arraybuffer")throw new TypeError("binaryType must be either 'blob', 'arraybuffer' or 'nodebuffer'");this.#V=j}get readyState(){return f[this.#z]}get url(){return this.#F}get protocol(){return this.#J}get extensions(){return this.#K}get bufferedAmount(){return this.#Q??0}setSocket(j,z,D){throw new Error("Not implemented")}set onclose(j){if(this.#X)this.removeListener("close",this.#X);this.on("close",j),this.#X=j}set onerror(j){if(this.#Y)this.removeListener("error",this.#Y);this.on("error",j),this.#Y=j}set onmessage(j){if(this.#Z)this.removeListener("message",this.#Z);this.on("message",j),this.#Z=j}set onopen(j){if(this.#_)this.removeListener("open",this.#_);this.on("open",j),this.#_=j}get onclose(){return this.#X}get onerror(){return this.#Y}get onmessage(){return this.#Z}get onopen(){return this.#_}}class g extends N{_server;options;clients;_shouldEmitClose;_state;_removeListeners;constructor(j,z){super();if(j={maxPayload:104857600,skipUTF8Validation:!1,perMessageDeflate:!1,handleProtocols:null,clientTracking:!0,verifyClient:null,noServer:!1,backlog:null,server:null,host:null,path:null,port:null,...j},j.port==null&&!j.server&&!j.noServer||j.port!=null&&(j.server||j.noServer)||j.server&&j.noServer)throw new TypeError('One and only one of the "port", "server", or "noServer" options must be specified');if(j.port!=null)this._server=A.createServer((D,F)=>{const J=A.STATUS_CODES[426];F.writeHead(426,{"Content-Length":J.length,"Content-Type":"text/plain"}),F.end(J)}),this._server.listen(j.port,j.host,j.backlog,z);else if(j.server)this._server=j.server;if(this._server){const D=this.emit.bind(this,"connection"),F=this.emit.bind(this,"listening"),J=this.emit.bind(this,"error"),K=(Q,V,X)=>{this.handleUpgrade(Q,V,X,D)};this._server.on("listening",F),this._server.on("error",J),this._server.on("upgrade",K),this._removeListeners=()=>{this._server.removeListener("upgrade",K),this._server.removeListener("listening",F),this._server.removeListener("error",J)}}if(j.perMessageDeflate===!0)j.perMessageDeflate={};if(j.clientTracking)this.clients=new Set,this._shouldEmitClose=!1;this.options=j,this._state=M}address(){if(this.options.noServer)throw new Error('The server is operating in "noServer" mode');if(!this._server)return null;return this._server.address()}close(j){if(this._state===L){if(j)this.once("close",()=>{j(new Error("The server is not running"))});process.nextTick((z)=>{z._state=L,z.emit("close")},this);return}if(j)this.once("close",j);if(this._state===R)return;if(this._state=R,this.options.noServer||this.options.server){if(this._server)this._removeListeners(),this._removeListeners=this._server=null;if(this.clients)if(!this.clients.size)process.nextTick((z)=>{z._state=L,z.emit("close")},this);else this._shouldEmitClose=!0;else process.nextTick((z)=>{z._state=L,z.emit("close")},this)}else{const z=this._server;this._removeListeners(),this._removeListeners=this._server=null,z.close(()=>{this._state=L,this.emit("close")})}}shouldHandle(j){if(this.options.path){const z=j.url.indexOf("?");if((z!==-1?j.url.slice(0,z):j.url)!==this.options.path)return!1}return!0}completeUpgrade(j,z,D,F,J,K,Q){const[V,X,Y]=J[U];if(this._state>M)return G(X,503);let Z="";if(D.size)Z=this.options.handleProtocols?this.options.handleProtocols(D,F):D.values().next().value;const _=new q(F.url,Z,j,"nodebuffer"),$=["HTTP/1.1 101 Switching Protocols","Upgrade: websocket","Connection: Upgrade"];if(this.emit("headers",$,F),V.upgrade(Y,{data:_[U]})){if(X._reply(void 0),this.clients)this.clients.add(_),_.on("close",()=>{if(this.clients.delete(_),this._shouldEmitClose&&!this.clients.size)process.nextTick(W,this)});Q(_,F)}else G(X,500)}handleUpgrade(j,z,D,F){const[J,K]=z[U],Q=j.headers["sec-websocket-key"],V=+j.headers["sec-websocket-version"];if(j.method!=="GET"){I(this,j,K,z,405,"Invalid HTTP method");return}if(j.headers.upgrade.toLowerCase()!=="websocket"){I(this,j,K,z,400,"Invalid Upgrade header");return}if(!Q||!w.test(Q)){I(this,j,K,z,400,"Missing or invalid Sec-WebSocket-Key header");return}if(V!==8&&V!==13){I(this,j,K,z,400,"Missing or invalid Sec-WebSocket-Version header");return}if(!this.shouldHandle(j)){G(K,400);return}const X=j.headers["sec-websocket-protocol"];let Y=new Set;if(X!==void 0)try{Y=B(X)}catch(_){I(this,j,K,z,400,"Invalid Sec-WebSocket-Protocol header");return}const Z={};if(this.options.verifyClient){const _={origin:j.headers[`${V===8?"sec-websocket-origin":"origin"}`],secure:!!(j.socket.authorized||j.socket.encrypted),req:j};if(this.options.verifyClient.length===2){this.options.verifyClient(_,($,O,P,C)=>{if(!$)return G(K,O||401,P,C);this.completeUpgrade(Z,Q,Y,j,z,D,F)});return}if(!this.options.verifyClient(_))return G(K,401)}this.completeUpgrade(Z,Q,Y,j,z,D,F)}}H.WebSocketServer=g;H.Server=g;Object.defineProperty(H,"CONNECTING",{enumerable:!0,value:f.indexOf("CONNECTING")});Object.defineProperty(H.prototype,"CONNECTING",{enumerable:!0,value:f.indexOf("CONNECTING")});Object.defineProperty(H,"OPEN",{enumerable:!0,value:f.indexOf("OPEN")});Object.defineProperty(H.prototype,"OPEN",{enumerable:!0,value:f.indexOf("OPEN")});Object.defineProperty(H,"CLOSING",{enumerable:!0,value:f.indexOf("CLOSING")});Object.defineProperty(H.prototype,"CLOSING",{enumerable:!0,value:f.indexOf("CLOSING")});Object.defineProperty(H,"CLOSED",{enumerable:!0,value:f.indexOf("CLOSED")});Object.defineProperty(H.prototype,"CLOSED",{enumerable:!0,value:f.indexOf("CLOSED")});class v{constructor(){throw new Error("Not supported yet in Bun")}}H.Sender=v;class S{constructor(){throw new Error("Not supported yet in Bun")}}H.Receiver=S;var m=(j)=>{throw new Error("Not supported yet in Bun")};H.createWebSocketStream=m;H[Symbol.for("CommonJS")]=0;var y=H;export{y as default,m as createWebSocketStream,g as WebSocketServer,H as WebSocket,g as Server,v as Sender,S as Receiver};
