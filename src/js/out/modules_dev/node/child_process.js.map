{
  "version": 3,
  "sources": ["src/js/node/child_process.js", "src/js/node/child_process.js", "src/js/node/child_process.js", "src/js/node/child_process.js"],
  "sourcesContent": [
    "// Hardcoded module \"node:child_process\"\nconst EventEmitter = import.meta.require(\"node:events\");\nconst {\n  Readable: { fromWeb: ReadableFromWeb },\n  NativeWritable,\n} = import.meta.require(\"node:stream\");\nconst {\n  constants: { signals },\n} = import.meta.require(\"node:os\");\nconst { promisify } = import.meta.require(\"node:util\");\n\nconst { ArrayBuffer, Uint8Array, String, Object, Buffer, Promise } = import.meta.primordials;\n\nvar ObjectPrototypeHasOwnProperty = Object.prototype.hasOwnProperty;\nvar ObjectCreate = Object.create;\nvar ObjectAssign = Object.assign;\nvar ObjectDefineProperty = Object.defineProperty;\nvar BufferConcat = Buffer.concat;\nvar BufferIsEncoding = Buffer.isEncoding;\n\nvar kEmptyObject = ObjectCreate(null);\n\nvar ArrayPrototypePush = Array.prototype.push;\nvar ArrayPrototypeReduce = Array.prototype.reduce;\nvar ArrayPrototypeFilter = Array.prototype.filter;\nvar ArrayPrototypeJoin = Array.prototype.join;\nvar ArrayPrototypeMap = Array.prototype.map;\nvar ArrayPrototypeIncludes = Array.prototype.includes;\nvar ArrayPrototypeSlice = Array.prototype.slice;\nvar ArrayPrototypeUnshift = Array.prototype.unshift;\nvar ArrayIsArray = Array.isArray;\n\n// var ArrayBuffer = ArrayBuffer;\nvar ArrayBufferIsView = ArrayBuffer.isView;\n\nvar NumberIsInteger = Number.isInteger;\nvar MathAbs = Math.abs;\n\nvar StringPrototypeToUpperCase = String.prototype.toUpperCase;\nvar StringPrototypeIncludes = String.prototype.includes;\nvar StringPrototypeSlice = String.prototype.slice;\nvar Uint8ArrayPrototypeIncludes = Uint8Array.prototype.includes;\n\nconst MAX_BUFFER = 1024 * 1024;\n\n// General debug vs tracking stdio streams. Useful for stream debugging in particular\nconst __DEBUG__ = process.env.DEBUG || false;\n\n// You can use this env var along with `process.env.DEBUG_TRACK_EE` to debug stdio streams\n// Just set `DEBUG_TRACK_EE=PARENT_STDOUT-0, PARENT_STDOUT-1`, etc. and `DEBUG_STDIO=1` and you will be able to track particular stdio streams\n// TODO: Add ability to track a range of IDs rather than just enumerated ones\nconst __TRACK_STDIO__ = process.env.DEBUG_STDIO;\nconst debug = __DEBUG__ ? console.log : () => {};\n\nif (__TRACK_STDIO__) {\n  debug(\"child_process: debug mode on\");\n  globalThis.__lastId = null;\n  globalThis.__getId = () => {\n    return globalThis.__lastId !== null ? globalThis.__lastId++ : 0;\n  };\n}\n\n// Sections:\n// 1. Exported child_process functions\n// 2. child_process helpers\n// 3. ChildProcess \"class\"\n// 4. ChildProcess helpers\n// 5. Validators\n// 6. Random utilities\n// 7. Node errors / error polyfills\n\n// TODO:\n// Port rest of node tests\n// Fix exit codes with Bun.spawn\n// ------------------------------\n// Fix errors\n// Support file descriptors being passed in for stdio\n// ------------------------------\n// TODO: Look at Pipe to see if we can support passing Node Pipe objects to stdio param\n\n// TODO: Add these params after support added in Bun.spawn\n// uid <number> Sets the user identity of the process (see setuid(2)).\n// gid <number> Sets the group identity of the process (see setgid(2)).\n// detached <boolean> Prepare child to run independently of its parent process. Specific behavior depends on the platform, see options.detached).\n\n// TODO: After IPC channels can be opened\n// serialization <string> Specify the kind of serialization used for sending messages between processes. Possible values are 'json' and 'advanced'. See Advanced serialization for more details. Default: 'json'.\n\n// TODO: Add support for ipc option, verify only one IPC channel in array\n// stdio <Array> | <string> Child's stdio configuration (see options.stdio).\n// Support wrapped ipc types (e.g. net.Socket, dgram.Socket, TTY, etc.)\n// IPC FD passing support\n\n// From node child_process docs(https://nodejs.org/api/child_process.html#optionsstdio):\n// 'ipc': Create an IPC channel for passing messages/file descriptors between parent and child.\n// A ChildProcess may have at most one IPC stdio file descriptor. Setting this option enables the subprocess.send() method.\n// If the child is a Node.js process, the presence of an IPC channel will enable process.send() and process.disconnect() methods,\n// as well as 'disconnect' and 'message' events within the child.\n\n//------------------------------------------------------------------------------\n// Section 1. Exported child_process functions\n//------------------------------------------------------------------------------\n\n// TODO: Implement these props when Windows is supported\n// *   windowsVerbatimArguments?: boolean;\n// *   windowsHide?: boolean;\n\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nfunction spawnTimeoutFunction(child, timeoutHolder) {\n  var timeoutId = timeoutHolder.timeoutId;\n  if (timeoutId > -1) {\n    try {\n      child.kill(killSignal);\n    } catch (err) {\n      child.emit(\"error\", err);\n    }\n    timeoutHolder.timeoutId = -1;\n  }\n}\n/**\n * Spawns a new process using the given `file`.\n * @param {string} file\n * @param {string[]} [args]\n * @param {{\n *   cwd?: string;\n *   env?: Record<string, string>;\n *   argv0?: string;\n *   stdio?: Array | string;\n *   detached?: boolean;\n *   uid?: number;\n *   gid?: number;\n *   serialization?: string;\n *   shell?: boolean | string;\n *   signal?: AbortSignal;\n *   timeout?: number;\n *   killSignal?: string | number;\n *   }} [options]\n * @returns {ChildProcess}\n */\nexport function spawn(file, args, options) {\n  options = normalizeSpawnArguments(file, args, options);\n  validateTimeout(options.timeout);\n  validateAbortSignal(options.signal, \"options.signal\");\n  const killSignal = sanitizeKillSignal(options.killSignal);\n  const child = new ChildProcess();\n\n  debug(\"spawn\", options);\n  child.spawn(options);\n\n  if (options.timeout > 0) {\n    let timeoutId = setTimeout(() => {\n      if (timeoutId) {\n        try {\n          child.kill(killSignal);\n        } catch (err) {\n          child.emit(\"error\", err);\n        }\n        timeoutId = null;\n      }\n    });\n\n    child.once(\"exit\", () => {\n      if (timeoutId) {\n        clearTimeout(timeoutId);\n        timeoutId = null;\n      }\n    });\n  }\n\n  if (options.signal) {\n    const signal = options.signal;\n    if (signal.aborted) {\n      process.nextTick(onAbortListener);\n    } else {\n      signal.addEventListener(\"abort\", onAbortListener, { once: true });\n      child.once(\"exit\", () => signal.removeEventListener(\"abort\", onAbortListener));\n    }\n\n    function onAbortListener() {\n      abortChildProcess(child, killSignal);\n    }\n  }\n  return child;\n}\n\n/**\n * Spawns the specified file as a shell.\n * @param {string} file\n * @param {string[]} [args]\n * @param {{\n *   cwd?: string;\n *   env?: Record<string, string>;\n *   encoding?: string;\n *   timeout?: number;\n *   maxBuffer?: number;\n *   killSignal?: string | number;\n *   uid?: number;\n *   gid?: number;\n *   windowsHide?: boolean;\n *   windowsVerbatimArguments?: boolean;\n *   shell?: boolean | string;\n *   signal?: AbortSignal;\n *   }} [options]\n * @param {(\n *   error?: Error,\n *   stdout?: string | Buffer,\n *   stderr?: string | Buffer\n *   ) => any} [callback]\n * @returns {ChildProcess}\n */\nexport function execFile(file, args, options, callback) {\n  ({ file, args, options, callback } = normalizeExecFileArgs(file, args, options, callback));\n\n  options = {\n    encoding: \"utf8\",\n    timeout: 0,\n    maxBuffer: MAX_BUFFER,\n    killSignal: \"SIGTERM\",\n    cwd: null,\n    env: null,\n    shell: false,\n    ...options,\n  };\n\n  const maxBuffer = options.maxBuffer;\n\n  // Validate the timeout, if present.\n  validateTimeout(options.timeout);\n\n  // Validate maxBuffer, if present.\n  validateMaxBuffer(maxBuffer);\n\n  options.killSignal = sanitizeKillSignal(options.killSignal);\n\n  const child = spawn(file, args, {\n    cwd: options.cwd,\n    env: options.env,\n    // gid: options.gid,\n    shell: options.shell,\n    signal: options.signal,\n    // uid: options.uid,\n  });\n\n  let encoding;\n  const _stdout = [];\n  const _stderr = [];\n  if (options.encoding !== \"buffer\" && BufferIsEncoding(options.encoding)) {\n    encoding = options.encoding;\n  } else {\n    encoding = null;\n  }\n  let stdoutLen = 0;\n  let stderrLen = 0;\n  let killed = false;\n  let exited = false;\n  let timeoutId;\n  let encodedStdoutLen;\n  let encodedStderrLen;\n\n  let ex = null;\n\n  let cmd = file;\n\n  function exitHandler(code, signal) {\n    if (exited) return;\n    exited = true;\n\n    if (timeoutId) {\n      clearTimeout(timeoutId);\n      timeoutId = null;\n    }\n\n    if (!callback) return;\n\n    const readableEncoding = child?.stdout?.readableEncoding;\n    // merge chunks\n    let stdout;\n    let stderr;\n    if (encoding || (child.stdout && readableEncoding)) {\n      stdout = ArrayPrototypeJoin.call(_stdout, \"\");\n    } else {\n      stdout = BufferConcat(_stdout);\n    }\n    if (encoding || (child.stderr && readableEncoding)) {\n      stderr = ArrayPrototypeJoin.call(_stderr, \"\");\n    } else {\n      stderr = BufferConcat(_stderr);\n    }\n\n    if (!ex && code === 0 && signal === null) {\n      callback(null, stdout, stderr);\n      return;\n    }\n\n    if (args?.length) cmd += ` ${ArrayPrototypeJoin.call(args, \" \")}`;\n    if (!ex) {\n      let message = `Command failed: ${cmd}`;\n      if (stderr) message += `\\n${stderr}`;\n      ex = genericNodeError(message, {\n        // code: code < 0 ? getSystemErrorName(code) : code, // TODO: Add getSystemErrorName\n        code: code,\n        killed: child.killed || killed,\n        signal: signal,\n      });\n    }\n\n    ex.cmd = cmd;\n    callback(ex, stdout, stderr);\n  }\n\n  function errorHandler(e) {\n    ex = e;\n\n    if (child.stdout) child.stdout.destroy();\n    if (child.stderr) child.stderr.destroy();\n\n    exitHandler();\n  }\n\n  function kill() {\n    if (child.stdout) child.stdout.destroy();\n    if (child.stderr) child.stderr.destroy();\n\n    killed = true;\n    try {\n      child.kill(options.killSignal);\n    } catch (e) {\n      ex = e;\n      exitHandler();\n    }\n  }\n\n  if (options.timeout > 0) {\n    timeoutId = setTimeout(function delayedKill() {\n      kill();\n      timeoutId = null;\n    }, options.timeout);\n  }\n\n  if (child.stdout) {\n    if (encoding) child.stdout.setEncoding(encoding);\n\n    child.stdout.on(\n      \"data\",\n      maxBuffer === Infinity\n        ? function onUnlimitedSizeBufferedData(chunk) {\n            ArrayPrototypePush.call(_stdout, chunk);\n          }\n        : encoding\n        ? function onChildStdoutEncoded(chunk) {\n            stdoutLen += chunk.length;\n\n            if (stdoutLen * 4 > maxBuffer) {\n              const encoding = child.stdout.readableEncoding;\n              const actualLen = Buffer.byteLength(chunk, encoding);\n              if (encodedStdoutLen === undefined) {\n                for (let i = 0; i < _stdout.length; i++) {\n                  encodedStdoutLen += Buffer.byteLength(_stdout[i], encoding);\n                }\n              } else {\n                encodedStdoutLen += actualLen;\n              }\n              const truncatedLen = maxBuffer - (encodedStdoutLen - actualLen);\n              ArrayPrototypePush.call(_stdout, StringPrototypeSlice.apply(chunk, 0, truncatedLen));\n\n              ex = new ERR_CHILD_PROCESS_STDIO_MAXBUFFER(\"stdout\");\n              kill();\n            } else {\n              ArrayPrototypePush.call(_stdout, chunk);\n            }\n          }\n        : function onChildStdoutRaw(chunk) {\n            stdoutLen += chunk.length;\n\n            if (stdoutLen > maxBuffer) {\n              const truncatedLen = maxBuffer - (stdoutLen - chunk.length);\n              ArrayPrototypePush.call(_stdout, chunk.slice(0, truncatedLen));\n\n              ex = new ERR_CHILD_PROCESS_STDIO_MAXBUFFER(\"stdout\");\n              kill();\n            } else {\n              ArrayPrototypePush.call(_stdout, chunk);\n            }\n          },\n    );\n  }\n\n  if (child.stderr) {\n    if (encoding) child.stderr.setEncoding(encoding);\n\n    child.stderr.on(\n      \"data\",\n      maxBuffer === Infinity\n        ? function onUnlimitedSizeBufferedData(chunk) {\n            ArrayPrototypePush.call(_stderr, chunk);\n          }\n        : encoding\n        ? function onChildStderrEncoded(chunk) {\n            stderrLen += chunk.length;\n\n            if (stderrLen * 4 > maxBuffer) {\n              const encoding = child.stderr.readableEncoding;\n              const actualLen = Buffer.byteLength(chunk, encoding);\n              if (encodedStderrLen === undefined) {\n                for (let i = 0; i < _stderr.length; i++) {\n                  encodedStderrLen += Buffer.byteLength(_stderr[i], encoding);\n                }\n              } else {\n                encodedStderrLen += actualLen;\n              }\n              const truncatedLen = maxBuffer - (encodedStderrLen - actualLen);\n              ArrayPrototypePush.call(_stderr, StringPrototypeSlice.call(chunk, 0, truncatedLen));\n\n              ex = new ERR_CHILD_PROCESS_STDIO_MAXBUFFER(\"stderr\");\n              kill();\n            } else {\n              ArrayPrototypePush.call(_stderr, chunk);\n            }\n          }\n        : function onChildStderrRaw(chunk) {\n            stderrLen += chunk.length;\n\n            if (stderrLen > maxBuffer) {\n              const truncatedLen = maxBuffer - (stderrLen - chunk.length);\n              ArrayPrototypePush.call(_stderr, StringPrototypeSlice.call(chunk, 0, truncatedLen));\n\n              ex = new ERR_CHILD_PROCESS_STDIO_MAXBUFFER(\"stderr\");\n              kill();\n            } else {\n              ArrayPrototypePush.call(_stderr, chunk);\n            }\n          },\n    );\n  }\n\n  child.addListener(\"close\", exitHandler);\n  child.addListener(\"error\", errorHandler);\n\n  return child;\n}\n\n/**\n * Spawns a shell executing the given command.\n * @param {string} command\n * @param {{\n *   cmd?: string;\n *   env?: Record<string, string>;\n *   encoding?: string;\n *   shell?: string;\n *   signal?: AbortSignal;\n *   timeout?: number;\n *   maxBuffer?: number;\n *   killSignal?: string | number;\n *   uid?: number;\n *   gid?: number;\n *   windowsHide?: boolean;\n *   }} [options]\n * @param {(\n *   error?: Error,\n *   stdout?: string | Buffer,\n *   stderr?: string | Buffer\n *   ) => any} [callback]\n * @returns {ChildProcess}\n */\nexport function exec(command, options, callback) {\n  const opts = normalizeExecArgs(command, options, callback);\n  return execFile(opts.file, opts.options, opts.callback);\n}\n\nconst customPromiseExecFunction = orig => {\n  return (...args) => {\n    let resolve;\n    let reject;\n    const promise = new Promise((res, rej) => {\n      resolve = res;\n      reject = rej;\n    });\n\n    promise.child = orig(...args, (err, stdout, stderr) => {\n      if (err !== null) {\n        err.stdout = stdout;\n        err.stderr = stderr;\n        reject(err);\n      } else {\n        resolve({ stdout, stderr });\n      }\n    });\n\n    return promise;\n  };\n};\n\nObjectDefineProperty(exec, promisify.custom, {\n  __proto__: null,\n  enumerable: false,\n  value: customPromiseExecFunction(exec),\n});\n\n/**\n * Spawns a new process synchronously using the given `file`.\n * @param {string} file\n * @param {string[]} [args]\n * @param {{\n *   cwd?: string;\n *   input?: string | Buffer | TypedArray | DataView;\n *   argv0?: string;\n *   stdio?: string | Array;\n *   env?: Record<string, string>;\n *   uid?: number;\n *   gid?: number;\n *   timeout?: number;\n *   killSignal?: string | number;\n *   maxBuffer?: number;\n *   encoding?: string;\n *   shell?: boolean | string;\n *   }} [options]\n * @returns {{\n *   pid: number;\n *   output: Array;\n *   stdout: Buffer | string;\n *   stderr: Buffer | string;\n *   status: number | null;\n *   signal: string | null;\n *   error: Error;\n *   }}\n */\nexport function spawnSync(file, args, options) {\n  options = {\n    maxBuffer: MAX_BUFFER,\n    ...normalizeSpawnArguments(file, args, options),\n  };\n\n  const maxBuffer = options.maxBuffer;\n  const encoding = options.encoding;\n\n  debug(\"spawnSync\", options);\n\n  // Validate the timeout, if present.\n  validateTimeout(options.timeout);\n\n  // Validate maxBuffer, if present.\n  validateMaxBuffer(maxBuffer);\n\n  // Validate and translate the kill signal, if present.\n  options.killSignal = sanitizeKillSignal(options.killSignal);\n\n  const stdio = options.stdio || \"pipe\";\n  const bunStdio = getBunStdioFromOptions(stdio);\n\n  var { input } = options;\n  if (input) {\n    if (ArrayBufferIsView(input)) {\n      bunStdio[0] = input;\n    } else if (typeof input === \"string\") {\n      bunStdio[0] = Buffer.from(input, encoding || \"utf8\");\n    } else {\n      throw new ERR_INVALID_ARG_TYPE(`options.stdio[0]`, [\"Buffer\", \"TypedArray\", \"DataView\", \"string\"], input);\n    }\n  }\n\n  const { stdout, stderr, success, exitCode } = Bun.spawnSync({\n    cmd: options.args,\n    env: options.env || undefined,\n    cwd: options.cwd || undefined,\n    stdin: bunStdio[0],\n    stdout: bunStdio[1],\n    stderr: bunStdio[2],\n  });\n\n  const result = {\n    signal: null,\n    status: exitCode,\n    output: [null, stdout, stderr],\n  };\n\n  if (stdout && encoding && encoding !== \"buffer\") {\n    result.output[1] = result.output[1]?.toString(encoding);\n  }\n\n  if (stderr && encoding && encoding !== \"buffer\") {\n    result.output[2] = result.output[2]?.toString(encoding);\n  }\n\n  result.stdout = result.output[1];\n  result.stderr = result.output[2];\n\n  if (!success) {\n    result.error = new SystemError(result.output[2], options.file, \"spawnSync\", -1, result.status);\n    result.error.spawnargs = ArrayPrototypeSlice.call(options.args, 1);\n  }\n\n  return result;\n}\n\n/**\n * Spawns a file as a shell synchronously.\n * @param {string} file\n * @param {string[]} [args]\n * @param {{\n *   cwd?: string;\n *   input?: string | Buffer | TypedArray | DataView;\n *   stdio?: string | Array;\n *   env?: Record<string, string>;\n *   uid?: number;\n *   gid?: number;\n *   timeout?: number;\n *   killSignal?: string | number;\n *   maxBuffer?: number;\n *   encoding?: string;\n *   windowsHide?: boolean;\n *   shell?: boolean | string;\n *   }} [options]\n * @returns {Buffer | string}\n */\nexport function execFileSync(file, args, options) {\n  ({ file, args, options } = normalizeExecFileArgs(file, args, options));\n\n  // const inheritStderr = !options.stdio;\n  const ret = spawnSync(file, args, options);\n\n  // if (inheritStderr && ret.stderr) process.stderr.write(ret.stderr);\n\n  const errArgs = [options.argv0 || file];\n  ArrayPrototypePush.apply(errArgs, args);\n  const err = checkExecSyncError(ret, errArgs);\n\n  if (err) throw err;\n\n  return ret.stdout;\n}\n\n/**\n * Spawns a shell executing the given `command` synchronously.\n * @param {string} command\n * @param {{\n *   cwd?: string;\n *   input?: string | Buffer | TypedArray | DataView;\n *   stdio?: string | Array;\n *   env?: Record<string, string>;\n *   shell?: string;\n *   uid?: number;\n *   gid?: number;\n *   timeout?: number;\n *   killSignal?: string | number;\n *   maxBuffer?: number;\n *   encoding?: string;\n *   windowsHide?: boolean;\n *   }} [options]\n * @returns {Buffer | string}\n */\nexport function execSync(command, options) {\n  const opts = normalizeExecArgs(command, options, null);\n  // const inheritStderr = !opts.options.stdio;\n\n  const ret = spawnSync(opts.file, opts.options);\n\n  // if (inheritStderr && ret.stderr) process.stderr.write(ret.stderr); // TODO: Uncomment when we have process.stderr\n\n  const err = checkExecSyncError(ret, undefined, command);\n\n  if (err) throw err;\n\n  return ret.stdout;\n}\n\nexport function fork() {\n  throw new Error(\"Not implemented\");\n}\n\n//------------------------------------------------------------------------------\n// Section 2. child_process helpers\n//------------------------------------------------------------------------------\nfunction convertToValidSignal(signal) {\n  if (typeof signal === \"number\" && getSignalsToNamesMapping()[signal]) return signal;\n\n  if (typeof signal === \"string\") {\n    const signalName = signals[StringPrototypeToUpperCase.call(signal)];\n    if (signalName) return signalName;\n  }\n\n  throw new ERR_UNKNOWN_SIGNAL(signal);\n}\n\nfunction sanitizeKillSignal(killSignal) {\n  if (typeof killSignal === \"string\" || typeof killSignal === \"number\") {\n    return convertToValidSignal(killSignal);\n  } else if (killSignal != null) {\n    throw new ERR_INVALID_ARG_TYPE(\"options.killSignal\", [\"string\", \"number\"], killSignal);\n  }\n}\n\nlet signalsToNamesMapping;\nfunction getSignalsToNamesMapping() {\n  if (signalsToNamesMapping !== undefined) return signalsToNamesMapping;\n\n  signalsToNamesMapping = ObjectCreate(null);\n  for (const key in signals) {\n    signalsToNamesMapping[signals[key]] = key;\n  }\n\n  return signalsToNamesMapping;\n}\n\nfunction normalizeExecFileArgs(file, args, options, callback) {\n  if (ArrayIsArray(args)) {\n    args = ArrayPrototypeSlice.call(args);\n  } else if (args != null && typeof args === \"object\") {\n    callback = options;\n    options = args;\n    args = null;\n  } else if (typeof args === \"function\") {\n    callback = args;\n    options = null;\n    args = null;\n  }\n\n  if (args == null) {\n    args = [];\n  }\n\n  if (typeof options === \"function\") {\n    callback = options;\n  } else if (options != null) {\n    validateObject(options, \"options\");\n  }\n\n  if (options == null) {\n    options = kEmptyObject;\n  }\n\n  if (callback != null) {\n    validateFunction(callback, \"callback\");\n  }\n\n  // Validate argv0, if present.\n  if (options.argv0 != null) {\n    validateString(options.argv0, \"options.argv0\");\n    validateArgumentNullCheck(options.argv0, \"options.argv0\");\n  }\n\n  return { file, args, options, callback };\n}\n\nfunction normalizeExecArgs(command, options, callback) {\n  validateString(command, \"command\");\n  validateArgumentNullCheck(command, \"command\");\n\n  if (typeof options === \"function\") {\n    callback = options;\n    options = undefined;\n  }\n\n  // Make a shallow copy so we don't clobber the user's options object.\n  options = { ...options };\n  options.shell = typeof options.shell === \"string\" ? options.shell : true;\n\n  return {\n    file: command,\n    options: options,\n    callback: callback,\n  };\n}\n\nfunction normalizeSpawnArguments(file, args, options) {\n  validateString(file, \"file\");\n  validateArgumentNullCheck(file, \"file\");\n\n  if (file.length === 0) throw new ERR_INVALID_ARG_VALUE(\"file\", file, \"cannot be empty\");\n\n  if (ArrayIsArray(args)) {\n    args = ArrayPrototypeSlice.call(args);\n  } else if (args == null) {\n    args = [];\n  } else if (typeof args !== \"object\") {\n    throw new ERR_INVALID_ARG_TYPE(\"args\", \"object\", args);\n  } else {\n    options = args;\n    args = [];\n  }\n\n  validateArgumentsNullCheck(args, \"args\");\n\n  if (options === undefined) options = {};\n  else validateObject(options, \"options\");\n\n  let cwd = options.cwd;\n\n  // Validate the cwd, if present.\n  if (cwd != null) {\n    cwd = getValidatedPath(cwd, \"options.cwd\");\n  }\n\n  // TODO: Detached check\n  // TODO: Gid check\n  // TODO: Uid check\n\n  // Validate the shell, if present.\n  if (options.shell != null && typeof options.shell !== \"boolean\" && typeof options.shell !== \"string\") {\n    throw new ERR_INVALID_ARG_TYPE(\"options.shell\", [\"boolean\", \"string\"], options.shell);\n  }\n\n  // Validate argv0, if present.\n  if (options.argv0 != null) {\n    validateString(options.argv0, \"options.argv0\");\n    validateArgumentNullCheck(options.argv0, \"options.argv0\");\n  }\n\n  // TODO: Windows checks for Windows specific options\n\n  // Handle shell\n  if (options.shell) {\n    validateArgumentNullCheck(options.shell, \"options.shell\");\n    const command = ArrayPrototypeJoin.call([file, ...args], \" \");\n    // TODO: Windows moment\n    // Set the shell, switches, and commands.\n    // if (process.platform === \"win32\") {\n    //   if (typeof options.shell === \"string\") file = options.shell;\n    //   else file = process.env.comspec || \"cmd.exe\";\n    //   // '/d /s /c' is used only for cmd.exe.\n    //   if (RegExpPrototypeExec(/^(?:.*\\\\)?cmd(?:\\.exe)?$/i, file) !== null) {\n    //     args = [\"/d\", \"/s\", \"/c\", `\"${command}\"`];\n    //     windowsVerbatimArguments = true;\n    //   } else {\n    //     args = [\"-c\", command];\n    //   }\n    // } else {\n    if (typeof options.shell === \"string\") file = options.shell;\n    else if (process.platform === \"android\") file = \"sh\";\n    else file = \"sh\";\n    args = [\"-c\", command];\n    // }\n  }\n\n  // Handle argv0\n  if (typeof options.argv0 === \"string\") {\n    ArrayPrototypeUnshift.call(args, options.argv0);\n  } else {\n    ArrayPrototypeUnshift.call(args, file);\n  }\n\n  const env = options.env || process.env;\n  const envPairs = env;\n\n  // // process.env.NODE_V8_COVERAGE always propagates, making it possible to\n  // // collect coverage for programs that spawn with white-listed environment.\n  // copyProcessEnvToEnv(env, \"NODE_V8_COVERAGE\", options.env);\n\n  // TODO: Windows env support here...\n\n  return { ...options, file, args, cwd, envPairs };\n}\n\nfunction checkExecSyncError(ret, args, cmd) {\n  let err;\n  if (ret.error) {\n    err = ret.error;\n    ObjectAssign(err, ret);\n  } else if (ret.status !== 0) {\n    let msg = \"Command failed: \";\n    msg += cmd || ArrayPrototypeJoin.call(args, \" \");\n    if (ret.stderr && ret.stderr.length > 0) msg += `\\n${ret.stderr.toString()}`;\n    err = genericNodeError(msg, ret);\n  }\n  return err;\n}\n\n//------------------------------------------------------------------------------\n// Section 3. ChildProcess class\n//------------------------------------------------------------------------------\nexport class ChildProcess extends EventEmitter {\n  #handle;\n  #exited = false;\n  #closesNeeded = 1;\n  #closesGot = 0;\n\n  connected = false;\n  signalCode = null;\n  exitCode = null;\n  spawnfile;\n  spawnargs;\n  pid;\n  channel;\n\n  get killed() {\n    if (this.#handle == null) return false;\n  }\n\n  // constructor(options) {\n  //   super(options);\n  //   this.#handle[owner_symbol] = this;\n  // }\n\n  #handleOnExit(exitCode, signalCode, err) {\n    if (this.#exited) return;\n    this.exitCode = this.#handle.exitCode;\n    this.signalCode = exitCode > 0 ? signalCode : null;\n\n    if (this.#stdin) {\n      this.#stdin.destroy();\n    }\n\n    if (this.#handle) {\n      this.#handle = null;\n    }\n\n    if (exitCode < 0) {\n      const err = new SystemError(\n        `Spawned process exited with error code: ${exitCode}`,\n        undefined,\n        \"spawn\",\n        \"EUNKNOWN\",\n        \"ERR_CHILD_PROCESS_UNKNOWN_ERROR\",\n      );\n\n      if (this.spawnfile) err.path = this.spawnfile;\n\n      err.spawnargs = ArrayPrototypeSlice.call(this.spawnargs, 1);\n      this.emit(\"error\", err);\n    } else {\n      this.emit(\"exit\", this.exitCode, this.signalCode);\n    }\n\n    // If any of the stdio streams have not been touched,\n    // then pull all the data through so that it can get the\n    // eof and emit a 'close' event.\n    // Do it on nextTick so that the user has one last chance\n    // to consume the output, if for example they only want to\n    // start reading the data once the process exits.\n    process.nextTick(flushStdio, this);\n\n    this.#maybeClose();\n    this.#exited = true;\n    this.#stdioOptions = [\"destroyed\", \"destroyed\", \"destroyed\"];\n  }\n\n  #getBunSpawnIo(i, encoding) {\n    if (__DEBUG__ && !this.#handle) {\n      if (this.#handle === null) {\n        debug(\"ChildProcess: getBunSpawnIo: this.#handle is null. This means the subprocess already exited\");\n      } else {\n        debug(\"ChildProcess: getBunSpawnIo: this.#handle is undefined\");\n      }\n    }\n    const io = this.#stdioOptions[i];\n    switch (i) {\n      case 0: {\n        switch (io) {\n          case \"pipe\":\n            return new NativeWritable(this.#handle.stdin);\n          case \"inherit\":\n            return process.stdin || null;\n          case \"destroyed\":\n            return new ShimmedStdin();\n          default:\n            return null;\n        }\n      }\n      case 2:\n      case 1: {\n        switch (io) {\n          case \"pipe\":\n            return ReadableFromWeb(\n              this.#handle[fdToStdioName(i)],\n              __TRACK_STDIO__\n                ? {\n                    encoding,\n                    __id: `PARENT_${fdToStdioName(i).toUpperCase()}-${globalThis.__getId()}`,\n                  }\n                : { encoding },\n            );\n          case \"inherit\":\n            return process[fdToStdioName(i)] || null;\n          case \"destroyed\":\n            return new ShimmedStdioOutStream();\n          default:\n            return null;\n        }\n      }\n    }\n  }\n\n  #stdin;\n  #stdout;\n  #stderr;\n  #stdioObject;\n  #encoding;\n  #stdioOptions;\n\n  #createStdioObject() {\n    return Object.create(null, {\n      0: {\n        get: () => this.stdin,\n      },\n      1: {\n        get: () => this.stdout,\n      },\n      2: {\n        get: () => this.stderr,\n      },\n    });\n  }\n\n  get stdin() {\n    return (this.#stdin ??= this.#getBunSpawnIo(0, this.#encoding));\n  }\n\n  get stdout() {\n    return (this.#stdout ??= this.#getBunSpawnIo(1, this.#encoding));\n  }\n\n  get stderr() {\n    return (this.#stderr ??= this.#getBunSpawnIo(2, this.#encoding));\n  }\n\n  get stdio() {\n    return (this.#stdioObject ??= this.#createStdioObject());\n  }\n\n  spawn(options) {\n    validateObject(options, \"options\");\n\n    // validateOneOf(options.serialization, \"options.serialization\", [\n    //   undefined,\n    //   \"json\",\n    //   // \"advanced\", // TODO\n    // ]);\n    // const serialization = options.serialization || \"json\";\n\n    // if (ipc !== undefined) {\n    //   // Let child process know about opened IPC channel\n    //   if (options.envPairs === undefined) options.envPairs = [];\n    //   else validateArray(options.envPairs, \"options.envPairs\");\n\n    //   ArrayPrototypePush.call(options.envPairs, `NODE_CHANNEL_FD=${ipcFd}`);\n    //   ArrayPrototypePush.call(\n    //     options.envPairs,\n    //     `NODE_CHANNEL_SERIALIZATION_MODE=${serialization}`\n    //   );\n    // }\n\n    validateString(options.file, \"options.file\");\n    // NOTE: This is confusing... So node allows you to pass a file name\n    // But also allows you to pass a command in the args and it should execute\n    // To add another layer of confusion, they also give the option to pass an explicit \"argv0\"\n    // which overrides the actual command of the spawned process...\n    var file;\n    file = this.spawnfile = options.file;\n\n    var spawnargs;\n    if (options.args == null) {\n      spawnargs = this.spawnargs = [];\n    } else {\n      validateArray(options.args, \"options.args\");\n      spawnargs = this.spawnargs = options.args;\n    }\n\n    const stdio = options.stdio || [\"pipe\", \"pipe\", \"pipe\"];\n    const bunStdio = getBunStdioFromOptions(stdio);\n\n    var env = options.envPairs || undefined;\n\n    this.#encoding = options.encoding || undefined;\n    this.#stdioOptions = bunStdio;\n    this.#handle = Bun.spawn({\n      cmd: spawnargs,\n      stdin: bunStdio[0],\n      stdout: bunStdio[1],\n      stderr: bunStdio[2],\n      cwd: options.cwd || undefined,\n      env: env || process.env,\n      onExit: (handle, exitCode, signalCode, err) => {\n        this.#handle = handle;\n        this.pid = this.#handle.pid;\n\n        process.nextTick(\n          (exitCode, signalCode, err) => this.#handleOnExit(exitCode, signalCode, err),\n          exitCode,\n          signalCode,\n          err,\n        );\n      },\n      lazy: true,\n    });\n    this.pid = this.#handle.pid;\n\n    onSpawnNT(this);\n\n    // const ipc = stdio.ipc;\n    // const ipcFd = stdio.ipcFd;\n    // stdio = options.stdio = stdio.stdio;\n\n    // for (i = 0; i < stdio.length; i++) {\n    //   const stream = stdio[i];\n    //   if (stream.type === \"ignore\") continue;\n\n    //   if (stream.ipc) {\n    //     this._closesNeeded++;\n    //     continue;\n    //   }\n\n    //   // The stream is already cloned and piped, thus stop its readable side,\n    //   // otherwise we might attempt to read from the stream when at the same time\n    //   // the child process does.\n    //   if (stream.type === \"wrap\") {\n    //     stream.handle.reading = false;\n    //     stream.handle.readStop();\n    //     stream._stdio.pause();\n    //     stream._stdio.readableFlowing = false;\n    //     stream._stdio._readableState.reading = false;\n    //     stream._stdio[kIsUsedAsStdio] = true;\n    //     continue;\n    //   }\n\n    //   if (stream.handle) {\n    //     stream.socket = createSocket(\n    //       this.pid !== 0 ? stream.handle : null,\n    //       i > 0\n    //     );\n\n    // // Add .send() method and start listening for IPC data\n    // if (ipc !== undefined) setupChannel(this, ipc, serialization);\n  }\n\n  send() {\n    console.log(\"ChildProcess.prototype.send() - Sorry! Not implemented yet\");\n  }\n\n  disconnect() {\n    console.log(\"ChildProcess.prototype.disconnect() - Sorry! Not implemented yet\");\n  }\n\n  kill(sig) {\n    const signal = sig === 0 ? sig : convertToValidSignal(sig === undefined ? \"SIGTERM\" : sig);\n\n    if (this.#handle) {\n      this.#handle.kill(signal);\n    }\n\n    this.#maybeClose();\n\n    // TODO: Figure out how to make this conform to the Node spec...\n    // The problem is that the handle does not report killed until the process exits\n    // So we can't return whether or not the process was killed because Bun.spawn seems to handle this async instead of sync like Node does\n    // return this.#handle?.killed ?? true;\n    return true;\n  }\n\n  #maybeClose() {\n    debug(\"Attempting to maybe close...\");\n    this.#closesGot++;\n    if (this.#closesGot === this.#closesNeeded) {\n      this.emit(\"close\", this.exitCode, this.signalCode);\n    }\n  }\n\n  ref() {\n    if (this.#handle) this.#handle.ref();\n  }\n\n  unref() {\n    if (this.#handle) this.#handle.unref();\n  }\n}\n\n//------------------------------------------------------------------------------\n// Section 4. ChildProcess helpers\n//------------------------------------------------------------------------------\nconst nodeToBunLookup = {\n  ignore: null,\n  pipe: \"pipe\",\n  overlapped: \"pipe\", // TODO: this may need to work differently for Windows\n  inherit: \"inherit\",\n};\n\nfunction nodeToBun(item) {\n  // If inherit and we are referencing stdin/stdout/stderr index,\n  // we can get the fd from the ReadStream for the corresponding stdio\n  if (typeof item === \"number\") {\n    return item;\n  } else {\n    const result = nodeToBunLookup[item];\n    if (result === undefined) throw new Error(\"Invalid stdio option\");\n    return result;\n  }\n}\n\nfunction fdToStdioName(fd) {\n  switch (fd) {\n    case 0:\n      return \"stdin\";\n    case 1:\n      return \"stdout\";\n    case 2:\n      return \"stderr\";\n    default:\n      return null;\n  }\n}\n\nfunction getBunStdioFromOptions(stdio) {\n  const normalizedStdio = normalizeStdio(stdio);\n  // Node options:\n  // pipe: just a pipe\n  // ipc = can only be one in array\n  // overlapped -- same as pipe on Unix based systems\n  // inherit -- 'inherit': equivalent to ['inherit', 'inherit', 'inherit'] or [0, 1, 2]\n  // ignore -- > /dev/null, more or less same as null option for Bun.spawn stdio\n  // TODO: Stream -- use this stream\n  // number -- used as FD\n  // null, undefined: Use default value. Not same as ignore, which is Bun.spawn null.\n  // null/undefined: For stdio fds 0, 1, and 2 (in other words, stdin, stdout, and stderr) a pipe is created. For fd 3 and up, the default is 'ignore'\n\n  // Important Bun options\n  // pipe\n  // fd\n  // null - no stdin/stdout/stderr\n\n  // Translations: node -> bun\n  // pipe -> pipe\n  // overlapped -> pipe\n  // ignore -> null\n  // inherit -> inherit (stdin/stdout/stderr)\n  // Stream -> throw err for now\n  const bunStdio = normalizedStdio.map(item => nodeToBun(item));\n  return bunStdio;\n}\n\nfunction normalizeStdio(stdio) {\n  if (typeof stdio === \"string\") {\n    switch (stdio) {\n      case \"ignore\":\n        return [\"ignore\", \"ignore\", \"ignore\"];\n      case \"pipe\":\n        return [\"pipe\", \"pipe\", \"pipe\"];\n      case \"inherit\":\n        return [\"inherit\", \"inherit\", \"inherit\"];\n      default:\n        throw new ERR_INVALID_OPT_VALUE(\"stdio\", stdio);\n    }\n  } else if (ArrayIsArray(stdio)) {\n    // Validate if each is a valid stdio type\n    // TODO: Support wrapped types here\n\n    let processedStdio;\n    if (stdio.length === 0) processedStdio = [\"pipe\", \"pipe\", \"pipe\"];\n    else if (stdio.length === 1) processedStdio = [stdio[0], \"pipe\", \"pipe\"];\n    else if (stdio.length === 2) processedStdio = [stdio[0], stdio[1], \"pipe\"];\n    else if (stdio.length >= 3) processedStdio = [stdio[0], stdio[1], stdio[2]];\n\n    return processedStdio.map(item => (!item ? \"pipe\" : item));\n  } else {\n    throw new ERR_INVALID_OPT_VALUE(\"stdio\", stdio);\n  }\n}\n\nfunction flushStdio(subprocess) {\n  const stdio = subprocess.stdio;\n  if (stdio == null) return;\n\n  for (let i = 0; i < stdio.length; i++) {\n    const stream = stdio[i];\n    // TODO(addaleax): This doesn't necessarily account for all the ways in\n    // which data can be read from a stream, e.g. being consumed on the\n    // native layer directly as a StreamBase.\n    if (!stream || !stream.readable) {\n      continue;\n    }\n    stream.resume();\n  }\n}\n\nfunction onSpawnNT(self) {\n  self.emit(\"spawn\");\n}\n\nfunction abortChildProcess(child, killSignal) {\n  if (!child) return;\n  try {\n    if (child.kill(killSignal)) {\n      child.emit(\"error\", new AbortError());\n    }\n  } catch (err) {\n    child.emit(\"error\", err);\n  }\n}\n\nclass ShimmedStdin extends EventEmitter {\n  constructor() {\n    super();\n  }\n  write() {\n    return false;\n  }\n  destroy() {}\n  end() {}\n  pipe() {}\n}\n\nclass ShimmedStdioOutStream extends EventEmitter {\n  pipe() {}\n}\n\n//------------------------------------------------------------------------------\n// Section 5. Validators\n//------------------------------------------------------------------------------\n\nfunction validateMaxBuffer(maxBuffer) {\n  if (maxBuffer != null && !(typeof maxBuffer === \"number\" && maxBuffer >= 0)) {\n    throw new ERR_OUT_OF_RANGE(\"options.maxBuffer\", \"a positive number\", maxBuffer);\n  }\n}\n\nfunction validateArgumentNullCheck(arg, propName) {\n  if (typeof arg === \"string\" && StringPrototypeIncludes.call(arg, \"\\u0000\")) {\n    throw new ERR_INVALID_ARG_VALUE(propName, arg, \"must be a string without null bytes\");\n  }\n}\n\nfunction validateArgumentsNullCheck(args, propName) {\n  for (let i = 0; i < args.length; ++i) {\n    validateArgumentNullCheck(args[i], `${propName}[${i}]`);\n  }\n}\n\nfunction validateTimeout(timeout) {\n  if (timeout != null && !(NumberIsInteger(timeout) && timeout >= 0)) {\n    throw new ERR_OUT_OF_RANGE(\"timeout\", \"an unsigned integer\", timeout);\n  }\n}\n\nfunction validateBoolean(value, name) {\n  if (typeof value !== \"boolean\") throw new ERR_INVALID_ARG_TYPE(name, \"boolean\", value);\n}\n\n/**\n * @callback validateFunction\n * @param {*} value\n * @param {string} name\n * @returns {asserts value is Function}\n */\n\n/** @type {validateFunction} */\nfunction validateFunction(value, name) {\n  if (typeof value !== \"function\") throw new ERR_INVALID_ARG_TYPE(name, \"Function\", value);\n}\n\n/**\n * @callback validateAbortSignal\n * @param {*} signal\n * @param {string} name\n */\n\n/** @type {validateAbortSignal} */\nconst validateAbortSignal = (signal, name) => {\n  if (signal !== undefined && (signal === null || typeof signal !== \"object\" || !(\"aborted\" in signal))) {\n    throw new ERR_INVALID_ARG_TYPE(name, \"AbortSignal\", signal);\n  }\n};\n\n/**\n * @callback validateOneOf\n * @template T\n * @param {T} value\n * @param {string} name\n * @param {T[]} oneOf\n */\n\n/** @type {validateOneOf} */\nconst validateOneOf = (value, name, oneOf) => {\n  // const validateOneOf = hideStackFrames((value, name, oneOf) => {\n  if (!ArrayPrototypeIncludes.call(oneOf, value)) {\n    const allowed = ArrayPrototypeJoin.call(\n      ArrayPrototypeMap.call(oneOf, v => (typeof v === \"string\" ? `'${v}'` : String(v))),\n      \", \",\n    );\n    const reason = \"must be one of: \" + allowed;\n    throw new ERR_INVALID_ARG_VALUE(name, value, reason);\n  }\n};\n\n/**\n * @callback validateObject\n * @param {*} value\n * @param {string} name\n * @param {{\n *   allowArray?: boolean,\n *   allowFunction?: boolean,\n *   nullable?: boolean\n * }} [options]\n */\n\n/** @type {validateObject} */\nconst validateObject = (value, name, options = null) => {\n  // const validateObject = hideStackFrames((value, name, options = null) => {\n  const allowArray = options?.allowArray ?? false;\n  const allowFunction = options?.allowFunction ?? false;\n  const nullable = options?.nullable ?? false;\n  if (\n    (!nullable && value === null) ||\n    (!allowArray && ArrayIsArray.call(value)) ||\n    (typeof value !== \"object\" && (!allowFunction || typeof value !== \"function\"))\n  ) {\n    throw new ERR_INVALID_ARG_TYPE(name, \"object\", value);\n  }\n};\n\n/**\n * @callback validateArray\n * @param {*} value\n * @param {string} name\n * @param {number} [minLength]\n * @returns {asserts value is any[]}\n */\n\n/** @type {validateArray} */\nconst validateArray = (value, name, minLength = 0) => {\n  // const validateArray = hideStackFrames((value, name, minLength = 0) => {\n  if (!ArrayIsArray(value)) {\n    throw new ERR_INVALID_ARG_TYPE(name, \"Array\", value);\n  }\n  if (value.length < minLength) {\n    const reason = `must be longer than ${minLength}`;\n    throw new ERR_INVALID_ARG_VALUE(name, value, reason);\n  }\n};\n\n/**\n * @callback validateString\n * @param {*} value\n * @param {string} name\n * @returns {asserts value is string}\n */\n\n/** @type {validateString} */\nfunction validateString(value, name) {\n  if (typeof value !== \"string\") throw new ERR_INVALID_ARG_TYPE(name, \"string\", value);\n}\n\nfunction nullCheck(path, propName, throwError = true) {\n  const pathIsString = typeof path === \"string\";\n  const pathIsUint8Array = isUint8Array(path);\n\n  // We can only perform meaningful checks on strings and Uint8Arrays.\n  if (\n    (!pathIsString && !pathIsUint8Array) ||\n    (pathIsString && !StringPrototypeIncludes.call(path, \"\\u0000\")) ||\n    (pathIsUint8Array && !Uint8ArrayPrototypeIncludes.call(path, 0))\n  ) {\n    return;\n  }\n\n  const err = new ERR_INVALID_ARG_VALUE(propName, path, \"must be a string or Uint8Array without null bytes\");\n  if (throwError) {\n    throw err;\n  }\n  return err;\n}\n\nfunction validatePath(path, propName = \"path\") {\n  if (typeof path !== \"string\" && !isUint8Array(path)) {\n    throw new ERR_INVALID_ARG_TYPE(propName, [\"string\", \"Buffer\", \"URL\"], path);\n  }\n\n  const err = nullCheck(path, propName, false);\n\n  if (err !== undefined) {\n    throw err;\n  }\n}\n\nfunction getValidatedPath(fileURLOrPath, propName = \"path\") {\n  const path = toPathIfFileURL(fileURLOrPath);\n  validatePath(path, propName);\n  return path;\n}\n\nfunction isUint8Array(value) {\n  return typeof value === \"object\" && value !== null && value instanceof Uint8Array;\n}\n\n//------------------------------------------------------------------------------\n// Section 6. Random utilities\n//------------------------------------------------------------------------------\n\nfunction isURLInstance(fileURLOrPath) {\n  return fileURLOrPath != null && fileURLOrPath.href && fileURLOrPath.origin;\n}\n\nfunction toPathIfFileURL(fileURLOrPath) {\n  if (!isURLInstance(fileURLOrPath)) return fileURLOrPath;\n  return Bun.fileURLToPath(fileURLOrPath);\n}\n\n//------------------------------------------------------------------------------\n// Section 7. Node errors / error polyfills\n//------------------------------------------------------------------------------\nvar Error = globalThis.Error;\nvar TypeError = globalThis.TypeError;\nvar RangeError = globalThis.RangeError;\n\n// Node uses a slightly different abort error than standard DOM. See: https://github.com/nodejs/node/blob/main/lib/internal/errors.js\nclass AbortError extends Error {\n  code = \"ABORT_ERR\";\n  name = \"AbortError\";\n  constructor(message = \"The operation was aborted\", options = undefined) {\n    if (options !== undefined && typeof options !== \"object\") {\n      throw new ERR_INVALID_ARG_TYPE(\"options\", \"Object\", options);\n    }\n    super(message, options);\n  }\n}\n\nfunction genericNodeError(message, options) {\n  const err = new Error(message);\n  err.code = options.code;\n  err.killed = options.killed;\n  err.signal = options.signal;\n  return err;\n}\n\n// const messages = new Map();\n\n// Utility function for registering the error codes. Only used here. Exported\n// *only* to allow for testing.\n// function E(sym, val, def) {\n//   messages.set(sym, val);\n//   def = makeNodeErrorWithCode(def, sym);\n//   errorCodes[sym] = def;\n// }\n\n// function makeNodeErrorWithCode(Base, key) {\n//   return function NodeError(...args) {\n//     // const limit = Error.stackTraceLimit;\n//     // if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = 0;\n//     const error = new Base();\n//     // Reset the limit and setting the name property.\n//     // if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = limit;\n//     const message = getMessage(key, args);\n//     error.message = message;\n//     // captureLargerStackTrace(error);\n//     error.code = key;\n//     return error;\n//   };\n// }\n\n// function getMessage(key, args) {\n//   const msgFn = messages.get(key);\n//   if (args.length !== msgFn.length)\n//     throw new Error(\n//       `Invalid number of args for error message ${key}. Got ${args.length}, expected ${msgFn.length}.`\n//     );\n//   return msgFn(...args);\n// }\n\n// E(\n//   \"ERR_INVALID_ARG_TYPE\",\n//   (name, expected, actual) => {\n//     assert(typeof name === \"string\", \"'name' must be a string\");\n//     if (!ArrayIsArray(expected)) {\n//       expected = [expected];\n//     }\n\n//     let msg = \"The \";\n//     if (StringPrototypeEndsWith(name, \" argument\")) {\n//       // For cases like 'first argument'\n//       msg += `${name} `;\n//     } else {\n//       const type = StringPrototypeIncludes(name, \".\") ? \"property\" : \"argument\";\n//       msg += `\"${name}\" ${type} `;\n//     }\n//     msg += \"must be \";\n\n//     const types = [];\n//     const instances = [];\n//     const other = [];\n\n//     for (const value of expected) {\n//       assert(\n//         typeof value === \"string\",\n//         \"All expected entries have to be of type string\"\n//       );\n//       if (ArrayPrototypeIncludes.call(kTypes, value)) {\n//         ArrayPrototypePush(types, StringPrototypeToLowerCase(value));\n//       } else if (RegExpPrototypeExec(classRegExp, value) !== null) {\n//         ArrayPrototypePush(instances, value);\n//       } else {\n//         assert(\n//           value !== \"object\",\n//           'The value \"object\" should be written as \"Object\"'\n//         );\n//         ArrayPrototypePush(other, value);\n//       }\n//     }\n\n//     // Special handle `object` in case other instances are allowed to outline\n//     // the differences between each other.\n//     if (instances.length > 0) {\n//       const pos = ArrayPrototypeIndexOf(types, \"object\");\n//       if (pos !== -1) {\n//         ArrayPrototypeSplice.call(types, pos, 1);\n//         ArrayPrototypePush.call(instances, \"Object\");\n//       }\n//     }\n\n//     if (types.length > 0) {\n//       if (types.length > 2) {\n//         const last = ArrayPrototypePop(types);\n//         msg += `one of type ${ArrayPrototypeJoin(types, \", \")}, or ${last}`;\n//       } else if (types.length === 2) {\n//         msg += `one of type ${types[0]} or ${types[1]}`;\n//       } else {\n//         msg += `of type ${types[0]}`;\n//       }\n//       if (instances.length > 0 || other.length > 0) msg += \" or \";\n//     }\n\n//     if (instances.length > 0) {\n//       if (instances.length > 2) {\n//         const last = ArrayPrototypePop(instances);\n//         msg += `an instance of ${ArrayPrototypeJoin(\n//           instances,\n//           \", \"\n//         )}, or ${last}`;\n//       } else {\n//         msg += `an instance of ${instances[0]}`;\n//         if (instances.length === 2) {\n//           msg += ` or ${instances[1]}`;\n//         }\n//       }\n//       if (other.length > 0) msg += \" or \";\n//     }\n\n//     if (other.length > 0) {\n//       if (other.length > 2) {\n//         const last = ArrayPrototypePop(other);\n//         msg += `one of ${ArrayPrototypeJoin.call(other, \", \")}, or ${last}`;\n//       } else if (other.length === 2) {\n//         msg += `one of ${other[0]} or ${other[1]}`;\n//       } else {\n//         if (StringPrototypeToLowerCase(other[0]) !== other[0]) msg += \"an \";\n//         msg += `${other[0]}`;\n//       }\n//     }\n\n//     msg += `. Received ${determineSpecificType(actual)}`;\n\n//     return msg;\n//   },\n//   TypeError\n// );\n\nfunction ERR_OUT_OF_RANGE(str, range, input, replaceDefaultBoolean = false) {\n  // Node implementation:\n  // assert(range, 'Missing \"range\" argument');\n  // let msg = replaceDefaultBoolean\n  //   ? str\n  //   : `The value of \"${str}\" is out of range.`;\n  // let received;\n  // if (NumberIsInteger(input) && MathAbs(input) > 2 ** 32) {\n  //   received = addNumericalSeparator(String(input));\n  // } else if (typeof input === \"bigint\") {\n  //   received = String(input);\n  //   if (input > 2n ** 32n || input < -(2n ** 32n)) {\n  //     received = addNumericalSeparator(received);\n  //   }\n  //   received += \"n\";\n  // } else {\n  //   received = lazyInternalUtilInspect().inspect(input);\n  // }\n  // msg += ` It must be ${range}. Received ${received}`;\n  // return new RangeError(msg);\n  return new RangeError(`The value of ${str} is out of range. It must be ${range}. Received ${input}`);\n}\n\nfunction ERR_CHILD_PROCESS_STDIO_MAXBUFFER(stdio) {\n  return Error(`${stdio} maxBuffer length exceeded`);\n}\n\nfunction ERR_UNKNOWN_SIGNAL(name) {\n  const err = new TypeError(`Unknown signal: ${name}`);\n  err.code = \"ERR_UNKNOWN_SIGNAL\";\n  return err;\n}\n\nfunction ERR_INVALID_ARG_TYPE(name, type, value) {\n  const err = new TypeError(`The \"${name}\" argument must be of type ${type}. Received ${value}`);\n  err.code = \"ERR_INVALID_ARG_TYPE\";\n  return err;\n}\n\nfunction ERR_INVALID_OPT_VALUE(name, value) {\n  return new TypeError(`The value \"${value}\" is invalid for option \"${name}\"`);\n}\n\nfunction ERR_INVALID_ARG_VALUE(name, value, reason) {\n  return new Error(`The value \"${value}\" is invalid for argument '${name}'. Reason: ${reason}`);\n}\n\nclass SystemError extends Error {\n  path;\n  syscall;\n  errno;\n  code;\n  constructor(message, path, syscall, errno, code) {\n    super(message);\n    this.path = path;\n    this.syscall = syscall;\n    this.errno = errno;\n    this.code = code;\n  }\n\n  get name() {\n    return \"SystemError\";\n  }\n}\n\nexport default {\n  ChildProcess,\n  spawn,\n  execFile,\n  exec,\n  fork,\n  spawnSync,\n  execFileSync,\n  execSync,\n\n  [Symbol.for(\"CommonJS\")]: 0,\n};\n",
  "// Hardcoded module \"node:child_process\"\nconst EventEmitter = import.meta.require(\"node:events\");\nconst {\n  Readable: { fromWeb: ReadableFromWeb },\n  NativeWritable,\n} = import.meta.require(\"node:stream\");\nconst {\n  constants: { signals },\n} = import.meta.require(\"node:os\");\nconst { promisify } = import.meta.require(\"node:util\");\n\nconst { ArrayBuffer, Uint8Array, String, Object, Buffer, Promise } = import.meta.primordials;\n\nvar ObjectPrototypeHasOwnProperty = Object.prototype.hasOwnProperty;\nvar ObjectCreate = Object.create;\nvar ObjectAssign = Object.assign;\nvar ObjectDefineProperty = Object.defineProperty;\nvar BufferConcat = Buffer.concat;\nvar BufferIsEncoding = Buffer.isEncoding;\n\nvar kEmptyObject = ObjectCreate(null);\n\nvar ArrayPrototypePush = Array.prototype.push;\nvar ArrayPrototypeReduce = Array.prototype.reduce;\nvar ArrayPrototypeFilter = Array.prototype.filter;\nvar ArrayPrototypeJoin = Array.prototype.join;\nvar ArrayPrototypeMap = Array.prototype.map;\nvar ArrayPrototypeIncludes = Array.prototype.includes;\nvar ArrayPrototypeSlice = Array.prototype.slice;\nvar ArrayPrototypeUnshift = Array.prototype.unshift;\nvar ArrayIsArray = Array.isArray;\n\n// var ArrayBuffer = ArrayBuffer;\nvar ArrayBufferIsView = ArrayBuffer.isView;\n\nvar NumberIsInteger = Number.isInteger;\nvar MathAbs = Math.abs;\n\nvar StringPrototypeToUpperCase = String.prototype.toUpperCase;\nvar StringPrototypeIncludes = String.prototype.includes;\nvar StringPrototypeSlice = String.prototype.slice;\nvar Uint8ArrayPrototypeIncludes = Uint8Array.prototype.includes;\n\nconst MAX_BUFFER = 1024 * 1024;\n\n// General debug vs tracking stdio streams. Useful for stream debugging in particular\nconst __DEBUG__ = process.env.DEBUG || false;\n\n// You can use this env var along with `process.env.DEBUG_TRACK_EE` to debug stdio streams\n// Just set `DEBUG_TRACK_EE=PARENT_STDOUT-0, PARENT_STDOUT-1`, etc. and `DEBUG_STDIO=1` and you will be able to track particular stdio streams\n// TODO: Add ability to track a range of IDs rather than just enumerated ones\nconst __TRACK_STDIO__ = process.env.DEBUG_STDIO;\nconst debug = __DEBUG__ ? console.log : () => {};\n\nif (__TRACK_STDIO__) {\n  debug(\"child_process: debug mode on\");\n  globalThis.__lastId = null;\n  globalThis.__getId = () => {\n    return globalThis.__lastId !== null ? globalThis.__lastId++ : 0;\n  };\n}\n\n// Sections:\n// 1. Exported child_process functions\n// 2. child_process helpers\n// 3. ChildProcess \"class\"\n// 4. ChildProcess helpers\n// 5. Validators\n// 6. Random utilities\n// 7. Node errors / error polyfills\n\n// TODO:\n// Port rest of node tests\n// Fix exit codes with Bun.spawn\n// ------------------------------\n// Fix errors\n// Support file descriptors being passed in for stdio\n// ------------------------------\n// TODO: Look at Pipe to see if we can support passing Node Pipe objects to stdio param\n\n// TODO: Add these params after support added in Bun.spawn\n// uid <number> Sets the user identity of the process (see setuid(2)).\n// gid <number> Sets the group identity of the process (see setgid(2)).\n// detached <boolean> Prepare child to run independently of its parent process. Specific behavior depends on the platform, see options.detached).\n\n// TODO: After IPC channels can be opened\n// serialization <string> Specify the kind of serialization used for sending messages between processes. Possible values are 'json' and 'advanced'. See Advanced serialization for more details. Default: 'json'.\n\n// TODO: Add support for ipc option, verify only one IPC channel in array\n// stdio <Array> | <string> Child's stdio configuration (see options.stdio).\n// Support wrapped ipc types (e.g. net.Socket, dgram.Socket, TTY, etc.)\n// IPC FD passing support\n\n// From node child_process docs(https://nodejs.org/api/child_process.html#optionsstdio):\n// 'ipc': Create an IPC channel for passing messages/file descriptors between parent and child.\n// A ChildProcess may have at most one IPC stdio file descriptor. Setting this option enables the subprocess.send() method.\n// If the child is a Node.js process, the presence of an IPC channel will enable process.send() and process.disconnect() methods,\n// as well as 'disconnect' and 'message' events within the child.\n\n//------------------------------------------------------------------------------\n// Section 1. Exported child_process functions\n//------------------------------------------------------------------------------\n\n// TODO: Implement these props when Windows is supported\n// *   windowsVerbatimArguments?: boolean;\n// *   windowsHide?: boolean;\n\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nfunction spawnTimeoutFunction(child, timeoutHolder) {\n  var timeoutId = timeoutHolder.timeoutId;\n  if (timeoutId > -1) {\n    try {\n      child.kill(killSignal);\n    } catch (err) {\n      child.emit(\"error\", err);\n    }\n    timeoutHolder.timeoutId = -1;\n  }\n}\n/**\n * Spawns a new process using the given `file`.\n * @param {string} file\n * @param {string[]} [args]\n * @param {{\n *   cwd?: string;\n *   env?: Record<string, string>;\n *   argv0?: string;\n *   stdio?: Array | string;\n *   detached?: boolean;\n *   uid?: number;\n *   gid?: number;\n *   serialization?: string;\n *   shell?: boolean | string;\n *   signal?: AbortSignal;\n *   timeout?: number;\n *   killSignal?: string | number;\n *   }} [options]\n * @returns {ChildProcess}\n */\nexport function spawn(file, args, options) {\n  options = normalizeSpawnArguments(file, args, options);\n  validateTimeout(options.timeout);\n  validateAbortSignal(options.signal, \"options.signal\");\n  const killSignal = sanitizeKillSignal(options.killSignal);\n  const child = new ChildProcess();\n\n  debug(\"spawn\", options);\n  child.spawn(options);\n\n  if (options.timeout > 0) {\n    let timeoutId = setTimeout(() => {\n      if (timeoutId) {\n        try {\n          child.kill(killSignal);\n        } catch (err) {\n          child.emit(\"error\", err);\n        }\n        timeoutId = null;\n      }\n    });\n\n    child.once(\"exit\", () => {\n      if (timeoutId) {\n        clearTimeout(timeoutId);\n        timeoutId = null;\n      }\n    });\n  }\n\n  if (options.signal) {\n    const signal = options.signal;\n    if (signal.aborted) {\n      process.nextTick(onAbortListener);\n    } else {\n      signal.addEventListener(\"abort\", onAbortListener, { once: true });\n      child.once(\"exit\", () => signal.removeEventListener(\"abort\", onAbortListener));\n    }\n\n    function onAbortListener() {\n      abortChildProcess(child, killSignal);\n    }\n  }\n  return child;\n}\n\n/**\n * Spawns the specified file as a shell.\n * @param {string} file\n * @param {string[]} [args]\n * @param {{\n *   cwd?: string;\n *   env?: Record<string, string>;\n *   encoding?: string;\n *   timeout?: number;\n *   maxBuffer?: number;\n *   killSignal?: string | number;\n *   uid?: number;\n *   gid?: number;\n *   windowsHide?: boolean;\n *   windowsVerbatimArguments?: boolean;\n *   shell?: boolean | string;\n *   signal?: AbortSignal;\n *   }} [options]\n * @param {(\n *   error?: Error,\n *   stdout?: string | Buffer,\n *   stderr?: string | Buffer\n *   ) => any} [callback]\n * @returns {ChildProcess}\n */\nexport function execFile(file, args, options, callback) {\n  ({ file, args, options, callback } = normalizeExecFileArgs(file, args, options, callback));\n\n  options = {\n    encoding: \"utf8\",\n    timeout: 0,\n    maxBuffer: MAX_BUFFER,\n    killSignal: \"SIGTERM\",\n    cwd: null,\n    env: null,\n    shell: false,\n    ...options,\n  };\n\n  const maxBuffer = options.maxBuffer;\n\n  // Validate the timeout, if present.\n  validateTimeout(options.timeout);\n\n  // Validate maxBuffer, if present.\n  validateMaxBuffer(maxBuffer);\n\n  options.killSignal = sanitizeKillSignal(options.killSignal);\n\n  const child = spawn(file, args, {\n    cwd: options.cwd,\n    env: options.env,\n    // gid: options.gid,\n    shell: options.shell,\n    signal: options.signal,\n    // uid: options.uid,\n  });\n\n  let encoding;\n  const _stdout = [];\n  const _stderr = [];\n  if (options.encoding !== \"buffer\" && BufferIsEncoding(options.encoding)) {\n    encoding = options.encoding;\n  } else {\n    encoding = null;\n  }\n  let stdoutLen = 0;\n  let stderrLen = 0;\n  let killed = false;\n  let exited = false;\n  let timeoutId;\n  let encodedStdoutLen;\n  let encodedStderrLen;\n\n  let ex = null;\n\n  let cmd = file;\n\n  function exitHandler(code, signal) {\n    if (exited) return;\n    exited = true;\n\n    if (timeoutId) {\n      clearTimeout(timeoutId);\n      timeoutId = null;\n    }\n\n    if (!callback) return;\n\n    const readableEncoding = child?.stdout?.readableEncoding;\n    // merge chunks\n    let stdout;\n    let stderr;\n    if (encoding || (child.stdout && readableEncoding)) {\n      stdout = ArrayPrototypeJoin.call(_stdout, \"\");\n    } else {\n      stdout = BufferConcat(_stdout);\n    }\n    if (encoding || (child.stderr && readableEncoding)) {\n      stderr = ArrayPrototypeJoin.call(_stderr, \"\");\n    } else {\n      stderr = BufferConcat(_stderr);\n    }\n\n    if (!ex && code === 0 && signal === null) {\n      callback(null, stdout, stderr);\n      return;\n    }\n\n    if (args?.length) cmd += ` ${ArrayPrototypeJoin.call(args, \" \")}`;\n    if (!ex) {\n      let message = `Command failed: ${cmd}`;\n      if (stderr) message += `\\n${stderr}`;\n      ex = genericNodeError(message, {\n        // code: code < 0 ? getSystemErrorName(code) : code, // TODO: Add getSystemErrorName\n        code: code,\n        killed: child.killed || killed,\n        signal: signal,\n      });\n    }\n\n    ex.cmd = cmd;\n    callback(ex, stdout, stderr);\n  }\n\n  function errorHandler(e) {\n    ex = e;\n\n    if (child.stdout) child.stdout.destroy();\n    if (child.stderr) child.stderr.destroy();\n\n    exitHandler();\n  }\n\n  function kill() {\n    if (child.stdout) child.stdout.destroy();\n    if (child.stderr) child.stderr.destroy();\n\n    killed = true;\n    try {\n      child.kill(options.killSignal);\n    } catch (e) {\n      ex = e;\n      exitHandler();\n    }\n  }\n\n  if (options.timeout > 0) {\n    timeoutId = setTimeout(function delayedKill() {\n      kill();\n      timeoutId = null;\n    }, options.timeout);\n  }\n\n  if (child.stdout) {\n    if (encoding) child.stdout.setEncoding(encoding);\n\n    child.stdout.on(\n      \"data\",\n      maxBuffer === Infinity\n        ? function onUnlimitedSizeBufferedData(chunk) {\n            ArrayPrototypePush.call(_stdout, chunk);\n          }\n        : encoding\n        ? function onChildStdoutEncoded(chunk) {\n            stdoutLen += chunk.length;\n\n            if (stdoutLen * 4 > maxBuffer) {\n              const encoding = child.stdout.readableEncoding;\n              const actualLen = Buffer.byteLength(chunk, encoding);\n              if (encodedStdoutLen === undefined) {\n                for (let i = 0; i < _stdout.length; i++) {\n                  encodedStdoutLen += Buffer.byteLength(_stdout[i], encoding);\n                }\n              } else {\n                encodedStdoutLen += actualLen;\n              }\n              const truncatedLen = maxBuffer - (encodedStdoutLen - actualLen);\n              ArrayPrototypePush.call(_stdout, StringPrototypeSlice.apply(chunk, 0, truncatedLen));\n\n              ex = new ERR_CHILD_PROCESS_STDIO_MAXBUFFER(\"stdout\");\n              kill();\n            } else {\n              ArrayPrototypePush.call(_stdout, chunk);\n            }\n          }\n        : function onChildStdoutRaw(chunk) {\n            stdoutLen += chunk.length;\n\n            if (stdoutLen > maxBuffer) {\n              const truncatedLen = maxBuffer - (stdoutLen - chunk.length);\n              ArrayPrototypePush.call(_stdout, chunk.slice(0, truncatedLen));\n\n              ex = new ERR_CHILD_PROCESS_STDIO_MAXBUFFER(\"stdout\");\n              kill();\n            } else {\n              ArrayPrototypePush.call(_stdout, chunk);\n            }\n          },\n    );\n  }\n\n  if (child.stderr) {\n    if (encoding) child.stderr.setEncoding(encoding);\n\n    child.stderr.on(\n      \"data\",\n      maxBuffer === Infinity\n        ? function onUnlimitedSizeBufferedData(chunk) {\n            ArrayPrototypePush.call(_stderr, chunk);\n          }\n        : encoding\n        ? function onChildStderrEncoded(chunk) {\n            stderrLen += chunk.length;\n\n            if (stderrLen * 4 > maxBuffer) {\n              const encoding = child.stderr.readableEncoding;\n              const actualLen = Buffer.byteLength(chunk, encoding);\n              if (encodedStderrLen === undefined) {\n                for (let i = 0; i < _stderr.length; i++) {\n                  encodedStderrLen += Buffer.byteLength(_stderr[i], encoding);\n                }\n              } else {\n                encodedStderrLen += actualLen;\n              }\n              const truncatedLen = maxBuffer - (encodedStderrLen - actualLen);\n              ArrayPrototypePush.call(_stderr, StringPrototypeSlice.call(chunk, 0, truncatedLen));\n\n              ex = new ERR_CHILD_PROCESS_STDIO_MAXBUFFER(\"stderr\");\n              kill();\n            } else {\n              ArrayPrototypePush.call(_stderr, chunk);\n            }\n          }\n        : function onChildStderrRaw(chunk) {\n            stderrLen += chunk.length;\n\n            if (stderrLen > maxBuffer) {\n              const truncatedLen = maxBuffer - (stderrLen - chunk.length);\n              ArrayPrototypePush.call(_stderr, StringPrototypeSlice.call(chunk, 0, truncatedLen));\n\n              ex = new ERR_CHILD_PROCESS_STDIO_MAXBUFFER(\"stderr\");\n              kill();\n            } else {\n              ArrayPrototypePush.call(_stderr, chunk);\n            }\n          },\n    );\n  }\n\n  child.addListener(\"close\", exitHandler);\n  child.addListener(\"error\", errorHandler);\n\n  return child;\n}\n\n/**\n * Spawns a shell executing the given command.\n * @param {string} command\n * @param {{\n *   cmd?: string;\n *   env?: Record<string, string>;\n *   encoding?: string;\n *   shell?: string;\n *   signal?: AbortSignal;\n *   timeout?: number;\n *   maxBuffer?: number;\n *   killSignal?: string | number;\n *   uid?: number;\n *   gid?: number;\n *   windowsHide?: boolean;\n *   }} [options]\n * @param {(\n *   error?: Error,\n *   stdout?: string | Buffer,\n *   stderr?: string | Buffer\n *   ) => any} [callback]\n * @returns {ChildProcess}\n */\nexport function exec(command, options, callback) {\n  const opts = normalizeExecArgs(command, options, callback);\n  return execFile(opts.file, opts.options, opts.callback);\n}\n\nconst customPromiseExecFunction = orig => {\n  return (...args) => {\n    let resolve;\n    let reject;\n    const promise = new Promise((res, rej) => {\n      resolve = res;\n      reject = rej;\n    });\n\n    promise.child = orig(...args, (err, stdout, stderr) => {\n      if (err !== null) {\n        err.stdout = stdout;\n        err.stderr = stderr;\n        reject(err);\n      } else {\n        resolve({ stdout, stderr });\n      }\n    });\n\n    return promise;\n  };\n};\n\nObjectDefineProperty(exec, promisify.custom, {\n  __proto__: null,\n  enumerable: false,\n  value: customPromiseExecFunction(exec),\n});\n\n/**\n * Spawns a new process synchronously using the given `file`.\n * @param {string} file\n * @param {string[]} [args]\n * @param {{\n *   cwd?: string;\n *   input?: string | Buffer | TypedArray | DataView;\n *   argv0?: string;\n *   stdio?: string | Array;\n *   env?: Record<string, string>;\n *   uid?: number;\n *   gid?: number;\n *   timeout?: number;\n *   killSignal?: string | number;\n *   maxBuffer?: number;\n *   encoding?: string;\n *   shell?: boolean | string;\n *   }} [options]\n * @returns {{\n *   pid: number;\n *   output: Array;\n *   stdout: Buffer | string;\n *   stderr: Buffer | string;\n *   status: number | null;\n *   signal: string | null;\n *   error: Error;\n *   }}\n */\nexport function spawnSync(file, args, options) {\n  options = {\n    maxBuffer: MAX_BUFFER,\n    ...normalizeSpawnArguments(file, args, options),\n  };\n\n  const maxBuffer = options.maxBuffer;\n  const encoding = options.encoding;\n\n  debug(\"spawnSync\", options);\n\n  // Validate the timeout, if present.\n  validateTimeout(options.timeout);\n\n  // Validate maxBuffer, if present.\n  validateMaxBuffer(maxBuffer);\n\n  // Validate and translate the kill signal, if present.\n  options.killSignal = sanitizeKillSignal(options.killSignal);\n\n  const stdio = options.stdio || \"pipe\";\n  const bunStdio = getBunStdioFromOptions(stdio);\n\n  var { input } = options;\n  if (input) {\n    if (ArrayBufferIsView(input)) {\n      bunStdio[0] = input;\n    } else if (typeof input === \"string\") {\n      bunStdio[0] = Buffer.from(input, encoding || \"utf8\");\n    } else {\n      throw new ERR_INVALID_ARG_TYPE(`options.stdio[0]`, [\"Buffer\", \"TypedArray\", \"DataView\", \"string\"], input);\n    }\n  }\n\n  const { stdout, stderr, success, exitCode } = Bun.spawnSync({\n    cmd: options.args,\n    env: options.env || undefined,\n    cwd: options.cwd || undefined,\n    stdin: bunStdio[0],\n    stdout: bunStdio[1],\n    stderr: bunStdio[2],\n  });\n\n  const result = {\n    signal: null,\n    status: exitCode,\n    output: [null, stdout, stderr],\n  };\n\n  if (stdout && encoding && encoding !== \"buffer\") {\n    result.output[1] = result.output[1]?.toString(encoding);\n  }\n\n  if (stderr && encoding && encoding !== \"buffer\") {\n    result.output[2] = result.output[2]?.toString(encoding);\n  }\n\n  result.stdout = result.output[1];\n  result.stderr = result.output[2];\n\n  if (!success) {\n    result.error = new SystemError(result.output[2], options.file, \"spawnSync\", -1, result.status);\n    result.error.spawnargs = ArrayPrototypeSlice.call(options.args, 1);\n  }\n\n  return result;\n}\n\n/**\n * Spawns a file as a shell synchronously.\n * @param {string} file\n * @param {string[]} [args]\n * @param {{\n *   cwd?: string;\n *   input?: string | Buffer | TypedArray | DataView;\n *   stdio?: string | Array;\n *   env?: Record<string, string>;\n *   uid?: number;\n *   gid?: number;\n *   timeout?: number;\n *   killSignal?: string | number;\n *   maxBuffer?: number;\n *   encoding?: string;\n *   windowsHide?: boolean;\n *   shell?: boolean | string;\n *   }} [options]\n * @returns {Buffer | string}\n */\nexport function execFileSync(file, args, options) {\n  ({ file, args, options } = normalizeExecFileArgs(file, args, options));\n\n  // const inheritStderr = !options.stdio;\n  const ret = spawnSync(file, args, options);\n\n  // if (inheritStderr && ret.stderr) process.stderr.write(ret.stderr);\n\n  const errArgs = [options.argv0 || file];\n  ArrayPrototypePush.apply(errArgs, args);\n  const err = checkExecSyncError(ret, errArgs);\n\n  if (err) throw err;\n\n  return ret.stdout;\n}\n\n/**\n * Spawns a shell executing the given `command` synchronously.\n * @param {string} command\n * @param {{\n *   cwd?: string;\n *   input?: string | Buffer | TypedArray | DataView;\n *   stdio?: string | Array;\n *   env?: Record<string, string>;\n *   shell?: string;\n *   uid?: number;\n *   gid?: number;\n *   timeout?: number;\n *   killSignal?: string | number;\n *   maxBuffer?: number;\n *   encoding?: string;\n *   windowsHide?: boolean;\n *   }} [options]\n * @returns {Buffer | string}\n */\nexport function execSync(command, options) {\n  const opts = normalizeExecArgs(command, options, null);\n  // const inheritStderr = !opts.options.stdio;\n\n  const ret = spawnSync(opts.file, opts.options);\n\n  // if (inheritStderr && ret.stderr) process.stderr.write(ret.stderr); // TODO: Uncomment when we have process.stderr\n\n  const err = checkExecSyncError(ret, undefined, command);\n\n  if (err) throw err;\n\n  return ret.stdout;\n}\n\nexport function fork() {\n  throw new Error(\"Not implemented\");\n}\n\n//------------------------------------------------------------------------------\n// Section 2. child_process helpers\n//------------------------------------------------------------------------------\nfunction convertToValidSignal(signal) {\n  if (typeof signal === \"number\" && getSignalsToNamesMapping()[signal]) return signal;\n\n  if (typeof signal === \"string\") {\n    const signalName = signals[StringPrototypeToUpperCase.call(signal)];\n    if (signalName) return signalName;\n  }\n\n  throw new ERR_UNKNOWN_SIGNAL(signal);\n}\n\nfunction sanitizeKillSignal(killSignal) {\n  if (typeof killSignal === \"string\" || typeof killSignal === \"number\") {\n    return convertToValidSignal(killSignal);\n  } else if (killSignal != null) {\n    throw new ERR_INVALID_ARG_TYPE(\"options.killSignal\", [\"string\", \"number\"], killSignal);\n  }\n}\n\nlet signalsToNamesMapping;\nfunction getSignalsToNamesMapping() {\n  if (signalsToNamesMapping !== undefined) return signalsToNamesMapping;\n\n  signalsToNamesMapping = ObjectCreate(null);\n  for (const key in signals) {\n    signalsToNamesMapping[signals[key]] = key;\n  }\n\n  return signalsToNamesMapping;\n}\n\nfunction normalizeExecFileArgs(file, args, options, callback) {\n  if (ArrayIsArray(args)) {\n    args = ArrayPrototypeSlice.call(args);\n  } else if (args != null && typeof args === \"object\") {\n    callback = options;\n    options = args;\n    args = null;\n  } else if (typeof args === \"function\") {\n    callback = args;\n    options = null;\n    args = null;\n  }\n\n  if (args == null) {\n    args = [];\n  }\n\n  if (typeof options === \"function\") {\n    callback = options;\n  } else if (options != null) {\n    validateObject(options, \"options\");\n  }\n\n  if (options == null) {\n    options = kEmptyObject;\n  }\n\n  if (callback != null) {\n    validateFunction(callback, \"callback\");\n  }\n\n  // Validate argv0, if present.\n  if (options.argv0 != null) {\n    validateString(options.argv0, \"options.argv0\");\n    validateArgumentNullCheck(options.argv0, \"options.argv0\");\n  }\n\n  return { file, args, options, callback };\n}\n\nfunction normalizeExecArgs(command, options, callback) {\n  validateString(command, \"command\");\n  validateArgumentNullCheck(command, \"command\");\n\n  if (typeof options === \"function\") {\n    callback = options;\n    options = undefined;\n  }\n\n  // Make a shallow copy so we don't clobber the user's options object.\n  options = { ...options };\n  options.shell = typeof options.shell === \"string\" ? options.shell : true;\n\n  return {\n    file: command,\n    options: options,\n    callback: callback,\n  };\n}\n\nfunction normalizeSpawnArguments(file, args, options) {\n  validateString(file, \"file\");\n  validateArgumentNullCheck(file, \"file\");\n\n  if (file.length === 0) throw new ERR_INVALID_ARG_VALUE(\"file\", file, \"cannot be empty\");\n\n  if (ArrayIsArray(args)) {\n    args = ArrayPrototypeSlice.call(args);\n  } else if (args == null) {\n    args = [];\n  } else if (typeof args !== \"object\") {\n    throw new ERR_INVALID_ARG_TYPE(\"args\", \"object\", args);\n  } else {\n    options = args;\n    args = [];\n  }\n\n  validateArgumentsNullCheck(args, \"args\");\n\n  if (options === undefined) options = {};\n  else validateObject(options, \"options\");\n\n  let cwd = options.cwd;\n\n  // Validate the cwd, if present.\n  if (cwd != null) {\n    cwd = getValidatedPath(cwd, \"options.cwd\");\n  }\n\n  // TODO: Detached check\n  // TODO: Gid check\n  // TODO: Uid check\n\n  // Validate the shell, if present.\n  if (options.shell != null && typeof options.shell !== \"boolean\" && typeof options.shell !== \"string\") {\n    throw new ERR_INVALID_ARG_TYPE(\"options.shell\", [\"boolean\", \"string\"], options.shell);\n  }\n\n  // Validate argv0, if present.\n  if (options.argv0 != null) {\n    validateString(options.argv0, \"options.argv0\");\n    validateArgumentNullCheck(options.argv0, \"options.argv0\");\n  }\n\n  // TODO: Windows checks for Windows specific options\n\n  // Handle shell\n  if (options.shell) {\n    validateArgumentNullCheck(options.shell, \"options.shell\");\n    const command = ArrayPrototypeJoin.call([file, ...args], \" \");\n    // TODO: Windows moment\n    // Set the shell, switches, and commands.\n    // if (process.platform === \"win32\") {\n    //   if (typeof options.shell === \"string\") file = options.shell;\n    //   else file = process.env.comspec || \"cmd.exe\";\n    //   // '/d /s /c' is used only for cmd.exe.\n    //   if (RegExpPrototypeExec(/^(?:.*\\\\)?cmd(?:\\.exe)?$/i, file) !== null) {\n    //     args = [\"/d\", \"/s\", \"/c\", `\"${command}\"`];\n    //     windowsVerbatimArguments = true;\n    //   } else {\n    //     args = [\"-c\", command];\n    //   }\n    // } else {\n    if (typeof options.shell === \"string\") file = options.shell;\n    else if (process.platform === \"android\") file = \"sh\";\n    else file = \"sh\";\n    args = [\"-c\", command];\n    // }\n  }\n\n  // Handle argv0\n  if (typeof options.argv0 === \"string\") {\n    ArrayPrototypeUnshift.call(args, options.argv0);\n  } else {\n    ArrayPrototypeUnshift.call(args, file);\n  }\n\n  const env = options.env || process.env;\n  const envPairs = env;\n\n  // // process.env.NODE_V8_COVERAGE always propagates, making it possible to\n  // // collect coverage for programs that spawn with white-listed environment.\n  // copyProcessEnvToEnv(env, \"NODE_V8_COVERAGE\", options.env);\n\n  // TODO: Windows env support here...\n\n  return { ...options, file, args, cwd, envPairs };\n}\n\nfunction checkExecSyncError(ret, args, cmd) {\n  let err;\n  if (ret.error) {\n    err = ret.error;\n    ObjectAssign(err, ret);\n  } else if (ret.status !== 0) {\n    let msg = \"Command failed: \";\n    msg += cmd || ArrayPrototypeJoin.call(args, \" \");\n    if (ret.stderr && ret.stderr.length > 0) msg += `\\n${ret.stderr.toString()}`;\n    err = genericNodeError(msg, ret);\n  }\n  return err;\n}\n\n//------------------------------------------------------------------------------\n// Section 3. ChildProcess class\n//------------------------------------------------------------------------------\nexport class ChildProcess extends EventEmitter {\n  #handle;\n  #exited = false;\n  #closesNeeded = 1;\n  #closesGot = 0;\n\n  connected = false;\n  signalCode = null;\n  exitCode = null;\n  spawnfile;\n  spawnargs;\n  pid;\n  channel;\n\n  get killed() {\n    if (this.#handle == null) return false;\n  }\n\n  // constructor(options) {\n  //   super(options);\n  //   this.#handle[owner_symbol] = this;\n  // }\n\n  #handleOnExit(exitCode, signalCode, err) {\n    if (this.#exited) return;\n    this.exitCode = this.#handle.exitCode;\n    this.signalCode = exitCode > 0 ? signalCode : null;\n\n    if (this.#stdin) {\n      this.#stdin.destroy();\n    }\n\n    if (this.#handle) {\n      this.#handle = null;\n    }\n\n    if (exitCode < 0) {\n      const err = new SystemError(\n        `Spawned process exited with error code: ${exitCode}`,\n        undefined,\n        \"spawn\",\n        \"EUNKNOWN\",\n        \"ERR_CHILD_PROCESS_UNKNOWN_ERROR\",\n      );\n\n      if (this.spawnfile) err.path = this.spawnfile;\n\n      err.spawnargs = ArrayPrototypeSlice.call(this.spawnargs, 1);\n      this.emit(\"error\", err);\n    } else {\n      this.emit(\"exit\", this.exitCode, this.signalCode);\n    }\n\n    // If any of the stdio streams have not been touched,\n    // then pull all the data through so that it can get the\n    // eof and emit a 'close' event.\n    // Do it on nextTick so that the user has one last chance\n    // to consume the output, if for example they only want to\n    // start reading the data once the process exits.\n    process.nextTick(flushStdio, this);\n\n    this.#maybeClose();\n    this.#exited = true;\n    this.#stdioOptions = [\"destroyed\", \"destroyed\", \"destroyed\"];\n  }\n\n  #getBunSpawnIo(i, encoding) {\n    if (__DEBUG__ && !this.#handle) {\n      if (this.#handle === null) {\n        debug(\"ChildProcess: getBunSpawnIo: this.#handle is null. This means the subprocess already exited\");\n      } else {\n        debug(\"ChildProcess: getBunSpawnIo: this.#handle is undefined\");\n      }\n    }\n    const io = this.#stdioOptions[i];\n    switch (i) {\n      case 0: {\n        switch (io) {\n          case \"pipe\":\n            return new NativeWritable(this.#handle.stdin);\n          case \"inherit\":\n            return process.stdin || null;\n          case \"destroyed\":\n            return new ShimmedStdin();\n          default:\n            return null;\n        }\n      }\n      case 2:\n      case 1: {\n        switch (io) {\n          case \"pipe\":\n            return ReadableFromWeb(\n              this.#handle[fdToStdioName(i)],\n              __TRACK_STDIO__\n                ? {\n                    encoding,\n                    __id: `PARENT_${fdToStdioName(i).toUpperCase()}-${globalThis.__getId()}`,\n                  }\n                : { encoding },\n            );\n          case \"inherit\":\n            return process[fdToStdioName(i)] || null;\n          case \"destroyed\":\n            return new ShimmedStdioOutStream();\n          default:\n            return null;\n        }\n      }\n    }\n  }\n\n  #stdin;\n  #stdout;\n  #stderr;\n  #stdioObject;\n  #encoding;\n  #stdioOptions;\n\n  #createStdioObject() {\n    return Object.create(null, {\n      0: {\n        get: () => this.stdin,\n      },\n      1: {\n        get: () => this.stdout,\n      },\n      2: {\n        get: () => this.stderr,\n      },\n    });\n  }\n\n  get stdin() {\n    return (this.#stdin ??= this.#getBunSpawnIo(0, this.#encoding));\n  }\n\n  get stdout() {\n    return (this.#stdout ??= this.#getBunSpawnIo(1, this.#encoding));\n  }\n\n  get stderr() {\n    return (this.#stderr ??= this.#getBunSpawnIo(2, this.#encoding));\n  }\n\n  get stdio() {\n    return (this.#stdioObject ??= this.#createStdioObject());\n  }\n\n  spawn(options) {\n    validateObject(options, \"options\");\n\n    // validateOneOf(options.serialization, \"options.serialization\", [\n    //   undefined,\n    //   \"json\",\n    //   // \"advanced\", // TODO\n    // ]);\n    // const serialization = options.serialization || \"json\";\n\n    // if (ipc !== undefined) {\n    //   // Let child process know about opened IPC channel\n    //   if (options.envPairs === undefined) options.envPairs = [];\n    //   else validateArray(options.envPairs, \"options.envPairs\");\n\n    //   ArrayPrototypePush.call(options.envPairs, `NODE_CHANNEL_FD=${ipcFd}`);\n    //   ArrayPrototypePush.call(\n    //     options.envPairs,\n    //     `NODE_CHANNEL_SERIALIZATION_MODE=${serialization}`\n    //   );\n    // }\n\n    validateString(options.file, \"options.file\");\n    // NOTE: This is confusing... So node allows you to pass a file name\n    // But also allows you to pass a command in the args and it should execute\n    // To add another layer of confusion, they also give the option to pass an explicit \"argv0\"\n    // which overrides the actual command of the spawned process...\n    var file;\n    file = this.spawnfile = options.file;\n\n    var spawnargs;\n    if (options.args == null) {\n      spawnargs = this.spawnargs = [];\n    } else {\n      validateArray(options.args, \"options.args\");\n      spawnargs = this.spawnargs = options.args;\n    }\n\n    const stdio = options.stdio || [\"pipe\", \"pipe\", \"pipe\"];\n    const bunStdio = getBunStdioFromOptions(stdio);\n\n    var env = options.envPairs || undefined;\n\n    this.#encoding = options.encoding || undefined;\n    this.#stdioOptions = bunStdio;\n    this.#handle = Bun.spawn({\n      cmd: spawnargs,\n      stdin: bunStdio[0],\n      stdout: bunStdio[1],\n      stderr: bunStdio[2],\n      cwd: options.cwd || undefined,\n      env: env || process.env,\n      onExit: (handle, exitCode, signalCode, err) => {\n        this.#handle = handle;\n        this.pid = this.#handle.pid;\n\n        process.nextTick(\n          (exitCode, signalCode, err) => this.#handleOnExit(exitCode, signalCode, err),\n          exitCode,\n          signalCode,\n          err,\n        );\n      },\n      lazy: true,\n    });\n    this.pid = this.#handle.pid;\n\n    onSpawnNT(this);\n\n    // const ipc = stdio.ipc;\n    // const ipcFd = stdio.ipcFd;\n    // stdio = options.stdio = stdio.stdio;\n\n    // for (i = 0; i < stdio.length; i++) {\n    //   const stream = stdio[i];\n    //   if (stream.type === \"ignore\") continue;\n\n    //   if (stream.ipc) {\n    //     this._closesNeeded++;\n    //     continue;\n    //   }\n\n    //   // The stream is already cloned and piped, thus stop its readable side,\n    //   // otherwise we might attempt to read from the stream when at the same time\n    //   // the child process does.\n    //   if (stream.type === \"wrap\") {\n    //     stream.handle.reading = false;\n    //     stream.handle.readStop();\n    //     stream._stdio.pause();\n    //     stream._stdio.readableFlowing = false;\n    //     stream._stdio._readableState.reading = false;\n    //     stream._stdio[kIsUsedAsStdio] = true;\n    //     continue;\n    //   }\n\n    //   if (stream.handle) {\n    //     stream.socket = createSocket(\n    //       this.pid !== 0 ? stream.handle : null,\n    //       i > 0\n    //     );\n\n    // // Add .send() method and start listening for IPC data\n    // if (ipc !== undefined) setupChannel(this, ipc, serialization);\n  }\n\n  send() {\n    console.log(\"ChildProcess.prototype.send() - Sorry! Not implemented yet\");\n  }\n\n  disconnect() {\n    console.log(\"ChildProcess.prototype.disconnect() - Sorry! Not implemented yet\");\n  }\n\n  kill(sig) {\n    const signal = sig === 0 ? sig : convertToValidSignal(sig === undefined ? \"SIGTERM\" : sig);\n\n    if (this.#handle) {\n      this.#handle.kill(signal);\n    }\n\n    this.#maybeClose();\n\n    // TODO: Figure out how to make this conform to the Node spec...\n    // The problem is that the handle does not report killed until the process exits\n    // So we can't return whether or not the process was killed because Bun.spawn seems to handle this async instead of sync like Node does\n    // return this.#handle?.killed ?? true;\n    return true;\n  }\n\n  #maybeClose() {\n    debug(\"Attempting to maybe close...\");\n    this.#closesGot++;\n    if (this.#closesGot === this.#closesNeeded) {\n      this.emit(\"close\", this.exitCode, this.signalCode);\n    }\n  }\n\n  ref() {\n    if (this.#handle) this.#handle.ref();\n  }\n\n  unref() {\n    if (this.#handle) this.#handle.unref();\n  }\n}\n\n//------------------------------------------------------------------------------\n// Section 4. ChildProcess helpers\n//------------------------------------------------------------------------------\nconst nodeToBunLookup = {\n  ignore: null,\n  pipe: \"pipe\",\n  overlapped: \"pipe\", // TODO: this may need to work differently for Windows\n  inherit: \"inherit\",\n};\n\nfunction nodeToBun(item) {\n  // If inherit and we are referencing stdin/stdout/stderr index,\n  // we can get the fd from the ReadStream for the corresponding stdio\n  if (typeof item === \"number\") {\n    return item;\n  } else {\n    const result = nodeToBunLookup[item];\n    if (result === undefined) throw new Error(\"Invalid stdio option\");\n    return result;\n  }\n}\n\nfunction fdToStdioName(fd) {\n  switch (fd) {\n    case 0:\n      return \"stdin\";\n    case 1:\n      return \"stdout\";\n    case 2:\n      return \"stderr\";\n    default:\n      return null;\n  }\n}\n\nfunction getBunStdioFromOptions(stdio) {\n  const normalizedStdio = normalizeStdio(stdio);\n  // Node options:\n  // pipe: just a pipe\n  // ipc = can only be one in array\n  // overlapped -- same as pipe on Unix based systems\n  // inherit -- 'inherit': equivalent to ['inherit', 'inherit', 'inherit'] or [0, 1, 2]\n  // ignore -- > /dev/null, more or less same as null option for Bun.spawn stdio\n  // TODO: Stream -- use this stream\n  // number -- used as FD\n  // null, undefined: Use default value. Not same as ignore, which is Bun.spawn null.\n  // null/undefined: For stdio fds 0, 1, and 2 (in other words, stdin, stdout, and stderr) a pipe is created. For fd 3 and up, the default is 'ignore'\n\n  // Important Bun options\n  // pipe\n  // fd\n  // null - no stdin/stdout/stderr\n\n  // Translations: node -> bun\n  // pipe -> pipe\n  // overlapped -> pipe\n  // ignore -> null\n  // inherit -> inherit (stdin/stdout/stderr)\n  // Stream -> throw err for now\n  const bunStdio = normalizedStdio.map(item => nodeToBun(item));\n  return bunStdio;\n}\n\nfunction normalizeStdio(stdio) {\n  if (typeof stdio === \"string\") {\n    switch (stdio) {\n      case \"ignore\":\n        return [\"ignore\", \"ignore\", \"ignore\"];\n      case \"pipe\":\n        return [\"pipe\", \"pipe\", \"pipe\"];\n      case \"inherit\":\n        return [\"inherit\", \"inherit\", \"inherit\"];\n      default:\n        throw new ERR_INVALID_OPT_VALUE(\"stdio\", stdio);\n    }\n  } else if (ArrayIsArray(stdio)) {\n    // Validate if each is a valid stdio type\n    // TODO: Support wrapped types here\n\n    let processedStdio;\n    if (stdio.length === 0) processedStdio = [\"pipe\", \"pipe\", \"pipe\"];\n    else if (stdio.length === 1) processedStdio = [stdio[0], \"pipe\", \"pipe\"];\n    else if (stdio.length === 2) processedStdio = [stdio[0], stdio[1], \"pipe\"];\n    else if (stdio.length >= 3) processedStdio = [stdio[0], stdio[1], stdio[2]];\n\n    return processedStdio.map(item => (!item ? \"pipe\" : item));\n  } else {\n    throw new ERR_INVALID_OPT_VALUE(\"stdio\", stdio);\n  }\n}\n\nfunction flushStdio(subprocess) {\n  const stdio = subprocess.stdio;\n  if (stdio == null) return;\n\n  for (let i = 0; i < stdio.length; i++) {\n    const stream = stdio[i];\n    // TODO(addaleax): This doesn't necessarily account for all the ways in\n    // which data can be read from a stream, e.g. being consumed on the\n    // native layer directly as a StreamBase.\n    if (!stream || !stream.readable) {\n      continue;\n    }\n    stream.resume();\n  }\n}\n\nfunction onSpawnNT(self) {\n  self.emit(\"spawn\");\n}\n\nfunction abortChildProcess(child, killSignal) {\n  if (!child) return;\n  try {\n    if (child.kill(killSignal)) {\n      child.emit(\"error\", new AbortError());\n    }\n  } catch (err) {\n    child.emit(\"error\", err);\n  }\n}\n\nclass ShimmedStdin extends EventEmitter {\n  constructor() {\n    super();\n  }\n  write() {\n    return false;\n  }\n  destroy() {}\n  end() {}\n  pipe() {}\n}\n\nclass ShimmedStdioOutStream extends EventEmitter {\n  pipe() {}\n}\n\n//------------------------------------------------------------------------------\n// Section 5. Validators\n//------------------------------------------------------------------------------\n\nfunction validateMaxBuffer(maxBuffer) {\n  if (maxBuffer != null && !(typeof maxBuffer === \"number\" && maxBuffer >= 0)) {\n    throw new ERR_OUT_OF_RANGE(\"options.maxBuffer\", \"a positive number\", maxBuffer);\n  }\n}\n\nfunction validateArgumentNullCheck(arg, propName) {\n  if (typeof arg === \"string\" && StringPrototypeIncludes.call(arg, \"\\u0000\")) {\n    throw new ERR_INVALID_ARG_VALUE(propName, arg, \"must be a string without null bytes\");\n  }\n}\n\nfunction validateArgumentsNullCheck(args, propName) {\n  for (let i = 0; i < args.length; ++i) {\n    validateArgumentNullCheck(args[i], `${propName}[${i}]`);\n  }\n}\n\nfunction validateTimeout(timeout) {\n  if (timeout != null && !(NumberIsInteger(timeout) && timeout >= 0)) {\n    throw new ERR_OUT_OF_RANGE(\"timeout\", \"an unsigned integer\", timeout);\n  }\n}\n\nfunction validateBoolean(value, name) {\n  if (typeof value !== \"boolean\") throw new ERR_INVALID_ARG_TYPE(name, \"boolean\", value);\n}\n\n/**\n * @callback validateFunction\n * @param {*} value\n * @param {string} name\n * @returns {asserts value is Function}\n */\n\n/** @type {validateFunction} */\nfunction validateFunction(value, name) {\n  if (typeof value !== \"function\") throw new ERR_INVALID_ARG_TYPE(name, \"Function\", value);\n}\n\n/**\n * @callback validateAbortSignal\n * @param {*} signal\n * @param {string} name\n */\n\n/** @type {validateAbortSignal} */\nconst validateAbortSignal = (signal, name) => {\n  if (signal !== undefined && (signal === null || typeof signal !== \"object\" || !(\"aborted\" in signal))) {\n    throw new ERR_INVALID_ARG_TYPE(name, \"AbortSignal\", signal);\n  }\n};\n\n/**\n * @callback validateOneOf\n * @template T\n * @param {T} value\n * @param {string} name\n * @param {T[]} oneOf\n */\n\n/** @type {validateOneOf} */\nconst validateOneOf = (value, name, oneOf) => {\n  // const validateOneOf = hideStackFrames((value, name, oneOf) => {\n  if (!ArrayPrototypeIncludes.call(oneOf, value)) {\n    const allowed = ArrayPrototypeJoin.call(\n      ArrayPrototypeMap.call(oneOf, v => (typeof v === \"string\" ? `'${v}'` : String(v))),\n      \", \",\n    );\n    const reason = \"must be one of: \" + allowed;\n    throw new ERR_INVALID_ARG_VALUE(name, value, reason);\n  }\n};\n\n/**\n * @callback validateObject\n * @param {*} value\n * @param {string} name\n * @param {{\n *   allowArray?: boolean,\n *   allowFunction?: boolean,\n *   nullable?: boolean\n * }} [options]\n */\n\n/** @type {validateObject} */\nconst validateObject = (value, name, options = null) => {\n  // const validateObject = hideStackFrames((value, name, options = null) => {\n  const allowArray = options?.allowArray ?? false;\n  const allowFunction = options?.allowFunction ?? false;\n  const nullable = options?.nullable ?? false;\n  if (\n    (!nullable && value === null) ||\n    (!allowArray && ArrayIsArray.call(value)) ||\n    (typeof value !== \"object\" && (!allowFunction || typeof value !== \"function\"))\n  ) {\n    throw new ERR_INVALID_ARG_TYPE(name, \"object\", value);\n  }\n};\n\n/**\n * @callback validateArray\n * @param {*} value\n * @param {string} name\n * @param {number} [minLength]\n * @returns {asserts value is any[]}\n */\n\n/** @type {validateArray} */\nconst validateArray = (value, name, minLength = 0) => {\n  // const validateArray = hideStackFrames((value, name, minLength = 0) => {\n  if (!ArrayIsArray(value)) {\n    throw new ERR_INVALID_ARG_TYPE(name, \"Array\", value);\n  }\n  if (value.length < minLength) {\n    const reason = `must be longer than ${minLength}`;\n    throw new ERR_INVALID_ARG_VALUE(name, value, reason);\n  }\n};\n\n/**\n * @callback validateString\n * @param {*} value\n * @param {string} name\n * @returns {asserts value is string}\n */\n\n/** @type {validateString} */\nfunction validateString(value, name) {\n  if (typeof value !== \"string\") throw new ERR_INVALID_ARG_TYPE(name, \"string\", value);\n}\n\nfunction nullCheck(path, propName, throwError = true) {\n  const pathIsString = typeof path === \"string\";\n  const pathIsUint8Array = isUint8Array(path);\n\n  // We can only perform meaningful checks on strings and Uint8Arrays.\n  if (\n    (!pathIsString && !pathIsUint8Array) ||\n    (pathIsString && !StringPrototypeIncludes.call(path, \"\\u0000\")) ||\n    (pathIsUint8Array && !Uint8ArrayPrototypeIncludes.call(path, 0))\n  ) {\n    return;\n  }\n\n  const err = new ERR_INVALID_ARG_VALUE(propName, path, \"must be a string or Uint8Array without null bytes\");\n  if (throwError) {\n    throw err;\n  }\n  return err;\n}\n\nfunction validatePath(path, propName = \"path\") {\n  if (typeof path !== \"string\" && !isUint8Array(path)) {\n    throw new ERR_INVALID_ARG_TYPE(propName, [\"string\", \"Buffer\", \"URL\"], path);\n  }\n\n  const err = nullCheck(path, propName, false);\n\n  if (err !== undefined) {\n    throw err;\n  }\n}\n\nfunction getValidatedPath(fileURLOrPath, propName = \"path\") {\n  const path = toPathIfFileURL(fileURLOrPath);\n  validatePath(path, propName);\n  return path;\n}\n\nfunction isUint8Array(value) {\n  return typeof value === \"object\" && value !== null && value instanceof Uint8Array;\n}\n\n//------------------------------------------------------------------------------\n// Section 6. Random utilities\n//------------------------------------------------------------------------------\n\nfunction isURLInstance(fileURLOrPath) {\n  return fileURLOrPath != null && fileURLOrPath.href && fileURLOrPath.origin;\n}\n\nfunction toPathIfFileURL(fileURLOrPath) {\n  if (!isURLInstance(fileURLOrPath)) return fileURLOrPath;\n  return Bun.fileURLToPath(fileURLOrPath);\n}\n\n//------------------------------------------------------------------------------\n// Section 7. Node errors / error polyfills\n//------------------------------------------------------------------------------\nvar Error = globalThis.Error;\nvar TypeError = globalThis.TypeError;\nvar RangeError = globalThis.RangeError;\n\n// Node uses a slightly different abort error than standard DOM. See: https://github.com/nodejs/node/blob/main/lib/internal/errors.js\nclass AbortError extends Error {\n  code = \"ABORT_ERR\";\n  name = \"AbortError\";\n  constructor(message = \"The operation was aborted\", options = undefined) {\n    if (options !== undefined && typeof options !== \"object\") {\n      throw new ERR_INVALID_ARG_TYPE(\"options\", \"Object\", options);\n    }\n    super(message, options);\n  }\n}\n\nfunction genericNodeError(message, options) {\n  const err = new Error(message);\n  err.code = options.code;\n  err.killed = options.killed;\n  err.signal = options.signal;\n  return err;\n}\n\n// const messages = new Map();\n\n// Utility function for registering the error codes. Only used here. Exported\n// *only* to allow for testing.\n// function E(sym, val, def) {\n//   messages.set(sym, val);\n//   def = makeNodeErrorWithCode(def, sym);\n//   errorCodes[sym] = def;\n// }\n\n// function makeNodeErrorWithCode(Base, key) {\n//   return function NodeError(...args) {\n//     // const limit = Error.stackTraceLimit;\n//     // if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = 0;\n//     const error = new Base();\n//     // Reset the limit and setting the name property.\n//     // if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = limit;\n//     const message = getMessage(key, args);\n//     error.message = message;\n//     // captureLargerStackTrace(error);\n//     error.code = key;\n//     return error;\n//   };\n// }\n\n// function getMessage(key, args) {\n//   const msgFn = messages.get(key);\n//   if (args.length !== msgFn.length)\n//     throw new Error(\n//       `Invalid number of args for error message ${key}. Got ${args.length}, expected ${msgFn.length}.`\n//     );\n//   return msgFn(...args);\n// }\n\n// E(\n//   \"ERR_INVALID_ARG_TYPE\",\n//   (name, expected, actual) => {\n//     assert(typeof name === \"string\", \"'name' must be a string\");\n//     if (!ArrayIsArray(expected)) {\n//       expected = [expected];\n//     }\n\n//     let msg = \"The \";\n//     if (StringPrototypeEndsWith(name, \" argument\")) {\n//       // For cases like 'first argument'\n//       msg += `${name} `;\n//     } else {\n//       const type = StringPrototypeIncludes(name, \".\") ? \"property\" : \"argument\";\n//       msg += `\"${name}\" ${type} `;\n//     }\n//     msg += \"must be \";\n\n//     const types = [];\n//     const instances = [];\n//     const other = [];\n\n//     for (const value of expected) {\n//       assert(\n//         typeof value === \"string\",\n//         \"All expected entries have to be of type string\"\n//       );\n//       if (ArrayPrototypeIncludes.call(kTypes, value)) {\n//         ArrayPrototypePush(types, StringPrototypeToLowerCase(value));\n//       } else if (RegExpPrototypeExec(classRegExp, value) !== null) {\n//         ArrayPrototypePush(instances, value);\n//       } else {\n//         assert(\n//           value !== \"object\",\n//           'The value \"object\" should be written as \"Object\"'\n//         );\n//         ArrayPrototypePush(other, value);\n//       }\n//     }\n\n//     // Special handle `object` in case other instances are allowed to outline\n//     // the differences between each other.\n//     if (instances.length > 0) {\n//       const pos = ArrayPrototypeIndexOf(types, \"object\");\n//       if (pos !== -1) {\n//         ArrayPrototypeSplice.call(types, pos, 1);\n//         ArrayPrototypePush.call(instances, \"Object\");\n//       }\n//     }\n\n//     if (types.length > 0) {\n//       if (types.length > 2) {\n//         const last = ArrayPrototypePop(types);\n//         msg += `one of type ${ArrayPrototypeJoin(types, \", \")}, or ${last}`;\n//       } else if (types.length === 2) {\n//         msg += `one of type ${types[0]} or ${types[1]}`;\n//       } else {\n//         msg += `of type ${types[0]}`;\n//       }\n//       if (instances.length > 0 || other.length > 0) msg += \" or \";\n//     }\n\n//     if (instances.length > 0) {\n//       if (instances.length > 2) {\n//         const last = ArrayPrototypePop(instances);\n//         msg += `an instance of ${ArrayPrototypeJoin(\n//           instances,\n//           \", \"\n//         )}, or ${last}`;\n//       } else {\n//         msg += `an instance of ${instances[0]}`;\n//         if (instances.length === 2) {\n//           msg += ` or ${instances[1]}`;\n//         }\n//       }\n//       if (other.length > 0) msg += \" or \";\n//     }\n\n//     if (other.length > 0) {\n//       if (other.length > 2) {\n//         const last = ArrayPrototypePop(other);\n//         msg += `one of ${ArrayPrototypeJoin.call(other, \", \")}, or ${last}`;\n//       } else if (other.length === 2) {\n//         msg += `one of ${other[0]} or ${other[1]}`;\n//       } else {\n//         if (StringPrototypeToLowerCase(other[0]) !== other[0]) msg += \"an \";\n//         msg += `${other[0]}`;\n//       }\n//     }\n\n//     msg += `. Received ${determineSpecificType(actual)}`;\n\n//     return msg;\n//   },\n//   TypeError\n// );\n\nfunction ERR_OUT_OF_RANGE(str, range, input, replaceDefaultBoolean = false) {\n  // Node implementation:\n  // assert(range, 'Missing \"range\" argument');\n  // let msg = replaceDefaultBoolean\n  //   ? str\n  //   : `The value of \"${str}\" is out of range.`;\n  // let received;\n  // if (NumberIsInteger(input) && MathAbs(input) > 2 ** 32) {\n  //   received = addNumericalSeparator(String(input));\n  // } else if (typeof input === \"bigint\") {\n  //   received = String(input);\n  //   if (input > 2n ** 32n || input < -(2n ** 32n)) {\n  //     received = addNumericalSeparator(received);\n  //   }\n  //   received += \"n\";\n  // } else {\n  //   received = lazyInternalUtilInspect().inspect(input);\n  // }\n  // msg += ` It must be ${range}. Received ${received}`;\n  // return new RangeError(msg);\n  return new RangeError(`The value of ${str} is out of range. It must be ${range}. Received ${input}`);\n}\n\nfunction ERR_CHILD_PROCESS_STDIO_MAXBUFFER(stdio) {\n  return Error(`${stdio} maxBuffer length exceeded`);\n}\n\nfunction ERR_UNKNOWN_SIGNAL(name) {\n  const err = new TypeError(`Unknown signal: ${name}`);\n  err.code = \"ERR_UNKNOWN_SIGNAL\";\n  return err;\n}\n\nfunction ERR_INVALID_ARG_TYPE(name, type, value) {\n  const err = new TypeError(`The \"${name}\" argument must be of type ${type}. Received ${value}`);\n  err.code = \"ERR_INVALID_ARG_TYPE\";\n  return err;\n}\n\nfunction ERR_INVALID_OPT_VALUE(name, value) {\n  return new TypeError(`The value \"${value}\" is invalid for option \"${name}\"`);\n}\n\nfunction ERR_INVALID_ARG_VALUE(name, value, reason) {\n  return new Error(`The value \"${value}\" is invalid for argument '${name}'. Reason: ${reason}`);\n}\n\nclass SystemError extends Error {\n  path;\n  syscall;\n  errno;\n  code;\n  constructor(message, path, syscall, errno, code) {\n    super(message);\n    this.path = path;\n    this.syscall = syscall;\n    this.errno = errno;\n    this.code = code;\n  }\n\n  get name() {\n    return \"SystemError\";\n  }\n}\n\nexport default {\n  ChildProcess,\n  spawn,\n  execFile,\n  exec,\n  fork,\n  spawnSync,\n  execFileSync,\n  execSync,\n\n  [Symbol.for(\"CommonJS\")]: 0,\n};\n",
  "// Hardcoded module \"node:child_process\"\nconst EventEmitter = import.meta.require(\"node:events\");\nconst {\n  Readable: { fromWeb: ReadableFromWeb },\n  NativeWritable,\n} = import.meta.require(\"node:stream\");\nconst {\n  constants: { signals },\n} = import.meta.require(\"node:os\");\nconst { promisify } = import.meta.require(\"node:util\");\n\nconst { ArrayBuffer, Uint8Array, String, Object, Buffer, Promise } = import.meta.primordials;\n\nvar ObjectPrototypeHasOwnProperty = Object.prototype.hasOwnProperty;\nvar ObjectCreate = Object.create;\nvar ObjectAssign = Object.assign;\nvar ObjectDefineProperty = Object.defineProperty;\nvar BufferConcat = Buffer.concat;\nvar BufferIsEncoding = Buffer.isEncoding;\n\nvar kEmptyObject = ObjectCreate(null);\n\nvar ArrayPrototypePush = Array.prototype.push;\nvar ArrayPrototypeReduce = Array.prototype.reduce;\nvar ArrayPrototypeFilter = Array.prototype.filter;\nvar ArrayPrototypeJoin = Array.prototype.join;\nvar ArrayPrototypeMap = Array.prototype.map;\nvar ArrayPrototypeIncludes = Array.prototype.includes;\nvar ArrayPrototypeSlice = Array.prototype.slice;\nvar ArrayPrototypeUnshift = Array.prototype.unshift;\nvar ArrayIsArray = Array.isArray;\n\n// var ArrayBuffer = ArrayBuffer;\nvar ArrayBufferIsView = ArrayBuffer.isView;\n\nvar NumberIsInteger = Number.isInteger;\nvar MathAbs = Math.abs;\n\nvar StringPrototypeToUpperCase = String.prototype.toUpperCase;\nvar StringPrototypeIncludes = String.prototype.includes;\nvar StringPrototypeSlice = String.prototype.slice;\nvar Uint8ArrayPrototypeIncludes = Uint8Array.prototype.includes;\n\nconst MAX_BUFFER = 1024 * 1024;\n\n// General debug vs tracking stdio streams. Useful for stream debugging in particular\nconst __DEBUG__ = process.env.DEBUG || false;\n\n// You can use this env var along with `process.env.DEBUG_TRACK_EE` to debug stdio streams\n// Just set `DEBUG_TRACK_EE=PARENT_STDOUT-0, PARENT_STDOUT-1`, etc. and `DEBUG_STDIO=1` and you will be able to track particular stdio streams\n// TODO: Add ability to track a range of IDs rather than just enumerated ones\nconst __TRACK_STDIO__ = process.env.DEBUG_STDIO;\nconst debug = __DEBUG__ ? console.log : () => {};\n\nif (__TRACK_STDIO__) {\n  debug(\"child_process: debug mode on\");\n  globalThis.__lastId = null;\n  globalThis.__getId = () => {\n    return globalThis.__lastId !== null ? globalThis.__lastId++ : 0;\n  };\n}\n\n// Sections:\n// 1. Exported child_process functions\n// 2. child_process helpers\n// 3. ChildProcess \"class\"\n// 4. ChildProcess helpers\n// 5. Validators\n// 6. Random utilities\n// 7. Node errors / error polyfills\n\n// TODO:\n// Port rest of node tests\n// Fix exit codes with Bun.spawn\n// ------------------------------\n// Fix errors\n// Support file descriptors being passed in for stdio\n// ------------------------------\n// TODO: Look at Pipe to see if we can support passing Node Pipe objects to stdio param\n\n// TODO: Add these params after support added in Bun.spawn\n// uid <number> Sets the user identity of the process (see setuid(2)).\n// gid <number> Sets the group identity of the process (see setgid(2)).\n// detached <boolean> Prepare child to run independently of its parent process. Specific behavior depends on the platform, see options.detached).\n\n// TODO: After IPC channels can be opened\n// serialization <string> Specify the kind of serialization used for sending messages between processes. Possible values are 'json' and 'advanced'. See Advanced serialization for more details. Default: 'json'.\n\n// TODO: Add support for ipc option, verify only one IPC channel in array\n// stdio <Array> | <string> Child's stdio configuration (see options.stdio).\n// Support wrapped ipc types (e.g. net.Socket, dgram.Socket, TTY, etc.)\n// IPC FD passing support\n\n// From node child_process docs(https://nodejs.org/api/child_process.html#optionsstdio):\n// 'ipc': Create an IPC channel for passing messages/file descriptors between parent and child.\n// A ChildProcess may have at most one IPC stdio file descriptor. Setting this option enables the subprocess.send() method.\n// If the child is a Node.js process, the presence of an IPC channel will enable process.send() and process.disconnect() methods,\n// as well as 'disconnect' and 'message' events within the child.\n\n//------------------------------------------------------------------------------\n// Section 1. Exported child_process functions\n//------------------------------------------------------------------------------\n\n// TODO: Implement these props when Windows is supported\n// *   windowsVerbatimArguments?: boolean;\n// *   windowsHide?: boolean;\n\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nfunction spawnTimeoutFunction(child, timeoutHolder) {\n  var timeoutId = timeoutHolder.timeoutId;\n  if (timeoutId > -1) {\n    try {\n      child.kill(killSignal);\n    } catch (err) {\n      child.emit(\"error\", err);\n    }\n    timeoutHolder.timeoutId = -1;\n  }\n}\n/**\n * Spawns a new process using the given `file`.\n * @param {string} file\n * @param {string[]} [args]\n * @param {{\n *   cwd?: string;\n *   env?: Record<string, string>;\n *   argv0?: string;\n *   stdio?: Array | string;\n *   detached?: boolean;\n *   uid?: number;\n *   gid?: number;\n *   serialization?: string;\n *   shell?: boolean | string;\n *   signal?: AbortSignal;\n *   timeout?: number;\n *   killSignal?: string | number;\n *   }} [options]\n * @returns {ChildProcess}\n */\nexport function spawn(file, args, options) {\n  options = normalizeSpawnArguments(file, args, options);\n  validateTimeout(options.timeout);\n  validateAbortSignal(options.signal, \"options.signal\");\n  const killSignal = sanitizeKillSignal(options.killSignal);\n  const child = new ChildProcess();\n\n  debug(\"spawn\", options);\n  child.spawn(options);\n\n  if (options.timeout > 0) {\n    let timeoutId = setTimeout(() => {\n      if (timeoutId) {\n        try {\n          child.kill(killSignal);\n        } catch (err) {\n          child.emit(\"error\", err);\n        }\n        timeoutId = null;\n      }\n    });\n\n    child.once(\"exit\", () => {\n      if (timeoutId) {\n        clearTimeout(timeoutId);\n        timeoutId = null;\n      }\n    });\n  }\n\n  if (options.signal) {\n    const signal = options.signal;\n    if (signal.aborted) {\n      process.nextTick(onAbortListener);\n    } else {\n      signal.addEventListener(\"abort\", onAbortListener, { once: true });\n      child.once(\"exit\", () => signal.removeEventListener(\"abort\", onAbortListener));\n    }\n\n    function onAbortListener() {\n      abortChildProcess(child, killSignal);\n    }\n  }\n  return child;\n}\n\n/**\n * Spawns the specified file as a shell.\n * @param {string} file\n * @param {string[]} [args]\n * @param {{\n *   cwd?: string;\n *   env?: Record<string, string>;\n *   encoding?: string;\n *   timeout?: number;\n *   maxBuffer?: number;\n *   killSignal?: string | number;\n *   uid?: number;\n *   gid?: number;\n *   windowsHide?: boolean;\n *   windowsVerbatimArguments?: boolean;\n *   shell?: boolean | string;\n *   signal?: AbortSignal;\n *   }} [options]\n * @param {(\n *   error?: Error,\n *   stdout?: string | Buffer,\n *   stderr?: string | Buffer\n *   ) => any} [callback]\n * @returns {ChildProcess}\n */\nexport function execFile(file, args, options, callback) {\n  ({ file, args, options, callback } = normalizeExecFileArgs(file, args, options, callback));\n\n  options = {\n    encoding: \"utf8\",\n    timeout: 0,\n    maxBuffer: MAX_BUFFER,\n    killSignal: \"SIGTERM\",\n    cwd: null,\n    env: null,\n    shell: false,\n    ...options,\n  };\n\n  const maxBuffer = options.maxBuffer;\n\n  // Validate the timeout, if present.\n  validateTimeout(options.timeout);\n\n  // Validate maxBuffer, if present.\n  validateMaxBuffer(maxBuffer);\n\n  options.killSignal = sanitizeKillSignal(options.killSignal);\n\n  const child = spawn(file, args, {\n    cwd: options.cwd,\n    env: options.env,\n    // gid: options.gid,\n    shell: options.shell,\n    signal: options.signal,\n    // uid: options.uid,\n  });\n\n  let encoding;\n  const _stdout = [];\n  const _stderr = [];\n  if (options.encoding !== \"buffer\" && BufferIsEncoding(options.encoding)) {\n    encoding = options.encoding;\n  } else {\n    encoding = null;\n  }\n  let stdoutLen = 0;\n  let stderrLen = 0;\n  let killed = false;\n  let exited = false;\n  let timeoutId;\n  let encodedStdoutLen;\n  let encodedStderrLen;\n\n  let ex = null;\n\n  let cmd = file;\n\n  function exitHandler(code, signal) {\n    if (exited) return;\n    exited = true;\n\n    if (timeoutId) {\n      clearTimeout(timeoutId);\n      timeoutId = null;\n    }\n\n    if (!callback) return;\n\n    const readableEncoding = child?.stdout?.readableEncoding;\n    // merge chunks\n    let stdout;\n    let stderr;\n    if (encoding || (child.stdout && readableEncoding)) {\n      stdout = ArrayPrototypeJoin.call(_stdout, \"\");\n    } else {\n      stdout = BufferConcat(_stdout);\n    }\n    if (encoding || (child.stderr && readableEncoding)) {\n      stderr = ArrayPrototypeJoin.call(_stderr, \"\");\n    } else {\n      stderr = BufferConcat(_stderr);\n    }\n\n    if (!ex && code === 0 && signal === null) {\n      callback(null, stdout, stderr);\n      return;\n    }\n\n    if (args?.length) cmd += ` ${ArrayPrototypeJoin.call(args, \" \")}`;\n    if (!ex) {\n      let message = `Command failed: ${cmd}`;\n      if (stderr) message += `\\n${stderr}`;\n      ex = genericNodeError(message, {\n        // code: code < 0 ? getSystemErrorName(code) : code, // TODO: Add getSystemErrorName\n        code: code,\n        killed: child.killed || killed,\n        signal: signal,\n      });\n    }\n\n    ex.cmd = cmd;\n    callback(ex, stdout, stderr);\n  }\n\n  function errorHandler(e) {\n    ex = e;\n\n    if (child.stdout) child.stdout.destroy();\n    if (child.stderr) child.stderr.destroy();\n\n    exitHandler();\n  }\n\n  function kill() {\n    if (child.stdout) child.stdout.destroy();\n    if (child.stderr) child.stderr.destroy();\n\n    killed = true;\n    try {\n      child.kill(options.killSignal);\n    } catch (e) {\n      ex = e;\n      exitHandler();\n    }\n  }\n\n  if (options.timeout > 0) {\n    timeoutId = setTimeout(function delayedKill() {\n      kill();\n      timeoutId = null;\n    }, options.timeout);\n  }\n\n  if (child.stdout) {\n    if (encoding) child.stdout.setEncoding(encoding);\n\n    child.stdout.on(\n      \"data\",\n      maxBuffer === Infinity\n        ? function onUnlimitedSizeBufferedData(chunk) {\n            ArrayPrototypePush.call(_stdout, chunk);\n          }\n        : encoding\n        ? function onChildStdoutEncoded(chunk) {\n            stdoutLen += chunk.length;\n\n            if (stdoutLen * 4 > maxBuffer) {\n              const encoding = child.stdout.readableEncoding;\n              const actualLen = Buffer.byteLength(chunk, encoding);\n              if (encodedStdoutLen === undefined) {\n                for (let i = 0; i < _stdout.length; i++) {\n                  encodedStdoutLen += Buffer.byteLength(_stdout[i], encoding);\n                }\n              } else {\n                encodedStdoutLen += actualLen;\n              }\n              const truncatedLen = maxBuffer - (encodedStdoutLen - actualLen);\n              ArrayPrototypePush.call(_stdout, StringPrototypeSlice.apply(chunk, 0, truncatedLen));\n\n              ex = new ERR_CHILD_PROCESS_STDIO_MAXBUFFER(\"stdout\");\n              kill();\n            } else {\n              ArrayPrototypePush.call(_stdout, chunk);\n            }\n          }\n        : function onChildStdoutRaw(chunk) {\n            stdoutLen += chunk.length;\n\n            if (stdoutLen > maxBuffer) {\n              const truncatedLen = maxBuffer - (stdoutLen - chunk.length);\n              ArrayPrototypePush.call(_stdout, chunk.slice(0, truncatedLen));\n\n              ex = new ERR_CHILD_PROCESS_STDIO_MAXBUFFER(\"stdout\");\n              kill();\n            } else {\n              ArrayPrototypePush.call(_stdout, chunk);\n            }\n          },\n    );\n  }\n\n  if (child.stderr) {\n    if (encoding) child.stderr.setEncoding(encoding);\n\n    child.stderr.on(\n      \"data\",\n      maxBuffer === Infinity\n        ? function onUnlimitedSizeBufferedData(chunk) {\n            ArrayPrototypePush.call(_stderr, chunk);\n          }\n        : encoding\n        ? function onChildStderrEncoded(chunk) {\n            stderrLen += chunk.length;\n\n            if (stderrLen * 4 > maxBuffer) {\n              const encoding = child.stderr.readableEncoding;\n              const actualLen = Buffer.byteLength(chunk, encoding);\n              if (encodedStderrLen === undefined) {\n                for (let i = 0; i < _stderr.length; i++) {\n                  encodedStderrLen += Buffer.byteLength(_stderr[i], encoding);\n                }\n              } else {\n                encodedStderrLen += actualLen;\n              }\n              const truncatedLen = maxBuffer - (encodedStderrLen - actualLen);\n              ArrayPrototypePush.call(_stderr, StringPrototypeSlice.call(chunk, 0, truncatedLen));\n\n              ex = new ERR_CHILD_PROCESS_STDIO_MAXBUFFER(\"stderr\");\n              kill();\n            } else {\n              ArrayPrototypePush.call(_stderr, chunk);\n            }\n          }\n        : function onChildStderrRaw(chunk) {\n            stderrLen += chunk.length;\n\n            if (stderrLen > maxBuffer) {\n              const truncatedLen = maxBuffer - (stderrLen - chunk.length);\n              ArrayPrototypePush.call(_stderr, StringPrototypeSlice.call(chunk, 0, truncatedLen));\n\n              ex = new ERR_CHILD_PROCESS_STDIO_MAXBUFFER(\"stderr\");\n              kill();\n            } else {\n              ArrayPrototypePush.call(_stderr, chunk);\n            }\n          },\n    );\n  }\n\n  child.addListener(\"close\", exitHandler);\n  child.addListener(\"error\", errorHandler);\n\n  return child;\n}\n\n/**\n * Spawns a shell executing the given command.\n * @param {string} command\n * @param {{\n *   cmd?: string;\n *   env?: Record<string, string>;\n *   encoding?: string;\n *   shell?: string;\n *   signal?: AbortSignal;\n *   timeout?: number;\n *   maxBuffer?: number;\n *   killSignal?: string | number;\n *   uid?: number;\n *   gid?: number;\n *   windowsHide?: boolean;\n *   }} [options]\n * @param {(\n *   error?: Error,\n *   stdout?: string | Buffer,\n *   stderr?: string | Buffer\n *   ) => any} [callback]\n * @returns {ChildProcess}\n */\nexport function exec(command, options, callback) {\n  const opts = normalizeExecArgs(command, options, callback);\n  return execFile(opts.file, opts.options, opts.callback);\n}\n\nconst customPromiseExecFunction = orig => {\n  return (...args) => {\n    let resolve;\n    let reject;\n    const promise = new Promise((res, rej) => {\n      resolve = res;\n      reject = rej;\n    });\n\n    promise.child = orig(...args, (err, stdout, stderr) => {\n      if (err !== null) {\n        err.stdout = stdout;\n        err.stderr = stderr;\n        reject(err);\n      } else {\n        resolve({ stdout, stderr });\n      }\n    });\n\n    return promise;\n  };\n};\n\nObjectDefineProperty(exec, promisify.custom, {\n  __proto__: null,\n  enumerable: false,\n  value: customPromiseExecFunction(exec),\n});\n\n/**\n * Spawns a new process synchronously using the given `file`.\n * @param {string} file\n * @param {string[]} [args]\n * @param {{\n *   cwd?: string;\n *   input?: string | Buffer | TypedArray | DataView;\n *   argv0?: string;\n *   stdio?: string | Array;\n *   env?: Record<string, string>;\n *   uid?: number;\n *   gid?: number;\n *   timeout?: number;\n *   killSignal?: string | number;\n *   maxBuffer?: number;\n *   encoding?: string;\n *   shell?: boolean | string;\n *   }} [options]\n * @returns {{\n *   pid: number;\n *   output: Array;\n *   stdout: Buffer | string;\n *   stderr: Buffer | string;\n *   status: number | null;\n *   signal: string | null;\n *   error: Error;\n *   }}\n */\nexport function spawnSync(file, args, options) {\n  options = {\n    maxBuffer: MAX_BUFFER,\n    ...normalizeSpawnArguments(file, args, options),\n  };\n\n  const maxBuffer = options.maxBuffer;\n  const encoding = options.encoding;\n\n  debug(\"spawnSync\", options);\n\n  // Validate the timeout, if present.\n  validateTimeout(options.timeout);\n\n  // Validate maxBuffer, if present.\n  validateMaxBuffer(maxBuffer);\n\n  // Validate and translate the kill signal, if present.\n  options.killSignal = sanitizeKillSignal(options.killSignal);\n\n  const stdio = options.stdio || \"pipe\";\n  const bunStdio = getBunStdioFromOptions(stdio);\n\n  var { input } = options;\n  if (input) {\n    if (ArrayBufferIsView(input)) {\n      bunStdio[0] = input;\n    } else if (typeof input === \"string\") {\n      bunStdio[0] = Buffer.from(input, encoding || \"utf8\");\n    } else {\n      throw new ERR_INVALID_ARG_TYPE(`options.stdio[0]`, [\"Buffer\", \"TypedArray\", \"DataView\", \"string\"], input);\n    }\n  }\n\n  const { stdout, stderr, success, exitCode } = Bun.spawnSync({\n    cmd: options.args,\n    env: options.env || undefined,\n    cwd: options.cwd || undefined,\n    stdin: bunStdio[0],\n    stdout: bunStdio[1],\n    stderr: bunStdio[2],\n  });\n\n  const result = {\n    signal: null,\n    status: exitCode,\n    output: [null, stdout, stderr],\n  };\n\n  if (stdout && encoding && encoding !== \"buffer\") {\n    result.output[1] = result.output[1]?.toString(encoding);\n  }\n\n  if (stderr && encoding && encoding !== \"buffer\") {\n    result.output[2] = result.output[2]?.toString(encoding);\n  }\n\n  result.stdout = result.output[1];\n  result.stderr = result.output[2];\n\n  if (!success) {\n    result.error = new SystemError(result.output[2], options.file, \"spawnSync\", -1, result.status);\n    result.error.spawnargs = ArrayPrototypeSlice.call(options.args, 1);\n  }\n\n  return result;\n}\n\n/**\n * Spawns a file as a shell synchronously.\n * @param {string} file\n * @param {string[]} [args]\n * @param {{\n *   cwd?: string;\n *   input?: string | Buffer | TypedArray | DataView;\n *   stdio?: string | Array;\n *   env?: Record<string, string>;\n *   uid?: number;\n *   gid?: number;\n *   timeout?: number;\n *   killSignal?: string | number;\n *   maxBuffer?: number;\n *   encoding?: string;\n *   windowsHide?: boolean;\n *   shell?: boolean | string;\n *   }} [options]\n * @returns {Buffer | string}\n */\nexport function execFileSync(file, args, options) {\n  ({ file, args, options } = normalizeExecFileArgs(file, args, options));\n\n  // const inheritStderr = !options.stdio;\n  const ret = spawnSync(file, args, options);\n\n  // if (inheritStderr && ret.stderr) process.stderr.write(ret.stderr);\n\n  const errArgs = [options.argv0 || file];\n  ArrayPrototypePush.apply(errArgs, args);\n  const err = checkExecSyncError(ret, errArgs);\n\n  if (err) throw err;\n\n  return ret.stdout;\n}\n\n/**\n * Spawns a shell executing the given `command` synchronously.\n * @param {string} command\n * @param {{\n *   cwd?: string;\n *   input?: string | Buffer | TypedArray | DataView;\n *   stdio?: string | Array;\n *   env?: Record<string, string>;\n *   shell?: string;\n *   uid?: number;\n *   gid?: number;\n *   timeout?: number;\n *   killSignal?: string | number;\n *   maxBuffer?: number;\n *   encoding?: string;\n *   windowsHide?: boolean;\n *   }} [options]\n * @returns {Buffer | string}\n */\nexport function execSync(command, options) {\n  const opts = normalizeExecArgs(command, options, null);\n  // const inheritStderr = !opts.options.stdio;\n\n  const ret = spawnSync(opts.file, opts.options);\n\n  // if (inheritStderr && ret.stderr) process.stderr.write(ret.stderr); // TODO: Uncomment when we have process.stderr\n\n  const err = checkExecSyncError(ret, undefined, command);\n\n  if (err) throw err;\n\n  return ret.stdout;\n}\n\nexport function fork() {\n  throw new Error(\"Not implemented\");\n}\n\n//------------------------------------------------------------------------------\n// Section 2. child_process helpers\n//------------------------------------------------------------------------------\nfunction convertToValidSignal(signal) {\n  if (typeof signal === \"number\" && getSignalsToNamesMapping()[signal]) return signal;\n\n  if (typeof signal === \"string\") {\n    const signalName = signals[StringPrototypeToUpperCase.call(signal)];\n    if (signalName) return signalName;\n  }\n\n  throw new ERR_UNKNOWN_SIGNAL(signal);\n}\n\nfunction sanitizeKillSignal(killSignal) {\n  if (typeof killSignal === \"string\" || typeof killSignal === \"number\") {\n    return convertToValidSignal(killSignal);\n  } else if (killSignal != null) {\n    throw new ERR_INVALID_ARG_TYPE(\"options.killSignal\", [\"string\", \"number\"], killSignal);\n  }\n}\n\nlet signalsToNamesMapping;\nfunction getSignalsToNamesMapping() {\n  if (signalsToNamesMapping !== undefined) return signalsToNamesMapping;\n\n  signalsToNamesMapping = ObjectCreate(null);\n  for (const key in signals) {\n    signalsToNamesMapping[signals[key]] = key;\n  }\n\n  return signalsToNamesMapping;\n}\n\nfunction normalizeExecFileArgs(file, args, options, callback) {\n  if (ArrayIsArray(args)) {\n    args = ArrayPrototypeSlice.call(args);\n  } else if (args != null && typeof args === \"object\") {\n    callback = options;\n    options = args;\n    args = null;\n  } else if (typeof args === \"function\") {\n    callback = args;\n    options = null;\n    args = null;\n  }\n\n  if (args == null) {\n    args = [];\n  }\n\n  if (typeof options === \"function\") {\n    callback = options;\n  } else if (options != null) {\n    validateObject(options, \"options\");\n  }\n\n  if (options == null) {\n    options = kEmptyObject;\n  }\n\n  if (callback != null) {\n    validateFunction(callback, \"callback\");\n  }\n\n  // Validate argv0, if present.\n  if (options.argv0 != null) {\n    validateString(options.argv0, \"options.argv0\");\n    validateArgumentNullCheck(options.argv0, \"options.argv0\");\n  }\n\n  return { file, args, options, callback };\n}\n\nfunction normalizeExecArgs(command, options, callback) {\n  validateString(command, \"command\");\n  validateArgumentNullCheck(command, \"command\");\n\n  if (typeof options === \"function\") {\n    callback = options;\n    options = undefined;\n  }\n\n  // Make a shallow copy so we don't clobber the user's options object.\n  options = { ...options };\n  options.shell = typeof options.shell === \"string\" ? options.shell : true;\n\n  return {\n    file: command,\n    options: options,\n    callback: callback,\n  };\n}\n\nfunction normalizeSpawnArguments(file, args, options) {\n  validateString(file, \"file\");\n  validateArgumentNullCheck(file, \"file\");\n\n  if (file.length === 0) throw new ERR_INVALID_ARG_VALUE(\"file\", file, \"cannot be empty\");\n\n  if (ArrayIsArray(args)) {\n    args = ArrayPrototypeSlice.call(args);\n  } else if (args == null) {\n    args = [];\n  } else if (typeof args !== \"object\") {\n    throw new ERR_INVALID_ARG_TYPE(\"args\", \"object\", args);\n  } else {\n    options = args;\n    args = [];\n  }\n\n  validateArgumentsNullCheck(args, \"args\");\n\n  if (options === undefined) options = {};\n  else validateObject(options, \"options\");\n\n  let cwd = options.cwd;\n\n  // Validate the cwd, if present.\n  if (cwd != null) {\n    cwd = getValidatedPath(cwd, \"options.cwd\");\n  }\n\n  // TODO: Detached check\n  // TODO: Gid check\n  // TODO: Uid check\n\n  // Validate the shell, if present.\n  if (options.shell != null && typeof options.shell !== \"boolean\" && typeof options.shell !== \"string\") {\n    throw new ERR_INVALID_ARG_TYPE(\"options.shell\", [\"boolean\", \"string\"], options.shell);\n  }\n\n  // Validate argv0, if present.\n  if (options.argv0 != null) {\n    validateString(options.argv0, \"options.argv0\");\n    validateArgumentNullCheck(options.argv0, \"options.argv0\");\n  }\n\n  // TODO: Windows checks for Windows specific options\n\n  // Handle shell\n  if (options.shell) {\n    validateArgumentNullCheck(options.shell, \"options.shell\");\n    const command = ArrayPrototypeJoin.call([file, ...args], \" \");\n    // TODO: Windows moment\n    // Set the shell, switches, and commands.\n    // if (process.platform === \"win32\") {\n    //   if (typeof options.shell === \"string\") file = options.shell;\n    //   else file = process.env.comspec || \"cmd.exe\";\n    //   // '/d /s /c' is used only for cmd.exe.\n    //   if (RegExpPrototypeExec(/^(?:.*\\\\)?cmd(?:\\.exe)?$/i, file) !== null) {\n    //     args = [\"/d\", \"/s\", \"/c\", `\"${command}\"`];\n    //     windowsVerbatimArguments = true;\n    //   } else {\n    //     args = [\"-c\", command];\n    //   }\n    // } else {\n    if (typeof options.shell === \"string\") file = options.shell;\n    else if (process.platform === \"android\") file = \"sh\";\n    else file = \"sh\";\n    args = [\"-c\", command];\n    // }\n  }\n\n  // Handle argv0\n  if (typeof options.argv0 === \"string\") {\n    ArrayPrototypeUnshift.call(args, options.argv0);\n  } else {\n    ArrayPrototypeUnshift.call(args, file);\n  }\n\n  const env = options.env || process.env;\n  const envPairs = env;\n\n  // // process.env.NODE_V8_COVERAGE always propagates, making it possible to\n  // // collect coverage for programs that spawn with white-listed environment.\n  // copyProcessEnvToEnv(env, \"NODE_V8_COVERAGE\", options.env);\n\n  // TODO: Windows env support here...\n\n  return { ...options, file, args, cwd, envPairs };\n}\n\nfunction checkExecSyncError(ret, args, cmd) {\n  let err;\n  if (ret.error) {\n    err = ret.error;\n    ObjectAssign(err, ret);\n  } else if (ret.status !== 0) {\n    let msg = \"Command failed: \";\n    msg += cmd || ArrayPrototypeJoin.call(args, \" \");\n    if (ret.stderr && ret.stderr.length > 0) msg += `\\n${ret.stderr.toString()}`;\n    err = genericNodeError(msg, ret);\n  }\n  return err;\n}\n\n//------------------------------------------------------------------------------\n// Section 3. ChildProcess class\n//------------------------------------------------------------------------------\nexport class ChildProcess extends EventEmitter {\n  #handle;\n  #exited = false;\n  #closesNeeded = 1;\n  #closesGot = 0;\n\n  connected = false;\n  signalCode = null;\n  exitCode = null;\n  spawnfile;\n  spawnargs;\n  pid;\n  channel;\n\n  get killed() {\n    if (this.#handle == null) return false;\n  }\n\n  // constructor(options) {\n  //   super(options);\n  //   this.#handle[owner_symbol] = this;\n  // }\n\n  #handleOnExit(exitCode, signalCode, err) {\n    if (this.#exited) return;\n    this.exitCode = this.#handle.exitCode;\n    this.signalCode = exitCode > 0 ? signalCode : null;\n\n    if (this.#stdin) {\n      this.#stdin.destroy();\n    }\n\n    if (this.#handle) {\n      this.#handle = null;\n    }\n\n    if (exitCode < 0) {\n      const err = new SystemError(\n        `Spawned process exited with error code: ${exitCode}`,\n        undefined,\n        \"spawn\",\n        \"EUNKNOWN\",\n        \"ERR_CHILD_PROCESS_UNKNOWN_ERROR\",\n      );\n\n      if (this.spawnfile) err.path = this.spawnfile;\n\n      err.spawnargs = ArrayPrototypeSlice.call(this.spawnargs, 1);\n      this.emit(\"error\", err);\n    } else {\n      this.emit(\"exit\", this.exitCode, this.signalCode);\n    }\n\n    // If any of the stdio streams have not been touched,\n    // then pull all the data through so that it can get the\n    // eof and emit a 'close' event.\n    // Do it on nextTick so that the user has one last chance\n    // to consume the output, if for example they only want to\n    // start reading the data once the process exits.\n    process.nextTick(flushStdio, this);\n\n    this.#maybeClose();\n    this.#exited = true;\n    this.#stdioOptions = [\"destroyed\", \"destroyed\", \"destroyed\"];\n  }\n\n  #getBunSpawnIo(i, encoding) {\n    if (__DEBUG__ && !this.#handle) {\n      if (this.#handle === null) {\n        debug(\"ChildProcess: getBunSpawnIo: this.#handle is null. This means the subprocess already exited\");\n      } else {\n        debug(\"ChildProcess: getBunSpawnIo: this.#handle is undefined\");\n      }\n    }\n    const io = this.#stdioOptions[i];\n    switch (i) {\n      case 0: {\n        switch (io) {\n          case \"pipe\":\n            return new NativeWritable(this.#handle.stdin);\n          case \"inherit\":\n            return process.stdin || null;\n          case \"destroyed\":\n            return new ShimmedStdin();\n          default:\n            return null;\n        }\n      }\n      case 2:\n      case 1: {\n        switch (io) {\n          case \"pipe\":\n            return ReadableFromWeb(\n              this.#handle[fdToStdioName(i)],\n              __TRACK_STDIO__\n                ? {\n                    encoding,\n                    __id: `PARENT_${fdToStdioName(i).toUpperCase()}-${globalThis.__getId()}`,\n                  }\n                : { encoding },\n            );\n          case \"inherit\":\n            return process[fdToStdioName(i)] || null;\n          case \"destroyed\":\n            return new ShimmedStdioOutStream();\n          default:\n            return null;\n        }\n      }\n    }\n  }\n\n  #stdin;\n  #stdout;\n  #stderr;\n  #stdioObject;\n  #encoding;\n  #stdioOptions;\n\n  #createStdioObject() {\n    return Object.create(null, {\n      0: {\n        get: () => this.stdin,\n      },\n      1: {\n        get: () => this.stdout,\n      },\n      2: {\n        get: () => this.stderr,\n      },\n    });\n  }\n\n  get stdin() {\n    return (this.#stdin ??= this.#getBunSpawnIo(0, this.#encoding));\n  }\n\n  get stdout() {\n    return (this.#stdout ??= this.#getBunSpawnIo(1, this.#encoding));\n  }\n\n  get stderr() {\n    return (this.#stderr ??= this.#getBunSpawnIo(2, this.#encoding));\n  }\n\n  get stdio() {\n    return (this.#stdioObject ??= this.#createStdioObject());\n  }\n\n  spawn(options) {\n    validateObject(options, \"options\");\n\n    // validateOneOf(options.serialization, \"options.serialization\", [\n    //   undefined,\n    //   \"json\",\n    //   // \"advanced\", // TODO\n    // ]);\n    // const serialization = options.serialization || \"json\";\n\n    // if (ipc !== undefined) {\n    //   // Let child process know about opened IPC channel\n    //   if (options.envPairs === undefined) options.envPairs = [];\n    //   else validateArray(options.envPairs, \"options.envPairs\");\n\n    //   ArrayPrototypePush.call(options.envPairs, `NODE_CHANNEL_FD=${ipcFd}`);\n    //   ArrayPrototypePush.call(\n    //     options.envPairs,\n    //     `NODE_CHANNEL_SERIALIZATION_MODE=${serialization}`\n    //   );\n    // }\n\n    validateString(options.file, \"options.file\");\n    // NOTE: This is confusing... So node allows you to pass a file name\n    // But also allows you to pass a command in the args and it should execute\n    // To add another layer of confusion, they also give the option to pass an explicit \"argv0\"\n    // which overrides the actual command of the spawned process...\n    var file;\n    file = this.spawnfile = options.file;\n\n    var spawnargs;\n    if (options.args == null) {\n      spawnargs = this.spawnargs = [];\n    } else {\n      validateArray(options.args, \"options.args\");\n      spawnargs = this.spawnargs = options.args;\n    }\n\n    const stdio = options.stdio || [\"pipe\", \"pipe\", \"pipe\"];\n    const bunStdio = getBunStdioFromOptions(stdio);\n\n    var env = options.envPairs || undefined;\n\n    this.#encoding = options.encoding || undefined;\n    this.#stdioOptions = bunStdio;\n    this.#handle = Bun.spawn({\n      cmd: spawnargs,\n      stdin: bunStdio[0],\n      stdout: bunStdio[1],\n      stderr: bunStdio[2],\n      cwd: options.cwd || undefined,\n      env: env || process.env,\n      onExit: (handle, exitCode, signalCode, err) => {\n        this.#handle = handle;\n        this.pid = this.#handle.pid;\n\n        process.nextTick(\n          (exitCode, signalCode, err) => this.#handleOnExit(exitCode, signalCode, err),\n          exitCode,\n          signalCode,\n          err,\n        );\n      },\n      lazy: true,\n    });\n    this.pid = this.#handle.pid;\n\n    onSpawnNT(this);\n\n    // const ipc = stdio.ipc;\n    // const ipcFd = stdio.ipcFd;\n    // stdio = options.stdio = stdio.stdio;\n\n    // for (i = 0; i < stdio.length; i++) {\n    //   const stream = stdio[i];\n    //   if (stream.type === \"ignore\") continue;\n\n    //   if (stream.ipc) {\n    //     this._closesNeeded++;\n    //     continue;\n    //   }\n\n    //   // The stream is already cloned and piped, thus stop its readable side,\n    //   // otherwise we might attempt to read from the stream when at the same time\n    //   // the child process does.\n    //   if (stream.type === \"wrap\") {\n    //     stream.handle.reading = false;\n    //     stream.handle.readStop();\n    //     stream._stdio.pause();\n    //     stream._stdio.readableFlowing = false;\n    //     stream._stdio._readableState.reading = false;\n    //     stream._stdio[kIsUsedAsStdio] = true;\n    //     continue;\n    //   }\n\n    //   if (stream.handle) {\n    //     stream.socket = createSocket(\n    //       this.pid !== 0 ? stream.handle : null,\n    //       i > 0\n    //     );\n\n    // // Add .send() method and start listening for IPC data\n    // if (ipc !== undefined) setupChannel(this, ipc, serialization);\n  }\n\n  send() {\n    console.log(\"ChildProcess.prototype.send() - Sorry! Not implemented yet\");\n  }\n\n  disconnect() {\n    console.log(\"ChildProcess.prototype.disconnect() - Sorry! Not implemented yet\");\n  }\n\n  kill(sig) {\n    const signal = sig === 0 ? sig : convertToValidSignal(sig === undefined ? \"SIGTERM\" : sig);\n\n    if (this.#handle) {\n      this.#handle.kill(signal);\n    }\n\n    this.#maybeClose();\n\n    // TODO: Figure out how to make this conform to the Node spec...\n    // The problem is that the handle does not report killed until the process exits\n    // So we can't return whether or not the process was killed because Bun.spawn seems to handle this async instead of sync like Node does\n    // return this.#handle?.killed ?? true;\n    return true;\n  }\n\n  #maybeClose() {\n    debug(\"Attempting to maybe close...\");\n    this.#closesGot++;\n    if (this.#closesGot === this.#closesNeeded) {\n      this.emit(\"close\", this.exitCode, this.signalCode);\n    }\n  }\n\n  ref() {\n    if (this.#handle) this.#handle.ref();\n  }\n\n  unref() {\n    if (this.#handle) this.#handle.unref();\n  }\n}\n\n//------------------------------------------------------------------------------\n// Section 4. ChildProcess helpers\n//------------------------------------------------------------------------------\nconst nodeToBunLookup = {\n  ignore: null,\n  pipe: \"pipe\",\n  overlapped: \"pipe\", // TODO: this may need to work differently for Windows\n  inherit: \"inherit\",\n};\n\nfunction nodeToBun(item) {\n  // If inherit and we are referencing stdin/stdout/stderr index,\n  // we can get the fd from the ReadStream for the corresponding stdio\n  if (typeof item === \"number\") {\n    return item;\n  } else {\n    const result = nodeToBunLookup[item];\n    if (result === undefined) throw new Error(\"Invalid stdio option\");\n    return result;\n  }\n}\n\nfunction fdToStdioName(fd) {\n  switch (fd) {\n    case 0:\n      return \"stdin\";\n    case 1:\n      return \"stdout\";\n    case 2:\n      return \"stderr\";\n    default:\n      return null;\n  }\n}\n\nfunction getBunStdioFromOptions(stdio) {\n  const normalizedStdio = normalizeStdio(stdio);\n  // Node options:\n  // pipe: just a pipe\n  // ipc = can only be one in array\n  // overlapped -- same as pipe on Unix based systems\n  // inherit -- 'inherit': equivalent to ['inherit', 'inherit', 'inherit'] or [0, 1, 2]\n  // ignore -- > /dev/null, more or less same as null option for Bun.spawn stdio\n  // TODO: Stream -- use this stream\n  // number -- used as FD\n  // null, undefined: Use default value. Not same as ignore, which is Bun.spawn null.\n  // null/undefined: For stdio fds 0, 1, and 2 (in other words, stdin, stdout, and stderr) a pipe is created. For fd 3 and up, the default is 'ignore'\n\n  // Important Bun options\n  // pipe\n  // fd\n  // null - no stdin/stdout/stderr\n\n  // Translations: node -> bun\n  // pipe -> pipe\n  // overlapped -> pipe\n  // ignore -> null\n  // inherit -> inherit (stdin/stdout/stderr)\n  // Stream -> throw err for now\n  const bunStdio = normalizedStdio.map(item => nodeToBun(item));\n  return bunStdio;\n}\n\nfunction normalizeStdio(stdio) {\n  if (typeof stdio === \"string\") {\n    switch (stdio) {\n      case \"ignore\":\n        return [\"ignore\", \"ignore\", \"ignore\"];\n      case \"pipe\":\n        return [\"pipe\", \"pipe\", \"pipe\"];\n      case \"inherit\":\n        return [\"inherit\", \"inherit\", \"inherit\"];\n      default:\n        throw new ERR_INVALID_OPT_VALUE(\"stdio\", stdio);\n    }\n  } else if (ArrayIsArray(stdio)) {\n    // Validate if each is a valid stdio type\n    // TODO: Support wrapped types here\n\n    let processedStdio;\n    if (stdio.length === 0) processedStdio = [\"pipe\", \"pipe\", \"pipe\"];\n    else if (stdio.length === 1) processedStdio = [stdio[0], \"pipe\", \"pipe\"];\n    else if (stdio.length === 2) processedStdio = [stdio[0], stdio[1], \"pipe\"];\n    else if (stdio.length >= 3) processedStdio = [stdio[0], stdio[1], stdio[2]];\n\n    return processedStdio.map(item => (!item ? \"pipe\" : item));\n  } else {\n    throw new ERR_INVALID_OPT_VALUE(\"stdio\", stdio);\n  }\n}\n\nfunction flushStdio(subprocess) {\n  const stdio = subprocess.stdio;\n  if (stdio == null) return;\n\n  for (let i = 0; i < stdio.length; i++) {\n    const stream = stdio[i];\n    // TODO(addaleax): This doesn't necessarily account for all the ways in\n    // which data can be read from a stream, e.g. being consumed on the\n    // native layer directly as a StreamBase.\n    if (!stream || !stream.readable) {\n      continue;\n    }\n    stream.resume();\n  }\n}\n\nfunction onSpawnNT(self) {\n  self.emit(\"spawn\");\n}\n\nfunction abortChildProcess(child, killSignal) {\n  if (!child) return;\n  try {\n    if (child.kill(killSignal)) {\n      child.emit(\"error\", new AbortError());\n    }\n  } catch (err) {\n    child.emit(\"error\", err);\n  }\n}\n\nclass ShimmedStdin extends EventEmitter {\n  constructor() {\n    super();\n  }\n  write() {\n    return false;\n  }\n  destroy() {}\n  end() {}\n  pipe() {}\n}\n\nclass ShimmedStdioOutStream extends EventEmitter {\n  pipe() {}\n}\n\n//------------------------------------------------------------------------------\n// Section 5. Validators\n//------------------------------------------------------------------------------\n\nfunction validateMaxBuffer(maxBuffer) {\n  if (maxBuffer != null && !(typeof maxBuffer === \"number\" && maxBuffer >= 0)) {\n    throw new ERR_OUT_OF_RANGE(\"options.maxBuffer\", \"a positive number\", maxBuffer);\n  }\n}\n\nfunction validateArgumentNullCheck(arg, propName) {\n  if (typeof arg === \"string\" && StringPrototypeIncludes.call(arg, \"\\u0000\")) {\n    throw new ERR_INVALID_ARG_VALUE(propName, arg, \"must be a string without null bytes\");\n  }\n}\n\nfunction validateArgumentsNullCheck(args, propName) {\n  for (let i = 0; i < args.length; ++i) {\n    validateArgumentNullCheck(args[i], `${propName}[${i}]`);\n  }\n}\n\nfunction validateTimeout(timeout) {\n  if (timeout != null && !(NumberIsInteger(timeout) && timeout >= 0)) {\n    throw new ERR_OUT_OF_RANGE(\"timeout\", \"an unsigned integer\", timeout);\n  }\n}\n\nfunction validateBoolean(value, name) {\n  if (typeof value !== \"boolean\") throw new ERR_INVALID_ARG_TYPE(name, \"boolean\", value);\n}\n\n/**\n * @callback validateFunction\n * @param {*} value\n * @param {string} name\n * @returns {asserts value is Function}\n */\n\n/** @type {validateFunction} */\nfunction validateFunction(value, name) {\n  if (typeof value !== \"function\") throw new ERR_INVALID_ARG_TYPE(name, \"Function\", value);\n}\n\n/**\n * @callback validateAbortSignal\n * @param {*} signal\n * @param {string} name\n */\n\n/** @type {validateAbortSignal} */\nconst validateAbortSignal = (signal, name) => {\n  if (signal !== undefined && (signal === null || typeof signal !== \"object\" || !(\"aborted\" in signal))) {\n    throw new ERR_INVALID_ARG_TYPE(name, \"AbortSignal\", signal);\n  }\n};\n\n/**\n * @callback validateOneOf\n * @template T\n * @param {T} value\n * @param {string} name\n * @param {T[]} oneOf\n */\n\n/** @type {validateOneOf} */\nconst validateOneOf = (value, name, oneOf) => {\n  // const validateOneOf = hideStackFrames((value, name, oneOf) => {\n  if (!ArrayPrototypeIncludes.call(oneOf, value)) {\n    const allowed = ArrayPrototypeJoin.call(\n      ArrayPrototypeMap.call(oneOf, v => (typeof v === \"string\" ? `'${v}'` : String(v))),\n      \", \",\n    );\n    const reason = \"must be one of: \" + allowed;\n    throw new ERR_INVALID_ARG_VALUE(name, value, reason);\n  }\n};\n\n/**\n * @callback validateObject\n * @param {*} value\n * @param {string} name\n * @param {{\n *   allowArray?: boolean,\n *   allowFunction?: boolean,\n *   nullable?: boolean\n * }} [options]\n */\n\n/** @type {validateObject} */\nconst validateObject = (value, name, options = null) => {\n  // const validateObject = hideStackFrames((value, name, options = null) => {\n  const allowArray = options?.allowArray ?? false;\n  const allowFunction = options?.allowFunction ?? false;\n  const nullable = options?.nullable ?? false;\n  if (\n    (!nullable && value === null) ||\n    (!allowArray && ArrayIsArray.call(value)) ||\n    (typeof value !== \"object\" && (!allowFunction || typeof value !== \"function\"))\n  ) {\n    throw new ERR_INVALID_ARG_TYPE(name, \"object\", value);\n  }\n};\n\n/**\n * @callback validateArray\n * @param {*} value\n * @param {string} name\n * @param {number} [minLength]\n * @returns {asserts value is any[]}\n */\n\n/** @type {validateArray} */\nconst validateArray = (value, name, minLength = 0) => {\n  // const validateArray = hideStackFrames((value, name, minLength = 0) => {\n  if (!ArrayIsArray(value)) {\n    throw new ERR_INVALID_ARG_TYPE(name, \"Array\", value);\n  }\n  if (value.length < minLength) {\n    const reason = `must be longer than ${minLength}`;\n    throw new ERR_INVALID_ARG_VALUE(name, value, reason);\n  }\n};\n\n/**\n * @callback validateString\n * @param {*} value\n * @param {string} name\n * @returns {asserts value is string}\n */\n\n/** @type {validateString} */\nfunction validateString(value, name) {\n  if (typeof value !== \"string\") throw new ERR_INVALID_ARG_TYPE(name, \"string\", value);\n}\n\nfunction nullCheck(path, propName, throwError = true) {\n  const pathIsString = typeof path === \"string\";\n  const pathIsUint8Array = isUint8Array(path);\n\n  // We can only perform meaningful checks on strings and Uint8Arrays.\n  if (\n    (!pathIsString && !pathIsUint8Array) ||\n    (pathIsString && !StringPrototypeIncludes.call(path, \"\\u0000\")) ||\n    (pathIsUint8Array && !Uint8ArrayPrototypeIncludes.call(path, 0))\n  ) {\n    return;\n  }\n\n  const err = new ERR_INVALID_ARG_VALUE(propName, path, \"must be a string or Uint8Array without null bytes\");\n  if (throwError) {\n    throw err;\n  }\n  return err;\n}\n\nfunction validatePath(path, propName = \"path\") {\n  if (typeof path !== \"string\" && !isUint8Array(path)) {\n    throw new ERR_INVALID_ARG_TYPE(propName, [\"string\", \"Buffer\", \"URL\"], path);\n  }\n\n  const err = nullCheck(path, propName, false);\n\n  if (err !== undefined) {\n    throw err;\n  }\n}\n\nfunction getValidatedPath(fileURLOrPath, propName = \"path\") {\n  const path = toPathIfFileURL(fileURLOrPath);\n  validatePath(path, propName);\n  return path;\n}\n\nfunction isUint8Array(value) {\n  return typeof value === \"object\" && value !== null && value instanceof Uint8Array;\n}\n\n//------------------------------------------------------------------------------\n// Section 6. Random utilities\n//------------------------------------------------------------------------------\n\nfunction isURLInstance(fileURLOrPath) {\n  return fileURLOrPath != null && fileURLOrPath.href && fileURLOrPath.origin;\n}\n\nfunction toPathIfFileURL(fileURLOrPath) {\n  if (!isURLInstance(fileURLOrPath)) return fileURLOrPath;\n  return Bun.fileURLToPath(fileURLOrPath);\n}\n\n//------------------------------------------------------------------------------\n// Section 7. Node errors / error polyfills\n//------------------------------------------------------------------------------\nvar Error = globalThis.Error;\nvar TypeError = globalThis.TypeError;\nvar RangeError = globalThis.RangeError;\n\n// Node uses a slightly different abort error than standard DOM. See: https://github.com/nodejs/node/blob/main/lib/internal/errors.js\nclass AbortError extends Error {\n  code = \"ABORT_ERR\";\n  name = \"AbortError\";\n  constructor(message = \"The operation was aborted\", options = undefined) {\n    if (options !== undefined && typeof options !== \"object\") {\n      throw new ERR_INVALID_ARG_TYPE(\"options\", \"Object\", options);\n    }\n    super(message, options);\n  }\n}\n\nfunction genericNodeError(message, options) {\n  const err = new Error(message);\n  err.code = options.code;\n  err.killed = options.killed;\n  err.signal = options.signal;\n  return err;\n}\n\n// const messages = new Map();\n\n// Utility function for registering the error codes. Only used here. Exported\n// *only* to allow for testing.\n// function E(sym, val, def) {\n//   messages.set(sym, val);\n//   def = makeNodeErrorWithCode(def, sym);\n//   errorCodes[sym] = def;\n// }\n\n// function makeNodeErrorWithCode(Base, key) {\n//   return function NodeError(...args) {\n//     // const limit = Error.stackTraceLimit;\n//     // if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = 0;\n//     const error = new Base();\n//     // Reset the limit and setting the name property.\n//     // if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = limit;\n//     const message = getMessage(key, args);\n//     error.message = message;\n//     // captureLargerStackTrace(error);\n//     error.code = key;\n//     return error;\n//   };\n// }\n\n// function getMessage(key, args) {\n//   const msgFn = messages.get(key);\n//   if (args.length !== msgFn.length)\n//     throw new Error(\n//       `Invalid number of args for error message ${key}. Got ${args.length}, expected ${msgFn.length}.`\n//     );\n//   return msgFn(...args);\n// }\n\n// E(\n//   \"ERR_INVALID_ARG_TYPE\",\n//   (name, expected, actual) => {\n//     assert(typeof name === \"string\", \"'name' must be a string\");\n//     if (!ArrayIsArray(expected)) {\n//       expected = [expected];\n//     }\n\n//     let msg = \"The \";\n//     if (StringPrototypeEndsWith(name, \" argument\")) {\n//       // For cases like 'first argument'\n//       msg += `${name} `;\n//     } else {\n//       const type = StringPrototypeIncludes(name, \".\") ? \"property\" : \"argument\";\n//       msg += `\"${name}\" ${type} `;\n//     }\n//     msg += \"must be \";\n\n//     const types = [];\n//     const instances = [];\n//     const other = [];\n\n//     for (const value of expected) {\n//       assert(\n//         typeof value === \"string\",\n//         \"All expected entries have to be of type string\"\n//       );\n//       if (ArrayPrototypeIncludes.call(kTypes, value)) {\n//         ArrayPrototypePush(types, StringPrototypeToLowerCase(value));\n//       } else if (RegExpPrototypeExec(classRegExp, value) !== null) {\n//         ArrayPrototypePush(instances, value);\n//       } else {\n//         assert(\n//           value !== \"object\",\n//           'The value \"object\" should be written as \"Object\"'\n//         );\n//         ArrayPrototypePush(other, value);\n//       }\n//     }\n\n//     // Special handle `object` in case other instances are allowed to outline\n//     // the differences between each other.\n//     if (instances.length > 0) {\n//       const pos = ArrayPrototypeIndexOf(types, \"object\");\n//       if (pos !== -1) {\n//         ArrayPrototypeSplice.call(types, pos, 1);\n//         ArrayPrototypePush.call(instances, \"Object\");\n//       }\n//     }\n\n//     if (types.length > 0) {\n//       if (types.length > 2) {\n//         const last = ArrayPrototypePop(types);\n//         msg += `one of type ${ArrayPrototypeJoin(types, \", \")}, or ${last}`;\n//       } else if (types.length === 2) {\n//         msg += `one of type ${types[0]} or ${types[1]}`;\n//       } else {\n//         msg += `of type ${types[0]}`;\n//       }\n//       if (instances.length > 0 || other.length > 0) msg += \" or \";\n//     }\n\n//     if (instances.length > 0) {\n//       if (instances.length > 2) {\n//         const last = ArrayPrototypePop(instances);\n//         msg += `an instance of ${ArrayPrototypeJoin(\n//           instances,\n//           \", \"\n//         )}, or ${last}`;\n//       } else {\n//         msg += `an instance of ${instances[0]}`;\n//         if (instances.length === 2) {\n//           msg += ` or ${instances[1]}`;\n//         }\n//       }\n//       if (other.length > 0) msg += \" or \";\n//     }\n\n//     if (other.length > 0) {\n//       if (other.length > 2) {\n//         const last = ArrayPrototypePop(other);\n//         msg += `one of ${ArrayPrototypeJoin.call(other, \", \")}, or ${last}`;\n//       } else if (other.length === 2) {\n//         msg += `one of ${other[0]} or ${other[1]}`;\n//       } else {\n//         if (StringPrototypeToLowerCase(other[0]) !== other[0]) msg += \"an \";\n//         msg += `${other[0]}`;\n//       }\n//     }\n\n//     msg += `. Received ${determineSpecificType(actual)}`;\n\n//     return msg;\n//   },\n//   TypeError\n// );\n\nfunction ERR_OUT_OF_RANGE(str, range, input, replaceDefaultBoolean = false) {\n  // Node implementation:\n  // assert(range, 'Missing \"range\" argument');\n  // let msg = replaceDefaultBoolean\n  //   ? str\n  //   : `The value of \"${str}\" is out of range.`;\n  // let received;\n  // if (NumberIsInteger(input) && MathAbs(input) > 2 ** 32) {\n  //   received = addNumericalSeparator(String(input));\n  // } else if (typeof input === \"bigint\") {\n  //   received = String(input);\n  //   if (input > 2n ** 32n || input < -(2n ** 32n)) {\n  //     received = addNumericalSeparator(received);\n  //   }\n  //   received += \"n\";\n  // } else {\n  //   received = lazyInternalUtilInspect().inspect(input);\n  // }\n  // msg += ` It must be ${range}. Received ${received}`;\n  // return new RangeError(msg);\n  return new RangeError(`The value of ${str} is out of range. It must be ${range}. Received ${input}`);\n}\n\nfunction ERR_CHILD_PROCESS_STDIO_MAXBUFFER(stdio) {\n  return Error(`${stdio} maxBuffer length exceeded`);\n}\n\nfunction ERR_UNKNOWN_SIGNAL(name) {\n  const err = new TypeError(`Unknown signal: ${name}`);\n  err.code = \"ERR_UNKNOWN_SIGNAL\";\n  return err;\n}\n\nfunction ERR_INVALID_ARG_TYPE(name, type, value) {\n  const err = new TypeError(`The \"${name}\" argument must be of type ${type}. Received ${value}`);\n  err.code = \"ERR_INVALID_ARG_TYPE\";\n  return err;\n}\n\nfunction ERR_INVALID_OPT_VALUE(name, value) {\n  return new TypeError(`The value \"${value}\" is invalid for option \"${name}\"`);\n}\n\nfunction ERR_INVALID_ARG_VALUE(name, value, reason) {\n  return new Error(`The value \"${value}\" is invalid for argument '${name}'. Reason: ${reason}`);\n}\n\nclass SystemError extends Error {\n  path;\n  syscall;\n  errno;\n  code;\n  constructor(message, path, syscall, errno, code) {\n    super(message);\n    this.path = path;\n    this.syscall = syscall;\n    this.errno = errno;\n    this.code = code;\n  }\n\n  get name() {\n    return \"SystemError\";\n  }\n}\n\nexport default {\n  ChildProcess,\n  spawn,\n  execFile,\n  exec,\n  fork,\n  spawnSync,\n  execFileSync,\n  execSync,\n\n  [Symbol.for(\"CommonJS\")]: 0,\n};\n",
  "// Hardcoded module \"node:child_process\"\nconst EventEmitter = import.meta.require(\"node:events\");\nconst {\n  Readable: { fromWeb: ReadableFromWeb },\n  NativeWritable,\n} = import.meta.require(\"node:stream\");\nconst {\n  constants: { signals },\n} = import.meta.require(\"node:os\");\nconst { promisify } = import.meta.require(\"node:util\");\n\nconst { ArrayBuffer, Uint8Array, String, Object, Buffer, Promise } = import.meta.primordials;\n\nvar ObjectPrototypeHasOwnProperty = Object.prototype.hasOwnProperty;\nvar ObjectCreate = Object.create;\nvar ObjectAssign = Object.assign;\nvar ObjectDefineProperty = Object.defineProperty;\nvar BufferConcat = Buffer.concat;\nvar BufferIsEncoding = Buffer.isEncoding;\n\nvar kEmptyObject = ObjectCreate(null);\n\nvar ArrayPrototypePush = Array.prototype.push;\nvar ArrayPrototypeReduce = Array.prototype.reduce;\nvar ArrayPrototypeFilter = Array.prototype.filter;\nvar ArrayPrototypeJoin = Array.prototype.join;\nvar ArrayPrototypeMap = Array.prototype.map;\nvar ArrayPrototypeIncludes = Array.prototype.includes;\nvar ArrayPrototypeSlice = Array.prototype.slice;\nvar ArrayPrototypeUnshift = Array.prototype.unshift;\nvar ArrayIsArray = Array.isArray;\n\n// var ArrayBuffer = ArrayBuffer;\nvar ArrayBufferIsView = ArrayBuffer.isView;\n\nvar NumberIsInteger = Number.isInteger;\nvar MathAbs = Math.abs;\n\nvar StringPrototypeToUpperCase = String.prototype.toUpperCase;\nvar StringPrototypeIncludes = String.prototype.includes;\nvar StringPrototypeSlice = String.prototype.slice;\nvar Uint8ArrayPrototypeIncludes = Uint8Array.prototype.includes;\n\nconst MAX_BUFFER = 1024 * 1024;\n\n// General debug vs tracking stdio streams. Useful for stream debugging in particular\nconst __DEBUG__ = process.env.DEBUG || false;\n\n// You can use this env var along with `process.env.DEBUG_TRACK_EE` to debug stdio streams\n// Just set `DEBUG_TRACK_EE=PARENT_STDOUT-0, PARENT_STDOUT-1`, etc. and `DEBUG_STDIO=1` and you will be able to track particular stdio streams\n// TODO: Add ability to track a range of IDs rather than just enumerated ones\nconst __TRACK_STDIO__ = process.env.DEBUG_STDIO;\nconst debug = __DEBUG__ ? console.log : () => {};\n\nif (__TRACK_STDIO__) {\n  debug(\"child_process: debug mode on\");\n  globalThis.__lastId = null;\n  globalThis.__getId = () => {\n    return globalThis.__lastId !== null ? globalThis.__lastId++ : 0;\n  };\n}\n\n// Sections:\n// 1. Exported child_process functions\n// 2. child_process helpers\n// 3. ChildProcess \"class\"\n// 4. ChildProcess helpers\n// 5. Validators\n// 6. Random utilities\n// 7. Node errors / error polyfills\n\n// TODO:\n// Port rest of node tests\n// Fix exit codes with Bun.spawn\n// ------------------------------\n// Fix errors\n// Support file descriptors being passed in for stdio\n// ------------------------------\n// TODO: Look at Pipe to see if we can support passing Node Pipe objects to stdio param\n\n// TODO: Add these params after support added in Bun.spawn\n// uid <number> Sets the user identity of the process (see setuid(2)).\n// gid <number> Sets the group identity of the process (see setgid(2)).\n// detached <boolean> Prepare child to run independently of its parent process. Specific behavior depends on the platform, see options.detached).\n\n// TODO: After IPC channels can be opened\n// serialization <string> Specify the kind of serialization used for sending messages between processes. Possible values are 'json' and 'advanced'. See Advanced serialization for more details. Default: 'json'.\n\n// TODO: Add support for ipc option, verify only one IPC channel in array\n// stdio <Array> | <string> Child's stdio configuration (see options.stdio).\n// Support wrapped ipc types (e.g. net.Socket, dgram.Socket, TTY, etc.)\n// IPC FD passing support\n\n// From node child_process docs(https://nodejs.org/api/child_process.html#optionsstdio):\n// 'ipc': Create an IPC channel for passing messages/file descriptors between parent and child.\n// A ChildProcess may have at most one IPC stdio file descriptor. Setting this option enables the subprocess.send() method.\n// If the child is a Node.js process, the presence of an IPC channel will enable process.send() and process.disconnect() methods,\n// as well as 'disconnect' and 'message' events within the child.\n\n//------------------------------------------------------------------------------\n// Section 1. Exported child_process functions\n//------------------------------------------------------------------------------\n\n// TODO: Implement these props when Windows is supported\n// *   windowsVerbatimArguments?: boolean;\n// *   windowsHide?: boolean;\n\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nfunction spawnTimeoutFunction(child, timeoutHolder) {\n  var timeoutId = timeoutHolder.timeoutId;\n  if (timeoutId > -1) {\n    try {\n      child.kill(killSignal);\n    } catch (err) {\n      child.emit(\"error\", err);\n    }\n    timeoutHolder.timeoutId = -1;\n  }\n}\n/**\n * Spawns a new process using the given `file`.\n * @param {string} file\n * @param {string[]} [args]\n * @param {{\n *   cwd?: string;\n *   env?: Record<string, string>;\n *   argv0?: string;\n *   stdio?: Array | string;\n *   detached?: boolean;\n *   uid?: number;\n *   gid?: number;\n *   serialization?: string;\n *   shell?: boolean | string;\n *   signal?: AbortSignal;\n *   timeout?: number;\n *   killSignal?: string | number;\n *   }} [options]\n * @returns {ChildProcess}\n */\nexport function spawn(file, args, options) {\n  options = normalizeSpawnArguments(file, args, options);\n  validateTimeout(options.timeout);\n  validateAbortSignal(options.signal, \"options.signal\");\n  const killSignal = sanitizeKillSignal(options.killSignal);\n  const child = new ChildProcess();\n\n  debug(\"spawn\", options);\n  child.spawn(options);\n\n  if (options.timeout > 0) {\n    let timeoutId = setTimeout(() => {\n      if (timeoutId) {\n        try {\n          child.kill(killSignal);\n        } catch (err) {\n          child.emit(\"error\", err);\n        }\n        timeoutId = null;\n      }\n    });\n\n    child.once(\"exit\", () => {\n      if (timeoutId) {\n        clearTimeout(timeoutId);\n        timeoutId = null;\n      }\n    });\n  }\n\n  if (options.signal) {\n    const signal = options.signal;\n    if (signal.aborted) {\n      process.nextTick(onAbortListener);\n    } else {\n      signal.addEventListener(\"abort\", onAbortListener, { once: true });\n      child.once(\"exit\", () => signal.removeEventListener(\"abort\", onAbortListener));\n    }\n\n    function onAbortListener() {\n      abortChildProcess(child, killSignal);\n    }\n  }\n  return child;\n}\n\n/**\n * Spawns the specified file as a shell.\n * @param {string} file\n * @param {string[]} [args]\n * @param {{\n *   cwd?: string;\n *   env?: Record<string, string>;\n *   encoding?: string;\n *   timeout?: number;\n *   maxBuffer?: number;\n *   killSignal?: string | number;\n *   uid?: number;\n *   gid?: number;\n *   windowsHide?: boolean;\n *   windowsVerbatimArguments?: boolean;\n *   shell?: boolean | string;\n *   signal?: AbortSignal;\n *   }} [options]\n * @param {(\n *   error?: Error,\n *   stdout?: string | Buffer,\n *   stderr?: string | Buffer\n *   ) => any} [callback]\n * @returns {ChildProcess}\n */\nexport function execFile(file, args, options, callback) {\n  ({ file, args, options, callback } = normalizeExecFileArgs(file, args, options, callback));\n\n  options = {\n    encoding: \"utf8\",\n    timeout: 0,\n    maxBuffer: MAX_BUFFER,\n    killSignal: \"SIGTERM\",\n    cwd: null,\n    env: null,\n    shell: false,\n    ...options,\n  };\n\n  const maxBuffer = options.maxBuffer;\n\n  // Validate the timeout, if present.\n  validateTimeout(options.timeout);\n\n  // Validate maxBuffer, if present.\n  validateMaxBuffer(maxBuffer);\n\n  options.killSignal = sanitizeKillSignal(options.killSignal);\n\n  const child = spawn(file, args, {\n    cwd: options.cwd,\n    env: options.env,\n    // gid: options.gid,\n    shell: options.shell,\n    signal: options.signal,\n    // uid: options.uid,\n  });\n\n  let encoding;\n  const _stdout = [];\n  const _stderr = [];\n  if (options.encoding !== \"buffer\" && BufferIsEncoding(options.encoding)) {\n    encoding = options.encoding;\n  } else {\n    encoding = null;\n  }\n  let stdoutLen = 0;\n  let stderrLen = 0;\n  let killed = false;\n  let exited = false;\n  let timeoutId;\n  let encodedStdoutLen;\n  let encodedStderrLen;\n\n  let ex = null;\n\n  let cmd = file;\n\n  function exitHandler(code, signal) {\n    if (exited) return;\n    exited = true;\n\n    if (timeoutId) {\n      clearTimeout(timeoutId);\n      timeoutId = null;\n    }\n\n    if (!callback) return;\n\n    const readableEncoding = child?.stdout?.readableEncoding;\n    // merge chunks\n    let stdout;\n    let stderr;\n    if (encoding || (child.stdout && readableEncoding)) {\n      stdout = ArrayPrototypeJoin.call(_stdout, \"\");\n    } else {\n      stdout = BufferConcat(_stdout);\n    }\n    if (encoding || (child.stderr && readableEncoding)) {\n      stderr = ArrayPrototypeJoin.call(_stderr, \"\");\n    } else {\n      stderr = BufferConcat(_stderr);\n    }\n\n    if (!ex && code === 0 && signal === null) {\n      callback(null, stdout, stderr);\n      return;\n    }\n\n    if (args?.length) cmd += ` ${ArrayPrototypeJoin.call(args, \" \")}`;\n    if (!ex) {\n      let message = `Command failed: ${cmd}`;\n      if (stderr) message += `\\n${stderr}`;\n      ex = genericNodeError(message, {\n        // code: code < 0 ? getSystemErrorName(code) : code, // TODO: Add getSystemErrorName\n        code: code,\n        killed: child.killed || killed,\n        signal: signal,\n      });\n    }\n\n    ex.cmd = cmd;\n    callback(ex, stdout, stderr);\n  }\n\n  function errorHandler(e) {\n    ex = e;\n\n    if (child.stdout) child.stdout.destroy();\n    if (child.stderr) child.stderr.destroy();\n\n    exitHandler();\n  }\n\n  function kill() {\n    if (child.stdout) child.stdout.destroy();\n    if (child.stderr) child.stderr.destroy();\n\n    killed = true;\n    try {\n      child.kill(options.killSignal);\n    } catch (e) {\n      ex = e;\n      exitHandler();\n    }\n  }\n\n  if (options.timeout > 0) {\n    timeoutId = setTimeout(function delayedKill() {\n      kill();\n      timeoutId = null;\n    }, options.timeout);\n  }\n\n  if (child.stdout) {\n    if (encoding) child.stdout.setEncoding(encoding);\n\n    child.stdout.on(\n      \"data\",\n      maxBuffer === Infinity\n        ? function onUnlimitedSizeBufferedData(chunk) {\n            ArrayPrototypePush.call(_stdout, chunk);\n          }\n        : encoding\n        ? function onChildStdoutEncoded(chunk) {\n            stdoutLen += chunk.length;\n\n            if (stdoutLen * 4 > maxBuffer) {\n              const encoding = child.stdout.readableEncoding;\n              const actualLen = Buffer.byteLength(chunk, encoding);\n              if (encodedStdoutLen === undefined) {\n                for (let i = 0; i < _stdout.length; i++) {\n                  encodedStdoutLen += Buffer.byteLength(_stdout[i], encoding);\n                }\n              } else {\n                encodedStdoutLen += actualLen;\n              }\n              const truncatedLen = maxBuffer - (encodedStdoutLen - actualLen);\n              ArrayPrototypePush.call(_stdout, StringPrototypeSlice.apply(chunk, 0, truncatedLen));\n\n              ex = new ERR_CHILD_PROCESS_STDIO_MAXBUFFER(\"stdout\");\n              kill();\n            } else {\n              ArrayPrototypePush.call(_stdout, chunk);\n            }\n          }\n        : function onChildStdoutRaw(chunk) {\n            stdoutLen += chunk.length;\n\n            if (stdoutLen > maxBuffer) {\n              const truncatedLen = maxBuffer - (stdoutLen - chunk.length);\n              ArrayPrototypePush.call(_stdout, chunk.slice(0, truncatedLen));\n\n              ex = new ERR_CHILD_PROCESS_STDIO_MAXBUFFER(\"stdout\");\n              kill();\n            } else {\n              ArrayPrototypePush.call(_stdout, chunk);\n            }\n          },\n    );\n  }\n\n  if (child.stderr) {\n    if (encoding) child.stderr.setEncoding(encoding);\n\n    child.stderr.on(\n      \"data\",\n      maxBuffer === Infinity\n        ? function onUnlimitedSizeBufferedData(chunk) {\n            ArrayPrototypePush.call(_stderr, chunk);\n          }\n        : encoding\n        ? function onChildStderrEncoded(chunk) {\n            stderrLen += chunk.length;\n\n            if (stderrLen * 4 > maxBuffer) {\n              const encoding = child.stderr.readableEncoding;\n              const actualLen = Buffer.byteLength(chunk, encoding);\n              if (encodedStderrLen === undefined) {\n                for (let i = 0; i < _stderr.length; i++) {\n                  encodedStderrLen += Buffer.byteLength(_stderr[i], encoding);\n                }\n              } else {\n                encodedStderrLen += actualLen;\n              }\n              const truncatedLen = maxBuffer - (encodedStderrLen - actualLen);\n              ArrayPrototypePush.call(_stderr, StringPrototypeSlice.call(chunk, 0, truncatedLen));\n\n              ex = new ERR_CHILD_PROCESS_STDIO_MAXBUFFER(\"stderr\");\n              kill();\n            } else {\n              ArrayPrototypePush.call(_stderr, chunk);\n            }\n          }\n        : function onChildStderrRaw(chunk) {\n            stderrLen += chunk.length;\n\n            if (stderrLen > maxBuffer) {\n              const truncatedLen = maxBuffer - (stderrLen - chunk.length);\n              ArrayPrototypePush.call(_stderr, StringPrototypeSlice.call(chunk, 0, truncatedLen));\n\n              ex = new ERR_CHILD_PROCESS_STDIO_MAXBUFFER(\"stderr\");\n              kill();\n            } else {\n              ArrayPrototypePush.call(_stderr, chunk);\n            }\n          },\n    );\n  }\n\n  child.addListener(\"close\", exitHandler);\n  child.addListener(\"error\", errorHandler);\n\n  return child;\n}\n\n/**\n * Spawns a shell executing the given command.\n * @param {string} command\n * @param {{\n *   cmd?: string;\n *   env?: Record<string, string>;\n *   encoding?: string;\n *   shell?: string;\n *   signal?: AbortSignal;\n *   timeout?: number;\n *   maxBuffer?: number;\n *   killSignal?: string | number;\n *   uid?: number;\n *   gid?: number;\n *   windowsHide?: boolean;\n *   }} [options]\n * @param {(\n *   error?: Error,\n *   stdout?: string | Buffer,\n *   stderr?: string | Buffer\n *   ) => any} [callback]\n * @returns {ChildProcess}\n */\nexport function exec(command, options, callback) {\n  const opts = normalizeExecArgs(command, options, callback);\n  return execFile(opts.file, opts.options, opts.callback);\n}\n\nconst customPromiseExecFunction = orig => {\n  return (...args) => {\n    let resolve;\n    let reject;\n    const promise = new Promise((res, rej) => {\n      resolve = res;\n      reject = rej;\n    });\n\n    promise.child = orig(...args, (err, stdout, stderr) => {\n      if (err !== null) {\n        err.stdout = stdout;\n        err.stderr = stderr;\n        reject(err);\n      } else {\n        resolve({ stdout, stderr });\n      }\n    });\n\n    return promise;\n  };\n};\n\nObjectDefineProperty(exec, promisify.custom, {\n  __proto__: null,\n  enumerable: false,\n  value: customPromiseExecFunction(exec),\n});\n\n/**\n * Spawns a new process synchronously using the given `file`.\n * @param {string} file\n * @param {string[]} [args]\n * @param {{\n *   cwd?: string;\n *   input?: string | Buffer | TypedArray | DataView;\n *   argv0?: string;\n *   stdio?: string | Array;\n *   env?: Record<string, string>;\n *   uid?: number;\n *   gid?: number;\n *   timeout?: number;\n *   killSignal?: string | number;\n *   maxBuffer?: number;\n *   encoding?: string;\n *   shell?: boolean | string;\n *   }} [options]\n * @returns {{\n *   pid: number;\n *   output: Array;\n *   stdout: Buffer | string;\n *   stderr: Buffer | string;\n *   status: number | null;\n *   signal: string | null;\n *   error: Error;\n *   }}\n */\nexport function spawnSync(file, args, options) {\n  options = {\n    maxBuffer: MAX_BUFFER,\n    ...normalizeSpawnArguments(file, args, options),\n  };\n\n  const maxBuffer = options.maxBuffer;\n  const encoding = options.encoding;\n\n  debug(\"spawnSync\", options);\n\n  // Validate the timeout, if present.\n  validateTimeout(options.timeout);\n\n  // Validate maxBuffer, if present.\n  validateMaxBuffer(maxBuffer);\n\n  // Validate and translate the kill signal, if present.\n  options.killSignal = sanitizeKillSignal(options.killSignal);\n\n  const stdio = options.stdio || \"pipe\";\n  const bunStdio = getBunStdioFromOptions(stdio);\n\n  var { input } = options;\n  if (input) {\n    if (ArrayBufferIsView(input)) {\n      bunStdio[0] = input;\n    } else if (typeof input === \"string\") {\n      bunStdio[0] = Buffer.from(input, encoding || \"utf8\");\n    } else {\n      throw new ERR_INVALID_ARG_TYPE(`options.stdio[0]`, [\"Buffer\", \"TypedArray\", \"DataView\", \"string\"], input);\n    }\n  }\n\n  const { stdout, stderr, success, exitCode } = Bun.spawnSync({\n    cmd: options.args,\n    env: options.env || undefined,\n    cwd: options.cwd || undefined,\n    stdin: bunStdio[0],\n    stdout: bunStdio[1],\n    stderr: bunStdio[2],\n  });\n\n  const result = {\n    signal: null,\n    status: exitCode,\n    output: [null, stdout, stderr],\n  };\n\n  if (stdout && encoding && encoding !== \"buffer\") {\n    result.output[1] = result.output[1]?.toString(encoding);\n  }\n\n  if (stderr && encoding && encoding !== \"buffer\") {\n    result.output[2] = result.output[2]?.toString(encoding);\n  }\n\n  result.stdout = result.output[1];\n  result.stderr = result.output[2];\n\n  if (!success) {\n    result.error = new SystemError(result.output[2], options.file, \"spawnSync\", -1, result.status);\n    result.error.spawnargs = ArrayPrototypeSlice.call(options.args, 1);\n  }\n\n  return result;\n}\n\n/**\n * Spawns a file as a shell synchronously.\n * @param {string} file\n * @param {string[]} [args]\n * @param {{\n *   cwd?: string;\n *   input?: string | Buffer | TypedArray | DataView;\n *   stdio?: string | Array;\n *   env?: Record<string, string>;\n *   uid?: number;\n *   gid?: number;\n *   timeout?: number;\n *   killSignal?: string | number;\n *   maxBuffer?: number;\n *   encoding?: string;\n *   windowsHide?: boolean;\n *   shell?: boolean | string;\n *   }} [options]\n * @returns {Buffer | string}\n */\nexport function execFileSync(file, args, options) {\n  ({ file, args, options } = normalizeExecFileArgs(file, args, options));\n\n  // const inheritStderr = !options.stdio;\n  const ret = spawnSync(file, args, options);\n\n  // if (inheritStderr && ret.stderr) process.stderr.write(ret.stderr);\n\n  const errArgs = [options.argv0 || file];\n  ArrayPrototypePush.apply(errArgs, args);\n  const err = checkExecSyncError(ret, errArgs);\n\n  if (err) throw err;\n\n  return ret.stdout;\n}\n\n/**\n * Spawns a shell executing the given `command` synchronously.\n * @param {string} command\n * @param {{\n *   cwd?: string;\n *   input?: string | Buffer | TypedArray | DataView;\n *   stdio?: string | Array;\n *   env?: Record<string, string>;\n *   shell?: string;\n *   uid?: number;\n *   gid?: number;\n *   timeout?: number;\n *   killSignal?: string | number;\n *   maxBuffer?: number;\n *   encoding?: string;\n *   windowsHide?: boolean;\n *   }} [options]\n * @returns {Buffer | string}\n */\nexport function execSync(command, options) {\n  const opts = normalizeExecArgs(command, options, null);\n  // const inheritStderr = !opts.options.stdio;\n\n  const ret = spawnSync(opts.file, opts.options);\n\n  // if (inheritStderr && ret.stderr) process.stderr.write(ret.stderr); // TODO: Uncomment when we have process.stderr\n\n  const err = checkExecSyncError(ret, undefined, command);\n\n  if (err) throw err;\n\n  return ret.stdout;\n}\n\nexport function fork() {\n  throw new Error(\"Not implemented\");\n}\n\n//------------------------------------------------------------------------------\n// Section 2. child_process helpers\n//------------------------------------------------------------------------------\nfunction convertToValidSignal(signal) {\n  if (typeof signal === \"number\" && getSignalsToNamesMapping()[signal]) return signal;\n\n  if (typeof signal === \"string\") {\n    const signalName = signals[StringPrototypeToUpperCase.call(signal)];\n    if (signalName) return signalName;\n  }\n\n  throw new ERR_UNKNOWN_SIGNAL(signal);\n}\n\nfunction sanitizeKillSignal(killSignal) {\n  if (typeof killSignal === \"string\" || typeof killSignal === \"number\") {\n    return convertToValidSignal(killSignal);\n  } else if (killSignal != null) {\n    throw new ERR_INVALID_ARG_TYPE(\"options.killSignal\", [\"string\", \"number\"], killSignal);\n  }\n}\n\nlet signalsToNamesMapping;\nfunction getSignalsToNamesMapping() {\n  if (signalsToNamesMapping !== undefined) return signalsToNamesMapping;\n\n  signalsToNamesMapping = ObjectCreate(null);\n  for (const key in signals) {\n    signalsToNamesMapping[signals[key]] = key;\n  }\n\n  return signalsToNamesMapping;\n}\n\nfunction normalizeExecFileArgs(file, args, options, callback) {\n  if (ArrayIsArray(args)) {\n    args = ArrayPrototypeSlice.call(args);\n  } else if (args != null && typeof args === \"object\") {\n    callback = options;\n    options = args;\n    args = null;\n  } else if (typeof args === \"function\") {\n    callback = args;\n    options = null;\n    args = null;\n  }\n\n  if (args == null) {\n    args = [];\n  }\n\n  if (typeof options === \"function\") {\n    callback = options;\n  } else if (options != null) {\n    validateObject(options, \"options\");\n  }\n\n  if (options == null) {\n    options = kEmptyObject;\n  }\n\n  if (callback != null) {\n    validateFunction(callback, \"callback\");\n  }\n\n  // Validate argv0, if present.\n  if (options.argv0 != null) {\n    validateString(options.argv0, \"options.argv0\");\n    validateArgumentNullCheck(options.argv0, \"options.argv0\");\n  }\n\n  return { file, args, options, callback };\n}\n\nfunction normalizeExecArgs(command, options, callback) {\n  validateString(command, \"command\");\n  validateArgumentNullCheck(command, \"command\");\n\n  if (typeof options === \"function\") {\n    callback = options;\n    options = undefined;\n  }\n\n  // Make a shallow copy so we don't clobber the user's options object.\n  options = { ...options };\n  options.shell = typeof options.shell === \"string\" ? options.shell : true;\n\n  return {\n    file: command,\n    options: options,\n    callback: callback,\n  };\n}\n\nfunction normalizeSpawnArguments(file, args, options) {\n  validateString(file, \"file\");\n  validateArgumentNullCheck(file, \"file\");\n\n  if (file.length === 0) throw new ERR_INVALID_ARG_VALUE(\"file\", file, \"cannot be empty\");\n\n  if (ArrayIsArray(args)) {\n    args = ArrayPrototypeSlice.call(args);\n  } else if (args == null) {\n    args = [];\n  } else if (typeof args !== \"object\") {\n    throw new ERR_INVALID_ARG_TYPE(\"args\", \"object\", args);\n  } else {\n    options = args;\n    args = [];\n  }\n\n  validateArgumentsNullCheck(args, \"args\");\n\n  if (options === undefined) options = {};\n  else validateObject(options, \"options\");\n\n  let cwd = options.cwd;\n\n  // Validate the cwd, if present.\n  if (cwd != null) {\n    cwd = getValidatedPath(cwd, \"options.cwd\");\n  }\n\n  // TODO: Detached check\n  // TODO: Gid check\n  // TODO: Uid check\n\n  // Validate the shell, if present.\n  if (options.shell != null && typeof options.shell !== \"boolean\" && typeof options.shell !== \"string\") {\n    throw new ERR_INVALID_ARG_TYPE(\"options.shell\", [\"boolean\", \"string\"], options.shell);\n  }\n\n  // Validate argv0, if present.\n  if (options.argv0 != null) {\n    validateString(options.argv0, \"options.argv0\");\n    validateArgumentNullCheck(options.argv0, \"options.argv0\");\n  }\n\n  // TODO: Windows checks for Windows specific options\n\n  // Handle shell\n  if (options.shell) {\n    validateArgumentNullCheck(options.shell, \"options.shell\");\n    const command = ArrayPrototypeJoin.call([file, ...args], \" \");\n    // TODO: Windows moment\n    // Set the shell, switches, and commands.\n    // if (process.platform === \"win32\") {\n    //   if (typeof options.shell === \"string\") file = options.shell;\n    //   else file = process.env.comspec || \"cmd.exe\";\n    //   // '/d /s /c' is used only for cmd.exe.\n    //   if (RegExpPrototypeExec(/^(?:.*\\\\)?cmd(?:\\.exe)?$/i, file) !== null) {\n    //     args = [\"/d\", \"/s\", \"/c\", `\"${command}\"`];\n    //     windowsVerbatimArguments = true;\n    //   } else {\n    //     args = [\"-c\", command];\n    //   }\n    // } else {\n    if (typeof options.shell === \"string\") file = options.shell;\n    else if (process.platform === \"android\") file = \"sh\";\n    else file = \"sh\";\n    args = [\"-c\", command];\n    // }\n  }\n\n  // Handle argv0\n  if (typeof options.argv0 === \"string\") {\n    ArrayPrototypeUnshift.call(args, options.argv0);\n  } else {\n    ArrayPrototypeUnshift.call(args, file);\n  }\n\n  const env = options.env || process.env;\n  const envPairs = env;\n\n  // // process.env.NODE_V8_COVERAGE always propagates, making it possible to\n  // // collect coverage for programs that spawn with white-listed environment.\n  // copyProcessEnvToEnv(env, \"NODE_V8_COVERAGE\", options.env);\n\n  // TODO: Windows env support here...\n\n  return { ...options, file, args, cwd, envPairs };\n}\n\nfunction checkExecSyncError(ret, args, cmd) {\n  let err;\n  if (ret.error) {\n    err = ret.error;\n    ObjectAssign(err, ret);\n  } else if (ret.status !== 0) {\n    let msg = \"Command failed: \";\n    msg += cmd || ArrayPrototypeJoin.call(args, \" \");\n    if (ret.stderr && ret.stderr.length > 0) msg += `\\n${ret.stderr.toString()}`;\n    err = genericNodeError(msg, ret);\n  }\n  return err;\n}\n\n//------------------------------------------------------------------------------\n// Section 3. ChildProcess class\n//------------------------------------------------------------------------------\nexport class ChildProcess extends EventEmitter {\n  #handle;\n  #exited = false;\n  #closesNeeded = 1;\n  #closesGot = 0;\n\n  connected = false;\n  signalCode = null;\n  exitCode = null;\n  spawnfile;\n  spawnargs;\n  pid;\n  channel;\n\n  get killed() {\n    if (this.#handle == null) return false;\n  }\n\n  // constructor(options) {\n  //   super(options);\n  //   this.#handle[owner_symbol] = this;\n  // }\n\n  #handleOnExit(exitCode, signalCode, err) {\n    if (this.#exited) return;\n    this.exitCode = this.#handle.exitCode;\n    this.signalCode = exitCode > 0 ? signalCode : null;\n\n    if (this.#stdin) {\n      this.#stdin.destroy();\n    }\n\n    if (this.#handle) {\n      this.#handle = null;\n    }\n\n    if (exitCode < 0) {\n      const err = new SystemError(\n        `Spawned process exited with error code: ${exitCode}`,\n        undefined,\n        \"spawn\",\n        \"EUNKNOWN\",\n        \"ERR_CHILD_PROCESS_UNKNOWN_ERROR\",\n      );\n\n      if (this.spawnfile) err.path = this.spawnfile;\n\n      err.spawnargs = ArrayPrototypeSlice.call(this.spawnargs, 1);\n      this.emit(\"error\", err);\n    } else {\n      this.emit(\"exit\", this.exitCode, this.signalCode);\n    }\n\n    // If any of the stdio streams have not been touched,\n    // then pull all the data through so that it can get the\n    // eof and emit a 'close' event.\n    // Do it on nextTick so that the user has one last chance\n    // to consume the output, if for example they only want to\n    // start reading the data once the process exits.\n    process.nextTick(flushStdio, this);\n\n    this.#maybeClose();\n    this.#exited = true;\n    this.#stdioOptions = [\"destroyed\", \"destroyed\", \"destroyed\"];\n  }\n\n  #getBunSpawnIo(i, encoding) {\n    if (__DEBUG__ && !this.#handle) {\n      if (this.#handle === null) {\n        debug(\"ChildProcess: getBunSpawnIo: this.#handle is null. This means the subprocess already exited\");\n      } else {\n        debug(\"ChildProcess: getBunSpawnIo: this.#handle is undefined\");\n      }\n    }\n    const io = this.#stdioOptions[i];\n    switch (i) {\n      case 0: {\n        switch (io) {\n          case \"pipe\":\n            return new NativeWritable(this.#handle.stdin);\n          case \"inherit\":\n            return process.stdin || null;\n          case \"destroyed\":\n            return new ShimmedStdin();\n          default:\n            return null;\n        }\n      }\n      case 2:\n      case 1: {\n        switch (io) {\n          case \"pipe\":\n            return ReadableFromWeb(\n              this.#handle[fdToStdioName(i)],\n              __TRACK_STDIO__\n                ? {\n                    encoding,\n                    __id: `PARENT_${fdToStdioName(i).toUpperCase()}-${globalThis.__getId()}`,\n                  }\n                : { encoding },\n            );\n          case \"inherit\":\n            return process[fdToStdioName(i)] || null;\n          case \"destroyed\":\n            return new ShimmedStdioOutStream();\n          default:\n            return null;\n        }\n      }\n    }\n  }\n\n  #stdin;\n  #stdout;\n  #stderr;\n  #stdioObject;\n  #encoding;\n  #stdioOptions;\n\n  #createStdioObject() {\n    return Object.create(null, {\n      0: {\n        get: () => this.stdin,\n      },\n      1: {\n        get: () => this.stdout,\n      },\n      2: {\n        get: () => this.stderr,\n      },\n    });\n  }\n\n  get stdin() {\n    return (this.#stdin ??= this.#getBunSpawnIo(0, this.#encoding));\n  }\n\n  get stdout() {\n    return (this.#stdout ??= this.#getBunSpawnIo(1, this.#encoding));\n  }\n\n  get stderr() {\n    return (this.#stderr ??= this.#getBunSpawnIo(2, this.#encoding));\n  }\n\n  get stdio() {\n    return (this.#stdioObject ??= this.#createStdioObject());\n  }\n\n  spawn(options) {\n    validateObject(options, \"options\");\n\n    // validateOneOf(options.serialization, \"options.serialization\", [\n    //   undefined,\n    //   \"json\",\n    //   // \"advanced\", // TODO\n    // ]);\n    // const serialization = options.serialization || \"json\";\n\n    // if (ipc !== undefined) {\n    //   // Let child process know about opened IPC channel\n    //   if (options.envPairs === undefined) options.envPairs = [];\n    //   else validateArray(options.envPairs, \"options.envPairs\");\n\n    //   ArrayPrototypePush.call(options.envPairs, `NODE_CHANNEL_FD=${ipcFd}`);\n    //   ArrayPrototypePush.call(\n    //     options.envPairs,\n    //     `NODE_CHANNEL_SERIALIZATION_MODE=${serialization}`\n    //   );\n    // }\n\n    validateString(options.file, \"options.file\");\n    // NOTE: This is confusing... So node allows you to pass a file name\n    // But also allows you to pass a command in the args and it should execute\n    // To add another layer of confusion, they also give the option to pass an explicit \"argv0\"\n    // which overrides the actual command of the spawned process...\n    var file;\n    file = this.spawnfile = options.file;\n\n    var spawnargs;\n    if (options.args == null) {\n      spawnargs = this.spawnargs = [];\n    } else {\n      validateArray(options.args, \"options.args\");\n      spawnargs = this.spawnargs = options.args;\n    }\n\n    const stdio = options.stdio || [\"pipe\", \"pipe\", \"pipe\"];\n    const bunStdio = getBunStdioFromOptions(stdio);\n\n    var env = options.envPairs || undefined;\n\n    this.#encoding = options.encoding || undefined;\n    this.#stdioOptions = bunStdio;\n    this.#handle = Bun.spawn({\n      cmd: spawnargs,\n      stdin: bunStdio[0],\n      stdout: bunStdio[1],\n      stderr: bunStdio[2],\n      cwd: options.cwd || undefined,\n      env: env || process.env,\n      onExit: (handle, exitCode, signalCode, err) => {\n        this.#handle = handle;\n        this.pid = this.#handle.pid;\n\n        process.nextTick(\n          (exitCode, signalCode, err) => this.#handleOnExit(exitCode, signalCode, err),\n          exitCode,\n          signalCode,\n          err,\n        );\n      },\n      lazy: true,\n    });\n    this.pid = this.#handle.pid;\n\n    onSpawnNT(this);\n\n    // const ipc = stdio.ipc;\n    // const ipcFd = stdio.ipcFd;\n    // stdio = options.stdio = stdio.stdio;\n\n    // for (i = 0; i < stdio.length; i++) {\n    //   const stream = stdio[i];\n    //   if (stream.type === \"ignore\") continue;\n\n    //   if (stream.ipc) {\n    //     this._closesNeeded++;\n    //     continue;\n    //   }\n\n    //   // The stream is already cloned and piped, thus stop its readable side,\n    //   // otherwise we might attempt to read from the stream when at the same time\n    //   // the child process does.\n    //   if (stream.type === \"wrap\") {\n    //     stream.handle.reading = false;\n    //     stream.handle.readStop();\n    //     stream._stdio.pause();\n    //     stream._stdio.readableFlowing = false;\n    //     stream._stdio._readableState.reading = false;\n    //     stream._stdio[kIsUsedAsStdio] = true;\n    //     continue;\n    //   }\n\n    //   if (stream.handle) {\n    //     stream.socket = createSocket(\n    //       this.pid !== 0 ? stream.handle : null,\n    //       i > 0\n    //     );\n\n    // // Add .send() method and start listening for IPC data\n    // if (ipc !== undefined) setupChannel(this, ipc, serialization);\n  }\n\n  send() {\n    console.log(\"ChildProcess.prototype.send() - Sorry! Not implemented yet\");\n  }\n\n  disconnect() {\n    console.log(\"ChildProcess.prototype.disconnect() - Sorry! Not implemented yet\");\n  }\n\n  kill(sig) {\n    const signal = sig === 0 ? sig : convertToValidSignal(sig === undefined ? \"SIGTERM\" : sig);\n\n    if (this.#handle) {\n      this.#handle.kill(signal);\n    }\n\n    this.#maybeClose();\n\n    // TODO: Figure out how to make this conform to the Node spec...\n    // The problem is that the handle does not report killed until the process exits\n    // So we can't return whether or not the process was killed because Bun.spawn seems to handle this async instead of sync like Node does\n    // return this.#handle?.killed ?? true;\n    return true;\n  }\n\n  #maybeClose() {\n    debug(\"Attempting to maybe close...\");\n    this.#closesGot++;\n    if (this.#closesGot === this.#closesNeeded) {\n      this.emit(\"close\", this.exitCode, this.signalCode);\n    }\n  }\n\n  ref() {\n    if (this.#handle) this.#handle.ref();\n  }\n\n  unref() {\n    if (this.#handle) this.#handle.unref();\n  }\n}\n\n//------------------------------------------------------------------------------\n// Section 4. ChildProcess helpers\n//------------------------------------------------------------------------------\nconst nodeToBunLookup = {\n  ignore: null,\n  pipe: \"pipe\",\n  overlapped: \"pipe\", // TODO: this may need to work differently for Windows\n  inherit: \"inherit\",\n};\n\nfunction nodeToBun(item) {\n  // If inherit and we are referencing stdin/stdout/stderr index,\n  // we can get the fd from the ReadStream for the corresponding stdio\n  if (typeof item === \"number\") {\n    return item;\n  } else {\n    const result = nodeToBunLookup[item];\n    if (result === undefined) throw new Error(\"Invalid stdio option\");\n    return result;\n  }\n}\n\nfunction fdToStdioName(fd) {\n  switch (fd) {\n    case 0:\n      return \"stdin\";\n    case 1:\n      return \"stdout\";\n    case 2:\n      return \"stderr\";\n    default:\n      return null;\n  }\n}\n\nfunction getBunStdioFromOptions(stdio) {\n  const normalizedStdio = normalizeStdio(stdio);\n  // Node options:\n  // pipe: just a pipe\n  // ipc = can only be one in array\n  // overlapped -- same as pipe on Unix based systems\n  // inherit -- 'inherit': equivalent to ['inherit', 'inherit', 'inherit'] or [0, 1, 2]\n  // ignore -- > /dev/null, more or less same as null option for Bun.spawn stdio\n  // TODO: Stream -- use this stream\n  // number -- used as FD\n  // null, undefined: Use default value. Not same as ignore, which is Bun.spawn null.\n  // null/undefined: For stdio fds 0, 1, and 2 (in other words, stdin, stdout, and stderr) a pipe is created. For fd 3 and up, the default is 'ignore'\n\n  // Important Bun options\n  // pipe\n  // fd\n  // null - no stdin/stdout/stderr\n\n  // Translations: node -> bun\n  // pipe -> pipe\n  // overlapped -> pipe\n  // ignore -> null\n  // inherit -> inherit (stdin/stdout/stderr)\n  // Stream -> throw err for now\n  const bunStdio = normalizedStdio.map(item => nodeToBun(item));\n  return bunStdio;\n}\n\nfunction normalizeStdio(stdio) {\n  if (typeof stdio === \"string\") {\n    switch (stdio) {\n      case \"ignore\":\n        return [\"ignore\", \"ignore\", \"ignore\"];\n      case \"pipe\":\n        return [\"pipe\", \"pipe\", \"pipe\"];\n      case \"inherit\":\n        return [\"inherit\", \"inherit\", \"inherit\"];\n      default:\n        throw new ERR_INVALID_OPT_VALUE(\"stdio\", stdio);\n    }\n  } else if (ArrayIsArray(stdio)) {\n    // Validate if each is a valid stdio type\n    // TODO: Support wrapped types here\n\n    let processedStdio;\n    if (stdio.length === 0) processedStdio = [\"pipe\", \"pipe\", \"pipe\"];\n    else if (stdio.length === 1) processedStdio = [stdio[0], \"pipe\", \"pipe\"];\n    else if (stdio.length === 2) processedStdio = [stdio[0], stdio[1], \"pipe\"];\n    else if (stdio.length >= 3) processedStdio = [stdio[0], stdio[1], stdio[2]];\n\n    return processedStdio.map(item => (!item ? \"pipe\" : item));\n  } else {\n    throw new ERR_INVALID_OPT_VALUE(\"stdio\", stdio);\n  }\n}\n\nfunction flushStdio(subprocess) {\n  const stdio = subprocess.stdio;\n  if (stdio == null) return;\n\n  for (let i = 0; i < stdio.length; i++) {\n    const stream = stdio[i];\n    // TODO(addaleax): This doesn't necessarily account for all the ways in\n    // which data can be read from a stream, e.g. being consumed on the\n    // native layer directly as a StreamBase.\n    if (!stream || !stream.readable) {\n      continue;\n    }\n    stream.resume();\n  }\n}\n\nfunction onSpawnNT(self) {\n  self.emit(\"spawn\");\n}\n\nfunction abortChildProcess(child, killSignal) {\n  if (!child) return;\n  try {\n    if (child.kill(killSignal)) {\n      child.emit(\"error\", new AbortError());\n    }\n  } catch (err) {\n    child.emit(\"error\", err);\n  }\n}\n\nclass ShimmedStdin extends EventEmitter {\n  constructor() {\n    super();\n  }\n  write() {\n    return false;\n  }\n  destroy() {}\n  end() {}\n  pipe() {}\n}\n\nclass ShimmedStdioOutStream extends EventEmitter {\n  pipe() {}\n}\n\n//------------------------------------------------------------------------------\n// Section 5. Validators\n//------------------------------------------------------------------------------\n\nfunction validateMaxBuffer(maxBuffer) {\n  if (maxBuffer != null && !(typeof maxBuffer === \"number\" && maxBuffer >= 0)) {\n    throw new ERR_OUT_OF_RANGE(\"options.maxBuffer\", \"a positive number\", maxBuffer);\n  }\n}\n\nfunction validateArgumentNullCheck(arg, propName) {\n  if (typeof arg === \"string\" && StringPrototypeIncludes.call(arg, \"\\u0000\")) {\n    throw new ERR_INVALID_ARG_VALUE(propName, arg, \"must be a string without null bytes\");\n  }\n}\n\nfunction validateArgumentsNullCheck(args, propName) {\n  for (let i = 0; i < args.length; ++i) {\n    validateArgumentNullCheck(args[i], `${propName}[${i}]`);\n  }\n}\n\nfunction validateTimeout(timeout) {\n  if (timeout != null && !(NumberIsInteger(timeout) && timeout >= 0)) {\n    throw new ERR_OUT_OF_RANGE(\"timeout\", \"an unsigned integer\", timeout);\n  }\n}\n\nfunction validateBoolean(value, name) {\n  if (typeof value !== \"boolean\") throw new ERR_INVALID_ARG_TYPE(name, \"boolean\", value);\n}\n\n/**\n * @callback validateFunction\n * @param {*} value\n * @param {string} name\n * @returns {asserts value is Function}\n */\n\n/** @type {validateFunction} */\nfunction validateFunction(value, name) {\n  if (typeof value !== \"function\") throw new ERR_INVALID_ARG_TYPE(name, \"Function\", value);\n}\n\n/**\n * @callback validateAbortSignal\n * @param {*} signal\n * @param {string} name\n */\n\n/** @type {validateAbortSignal} */\nconst validateAbortSignal = (signal, name) => {\n  if (signal !== undefined && (signal === null || typeof signal !== \"object\" || !(\"aborted\" in signal))) {\n    throw new ERR_INVALID_ARG_TYPE(name, \"AbortSignal\", signal);\n  }\n};\n\n/**\n * @callback validateOneOf\n * @template T\n * @param {T} value\n * @param {string} name\n * @param {T[]} oneOf\n */\n\n/** @type {validateOneOf} */\nconst validateOneOf = (value, name, oneOf) => {\n  // const validateOneOf = hideStackFrames((value, name, oneOf) => {\n  if (!ArrayPrototypeIncludes.call(oneOf, value)) {\n    const allowed = ArrayPrototypeJoin.call(\n      ArrayPrototypeMap.call(oneOf, v => (typeof v === \"string\" ? `'${v}'` : String(v))),\n      \", \",\n    );\n    const reason = \"must be one of: \" + allowed;\n    throw new ERR_INVALID_ARG_VALUE(name, value, reason);\n  }\n};\n\n/**\n * @callback validateObject\n * @param {*} value\n * @param {string} name\n * @param {{\n *   allowArray?: boolean,\n *   allowFunction?: boolean,\n *   nullable?: boolean\n * }} [options]\n */\n\n/** @type {validateObject} */\nconst validateObject = (value, name, options = null) => {\n  // const validateObject = hideStackFrames((value, name, options = null) => {\n  const allowArray = options?.allowArray ?? false;\n  const allowFunction = options?.allowFunction ?? false;\n  const nullable = options?.nullable ?? false;\n  if (\n    (!nullable && value === null) ||\n    (!allowArray && ArrayIsArray.call(value)) ||\n    (typeof value !== \"object\" && (!allowFunction || typeof value !== \"function\"))\n  ) {\n    throw new ERR_INVALID_ARG_TYPE(name, \"object\", value);\n  }\n};\n\n/**\n * @callback validateArray\n * @param {*} value\n * @param {string} name\n * @param {number} [minLength]\n * @returns {asserts value is any[]}\n */\n\n/** @type {validateArray} */\nconst validateArray = (value, name, minLength = 0) => {\n  // const validateArray = hideStackFrames((value, name, minLength = 0) => {\n  if (!ArrayIsArray(value)) {\n    throw new ERR_INVALID_ARG_TYPE(name, \"Array\", value);\n  }\n  if (value.length < minLength) {\n    const reason = `must be longer than ${minLength}`;\n    throw new ERR_INVALID_ARG_VALUE(name, value, reason);\n  }\n};\n\n/**\n * @callback validateString\n * @param {*} value\n * @param {string} name\n * @returns {asserts value is string}\n */\n\n/** @type {validateString} */\nfunction validateString(value, name) {\n  if (typeof value !== \"string\") throw new ERR_INVALID_ARG_TYPE(name, \"string\", value);\n}\n\nfunction nullCheck(path, propName, throwError = true) {\n  const pathIsString = typeof path === \"string\";\n  const pathIsUint8Array = isUint8Array(path);\n\n  // We can only perform meaningful checks on strings and Uint8Arrays.\n  if (\n    (!pathIsString && !pathIsUint8Array) ||\n    (pathIsString && !StringPrototypeIncludes.call(path, \"\\u0000\")) ||\n    (pathIsUint8Array && !Uint8ArrayPrototypeIncludes.call(path, 0))\n  ) {\n    return;\n  }\n\n  const err = new ERR_INVALID_ARG_VALUE(propName, path, \"must be a string or Uint8Array without null bytes\");\n  if (throwError) {\n    throw err;\n  }\n  return err;\n}\n\nfunction validatePath(path, propName = \"path\") {\n  if (typeof path !== \"string\" && !isUint8Array(path)) {\n    throw new ERR_INVALID_ARG_TYPE(propName, [\"string\", \"Buffer\", \"URL\"], path);\n  }\n\n  const err = nullCheck(path, propName, false);\n\n  if (err !== undefined) {\n    throw err;\n  }\n}\n\nfunction getValidatedPath(fileURLOrPath, propName = \"path\") {\n  const path = toPathIfFileURL(fileURLOrPath);\n  validatePath(path, propName);\n  return path;\n}\n\nfunction isUint8Array(value) {\n  return typeof value === \"object\" && value !== null && value instanceof Uint8Array;\n}\n\n//------------------------------------------------------------------------------\n// Section 6. Random utilities\n//------------------------------------------------------------------------------\n\nfunction isURLInstance(fileURLOrPath) {\n  return fileURLOrPath != null && fileURLOrPath.href && fileURLOrPath.origin;\n}\n\nfunction toPathIfFileURL(fileURLOrPath) {\n  if (!isURLInstance(fileURLOrPath)) return fileURLOrPath;\n  return Bun.fileURLToPath(fileURLOrPath);\n}\n\n//------------------------------------------------------------------------------\n// Section 7. Node errors / error polyfills\n//------------------------------------------------------------------------------\nvar Error = globalThis.Error;\nvar TypeError = globalThis.TypeError;\nvar RangeError = globalThis.RangeError;\n\n// Node uses a slightly different abort error than standard DOM. See: https://github.com/nodejs/node/blob/main/lib/internal/errors.js\nclass AbortError extends Error {\n  code = \"ABORT_ERR\";\n  name = \"AbortError\";\n  constructor(message = \"The operation was aborted\", options = undefined) {\n    if (options !== undefined && typeof options !== \"object\") {\n      throw new ERR_INVALID_ARG_TYPE(\"options\", \"Object\", options);\n    }\n    super(message, options);\n  }\n}\n\nfunction genericNodeError(message, options) {\n  const err = new Error(message);\n  err.code = options.code;\n  err.killed = options.killed;\n  err.signal = options.signal;\n  return err;\n}\n\n// const messages = new Map();\n\n// Utility function for registering the error codes. Only used here. Exported\n// *only* to allow for testing.\n// function E(sym, val, def) {\n//   messages.set(sym, val);\n//   def = makeNodeErrorWithCode(def, sym);\n//   errorCodes[sym] = def;\n// }\n\n// function makeNodeErrorWithCode(Base, key) {\n//   return function NodeError(...args) {\n//     // const limit = Error.stackTraceLimit;\n//     // if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = 0;\n//     const error = new Base();\n//     // Reset the limit and setting the name property.\n//     // if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = limit;\n//     const message = getMessage(key, args);\n//     error.message = message;\n//     // captureLargerStackTrace(error);\n//     error.code = key;\n//     return error;\n//   };\n// }\n\n// function getMessage(key, args) {\n//   const msgFn = messages.get(key);\n//   if (args.length !== msgFn.length)\n//     throw new Error(\n//       `Invalid number of args for error message ${key}. Got ${args.length}, expected ${msgFn.length}.`\n//     );\n//   return msgFn(...args);\n// }\n\n// E(\n//   \"ERR_INVALID_ARG_TYPE\",\n//   (name, expected, actual) => {\n//     assert(typeof name === \"string\", \"'name' must be a string\");\n//     if (!ArrayIsArray(expected)) {\n//       expected = [expected];\n//     }\n\n//     let msg = \"The \";\n//     if (StringPrototypeEndsWith(name, \" argument\")) {\n//       // For cases like 'first argument'\n//       msg += `${name} `;\n//     } else {\n//       const type = StringPrototypeIncludes(name, \".\") ? \"property\" : \"argument\";\n//       msg += `\"${name}\" ${type} `;\n//     }\n//     msg += \"must be \";\n\n//     const types = [];\n//     const instances = [];\n//     const other = [];\n\n//     for (const value of expected) {\n//       assert(\n//         typeof value === \"string\",\n//         \"All expected entries have to be of type string\"\n//       );\n//       if (ArrayPrototypeIncludes.call(kTypes, value)) {\n//         ArrayPrototypePush(types, StringPrototypeToLowerCase(value));\n//       } else if (RegExpPrototypeExec(classRegExp, value) !== null) {\n//         ArrayPrototypePush(instances, value);\n//       } else {\n//         assert(\n//           value !== \"object\",\n//           'The value \"object\" should be written as \"Object\"'\n//         );\n//         ArrayPrototypePush(other, value);\n//       }\n//     }\n\n//     // Special handle `object` in case other instances are allowed to outline\n//     // the differences between each other.\n//     if (instances.length > 0) {\n//       const pos = ArrayPrototypeIndexOf(types, \"object\");\n//       if (pos !== -1) {\n//         ArrayPrototypeSplice.call(types, pos, 1);\n//         ArrayPrototypePush.call(instances, \"Object\");\n//       }\n//     }\n\n//     if (types.length > 0) {\n//       if (types.length > 2) {\n//         const last = ArrayPrototypePop(types);\n//         msg += `one of type ${ArrayPrototypeJoin(types, \", \")}, or ${last}`;\n//       } else if (types.length === 2) {\n//         msg += `one of type ${types[0]} or ${types[1]}`;\n//       } else {\n//         msg += `of type ${types[0]}`;\n//       }\n//       if (instances.length > 0 || other.length > 0) msg += \" or \";\n//     }\n\n//     if (instances.length > 0) {\n//       if (instances.length > 2) {\n//         const last = ArrayPrototypePop(instances);\n//         msg += `an instance of ${ArrayPrototypeJoin(\n//           instances,\n//           \", \"\n//         )}, or ${last}`;\n//       } else {\n//         msg += `an instance of ${instances[0]}`;\n//         if (instances.length === 2) {\n//           msg += ` or ${instances[1]}`;\n//         }\n//       }\n//       if (other.length > 0) msg += \" or \";\n//     }\n\n//     if (other.length > 0) {\n//       if (other.length > 2) {\n//         const last = ArrayPrototypePop(other);\n//         msg += `one of ${ArrayPrototypeJoin.call(other, \", \")}, or ${last}`;\n//       } else if (other.length === 2) {\n//         msg += `one of ${other[0]} or ${other[1]}`;\n//       } else {\n//         if (StringPrototypeToLowerCase(other[0]) !== other[0]) msg += \"an \";\n//         msg += `${other[0]}`;\n//       }\n//     }\n\n//     msg += `. Received ${determineSpecificType(actual)}`;\n\n//     return msg;\n//   },\n//   TypeError\n// );\n\nfunction ERR_OUT_OF_RANGE(str, range, input, replaceDefaultBoolean = false) {\n  // Node implementation:\n  // assert(range, 'Missing \"range\" argument');\n  // let msg = replaceDefaultBoolean\n  //   ? str\n  //   : `The value of \"${str}\" is out of range.`;\n  // let received;\n  // if (NumberIsInteger(input) && MathAbs(input) > 2 ** 32) {\n  //   received = addNumericalSeparator(String(input));\n  // } else if (typeof input === \"bigint\") {\n  //   received = String(input);\n  //   if (input > 2n ** 32n || input < -(2n ** 32n)) {\n  //     received = addNumericalSeparator(received);\n  //   }\n  //   received += \"n\";\n  // } else {\n  //   received = lazyInternalUtilInspect().inspect(input);\n  // }\n  // msg += ` It must be ${range}. Received ${received}`;\n  // return new RangeError(msg);\n  return new RangeError(`The value of ${str} is out of range. It must be ${range}. Received ${input}`);\n}\n\nfunction ERR_CHILD_PROCESS_STDIO_MAXBUFFER(stdio) {\n  return Error(`${stdio} maxBuffer length exceeded`);\n}\n\nfunction ERR_UNKNOWN_SIGNAL(name) {\n  const err = new TypeError(`Unknown signal: ${name}`);\n  err.code = \"ERR_UNKNOWN_SIGNAL\";\n  return err;\n}\n\nfunction ERR_INVALID_ARG_TYPE(name, type, value) {\n  const err = new TypeError(`The \"${name}\" argument must be of type ${type}. Received ${value}`);\n  err.code = \"ERR_INVALID_ARG_TYPE\";\n  return err;\n}\n\nfunction ERR_INVALID_OPT_VALUE(name, value) {\n  return new TypeError(`The value \"${value}\" is invalid for option \"${name}\"`);\n}\n\nfunction ERR_INVALID_ARG_VALUE(name, value, reason) {\n  return new Error(`The value \"${value}\" is invalid for argument '${name}'. Reason: ${reason}`);\n}\n\nclass SystemError extends Error {\n  path;\n  syscall;\n  errno;\n  code;\n  constructor(message, path, syscall, errno, code) {\n    super(message);\n    this.path = path;\n    this.syscall = syscall;\n    this.errno = errno;\n    this.code = code;\n  }\n\n  get name() {\n    return \"SystemError\";\n  }\n}\n\nexport default {\n  ChildProcess,\n  spawn,\n  execFile,\n  exec,\n  fork,\n  spawnSync,\n  execFileSync,\n  execSync,\n\n  [Symbol.for(\"CommonJS\")]: 0,\n};\n"
  ],
  "mappings": "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",
  "debugId": "92CBE603A3C13D0664756e2164756e21",
  "names": []
}