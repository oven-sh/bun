{
  "version": 3,
  "sources": ["src/js/node/net.js"],
  "sourcesContent": [
    "// Hardcoded module \"node:net\"\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// IPv4 Segment\nconst v4Seg = \"(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\";\nconst v4Str = `(${v4Seg}[.]){3}${v4Seg}`;\nconst IPv4Reg = new RegExp(`^${v4Str}$`);\n\n// IPv6 Segment\nconst v6Seg = \"(?:[0-9a-fA-F]{1,4})\";\nconst IPv6Reg = new RegExp(\n  \"^(\" +\n    `(?:${v6Seg}:){7}(?:${v6Seg}|:)|` +\n    `(?:${v6Seg}:){6}(?:${v4Str}|:${v6Seg}|:)|` +\n    `(?:${v6Seg}:){5}(?::${v4Str}|(:${v6Seg}){1,2}|:)|` +\n    `(?:${v6Seg}:){4}(?:(:${v6Seg}){0,1}:${v4Str}|(:${v6Seg}){1,3}|:)|` +\n    `(?:${v6Seg}:){3}(?:(:${v6Seg}){0,2}:${v4Str}|(:${v6Seg}){1,4}|:)|` +\n    `(?:${v6Seg}:){2}(?:(:${v6Seg}){0,3}:${v4Str}|(:${v6Seg}){1,5}|:)|` +\n    `(?:${v6Seg}:){1}(?:(:${v6Seg}){0,4}:${v4Str}|(:${v6Seg}){1,6}|:)|` +\n    `(?::((?::${v6Seg}){0,5}:${v4Str}|(?::${v6Seg}){1,7}|:))` +\n    \")(%[0-9a-zA-Z-.:]{1,})?$\",\n);\n\nfunction isIPv4(s) {\n  return IPv4Reg.test(s);\n}\n\nfunction isIPv6(s) {\n  return IPv6Reg.test(s);\n}\n\nfunction isIP(s) {\n  if (isIPv4(s)) return 4;\n  if (isIPv6(s)) return 6;\n  return 0;\n}\n\nconst { Bun, createFIFO, Object } = import.meta.primordials;\nconst { connect: bunConnect } = Bun;\nconst { Duplex } = import.meta.require(\"node:stream\");\nconst { EventEmitter } = import.meta.require(\"node:events\");\nvar { setTimeout } = globalThis;\n\nconst bunTlsSymbol = Symbol.for(\"::buntls::\");\nconst bunSocketServerHandlers = Symbol.for(\"::bunsocket_serverhandlers::\");\nconst bunSocketServerConnections = Symbol.for(\"::bunnetserverconnections::\");\nconst bunSocketServerOptions = Symbol.for(\"::bunnetserveroptions::\");\n\nvar SocketClass;\nconst Socket = (function (InternalSocket) {\n  SocketClass = InternalSocket;\n  Object.defineProperty(SocketClass.prototype, Symbol.toStringTag, {\n    value: \"Socket\",\n    enumerable: false,\n  });\n\n  return Object.defineProperty(\n    function Socket(options) {\n      return new InternalSocket(options);\n    },\n    Symbol.hasInstance,\n    {\n      value(instance) {\n        return instance instanceof InternalSocket;\n      },\n    },\n  );\n})(\n  class Socket extends Duplex {\n    static #Handlers = {\n      close: Socket.#Close,\n      connectError(socket, error) {\n        const self = socket.data;\n\n        self.emit(\"error\", error);\n      },\n      data({ data: self }, buffer) {\n        self.bytesRead += buffer.length;\n        const queue = self.#readQueue;\n\n        if (queue.isEmpty()) {\n          if (self.push(buffer)) return;\n        }\n        queue.push(buffer);\n      },\n      drain: Socket.#Drain,\n      end: Socket.#Close,\n      error(socket, error) {\n        const self = socket.data;\n        const callback = self.#writeCallback;\n        if (callback) {\n          self.#writeCallback = null;\n          callback(error);\n        }\n        self.emit(\"error\", error);\n      },\n      open(socket) {\n        const self = socket.data;\n        socket.timeout(self.timeout);\n        socket.ref();\n        self.#socket = socket;\n        self.connecting = false;\n        self.emit(\"connect\", self);\n        Socket.#Drain(socket);\n      },\n      handshake(socket, success, verifyError) {\n        const { data: self } = socket;\n        self._securePending = false;\n        self.secureConnecting = false;\n        self._secureEstablished = !!success;\n\n        // Needs getPeerCertificate support (not implemented yet)\n        // if (!verifyError && !this.isSessionReused()) {\n        //   const hostname = options.servername ||\n        //                  options.host ||\n        //                  (options.socket && options.socket._host) ||\n        //                  'localhost';\n        //   const cert = this.getPeerCertificate(true);\n        //   verifyError = options.checkServerIdentity(hostname, cert);\n        // }\n\n        if (self._requestCert || self._rejectUnauthorized) {\n          if (verifyError) {\n            self.authorized = false;\n            self.authorizationError = verifyError.code || verifyError.message;\n            if (self._rejectUnauthorized) {\n              self.destroy(verifyError);\n              return;\n            }\n          }\n        } else {\n          self.authorized = true;\n        }\n        self.emit(\"secureConnect\", verifyError);\n      },\n      timeout(socket) {\n        const self = socket.data;\n        self.emit(\"timeout\", self);\n      },\n      binaryType: \"buffer\",\n    };\n\n    static #Close(socket) {\n      const self = socket.data;\n      if (self.#closed) return;\n      self.#closed = true;\n      //socket cannot be used after close\n      self.#socket = null;\n      const queue = self.#readQueue;\n      if (queue.isEmpty()) {\n        if (self.push(null)) return;\n      }\n      queue.push(null);\n    }\n\n    static #Drain(socket) {\n      const self = socket.data;\n\n      const callback = self.#writeCallback;\n      if (callback) {\n        const chunk = self.#writeChunk;\n        const written = socket.write(chunk);\n\n        self.bytesWritten += written;\n        if (written < chunk.length) {\n          self.#writeChunk = chunk.slice(written);\n        } else {\n          self.#writeCallback = null;\n          self.#writeChunk = null;\n          callback(null);\n        }\n      }\n    }\n\n    static [bunSocketServerHandlers] = {\n      data: Socket.#Handlers.data,\n      close(socket) {\n        Socket.#Handlers.close(socket);\n        this.data[bunSocketServerConnections]--;\n      },\n      end(socket) {\n        Socket.#Handlers.end(socket);\n        this.data[bunSocketServerConnections]--;\n      },\n      open(socket) {\n        const self = this.data;\n        const options = self[bunSocketServerOptions];\n        const { pauseOnConnect, connectionListener, InternalSocketClass, requestCert, rejectUnauthorized } = options;\n        const _socket = new InternalSocketClass({});\n        _socket.isServer = true;\n        _socket._requestCert = requestCert;\n        _socket._rejectUnauthorized = rejectUnauthorized;\n\n        _socket.#attach(this.localPort, socket);\n        if (self.maxConnections && self[bunSocketServerConnections] >= self.maxConnections) {\n          const data = {\n            localAddress: _socket.localAddress,\n            localPort: _socket.localPort,\n            localFamily: _socket.localFamily,\n            remoteAddress: _socket.remoteAddress,\n            remotePort: _socket.remotePort,\n            remoteFamily: _socket.remoteFamily || \"IPv4\",\n          };\n\n          socket.end();\n\n          self.emit(\"drop\", data);\n          return;\n        }\n        // the duplex implementation start paused, so we resume when pauseOnConnect is falsy\n        if (!pauseOnConnect) {\n          _socket.resume();\n        }\n\n        self[bunSocketServerConnections]++;\n\n        if (typeof connectionListener == \"function\") {\n          if (InternalSocketClass.name === \"TLSSocket\") {\n            // add secureConnection event handler\n            self.once(\"secureConnection\", () => connectionListener(_socket));\n          } else {\n            connectionListener(_socket);\n          }\n        }\n\n        self.emit(\"connection\", _socket);\n      },\n      handshake({ data: self }, success, verifyError) {\n        self._securePending = false;\n        self.secureConnecting = false;\n        self._secureEstablished = !!success;\n        // Needs getPeerCertificate support (not implemented yet)\n        // if (!verifyError && !this.isSessionReused()) {\n        //   const hostname = options.servername ||\n        //                  options.host ||\n        //                  (options.socket && options.socket._host) ||\n        //                  'localhost';\n        //   const cert = this.getPeerCertificate(true);\n        //   verifyError = options.checkServerIdentity(hostname, cert);\n        // }\n\n        if (self._requestCert || self._rejectUnauthorized) {\n          if (verifyError) {\n            self.authorized = false;\n            self.authorizationError = verifyError.code || verifyError.message;\n            if (self._rejectUnauthorized) {\n              self.destroy(verifyError);\n              return;\n            }\n          }\n        } else {\n          self.authorized = true;\n        }\n        self.emit(\"secureConnect\", verifyError);\n      },\n      error(socket, error) {\n        Socket.#Handlers.error(socket, error);\n        this.data.emit(\"error\", error);\n      },\n      timeout: Socket.#Handlers.timeout,\n      connectError: Socket.#Handlers.connectError,\n      drain: Socket.#Handlers.drain,\n      binaryType: \"buffer\",\n    };\n\n    bytesRead = 0;\n    bytesWritten = 0;\n    #closed = false;\n    connecting = false;\n    localAddress = \"127.0.0.1\";\n    #readQueue = createFIFO();\n    remotePort;\n    #socket;\n    timeout = 0;\n    #writeCallback;\n    #writeChunk;\n    #pendingRead;\n\n    isServer = false;\n\n    constructor(options) {\n      const { signal, write, read, allowHalfOpen = false, ...opts } = options || {};\n      super({\n        ...opts,\n        allowHalfOpen,\n        readable: true,\n        writable: true,\n      });\n      this.#pendingRead = undefined;\n      signal?.once(\"abort\", () => this.destroy());\n      this.once(\"connect\", () => this.emit(\"ready\"));\n    }\n\n    address() {\n      return {\n        address: this.localAddress,\n        family: this.localFamily,\n        port: this.localPort,\n      };\n    }\n\n    get bufferSize() {\n      return this.writableLength;\n    }\n\n    #attach(port, socket) {\n      this.remotePort = port;\n      socket.data = this;\n      socket.timeout(this.timeout);\n      socket.ref();\n      this.#socket = socket;\n      this.connecting = false;\n      this.emit(\"connect\", this);\n      Socket.#Drain(socket);\n    }\n\n    connect(port, host, connectListener) {\n      var path;\n      if (typeof port === \"string\") {\n        path = port;\n        port = undefined;\n\n        if (typeof host === \"function\") {\n          connectListener = host;\n          host = undefined;\n        }\n      } else if (typeof host == \"function\") {\n        if (typeof port === \"string\") {\n          path = port;\n          port = undefined;\n        }\n\n        connectListener = host;\n        host = undefined;\n      }\n      if (typeof port == \"object\") {\n        var {\n          port,\n          host,\n          path,\n          // TODOs\n          localAddress,\n          localPort,\n          family,\n          hints,\n          lookup,\n          noDelay,\n          keepAlive,\n          keepAliveInitialDelay,\n          requestCert,\n          rejectUnauthorized,\n          pauseOnConnect,\n          servername,\n        } = port;\n        this.servername = servername;\n      }\n\n      if (!pauseOnConnect) {\n        this.resume();\n      }\n      this.connecting = true;\n      this.remotePort = port;\n\n      const bunTLS = this[bunTlsSymbol];\n      var tls = undefined;\n\n      if (typeof bunTLS === \"function\") {\n        tls = bunTLS.call(this, port, host, true);\n        // Client always request Cert\n        this._requestCert = true;\n        this._rejectUnauthorized = rejectUnauthorized;\n\n        if (tls) {\n          // TLS can true/false or options\n          if (typeof tls !== \"object\") {\n            tls = {\n              rejectUnauthorized: rejectUnauthorized,\n              requestCert: true,\n            };\n          } else {\n            tls.rejectUnauthorized = rejectUnauthorized;\n            tls.requestCert = true;\n          }\n        }\n\n        this.authorized = false;\n        this.secureConnecting = true;\n        this._secureEstablished = false;\n        this._securePending = true;\n        if (connectListener) this.on(\"secureConnect\", connectListener);\n      } else if (connectListener) this.on(\"connect\", connectListener);\n      bunConnect(\n        path\n          ? {\n              data: this,\n              unix: path,\n              socket: Socket.#Handlers,\n              tls,\n            }\n          : {\n              data: this,\n              hostname: host || \"localhost\",\n              port: port,\n              socket: Socket.#Handlers,\n              tls,\n            },\n      );\n      return this;\n    }\n\n    _destroy(err, callback) {\n      this.#socket?.end();\n      callback(err);\n    }\n\n    _final(callback) {\n      this.#socket?.end();\n      callback();\n    }\n\n    get localAddress() {\n      return \"127.0.0.1\";\n    }\n\n    get localFamily() {\n      return \"IPv4\";\n    }\n\n    get localPort() {\n      return this.#socket?.localPort;\n    }\n\n    get pending() {\n      return this.connecting;\n    }\n\n    _read(size) {\n      const queue = this.#readQueue;\n      let chunk;\n      while ((chunk = queue.peek())) {\n        if (!this.push(chunk)) return;\n        queue.shift();\n      }\n    }\n\n    get readyState() {\n      if (this.connecting) return \"opening\";\n      if (this.readable) {\n        return this.writable ? \"open\" : \"readOnly\";\n      } else {\n        return this.writable ? \"writeOnly\" : \"closed\";\n      }\n    }\n\n    ref() {\n      this.#socket?.ref();\n    }\n\n    get remoteAddress() {\n      return this.#socket?.remoteAddress;\n    }\n\n    get remoteFamily() {\n      return \"IPv4\";\n    }\n\n    resetAndDestroy() {\n      this.#socket?.end();\n    }\n\n    setKeepAlive(enable = false, initialDelay = 0) {\n      // TODO\n      return this;\n    }\n\n    setNoDelay(noDelay = true) {\n      // TODO\n      return this;\n    }\n\n    setTimeout(timeout, callback) {\n      this.#socket?.timeout(timeout);\n      this.timeout = timeout;\n      if (callback) this.once(\"timeout\", callback);\n      return this;\n    }\n\n    unref() {\n      this.#socket?.unref();\n    }\n\n    _write(chunk, encoding, callback) {\n      if (typeof chunk == \"string\" && encoding !== \"utf8\") chunk = Buffer.from(chunk, encoding);\n      var written = this.#socket?.write(chunk);\n      if (written == chunk.length) {\n        callback();\n      } else if (this.#writeCallback) {\n        callback(new Error(\"overlapping _write()\"));\n      } else {\n        if (written > 0) {\n          if (typeof chunk == \"string\") {\n            chunk = chunk.slice(written);\n          } else {\n            chunk = chunk.subarray(written);\n          }\n        }\n\n        this.#writeCallback = callback;\n        this.#writeChunk = chunk;\n      }\n    }\n  },\n);\n\nfunction createConnection(port, host, connectListener) {\n  if (typeof port === \"object\") {\n    // port is option pass Socket options and let connect handle connection options\n    return new Socket(port).connect(port, host, connectListener);\n  }\n  // port is path or host, let connect handle this\n  return new Socket().connect(port, host, connectListener);\n}\n\nconst connect = createConnection;\n\nclass Server extends EventEmitter {\n  #server;\n  #listening = false;\n  [bunSocketServerConnections] = 0;\n  [bunSocketServerOptions];\n  maxConnections = 0;\n\n  constructor(options, connectionListener) {\n    super();\n\n    if (typeof options === \"function\") {\n      connectionListener = options;\n      options = {};\n    } else if (options == null || typeof options === \"object\") {\n      options = { ...options };\n    } else {\n      throw new Error(\"bun-net-polyfill: invalid arguments\");\n    }\n\n    const { maxConnections } = options;\n    this.maxConnections = Number.isSafeInteger(maxConnections) && maxConnections > 0 ? maxConnections : 0;\n\n    options.connectionListener = connectionListener;\n    this[bunSocketServerOptions] = options;\n  }\n\n  ref() {\n    this.#server?.ref();\n    return this;\n  }\n\n  unref() {\n    this.#server?.unref();\n    return this;\n  }\n\n  close(callback) {\n    if (this.#server) {\n      this.#server.stop(true);\n      this.#server = null;\n      this.#listening = false;\n      this[bunSocketServerConnections] = 0;\n      this.emit(\"close\");\n      if (typeof callback === \"function\") {\n        callback();\n      }\n\n      return this;\n    }\n\n    if (typeof callback === \"function\") {\n      const error = new Error(\"Server is not running\");\n      error.code = \"ERR_SERVER_NOT_RUNNING\";\n      callback(error);\n    }\n    return this;\n  }\n\n  address() {\n    const server = this.#server;\n    if (server) {\n      const unix = server.unix;\n      if (unix) {\n        return unix;\n      }\n\n      //TODO: fix adress when host is passed\n      let address = server.hostname;\n      const type = isIP(address);\n      const port = server.port;\n      if (typeof port === \"number\") {\n        return {\n          port,\n          address,\n          family: type ? `IPv${type}` : undefined,\n        };\n      }\n      if (type) {\n        return {\n          address,\n          family: type ? `IPv${type}` : undefined,\n        };\n      }\n\n      return address;\n    }\n    return null;\n  }\n\n  getConnections(callback) {\n    if (typeof callback === \"function\") {\n      //in Bun case we will never error on getConnections\n      //node only errors if in the middle of the couting the server got disconnected, what never happens in Bun\n      //if disconnected will only pass null as well and 0 connected\n      callback(null, this.#server ? this[bunSocketServerConnections] : 0);\n    }\n    return this;\n  }\n\n  listen(port, hostname, onListen) {\n    let backlog;\n    let path;\n    let exclusive = false;\n    //port is actually path\n    if (typeof port === \"string\") {\n      if (Number.isSafeInteger(hostname)) {\n        if (hostname > 0) {\n          //hostname is backlog\n          backlog = hostname;\n        }\n      } else if (typeof hostname === \"function\") {\n        //hostname is callback\n        onListen = hostname;\n      }\n\n      path = port;\n      hostname = undefined;\n      port = undefined;\n    } else {\n      if (typeof hostname === \"function\") {\n        onListen = hostname;\n        hostname = undefined;\n      }\n\n      if (typeof port === \"function\") {\n        onListen = port;\n        port = 0;\n      } else if (typeof port === \"object\") {\n        const options = port;\n        options.signal?.addEventListener(\"abort\", () => this.close());\n\n        hostname = options.host;\n        exclusive = options.exclusive === true;\n        const path = options.path;\n        port = options.port;\n\n        if (!Number.isSafeInteger(port) || port < 0) {\n          if (path) {\n            hostname = path;\n            port = undefined;\n          } else {\n            let message = 'The argument \\'options\\' must have the property \"port\" or \"path\"';\n            try {\n              message = `${message}. Received ${JSON.stringify(options)}`;\n            } catch {}\n\n            const error = new TypeError(message);\n            error.code = \"ERR_INVALID_ARG_VALUE\";\n            throw error;\n          }\n        } else if (!Number.isSafeInteger(port) || port < 0) {\n          port = 0;\n        }\n\n        // port <number>\n        // host <string>\n        // path <string> Will be ignored if port is specified. See Identifying paths for IPC connections.\n        // backlog <number> Common parameter of server.listen() functions.\n        // exclusive <boolean> Default: false\n        // readableAll <boolean> For IPC servers makes the pipe readable for all users. Default: false.\n        // writableAll <boolean> For IPC servers makes the pipe writable for all users. Default: false.\n        // ipv6Only <boolean> For TCP servers, setting ipv6Only to true will disable dual-stack support, i.e., binding to host :: won't make 0.0.0.0 be bound. Default: false.\n        // signal <AbortSignal> An AbortSignal that may be used to close a listening server.\n\n        if (typeof port.callback === \"function\") onListen = port?.callback;\n      } else if (!Number.isSafeInteger(port) || port < 0) {\n        port = 0;\n      }\n      hostname = hostname || \"::\";\n    }\n\n    try {\n      var tls = undefined;\n      var TLSSocketClass = undefined;\n      const bunTLS = this[bunTlsSymbol];\n      if (typeof bunTLS === \"function\") {\n        [tls, TLSSocketClass] = bunTLS.call(this, port, hostname, false);\n      }\n\n      this[bunSocketServerOptions].InternalSocketClass = TLSSocketClass || SocketClass;\n\n      this.#server = Bun.listen(\n        path\n          ? {\n              exclusive,\n              unix: path,\n              tls,\n              socket: SocketClass[bunSocketServerHandlers],\n            }\n          : {\n              exclusive,\n              port,\n              hostname,\n              tls,\n              socket: SocketClass[bunSocketServerHandlers],\n            },\n      );\n\n      //make this instance available on handlers\n      this.#server.data = this;\n\n      this.#listening = true;\n\n      // We must schedule the emitListeningNextTick() only after the next run of\n      // the event loop's IO queue. Otherwise, the server may not actually be listening\n      // when the 'listening' event is emitted.\n      //\n      // That leads to all sorts of confusion.\n      //\n      // process.nextTick() is not sufficient because it will run before the IO queue.\n      setTimeout(emitListeningNextTick, 1, this, onListen);\n    } catch (err) {\n      this.#listening = false;\n      setTimeout(emitErrorNextTick, 1, this, err);\n    }\n    return this;\n  }\n}\n\nfunction emitErrorNextTick(self, error) {\n  self.emit(\"error\", error);\n}\n\nfunction emitListeningNextTick(self, onListen) {\n  if (typeof onListen === \"function\") {\n    try {\n      onListen();\n    } catch (err) {\n      self.emit(\"error\", err);\n    }\n  }\n  self.emit(\"listening\");\n}\n\nfunction createServer(options, connectionListener) {\n  return new Server(options, connectionListener);\n}\n\nexport default {\n  createServer,\n  Server,\n  createConnection,\n  connect,\n  isIP,\n  isIPv4,\n  isIPv6,\n  Socket,\n  [Symbol.for(\"CommonJS\")]: 0,\n  [Symbol.for(\"::bunternal::\")]: SocketClass,\n};\n\nexport { createServer, Server, createConnection, connect, isIP, isIPv4, isIPv6, Socket };\n"
  ],
  "mappings": "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",
  "debugId": "206C298863DB15E864756e2164756e21",
  "names": []
}