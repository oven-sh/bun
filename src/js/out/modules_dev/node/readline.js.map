{
  "version": 3,
  "sources": ["src/js/node/readline.js", "src/js/node/readline.js", "src/js/node/readline.js", "src/js/node/readline.js", "src/js/node/readline.js"],
  "sourcesContent": [
    "// Hardcoded module \"node:readline\"\n// Attribution: Some parts of of this module are derived from code originating from the Node.js\n// readline module which is licensed under an MIT license:\n//\n// Copyright Node.js contributors. All rights reserved.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to\n// deal in the Software without restriction, including without limitation the\n// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n// sell copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n// IN THE SOFTWARE.\n\n// ----------------------------------------------------------------------------\n// Section: Imports\n// ----------------------------------------------------------------------------\nvar { Array, RegExp, String, Bun } = import.meta.primordials;\nvar EventEmitter = import.meta.require(\"node:events\");\nvar { clearTimeout, setTimeout } = import.meta.require(\"timers\");\nvar { StringDecoder } = import.meta.require(\"string_decoder\");\nvar isWritable;\n\nvar { inspect } = Bun;\nvar debug = process.env.BUN_JS_DEBUG ? console.log : () => {};\n\n// ----------------------------------------------------------------------------\n// Section: Preamble\n// ----------------------------------------------------------------------------\n\nvar SymbolAsyncIterator = Symbol.asyncIterator;\nvar SymbolIterator = Symbol.iterator;\nvar SymbolFor = Symbol.for;\nvar SymbolReplace = Symbol.replace;\nvar ArrayFrom = Array.from;\nvar ArrayIsArray = Array.isArray;\nvar ArrayPrototypeFilter = Array.prototype.filter;\nvar ArrayPrototypeSort = Array.prototype.sort;\nvar ArrayPrototypeIndexOf = Array.prototype.indexOf;\nvar ArrayPrototypeJoin = Array.prototype.join;\nvar ArrayPrototypeMap = Array.prototype.map;\nvar ArrayPrototypePop = Array.prototype.pop;\nvar ArrayPrototypePush = Array.prototype.push;\nvar ArrayPrototypeSlice = Array.prototype.slice;\nvar ArrayPrototypeSplice = Array.prototype.splice;\nvar ArrayPrototypeReverse = Array.prototype.reverse;\nvar ArrayPrototypeShift = Array.prototype.shift;\nvar ArrayPrototypeUnshift = Array.prototype.unshift;\nvar RegExpPrototypeExec = RegExp.prototype.exec;\nvar RegExpPrototypeSymbolReplace = RegExp.prototype[SymbolReplace];\nvar StringFromCharCode = String.fromCharCode;\nvar StringPrototypeCharCodeAt = String.prototype.charCodeAt;\nvar StringPrototypeCodePointAt = String.prototype.codePointAt;\nvar StringPrototypeSlice = String.prototype.slice;\nvar StringPrototypeToLowerCase = String.prototype.toLowerCase;\nvar StringPrototypeEndsWith = String.prototype.endsWith;\nvar StringPrototypeRepeat = String.prototype.repeat;\nvar StringPrototypeStartsWith = String.prototype.startsWith;\nvar StringPrototypeTrim = String.prototype.trim;\nvar StringPrototypeNormalize = String.prototype.normalize;\nvar NumberIsNaN = Number.isNaN;\nvar NumberIsFinite = Number.isFinite;\nvar NumberIsInteger = Number.isInteger;\nvar NumberMAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER;\nvar NumberMIN_SAFE_INTEGER = Number.MIN_SAFE_INTEGER;\nvar MathCeil = Math.ceil;\nvar MathFloor = Math.floor;\nvar MathMax = Math.max;\nvar MathMaxApply = Math.max.apply;\nvar DateNow = Date.now;\nvar FunctionPrototype = Function.prototype;\nvar StringPrototype = String.prototype;\nvar StringPrototypeSymbolIterator = StringPrototype[SymbolIterator];\nvar StringIteratorPrototypeNext = StringPrototypeSymbolIterator.call(\"\").next;\nvar ObjectSetPrototypeOf = Object.setPrototypeOf;\nvar ObjectDefineProperty = Object.defineProperty;\nvar ObjectDefineProperties = Object.defineProperties;\nvar ObjectFreeze = Object.freeze;\nvar ObjectAssign = Object.assign;\nvar ObjectCreate = Object.create;\nvar ObjectKeys = Object.keys;\nvar ObjectSeal = Object.seal;\n\nvar createSafeIterator = (factory, next) => {\n  class SafeIterator {\n    #iterator;\n    constructor(iterable) {\n      this.#iterator = factory.call(iterable);\n    }\n    next() {\n      return next.call(this.#iterator);\n    }\n    [SymbolIterator]() {\n      return this;\n    }\n  }\n  ObjectSetPrototypeOf(SafeIterator.prototype, null);\n  ObjectFreeze(SafeIterator.prototype);\n  ObjectFreeze(SafeIterator);\n  return SafeIterator;\n};\n\nvar SafeStringIterator = createSafeIterator(StringPrototypeSymbolIterator, StringIteratorPrototypeNext);\n\n// ----------------------------------------------------------------------------\n// Section: \"Internal\" modules\n// ----------------------------------------------------------------------------\n\n/**\n * Returns true if the character represented by a given\n * Unicode code point is full-width. Otherwise returns false.\n */\nvar isFullWidthCodePoint = code => {\n  // Code points are partially derived from:\n  // https://www.unicode.org/Public/UNIDATA/EastAsianWidth.txt\n  return (\n    code >= 0x1100 &&\n    (code <= 0x115f || // Hangul Jamo\n      code === 0x2329 || // LEFT-POINTING ANGLE BRACKET\n      code === 0x232a || // RIGHT-POINTING ANGLE BRACKET\n      // CJK Radicals Supplement .. Enclosed CJK Letters and Months\n      (code >= 0x2e80 && code <= 0x3247 && code !== 0x303f) ||\n      // Enclosed CJK Letters and Months .. CJK Unified Ideographs Extension A\n      (code >= 0x3250 && code <= 0x4dbf) ||\n      // CJK Unified Ideographs .. Yi Radicals\n      (code >= 0x4e00 && code <= 0xa4c6) ||\n      // Hangul Jamo Extended-A\n      (code >= 0xa960 && code <= 0xa97c) ||\n      // Hangul Syllables\n      (code >= 0xac00 && code <= 0xd7a3) ||\n      // CJK Compatibility Ideographs\n      (code >= 0xf900 && code <= 0xfaff) ||\n      // Vertical Forms\n      (code >= 0xfe10 && code <= 0xfe19) ||\n      // CJK Compatibility Forms .. Small Form Variants\n      (code >= 0xfe30 && code <= 0xfe6b) ||\n      // Halfwidth and Fullwidth Forms\n      (code >= 0xff01 && code <= 0xff60) ||\n      (code >= 0xffe0 && code <= 0xffe6) ||\n      // Kana Supplement\n      (code >= 0x1b000 && code <= 0x1b001) ||\n      // Enclosed Ideographic Supplement\n      (code >= 0x1f200 && code <= 0x1f251) ||\n      // Miscellaneous Symbols and Pictographs 0x1f300 - 0x1f5ff\n      // Emoticons 0x1f600 - 0x1f64f\n      (code >= 0x1f300 && code <= 0x1f64f) ||\n      // CJK Unified Ideographs Extension B .. Tertiary Ideographic Plane\n      (code >= 0x20000 && code <= 0x3fffd))\n  );\n};\n\nvar isZeroWidthCodePoint = code => {\n  return (\n    code <= 0x1f || // C0 control codes\n    (code >= 0x7f && code <= 0x9f) || // C1 control codes\n    (code >= 0x300 && code <= 0x36f) || // Combining Diacritical Marks\n    (code >= 0x200b && code <= 0x200f) || // Modifying Invisible Characters\n    // Combining Diacritical Marks for Symbols\n    (code >= 0x20d0 && code <= 0x20ff) ||\n    (code >= 0xfe00 && code <= 0xfe0f) || // Variation Selectors\n    (code >= 0xfe20 && code <= 0xfe2f) || // Combining Half Marks\n    (code >= 0xe0100 && code <= 0xe01ef)\n  ); // Variation Selectors\n};\n\n/**\n * Returns the number of columns required to display the given string.\n */\nvar getStringWidth = function getStringWidth(str, removeControlChars = true) {\n  var width = 0;\n\n  if (removeControlChars) str = stripVTControlCharacters(str);\n  str = StringPrototypeNormalize.call(str, \"NFC\");\n  for (var char of new SafeStringIterator(str)) {\n    var code = StringPrototypeCodePointAt.call(char, 0);\n    if (isFullWidthCodePoint(code)) {\n      width += 2;\n    } else if (!isZeroWidthCodePoint(code)) {\n      width++;\n    }\n  }\n\n  return width;\n};\n\n// Regex used for ansi escape code splitting\n// Adopted from https://github.com/chalk/ansi-regex/blob/HEAD/index.js\n// License: MIT, authors: @sindresorhus, Qix-, arjunmehta and LitoMore\n// Matches all ansi escape code sequences in a string\nvar ansiPattern =\n  \"[\\\\u001B\\\\u009B][[\\\\]()#;?]*\" +\n  \"(?:(?:(?:(?:;[-a-zA-Z\\\\d\\\\/#&.:=?%@~_]+)*\" +\n  \"|[a-zA-Z\\\\d]+(?:;[-a-zA-Z\\\\d\\\\/#&.:=?%@~_]*)*)?\\\\u0007)\" +\n  \"|(?:(?:\\\\d{1,4}(?:;\\\\d{0,4})*)?[\\\\dA-PR-TZcf-ntqry=><~]))\";\nvar ansi = new RegExp(ansiPattern, \"g\");\n\n/**\n * Remove all VT control characters. Use to estimate displayed string width.\n */\nfunction stripVTControlCharacters(str) {\n  validateString(str, \"str\");\n  return RegExpPrototypeSymbolReplace.call(ansi, str, \"\");\n}\n\n// Promisify\n\nvar kCustomPromisifiedSymbol = SymbolFor(\"nodejs.util.promisify.custom\");\nvar kCustomPromisifyArgsSymbol = Symbol(\"customPromisifyArgs\");\n\nfunction promisify(original) {\n  validateFunction(original, \"original\");\n\n  if (original[kCustomPromisifiedSymbol]) {\n    var fn = original[kCustomPromisifiedSymbol];\n\n    validateFunction(fn, \"util.promisify.custom\");\n\n    return ObjectDefineProperty(fn, kCustomPromisifiedSymbol, {\n      __proto__: null,\n      value: fn,\n      enumerable: false,\n      writable: false,\n      configurable: true,\n    });\n  }\n\n  // Names to create an object from in case the callback receives multiple\n  // arguments, e.g. ['bytesRead', 'buffer'] for fs.read.\n  var argumentNames = original[kCustomPromisifyArgsSymbol];\n\n  function fn(...args) {\n    return new Promise((resolve, reject) => {\n      ArrayPrototypePush.call(args, (err, ...values) => {\n        if (err) {\n          return reject(err);\n        }\n        if (argumentNames !== undefined && values.length > 1) {\n          var obj = {};\n          for (var i = 0; i < argumentNames.length; i++) obj[argumentNames[i]] = values[i];\n          resolve(obj);\n        } else {\n          resolve(values[0]);\n        }\n      });\n      ReflectApply(original, this, args);\n    });\n  }\n\n  ObjectSetPrototypeOf(fn, ObjectGetPrototypeOf(original));\n\n  ObjectDefineProperty(fn, kCustomPromisifiedSymbol, {\n    __proto__: null,\n    value: fn,\n    enumerable: false,\n    writable: false,\n    configurable: true,\n  });\n\n  var descriptors = ObjectGetOwnPropertyDescriptors(original);\n  var propertiesValues = ObjectValues(descriptors);\n  for (var i = 0; i < propertiesValues.length; i++) {\n    // We want to use null-prototype objects to not rely on globally mutable\n    // %Object.prototype%.\n    ObjectSetPrototypeOf(propertiesValues[i], null);\n  }\n  return ObjectDefineProperties(fn, descriptors);\n}\n\npromisify.custom = kCustomPromisifiedSymbol;\n\n// Constants\n\nvar kUTF16SurrogateThreshold = 0x10000; // 2 ** 16\nvar kEscape = \"\\x1b\";\nvar kSubstringSearch = Symbol(\"kSubstringSearch\");\n\nvar kIsNodeError = Symbol(\"kIsNodeError\");\n\n// Errors\nvar errorBases = {};\nvar VALID_NODE_ERROR_BASES = {\n  TypeError,\n  RangeError,\n  Error,\n};\n\nfunction getNodeErrorByName(typeName) {\n  var base = errorBases[typeName];\n  if (base) {\n    return base;\n  }\n  if (!ObjectKeys(VALID_NODE_ERROR_BASES).includes(typeName)) {\n    throw new Error(\"Invalid NodeError type\");\n  }\n\n  var Base = VALID_NODE_ERROR_BASES[typeName];\n\n  class NodeError extends Base {\n    [kIsNodeError] = true;\n    code;\n    constructor(msg, opts) {\n      super(msg, opts);\n      this.code = opts?.code || \"ERR_GENERIC\";\n    }\n\n    toString() {\n      return `${this.name} [${this.code}]: ${this.message}`;\n    }\n  }\n  errorBases[typeName] = NodeError;\n  return NodeError;\n}\n\nvar NodeError = getNodeErrorByName(\"Error\");\nvar NodeTypeError = getNodeErrorByName(\"TypeError\");\nvar NodeRangeError = getNodeErrorByName(\"RangeError\");\n\nclass ERR_INVALID_ARG_TYPE extends NodeTypeError {\n  constructor(name, type, value) {\n    super(`The \"${name}\" argument must be of type ${type}. Received type ${typeof value}`, {\n      code: \"ERR_INVALID_ARG_TYPE\",\n    });\n  }\n}\n\nclass ERR_INVALID_ARG_VALUE extends NodeTypeError {\n  constructor(name, value, reason = \"not specified\") {\n    super(`The value \"${String(value)}\" is invalid for argument '${name}'. Reason: ${reason}`, {\n      code: \"ERR_INVALID_ARG_VALUE\",\n    });\n  }\n}\n\nclass ERR_INVALID_CURSOR_POS extends NodeTypeError {\n  constructor() {\n    super(\"Cannot set cursor row without setting its column\", {\n      code: \"ERR_INVALID_CURSOR_POS\",\n    });\n  }\n}\n\nclass ERR_OUT_OF_RANGE extends NodeRangeError {\n  constructor(name, range, received) {\n    super(`The value of \"${name}\" is out of range. It must be ${range}. Received ${received}`, {\n      code: \"ERR_OUT_OF_RANGE\",\n    });\n  }\n}\n\nclass ERR_USE_AFTER_CLOSE extends NodeError {\n  constructor() {\n    super(\"This socket has been ended by the other party\", {\n      code: \"ERR_USE_AFTER_CLOSE\",\n    });\n  }\n}\n\nclass AbortError extends Error {\n  code;\n  constructor() {\n    super(\"The operation was aborted\");\n    this.code = \"ABORT_ERR\";\n  }\n}\n\n// Validators\n\n/**\n * @callback validateFunction\n * @param {*} value\n * @param {string} name\n * @returns {asserts value is Function}\n */\nfunction validateFunction(value, name) {\n  if (typeof value !== \"function\") throw new ERR_INVALID_ARG_TYPE(name, \"Function\", value);\n}\n\n/**\n * @callback validateAbortSignal\n * @param {*} signal\n * @param {string} name\n */\nfunction validateAbortSignal(signal, name) {\n  if (signal !== undefined && (signal === null || typeof signal !== \"object\" || !(\"aborted\" in signal))) {\n    throw new ERR_INVALID_ARG_TYPE(name, \"AbortSignal\", signal);\n  }\n}\n\n/**\n * @callback validateArray\n * @param {*} value\n * @param {string} name\n * @param {number} [minLength]\n * @returns {asserts value is any[]}\n */\nfunction validateArray(value, name, minLength = 0) {\n  // var validateArray = hideStackFrames((value, name, minLength = 0) => {\n  if (!ArrayIsArray(value)) {\n    throw new ERR_INVALID_ARG_TYPE(name, \"Array\", value);\n  }\n  if (value.length < minLength) {\n    var reason = `must be longer than ${minLength}`;\n    throw new ERR_INVALID_ARG_VALUE(name, value, reason);\n  }\n}\n\n/**\n * @callback validateString\n * @param {*} value\n * @param {string} name\n * @returns {asserts value is string}\n */\nfunction validateString(value, name) {\n  if (typeof value !== \"string\") throw new ERR_INVALID_ARG_TYPE(name, \"string\", value);\n}\n\n/**\n * @callback validateBoolean\n * @param {*} value\n * @param {string} name\n * @returns {asserts value is boolean}\n */\nfunction validateBoolean(value, name) {\n  if (typeof value !== \"boolean\") throw new ERR_INVALID_ARG_TYPE(name, \"boolean\", value);\n}\n\n/**\n * @callback validateObject\n * @param {*} value\n * @param {string} name\n * @param {{\n *   allowArray?: boolean,\n *   allowFunction?: boolean,\n *   nullable?: boolean\n * }} [options]\n */\nfunction validateObject(value, name, options = null) {\n  // var validateObject = hideStackFrames((value, name, options = null) => {\n  var allowArray = options?.allowArray ?? false;\n  var allowFunction = options?.allowFunction ?? false;\n  var nullable = options?.nullable ?? false;\n  if (\n    (!nullable && value === null) ||\n    (!allowArray && ArrayIsArray.call(value)) ||\n    (typeof value !== \"object\" && (!allowFunction || typeof value !== \"function\"))\n  ) {\n    throw new ERR_INVALID_ARG_TYPE(name, \"object\", value);\n  }\n}\n\n/**\n * @callback validateInteger\n * @param {*} value\n * @param {string} name\n * @param {number} [min]\n * @param {number} [max]\n * @returns {asserts value is number}\n */\nfunction validateInteger(value, name, min = NumberMIN_SAFE_INTEGER, max = NumberMAX_SAFE_INTEGER) {\n  if (typeof value !== \"number\") throw new ERR_INVALID_ARG_TYPE(name, \"number\", value);\n  if (!NumberIsInteger(value)) throw new ERR_OUT_OF_RANGE(name, \"an integer\", value);\n  if (value < min || value > max) throw new ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value);\n}\n\n/**\n * @callback validateUint32\n * @param {*} value\n * @param {string} name\n * @param {number|boolean} [positive=false]\n * @returns {asserts value is number}\n */\nfunction validateUint32(value, name, positive = false) {\n  if (typeof value !== \"number\") {\n    throw new ERR_INVALID_ARG_TYPE(name, \"number\", value);\n  }\n\n  if (!NumberIsInteger(value)) {\n    throw new ERR_OUT_OF_RANGE(name, \"an integer\", value);\n  }\n\n  var min = positive ? 1 : 0; // 2 ** 32 === 4294967296\n  var max = 4_294_967_295;\n\n  if (value < min || value > max) {\n    throw new ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value);\n  }\n}\n\n// ----------------------------------------------------------------------------\n// Section: Utils\n// ----------------------------------------------------------------------------\n\nfunction CSI(strings, ...args) {\n  var ret = `${kEscape}[`;\n  for (var n = 0; n < strings.length; n++) {\n    ret += strings[n];\n    if (n < args.length) ret += args[n];\n  }\n  return ret;\n}\n\nvar kClearLine, kClearScreenDown, kClearToLineBeginning, kClearToLineEnd;\n\nCSI.kEscape = kEscape;\nCSI.kClearLine = kClearLine = CSI`2K`;\nCSI.kClearScreenDown = kClearScreenDown = CSI`0J`;\nCSI.kClearToLineBeginning = kClearToLineBeginning = CSI`1K`;\nCSI.kClearToLineEnd = kClearToLineEnd = CSI`0K`;\n\nfunction charLengthLeft(str, i) {\n  if (i <= 0) return 0;\n  if (\n    (i > 1 && StringPrototypeCodePointAt.call(str, i - 2) >= kUTF16SurrogateThreshold) ||\n    StringPrototypeCodePointAt.call(str, i - 1) >= kUTF16SurrogateThreshold\n  ) {\n    return 2;\n  }\n  return 1;\n}\n\nfunction charLengthAt(str, i) {\n  if (str.length <= i) {\n    // Pretend to move to the right. This is necessary to autocomplete while\n    // moving to the right.\n    return 1;\n  }\n  return StringPrototypeCodePointAt.call(str, i) >= kUTF16SurrogateThreshold ? 2 : 1;\n}\n\n/*\n  Some patterns seen in terminal key escape codes, derived from combos seen\n  at http://www.midnight-commander.org/browser/lib/tty/key.c\n  ESC letter\n  ESC [ letter\n  ESC [ modifier letter\n  ESC [ 1 ; modifier letter\n  ESC [ num char\n  ESC [ num ; modifier char\n  ESC O letter\n  ESC O modifier letter\n  ESC O 1 ; modifier letter\n  ESC N letter\n  ESC [ [ num ; modifier char\n  ESC [ [ 1 ; modifier letter\n  ESC ESC [ num char\n  ESC ESC O letter\n  - char is usually ~ but $ and ^ also happen with rxvt\n  - modifier is 1 +\n                (shift     * 1) +\n                (left_alt  * 2) +\n                (ctrl      * 4) +\n                (right_alt * 8)\n  - two leading ESCs apparently mean the same as one leading ESC\n*/\nfunction* emitKeys(stream) {\n  while (true) {\n    var ch = yield;\n    var s = ch;\n    var escaped = false;\n\n    var keySeq = null;\n    var keyName;\n    var keyCtrl = false;\n    var keyMeta = false;\n    var keyShift = false;\n\n    // var key = {\n    //   sequence: null,\n    //   name: undefined,\n    //   ctrl: false,\n    //   meta: false,\n    //   shift: false,\n    // };\n\n    if (ch === kEscape) {\n      escaped = true;\n      s += ch = yield;\n\n      if (ch === kEscape) {\n        s += ch = yield;\n      }\n    }\n\n    if (escaped && (ch === \"O\" || ch === \"[\")) {\n      // ANSI escape sequence\n      var code = ch;\n      var modifier = 0;\n\n      if (ch === \"O\") {\n        // ESC O letter\n        // ESC O modifier letter\n        s += ch = yield;\n\n        if (ch >= \"0\" && ch <= \"9\") {\n          modifier = (ch >> 0) - 1;\n          s += ch = yield;\n        }\n\n        code += ch;\n      } else if (ch === \"[\") {\n        // ESC [ letter\n        // ESC [ modifier letter\n        // ESC [ [ modifier letter\n        // ESC [ [ num char\n        s += ch = yield;\n\n        if (ch === \"[\") {\n          // \\x1b[[A\n          //      ^--- escape codes might have a second bracket\n          code += ch;\n          s += ch = yield;\n        }\n\n        /*\n         * Here and later we try to buffer just enough data to get\n         * a complete ascii sequence.\n         *\n         * We have basically two classes of ascii characters to process:\n         *\n         *\n         * 1. `\\x1b[24;5~` should be parsed as { code: '[24~', modifier: 5 }\n         *\n         * This particular example is featuring Ctrl+F12 in xterm.\n         *\n         *  - `;5` part is optional, e.g. it could be `\\x1b[24~`\n         *  - first part can contain one or two digits\n         *\n         * So the generic regexp is like /^\\d\\d?(;\\d)?[~^$]$/\n         *\n         *\n         * 2. `\\x1b[1;5H` should be parsed as { code: '[H', modifier: 5 }\n         *\n         * This particular example is featuring Ctrl+Home in xterm.\n         *\n         *  - `1;5` part is optional, e.g. it could be `\\x1b[H`\n         *  - `1;` part is optional, e.g. it could be `\\x1b[5H`\n         *\n         * So the generic regexp is like /^((\\d;)?\\d)?[A-Za-z]$/\n         *\n         */\n        var cmdStart = s.length - 1;\n\n        // Skip one or two leading digits\n        if (ch >= \"0\" && ch <= \"9\") {\n          s += ch = yield;\n\n          if (ch >= \"0\" && ch <= \"9\") {\n            s += ch = yield;\n          }\n        }\n\n        // skip modifier\n        if (ch === \";\") {\n          s += ch = yield;\n\n          if (ch >= \"0\" && ch <= \"9\") {\n            s += yield;\n          }\n        }\n\n        /*\n         * We buffered enough data, now trying to extract code\n         * and modifier from it\n         */\n        var cmd = StringPrototypeSlice.call(s, cmdStart);\n        var match;\n\n        if ((match = RegExpPrototypeExec.call(/^(\\d\\d?)(;(\\d))?([~^$])$/, cmd))) {\n          code += match[1] + match[4];\n          modifier = (match[3] || 1) - 1;\n        } else if ((match = RegExpPrototypeExec.call(/^((\\d;)?(\\d))?([A-Za-z])$/, cmd))) {\n          code += match[4];\n          modifier = (match[3] || 1) - 1;\n        } else {\n          code += cmd;\n        }\n      }\n\n      // Parse the key modifier\n      keyCtrl = !!(modifier & 4);\n      keyMeta = !!(modifier & 10);\n      keyShift = !!(modifier & 1);\n      keyCode = code;\n\n      // Parse the key itself\n      switch (code) {\n        /* xterm/gnome ESC [ letter (with modifier) */\n        case \"[P\":\n          keyName = \"f1\";\n          break;\n        case \"[Q\":\n          keyName = \"f2\";\n          break;\n        case \"[R\":\n          keyName = \"f3\";\n          break;\n        case \"[S\":\n          keyName = \"f4\";\n          break;\n\n        /* xterm/gnome ESC O letter (without modifier) */\n        case \"OP\":\n          keyName = \"f1\";\n          break;\n        case \"OQ\":\n          keyName = \"f2\";\n          break;\n        case \"OR\":\n          keyName = \"f3\";\n          break;\n        case \"OS\":\n          keyName = \"f4\";\n          break;\n\n        /* xterm/rxvt ESC [ number ~ */\n        case \"[11~\":\n          keyName = \"f1\";\n          break;\n        case \"[12~\":\n          keyName = \"f2\";\n          break;\n        case \"[13~\":\n          keyName = \"f3\";\n          break;\n        case \"[14~\":\n          keyName = \"f4\";\n          break;\n\n        /* from Cygwin and used in libuv */\n        case \"[[A\":\n          keyName = \"f1\";\n          break;\n        case \"[[B\":\n          keyName = \"f2\";\n          break;\n        case \"[[C\":\n          keyName = \"f3\";\n          break;\n        case \"[[D\":\n          keyName = \"f4\";\n          break;\n        case \"[[E\":\n          keyName = \"f5\";\n          break;\n\n        /* common */\n        case \"[15~\":\n          keyName = \"f5\";\n          break;\n        case \"[17~\":\n          keyName = \"f6\";\n          break;\n        case \"[18~\":\n          keyName = \"f7\";\n          break;\n        case \"[19~\":\n          keyName = \"f8\";\n          break;\n        case \"[20~\":\n          keyName = \"f9\";\n          break;\n        case \"[21~\":\n          keyName = \"f10\";\n          break;\n        case \"[23~\":\n          keyName = \"f11\";\n          break;\n        case \"[24~\":\n          keyName = \"f12\";\n          break;\n\n        /* xterm ESC [ letter */\n        case \"[A\":\n          keyName = \"up\";\n          break;\n        case \"[B\":\n          keyName = \"down\";\n          break;\n        case \"[C\":\n          keyName = \"right\";\n          break;\n        case \"[D\":\n          keyName = \"left\";\n          break;\n        case \"[E\":\n          keyName = \"clear\";\n          break;\n        case \"[F\":\n          keyName = \"end\";\n          break;\n        case \"[H\":\n          keyName = \"home\";\n          break;\n\n        /* xterm/gnome ESC O letter */\n        case \"OA\":\n          keyName = \"up\";\n          break;\n        case \"OB\":\n          keyName = \"down\";\n          break;\n        case \"OC\":\n          keyName = \"right\";\n          break;\n        case \"OD\":\n          keyName = \"left\";\n          break;\n        case \"OE\":\n          keyName = \"clear\";\n          break;\n        case \"OF\":\n          keyName = \"end\";\n          break;\n        case \"OH\":\n          keyName = \"home\";\n          break;\n\n        /* xterm/rxvt ESC [ number ~ */\n        case \"[1~\":\n          keyName = \"home\";\n          break;\n        case \"[2~\":\n          keyName = \"insert\";\n          break;\n        case \"[3~\":\n          keyName = \"delete\";\n          break;\n        case \"[4~\":\n          keyName = \"end\";\n          break;\n        case \"[5~\":\n          keyName = \"pageup\";\n          break;\n        case \"[6~\":\n          keyName = \"pagedown\";\n          break;\n\n        /* putty */\n        case \"[[5~\":\n          keyName = \"pageup\";\n          break;\n        case \"[[6~\":\n          keyName = \"pagedown\";\n          break;\n\n        /* rxvt */\n        case \"[7~\":\n          keyName = \"home\";\n          break;\n        case \"[8~\":\n          keyName = \"end\";\n          break;\n\n        /* rxvt keys with modifiers */\n        case \"[a\":\n          keyName = \"up\";\n          keyShift = true;\n          break;\n        case \"[b\":\n          keyName = \"down\";\n          keyShift = true;\n          break;\n        case \"[c\":\n          keyName = \"right\";\n          keyShift = true;\n          break;\n        case \"[d\":\n          keyName = \"left\";\n          keyShift = true;\n          break;\n        case \"[e\":\n          keyName = \"clear\";\n          keyShift = true;\n          break;\n\n        case \"[2$\":\n          keyName = \"insert\";\n          keyShift = true;\n          break;\n        case \"[3$\":\n          keyName = \"delete\";\n          keyShift = true;\n          break;\n        case \"[5$\":\n          keyName = \"pageup\";\n          keyShift = true;\n          break;\n        case \"[6$\":\n          keyName = \"pagedown\";\n          keyShift = true;\n          break;\n        case \"[7$\":\n          keyName = \"home\";\n          keyShift = true;\n          break;\n        case \"[8$\":\n          keyName = \"end\";\n          keyShift = true;\n          break;\n\n        case \"Oa\":\n          keyName = \"up\";\n          keyCtrl = true;\n          break;\n        case \"Ob\":\n          keyName = \"down\";\n          keyCtrl = true;\n          break;\n        case \"Oc\":\n          keyName = \"right\";\n          keyCtrl = true;\n          break;\n        case \"Od\":\n          keyName = \"left\";\n          keyCtrl = true;\n          break;\n        case \"Oe\":\n          keyName = \"clear\";\n          keyCtrl = true;\n          break;\n\n        case \"[2^\":\n          keyName = \"insert\";\n          keyCtrl = true;\n          break;\n        case \"[3^\":\n          keyName = \"delete\";\n          keyCtrl = true;\n          break;\n        case \"[5^\":\n          keyName = \"pageup\";\n          keyCtrl = true;\n          break;\n        case \"[6^\":\n          keyName = \"pagedown\";\n          keyCtrl = true;\n          break;\n        case \"[7^\":\n          keyName = \"home\";\n          keyCtrl = true;\n          break;\n        case \"[8^\":\n          keyName = \"end\";\n          keyCtrl = true;\n          break;\n\n        /* misc. */\n        case \"[Z\":\n          keyName = \"tab\";\n          keyShift = true;\n          break;\n        default:\n          keyName = \"undefined\";\n          break;\n      }\n    } else if (ch === \"\\r\") {\n      // carriage return\n      keyName = \"return\";\n      keyMeta = escaped;\n    } else if (ch === \"\\n\") {\n      // Enter, should have been called linefeed\n      keyName = \"enter\";\n      keyMeta = escaped;\n    } else if (ch === \"\\t\") {\n      // tab\n      keyName = \"tab\";\n      keyMeta = escaped;\n    } else if (ch === \"\\b\" || ch === \"\\x7f\") {\n      // backspace or ctrl+h\n      keyName = \"backspace\";\n      keyMeta = escaped;\n    } else if (ch === kEscape) {\n      // escape key\n      keyName = \"escape\";\n      keyMeta = escaped;\n    } else if (ch === \" \") {\n      keyName = \"space\";\n      keyMeta = escaped;\n    } else if (!escaped && ch <= \"\\x1a\") {\n      // ctrl+letter\n      keyName = StringFromCharCode(StringPrototypeCharCodeAt.call(ch) + StringPrototypeCharCodeAt.call(\"a\") - 1);\n      keyCtrl = true;\n    } else if (RegExpPrototypeExec.call(/^[0-9A-Za-z]$/, ch) !== null) {\n      // Letter, number, shift+letter\n      keyName = StringPrototypeToLowerCase.call(ch);\n      keyShift = RegExpPrototypeExec.call(/^[A-Z]$/, ch) !== null;\n      keyMeta = escaped;\n    } else if (escaped) {\n      // Escape sequence timeout\n      keyName = ch.length ? undefined : \"escape\";\n      keyMeta = true;\n    }\n\n    keySeq = s;\n\n    if (s.length !== 0 && (keyName !== undefined || escaped)) {\n      /* Named character or sequence */\n      stream.emit(\"keypress\", escaped ? undefined : s, {\n        sequence: keySeq,\n        name: keyName,\n        ctrl: keyCtrl,\n        meta: keyMeta,\n        shift: keyShift,\n      });\n    } else if (charLengthAt(s, 0) === s.length) {\n      /* Single unnamed character, e.g. \".\" */\n      stream.emit(\"keypress\", s, {\n        sequence: keySeq,\n        name: keyName,\n        ctrl: keyCtrl,\n        meta: keyMeta,\n        shift: keyShift,\n      });\n    }\n    /* Unrecognized or broken escape sequence, don't emit anything */\n  }\n}\n\n// This runs in O(n log n).\nfunction commonPrefix(strings) {\n  if (strings.length === 0) {\n    return \"\";\n  }\n  if (strings.length === 1) {\n    return strings[0];\n  }\n  var sorted = ArrayPrototypeSort.call(ArrayPrototypeSlice.call(strings));\n  var min = sorted[0];\n  var max = sorted[sorted.length - 1];\n  for (var i = 0; i < min.length; i++) {\n    if (min[i] !== max[i]) {\n      return StringPrototypeSlice.call(min, 0, i);\n    }\n  }\n  return min;\n}\n\n// ----------------------------------------------------------------------------\n// Section: Cursor Functions\n// ----------------------------------------------------------------------------\n\n/**\n * moves the cursor to the x and y coordinate on the given stream\n */\n\nfunction cursorTo(stream, x, y, callback) {\n  if (callback !== undefined) {\n    validateFunction(callback, \"callback\");\n  }\n\n  if (typeof y === \"function\") {\n    callback = y;\n    y = undefined;\n  }\n\n  if (NumberIsNaN(x)) throw new ERR_INVALID_ARG_VALUE(\"x\", x);\n  if (NumberIsNaN(y)) throw new ERR_INVALID_ARG_VALUE(\"y\", y);\n\n  if (stream == null || (typeof x !== \"number\" && typeof y !== \"number\")) {\n    if (typeof callback === \"function\") process.nextTick(callback, null);\n    return true;\n  }\n\n  if (typeof x !== \"number\") throw new ERR_INVALID_CURSOR_POS();\n\n  var data = typeof y !== \"number\" ? CSI`${x + 1}G` : CSI`${y + 1};${x + 1}H`;\n  return stream.write(data, callback);\n}\n\n/**\n * moves the cursor relative to its current location\n */\n\nfunction moveCursor(stream, dx, dy, callback) {\n  if (callback !== undefined) {\n    validateFunction(callback, \"callback\");\n  }\n\n  if (stream == null || !(dx || dy)) {\n    if (typeof callback === \"function\") process.nextTick(callback, null);\n    return true;\n  }\n\n  var data = \"\";\n\n  if (dx < 0) {\n    data += CSI`${-dx}D`;\n  } else if (dx > 0) {\n    data += CSI`${dx}C`;\n  }\n\n  if (dy < 0) {\n    data += CSI`${-dy}A`;\n  } else if (dy > 0) {\n    data += CSI`${dy}B`;\n  }\n\n  return stream.write(data, callback);\n}\n\n/**\n * clears the current line the cursor is on:\n *   -1 for left of the cursor\n *   +1 for right of the cursor\n *    0 for the entire line\n */\n\nfunction clearLine(stream, dir, callback) {\n  if (callback !== undefined) {\n    validateFunction(callback, \"callback\");\n  }\n\n  if (stream === null || stream === undefined) {\n    if (typeof callback === \"function\") process.nextTick(callback, null);\n    return true;\n  }\n\n  var type = dir < 0 ? kClearToLineBeginning : dir > 0 ? kClearToLineEnd : kClearLine;\n  return stream.write(type, callback);\n}\n\n/**\n * clears the screen from the current position of the cursor down\n */\n\nfunction clearScreenDown(stream, callback) {\n  if (callback !== undefined) {\n    validateFunction(callback, \"callback\");\n  }\n\n  if (stream === null || stream === undefined) {\n    if (typeof callback === \"function\") process.nextTick(callback, null);\n    return true;\n  }\n\n  return stream.write(kClearScreenDown, callback);\n}\n\n// ----------------------------------------------------------------------------\n// Section: Emit keypress events\n// ----------------------------------------------------------------------------\n\nvar KEYPRESS_DECODER = Symbol(\"keypress-decoder\");\nvar ESCAPE_DECODER = Symbol(\"escape-decoder\");\n\n// GNU readline library - keyseq-timeout is 500ms (default)\nvar ESCAPE_CODE_TIMEOUT = 500;\n\n/**\n * accepts a readable Stream instance and makes it emit \"keypress\" events\n */\n\nfunction emitKeypressEvents(stream, iface = {}) {\n  if (stream[KEYPRESS_DECODER]) return;\n\n  stream[KEYPRESS_DECODER] = new StringDecoder(\"utf8\");\n\n  stream[ESCAPE_DECODER] = emitKeys(stream);\n  stream[ESCAPE_DECODER].next();\n\n  var triggerEscape = () => stream[ESCAPE_DECODER].next(\"\");\n  var { escapeCodeTimeout = ESCAPE_CODE_TIMEOUT } = iface;\n  var timeoutId;\n\n  function onData(input) {\n    if (stream.listenerCount(\"keypress\") > 0) {\n      var string = stream[KEYPRESS_DECODER].write(input);\n      if (string) {\n        clearTimeout(timeoutId);\n\n        // This supports characters of length 2.\n        iface[kSawKeyPress] = charLengthAt(string, 0) === string.length;\n        iface.isCompletionEnabled = false;\n\n        var length = 0;\n        for (var character of new SafeStringIterator(string)) {\n          length += character.length;\n          if (length === string.length) {\n            iface.isCompletionEnabled = true;\n          }\n\n          try {\n            stream[ESCAPE_DECODER].next(character);\n            // Escape letter at the tail position\n            if (length === string.length && character === kEscape) {\n              timeoutId = setTimeout(triggerEscape, escapeCodeTimeout);\n            }\n          } catch (err) {\n            // If the generator throws (it could happen in the `keypress`\n            // event), we need to restart it.\n            stream[ESCAPE_DECODER] = emitKeys(stream);\n            stream[ESCAPE_DECODER].next();\n            throw err;\n          }\n        }\n      }\n    } else {\n      // Nobody's watching anyway\n      stream.removeListener(\"data\", onData);\n      stream.on(\"newListener\", onNewListener);\n    }\n  }\n\n  function onNewListener(event) {\n    if (event === \"keypress\") {\n      stream.on(\"data\", onData);\n      stream.removeListener(\"newListener\", onNewListener);\n    }\n  }\n\n  if (stream.listenerCount(\"keypress\") > 0) {\n    stream.on(\"data\", onData);\n  } else {\n    stream.on(\"newListener\", onNewListener);\n  }\n}\n\n// ----------------------------------------------------------------------------\n// Section: Interface\n// ----------------------------------------------------------------------------\n\nvar kEmptyObject = ObjectFreeze(ObjectCreate(null));\n\n// Some constants regarding configuration of interface\nvar kHistorySize = 30;\nvar kMaxUndoRedoStackSize = 2048;\nvar kMincrlfDelay = 100;\n// \\r\\n, \\n, or \\r followed by something other than \\n\nvar lineEnding = /\\r?\\n|\\r(?!\\n)/g;\n\n// Max length of the kill ring\nvar kMaxLengthOfKillRing = 32;\n\n// Symbols\n\n// Public symbols\nvar kLineObjectStream = Symbol(\"line object stream\");\nvar kQuestionCancel = Symbol(\"kQuestionCancel\");\nvar kQuestion = Symbol(\"kQuestion\");\n\n// Private symbols\nvar kAddHistory = Symbol(\"_addHistory\");\nvar kBeforeEdit = Symbol(\"_beforeEdit\");\nvar kDecoder = Symbol(\"_decoder\");\nvar kDeleteLeft = Symbol(\"_deleteLeft\");\nvar kDeleteLineLeft = Symbol(\"_deleteLineLeft\");\nvar kDeleteLineRight = Symbol(\"_deleteLineRight\");\nvar kDeleteRight = Symbol(\"_deleteRight\");\nvar kDeleteWordLeft = Symbol(\"_deleteWordLeft\");\nvar kDeleteWordRight = Symbol(\"_deleteWordRight\");\nvar kGetDisplayPos = Symbol(\"_getDisplayPos\");\nvar kHistoryNext = Symbol(\"_historyNext\");\nvar kHistoryPrev = Symbol(\"_historyPrev\");\nvar kInsertString = Symbol(\"_insertString\");\nvar kLine = Symbol(\"_line\");\nvar kLine_buffer = Symbol(\"_line_buffer\");\nvar kKillRing = Symbol(\"_killRing\");\nvar kKillRingCursor = Symbol(\"_killRingCursor\");\nvar kMoveCursor = Symbol(\"_moveCursor\");\nvar kNormalWrite = Symbol(\"_normalWrite\");\nvar kOldPrompt = Symbol(\"_oldPrompt\");\nvar kOnLine = Symbol(\"_onLine\");\nvar kPreviousKey = Symbol(\"_previousKey\");\nvar kPrompt = Symbol(\"_prompt\");\nvar kPushToKillRing = Symbol(\"_pushToKillRing\");\nvar kPushToUndoStack = Symbol(\"_pushToUndoStack\");\nvar kQuestionCallback = Symbol(\"_questionCallback\");\nvar kRedo = Symbol(\"_redo\");\nvar kRedoStack = Symbol(\"_redoStack\");\nvar kRefreshLine = Symbol(\"_refreshLine\");\nvar kSawKeyPress = Symbol(\"_sawKeyPress\");\nvar kSawReturnAt = Symbol(\"_sawReturnAt\");\nvar kSetRawMode = Symbol(\"_setRawMode\");\nvar kTabComplete = Symbol(\"_tabComplete\");\nvar kTabCompleter = Symbol(\"_tabCompleter\");\nvar kTtyWrite = Symbol(\"_ttyWrite\");\nvar kUndo = Symbol(\"_undo\");\nvar kUndoStack = Symbol(\"_undoStack\");\nvar kWordLeft = Symbol(\"_wordLeft\");\nvar kWordRight = Symbol(\"_wordRight\");\nvar kWriteToOutput = Symbol(\"_writeToOutput\");\nvar kYank = Symbol(\"_yank\");\nvar kYanking = Symbol(\"_yanking\");\nvar kYankPop = Symbol(\"_yankPop\");\n\n// Event symbols\nvar kFirstEventParam = Symbol(\"nodejs.kFirstEventParam\");\n\n// class InterfaceConstructor extends EventEmitter {\n// #onSelfCloseWithTerminal;\n// #onSelfCloseWithoutTerminal;\n\n// #onError;\n// #onData;\n// #onEnd;\n// #onTermEnd;\n// #onKeyPress;\n// #onResize;\n\n// [kSawReturnAt];\n// isCompletionEnabled = true;\n// [kSawKeyPress];\n// [kPreviousKey];\n// escapeCodeTimeout;\n// tabSize;\n\n// line;\n// [kSubstringSearch];\n// output;\n// input;\n// [kUndoStack];\n// [kRedoStack];\n// history;\n// historySize;\n\n// [kKillRing];\n// [kKillRingCursor];\n\n// removeHistoryDuplicates;\n// crlfDelay;\n// completer;\n\n// terminal;\n// [kLineObjectStream];\n\n// cursor;\n// historyIndex;\n\n// constructor(input, output, completer, terminal) {\n//   super();\n\nvar kOnSelfCloseWithTerminal = Symbol(\"_onSelfCloseWithTerminal\");\nvar kOnSelfCloseWithoutTerminal = Symbol(\"_onSelfCloseWithoutTerminal\");\nvar kOnKeyPress = Symbol(\"_onKeyPress\");\nvar kOnError = Symbol(\"_onError\");\nvar kOnData = Symbol(\"_onData\");\nvar kOnEnd = Symbol(\"_onEnd\");\nvar kOnTermEnd = Symbol(\"_onTermEnd\");\nvar kOnResize = Symbol(\"_onResize\");\n\nfunction onSelfCloseWithTerminal() {\n  var input = this.input;\n  var output = this.output;\n\n  if (!input) throw new Error(\"Input not set, invalid state for readline!\");\n\n  input.removeListener(\"keypress\", this[kOnKeyPress]);\n  input.removeListener(\"error\", this[kOnError]);\n  input.removeListener(\"end\", this[kOnTermEnd]);\n  if (output !== null && output !== undefined) {\n    output.removeListener(\"resize\", this[kOnResize]);\n  }\n}\n\nfunction onSelfCloseWithoutTerminal() {\n  var input = this.input;\n  if (!input) throw new Error(\"Input not set, invalid state for readline!\");\n\n  input.removeListener(\"data\", this[kOnData]);\n  input.removeListener(\"error\", this[kOnError]);\n  input.removeListener(\"end\", this[kOnEnd]);\n}\n\nfunction onError(err) {\n  this.emit(\"error\", err);\n}\n\nfunction onData(data) {\n  debug(\"onData\");\n  this[kNormalWrite](data);\n}\n\nfunction onEnd() {\n  debug(\"onEnd\");\n  if (typeof this[kLine_buffer] === \"string\" && this[kLine_buffer].length > 0) {\n    this.emit(\"line\", this[kLine_buffer]);\n  }\n  this.close();\n}\n\nfunction onTermEnd() {\n  debug(\"onTermEnd\");\n  if (typeof this.line === \"string\" && this.line.length > 0) {\n    this.emit(\"line\", this.line);\n  }\n  this.close();\n}\n\nfunction onKeyPress(s, key) {\n  this[kTtyWrite](s, key);\n  if (key && key.sequence) {\n    // If the keySeq is half of a surrogate pair\n    // (>= 0xd800 and <= 0xdfff), refresh the line so\n    // the character is displayed appropriately.\n    var ch = StringPrototypeCodePointAt.call(key.sequence, 0);\n    if (ch >= 0xd800 && ch <= 0xdfff) this[kRefreshLine]();\n  }\n}\n\nfunction onResize() {\n  this[kRefreshLine]();\n}\n\nfunction InterfaceConstructor(input, output, completer, terminal) {\n  if (!(this instanceof InterfaceConstructor)) {\n    return new InterfaceConstructor(input, output, completer, terminal);\n  }\n\n  EventEmitter.call(this);\n\n  this[kOnSelfCloseWithoutTerminal] = onSelfCloseWithoutTerminal.bind(this);\n  this[kOnSelfCloseWithTerminal] = onSelfCloseWithTerminal.bind(this);\n\n  this[kOnError] = onError.bind(this);\n  this[kOnData] = onData.bind(this);\n  this[kOnEnd] = onEnd.bind(this);\n  this[kOnTermEnd] = onTermEnd.bind(this);\n  this[kOnKeyPress] = onKeyPress.bind(this);\n  this[kOnResize] = onResize.bind(this);\n\n  this[kSawReturnAt] = 0;\n  this.isCompletionEnabled = true;\n  this[kSawKeyPress] = false;\n  this[kPreviousKey] = null;\n  this.escapeCodeTimeout = ESCAPE_CODE_TIMEOUT;\n  this.tabSize = 8;\n\n  var history;\n  var historySize;\n  var removeHistoryDuplicates = false;\n  var crlfDelay;\n  var prompt = \"> \";\n  var signal;\n\n  if (input?.input) {\n    // An options object was given\n    output = input.output;\n    completer = input.completer;\n    terminal = input.terminal;\n    history = input.history;\n    historySize = input.historySize;\n    signal = input.signal;\n\n    var tabSize = input.tabSize;\n    if (tabSize !== undefined) {\n      validateUint32(tabSize, \"tabSize\", true);\n      this.tabSize = tabSize;\n    }\n    removeHistoryDuplicates = input.removeHistoryDuplicates;\n\n    var inputPrompt = input.prompt;\n    if (inputPrompt !== undefined) {\n      prompt = inputPrompt;\n    }\n\n    var inputEscapeCodeTimeout = input.escapeCodeTimeout;\n    if (inputEscapeCodeTimeout !== undefined) {\n      if (NumberIsFinite(inputEscapeCodeTimeout)) {\n        this.escapeCodeTimeout = inputEscapeCodeTimeout;\n      } else {\n        throw new ERR_INVALID_ARG_VALUE(\"input.escapeCodeTimeout\", this.escapeCodeTimeout);\n      }\n    }\n\n    if (signal) {\n      validateAbortSignal(signal, \"options.signal\");\n    }\n\n    crlfDelay = input.crlfDelay;\n    input = input.input;\n  }\n\n  if (completer !== undefined && typeof completer !== \"function\") {\n    throw new ERR_INVALID_ARG_VALUE(\"completer\", completer);\n  }\n\n  if (history === undefined) {\n    history = [];\n  } else {\n    validateArray(history, \"history\");\n  }\n\n  if (historySize === undefined) {\n    historySize = kHistorySize;\n  }\n\n  if (typeof historySize !== \"number\" || NumberIsNaN(historySize) || historySize < 0) {\n    throw new ERR_INVALID_ARG_VALUE(\"historySize\", historySize);\n  }\n\n  // Backwards compat; check the isTTY prop of the output stream\n  //  when `terminal` was not specified\n  if (terminal === undefined && !(output === null || output === undefined)) {\n    terminal = !!output.isTTY;\n  }\n\n  this.line = \"\";\n  this[kSubstringSearch] = null;\n  this.output = output;\n  this.input = input;\n  this[kUndoStack] = [];\n  this[kRedoStack] = [];\n  this.history = history;\n  this.historySize = historySize;\n\n  // The kill ring is a global list of blocks of text that were previously\n  // killed (deleted). If its size exceeds kMaxLengthOfKillRing, the oldest\n  // element will be removed to make room for the latest deletion. With kill\n  // ring, users are able to recall (yank) or cycle (yank pop) among previously\n  // killed texts, quite similar to the behavior of Emacs.\n  this[kKillRing] = [];\n  this[kKillRingCursor] = 0;\n\n  this.removeHistoryDuplicates = !!removeHistoryDuplicates;\n  this.crlfDelay = crlfDelay ? MathMax(kMincrlfDelay, crlfDelay) : kMincrlfDelay;\n  this.completer = completer;\n\n  this.setPrompt(prompt);\n\n  this.terminal = !!terminal;\n\n  this[kLineObjectStream] = undefined;\n\n  input.on(\"error\", this[kOnError]);\n\n  if (!this.terminal) {\n    input.on(\"data\", this[kOnData]);\n    input.on(\"end\", this[kOnEnd]);\n    this.once(\"close\", this[kOnSelfCloseWithoutTerminal]);\n    this[kDecoder] = new StringDecoder(\"utf8\");\n  } else {\n    emitKeypressEvents(input, this);\n\n    // `input` usually refers to stdin\n    input.on(\"keypress\", this[kOnKeyPress]);\n    input.on(\"end\", this[kOnTermEnd]);\n\n    this[kSetRawMode](true);\n    this.terminal = true;\n\n    // Cursor position on the line.\n    this.cursor = 0;\n    this.historyIndex = -1;\n\n    if (output !== null && output !== undefined) output.on(\"resize\", this[kOnResize]);\n\n    this.once(\"close\", this[kOnSelfCloseWithTerminal]);\n  }\n\n  if (signal) {\n    var onAborted = (() => this.close()).bind(this);\n    if (signal.aborted) {\n      process.nextTick(onAborted);\n    } else {\n      signal.addEventListener(\"abort\", onAborted, { once: true });\n      this.once(\"close\", () => signal.removeEventListener(\"abort\", onAborted));\n    }\n  }\n\n  // Current line\n  this.line = \"\";\n\n  input.resume();\n}\n\nObjectSetPrototypeOf(InterfaceConstructor.prototype, EventEmitter.prototype);\nObjectSetPrototypeOf(InterfaceConstructor, EventEmitter);\n\nvar _Interface = class Interface extends InterfaceConstructor {\n  // TODO: Enumerate all the properties of the class\n\n  // eslint-disable-next-line no-useless-constructor\n  constructor(input, output, completer, terminal) {\n    super(input, output, completer, terminal);\n  }\n  get columns() {\n    var output = this.output;\n    if (output && output.columns) return output.columns;\n    return Infinity;\n  }\n\n  /**\n   * Sets the prompt written to the output.\n   * @param {string} prompt\n   * @returns {void}\n   */\n  setPrompt(prompt) {\n    this[kPrompt] = prompt;\n  }\n\n  /**\n   * Returns the current prompt used by `rl.prompt()`.\n   * @returns {string}\n   */\n  getPrompt() {\n    return this[kPrompt];\n  }\n\n  [kSetRawMode](mode) {\n    var input = this.input;\n    var { setRawMode, wasInRawMode } = input;\n\n    // TODO: Make this work, for now just stub this and print debug\n    debug(\"setRawMode\", mode, \"set!\");\n    // if (typeof setRawMode === \"function\") {\n    //   setRawMode(mode);\n    // }\n\n    return wasInRawMode;\n  }\n\n  /**\n   * Writes the configured `prompt` to a new line in `output`.\n   * @param {boolean} [preserveCursor]\n   * @returns {void}\n   */\n  prompt(preserveCursor) {\n    if (this.paused) this.resume();\n    if (this.terminal && process.env.TERM !== \"dumb\") {\n      if (!preserveCursor) this.cursor = 0;\n      this[kRefreshLine]();\n    } else {\n      this[kWriteToOutput](this[kPrompt]);\n    }\n  }\n\n  [kQuestion](query, cb) {\n    if (this.closed) {\n      throw new ERR_USE_AFTER_CLOSE(\"readline\");\n    }\n    if (this[kQuestionCallback]) {\n      this.prompt();\n    } else {\n      this[kOldPrompt] = this[kPrompt];\n      this.setPrompt(query);\n      this[kQuestionCallback] = cb;\n      this.prompt();\n    }\n  }\n\n  [kOnLine](line) {\n    if (this[kQuestionCallback]) {\n      var cb = this[kQuestionCallback];\n      this[kQuestionCallback] = null;\n      this.setPrompt(this[kOldPrompt]);\n      cb(line);\n    } else {\n      this.emit(\"line\", line);\n    }\n  }\n\n  [kBeforeEdit](oldText, oldCursor) {\n    this[kPushToUndoStack](oldText, oldCursor);\n  }\n\n  [kQuestionCancel]() {\n    if (this[kQuestionCallback]) {\n      this[kQuestionCallback] = null;\n      this.setPrompt(this[kOldPrompt]);\n      this.clearLine();\n    }\n  }\n\n  [kWriteToOutput](stringToWrite) {\n    validateString(stringToWrite, \"stringToWrite\");\n\n    if (this.output !== null && this.output !== undefined) {\n      this.output.write(stringToWrite);\n    }\n  }\n\n  [kAddHistory]() {\n    if (this.line.length === 0) return \"\";\n\n    // If the history is disabled then return the line\n    if (this.historySize === 0) return this.line;\n\n    // If the trimmed line is empty then return the line\n    if (StringPrototypeTrim.call(this.line).length === 0) return this.line;\n\n    if (this.history.length === 0 || this.history[0] !== this.line) {\n      if (this.removeHistoryDuplicates) {\n        // Remove older history line if identical to new one\n        var dupIndex = ArrayPrototypeIndexOf.call(this.history, this.line);\n        if (dupIndex !== -1) ArrayPrototypeSplice.call(this.history, dupIndex, 1);\n      }\n\n      ArrayPrototypeUnshift.call(this.history, this.line);\n\n      // Only store so many\n      if (this.history.length > this.historySize) ArrayPrototypePop.call(this.history);\n    }\n\n    this.historyIndex = -1;\n\n    // The listener could change the history object, possibly\n    // to remove the last added entry if it is sensitive and should\n    // not be persisted in the history, like a password\n    var line = this.history[0];\n\n    // Emit history event to notify listeners of update\n    this.emit(\"history\", this.history);\n\n    return line;\n  }\n\n  [kRefreshLine]() {\n    // line length\n    var line = this[kPrompt] + this.line;\n    var dispPos = this[kGetDisplayPos](line);\n    var lineCols = dispPos.cols;\n    var lineRows = dispPos.rows;\n\n    // cursor position\n    var cursorPos = this.getCursorPos();\n\n    // First move to the bottom of the current line, based on cursor pos\n    var prevRows = this.prevRows || 0;\n    if (prevRows > 0) {\n      moveCursor(this.output, 0, -prevRows);\n    }\n\n    // Cursor to left edge.\n    cursorTo(this.output, 0);\n    // erase data\n    clearScreenDown(this.output);\n\n    // Write the prompt and the current buffer content.\n    this[kWriteToOutput](line);\n\n    // Force terminal to allocate a new line\n    if (lineCols === 0) {\n      this[kWriteToOutput](\" \");\n    }\n\n    // Move cursor to original position.\n    cursorTo(this.output, cursorPos.cols);\n\n    var diff = lineRows - cursorPos.rows;\n    if (diff > 0) {\n      moveCursor(this.output, 0, -diff);\n    }\n\n    this.prevRows = cursorPos.rows;\n  }\n\n  /**\n   * Closes the `readline.Interface` instance.\n   * @returns {void}\n   */\n  close() {\n    if (this.closed) return;\n    this.pause();\n    if (this.terminal) {\n      this[kSetRawMode](false);\n    }\n    this.closed = true;\n    this.emit(\"close\");\n  }\n\n  /**\n   * Pauses the `input` stream.\n   * @returns {void | Interface}\n   */\n  pause() {\n    if (this.paused) return;\n    this.input.pause();\n    this.paused = true;\n    this.emit(\"pause\");\n    return this;\n  }\n\n  /**\n   * Resumes the `input` stream if paused.\n   * @returns {void | Interface}\n   */\n  resume() {\n    if (!this.paused) return;\n    this.input.resume();\n    this.paused = false;\n    this.emit(\"resume\");\n    return this;\n  }\n\n  /**\n   * Writes either `data` or a `key` sequence identified by\n   * `key` to the `output`.\n   * @param {string} d\n   * @param {{\n   *   ctrl?: boolean;\n   *   meta?: boolean;\n   *   shift?: boolean;\n   *   name?: string;\n   *   }} [key]\n   * @returns {void}\n   */\n  write(d, key) {\n    if (this.paused) this.resume();\n    if (this.terminal) {\n      this[kTtyWrite](d, key);\n    } else {\n      this[kNormalWrite](d);\n    }\n  }\n\n  [kNormalWrite](b) {\n    if (b === undefined) {\n      return;\n    }\n    var string = this[kDecoder].write(b);\n    if (this[kSawReturnAt] && DateNow() - this[kSawReturnAt] <= this.crlfDelay) {\n      if (StringPrototypeCodePointAt.call(string) === 10) string = StringPrototypeSlice.call(string, 1);\n      this[kSawReturnAt] = 0;\n    }\n\n    // Run test() on the new string chunk, not on the entire line buffer.\n    var newPartContainsEnding = RegExpPrototypeExec.call(lineEnding, string);\n    if (newPartContainsEnding !== null) {\n      if (this[kLine_buffer]) {\n        string = this[kLine_buffer] + string;\n        this[kLine_buffer] = null;\n        newPartContainsEnding = RegExpPrototypeExec.call(lineEnding, string);\n      }\n      this[kSawReturnAt] = StringPrototypeEndsWith.call(string, \"\\r\") ? DateNow() : 0;\n\n      var indexes = [0, newPartContainsEnding.index, lineEnding.lastIndex];\n      var nextMatch;\n      while ((nextMatch = RegExpPrototypeExec.call(lineEnding, string)) !== null) {\n        ArrayPrototypePush.call(indexes, nextMatch.index, lineEnding.lastIndex);\n      }\n      var lastIndex = indexes.length - 1;\n      // Either '' or (conceivably) the unfinished portion of the next line\n      this[kLine_buffer] = StringPrototypeSlice.call(string, indexes[lastIndex]);\n      for (var i = 1; i < lastIndex; i += 2) {\n        this[kOnLine](StringPrototypeSlice.call(string, indexes[i - 1], indexes[i]));\n      }\n    } else if (string) {\n      // No newlines this time, save what we have for next time\n      if (this[kLine_buffer]) {\n        this[kLine_buffer] += string;\n      } else {\n        this[kLine_buffer] = string;\n      }\n    }\n  }\n\n  [kInsertString](c) {\n    this[kBeforeEdit](this.line, this.cursor);\n    if (this.cursor < this.line.length) {\n      var beg = StringPrototypeSlice.call(this.line, 0, this.cursor);\n      var end = StringPrototypeSlice.call(this.line, this.cursor, this.line.length);\n      this.line = beg + c + end;\n      this.cursor += c.length;\n      this[kRefreshLine]();\n    } else {\n      var oldPos = this.getCursorPos();\n      this.line += c;\n      this.cursor += c.length;\n      var newPos = this.getCursorPos();\n\n      if (oldPos.rows < newPos.rows) {\n        this[kRefreshLine]();\n      } else {\n        this[kWriteToOutput](c);\n      }\n    }\n  }\n\n  async [kTabComplete](lastKeypressWasTab) {\n    this.pause();\n    var string = StringPrototypeSlice.call(this.line, 0, this.cursor);\n    var value;\n    try {\n      value = await this.completer(string);\n    } catch (err) {\n      this[kWriteToOutput](`Tab completion error: ${inspect(err)}`);\n      return;\n    } finally {\n      this.resume();\n    }\n    this[kTabCompleter](lastKeypressWasTab, value);\n  }\n\n  [kTabCompleter](lastKeypressWasTab, { 0: completions, 1: completeOn }) {\n    // Result and the text that was completed.\n\n    if (!completions || completions.length === 0) {\n      return;\n    }\n\n    // If there is a common prefix to all matches, then apply that portion.\n    var prefix = commonPrefix(ArrayPrototypeFilter.call(completions, e => e !== \"\"));\n    if (StringPrototypeStartsWith.call(prefix, completeOn) && prefix.length > completeOn.length) {\n      this[kInsertString](StringPrototypeSlice.call(prefix, completeOn.length));\n      return;\n    } else if (!StringPrototypeStartsWith.call(completeOn, prefix)) {\n      this.line =\n        StringPrototypeSlice.call(this.line, 0, this.cursor - completeOn.length) +\n        prefix +\n        StringPrototypeSlice.call(this.line, this.cursor, this.line.length);\n      this.cursor = this.cursor - completeOn.length + prefix.length;\n      this._refreshLine();\n      return;\n    }\n\n    if (!lastKeypressWasTab) {\n      return;\n    }\n\n    this[kBeforeEdit](this.line, this.cursor);\n\n    // Apply/show completions.\n    var completionsWidth = ArrayPrototypeMap.call(completions, e => getStringWidth(e));\n    var width = MathMaxApply(completionsWidth) + 2; // 2 space padding\n    var maxColumns = MathFloor(this.columns / width) || 1;\n    if (maxColumns === Infinity) {\n      maxColumns = 1;\n    }\n    var output = \"\\r\\n\";\n    var lineIndex = 0;\n    var whitespace = 0;\n    for (var i = 0; i < completions.length; i++) {\n      var completion = completions[i];\n      if (completion === \"\" || lineIndex === maxColumns) {\n        output += \"\\r\\n\";\n        lineIndex = 0;\n        whitespace = 0;\n      } else {\n        output += StringPrototypeRepeat.call(\" \", whitespace);\n      }\n      if (completion !== \"\") {\n        output += completion;\n        whitespace = width - completionsWidth[i];\n        lineIndex++;\n      } else {\n        output += \"\\r\\n\";\n      }\n    }\n    if (lineIndex !== 0) {\n      output += \"\\r\\n\\r\\n\";\n    }\n    this[kWriteToOutput](output);\n    this[kRefreshLine]();\n  }\n\n  [kWordLeft]() {\n    if (this.cursor > 0) {\n      // Reverse the string and match a word near beginning\n      // to avoid quadratic time complexity\n      var leading = StringPrototypeSlice.call(this.line, 0, this.cursor);\n      var reversed = ArrayPrototypeJoin.call(ArrayPrototypeReverse.call(ArrayFrom(leading)), \"\");\n      var match = RegExpPrototypeExec.call(/^\\s*(?:[^\\w\\s]+|\\w+)?/, reversed);\n      this[kMoveCursor](-match[0].length);\n    }\n  }\n\n  [kWordRight]() {\n    if (this.cursor < this.line.length) {\n      var trailing = StringPrototypeSlice.call(this.line, this.cursor);\n      var match = RegExpPrototypeExec.call(/^(?:\\s+|[^\\w\\s]+|\\w+)\\s*/, trailing);\n      this[kMoveCursor](match[0].length);\n    }\n  }\n\n  [kDeleteLeft]() {\n    if (this.cursor > 0 && this.line.length > 0) {\n      this[kBeforeEdit](this.line, this.cursor);\n      // The number of UTF-16 units comprising the character to the left\n      var charSize = charLengthLeft(this.line, this.cursor);\n      this.line =\n        StringPrototypeSlice.call(this.line, 0, this.cursor - charSize) +\n        StringPrototypeSlice.call(this.line, this.cursor, this.line.length);\n\n      this.cursor -= charSize;\n      this[kRefreshLine]();\n    }\n  }\n\n  [kDeleteRight]() {\n    if (this.cursor < this.line.length) {\n      this[kBeforeEdit](this.line, this.cursor);\n      // The number of UTF-16 units comprising the character to the left\n      var charSize = charLengthAt(this.line, this.cursor);\n      this.line =\n        StringPrototypeSlice.call(this.line, 0, this.cursor) +\n        StringPrototypeSlice.call(this.line, this.cursor + charSize, this.line.length);\n      this[kRefreshLine]();\n    }\n  }\n\n  [kDeleteWordLeft]() {\n    if (this.cursor > 0) {\n      this[kBeforeEdit](this.line, this.cursor);\n      // Reverse the string and match a word near beginning\n      // to avoid quadratic time complexity\n      var leading = StringPrototypeSlice.call(this.line, 0, this.cursor);\n      var reversed = ArrayPrototypeJoin.call(ArrayPrototypeReverse.call(ArrayFrom(leading)), \"\");\n      var match = RegExpPrototypeExec.call(/^\\s*(?:[^\\w\\s]+|\\w+)?/, reversed);\n      leading = StringPrototypeSlice.call(leading, 0, leading.length - match[0].length);\n      this.line = leading + StringPrototypeSlice.call(this.line, this.cursor, this.line.length);\n      this.cursor = leading.length;\n      this[kRefreshLine]();\n    }\n  }\n\n  [kDeleteWordRight]() {\n    if (this.cursor < this.line.length) {\n      this[kBeforeEdit](this.line, this.cursor);\n      var trailing = StringPrototypeSlice.call(this.line, this.cursor);\n      var match = RegExpPrototypeExec.call(/^(?:\\s+|\\W+|\\w+)\\s*/, trailing);\n      this.line =\n        StringPrototypeSlice.call(this.line, 0, this.cursor) + StringPrototypeSlice.call(trailing, match[0].length);\n      this[kRefreshLine]();\n    }\n  }\n\n  [kDeleteLineLeft]() {\n    this[kBeforeEdit](this.line, this.cursor);\n    var del = StringPrototypeSlice.call(this.line, 0, this.cursor);\n    this.line = StringPrototypeSlice.call(this.line, this.cursor);\n    this.cursor = 0;\n    this[kPushToKillRing](del);\n    this[kRefreshLine]();\n  }\n\n  [kDeleteLineRight]() {\n    this[kBeforeEdit](this.line, this.cursor);\n    var del = StringPrototypeSlice.call(this.line, this.cursor);\n    this.line = StringPrototypeSlice.call(this.line, 0, this.cursor);\n    this[kPushToKillRing](del);\n    this[kRefreshLine]();\n  }\n\n  [kPushToKillRing](del) {\n    if (!del || del === this[kKillRing][0]) return;\n    ArrayPrototypeUnshift.call(this[kKillRing], del);\n    this[kKillRingCursor] = 0;\n    while (this[kKillRing].length > kMaxLengthOfKillRing) ArrayPrototypePop.call(this[kKillRing]);\n  }\n\n  [kYank]() {\n    if (this[kKillRing].length > 0) {\n      this[kYanking] = true;\n      this[kInsertString](this[kKillRing][this[kKillRingCursor]]);\n    }\n  }\n\n  [kYankPop]() {\n    if (!this[kYanking]) {\n      return;\n    }\n    if (this[kKillRing].length > 1) {\n      var lastYank = this[kKillRing][this[kKillRingCursor]];\n      this[kKillRingCursor]++;\n      if (this[kKillRingCursor] >= this[kKillRing].length) {\n        this[kKillRingCursor] = 0;\n      }\n      var currentYank = this[kKillRing][this[kKillRingCursor]];\n      var head = StringPrototypeSlice.call(this.line, 0, this.cursor - lastYank.length);\n      var tail = StringPrototypeSlice.call(this.line, this.cursor);\n      this.line = head + currentYank + tail;\n      this.cursor = head.length + currentYank.length;\n      this[kRefreshLine]();\n    }\n  }\n\n  clearLine() {\n    this[kMoveCursor](+Infinity);\n    this[kWriteToOutput](\"\\r\\n\");\n    this.line = \"\";\n    this.cursor = 0;\n    this.prevRows = 0;\n  }\n\n  [kLine]() {\n    var line = this[kAddHistory]();\n    this[kUndoStack] = [];\n    this[kRedoStack] = [];\n    this.clearLine();\n    this[kOnLine](line);\n  }\n\n  [kPushToUndoStack](text, cursor) {\n    if (ArrayPrototypePush.call(this[kUndoStack], { text, cursor }) > kMaxUndoRedoStackSize) {\n      ArrayPrototypeShift.call(this[kUndoStack]);\n    }\n  }\n\n  [kUndo]() {\n    if (this[kUndoStack].length <= 0) return;\n\n    ArrayPrototypePush.call(this[kRedoStack], {\n      text: this.line,\n      cursor: this.cursor,\n    });\n\n    var entry = ArrayPrototypePop.call(this[kUndoStack]);\n    this.line = entry.text;\n    this.cursor = entry.cursor;\n\n    this[kRefreshLine]();\n  }\n\n  [kRedo]() {\n    if (this[kRedoStack].length <= 0) return;\n\n    ArrayPrototypePush.call(this[kUndoStack], {\n      text: this.line,\n      cursor: this.cursor,\n    });\n\n    var entry = ArrayPrototypePop.call(this[kRedoStack]);\n    this.line = entry.text;\n    this.cursor = entry.cursor;\n\n    this[kRefreshLine]();\n  }\n\n  [kHistoryNext]() {\n    if (this.historyIndex >= 0) {\n      this[kBeforeEdit](this.line, this.cursor);\n      var search = this[kSubstringSearch] || \"\";\n      var index = this.historyIndex - 1;\n      while (\n        index >= 0 &&\n        (!StringPrototypeStartsWith.call(this.history[index], search) || this.line === this.history[index])\n      ) {\n        index--;\n      }\n      if (index === -1) {\n        this.line = search;\n      } else {\n        this.line = this.history[index];\n      }\n      this.historyIndex = index;\n      this.cursor = this.line.length; // Set cursor to end of line.\n      this[kRefreshLine]();\n    }\n  }\n\n  [kHistoryPrev]() {\n    if (this.historyIndex < this.history.length && this.history.length) {\n      this[kBeforeEdit](this.line, this.cursor);\n      var search = this[kSubstringSearch] || \"\";\n      var index = this.historyIndex + 1;\n      while (\n        index < this.history.length &&\n        (!StringPrototypeStartsWith.call(this.history[index], search) || this.line === this.history[index])\n      ) {\n        index++;\n      }\n      if (index === this.history.length) {\n        this.line = search;\n      } else {\n        this.line = this.history[index];\n      }\n      this.historyIndex = index;\n      this.cursor = this.line.length; // Set cursor to end of line.\n      this[kRefreshLine]();\n    }\n  }\n\n  // Returns the last character's display position of the given string\n  [kGetDisplayPos](str) {\n    var offset = 0;\n    var col = this.columns;\n    var rows = 0;\n    str = stripVTControlCharacters(str);\n    for (var char of new SafeStringIterator(str)) {\n      if (char === \"\\n\") {\n        // Rows must be incremented by 1 even if offset = 0 or col = +Infinity.\n        rows += MathCeil(offset / col) || 1;\n        offset = 0;\n        continue;\n      }\n      // Tabs must be aligned by an offset of the tab size.\n      if (char === \"\\t\") {\n        offset += this.tabSize - (offset % this.tabSize);\n        continue;\n      }\n      var width = getStringWidth(char, false /* stripVTControlCharacters */);\n      if (width === 0 || width === 1) {\n        offset += width;\n      } else {\n        // width === 2\n        if ((offset + 1) % col === 0) {\n          offset++;\n        }\n        offset += 2;\n      }\n    }\n    var cols = offset % col;\n    rows += (offset - cols) / col;\n    return { cols, rows };\n  }\n\n  /**\n   * Returns the real position of the cursor in relation\n   * to the input prompt + string.\n   * @returns {{\n   *   rows: number;\n   *   cols: number;\n   * }}\n   */\n  getCursorPos() {\n    var strBeforeCursor = this[kPrompt] + StringPrototypeSlice.call(this.line, 0, this.cursor);\n    return this[kGetDisplayPos](strBeforeCursor);\n  }\n\n  // This function moves cursor dx places to the right\n  // (-dx for left) and refreshes the line if it is needed.\n  [kMoveCursor](dx) {\n    if (dx === 0) {\n      return;\n    }\n    var oldPos = this.getCursorPos();\n    this.cursor += dx;\n\n    // Bounds check\n    if (this.cursor < 0) {\n      this.cursor = 0;\n    } else if (this.cursor > this.line.length) {\n      this.cursor = this.line.length;\n    }\n\n    var newPos = this.getCursorPos();\n\n    // Check if cursor stayed on the line.\n    if (oldPos.rows === newPos.rows) {\n      var diffWidth = newPos.cols - oldPos.cols;\n      moveCursor(this.output, diffWidth, 0);\n    } else {\n      this[kRefreshLine]();\n    }\n  }\n\n  // Handle a write from the tty\n  [kTtyWrite](s, key) {\n    var previousKey = this[kPreviousKey];\n    key = key || kEmptyObject;\n    this[kPreviousKey] = key;\n    var { name: keyName, meta: keyMeta, ctrl: keyCtrl, shift: keyShift, sequence: keySeq } = key;\n\n    if (!keyMeta || keyName !== \"y\") {\n      // Reset yanking state unless we are doing yank pop.\n      this[kYanking] = false;\n    }\n\n    // Activate or deactivate substring search.\n    if ((keyName === \"up\" || keyName === \"down\") && !keyCtrl && !keyMeta && !keyShift) {\n      if (this[kSubstringSearch] === null) {\n        this[kSubstringSearch] = StringPrototypeSlice.call(this.line, 0, this.cursor);\n      }\n    } else if (this[kSubstringSearch] !== null) {\n      this[kSubstringSearch] = null;\n      // Reset the index in case there's no match.\n      if (this.history.length === this.historyIndex) {\n        this.historyIndex = -1;\n      }\n    }\n\n    // Undo & Redo\n    if (typeof keySeq === \"string\") {\n      switch (StringPrototypeCodePointAt.call(keySeq, 0)) {\n        case 0x1f:\n          this[kUndo]();\n          return;\n        case 0x1e:\n          this[kRedo]();\n          return;\n        default:\n          break;\n      }\n    }\n\n    // Ignore escape key, fixes\n    // https://github.com/nodejs/node-v0.x-archive/issues/2876.\n    if (keyName === \"escape\") return;\n\n    if (keyCtrl && keyShift) {\n      /* Control and shift pressed */\n      switch (keyName) {\n        // TODO(BridgeAR): The transmitted escape sequence is `\\b` and that is\n        // identical to <ctrl>-h. It should have a unique escape sequence.\n        case \"backspace\":\n          this[kDeleteLineLeft]();\n          break;\n\n        case \"delete\":\n          this[kDeleteLineRight]();\n          break;\n      }\n    } else if (keyCtrl) {\n      /* Control key pressed */\n\n      switch (keyName) {\n        case \"c\":\n          if (this.listenerCount(\"SIGINT\") > 0) {\n            this.emit(\"SIGINT\");\n          } else {\n            // This readline instance is finished\n            this.close();\n          }\n          break;\n\n        case \"h\": // delete left\n          this[kDeleteLeft]();\n          break;\n\n        case \"d\": // delete right or EOF\n          if (this.cursor === 0 && this.line.length === 0) {\n            // This readline instance is finished\n            this.close();\n          } else if (this.cursor < this.line.length) {\n            this[kDeleteRight]();\n          }\n          break;\n\n        case \"u\": // Delete from current to start of line\n          this[kDeleteLineLeft]();\n          break;\n\n        case \"k\": // Delete from current to end of line\n          this[kDeleteLineRight]();\n          break;\n\n        case \"a\": // Go to the start of the line\n          this[kMoveCursor](-Infinity);\n          break;\n\n        case \"e\": // Go to the end of the line\n          this[kMoveCursor](+Infinity);\n          break;\n\n        case \"b\": // back one character\n          this[kMoveCursor](-charLengthLeft(this.line, this.cursor));\n          break;\n\n        case \"f\": // Forward one character\n          this[kMoveCursor](+charLengthAt(this.line, this.cursor));\n          break;\n\n        case \"l\": // Clear the whole screen\n          cursorTo(this.output, 0, 0);\n          clearScreenDown(this.output);\n          this[kRefreshLine]();\n          break;\n\n        case \"n\": // next history item\n          this[kHistoryNext]();\n          break;\n\n        case \"p\": // Previous history item\n          this[kHistoryPrev]();\n          break;\n\n        case \"y\": // Yank killed string\n          this[kYank]();\n          break;\n\n        case \"z\":\n          if (process.platform === \"win32\") break;\n          if (this.listenerCount(\"SIGTSTP\") > 0) {\n            this.emit(\"SIGTSTP\");\n          } else {\n            process.once(\"SIGCONT\", () => {\n              // Don't raise events if stream has already been abandoned.\n              if (!this.paused) {\n                // Stream must be paused and resumed after SIGCONT to catch\n                // SIGINT, SIGTSTP, and EOF.\n                this.pause();\n                this.emit(\"SIGCONT\");\n              }\n              // Explicitly re-enable \"raw mode\" and move the cursor to\n              // the correct position.\n              // See https://github.com/joyent/node/issues/3295.\n              this[kSetRawMode](true);\n              this[kRefreshLine]();\n            });\n            this[kSetRawMode](false);\n            process.kill(process.pid, \"SIGTSTP\");\n          }\n          break;\n\n        case \"w\": // Delete backwards to a word boundary\n        case \"backspace\":\n          this[kDeleteWordLeft]();\n          break;\n\n        case \"delete\": // Delete forward to a word boundary\n          this[kDeleteWordRight]();\n          break;\n\n        case \"left\":\n          this[kWordLeft]();\n          break;\n\n        case \"right\":\n          this[kWordRight]();\n          break;\n      }\n    } else if (keyMeta) {\n      /* Meta key pressed */\n\n      switch (keyName) {\n        case \"b\": // backward word\n          this[kWordLeft]();\n          break;\n\n        case \"f\": // forward word\n          this[kWordRight]();\n          break;\n\n        case \"d\": // delete forward word\n        case \"delete\":\n          this[kDeleteWordRight]();\n          break;\n\n        case \"backspace\": // Delete backwards to a word boundary\n          this[kDeleteWordLeft]();\n          break;\n\n        case \"y\": // Doing yank pop\n          this[kYankPop]();\n          break;\n      }\n    } else {\n      /* No modifier keys used */\n\n      // \\r bookkeeping is only relevant if a \\n comes right after.\n      if (this[kSawReturnAt] && keyName !== \"enter\") this[kSawReturnAt] = 0;\n\n      switch (keyName) {\n        case \"return\": // Carriage return, i.e. \\r\n          this[kSawReturnAt] = DateNow();\n          this[kLine]();\n          break;\n\n        case \"enter\":\n          // When key interval > crlfDelay\n          if (this[kSawReturnAt] === 0 || DateNow() - this[kSawReturnAt] > this.crlfDelay) {\n            this[kLine]();\n          }\n          this[kSawReturnAt] = 0;\n          break;\n\n        case \"backspace\":\n          this[kDeleteLeft]();\n          break;\n\n        case \"delete\":\n          this[kDeleteRight]();\n          break;\n\n        case \"left\":\n          // Obtain the code point to the left\n          this[kMoveCursor](-charLengthLeft(this.line, this.cursor));\n          break;\n\n        case \"right\":\n          this[kMoveCursor](+charLengthAt(this.line, this.cursor));\n          break;\n\n        case \"home\":\n          this[kMoveCursor](-Infinity);\n          break;\n\n        case \"end\":\n          this[kMoveCursor](+Infinity);\n          break;\n\n        case \"up\":\n          this[kHistoryPrev]();\n          break;\n\n        case \"down\":\n          this[kHistoryNext]();\n          break;\n\n        case \"tab\":\n          // If tab completion enabled, do that...\n          if (typeof this.completer === \"function\" && this.isCompletionEnabled) {\n            var lastKeypressWasTab = previousKey && previousKey.name === \"tab\";\n            this[kTabComplete](lastKeypressWasTab);\n            break;\n          }\n        // falls through\n        default:\n          if (typeof s === \"string\" && s) {\n            var nextMatch = RegExpPrototypeExec.call(lineEnding, s);\n            if (nextMatch !== null) {\n              this[kInsertString](StringPrototypeSlice.call(s, 0, nextMatch.index));\n              var { lastIndex } = lineEnding;\n              while ((nextMatch = RegExpPrototypeExec.call(lineEnding, s)) !== null) {\n                this[kLine]();\n                this[kInsertString](StringPrototypeSlice.call(s, lastIndex, nextMatch.index));\n                ({ lastIndex } = lineEnding);\n              }\n              if (lastIndex === s.length) this[kLine]();\n            } else {\n              this[kInsertString](s);\n            }\n          }\n      }\n    }\n  }\n\n  /**\n   * Creates an `AsyncIterator` object that iterates through\n   * each line in the input stream as a string.\n   * @typedef {{\n   *   [Symbol.asyncIterator]: () => InterfaceAsyncIterator,\n   *   next: () => Promise<string>\n   * }} InterfaceAsyncIterator\n   * @returns {InterfaceAsyncIterator}\n   */\n  [SymbolAsyncIterator]() {\n    if (this[kLineObjectStream] === undefined) {\n      this[kLineObjectStream] = EventEmitter.on(this, \"line\", {\n        close: [\"close\"],\n        highWatermark: 1024,\n        [kFirstEventParam]: true,\n      });\n    }\n    return this[kLineObjectStream];\n  }\n};\n\nfunction Interface(input, output, completer, terminal) {\n  if (!(this instanceof Interface)) {\n    return new Interface(input, output, completer, terminal);\n  }\n\n  if (input?.input && typeof input.completer === \"function\" && input.completer.length !== 2) {\n    var { completer } = input;\n    input.completer = (v, cb) => cb(null, completer(v));\n  } else if (typeof completer === \"function\" && completer.length !== 2) {\n    var realCompleter = completer;\n    completer = (v, cb) => cb(null, realCompleter(v));\n  }\n\n  InterfaceConstructor.call(this, input, output, completer, terminal);\n\n  // TODO: Test this\n  if (process.env.TERM === \"dumb\") {\n    this._ttyWrite = _ttyWriteDumb.bind(this);\n  }\n}\n\nObjectSetPrototypeOf(Interface.prototype, _Interface.prototype);\nObjectSetPrototypeOf(Interface, _Interface);\n\n/**\n * Displays `query` by writing it to the `output`.\n * @param {string} query\n * @param {{ signal?: AbortSignal; }} [options]\n * @param {Function} cb\n * @returns {void}\n */\nInterface.prototype.question = function question(query, options, cb) {\n  cb = typeof options === \"function\" ? options : cb;\n  if (options === null || typeof options !== \"object\") {\n    options = kEmptyObject;\n  }\n\n  var signal = options?.signal;\n  if (signal) {\n    validateAbortSignal(signal, \"options.signal\");\n    if (signal.aborted) {\n      return;\n    }\n\n    var onAbort = () => {\n      this[kQuestionCancel]();\n    };\n    signal.addEventListener(\"abort\", onAbort, { once: true });\n    var cleanup = () => {\n      signal.removeEventListener(\"abort\", onAbort);\n    };\n    var originalCb = cb;\n    cb =\n      typeof cb === \"function\"\n        ? answer => {\n            cleanup();\n            return originalCb(answer);\n          }\n        : cleanup;\n  }\n\n  if (typeof cb === \"function\") {\n    this[kQuestion](query, cb);\n  }\n};\n\nInterface.prototype.question[promisify.custom] = function question(query, options) {\n  if (options === null || typeof options !== \"object\") {\n    options = kEmptyObject;\n  }\n\n  var signal = options?.signal;\n\n  if (signal && signal.aborted) {\n    return PromiseReject(new AbortError(undefined, { cause: signal.reason }));\n  }\n\n  return new Promise((resolve, reject) => {\n    var cb = resolve;\n    if (signal) {\n      var onAbort = () => {\n        reject(new AbortError(undefined, { cause: signal.reason }));\n      };\n      signal.addEventListener(\"abort\", onAbort, { once: true });\n      cb = answer => {\n        signal.removeEventListener(\"abort\", onAbort);\n        resolve(answer);\n      };\n    }\n    this.question(query, options, cb);\n  });\n};\n\n/**\n * Creates a new `readline.Interface` instance.\n * @param {Readable | {\n *   input: Readable;\n *   output: Writable;\n *   completer?: Function;\n *   terminal?: boolean;\n *   history?: string[];\n *   historySize?: number;\n *   removeHistoryDuplicates?: boolean;\n *   prompt?: string;\n *   crlfDelay?: number;\n *   escapeCodeTimeout?: number;\n *   tabSize?: number;\n *   signal?: AbortSignal;\n *   }} input\n * @param {Writable} [output]\n * @param {Function} [completer]\n * @param {boolean} [terminal]\n * @returns {Interface}\n */\nfunction createInterface(input, output, completer, terminal) {\n  return new Interface(input, output, completer, terminal);\n}\n\nObjectDefineProperties(Interface.prototype, {\n  // Redirect internal prototype methods to the underscore notation for backward\n  // compatibility.\n  [kSetRawMode]: {\n    __proto__: null,\n    get() {\n      return this._setRawMode;\n    },\n  },\n  [kOnLine]: {\n    __proto__: null,\n    get() {\n      return this._onLine;\n    },\n  },\n  [kWriteToOutput]: {\n    __proto__: null,\n    get() {\n      return this._writeToOutput;\n    },\n  },\n  [kAddHistory]: {\n    __proto__: null,\n    get() {\n      return this._addHistory;\n    },\n  },\n  [kRefreshLine]: {\n    __proto__: null,\n    get() {\n      return this._refreshLine;\n    },\n  },\n  [kNormalWrite]: {\n    __proto__: null,\n    get() {\n      return this._normalWrite;\n    },\n  },\n  [kInsertString]: {\n    __proto__: null,\n    get() {\n      return this._insertString;\n    },\n  },\n  [kTabComplete]: {\n    __proto__: null,\n    get() {\n      return this._tabComplete;\n    },\n  },\n  [kWordLeft]: {\n    __proto__: null,\n    get() {\n      return this._wordLeft;\n    },\n  },\n  [kWordRight]: {\n    __proto__: null,\n    get() {\n      return this._wordRight;\n    },\n  },\n  [kDeleteLeft]: {\n    __proto__: null,\n    get() {\n      return this._deleteLeft;\n    },\n  },\n  [kDeleteRight]: {\n    __proto__: null,\n    get() {\n      return this._deleteRight;\n    },\n  },\n  [kDeleteWordLeft]: {\n    __proto__: null,\n    get() {\n      return this._deleteWordLeft;\n    },\n  },\n  [kDeleteWordRight]: {\n    __proto__: null,\n    get() {\n      return this._deleteWordRight;\n    },\n  },\n  [kDeleteLineLeft]: {\n    __proto__: null,\n    get() {\n      return this._deleteLineLeft;\n    },\n  },\n  [kDeleteLineRight]: {\n    __proto__: null,\n    get() {\n      return this._deleteLineRight;\n    },\n  },\n  [kLine]: {\n    __proto__: null,\n    get() {\n      return this._line;\n    },\n  },\n  [kHistoryNext]: {\n    __proto__: null,\n    get() {\n      return this._historyNext;\n    },\n  },\n  [kHistoryPrev]: {\n    __proto__: null,\n    get() {\n      return this._historyPrev;\n    },\n  },\n  [kGetDisplayPos]: {\n    __proto__: null,\n    get() {\n      return this._getDisplayPos;\n    },\n  },\n  [kMoveCursor]: {\n    __proto__: null,\n    get() {\n      return this._moveCursor;\n    },\n  },\n  [kTtyWrite]: {\n    __proto__: null,\n    get() {\n      return this._ttyWrite;\n    },\n  },\n\n  // Defining proxies for the internal instance properties for backward\n  // compatibility.\n  _decoder: {\n    __proto__: null,\n    get() {\n      return this[kDecoder];\n    },\n    set(value) {\n      this[kDecoder] = value;\n    },\n  },\n  _line_buffer: {\n    __proto__: null,\n    get() {\n      return this[kLine_buffer];\n    },\n    set(value) {\n      this[kLine_buffer] = value;\n    },\n  },\n  _oldPrompt: {\n    __proto__: null,\n    get() {\n      return this[kOldPrompt];\n    },\n    set(value) {\n      this[kOldPrompt] = value;\n    },\n  },\n  _previousKey: {\n    __proto__: null,\n    get() {\n      return this[kPreviousKey];\n    },\n    set(value) {\n      this[kPreviousKey] = value;\n    },\n  },\n  _prompt: {\n    __proto__: null,\n    get() {\n      return this[kPrompt];\n    },\n    set(value) {\n      this[kPrompt] = value;\n    },\n  },\n  _questionCallback: {\n    __proto__: null,\n    get() {\n      return this[kQuestionCallback];\n    },\n    set(value) {\n      this[kQuestionCallback] = value;\n    },\n  },\n  _sawKeyPress: {\n    __proto__: null,\n    get() {\n      return this[kSawKeyPress];\n    },\n    set(value) {\n      this[kSawKeyPress] = value;\n    },\n  },\n  _sawReturnAt: {\n    __proto__: null,\n    get() {\n      return this[kSawReturnAt];\n    },\n    set(value) {\n      this[kSawReturnAt] = value;\n    },\n  },\n});\n\n// Make internal methods public for backward compatibility.\nInterface.prototype._setRawMode = _Interface.prototype[kSetRawMode];\nInterface.prototype._onLine = _Interface.prototype[kOnLine];\nInterface.prototype._writeToOutput = _Interface.prototype[kWriteToOutput];\nInterface.prototype._addHistory = _Interface.prototype[kAddHistory];\nInterface.prototype._refreshLine = _Interface.prototype[kRefreshLine];\nInterface.prototype._normalWrite = _Interface.prototype[kNormalWrite];\nInterface.prototype._insertString = _Interface.prototype[kInsertString];\nInterface.prototype._tabComplete = function (lastKeypressWasTab) {\n  // Overriding parent method because `this.completer` in the legacy\n  // implementation takes a callback instead of being an async function.\n  this.pause();\n  var string = StringPrototypeSlice.call(this.line, 0, this.cursor);\n  this.completer(string, (err, value) => {\n    this.resume();\n\n    if (err) {\n      this._writeToOutput(`Tab completion error: ${inspect(err)}`);\n      return;\n    }\n\n    this[kTabCompleter](lastKeypressWasTab, value);\n  });\n};\nInterface.prototype._wordLeft = _Interface.prototype[kWordLeft];\nInterface.prototype._wordRight = _Interface.prototype[kWordRight];\nInterface.prototype._deleteLeft = _Interface.prototype[kDeleteLeft];\nInterface.prototype._deleteRight = _Interface.prototype[kDeleteRight];\nInterface.prototype._deleteWordLeft = _Interface.prototype[kDeleteWordLeft];\nInterface.prototype._deleteWordRight = _Interface.prototype[kDeleteWordRight];\nInterface.prototype._deleteLineLeft = _Interface.prototype[kDeleteLineLeft];\nInterface.prototype._deleteLineRight = _Interface.prototype[kDeleteLineRight];\nInterface.prototype._line = _Interface.prototype[kLine];\nInterface.prototype._historyNext = _Interface.prototype[kHistoryNext];\nInterface.prototype._historyPrev = _Interface.prototype[kHistoryPrev];\nInterface.prototype._getDisplayPos = _Interface.prototype[kGetDisplayPos];\nInterface.prototype._getCursorPos = _Interface.prototype.getCursorPos;\nInterface.prototype._moveCursor = _Interface.prototype[kMoveCursor];\nInterface.prototype._ttyWrite = _Interface.prototype[kTtyWrite];\n\nfunction _ttyWriteDumb(s, key) {\n  key = key || kEmptyObject;\n\n  if (key.name === \"escape\") return;\n\n  if (this[kSawReturnAt] && key.name !== \"enter\") this[kSawReturnAt] = 0;\n\n  if (keyCtrl) {\n    if (key.name === \"c\") {\n      if (this.listenerCount(\"SIGINT\") > 0) {\n        this.emit(\"SIGINT\");\n      } else {\n        // This readline instance is finished\n        this.close();\n      }\n\n      return;\n    } else if (key.name === \"d\") {\n      this.close();\n      return;\n    }\n  }\n\n  switch (key.name) {\n    case \"return\": // Carriage return, i.e. \\r\n      this[kSawReturnAt] = DateNow();\n      this._line();\n      break;\n\n    case \"enter\":\n      // When key interval > crlfDelay\n      if (this[kSawReturnAt] === 0 || DateNow() - this[kSawReturnAt] > this.crlfDelay) {\n        this._line();\n      }\n      this[kSawReturnAt] = 0;\n      break;\n\n    default:\n      if (typeof s === \"string\" && s) {\n        this.line += s;\n        this.cursor += s.length;\n        this._writeToOutput(s);\n      }\n  }\n}\n\nclass Readline {\n  #autoCommit = false;\n  #stream;\n  #todo = [];\n\n  constructor(stream, options = undefined) {\n    isWritable ??= import.meta.require(\"node:stream\").isWritable;\n    if (!isWritable(stream)) throw new ERR_INVALID_ARG_TYPE(\"stream\", \"Writable\", stream);\n    this.#stream = stream;\n    if (options?.autoCommit != null) {\n      validateBoolean(options.autoCommit, \"options.autoCommit\");\n      this.#autoCommit = options.autoCommit;\n    }\n  }\n\n  /**\n   * Moves the cursor to the x and y coordinate on the given stream.\n   * @param {integer} x\n   * @param {integer} [y]\n   * @returns {Readline} this\n   */\n  cursorTo(x, y = undefined) {\n    validateInteger(x, \"x\");\n    if (y != null) validateInteger(y, \"y\");\n\n    var data = y == null ? CSI`${x + 1}G` : CSI`${y + 1};${x + 1}H`;\n    if (this.#autoCommit) process.nextTick(() => this.#stream.write(data));\n    else ArrayPrototypePush.call(this.#todo, data);\n\n    return this;\n  }\n\n  /**\n   * Moves the cursor relative to its current location.\n   * @param {integer} dx\n   * @param {integer} dy\n   * @returns {Readline} this\n   */\n  moveCursor(dx, dy) {\n    if (dx || dy) {\n      validateInteger(dx, \"dx\");\n      validateInteger(dy, \"dy\");\n\n      var data = \"\";\n\n      if (dx < 0) {\n        data += CSI`${-dx}D`;\n      } else if (dx > 0) {\n        data += CSI`${dx}C`;\n      }\n\n      if (dy < 0) {\n        data += CSI`${-dy}A`;\n      } else if (dy > 0) {\n        data += CSI`${dy}B`;\n      }\n      if (this.#autoCommit) process.nextTick(() => this.#stream.write(data));\n      else ArrayPrototypePush.call(this.#todo, data);\n    }\n    return this;\n  }\n\n  /**\n   * Clears the current line the cursor is on.\n   * @param {-1|0|1} dir Direction to clear:\n   *   -1 for left of the cursor\n   *   +1 for right of the cursor\n   *    0 for the entire line\n   * @returns {Readline} this\n   */\n  clearLine(dir) {\n    validateInteger(dir, \"dir\", -1, 1);\n\n    var data = dir < 0 ? kClearToLineBeginning : dir > 0 ? kClearToLineEnd : kClearLine;\n    if (this.#autoCommit) process.nextTick(() => this.#stream.write(data));\n    else ArrayPrototypePush.call(this.#todo, data);\n    return this;\n  }\n\n  /**\n   * Clears the screen from the current position of the cursor down.\n   * @returns {Readline} this\n   */\n  clearScreenDown() {\n    if (this.#autoCommit) {\n      process.nextTick(() => this.#stream.write(kClearScreenDown));\n    } else {\n      ArrayPrototypePush.call(this.#todo, kClearScreenDown);\n    }\n    return this;\n  }\n\n  /**\n   * Sends all the pending actions to the associated `stream` and clears the\n   * internal list of pending actions.\n   * @returns {Promise<void>} Resolves when all pending actions have been\n   * flushed to the associated `stream`.\n   */\n  commit() {\n    return new Promise(resolve => {\n      this.#stream.write(ArrayPrototypeJoin.call(this.#todo, \"\"), resolve);\n      this.#todo = [];\n    });\n  }\n\n  /**\n   * Clears the internal list of pending actions without sending it to the\n   * associated `stream`.\n   * @returns {Readline} this\n   */\n  rollback() {\n    this.#todo = [];\n    return this;\n  }\n}\n\nvar PromisesInterface = class Interface extends _Interface {\n  // eslint-disable-next-line no-useless-constructor\n  constructor(input, output, completer, terminal) {\n    super(input, output, completer, terminal);\n  }\n  question(query, options = kEmptyObject) {\n    var signal = options?.signal;\n    if (signal) {\n      validateAbortSignal(signal, \"options.signal\");\n      if (signal.aborted) {\n        return PromiseReject(new AbortError(undefined, { cause: signal.reason }));\n      }\n    }\n    return new Promise((resolve, reject) => {\n      var cb = resolve;\n      if (options?.signal) {\n        var onAbort = () => {\n          this[kQuestionCancel]();\n          reject(new AbortError(undefined, { cause: signal.reason }));\n        };\n        signal.addEventListener(\"abort\", onAbort, { once: true });\n        cb = answer => {\n          signal.removeEventListener(\"abort\", onAbort);\n          resolve(answer);\n        };\n      }\n      this[kQuestion](query, cb);\n    });\n  }\n};\n\n// ----------------------------------------------------------------------------\n// Exports\n// ----------------------------------------------------------------------------\nexport var Interface = Interface;\nexport var clearLine = clearLine;\nexport var clearScreenDown = clearScreenDown;\nexport var createInterface = createInterface;\nexport var cursorTo = cursorTo;\nexport var emitKeypressEvents = emitKeypressEvents;\nexport var moveCursor = moveCursor;\nexport var promises = {\n  Readline,\n  Interface: PromisesInterface,\n  createInterface(input, output, completer, terminal) {\n    return new PromisesInterface(input, output, completer, terminal);\n  },\n};\n\nexport default {\n  Interface,\n  clearLine,\n  clearScreenDown,\n  createInterface,\n  cursorTo,\n  emitKeypressEvents,\n  moveCursor,\n  promises,\n\n  [SymbolFor(\"__BUN_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED__\")]: {\n    CSI,\n    utils: {\n      getStringWidth,\n      stripVTControlCharacters,\n    },\n  },\n  [SymbolFor(\"CommonJS\")]: 0,\n};\n",
  "// Hardcoded module \"node:readline\"\n// Attribution: Some parts of of this module are derived from code originating from the Node.js\n// readline module which is licensed under an MIT license:\n//\n// Copyright Node.js contributors. All rights reserved.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to\n// deal in the Software without restriction, including without limitation the\n// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n// sell copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n// IN THE SOFTWARE.\n\n// ----------------------------------------------------------------------------\n// Section: Imports\n// ----------------------------------------------------------------------------\nvar { Array, RegExp, String, Bun } = import.meta.primordials;\nvar EventEmitter = import.meta.require(\"node:events\");\nvar { clearTimeout, setTimeout } = import.meta.require(\"timers\");\nvar { StringDecoder } = import.meta.require(\"string_decoder\");\nvar isWritable;\n\nvar { inspect } = Bun;\nvar debug = process.env.BUN_JS_DEBUG ? console.log : () => {};\n\n// ----------------------------------------------------------------------------\n// Section: Preamble\n// ----------------------------------------------------------------------------\n\nvar SymbolAsyncIterator = Symbol.asyncIterator;\nvar SymbolIterator = Symbol.iterator;\nvar SymbolFor = Symbol.for;\nvar SymbolReplace = Symbol.replace;\nvar ArrayFrom = Array.from;\nvar ArrayIsArray = Array.isArray;\nvar ArrayPrototypeFilter = Array.prototype.filter;\nvar ArrayPrototypeSort = Array.prototype.sort;\nvar ArrayPrototypeIndexOf = Array.prototype.indexOf;\nvar ArrayPrototypeJoin = Array.prototype.join;\nvar ArrayPrototypeMap = Array.prototype.map;\nvar ArrayPrototypePop = Array.prototype.pop;\nvar ArrayPrototypePush = Array.prototype.push;\nvar ArrayPrototypeSlice = Array.prototype.slice;\nvar ArrayPrototypeSplice = Array.prototype.splice;\nvar ArrayPrototypeReverse = Array.prototype.reverse;\nvar ArrayPrototypeShift = Array.prototype.shift;\nvar ArrayPrototypeUnshift = Array.prototype.unshift;\nvar RegExpPrototypeExec = RegExp.prototype.exec;\nvar RegExpPrototypeSymbolReplace = RegExp.prototype[SymbolReplace];\nvar StringFromCharCode = String.fromCharCode;\nvar StringPrototypeCharCodeAt = String.prototype.charCodeAt;\nvar StringPrototypeCodePointAt = String.prototype.codePointAt;\nvar StringPrototypeSlice = String.prototype.slice;\nvar StringPrototypeToLowerCase = String.prototype.toLowerCase;\nvar StringPrototypeEndsWith = String.prototype.endsWith;\nvar StringPrototypeRepeat = String.prototype.repeat;\nvar StringPrototypeStartsWith = String.prototype.startsWith;\nvar StringPrototypeTrim = String.prototype.trim;\nvar StringPrototypeNormalize = String.prototype.normalize;\nvar NumberIsNaN = Number.isNaN;\nvar NumberIsFinite = Number.isFinite;\nvar NumberIsInteger = Number.isInteger;\nvar NumberMAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER;\nvar NumberMIN_SAFE_INTEGER = Number.MIN_SAFE_INTEGER;\nvar MathCeil = Math.ceil;\nvar MathFloor = Math.floor;\nvar MathMax = Math.max;\nvar MathMaxApply = Math.max.apply;\nvar DateNow = Date.now;\nvar FunctionPrototype = Function.prototype;\nvar StringPrototype = String.prototype;\nvar StringPrototypeSymbolIterator = StringPrototype[SymbolIterator];\nvar StringIteratorPrototypeNext = StringPrototypeSymbolIterator.call(\"\").next;\nvar ObjectSetPrototypeOf = Object.setPrototypeOf;\nvar ObjectDefineProperty = Object.defineProperty;\nvar ObjectDefineProperties = Object.defineProperties;\nvar ObjectFreeze = Object.freeze;\nvar ObjectAssign = Object.assign;\nvar ObjectCreate = Object.create;\nvar ObjectKeys = Object.keys;\nvar ObjectSeal = Object.seal;\n\nvar createSafeIterator = (factory, next) => {\n  class SafeIterator {\n    #iterator;\n    constructor(iterable) {\n      this.#iterator = factory.call(iterable);\n    }\n    next() {\n      return next.call(this.#iterator);\n    }\n    [SymbolIterator]() {\n      return this;\n    }\n  }\n  ObjectSetPrototypeOf(SafeIterator.prototype, null);\n  ObjectFreeze(SafeIterator.prototype);\n  ObjectFreeze(SafeIterator);\n  return SafeIterator;\n};\n\nvar SafeStringIterator = createSafeIterator(StringPrototypeSymbolIterator, StringIteratorPrototypeNext);\n\n// ----------------------------------------------------------------------------\n// Section: \"Internal\" modules\n// ----------------------------------------------------------------------------\n\n/**\n * Returns true if the character represented by a given\n * Unicode code point is full-width. Otherwise returns false.\n */\nvar isFullWidthCodePoint = code => {\n  // Code points are partially derived from:\n  // https://www.unicode.org/Public/UNIDATA/EastAsianWidth.txt\n  return (\n    code >= 0x1100 &&\n    (code <= 0x115f || // Hangul Jamo\n      code === 0x2329 || // LEFT-POINTING ANGLE BRACKET\n      code === 0x232a || // RIGHT-POINTING ANGLE BRACKET\n      // CJK Radicals Supplement .. Enclosed CJK Letters and Months\n      (code >= 0x2e80 && code <= 0x3247 && code !== 0x303f) ||\n      // Enclosed CJK Letters and Months .. CJK Unified Ideographs Extension A\n      (code >= 0x3250 && code <= 0x4dbf) ||\n      // CJK Unified Ideographs .. Yi Radicals\n      (code >= 0x4e00 && code <= 0xa4c6) ||\n      // Hangul Jamo Extended-A\n      (code >= 0xa960 && code <= 0xa97c) ||\n      // Hangul Syllables\n      (code >= 0xac00 && code <= 0xd7a3) ||\n      // CJK Compatibility Ideographs\n      (code >= 0xf900 && code <= 0xfaff) ||\n      // Vertical Forms\n      (code >= 0xfe10 && code <= 0xfe19) ||\n      // CJK Compatibility Forms .. Small Form Variants\n      (code >= 0xfe30 && code <= 0xfe6b) ||\n      // Halfwidth and Fullwidth Forms\n      (code >= 0xff01 && code <= 0xff60) ||\n      (code >= 0xffe0 && code <= 0xffe6) ||\n      // Kana Supplement\n      (code >= 0x1b000 && code <= 0x1b001) ||\n      // Enclosed Ideographic Supplement\n      (code >= 0x1f200 && code <= 0x1f251) ||\n      // Miscellaneous Symbols and Pictographs 0x1f300 - 0x1f5ff\n      // Emoticons 0x1f600 - 0x1f64f\n      (code >= 0x1f300 && code <= 0x1f64f) ||\n      // CJK Unified Ideographs Extension B .. Tertiary Ideographic Plane\n      (code >= 0x20000 && code <= 0x3fffd))\n  );\n};\n\nvar isZeroWidthCodePoint = code => {\n  return (\n    code <= 0x1f || // C0 control codes\n    (code >= 0x7f && code <= 0x9f) || // C1 control codes\n    (code >= 0x300 && code <= 0x36f) || // Combining Diacritical Marks\n    (code >= 0x200b && code <= 0x200f) || // Modifying Invisible Characters\n    // Combining Diacritical Marks for Symbols\n    (code >= 0x20d0 && code <= 0x20ff) ||\n    (code >= 0xfe00 && code <= 0xfe0f) || // Variation Selectors\n    (code >= 0xfe20 && code <= 0xfe2f) || // Combining Half Marks\n    (code >= 0xe0100 && code <= 0xe01ef)\n  ); // Variation Selectors\n};\n\n/**\n * Returns the number of columns required to display the given string.\n */\nvar getStringWidth = function getStringWidth(str, removeControlChars = true) {\n  var width = 0;\n\n  if (removeControlChars) str = stripVTControlCharacters(str);\n  str = StringPrototypeNormalize.call(str, \"NFC\");\n  for (var char of new SafeStringIterator(str)) {\n    var code = StringPrototypeCodePointAt.call(char, 0);\n    if (isFullWidthCodePoint(code)) {\n      width += 2;\n    } else if (!isZeroWidthCodePoint(code)) {\n      width++;\n    }\n  }\n\n  return width;\n};\n\n// Regex used for ansi escape code splitting\n// Adopted from https://github.com/chalk/ansi-regex/blob/HEAD/index.js\n// License: MIT, authors: @sindresorhus, Qix-, arjunmehta and LitoMore\n// Matches all ansi escape code sequences in a string\nvar ansiPattern =\n  \"[\\\\u001B\\\\u009B][[\\\\]()#;?]*\" +\n  \"(?:(?:(?:(?:;[-a-zA-Z\\\\d\\\\/#&.:=?%@~_]+)*\" +\n  \"|[a-zA-Z\\\\d]+(?:;[-a-zA-Z\\\\d\\\\/#&.:=?%@~_]*)*)?\\\\u0007)\" +\n  \"|(?:(?:\\\\d{1,4}(?:;\\\\d{0,4})*)?[\\\\dA-PR-TZcf-ntqry=><~]))\";\nvar ansi = new RegExp(ansiPattern, \"g\");\n\n/**\n * Remove all VT control characters. Use to estimate displayed string width.\n */\nfunction stripVTControlCharacters(str) {\n  validateString(str, \"str\");\n  return RegExpPrototypeSymbolReplace.call(ansi, str, \"\");\n}\n\n// Promisify\n\nvar kCustomPromisifiedSymbol = SymbolFor(\"nodejs.util.promisify.custom\");\nvar kCustomPromisifyArgsSymbol = Symbol(\"customPromisifyArgs\");\n\nfunction promisify(original) {\n  validateFunction(original, \"original\");\n\n  if (original[kCustomPromisifiedSymbol]) {\n    var fn = original[kCustomPromisifiedSymbol];\n\n    validateFunction(fn, \"util.promisify.custom\");\n\n    return ObjectDefineProperty(fn, kCustomPromisifiedSymbol, {\n      __proto__: null,\n      value: fn,\n      enumerable: false,\n      writable: false,\n      configurable: true,\n    });\n  }\n\n  // Names to create an object from in case the callback receives multiple\n  // arguments, e.g. ['bytesRead', 'buffer'] for fs.read.\n  var argumentNames = original[kCustomPromisifyArgsSymbol];\n\n  function fn(...args) {\n    return new Promise((resolve, reject) => {\n      ArrayPrototypePush.call(args, (err, ...values) => {\n        if (err) {\n          return reject(err);\n        }\n        if (argumentNames !== undefined && values.length > 1) {\n          var obj = {};\n          for (var i = 0; i < argumentNames.length; i++) obj[argumentNames[i]] = values[i];\n          resolve(obj);\n        } else {\n          resolve(values[0]);\n        }\n      });\n      ReflectApply(original, this, args);\n    });\n  }\n\n  ObjectSetPrototypeOf(fn, ObjectGetPrototypeOf(original));\n\n  ObjectDefineProperty(fn, kCustomPromisifiedSymbol, {\n    __proto__: null,\n    value: fn,\n    enumerable: false,\n    writable: false,\n    configurable: true,\n  });\n\n  var descriptors = ObjectGetOwnPropertyDescriptors(original);\n  var propertiesValues = ObjectValues(descriptors);\n  for (var i = 0; i < propertiesValues.length; i++) {\n    // We want to use null-prototype objects to not rely on globally mutable\n    // %Object.prototype%.\n    ObjectSetPrototypeOf(propertiesValues[i], null);\n  }\n  return ObjectDefineProperties(fn, descriptors);\n}\n\npromisify.custom = kCustomPromisifiedSymbol;\n\n// Constants\n\nvar kUTF16SurrogateThreshold = 0x10000; // 2 ** 16\nvar kEscape = \"\\x1b\";\nvar kSubstringSearch = Symbol(\"kSubstringSearch\");\n\nvar kIsNodeError = Symbol(\"kIsNodeError\");\n\n// Errors\nvar errorBases = {};\nvar VALID_NODE_ERROR_BASES = {\n  TypeError,\n  RangeError,\n  Error,\n};\n\nfunction getNodeErrorByName(typeName) {\n  var base = errorBases[typeName];\n  if (base) {\n    return base;\n  }\n  if (!ObjectKeys(VALID_NODE_ERROR_BASES).includes(typeName)) {\n    throw new Error(\"Invalid NodeError type\");\n  }\n\n  var Base = VALID_NODE_ERROR_BASES[typeName];\n\n  class NodeError extends Base {\n    [kIsNodeError] = true;\n    code;\n    constructor(msg, opts) {\n      super(msg, opts);\n      this.code = opts?.code || \"ERR_GENERIC\";\n    }\n\n    toString() {\n      return `${this.name} [${this.code}]: ${this.message}`;\n    }\n  }\n  errorBases[typeName] = NodeError;\n  return NodeError;\n}\n\nvar NodeError = getNodeErrorByName(\"Error\");\nvar NodeTypeError = getNodeErrorByName(\"TypeError\");\nvar NodeRangeError = getNodeErrorByName(\"RangeError\");\n\nclass ERR_INVALID_ARG_TYPE extends NodeTypeError {\n  constructor(name, type, value) {\n    super(`The \"${name}\" argument must be of type ${type}. Received type ${typeof value}`, {\n      code: \"ERR_INVALID_ARG_TYPE\",\n    });\n  }\n}\n\nclass ERR_INVALID_ARG_VALUE extends NodeTypeError {\n  constructor(name, value, reason = \"not specified\") {\n    super(`The value \"${String(value)}\" is invalid for argument '${name}'. Reason: ${reason}`, {\n      code: \"ERR_INVALID_ARG_VALUE\",\n    });\n  }\n}\n\nclass ERR_INVALID_CURSOR_POS extends NodeTypeError {\n  constructor() {\n    super(\"Cannot set cursor row without setting its column\", {\n      code: \"ERR_INVALID_CURSOR_POS\",\n    });\n  }\n}\n\nclass ERR_OUT_OF_RANGE extends NodeRangeError {\n  constructor(name, range, received) {\n    super(`The value of \"${name}\" is out of range. It must be ${range}. Received ${received}`, {\n      code: \"ERR_OUT_OF_RANGE\",\n    });\n  }\n}\n\nclass ERR_USE_AFTER_CLOSE extends NodeError {\n  constructor() {\n    super(\"This socket has been ended by the other party\", {\n      code: \"ERR_USE_AFTER_CLOSE\",\n    });\n  }\n}\n\nclass AbortError extends Error {\n  code;\n  constructor() {\n    super(\"The operation was aborted\");\n    this.code = \"ABORT_ERR\";\n  }\n}\n\n// Validators\n\n/**\n * @callback validateFunction\n * @param {*} value\n * @param {string} name\n * @returns {asserts value is Function}\n */\nfunction validateFunction(value, name) {\n  if (typeof value !== \"function\") throw new ERR_INVALID_ARG_TYPE(name, \"Function\", value);\n}\n\n/**\n * @callback validateAbortSignal\n * @param {*} signal\n * @param {string} name\n */\nfunction validateAbortSignal(signal, name) {\n  if (signal !== undefined && (signal === null || typeof signal !== \"object\" || !(\"aborted\" in signal))) {\n    throw new ERR_INVALID_ARG_TYPE(name, \"AbortSignal\", signal);\n  }\n}\n\n/**\n * @callback validateArray\n * @param {*} value\n * @param {string} name\n * @param {number} [minLength]\n * @returns {asserts value is any[]}\n */\nfunction validateArray(value, name, minLength = 0) {\n  // var validateArray = hideStackFrames((value, name, minLength = 0) => {\n  if (!ArrayIsArray(value)) {\n    throw new ERR_INVALID_ARG_TYPE(name, \"Array\", value);\n  }\n  if (value.length < minLength) {\n    var reason = `must be longer than ${minLength}`;\n    throw new ERR_INVALID_ARG_VALUE(name, value, reason);\n  }\n}\n\n/**\n * @callback validateString\n * @param {*} value\n * @param {string} name\n * @returns {asserts value is string}\n */\nfunction validateString(value, name) {\n  if (typeof value !== \"string\") throw new ERR_INVALID_ARG_TYPE(name, \"string\", value);\n}\n\n/**\n * @callback validateBoolean\n * @param {*} value\n * @param {string} name\n * @returns {asserts value is boolean}\n */\nfunction validateBoolean(value, name) {\n  if (typeof value !== \"boolean\") throw new ERR_INVALID_ARG_TYPE(name, \"boolean\", value);\n}\n\n/**\n * @callback validateObject\n * @param {*} value\n * @param {string} name\n * @param {{\n *   allowArray?: boolean,\n *   allowFunction?: boolean,\n *   nullable?: boolean\n * }} [options]\n */\nfunction validateObject(value, name, options = null) {\n  // var validateObject = hideStackFrames((value, name, options = null) => {\n  var allowArray = options?.allowArray ?? false;\n  var allowFunction = options?.allowFunction ?? false;\n  var nullable = options?.nullable ?? false;\n  if (\n    (!nullable && value === null) ||\n    (!allowArray && ArrayIsArray.call(value)) ||\n    (typeof value !== \"object\" && (!allowFunction || typeof value !== \"function\"))\n  ) {\n    throw new ERR_INVALID_ARG_TYPE(name, \"object\", value);\n  }\n}\n\n/**\n * @callback validateInteger\n * @param {*} value\n * @param {string} name\n * @param {number} [min]\n * @param {number} [max]\n * @returns {asserts value is number}\n */\nfunction validateInteger(value, name, min = NumberMIN_SAFE_INTEGER, max = NumberMAX_SAFE_INTEGER) {\n  if (typeof value !== \"number\") throw new ERR_INVALID_ARG_TYPE(name, \"number\", value);\n  if (!NumberIsInteger(value)) throw new ERR_OUT_OF_RANGE(name, \"an integer\", value);\n  if (value < min || value > max) throw new ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value);\n}\n\n/**\n * @callback validateUint32\n * @param {*} value\n * @param {string} name\n * @param {number|boolean} [positive=false]\n * @returns {asserts value is number}\n */\nfunction validateUint32(value, name, positive = false) {\n  if (typeof value !== \"number\") {\n    throw new ERR_INVALID_ARG_TYPE(name, \"number\", value);\n  }\n\n  if (!NumberIsInteger(value)) {\n    throw new ERR_OUT_OF_RANGE(name, \"an integer\", value);\n  }\n\n  var min = positive ? 1 : 0; // 2 ** 32 === 4294967296\n  var max = 4_294_967_295;\n\n  if (value < min || value > max) {\n    throw new ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value);\n  }\n}\n\n// ----------------------------------------------------------------------------\n// Section: Utils\n// ----------------------------------------------------------------------------\n\nfunction CSI(strings, ...args) {\n  var ret = `${kEscape}[`;\n  for (var n = 0; n < strings.length; n++) {\n    ret += strings[n];\n    if (n < args.length) ret += args[n];\n  }\n  return ret;\n}\n\nvar kClearLine, kClearScreenDown, kClearToLineBeginning, kClearToLineEnd;\n\nCSI.kEscape = kEscape;\nCSI.kClearLine = kClearLine = CSI`2K`;\nCSI.kClearScreenDown = kClearScreenDown = CSI`0J`;\nCSI.kClearToLineBeginning = kClearToLineBeginning = CSI`1K`;\nCSI.kClearToLineEnd = kClearToLineEnd = CSI`0K`;\n\nfunction charLengthLeft(str, i) {\n  if (i <= 0) return 0;\n  if (\n    (i > 1 && StringPrototypeCodePointAt.call(str, i - 2) >= kUTF16SurrogateThreshold) ||\n    StringPrototypeCodePointAt.call(str, i - 1) >= kUTF16SurrogateThreshold\n  ) {\n    return 2;\n  }\n  return 1;\n}\n\nfunction charLengthAt(str, i) {\n  if (str.length <= i) {\n    // Pretend to move to the right. This is necessary to autocomplete while\n    // moving to the right.\n    return 1;\n  }\n  return StringPrototypeCodePointAt.call(str, i) >= kUTF16SurrogateThreshold ? 2 : 1;\n}\n\n/*\n  Some patterns seen in terminal key escape codes, derived from combos seen\n  at http://www.midnight-commander.org/browser/lib/tty/key.c\n  ESC letter\n  ESC [ letter\n  ESC [ modifier letter\n  ESC [ 1 ; modifier letter\n  ESC [ num char\n  ESC [ num ; modifier char\n  ESC O letter\n  ESC O modifier letter\n  ESC O 1 ; modifier letter\n  ESC N letter\n  ESC [ [ num ; modifier char\n  ESC [ [ 1 ; modifier letter\n  ESC ESC [ num char\n  ESC ESC O letter\n  - char is usually ~ but $ and ^ also happen with rxvt\n  - modifier is 1 +\n                (shift     * 1) +\n                (left_alt  * 2) +\n                (ctrl      * 4) +\n                (right_alt * 8)\n  - two leading ESCs apparently mean the same as one leading ESC\n*/\nfunction* emitKeys(stream) {\n  while (true) {\n    var ch = yield;\n    var s = ch;\n    var escaped = false;\n\n    var keySeq = null;\n    var keyName;\n    var keyCtrl = false;\n    var keyMeta = false;\n    var keyShift = false;\n\n    // var key = {\n    //   sequence: null,\n    //   name: undefined,\n    //   ctrl: false,\n    //   meta: false,\n    //   shift: false,\n    // };\n\n    if (ch === kEscape) {\n      escaped = true;\n      s += ch = yield;\n\n      if (ch === kEscape) {\n        s += ch = yield;\n      }\n    }\n\n    if (escaped && (ch === \"O\" || ch === \"[\")) {\n      // ANSI escape sequence\n      var code = ch;\n      var modifier = 0;\n\n      if (ch === \"O\") {\n        // ESC O letter\n        // ESC O modifier letter\n        s += ch = yield;\n\n        if (ch >= \"0\" && ch <= \"9\") {\n          modifier = (ch >> 0) - 1;\n          s += ch = yield;\n        }\n\n        code += ch;\n      } else if (ch === \"[\") {\n        // ESC [ letter\n        // ESC [ modifier letter\n        // ESC [ [ modifier letter\n        // ESC [ [ num char\n        s += ch = yield;\n\n        if (ch === \"[\") {\n          // \\x1b[[A\n          //      ^--- escape codes might have a second bracket\n          code += ch;\n          s += ch = yield;\n        }\n\n        /*\n         * Here and later we try to buffer just enough data to get\n         * a complete ascii sequence.\n         *\n         * We have basically two classes of ascii characters to process:\n         *\n         *\n         * 1. `\\x1b[24;5~` should be parsed as { code: '[24~', modifier: 5 }\n         *\n         * This particular example is featuring Ctrl+F12 in xterm.\n         *\n         *  - `;5` part is optional, e.g. it could be `\\x1b[24~`\n         *  - first part can contain one or two digits\n         *\n         * So the generic regexp is like /^\\d\\d?(;\\d)?[~^$]$/\n         *\n         *\n         * 2. `\\x1b[1;5H` should be parsed as { code: '[H', modifier: 5 }\n         *\n         * This particular example is featuring Ctrl+Home in xterm.\n         *\n         *  - `1;5` part is optional, e.g. it could be `\\x1b[H`\n         *  - `1;` part is optional, e.g. it could be `\\x1b[5H`\n         *\n         * So the generic regexp is like /^((\\d;)?\\d)?[A-Za-z]$/\n         *\n         */\n        var cmdStart = s.length - 1;\n\n        // Skip one or two leading digits\n        if (ch >= \"0\" && ch <= \"9\") {\n          s += ch = yield;\n\n          if (ch >= \"0\" && ch <= \"9\") {\n            s += ch = yield;\n          }\n        }\n\n        // skip modifier\n        if (ch === \";\") {\n          s += ch = yield;\n\n          if (ch >= \"0\" && ch <= \"9\") {\n            s += yield;\n          }\n        }\n\n        /*\n         * We buffered enough data, now trying to extract code\n         * and modifier from it\n         */\n        var cmd = StringPrototypeSlice.call(s, cmdStart);\n        var match;\n\n        if ((match = RegExpPrototypeExec.call(/^(\\d\\d?)(;(\\d))?([~^$])$/, cmd))) {\n          code += match[1] + match[4];\n          modifier = (match[3] || 1) - 1;\n        } else if ((match = RegExpPrototypeExec.call(/^((\\d;)?(\\d))?([A-Za-z])$/, cmd))) {\n          code += match[4];\n          modifier = (match[3] || 1) - 1;\n        } else {\n          code += cmd;\n        }\n      }\n\n      // Parse the key modifier\n      keyCtrl = !!(modifier & 4);\n      keyMeta = !!(modifier & 10);\n      keyShift = !!(modifier & 1);\n      keyCode = code;\n\n      // Parse the key itself\n      switch (code) {\n        /* xterm/gnome ESC [ letter (with modifier) */\n        case \"[P\":\n          keyName = \"f1\";\n          break;\n        case \"[Q\":\n          keyName = \"f2\";\n          break;\n        case \"[R\":\n          keyName = \"f3\";\n          break;\n        case \"[S\":\n          keyName = \"f4\";\n          break;\n\n        /* xterm/gnome ESC O letter (without modifier) */\n        case \"OP\":\n          keyName = \"f1\";\n          break;\n        case \"OQ\":\n          keyName = \"f2\";\n          break;\n        case \"OR\":\n          keyName = \"f3\";\n          break;\n        case \"OS\":\n          keyName = \"f4\";\n          break;\n\n        /* xterm/rxvt ESC [ number ~ */\n        case \"[11~\":\n          keyName = \"f1\";\n          break;\n        case \"[12~\":\n          keyName = \"f2\";\n          break;\n        case \"[13~\":\n          keyName = \"f3\";\n          break;\n        case \"[14~\":\n          keyName = \"f4\";\n          break;\n\n        /* from Cygwin and used in libuv */\n        case \"[[A\":\n          keyName = \"f1\";\n          break;\n        case \"[[B\":\n          keyName = \"f2\";\n          break;\n        case \"[[C\":\n          keyName = \"f3\";\n          break;\n        case \"[[D\":\n          keyName = \"f4\";\n          break;\n        case \"[[E\":\n          keyName = \"f5\";\n          break;\n\n        /* common */\n        case \"[15~\":\n          keyName = \"f5\";\n          break;\n        case \"[17~\":\n          keyName = \"f6\";\n          break;\n        case \"[18~\":\n          keyName = \"f7\";\n          break;\n        case \"[19~\":\n          keyName = \"f8\";\n          break;\n        case \"[20~\":\n          keyName = \"f9\";\n          break;\n        case \"[21~\":\n          keyName = \"f10\";\n          break;\n        case \"[23~\":\n          keyName = \"f11\";\n          break;\n        case \"[24~\":\n          keyName = \"f12\";\n          break;\n\n        /* xterm ESC [ letter */\n        case \"[A\":\n          keyName = \"up\";\n          break;\n        case \"[B\":\n          keyName = \"down\";\n          break;\n        case \"[C\":\n          keyName = \"right\";\n          break;\n        case \"[D\":\n          keyName = \"left\";\n          break;\n        case \"[E\":\n          keyName = \"clear\";\n          break;\n        case \"[F\":\n          keyName = \"end\";\n          break;\n        case \"[H\":\n          keyName = \"home\";\n          break;\n\n        /* xterm/gnome ESC O letter */\n        case \"OA\":\n          keyName = \"up\";\n          break;\n        case \"OB\":\n          keyName = \"down\";\n          break;\n        case \"OC\":\n          keyName = \"right\";\n          break;\n        case \"OD\":\n          keyName = \"left\";\n          break;\n        case \"OE\":\n          keyName = \"clear\";\n          break;\n        case \"OF\":\n          keyName = \"end\";\n          break;\n        case \"OH\":\n          keyName = \"home\";\n          break;\n\n        /* xterm/rxvt ESC [ number ~ */\n        case \"[1~\":\n          keyName = \"home\";\n          break;\n        case \"[2~\":\n          keyName = \"insert\";\n          break;\n        case \"[3~\":\n          keyName = \"delete\";\n          break;\n        case \"[4~\":\n          keyName = \"end\";\n          break;\n        case \"[5~\":\n          keyName = \"pageup\";\n          break;\n        case \"[6~\":\n          keyName = \"pagedown\";\n          break;\n\n        /* putty */\n        case \"[[5~\":\n          keyName = \"pageup\";\n          break;\n        case \"[[6~\":\n          keyName = \"pagedown\";\n          break;\n\n        /* rxvt */\n        case \"[7~\":\n          keyName = \"home\";\n          break;\n        case \"[8~\":\n          keyName = \"end\";\n          break;\n\n        /* rxvt keys with modifiers */\n        case \"[a\":\n          keyName = \"up\";\n          keyShift = true;\n          break;\n        case \"[b\":\n          keyName = \"down\";\n          keyShift = true;\n          break;\n        case \"[c\":\n          keyName = \"right\";\n          keyShift = true;\n          break;\n        case \"[d\":\n          keyName = \"left\";\n          keyShift = true;\n          break;\n        case \"[e\":\n          keyName = \"clear\";\n          keyShift = true;\n          break;\n\n        case \"[2$\":\n          keyName = \"insert\";\n          keyShift = true;\n          break;\n        case \"[3$\":\n          keyName = \"delete\";\n          keyShift = true;\n          break;\n        case \"[5$\":\n          keyName = \"pageup\";\n          keyShift = true;\n          break;\n        case \"[6$\":\n          keyName = \"pagedown\";\n          keyShift = true;\n          break;\n        case \"[7$\":\n          keyName = \"home\";\n          keyShift = true;\n          break;\n        case \"[8$\":\n          keyName = \"end\";\n          keyShift = true;\n          break;\n\n        case \"Oa\":\n          keyName = \"up\";\n          keyCtrl = true;\n          break;\n        case \"Ob\":\n          keyName = \"down\";\n          keyCtrl = true;\n          break;\n        case \"Oc\":\n          keyName = \"right\";\n          keyCtrl = true;\n          break;\n        case \"Od\":\n          keyName = \"left\";\n          keyCtrl = true;\n          break;\n        case \"Oe\":\n          keyName = \"clear\";\n          keyCtrl = true;\n          break;\n\n        case \"[2^\":\n          keyName = \"insert\";\n          keyCtrl = true;\n          break;\n        case \"[3^\":\n          keyName = \"delete\";\n          keyCtrl = true;\n          break;\n        case \"[5^\":\n          keyName = \"pageup\";\n          keyCtrl = true;\n          break;\n        case \"[6^\":\n          keyName = \"pagedown\";\n          keyCtrl = true;\n          break;\n        case \"[7^\":\n          keyName = \"home\";\n          keyCtrl = true;\n          break;\n        case \"[8^\":\n          keyName = \"end\";\n          keyCtrl = true;\n          break;\n\n        /* misc. */\n        case \"[Z\":\n          keyName = \"tab\";\n          keyShift = true;\n          break;\n        default:\n          keyName = \"undefined\";\n          break;\n      }\n    } else if (ch === \"\\r\") {\n      // carriage return\n      keyName = \"return\";\n      keyMeta = escaped;\n    } else if (ch === \"\\n\") {\n      // Enter, should have been called linefeed\n      keyName = \"enter\";\n      keyMeta = escaped;\n    } else if (ch === \"\\t\") {\n      // tab\n      keyName = \"tab\";\n      keyMeta = escaped;\n    } else if (ch === \"\\b\" || ch === \"\\x7f\") {\n      // backspace or ctrl+h\n      keyName = \"backspace\";\n      keyMeta = escaped;\n    } else if (ch === kEscape) {\n      // escape key\n      keyName = \"escape\";\n      keyMeta = escaped;\n    } else if (ch === \" \") {\n      keyName = \"space\";\n      keyMeta = escaped;\n    } else if (!escaped && ch <= \"\\x1a\") {\n      // ctrl+letter\n      keyName = StringFromCharCode(StringPrototypeCharCodeAt.call(ch) + StringPrototypeCharCodeAt.call(\"a\") - 1);\n      keyCtrl = true;\n    } else if (RegExpPrototypeExec.call(/^[0-9A-Za-z]$/, ch) !== null) {\n      // Letter, number, shift+letter\n      keyName = StringPrototypeToLowerCase.call(ch);\n      keyShift = RegExpPrototypeExec.call(/^[A-Z]$/, ch) !== null;\n      keyMeta = escaped;\n    } else if (escaped) {\n      // Escape sequence timeout\n      keyName = ch.length ? undefined : \"escape\";\n      keyMeta = true;\n    }\n\n    keySeq = s;\n\n    if (s.length !== 0 && (keyName !== undefined || escaped)) {\n      /* Named character or sequence */\n      stream.emit(\"keypress\", escaped ? undefined : s, {\n        sequence: keySeq,\n        name: keyName,\n        ctrl: keyCtrl,\n        meta: keyMeta,\n        shift: keyShift,\n      });\n    } else if (charLengthAt(s, 0) === s.length) {\n      /* Single unnamed character, e.g. \".\" */\n      stream.emit(\"keypress\", s, {\n        sequence: keySeq,\n        name: keyName,\n        ctrl: keyCtrl,\n        meta: keyMeta,\n        shift: keyShift,\n      });\n    }\n    /* Unrecognized or broken escape sequence, don't emit anything */\n  }\n}\n\n// This runs in O(n log n).\nfunction commonPrefix(strings) {\n  if (strings.length === 0) {\n    return \"\";\n  }\n  if (strings.length === 1) {\n    return strings[0];\n  }\n  var sorted = ArrayPrototypeSort.call(ArrayPrototypeSlice.call(strings));\n  var min = sorted[0];\n  var max = sorted[sorted.length - 1];\n  for (var i = 0; i < min.length; i++) {\n    if (min[i] !== max[i]) {\n      return StringPrototypeSlice.call(min, 0, i);\n    }\n  }\n  return min;\n}\n\n// ----------------------------------------------------------------------------\n// Section: Cursor Functions\n// ----------------------------------------------------------------------------\n\n/**\n * moves the cursor to the x and y coordinate on the given stream\n */\n\nfunction cursorTo(stream, x, y, callback) {\n  if (callback !== undefined) {\n    validateFunction(callback, \"callback\");\n  }\n\n  if (typeof y === \"function\") {\n    callback = y;\n    y = undefined;\n  }\n\n  if (NumberIsNaN(x)) throw new ERR_INVALID_ARG_VALUE(\"x\", x);\n  if (NumberIsNaN(y)) throw new ERR_INVALID_ARG_VALUE(\"y\", y);\n\n  if (stream == null || (typeof x !== \"number\" && typeof y !== \"number\")) {\n    if (typeof callback === \"function\") process.nextTick(callback, null);\n    return true;\n  }\n\n  if (typeof x !== \"number\") throw new ERR_INVALID_CURSOR_POS();\n\n  var data = typeof y !== \"number\" ? CSI`${x + 1}G` : CSI`${y + 1};${x + 1}H`;\n  return stream.write(data, callback);\n}\n\n/**\n * moves the cursor relative to its current location\n */\n\nfunction moveCursor(stream, dx, dy, callback) {\n  if (callback !== undefined) {\n    validateFunction(callback, \"callback\");\n  }\n\n  if (stream == null || !(dx || dy)) {\n    if (typeof callback === \"function\") process.nextTick(callback, null);\n    return true;\n  }\n\n  var data = \"\";\n\n  if (dx < 0) {\n    data += CSI`${-dx}D`;\n  } else if (dx > 0) {\n    data += CSI`${dx}C`;\n  }\n\n  if (dy < 0) {\n    data += CSI`${-dy}A`;\n  } else if (dy > 0) {\n    data += CSI`${dy}B`;\n  }\n\n  return stream.write(data, callback);\n}\n\n/**\n * clears the current line the cursor is on:\n *   -1 for left of the cursor\n *   +1 for right of the cursor\n *    0 for the entire line\n */\n\nfunction clearLine(stream, dir, callback) {\n  if (callback !== undefined) {\n    validateFunction(callback, \"callback\");\n  }\n\n  if (stream === null || stream === undefined) {\n    if (typeof callback === \"function\") process.nextTick(callback, null);\n    return true;\n  }\n\n  var type = dir < 0 ? kClearToLineBeginning : dir > 0 ? kClearToLineEnd : kClearLine;\n  return stream.write(type, callback);\n}\n\n/**\n * clears the screen from the current position of the cursor down\n */\n\nfunction clearScreenDown(stream, callback) {\n  if (callback !== undefined) {\n    validateFunction(callback, \"callback\");\n  }\n\n  if (stream === null || stream === undefined) {\n    if (typeof callback === \"function\") process.nextTick(callback, null);\n    return true;\n  }\n\n  return stream.write(kClearScreenDown, callback);\n}\n\n// ----------------------------------------------------------------------------\n// Section: Emit keypress events\n// ----------------------------------------------------------------------------\n\nvar KEYPRESS_DECODER = Symbol(\"keypress-decoder\");\nvar ESCAPE_DECODER = Symbol(\"escape-decoder\");\n\n// GNU readline library - keyseq-timeout is 500ms (default)\nvar ESCAPE_CODE_TIMEOUT = 500;\n\n/**\n * accepts a readable Stream instance and makes it emit \"keypress\" events\n */\n\nfunction emitKeypressEvents(stream, iface = {}) {\n  if (stream[KEYPRESS_DECODER]) return;\n\n  stream[KEYPRESS_DECODER] = new StringDecoder(\"utf8\");\n\n  stream[ESCAPE_DECODER] = emitKeys(stream);\n  stream[ESCAPE_DECODER].next();\n\n  var triggerEscape = () => stream[ESCAPE_DECODER].next(\"\");\n  var { escapeCodeTimeout = ESCAPE_CODE_TIMEOUT } = iface;\n  var timeoutId;\n\n  function onData(input) {\n    if (stream.listenerCount(\"keypress\") > 0) {\n      var string = stream[KEYPRESS_DECODER].write(input);\n      if (string) {\n        clearTimeout(timeoutId);\n\n        // This supports characters of length 2.\n        iface[kSawKeyPress] = charLengthAt(string, 0) === string.length;\n        iface.isCompletionEnabled = false;\n\n        var length = 0;\n        for (var character of new SafeStringIterator(string)) {\n          length += character.length;\n          if (length === string.length) {\n            iface.isCompletionEnabled = true;\n          }\n\n          try {\n            stream[ESCAPE_DECODER].next(character);\n            // Escape letter at the tail position\n            if (length === string.length && character === kEscape) {\n              timeoutId = setTimeout(triggerEscape, escapeCodeTimeout);\n            }\n          } catch (err) {\n            // If the generator throws (it could happen in the `keypress`\n            // event), we need to restart it.\n            stream[ESCAPE_DECODER] = emitKeys(stream);\n            stream[ESCAPE_DECODER].next();\n            throw err;\n          }\n        }\n      }\n    } else {\n      // Nobody's watching anyway\n      stream.removeListener(\"data\", onData);\n      stream.on(\"newListener\", onNewListener);\n    }\n  }\n\n  function onNewListener(event) {\n    if (event === \"keypress\") {\n      stream.on(\"data\", onData);\n      stream.removeListener(\"newListener\", onNewListener);\n    }\n  }\n\n  if (stream.listenerCount(\"keypress\") > 0) {\n    stream.on(\"data\", onData);\n  } else {\n    stream.on(\"newListener\", onNewListener);\n  }\n}\n\n// ----------------------------------------------------------------------------\n// Section: Interface\n// ----------------------------------------------------------------------------\n\nvar kEmptyObject = ObjectFreeze(ObjectCreate(null));\n\n// Some constants regarding configuration of interface\nvar kHistorySize = 30;\nvar kMaxUndoRedoStackSize = 2048;\nvar kMincrlfDelay = 100;\n// \\r\\n, \\n, or \\r followed by something other than \\n\nvar lineEnding = /\\r?\\n|\\r(?!\\n)/g;\n\n// Max length of the kill ring\nvar kMaxLengthOfKillRing = 32;\n\n// Symbols\n\n// Public symbols\nvar kLineObjectStream = Symbol(\"line object stream\");\nvar kQuestionCancel = Symbol(\"kQuestionCancel\");\nvar kQuestion = Symbol(\"kQuestion\");\n\n// Private symbols\nvar kAddHistory = Symbol(\"_addHistory\");\nvar kBeforeEdit = Symbol(\"_beforeEdit\");\nvar kDecoder = Symbol(\"_decoder\");\nvar kDeleteLeft = Symbol(\"_deleteLeft\");\nvar kDeleteLineLeft = Symbol(\"_deleteLineLeft\");\nvar kDeleteLineRight = Symbol(\"_deleteLineRight\");\nvar kDeleteRight = Symbol(\"_deleteRight\");\nvar kDeleteWordLeft = Symbol(\"_deleteWordLeft\");\nvar kDeleteWordRight = Symbol(\"_deleteWordRight\");\nvar kGetDisplayPos = Symbol(\"_getDisplayPos\");\nvar kHistoryNext = Symbol(\"_historyNext\");\nvar kHistoryPrev = Symbol(\"_historyPrev\");\nvar kInsertString = Symbol(\"_insertString\");\nvar kLine = Symbol(\"_line\");\nvar kLine_buffer = Symbol(\"_line_buffer\");\nvar kKillRing = Symbol(\"_killRing\");\nvar kKillRingCursor = Symbol(\"_killRingCursor\");\nvar kMoveCursor = Symbol(\"_moveCursor\");\nvar kNormalWrite = Symbol(\"_normalWrite\");\nvar kOldPrompt = Symbol(\"_oldPrompt\");\nvar kOnLine = Symbol(\"_onLine\");\nvar kPreviousKey = Symbol(\"_previousKey\");\nvar kPrompt = Symbol(\"_prompt\");\nvar kPushToKillRing = Symbol(\"_pushToKillRing\");\nvar kPushToUndoStack = Symbol(\"_pushToUndoStack\");\nvar kQuestionCallback = Symbol(\"_questionCallback\");\nvar kRedo = Symbol(\"_redo\");\nvar kRedoStack = Symbol(\"_redoStack\");\nvar kRefreshLine = Symbol(\"_refreshLine\");\nvar kSawKeyPress = Symbol(\"_sawKeyPress\");\nvar kSawReturnAt = Symbol(\"_sawReturnAt\");\nvar kSetRawMode = Symbol(\"_setRawMode\");\nvar kTabComplete = Symbol(\"_tabComplete\");\nvar kTabCompleter = Symbol(\"_tabCompleter\");\nvar kTtyWrite = Symbol(\"_ttyWrite\");\nvar kUndo = Symbol(\"_undo\");\nvar kUndoStack = Symbol(\"_undoStack\");\nvar kWordLeft = Symbol(\"_wordLeft\");\nvar kWordRight = Symbol(\"_wordRight\");\nvar kWriteToOutput = Symbol(\"_writeToOutput\");\nvar kYank = Symbol(\"_yank\");\nvar kYanking = Symbol(\"_yanking\");\nvar kYankPop = Symbol(\"_yankPop\");\n\n// Event symbols\nvar kFirstEventParam = Symbol(\"nodejs.kFirstEventParam\");\n\n// class InterfaceConstructor extends EventEmitter {\n// #onSelfCloseWithTerminal;\n// #onSelfCloseWithoutTerminal;\n\n// #onError;\n// #onData;\n// #onEnd;\n// #onTermEnd;\n// #onKeyPress;\n// #onResize;\n\n// [kSawReturnAt];\n// isCompletionEnabled = true;\n// [kSawKeyPress];\n// [kPreviousKey];\n// escapeCodeTimeout;\n// tabSize;\n\n// line;\n// [kSubstringSearch];\n// output;\n// input;\n// [kUndoStack];\n// [kRedoStack];\n// history;\n// historySize;\n\n// [kKillRing];\n// [kKillRingCursor];\n\n// removeHistoryDuplicates;\n// crlfDelay;\n// completer;\n\n// terminal;\n// [kLineObjectStream];\n\n// cursor;\n// historyIndex;\n\n// constructor(input, output, completer, terminal) {\n//   super();\n\nvar kOnSelfCloseWithTerminal = Symbol(\"_onSelfCloseWithTerminal\");\nvar kOnSelfCloseWithoutTerminal = Symbol(\"_onSelfCloseWithoutTerminal\");\nvar kOnKeyPress = Symbol(\"_onKeyPress\");\nvar kOnError = Symbol(\"_onError\");\nvar kOnData = Symbol(\"_onData\");\nvar kOnEnd = Symbol(\"_onEnd\");\nvar kOnTermEnd = Symbol(\"_onTermEnd\");\nvar kOnResize = Symbol(\"_onResize\");\n\nfunction onSelfCloseWithTerminal() {\n  var input = this.input;\n  var output = this.output;\n\n  if (!input) throw new Error(\"Input not set, invalid state for readline!\");\n\n  input.removeListener(\"keypress\", this[kOnKeyPress]);\n  input.removeListener(\"error\", this[kOnError]);\n  input.removeListener(\"end\", this[kOnTermEnd]);\n  if (output !== null && output !== undefined) {\n    output.removeListener(\"resize\", this[kOnResize]);\n  }\n}\n\nfunction onSelfCloseWithoutTerminal() {\n  var input = this.input;\n  if (!input) throw new Error(\"Input not set, invalid state for readline!\");\n\n  input.removeListener(\"data\", this[kOnData]);\n  input.removeListener(\"error\", this[kOnError]);\n  input.removeListener(\"end\", this[kOnEnd]);\n}\n\nfunction onError(err) {\n  this.emit(\"error\", err);\n}\n\nfunction onData(data) {\n  debug(\"onData\");\n  this[kNormalWrite](data);\n}\n\nfunction onEnd() {\n  debug(\"onEnd\");\n  if (typeof this[kLine_buffer] === \"string\" && this[kLine_buffer].length > 0) {\n    this.emit(\"line\", this[kLine_buffer]);\n  }\n  this.close();\n}\n\nfunction onTermEnd() {\n  debug(\"onTermEnd\");\n  if (typeof this.line === \"string\" && this.line.length > 0) {\n    this.emit(\"line\", this.line);\n  }\n  this.close();\n}\n\nfunction onKeyPress(s, key) {\n  this[kTtyWrite](s, key);\n  if (key && key.sequence) {\n    // If the keySeq is half of a surrogate pair\n    // (>= 0xd800 and <= 0xdfff), refresh the line so\n    // the character is displayed appropriately.\n    var ch = StringPrototypeCodePointAt.call(key.sequence, 0);\n    if (ch >= 0xd800 && ch <= 0xdfff) this[kRefreshLine]();\n  }\n}\n\nfunction onResize() {\n  this[kRefreshLine]();\n}\n\nfunction InterfaceConstructor(input, output, completer, terminal) {\n  if (!(this instanceof InterfaceConstructor)) {\n    return new InterfaceConstructor(input, output, completer, terminal);\n  }\n\n  EventEmitter.call(this);\n\n  this[kOnSelfCloseWithoutTerminal] = onSelfCloseWithoutTerminal.bind(this);\n  this[kOnSelfCloseWithTerminal] = onSelfCloseWithTerminal.bind(this);\n\n  this[kOnError] = onError.bind(this);\n  this[kOnData] = onData.bind(this);\n  this[kOnEnd] = onEnd.bind(this);\n  this[kOnTermEnd] = onTermEnd.bind(this);\n  this[kOnKeyPress] = onKeyPress.bind(this);\n  this[kOnResize] = onResize.bind(this);\n\n  this[kSawReturnAt] = 0;\n  this.isCompletionEnabled = true;\n  this[kSawKeyPress] = false;\n  this[kPreviousKey] = null;\n  this.escapeCodeTimeout = ESCAPE_CODE_TIMEOUT;\n  this.tabSize = 8;\n\n  var history;\n  var historySize;\n  var removeHistoryDuplicates = false;\n  var crlfDelay;\n  var prompt = \"> \";\n  var signal;\n\n  if (input?.input) {\n    // An options object was given\n    output = input.output;\n    completer = input.completer;\n    terminal = input.terminal;\n    history = input.history;\n    historySize = input.historySize;\n    signal = input.signal;\n\n    var tabSize = input.tabSize;\n    if (tabSize !== undefined) {\n      validateUint32(tabSize, \"tabSize\", true);\n      this.tabSize = tabSize;\n    }\n    removeHistoryDuplicates = input.removeHistoryDuplicates;\n\n    var inputPrompt = input.prompt;\n    if (inputPrompt !== undefined) {\n      prompt = inputPrompt;\n    }\n\n    var inputEscapeCodeTimeout = input.escapeCodeTimeout;\n    if (inputEscapeCodeTimeout !== undefined) {\n      if (NumberIsFinite(inputEscapeCodeTimeout)) {\n        this.escapeCodeTimeout = inputEscapeCodeTimeout;\n      } else {\n        throw new ERR_INVALID_ARG_VALUE(\"input.escapeCodeTimeout\", this.escapeCodeTimeout);\n      }\n    }\n\n    if (signal) {\n      validateAbortSignal(signal, \"options.signal\");\n    }\n\n    crlfDelay = input.crlfDelay;\n    input = input.input;\n  }\n\n  if (completer !== undefined && typeof completer !== \"function\") {\n    throw new ERR_INVALID_ARG_VALUE(\"completer\", completer);\n  }\n\n  if (history === undefined) {\n    history = [];\n  } else {\n    validateArray(history, \"history\");\n  }\n\n  if (historySize === undefined) {\n    historySize = kHistorySize;\n  }\n\n  if (typeof historySize !== \"number\" || NumberIsNaN(historySize) || historySize < 0) {\n    throw new ERR_INVALID_ARG_VALUE(\"historySize\", historySize);\n  }\n\n  // Backwards compat; check the isTTY prop of the output stream\n  //  when `terminal` was not specified\n  if (terminal === undefined && !(output === null || output === undefined)) {\n    terminal = !!output.isTTY;\n  }\n\n  this.line = \"\";\n  this[kSubstringSearch] = null;\n  this.output = output;\n  this.input = input;\n  this[kUndoStack] = [];\n  this[kRedoStack] = [];\n  this.history = history;\n  this.historySize = historySize;\n\n  // The kill ring is a global list of blocks of text that were previously\n  // killed (deleted). If its size exceeds kMaxLengthOfKillRing, the oldest\n  // element will be removed to make room for the latest deletion. With kill\n  // ring, users are able to recall (yank) or cycle (yank pop) among previously\n  // killed texts, quite similar to the behavior of Emacs.\n  this[kKillRing] = [];\n  this[kKillRingCursor] = 0;\n\n  this.removeHistoryDuplicates = !!removeHistoryDuplicates;\n  this.crlfDelay = crlfDelay ? MathMax(kMincrlfDelay, crlfDelay) : kMincrlfDelay;\n  this.completer = completer;\n\n  this.setPrompt(prompt);\n\n  this.terminal = !!terminal;\n\n  this[kLineObjectStream] = undefined;\n\n  input.on(\"error\", this[kOnError]);\n\n  if (!this.terminal) {\n    input.on(\"data\", this[kOnData]);\n    input.on(\"end\", this[kOnEnd]);\n    this.once(\"close\", this[kOnSelfCloseWithoutTerminal]);\n    this[kDecoder] = new StringDecoder(\"utf8\");\n  } else {\n    emitKeypressEvents(input, this);\n\n    // `input` usually refers to stdin\n    input.on(\"keypress\", this[kOnKeyPress]);\n    input.on(\"end\", this[kOnTermEnd]);\n\n    this[kSetRawMode](true);\n    this.terminal = true;\n\n    // Cursor position on the line.\n    this.cursor = 0;\n    this.historyIndex = -1;\n\n    if (output !== null && output !== undefined) output.on(\"resize\", this[kOnResize]);\n\n    this.once(\"close\", this[kOnSelfCloseWithTerminal]);\n  }\n\n  if (signal) {\n    var onAborted = (() => this.close()).bind(this);\n    if (signal.aborted) {\n      process.nextTick(onAborted);\n    } else {\n      signal.addEventListener(\"abort\", onAborted, { once: true });\n      this.once(\"close\", () => signal.removeEventListener(\"abort\", onAborted));\n    }\n  }\n\n  // Current line\n  this.line = \"\";\n\n  input.resume();\n}\n\nObjectSetPrototypeOf(InterfaceConstructor.prototype, EventEmitter.prototype);\nObjectSetPrototypeOf(InterfaceConstructor, EventEmitter);\n\nvar _Interface = class Interface extends InterfaceConstructor {\n  // TODO: Enumerate all the properties of the class\n\n  // eslint-disable-next-line no-useless-constructor\n  constructor(input, output, completer, terminal) {\n    super(input, output, completer, terminal);\n  }\n  get columns() {\n    var output = this.output;\n    if (output && output.columns) return output.columns;\n    return Infinity;\n  }\n\n  /**\n   * Sets the prompt written to the output.\n   * @param {string} prompt\n   * @returns {void}\n   */\n  setPrompt(prompt) {\n    this[kPrompt] = prompt;\n  }\n\n  /**\n   * Returns the current prompt used by `rl.prompt()`.\n   * @returns {string}\n   */\n  getPrompt() {\n    return this[kPrompt];\n  }\n\n  [kSetRawMode](mode) {\n    var input = this.input;\n    var { setRawMode, wasInRawMode } = input;\n\n    // TODO: Make this work, for now just stub this and print debug\n    debug(\"setRawMode\", mode, \"set!\");\n    // if (typeof setRawMode === \"function\") {\n    //   setRawMode(mode);\n    // }\n\n    return wasInRawMode;\n  }\n\n  /**\n   * Writes the configured `prompt` to a new line in `output`.\n   * @param {boolean} [preserveCursor]\n   * @returns {void}\n   */\n  prompt(preserveCursor) {\n    if (this.paused) this.resume();\n    if (this.terminal && process.env.TERM !== \"dumb\") {\n      if (!preserveCursor) this.cursor = 0;\n      this[kRefreshLine]();\n    } else {\n      this[kWriteToOutput](this[kPrompt]);\n    }\n  }\n\n  [kQuestion](query, cb) {\n    if (this.closed) {\n      throw new ERR_USE_AFTER_CLOSE(\"readline\");\n    }\n    if (this[kQuestionCallback]) {\n      this.prompt();\n    } else {\n      this[kOldPrompt] = this[kPrompt];\n      this.setPrompt(query);\n      this[kQuestionCallback] = cb;\n      this.prompt();\n    }\n  }\n\n  [kOnLine](line) {\n    if (this[kQuestionCallback]) {\n      var cb = this[kQuestionCallback];\n      this[kQuestionCallback] = null;\n      this.setPrompt(this[kOldPrompt]);\n      cb(line);\n    } else {\n      this.emit(\"line\", line);\n    }\n  }\n\n  [kBeforeEdit](oldText, oldCursor) {\n    this[kPushToUndoStack](oldText, oldCursor);\n  }\n\n  [kQuestionCancel]() {\n    if (this[kQuestionCallback]) {\n      this[kQuestionCallback] = null;\n      this.setPrompt(this[kOldPrompt]);\n      this.clearLine();\n    }\n  }\n\n  [kWriteToOutput](stringToWrite) {\n    validateString(stringToWrite, \"stringToWrite\");\n\n    if (this.output !== null && this.output !== undefined) {\n      this.output.write(stringToWrite);\n    }\n  }\n\n  [kAddHistory]() {\n    if (this.line.length === 0) return \"\";\n\n    // If the history is disabled then return the line\n    if (this.historySize === 0) return this.line;\n\n    // If the trimmed line is empty then return the line\n    if (StringPrototypeTrim.call(this.line).length === 0) return this.line;\n\n    if (this.history.length === 0 || this.history[0] !== this.line) {\n      if (this.removeHistoryDuplicates) {\n        // Remove older history line if identical to new one\n        var dupIndex = ArrayPrototypeIndexOf.call(this.history, this.line);\n        if (dupIndex !== -1) ArrayPrototypeSplice.call(this.history, dupIndex, 1);\n      }\n\n      ArrayPrototypeUnshift.call(this.history, this.line);\n\n      // Only store so many\n      if (this.history.length > this.historySize) ArrayPrototypePop.call(this.history);\n    }\n\n    this.historyIndex = -1;\n\n    // The listener could change the history object, possibly\n    // to remove the last added entry if it is sensitive and should\n    // not be persisted in the history, like a password\n    var line = this.history[0];\n\n    // Emit history event to notify listeners of update\n    this.emit(\"history\", this.history);\n\n    return line;\n  }\n\n  [kRefreshLine]() {\n    // line length\n    var line = this[kPrompt] + this.line;\n    var dispPos = this[kGetDisplayPos](line);\n    var lineCols = dispPos.cols;\n    var lineRows = dispPos.rows;\n\n    // cursor position\n    var cursorPos = this.getCursorPos();\n\n    // First move to the bottom of the current line, based on cursor pos\n    var prevRows = this.prevRows || 0;\n    if (prevRows > 0) {\n      moveCursor(this.output, 0, -prevRows);\n    }\n\n    // Cursor to left edge.\n    cursorTo(this.output, 0);\n    // erase data\n    clearScreenDown(this.output);\n\n    // Write the prompt and the current buffer content.\n    this[kWriteToOutput](line);\n\n    // Force terminal to allocate a new line\n    if (lineCols === 0) {\n      this[kWriteToOutput](\" \");\n    }\n\n    // Move cursor to original position.\n    cursorTo(this.output, cursorPos.cols);\n\n    var diff = lineRows - cursorPos.rows;\n    if (diff > 0) {\n      moveCursor(this.output, 0, -diff);\n    }\n\n    this.prevRows = cursorPos.rows;\n  }\n\n  /**\n   * Closes the `readline.Interface` instance.\n   * @returns {void}\n   */\n  close() {\n    if (this.closed) return;\n    this.pause();\n    if (this.terminal) {\n      this[kSetRawMode](false);\n    }\n    this.closed = true;\n    this.emit(\"close\");\n  }\n\n  /**\n   * Pauses the `input` stream.\n   * @returns {void | Interface}\n   */\n  pause() {\n    if (this.paused) return;\n    this.input.pause();\n    this.paused = true;\n    this.emit(\"pause\");\n    return this;\n  }\n\n  /**\n   * Resumes the `input` stream if paused.\n   * @returns {void | Interface}\n   */\n  resume() {\n    if (!this.paused) return;\n    this.input.resume();\n    this.paused = false;\n    this.emit(\"resume\");\n    return this;\n  }\n\n  /**\n   * Writes either `data` or a `key` sequence identified by\n   * `key` to the `output`.\n   * @param {string} d\n   * @param {{\n   *   ctrl?: boolean;\n   *   meta?: boolean;\n   *   shift?: boolean;\n   *   name?: string;\n   *   }} [key]\n   * @returns {void}\n   */\n  write(d, key) {\n    if (this.paused) this.resume();\n    if (this.terminal) {\n      this[kTtyWrite](d, key);\n    } else {\n      this[kNormalWrite](d);\n    }\n  }\n\n  [kNormalWrite](b) {\n    if (b === undefined) {\n      return;\n    }\n    var string = this[kDecoder].write(b);\n    if (this[kSawReturnAt] && DateNow() - this[kSawReturnAt] <= this.crlfDelay) {\n      if (StringPrototypeCodePointAt.call(string) === 10) string = StringPrototypeSlice.call(string, 1);\n      this[kSawReturnAt] = 0;\n    }\n\n    // Run test() on the new string chunk, not on the entire line buffer.\n    var newPartContainsEnding = RegExpPrototypeExec.call(lineEnding, string);\n    if (newPartContainsEnding !== null) {\n      if (this[kLine_buffer]) {\n        string = this[kLine_buffer] + string;\n        this[kLine_buffer] = null;\n        newPartContainsEnding = RegExpPrototypeExec.call(lineEnding, string);\n      }\n      this[kSawReturnAt] = StringPrototypeEndsWith.call(string, \"\\r\") ? DateNow() : 0;\n\n      var indexes = [0, newPartContainsEnding.index, lineEnding.lastIndex];\n      var nextMatch;\n      while ((nextMatch = RegExpPrototypeExec.call(lineEnding, string)) !== null) {\n        ArrayPrototypePush.call(indexes, nextMatch.index, lineEnding.lastIndex);\n      }\n      var lastIndex = indexes.length - 1;\n      // Either '' or (conceivably) the unfinished portion of the next line\n      this[kLine_buffer] = StringPrototypeSlice.call(string, indexes[lastIndex]);\n      for (var i = 1; i < lastIndex; i += 2) {\n        this[kOnLine](StringPrototypeSlice.call(string, indexes[i - 1], indexes[i]));\n      }\n    } else if (string) {\n      // No newlines this time, save what we have for next time\n      if (this[kLine_buffer]) {\n        this[kLine_buffer] += string;\n      } else {\n        this[kLine_buffer] = string;\n      }\n    }\n  }\n\n  [kInsertString](c) {\n    this[kBeforeEdit](this.line, this.cursor);\n    if (this.cursor < this.line.length) {\n      var beg = StringPrototypeSlice.call(this.line, 0, this.cursor);\n      var end = StringPrototypeSlice.call(this.line, this.cursor, this.line.length);\n      this.line = beg + c + end;\n      this.cursor += c.length;\n      this[kRefreshLine]();\n    } else {\n      var oldPos = this.getCursorPos();\n      this.line += c;\n      this.cursor += c.length;\n      var newPos = this.getCursorPos();\n\n      if (oldPos.rows < newPos.rows) {\n        this[kRefreshLine]();\n      } else {\n        this[kWriteToOutput](c);\n      }\n    }\n  }\n\n  async [kTabComplete](lastKeypressWasTab) {\n    this.pause();\n    var string = StringPrototypeSlice.call(this.line, 0, this.cursor);\n    var value;\n    try {\n      value = await this.completer(string);\n    } catch (err) {\n      this[kWriteToOutput](`Tab completion error: ${inspect(err)}`);\n      return;\n    } finally {\n      this.resume();\n    }\n    this[kTabCompleter](lastKeypressWasTab, value);\n  }\n\n  [kTabCompleter](lastKeypressWasTab, { 0: completions, 1: completeOn }) {\n    // Result and the text that was completed.\n\n    if (!completions || completions.length === 0) {\n      return;\n    }\n\n    // If there is a common prefix to all matches, then apply that portion.\n    var prefix = commonPrefix(ArrayPrototypeFilter.call(completions, e => e !== \"\"));\n    if (StringPrototypeStartsWith.call(prefix, completeOn) && prefix.length > completeOn.length) {\n      this[kInsertString](StringPrototypeSlice.call(prefix, completeOn.length));\n      return;\n    } else if (!StringPrototypeStartsWith.call(completeOn, prefix)) {\n      this.line =\n        StringPrototypeSlice.call(this.line, 0, this.cursor - completeOn.length) +\n        prefix +\n        StringPrototypeSlice.call(this.line, this.cursor, this.line.length);\n      this.cursor = this.cursor - completeOn.length + prefix.length;\n      this._refreshLine();\n      return;\n    }\n\n    if (!lastKeypressWasTab) {\n      return;\n    }\n\n    this[kBeforeEdit](this.line, this.cursor);\n\n    // Apply/show completions.\n    var completionsWidth = ArrayPrototypeMap.call(completions, e => getStringWidth(e));\n    var width = MathMaxApply(completionsWidth) + 2; // 2 space padding\n    var maxColumns = MathFloor(this.columns / width) || 1;\n    if (maxColumns === Infinity) {\n      maxColumns = 1;\n    }\n    var output = \"\\r\\n\";\n    var lineIndex = 0;\n    var whitespace = 0;\n    for (var i = 0; i < completions.length; i++) {\n      var completion = completions[i];\n      if (completion === \"\" || lineIndex === maxColumns) {\n        output += \"\\r\\n\";\n        lineIndex = 0;\n        whitespace = 0;\n      } else {\n        output += StringPrototypeRepeat.call(\" \", whitespace);\n      }\n      if (completion !== \"\") {\n        output += completion;\n        whitespace = width - completionsWidth[i];\n        lineIndex++;\n      } else {\n        output += \"\\r\\n\";\n      }\n    }\n    if (lineIndex !== 0) {\n      output += \"\\r\\n\\r\\n\";\n    }\n    this[kWriteToOutput](output);\n    this[kRefreshLine]();\n  }\n\n  [kWordLeft]() {\n    if (this.cursor > 0) {\n      // Reverse the string and match a word near beginning\n      // to avoid quadratic time complexity\n      var leading = StringPrototypeSlice.call(this.line, 0, this.cursor);\n      var reversed = ArrayPrototypeJoin.call(ArrayPrototypeReverse.call(ArrayFrom(leading)), \"\");\n      var match = RegExpPrototypeExec.call(/^\\s*(?:[^\\w\\s]+|\\w+)?/, reversed);\n      this[kMoveCursor](-match[0].length);\n    }\n  }\n\n  [kWordRight]() {\n    if (this.cursor < this.line.length) {\n      var trailing = StringPrototypeSlice.call(this.line, this.cursor);\n      var match = RegExpPrototypeExec.call(/^(?:\\s+|[^\\w\\s]+|\\w+)\\s*/, trailing);\n      this[kMoveCursor](match[0].length);\n    }\n  }\n\n  [kDeleteLeft]() {\n    if (this.cursor > 0 && this.line.length > 0) {\n      this[kBeforeEdit](this.line, this.cursor);\n      // The number of UTF-16 units comprising the character to the left\n      var charSize = charLengthLeft(this.line, this.cursor);\n      this.line =\n        StringPrototypeSlice.call(this.line, 0, this.cursor - charSize) +\n        StringPrototypeSlice.call(this.line, this.cursor, this.line.length);\n\n      this.cursor -= charSize;\n      this[kRefreshLine]();\n    }\n  }\n\n  [kDeleteRight]() {\n    if (this.cursor < this.line.length) {\n      this[kBeforeEdit](this.line, this.cursor);\n      // The number of UTF-16 units comprising the character to the left\n      var charSize = charLengthAt(this.line, this.cursor);\n      this.line =\n        StringPrototypeSlice.call(this.line, 0, this.cursor) +\n        StringPrototypeSlice.call(this.line, this.cursor + charSize, this.line.length);\n      this[kRefreshLine]();\n    }\n  }\n\n  [kDeleteWordLeft]() {\n    if (this.cursor > 0) {\n      this[kBeforeEdit](this.line, this.cursor);\n      // Reverse the string and match a word near beginning\n      // to avoid quadratic time complexity\n      var leading = StringPrototypeSlice.call(this.line, 0, this.cursor);\n      var reversed = ArrayPrototypeJoin.call(ArrayPrototypeReverse.call(ArrayFrom(leading)), \"\");\n      var match = RegExpPrototypeExec.call(/^\\s*(?:[^\\w\\s]+|\\w+)?/, reversed);\n      leading = StringPrototypeSlice.call(leading, 0, leading.length - match[0].length);\n      this.line = leading + StringPrototypeSlice.call(this.line, this.cursor, this.line.length);\n      this.cursor = leading.length;\n      this[kRefreshLine]();\n    }\n  }\n\n  [kDeleteWordRight]() {\n    if (this.cursor < this.line.length) {\n      this[kBeforeEdit](this.line, this.cursor);\n      var trailing = StringPrototypeSlice.call(this.line, this.cursor);\n      var match = RegExpPrototypeExec.call(/^(?:\\s+|\\W+|\\w+)\\s*/, trailing);\n      this.line =\n        StringPrototypeSlice.call(this.line, 0, this.cursor) + StringPrototypeSlice.call(trailing, match[0].length);\n      this[kRefreshLine]();\n    }\n  }\n\n  [kDeleteLineLeft]() {\n    this[kBeforeEdit](this.line, this.cursor);\n    var del = StringPrototypeSlice.call(this.line, 0, this.cursor);\n    this.line = StringPrototypeSlice.call(this.line, this.cursor);\n    this.cursor = 0;\n    this[kPushToKillRing](del);\n    this[kRefreshLine]();\n  }\n\n  [kDeleteLineRight]() {\n    this[kBeforeEdit](this.line, this.cursor);\n    var del = StringPrototypeSlice.call(this.line, this.cursor);\n    this.line = StringPrototypeSlice.call(this.line, 0, this.cursor);\n    this[kPushToKillRing](del);\n    this[kRefreshLine]();\n  }\n\n  [kPushToKillRing](del) {\n    if (!del || del === this[kKillRing][0]) return;\n    ArrayPrototypeUnshift.call(this[kKillRing], del);\n    this[kKillRingCursor] = 0;\n    while (this[kKillRing].length > kMaxLengthOfKillRing) ArrayPrototypePop.call(this[kKillRing]);\n  }\n\n  [kYank]() {\n    if (this[kKillRing].length > 0) {\n      this[kYanking] = true;\n      this[kInsertString](this[kKillRing][this[kKillRingCursor]]);\n    }\n  }\n\n  [kYankPop]() {\n    if (!this[kYanking]) {\n      return;\n    }\n    if (this[kKillRing].length > 1) {\n      var lastYank = this[kKillRing][this[kKillRingCursor]];\n      this[kKillRingCursor]++;\n      if (this[kKillRingCursor] >= this[kKillRing].length) {\n        this[kKillRingCursor] = 0;\n      }\n      var currentYank = this[kKillRing][this[kKillRingCursor]];\n      var head = StringPrototypeSlice.call(this.line, 0, this.cursor - lastYank.length);\n      var tail = StringPrototypeSlice.call(this.line, this.cursor);\n      this.line = head + currentYank + tail;\n      this.cursor = head.length + currentYank.length;\n      this[kRefreshLine]();\n    }\n  }\n\n  clearLine() {\n    this[kMoveCursor](+Infinity);\n    this[kWriteToOutput](\"\\r\\n\");\n    this.line = \"\";\n    this.cursor = 0;\n    this.prevRows = 0;\n  }\n\n  [kLine]() {\n    var line = this[kAddHistory]();\n    this[kUndoStack] = [];\n    this[kRedoStack] = [];\n    this.clearLine();\n    this[kOnLine](line);\n  }\n\n  [kPushToUndoStack](text, cursor) {\n    if (ArrayPrototypePush.call(this[kUndoStack], { text, cursor }) > kMaxUndoRedoStackSize) {\n      ArrayPrototypeShift.call(this[kUndoStack]);\n    }\n  }\n\n  [kUndo]() {\n    if (this[kUndoStack].length <= 0) return;\n\n    ArrayPrototypePush.call(this[kRedoStack], {\n      text: this.line,\n      cursor: this.cursor,\n    });\n\n    var entry = ArrayPrototypePop.call(this[kUndoStack]);\n    this.line = entry.text;\n    this.cursor = entry.cursor;\n\n    this[kRefreshLine]();\n  }\n\n  [kRedo]() {\n    if (this[kRedoStack].length <= 0) return;\n\n    ArrayPrototypePush.call(this[kUndoStack], {\n      text: this.line,\n      cursor: this.cursor,\n    });\n\n    var entry = ArrayPrototypePop.call(this[kRedoStack]);\n    this.line = entry.text;\n    this.cursor = entry.cursor;\n\n    this[kRefreshLine]();\n  }\n\n  [kHistoryNext]() {\n    if (this.historyIndex >= 0) {\n      this[kBeforeEdit](this.line, this.cursor);\n      var search = this[kSubstringSearch] || \"\";\n      var index = this.historyIndex - 1;\n      while (\n        index >= 0 &&\n        (!StringPrototypeStartsWith.call(this.history[index], search) || this.line === this.history[index])\n      ) {\n        index--;\n      }\n      if (index === -1) {\n        this.line = search;\n      } else {\n        this.line = this.history[index];\n      }\n      this.historyIndex = index;\n      this.cursor = this.line.length; // Set cursor to end of line.\n      this[kRefreshLine]();\n    }\n  }\n\n  [kHistoryPrev]() {\n    if (this.historyIndex < this.history.length && this.history.length) {\n      this[kBeforeEdit](this.line, this.cursor);\n      var search = this[kSubstringSearch] || \"\";\n      var index = this.historyIndex + 1;\n      while (\n        index < this.history.length &&\n        (!StringPrototypeStartsWith.call(this.history[index], search) || this.line === this.history[index])\n      ) {\n        index++;\n      }\n      if (index === this.history.length) {\n        this.line = search;\n      } else {\n        this.line = this.history[index];\n      }\n      this.historyIndex = index;\n      this.cursor = this.line.length; // Set cursor to end of line.\n      this[kRefreshLine]();\n    }\n  }\n\n  // Returns the last character's display position of the given string\n  [kGetDisplayPos](str) {\n    var offset = 0;\n    var col = this.columns;\n    var rows = 0;\n    str = stripVTControlCharacters(str);\n    for (var char of new SafeStringIterator(str)) {\n      if (char === \"\\n\") {\n        // Rows must be incremented by 1 even if offset = 0 or col = +Infinity.\n        rows += MathCeil(offset / col) || 1;\n        offset = 0;\n        continue;\n      }\n      // Tabs must be aligned by an offset of the tab size.\n      if (char === \"\\t\") {\n        offset += this.tabSize - (offset % this.tabSize);\n        continue;\n      }\n      var width = getStringWidth(char, false /* stripVTControlCharacters */);\n      if (width === 0 || width === 1) {\n        offset += width;\n      } else {\n        // width === 2\n        if ((offset + 1) % col === 0) {\n          offset++;\n        }\n        offset += 2;\n      }\n    }\n    var cols = offset % col;\n    rows += (offset - cols) / col;\n    return { cols, rows };\n  }\n\n  /**\n   * Returns the real position of the cursor in relation\n   * to the input prompt + string.\n   * @returns {{\n   *   rows: number;\n   *   cols: number;\n   * }}\n   */\n  getCursorPos() {\n    var strBeforeCursor = this[kPrompt] + StringPrototypeSlice.call(this.line, 0, this.cursor);\n    return this[kGetDisplayPos](strBeforeCursor);\n  }\n\n  // This function moves cursor dx places to the right\n  // (-dx for left) and refreshes the line if it is needed.\n  [kMoveCursor](dx) {\n    if (dx === 0) {\n      return;\n    }\n    var oldPos = this.getCursorPos();\n    this.cursor += dx;\n\n    // Bounds check\n    if (this.cursor < 0) {\n      this.cursor = 0;\n    } else if (this.cursor > this.line.length) {\n      this.cursor = this.line.length;\n    }\n\n    var newPos = this.getCursorPos();\n\n    // Check if cursor stayed on the line.\n    if (oldPos.rows === newPos.rows) {\n      var diffWidth = newPos.cols - oldPos.cols;\n      moveCursor(this.output, diffWidth, 0);\n    } else {\n      this[kRefreshLine]();\n    }\n  }\n\n  // Handle a write from the tty\n  [kTtyWrite](s, key) {\n    var previousKey = this[kPreviousKey];\n    key = key || kEmptyObject;\n    this[kPreviousKey] = key;\n    var { name: keyName, meta: keyMeta, ctrl: keyCtrl, shift: keyShift, sequence: keySeq } = key;\n\n    if (!keyMeta || keyName !== \"y\") {\n      // Reset yanking state unless we are doing yank pop.\n      this[kYanking] = false;\n    }\n\n    // Activate or deactivate substring search.\n    if ((keyName === \"up\" || keyName === \"down\") && !keyCtrl && !keyMeta && !keyShift) {\n      if (this[kSubstringSearch] === null) {\n        this[kSubstringSearch] = StringPrototypeSlice.call(this.line, 0, this.cursor);\n      }\n    } else if (this[kSubstringSearch] !== null) {\n      this[kSubstringSearch] = null;\n      // Reset the index in case there's no match.\n      if (this.history.length === this.historyIndex) {\n        this.historyIndex = -1;\n      }\n    }\n\n    // Undo & Redo\n    if (typeof keySeq === \"string\") {\n      switch (StringPrototypeCodePointAt.call(keySeq, 0)) {\n        case 0x1f:\n          this[kUndo]();\n          return;\n        case 0x1e:\n          this[kRedo]();\n          return;\n        default:\n          break;\n      }\n    }\n\n    // Ignore escape key, fixes\n    // https://github.com/nodejs/node-v0.x-archive/issues/2876.\n    if (keyName === \"escape\") return;\n\n    if (keyCtrl && keyShift) {\n      /* Control and shift pressed */\n      switch (keyName) {\n        // TODO(BridgeAR): The transmitted escape sequence is `\\b` and that is\n        // identical to <ctrl>-h. It should have a unique escape sequence.\n        case \"backspace\":\n          this[kDeleteLineLeft]();\n          break;\n\n        case \"delete\":\n          this[kDeleteLineRight]();\n          break;\n      }\n    } else if (keyCtrl) {\n      /* Control key pressed */\n\n      switch (keyName) {\n        case \"c\":\n          if (this.listenerCount(\"SIGINT\") > 0) {\n            this.emit(\"SIGINT\");\n          } else {\n            // This readline instance is finished\n            this.close();\n          }\n          break;\n\n        case \"h\": // delete left\n          this[kDeleteLeft]();\n          break;\n\n        case \"d\": // delete right or EOF\n          if (this.cursor === 0 && this.line.length === 0) {\n            // This readline instance is finished\n            this.close();\n          } else if (this.cursor < this.line.length) {\n            this[kDeleteRight]();\n          }\n          break;\n\n        case \"u\": // Delete from current to start of line\n          this[kDeleteLineLeft]();\n          break;\n\n        case \"k\": // Delete from current to end of line\n          this[kDeleteLineRight]();\n          break;\n\n        case \"a\": // Go to the start of the line\n          this[kMoveCursor](-Infinity);\n          break;\n\n        case \"e\": // Go to the end of the line\n          this[kMoveCursor](+Infinity);\n          break;\n\n        case \"b\": // back one character\n          this[kMoveCursor](-charLengthLeft(this.line, this.cursor));\n          break;\n\n        case \"f\": // Forward one character\n          this[kMoveCursor](+charLengthAt(this.line, this.cursor));\n          break;\n\n        case \"l\": // Clear the whole screen\n          cursorTo(this.output, 0, 0);\n          clearScreenDown(this.output);\n          this[kRefreshLine]();\n          break;\n\n        case \"n\": // next history item\n          this[kHistoryNext]();\n          break;\n\n        case \"p\": // Previous history item\n          this[kHistoryPrev]();\n          break;\n\n        case \"y\": // Yank killed string\n          this[kYank]();\n          break;\n\n        case \"z\":\n          if (process.platform === \"win32\") break;\n          if (this.listenerCount(\"SIGTSTP\") > 0) {\n            this.emit(\"SIGTSTP\");\n          } else {\n            process.once(\"SIGCONT\", () => {\n              // Don't raise events if stream has already been abandoned.\n              if (!this.paused) {\n                // Stream must be paused and resumed after SIGCONT to catch\n                // SIGINT, SIGTSTP, and EOF.\n                this.pause();\n                this.emit(\"SIGCONT\");\n              }\n              // Explicitly re-enable \"raw mode\" and move the cursor to\n              // the correct position.\n              // See https://github.com/joyent/node/issues/3295.\n              this[kSetRawMode](true);\n              this[kRefreshLine]();\n            });\n            this[kSetRawMode](false);\n            process.kill(process.pid, \"SIGTSTP\");\n          }\n          break;\n\n        case \"w\": // Delete backwards to a word boundary\n        case \"backspace\":\n          this[kDeleteWordLeft]();\n          break;\n\n        case \"delete\": // Delete forward to a word boundary\n          this[kDeleteWordRight]();\n          break;\n\n        case \"left\":\n          this[kWordLeft]();\n          break;\n\n        case \"right\":\n          this[kWordRight]();\n          break;\n      }\n    } else if (keyMeta) {\n      /* Meta key pressed */\n\n      switch (keyName) {\n        case \"b\": // backward word\n          this[kWordLeft]();\n          break;\n\n        case \"f\": // forward word\n          this[kWordRight]();\n          break;\n\n        case \"d\": // delete forward word\n        case \"delete\":\n          this[kDeleteWordRight]();\n          break;\n\n        case \"backspace\": // Delete backwards to a word boundary\n          this[kDeleteWordLeft]();\n          break;\n\n        case \"y\": // Doing yank pop\n          this[kYankPop]();\n          break;\n      }\n    } else {\n      /* No modifier keys used */\n\n      // \\r bookkeeping is only relevant if a \\n comes right after.\n      if (this[kSawReturnAt] && keyName !== \"enter\") this[kSawReturnAt] = 0;\n\n      switch (keyName) {\n        case \"return\": // Carriage return, i.e. \\r\n          this[kSawReturnAt] = DateNow();\n          this[kLine]();\n          break;\n\n        case \"enter\":\n          // When key interval > crlfDelay\n          if (this[kSawReturnAt] === 0 || DateNow() - this[kSawReturnAt] > this.crlfDelay) {\n            this[kLine]();\n          }\n          this[kSawReturnAt] = 0;\n          break;\n\n        case \"backspace\":\n          this[kDeleteLeft]();\n          break;\n\n        case \"delete\":\n          this[kDeleteRight]();\n          break;\n\n        case \"left\":\n          // Obtain the code point to the left\n          this[kMoveCursor](-charLengthLeft(this.line, this.cursor));\n          break;\n\n        case \"right\":\n          this[kMoveCursor](+charLengthAt(this.line, this.cursor));\n          break;\n\n        case \"home\":\n          this[kMoveCursor](-Infinity);\n          break;\n\n        case \"end\":\n          this[kMoveCursor](+Infinity);\n          break;\n\n        case \"up\":\n          this[kHistoryPrev]();\n          break;\n\n        case \"down\":\n          this[kHistoryNext]();\n          break;\n\n        case \"tab\":\n          // If tab completion enabled, do that...\n          if (typeof this.completer === \"function\" && this.isCompletionEnabled) {\n            var lastKeypressWasTab = previousKey && previousKey.name === \"tab\";\n            this[kTabComplete](lastKeypressWasTab);\n            break;\n          }\n        // falls through\n        default:\n          if (typeof s === \"string\" && s) {\n            var nextMatch = RegExpPrototypeExec.call(lineEnding, s);\n            if (nextMatch !== null) {\n              this[kInsertString](StringPrototypeSlice.call(s, 0, nextMatch.index));\n              var { lastIndex } = lineEnding;\n              while ((nextMatch = RegExpPrototypeExec.call(lineEnding, s)) !== null) {\n                this[kLine]();\n                this[kInsertString](StringPrototypeSlice.call(s, lastIndex, nextMatch.index));\n                ({ lastIndex } = lineEnding);\n              }\n              if (lastIndex === s.length) this[kLine]();\n            } else {\n              this[kInsertString](s);\n            }\n          }\n      }\n    }\n  }\n\n  /**\n   * Creates an `AsyncIterator` object that iterates through\n   * each line in the input stream as a string.\n   * @typedef {{\n   *   [Symbol.asyncIterator]: () => InterfaceAsyncIterator,\n   *   next: () => Promise<string>\n   * }} InterfaceAsyncIterator\n   * @returns {InterfaceAsyncIterator}\n   */\n  [SymbolAsyncIterator]() {\n    if (this[kLineObjectStream] === undefined) {\n      this[kLineObjectStream] = EventEmitter.on(this, \"line\", {\n        close: [\"close\"],\n        highWatermark: 1024,\n        [kFirstEventParam]: true,\n      });\n    }\n    return this[kLineObjectStream];\n  }\n};\n\nfunction Interface(input, output, completer, terminal) {\n  if (!(this instanceof Interface)) {\n    return new Interface(input, output, completer, terminal);\n  }\n\n  if (input?.input && typeof input.completer === \"function\" && input.completer.length !== 2) {\n    var { completer } = input;\n    input.completer = (v, cb) => cb(null, completer(v));\n  } else if (typeof completer === \"function\" && completer.length !== 2) {\n    var realCompleter = completer;\n    completer = (v, cb) => cb(null, realCompleter(v));\n  }\n\n  InterfaceConstructor.call(this, input, output, completer, terminal);\n\n  // TODO: Test this\n  if (process.env.TERM === \"dumb\") {\n    this._ttyWrite = _ttyWriteDumb.bind(this);\n  }\n}\n\nObjectSetPrototypeOf(Interface.prototype, _Interface.prototype);\nObjectSetPrototypeOf(Interface, _Interface);\n\n/**\n * Displays `query` by writing it to the `output`.\n * @param {string} query\n * @param {{ signal?: AbortSignal; }} [options]\n * @param {Function} cb\n * @returns {void}\n */\nInterface.prototype.question = function question(query, options, cb) {\n  cb = typeof options === \"function\" ? options : cb;\n  if (options === null || typeof options !== \"object\") {\n    options = kEmptyObject;\n  }\n\n  var signal = options?.signal;\n  if (signal) {\n    validateAbortSignal(signal, \"options.signal\");\n    if (signal.aborted) {\n      return;\n    }\n\n    var onAbort = () => {\n      this[kQuestionCancel]();\n    };\n    signal.addEventListener(\"abort\", onAbort, { once: true });\n    var cleanup = () => {\n      signal.removeEventListener(\"abort\", onAbort);\n    };\n    var originalCb = cb;\n    cb =\n      typeof cb === \"function\"\n        ? answer => {\n            cleanup();\n            return originalCb(answer);\n          }\n        : cleanup;\n  }\n\n  if (typeof cb === \"function\") {\n    this[kQuestion](query, cb);\n  }\n};\n\nInterface.prototype.question[promisify.custom] = function question(query, options) {\n  if (options === null || typeof options !== \"object\") {\n    options = kEmptyObject;\n  }\n\n  var signal = options?.signal;\n\n  if (signal && signal.aborted) {\n    return PromiseReject(new AbortError(undefined, { cause: signal.reason }));\n  }\n\n  return new Promise((resolve, reject) => {\n    var cb = resolve;\n    if (signal) {\n      var onAbort = () => {\n        reject(new AbortError(undefined, { cause: signal.reason }));\n      };\n      signal.addEventListener(\"abort\", onAbort, { once: true });\n      cb = answer => {\n        signal.removeEventListener(\"abort\", onAbort);\n        resolve(answer);\n      };\n    }\n    this.question(query, options, cb);\n  });\n};\n\n/**\n * Creates a new `readline.Interface` instance.\n * @param {Readable | {\n *   input: Readable;\n *   output: Writable;\n *   completer?: Function;\n *   terminal?: boolean;\n *   history?: string[];\n *   historySize?: number;\n *   removeHistoryDuplicates?: boolean;\n *   prompt?: string;\n *   crlfDelay?: number;\n *   escapeCodeTimeout?: number;\n *   tabSize?: number;\n *   signal?: AbortSignal;\n *   }} input\n * @param {Writable} [output]\n * @param {Function} [completer]\n * @param {boolean} [terminal]\n * @returns {Interface}\n */\nfunction createInterface(input, output, completer, terminal) {\n  return new Interface(input, output, completer, terminal);\n}\n\nObjectDefineProperties(Interface.prototype, {\n  // Redirect internal prototype methods to the underscore notation for backward\n  // compatibility.\n  [kSetRawMode]: {\n    __proto__: null,\n    get() {\n      return this._setRawMode;\n    },\n  },\n  [kOnLine]: {\n    __proto__: null,\n    get() {\n      return this._onLine;\n    },\n  },\n  [kWriteToOutput]: {\n    __proto__: null,\n    get() {\n      return this._writeToOutput;\n    },\n  },\n  [kAddHistory]: {\n    __proto__: null,\n    get() {\n      return this._addHistory;\n    },\n  },\n  [kRefreshLine]: {\n    __proto__: null,\n    get() {\n      return this._refreshLine;\n    },\n  },\n  [kNormalWrite]: {\n    __proto__: null,\n    get() {\n      return this._normalWrite;\n    },\n  },\n  [kInsertString]: {\n    __proto__: null,\n    get() {\n      return this._insertString;\n    },\n  },\n  [kTabComplete]: {\n    __proto__: null,\n    get() {\n      return this._tabComplete;\n    },\n  },\n  [kWordLeft]: {\n    __proto__: null,\n    get() {\n      return this._wordLeft;\n    },\n  },\n  [kWordRight]: {\n    __proto__: null,\n    get() {\n      return this._wordRight;\n    },\n  },\n  [kDeleteLeft]: {\n    __proto__: null,\n    get() {\n      return this._deleteLeft;\n    },\n  },\n  [kDeleteRight]: {\n    __proto__: null,\n    get() {\n      return this._deleteRight;\n    },\n  },\n  [kDeleteWordLeft]: {\n    __proto__: null,\n    get() {\n      return this._deleteWordLeft;\n    },\n  },\n  [kDeleteWordRight]: {\n    __proto__: null,\n    get() {\n      return this._deleteWordRight;\n    },\n  },\n  [kDeleteLineLeft]: {\n    __proto__: null,\n    get() {\n      return this._deleteLineLeft;\n    },\n  },\n  [kDeleteLineRight]: {\n    __proto__: null,\n    get() {\n      return this._deleteLineRight;\n    },\n  },\n  [kLine]: {\n    __proto__: null,\n    get() {\n      return this._line;\n    },\n  },\n  [kHistoryNext]: {\n    __proto__: null,\n    get() {\n      return this._historyNext;\n    },\n  },\n  [kHistoryPrev]: {\n    __proto__: null,\n    get() {\n      return this._historyPrev;\n    },\n  },\n  [kGetDisplayPos]: {\n    __proto__: null,\n    get() {\n      return this._getDisplayPos;\n    },\n  },\n  [kMoveCursor]: {\n    __proto__: null,\n    get() {\n      return this._moveCursor;\n    },\n  },\n  [kTtyWrite]: {\n    __proto__: null,\n    get() {\n      return this._ttyWrite;\n    },\n  },\n\n  // Defining proxies for the internal instance properties for backward\n  // compatibility.\n  _decoder: {\n    __proto__: null,\n    get() {\n      return this[kDecoder];\n    },\n    set(value) {\n      this[kDecoder] = value;\n    },\n  },\n  _line_buffer: {\n    __proto__: null,\n    get() {\n      return this[kLine_buffer];\n    },\n    set(value) {\n      this[kLine_buffer] = value;\n    },\n  },\n  _oldPrompt: {\n    __proto__: null,\n    get() {\n      return this[kOldPrompt];\n    },\n    set(value) {\n      this[kOldPrompt] = value;\n    },\n  },\n  _previousKey: {\n    __proto__: null,\n    get() {\n      return this[kPreviousKey];\n    },\n    set(value) {\n      this[kPreviousKey] = value;\n    },\n  },\n  _prompt: {\n    __proto__: null,\n    get() {\n      return this[kPrompt];\n    },\n    set(value) {\n      this[kPrompt] = value;\n    },\n  },\n  _questionCallback: {\n    __proto__: null,\n    get() {\n      return this[kQuestionCallback];\n    },\n    set(value) {\n      this[kQuestionCallback] = value;\n    },\n  },\n  _sawKeyPress: {\n    __proto__: null,\n    get() {\n      return this[kSawKeyPress];\n    },\n    set(value) {\n      this[kSawKeyPress] = value;\n    },\n  },\n  _sawReturnAt: {\n    __proto__: null,\n    get() {\n      return this[kSawReturnAt];\n    },\n    set(value) {\n      this[kSawReturnAt] = value;\n    },\n  },\n});\n\n// Make internal methods public for backward compatibility.\nInterface.prototype._setRawMode = _Interface.prototype[kSetRawMode];\nInterface.prototype._onLine = _Interface.prototype[kOnLine];\nInterface.prototype._writeToOutput = _Interface.prototype[kWriteToOutput];\nInterface.prototype._addHistory = _Interface.prototype[kAddHistory];\nInterface.prototype._refreshLine = _Interface.prototype[kRefreshLine];\nInterface.prototype._normalWrite = _Interface.prototype[kNormalWrite];\nInterface.prototype._insertString = _Interface.prototype[kInsertString];\nInterface.prototype._tabComplete = function (lastKeypressWasTab) {\n  // Overriding parent method because `this.completer` in the legacy\n  // implementation takes a callback instead of being an async function.\n  this.pause();\n  var string = StringPrototypeSlice.call(this.line, 0, this.cursor);\n  this.completer(string, (err, value) => {\n    this.resume();\n\n    if (err) {\n      this._writeToOutput(`Tab completion error: ${inspect(err)}`);\n      return;\n    }\n\n    this[kTabCompleter](lastKeypressWasTab, value);\n  });\n};\nInterface.prototype._wordLeft = _Interface.prototype[kWordLeft];\nInterface.prototype._wordRight = _Interface.prototype[kWordRight];\nInterface.prototype._deleteLeft = _Interface.prototype[kDeleteLeft];\nInterface.prototype._deleteRight = _Interface.prototype[kDeleteRight];\nInterface.prototype._deleteWordLeft = _Interface.prototype[kDeleteWordLeft];\nInterface.prototype._deleteWordRight = _Interface.prototype[kDeleteWordRight];\nInterface.prototype._deleteLineLeft = _Interface.prototype[kDeleteLineLeft];\nInterface.prototype._deleteLineRight = _Interface.prototype[kDeleteLineRight];\nInterface.prototype._line = _Interface.prototype[kLine];\nInterface.prototype._historyNext = _Interface.prototype[kHistoryNext];\nInterface.prototype._historyPrev = _Interface.prototype[kHistoryPrev];\nInterface.prototype._getDisplayPos = _Interface.prototype[kGetDisplayPos];\nInterface.prototype._getCursorPos = _Interface.prototype.getCursorPos;\nInterface.prototype._moveCursor = _Interface.prototype[kMoveCursor];\nInterface.prototype._ttyWrite = _Interface.prototype[kTtyWrite];\n\nfunction _ttyWriteDumb(s, key) {\n  key = key || kEmptyObject;\n\n  if (key.name === \"escape\") return;\n\n  if (this[kSawReturnAt] && key.name !== \"enter\") this[kSawReturnAt] = 0;\n\n  if (keyCtrl) {\n    if (key.name === \"c\") {\n      if (this.listenerCount(\"SIGINT\") > 0) {\n        this.emit(\"SIGINT\");\n      } else {\n        // This readline instance is finished\n        this.close();\n      }\n\n      return;\n    } else if (key.name === \"d\") {\n      this.close();\n      return;\n    }\n  }\n\n  switch (key.name) {\n    case \"return\": // Carriage return, i.e. \\r\n      this[kSawReturnAt] = DateNow();\n      this._line();\n      break;\n\n    case \"enter\":\n      // When key interval > crlfDelay\n      if (this[kSawReturnAt] === 0 || DateNow() - this[kSawReturnAt] > this.crlfDelay) {\n        this._line();\n      }\n      this[kSawReturnAt] = 0;\n      break;\n\n    default:\n      if (typeof s === \"string\" && s) {\n        this.line += s;\n        this.cursor += s.length;\n        this._writeToOutput(s);\n      }\n  }\n}\n\nclass Readline {\n  #autoCommit = false;\n  #stream;\n  #todo = [];\n\n  constructor(stream, options = undefined) {\n    isWritable ??= import.meta.require(\"node:stream\").isWritable;\n    if (!isWritable(stream)) throw new ERR_INVALID_ARG_TYPE(\"stream\", \"Writable\", stream);\n    this.#stream = stream;\n    if (options?.autoCommit != null) {\n      validateBoolean(options.autoCommit, \"options.autoCommit\");\n      this.#autoCommit = options.autoCommit;\n    }\n  }\n\n  /**\n   * Moves the cursor to the x and y coordinate on the given stream.\n   * @param {integer} x\n   * @param {integer} [y]\n   * @returns {Readline} this\n   */\n  cursorTo(x, y = undefined) {\n    validateInteger(x, \"x\");\n    if (y != null) validateInteger(y, \"y\");\n\n    var data = y == null ? CSI`${x + 1}G` : CSI`${y + 1};${x + 1}H`;\n    if (this.#autoCommit) process.nextTick(() => this.#stream.write(data));\n    else ArrayPrototypePush.call(this.#todo, data);\n\n    return this;\n  }\n\n  /**\n   * Moves the cursor relative to its current location.\n   * @param {integer} dx\n   * @param {integer} dy\n   * @returns {Readline} this\n   */\n  moveCursor(dx, dy) {\n    if (dx || dy) {\n      validateInteger(dx, \"dx\");\n      validateInteger(dy, \"dy\");\n\n      var data = \"\";\n\n      if (dx < 0) {\n        data += CSI`${-dx}D`;\n      } else if (dx > 0) {\n        data += CSI`${dx}C`;\n      }\n\n      if (dy < 0) {\n        data += CSI`${-dy}A`;\n      } else if (dy > 0) {\n        data += CSI`${dy}B`;\n      }\n      if (this.#autoCommit) process.nextTick(() => this.#stream.write(data));\n      else ArrayPrototypePush.call(this.#todo, data);\n    }\n    return this;\n  }\n\n  /**\n   * Clears the current line the cursor is on.\n   * @param {-1|0|1} dir Direction to clear:\n   *   -1 for left of the cursor\n   *   +1 for right of the cursor\n   *    0 for the entire line\n   * @returns {Readline} this\n   */\n  clearLine(dir) {\n    validateInteger(dir, \"dir\", -1, 1);\n\n    var data = dir < 0 ? kClearToLineBeginning : dir > 0 ? kClearToLineEnd : kClearLine;\n    if (this.#autoCommit) process.nextTick(() => this.#stream.write(data));\n    else ArrayPrototypePush.call(this.#todo, data);\n    return this;\n  }\n\n  /**\n   * Clears the screen from the current position of the cursor down.\n   * @returns {Readline} this\n   */\n  clearScreenDown() {\n    if (this.#autoCommit) {\n      process.nextTick(() => this.#stream.write(kClearScreenDown));\n    } else {\n      ArrayPrototypePush.call(this.#todo, kClearScreenDown);\n    }\n    return this;\n  }\n\n  /**\n   * Sends all the pending actions to the associated `stream` and clears the\n   * internal list of pending actions.\n   * @returns {Promise<void>} Resolves when all pending actions have been\n   * flushed to the associated `stream`.\n   */\n  commit() {\n    return new Promise(resolve => {\n      this.#stream.write(ArrayPrototypeJoin.call(this.#todo, \"\"), resolve);\n      this.#todo = [];\n    });\n  }\n\n  /**\n   * Clears the internal list of pending actions without sending it to the\n   * associated `stream`.\n   * @returns {Readline} this\n   */\n  rollback() {\n    this.#todo = [];\n    return this;\n  }\n}\n\nvar PromisesInterface = class Interface extends _Interface {\n  // eslint-disable-next-line no-useless-constructor\n  constructor(input, output, completer, terminal) {\n    super(input, output, completer, terminal);\n  }\n  question(query, options = kEmptyObject) {\n    var signal = options?.signal;\n    if (signal) {\n      validateAbortSignal(signal, \"options.signal\");\n      if (signal.aborted) {\n        return PromiseReject(new AbortError(undefined, { cause: signal.reason }));\n      }\n    }\n    return new Promise((resolve, reject) => {\n      var cb = resolve;\n      if (options?.signal) {\n        var onAbort = () => {\n          this[kQuestionCancel]();\n          reject(new AbortError(undefined, { cause: signal.reason }));\n        };\n        signal.addEventListener(\"abort\", onAbort, { once: true });\n        cb = answer => {\n          signal.removeEventListener(\"abort\", onAbort);\n          resolve(answer);\n        };\n      }\n      this[kQuestion](query, cb);\n    });\n  }\n};\n\n// ----------------------------------------------------------------------------\n// Exports\n// ----------------------------------------------------------------------------\nexport var Interface = Interface;\nexport var clearLine = clearLine;\nexport var clearScreenDown = clearScreenDown;\nexport var createInterface = createInterface;\nexport var cursorTo = cursorTo;\nexport var emitKeypressEvents = emitKeypressEvents;\nexport var moveCursor = moveCursor;\nexport var promises = {\n  Readline,\n  Interface: PromisesInterface,\n  createInterface(input, output, completer, terminal) {\n    return new PromisesInterface(input, output, completer, terminal);\n  },\n};\n\nexport default {\n  Interface,\n  clearLine,\n  clearScreenDown,\n  createInterface,\n  cursorTo,\n  emitKeypressEvents,\n  moveCursor,\n  promises,\n\n  [SymbolFor(\"__BUN_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED__\")]: {\n    CSI,\n    utils: {\n      getStringWidth,\n      stripVTControlCharacters,\n    },\n  },\n  [SymbolFor(\"CommonJS\")]: 0,\n};\n",
  "// Hardcoded module \"node:readline\"\n// Attribution: Some parts of of this module are derived from code originating from the Node.js\n// readline module which is licensed under an MIT license:\n//\n// Copyright Node.js contributors. All rights reserved.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to\n// deal in the Software without restriction, including without limitation the\n// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n// sell copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n// IN THE SOFTWARE.\n\n// ----------------------------------------------------------------------------\n// Section: Imports\n// ----------------------------------------------------------------------------\nvar { Array, RegExp, String, Bun } = import.meta.primordials;\nvar EventEmitter = import.meta.require(\"node:events\");\nvar { clearTimeout, setTimeout } = import.meta.require(\"timers\");\nvar { StringDecoder } = import.meta.require(\"string_decoder\");\nvar isWritable;\n\nvar { inspect } = Bun;\nvar debug = process.env.BUN_JS_DEBUG ? console.log : () => {};\n\n// ----------------------------------------------------------------------------\n// Section: Preamble\n// ----------------------------------------------------------------------------\n\nvar SymbolAsyncIterator = Symbol.asyncIterator;\nvar SymbolIterator = Symbol.iterator;\nvar SymbolFor = Symbol.for;\nvar SymbolReplace = Symbol.replace;\nvar ArrayFrom = Array.from;\nvar ArrayIsArray = Array.isArray;\nvar ArrayPrototypeFilter = Array.prototype.filter;\nvar ArrayPrototypeSort = Array.prototype.sort;\nvar ArrayPrototypeIndexOf = Array.prototype.indexOf;\nvar ArrayPrototypeJoin = Array.prototype.join;\nvar ArrayPrototypeMap = Array.prototype.map;\nvar ArrayPrototypePop = Array.prototype.pop;\nvar ArrayPrototypePush = Array.prototype.push;\nvar ArrayPrototypeSlice = Array.prototype.slice;\nvar ArrayPrototypeSplice = Array.prototype.splice;\nvar ArrayPrototypeReverse = Array.prototype.reverse;\nvar ArrayPrototypeShift = Array.prototype.shift;\nvar ArrayPrototypeUnshift = Array.prototype.unshift;\nvar RegExpPrototypeExec = RegExp.prototype.exec;\nvar RegExpPrototypeSymbolReplace = RegExp.prototype[SymbolReplace];\nvar StringFromCharCode = String.fromCharCode;\nvar StringPrototypeCharCodeAt = String.prototype.charCodeAt;\nvar StringPrototypeCodePointAt = String.prototype.codePointAt;\nvar StringPrototypeSlice = String.prototype.slice;\nvar StringPrototypeToLowerCase = String.prototype.toLowerCase;\nvar StringPrototypeEndsWith = String.prototype.endsWith;\nvar StringPrototypeRepeat = String.prototype.repeat;\nvar StringPrototypeStartsWith = String.prototype.startsWith;\nvar StringPrototypeTrim = String.prototype.trim;\nvar StringPrototypeNormalize = String.prototype.normalize;\nvar NumberIsNaN = Number.isNaN;\nvar NumberIsFinite = Number.isFinite;\nvar NumberIsInteger = Number.isInteger;\nvar NumberMAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER;\nvar NumberMIN_SAFE_INTEGER = Number.MIN_SAFE_INTEGER;\nvar MathCeil = Math.ceil;\nvar MathFloor = Math.floor;\nvar MathMax = Math.max;\nvar MathMaxApply = Math.max.apply;\nvar DateNow = Date.now;\nvar FunctionPrototype = Function.prototype;\nvar StringPrototype = String.prototype;\nvar StringPrototypeSymbolIterator = StringPrototype[SymbolIterator];\nvar StringIteratorPrototypeNext = StringPrototypeSymbolIterator.call(\"\").next;\nvar ObjectSetPrototypeOf = Object.setPrototypeOf;\nvar ObjectDefineProperty = Object.defineProperty;\nvar ObjectDefineProperties = Object.defineProperties;\nvar ObjectFreeze = Object.freeze;\nvar ObjectAssign = Object.assign;\nvar ObjectCreate = Object.create;\nvar ObjectKeys = Object.keys;\nvar ObjectSeal = Object.seal;\n\nvar createSafeIterator = (factory, next) => {\n  class SafeIterator {\n    #iterator;\n    constructor(iterable) {\n      this.#iterator = factory.call(iterable);\n    }\n    next() {\n      return next.call(this.#iterator);\n    }\n    [SymbolIterator]() {\n      return this;\n    }\n  }\n  ObjectSetPrototypeOf(SafeIterator.prototype, null);\n  ObjectFreeze(SafeIterator.prototype);\n  ObjectFreeze(SafeIterator);\n  return SafeIterator;\n};\n\nvar SafeStringIterator = createSafeIterator(StringPrototypeSymbolIterator, StringIteratorPrototypeNext);\n\n// ----------------------------------------------------------------------------\n// Section: \"Internal\" modules\n// ----------------------------------------------------------------------------\n\n/**\n * Returns true if the character represented by a given\n * Unicode code point is full-width. Otherwise returns false.\n */\nvar isFullWidthCodePoint = code => {\n  // Code points are partially derived from:\n  // https://www.unicode.org/Public/UNIDATA/EastAsianWidth.txt\n  return (\n    code >= 0x1100 &&\n    (code <= 0x115f || // Hangul Jamo\n      code === 0x2329 || // LEFT-POINTING ANGLE BRACKET\n      code === 0x232a || // RIGHT-POINTING ANGLE BRACKET\n      // CJK Radicals Supplement .. Enclosed CJK Letters and Months\n      (code >= 0x2e80 && code <= 0x3247 && code !== 0x303f) ||\n      // Enclosed CJK Letters and Months .. CJK Unified Ideographs Extension A\n      (code >= 0x3250 && code <= 0x4dbf) ||\n      // CJK Unified Ideographs .. Yi Radicals\n      (code >= 0x4e00 && code <= 0xa4c6) ||\n      // Hangul Jamo Extended-A\n      (code >= 0xa960 && code <= 0xa97c) ||\n      // Hangul Syllables\n      (code >= 0xac00 && code <= 0xd7a3) ||\n      // CJK Compatibility Ideographs\n      (code >= 0xf900 && code <= 0xfaff) ||\n      // Vertical Forms\n      (code >= 0xfe10 && code <= 0xfe19) ||\n      // CJK Compatibility Forms .. Small Form Variants\n      (code >= 0xfe30 && code <= 0xfe6b) ||\n      // Halfwidth and Fullwidth Forms\n      (code >= 0xff01 && code <= 0xff60) ||\n      (code >= 0xffe0 && code <= 0xffe6) ||\n      // Kana Supplement\n      (code >= 0x1b000 && code <= 0x1b001) ||\n      // Enclosed Ideographic Supplement\n      (code >= 0x1f200 && code <= 0x1f251) ||\n      // Miscellaneous Symbols and Pictographs 0x1f300 - 0x1f5ff\n      // Emoticons 0x1f600 - 0x1f64f\n      (code >= 0x1f300 && code <= 0x1f64f) ||\n      // CJK Unified Ideographs Extension B .. Tertiary Ideographic Plane\n      (code >= 0x20000 && code <= 0x3fffd))\n  );\n};\n\nvar isZeroWidthCodePoint = code => {\n  return (\n    code <= 0x1f || // C0 control codes\n    (code >= 0x7f && code <= 0x9f) || // C1 control codes\n    (code >= 0x300 && code <= 0x36f) || // Combining Diacritical Marks\n    (code >= 0x200b && code <= 0x200f) || // Modifying Invisible Characters\n    // Combining Diacritical Marks for Symbols\n    (code >= 0x20d0 && code <= 0x20ff) ||\n    (code >= 0xfe00 && code <= 0xfe0f) || // Variation Selectors\n    (code >= 0xfe20 && code <= 0xfe2f) || // Combining Half Marks\n    (code >= 0xe0100 && code <= 0xe01ef)\n  ); // Variation Selectors\n};\n\n/**\n * Returns the number of columns required to display the given string.\n */\nvar getStringWidth = function getStringWidth(str, removeControlChars = true) {\n  var width = 0;\n\n  if (removeControlChars) str = stripVTControlCharacters(str);\n  str = StringPrototypeNormalize.call(str, \"NFC\");\n  for (var char of new SafeStringIterator(str)) {\n    var code = StringPrototypeCodePointAt.call(char, 0);\n    if (isFullWidthCodePoint(code)) {\n      width += 2;\n    } else if (!isZeroWidthCodePoint(code)) {\n      width++;\n    }\n  }\n\n  return width;\n};\n\n// Regex used for ansi escape code splitting\n// Adopted from https://github.com/chalk/ansi-regex/blob/HEAD/index.js\n// License: MIT, authors: @sindresorhus, Qix-, arjunmehta and LitoMore\n// Matches all ansi escape code sequences in a string\nvar ansiPattern =\n  \"[\\\\u001B\\\\u009B][[\\\\]()#;?]*\" +\n  \"(?:(?:(?:(?:;[-a-zA-Z\\\\d\\\\/#&.:=?%@~_]+)*\" +\n  \"|[a-zA-Z\\\\d]+(?:;[-a-zA-Z\\\\d\\\\/#&.:=?%@~_]*)*)?\\\\u0007)\" +\n  \"|(?:(?:\\\\d{1,4}(?:;\\\\d{0,4})*)?[\\\\dA-PR-TZcf-ntqry=><~]))\";\nvar ansi = new RegExp(ansiPattern, \"g\");\n\n/**\n * Remove all VT control characters. Use to estimate displayed string width.\n */\nfunction stripVTControlCharacters(str) {\n  validateString(str, \"str\");\n  return RegExpPrototypeSymbolReplace.call(ansi, str, \"\");\n}\n\n// Promisify\n\nvar kCustomPromisifiedSymbol = SymbolFor(\"nodejs.util.promisify.custom\");\nvar kCustomPromisifyArgsSymbol = Symbol(\"customPromisifyArgs\");\n\nfunction promisify(original) {\n  validateFunction(original, \"original\");\n\n  if (original[kCustomPromisifiedSymbol]) {\n    var fn = original[kCustomPromisifiedSymbol];\n\n    validateFunction(fn, \"util.promisify.custom\");\n\n    return ObjectDefineProperty(fn, kCustomPromisifiedSymbol, {\n      __proto__: null,\n      value: fn,\n      enumerable: false,\n      writable: false,\n      configurable: true,\n    });\n  }\n\n  // Names to create an object from in case the callback receives multiple\n  // arguments, e.g. ['bytesRead', 'buffer'] for fs.read.\n  var argumentNames = original[kCustomPromisifyArgsSymbol];\n\n  function fn(...args) {\n    return new Promise((resolve, reject) => {\n      ArrayPrototypePush.call(args, (err, ...values) => {\n        if (err) {\n          return reject(err);\n        }\n        if (argumentNames !== undefined && values.length > 1) {\n          var obj = {};\n          for (var i = 0; i < argumentNames.length; i++) obj[argumentNames[i]] = values[i];\n          resolve(obj);\n        } else {\n          resolve(values[0]);\n        }\n      });\n      ReflectApply(original, this, args);\n    });\n  }\n\n  ObjectSetPrototypeOf(fn, ObjectGetPrototypeOf(original));\n\n  ObjectDefineProperty(fn, kCustomPromisifiedSymbol, {\n    __proto__: null,\n    value: fn,\n    enumerable: false,\n    writable: false,\n    configurable: true,\n  });\n\n  var descriptors = ObjectGetOwnPropertyDescriptors(original);\n  var propertiesValues = ObjectValues(descriptors);\n  for (var i = 0; i < propertiesValues.length; i++) {\n    // We want to use null-prototype objects to not rely on globally mutable\n    // %Object.prototype%.\n    ObjectSetPrototypeOf(propertiesValues[i], null);\n  }\n  return ObjectDefineProperties(fn, descriptors);\n}\n\npromisify.custom = kCustomPromisifiedSymbol;\n\n// Constants\n\nvar kUTF16SurrogateThreshold = 0x10000; // 2 ** 16\nvar kEscape = \"\\x1b\";\nvar kSubstringSearch = Symbol(\"kSubstringSearch\");\n\nvar kIsNodeError = Symbol(\"kIsNodeError\");\n\n// Errors\nvar errorBases = {};\nvar VALID_NODE_ERROR_BASES = {\n  TypeError,\n  RangeError,\n  Error,\n};\n\nfunction getNodeErrorByName(typeName) {\n  var base = errorBases[typeName];\n  if (base) {\n    return base;\n  }\n  if (!ObjectKeys(VALID_NODE_ERROR_BASES).includes(typeName)) {\n    throw new Error(\"Invalid NodeError type\");\n  }\n\n  var Base = VALID_NODE_ERROR_BASES[typeName];\n\n  class NodeError extends Base {\n    [kIsNodeError] = true;\n    code;\n    constructor(msg, opts) {\n      super(msg, opts);\n      this.code = opts?.code || \"ERR_GENERIC\";\n    }\n\n    toString() {\n      return `${this.name} [${this.code}]: ${this.message}`;\n    }\n  }\n  errorBases[typeName] = NodeError;\n  return NodeError;\n}\n\nvar NodeError = getNodeErrorByName(\"Error\");\nvar NodeTypeError = getNodeErrorByName(\"TypeError\");\nvar NodeRangeError = getNodeErrorByName(\"RangeError\");\n\nclass ERR_INVALID_ARG_TYPE extends NodeTypeError {\n  constructor(name, type, value) {\n    super(`The \"${name}\" argument must be of type ${type}. Received type ${typeof value}`, {\n      code: \"ERR_INVALID_ARG_TYPE\",\n    });\n  }\n}\n\nclass ERR_INVALID_ARG_VALUE extends NodeTypeError {\n  constructor(name, value, reason = \"not specified\") {\n    super(`The value \"${String(value)}\" is invalid for argument '${name}'. Reason: ${reason}`, {\n      code: \"ERR_INVALID_ARG_VALUE\",\n    });\n  }\n}\n\nclass ERR_INVALID_CURSOR_POS extends NodeTypeError {\n  constructor() {\n    super(\"Cannot set cursor row without setting its column\", {\n      code: \"ERR_INVALID_CURSOR_POS\",\n    });\n  }\n}\n\nclass ERR_OUT_OF_RANGE extends NodeRangeError {\n  constructor(name, range, received) {\n    super(`The value of \"${name}\" is out of range. It must be ${range}. Received ${received}`, {\n      code: \"ERR_OUT_OF_RANGE\",\n    });\n  }\n}\n\nclass ERR_USE_AFTER_CLOSE extends NodeError {\n  constructor() {\n    super(\"This socket has been ended by the other party\", {\n      code: \"ERR_USE_AFTER_CLOSE\",\n    });\n  }\n}\n\nclass AbortError extends Error {\n  code;\n  constructor() {\n    super(\"The operation was aborted\");\n    this.code = \"ABORT_ERR\";\n  }\n}\n\n// Validators\n\n/**\n * @callback validateFunction\n * @param {*} value\n * @param {string} name\n * @returns {asserts value is Function}\n */\nfunction validateFunction(value, name) {\n  if (typeof value !== \"function\") throw new ERR_INVALID_ARG_TYPE(name, \"Function\", value);\n}\n\n/**\n * @callback validateAbortSignal\n * @param {*} signal\n * @param {string} name\n */\nfunction validateAbortSignal(signal, name) {\n  if (signal !== undefined && (signal === null || typeof signal !== \"object\" || !(\"aborted\" in signal))) {\n    throw new ERR_INVALID_ARG_TYPE(name, \"AbortSignal\", signal);\n  }\n}\n\n/**\n * @callback validateArray\n * @param {*} value\n * @param {string} name\n * @param {number} [minLength]\n * @returns {asserts value is any[]}\n */\nfunction validateArray(value, name, minLength = 0) {\n  // var validateArray = hideStackFrames((value, name, minLength = 0) => {\n  if (!ArrayIsArray(value)) {\n    throw new ERR_INVALID_ARG_TYPE(name, \"Array\", value);\n  }\n  if (value.length < minLength) {\n    var reason = `must be longer than ${minLength}`;\n    throw new ERR_INVALID_ARG_VALUE(name, value, reason);\n  }\n}\n\n/**\n * @callback validateString\n * @param {*} value\n * @param {string} name\n * @returns {asserts value is string}\n */\nfunction validateString(value, name) {\n  if (typeof value !== \"string\") throw new ERR_INVALID_ARG_TYPE(name, \"string\", value);\n}\n\n/**\n * @callback validateBoolean\n * @param {*} value\n * @param {string} name\n * @returns {asserts value is boolean}\n */\nfunction validateBoolean(value, name) {\n  if (typeof value !== \"boolean\") throw new ERR_INVALID_ARG_TYPE(name, \"boolean\", value);\n}\n\n/**\n * @callback validateObject\n * @param {*} value\n * @param {string} name\n * @param {{\n *   allowArray?: boolean,\n *   allowFunction?: boolean,\n *   nullable?: boolean\n * }} [options]\n */\nfunction validateObject(value, name, options = null) {\n  // var validateObject = hideStackFrames((value, name, options = null) => {\n  var allowArray = options?.allowArray ?? false;\n  var allowFunction = options?.allowFunction ?? false;\n  var nullable = options?.nullable ?? false;\n  if (\n    (!nullable && value === null) ||\n    (!allowArray && ArrayIsArray.call(value)) ||\n    (typeof value !== \"object\" && (!allowFunction || typeof value !== \"function\"))\n  ) {\n    throw new ERR_INVALID_ARG_TYPE(name, \"object\", value);\n  }\n}\n\n/**\n * @callback validateInteger\n * @param {*} value\n * @param {string} name\n * @param {number} [min]\n * @param {number} [max]\n * @returns {asserts value is number}\n */\nfunction validateInteger(value, name, min = NumberMIN_SAFE_INTEGER, max = NumberMAX_SAFE_INTEGER) {\n  if (typeof value !== \"number\") throw new ERR_INVALID_ARG_TYPE(name, \"number\", value);\n  if (!NumberIsInteger(value)) throw new ERR_OUT_OF_RANGE(name, \"an integer\", value);\n  if (value < min || value > max) throw new ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value);\n}\n\n/**\n * @callback validateUint32\n * @param {*} value\n * @param {string} name\n * @param {number|boolean} [positive=false]\n * @returns {asserts value is number}\n */\nfunction validateUint32(value, name, positive = false) {\n  if (typeof value !== \"number\") {\n    throw new ERR_INVALID_ARG_TYPE(name, \"number\", value);\n  }\n\n  if (!NumberIsInteger(value)) {\n    throw new ERR_OUT_OF_RANGE(name, \"an integer\", value);\n  }\n\n  var min = positive ? 1 : 0; // 2 ** 32 === 4294967296\n  var max = 4_294_967_295;\n\n  if (value < min || value > max) {\n    throw new ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value);\n  }\n}\n\n// ----------------------------------------------------------------------------\n// Section: Utils\n// ----------------------------------------------------------------------------\n\nfunction CSI(strings, ...args) {\n  var ret = `${kEscape}[`;\n  for (var n = 0; n < strings.length; n++) {\n    ret += strings[n];\n    if (n < args.length) ret += args[n];\n  }\n  return ret;\n}\n\nvar kClearLine, kClearScreenDown, kClearToLineBeginning, kClearToLineEnd;\n\nCSI.kEscape = kEscape;\nCSI.kClearLine = kClearLine = CSI`2K`;\nCSI.kClearScreenDown = kClearScreenDown = CSI`0J`;\nCSI.kClearToLineBeginning = kClearToLineBeginning = CSI`1K`;\nCSI.kClearToLineEnd = kClearToLineEnd = CSI`0K`;\n\nfunction charLengthLeft(str, i) {\n  if (i <= 0) return 0;\n  if (\n    (i > 1 && StringPrototypeCodePointAt.call(str, i - 2) >= kUTF16SurrogateThreshold) ||\n    StringPrototypeCodePointAt.call(str, i - 1) >= kUTF16SurrogateThreshold\n  ) {\n    return 2;\n  }\n  return 1;\n}\n\nfunction charLengthAt(str, i) {\n  if (str.length <= i) {\n    // Pretend to move to the right. This is necessary to autocomplete while\n    // moving to the right.\n    return 1;\n  }\n  return StringPrototypeCodePointAt.call(str, i) >= kUTF16SurrogateThreshold ? 2 : 1;\n}\n\n/*\n  Some patterns seen in terminal key escape codes, derived from combos seen\n  at http://www.midnight-commander.org/browser/lib/tty/key.c\n  ESC letter\n  ESC [ letter\n  ESC [ modifier letter\n  ESC [ 1 ; modifier letter\n  ESC [ num char\n  ESC [ num ; modifier char\n  ESC O letter\n  ESC O modifier letter\n  ESC O 1 ; modifier letter\n  ESC N letter\n  ESC [ [ num ; modifier char\n  ESC [ [ 1 ; modifier letter\n  ESC ESC [ num char\n  ESC ESC O letter\n  - char is usually ~ but $ and ^ also happen with rxvt\n  - modifier is 1 +\n                (shift     * 1) +\n                (left_alt  * 2) +\n                (ctrl      * 4) +\n                (right_alt * 8)\n  - two leading ESCs apparently mean the same as one leading ESC\n*/\nfunction* emitKeys(stream) {\n  while (true) {\n    var ch = yield;\n    var s = ch;\n    var escaped = false;\n\n    var keySeq = null;\n    var keyName;\n    var keyCtrl = false;\n    var keyMeta = false;\n    var keyShift = false;\n\n    // var key = {\n    //   sequence: null,\n    //   name: undefined,\n    //   ctrl: false,\n    //   meta: false,\n    //   shift: false,\n    // };\n\n    if (ch === kEscape) {\n      escaped = true;\n      s += ch = yield;\n\n      if (ch === kEscape) {\n        s += ch = yield;\n      }\n    }\n\n    if (escaped && (ch === \"O\" || ch === \"[\")) {\n      // ANSI escape sequence\n      var code = ch;\n      var modifier = 0;\n\n      if (ch === \"O\") {\n        // ESC O letter\n        // ESC O modifier letter\n        s += ch = yield;\n\n        if (ch >= \"0\" && ch <= \"9\") {\n          modifier = (ch >> 0) - 1;\n          s += ch = yield;\n        }\n\n        code += ch;\n      } else if (ch === \"[\") {\n        // ESC [ letter\n        // ESC [ modifier letter\n        // ESC [ [ modifier letter\n        // ESC [ [ num char\n        s += ch = yield;\n\n        if (ch === \"[\") {\n          // \\x1b[[A\n          //      ^--- escape codes might have a second bracket\n          code += ch;\n          s += ch = yield;\n        }\n\n        /*\n         * Here and later we try to buffer just enough data to get\n         * a complete ascii sequence.\n         *\n         * We have basically two classes of ascii characters to process:\n         *\n         *\n         * 1. `\\x1b[24;5~` should be parsed as { code: '[24~', modifier: 5 }\n         *\n         * This particular example is featuring Ctrl+F12 in xterm.\n         *\n         *  - `;5` part is optional, e.g. it could be `\\x1b[24~`\n         *  - first part can contain one or two digits\n         *\n         * So the generic regexp is like /^\\d\\d?(;\\d)?[~^$]$/\n         *\n         *\n         * 2. `\\x1b[1;5H` should be parsed as { code: '[H', modifier: 5 }\n         *\n         * This particular example is featuring Ctrl+Home in xterm.\n         *\n         *  - `1;5` part is optional, e.g. it could be `\\x1b[H`\n         *  - `1;` part is optional, e.g. it could be `\\x1b[5H`\n         *\n         * So the generic regexp is like /^((\\d;)?\\d)?[A-Za-z]$/\n         *\n         */\n        var cmdStart = s.length - 1;\n\n        // Skip one or two leading digits\n        if (ch >= \"0\" && ch <= \"9\") {\n          s += ch = yield;\n\n          if (ch >= \"0\" && ch <= \"9\") {\n            s += ch = yield;\n          }\n        }\n\n        // skip modifier\n        if (ch === \";\") {\n          s += ch = yield;\n\n          if (ch >= \"0\" && ch <= \"9\") {\n            s += yield;\n          }\n        }\n\n        /*\n         * We buffered enough data, now trying to extract code\n         * and modifier from it\n         */\n        var cmd = StringPrototypeSlice.call(s, cmdStart);\n        var match;\n\n        if ((match = RegExpPrototypeExec.call(/^(\\d\\d?)(;(\\d))?([~^$])$/, cmd))) {\n          code += match[1] + match[4];\n          modifier = (match[3] || 1) - 1;\n        } else if ((match = RegExpPrototypeExec.call(/^((\\d;)?(\\d))?([A-Za-z])$/, cmd))) {\n          code += match[4];\n          modifier = (match[3] || 1) - 1;\n        } else {\n          code += cmd;\n        }\n      }\n\n      // Parse the key modifier\n      keyCtrl = !!(modifier & 4);\n      keyMeta = !!(modifier & 10);\n      keyShift = !!(modifier & 1);\n      keyCode = code;\n\n      // Parse the key itself\n      switch (code) {\n        /* xterm/gnome ESC [ letter (with modifier) */\n        case \"[P\":\n          keyName = \"f1\";\n          break;\n        case \"[Q\":\n          keyName = \"f2\";\n          break;\n        case \"[R\":\n          keyName = \"f3\";\n          break;\n        case \"[S\":\n          keyName = \"f4\";\n          break;\n\n        /* xterm/gnome ESC O letter (without modifier) */\n        case \"OP\":\n          keyName = \"f1\";\n          break;\n        case \"OQ\":\n          keyName = \"f2\";\n          break;\n        case \"OR\":\n          keyName = \"f3\";\n          break;\n        case \"OS\":\n          keyName = \"f4\";\n          break;\n\n        /* xterm/rxvt ESC [ number ~ */\n        case \"[11~\":\n          keyName = \"f1\";\n          break;\n        case \"[12~\":\n          keyName = \"f2\";\n          break;\n        case \"[13~\":\n          keyName = \"f3\";\n          break;\n        case \"[14~\":\n          keyName = \"f4\";\n          break;\n\n        /* from Cygwin and used in libuv */\n        case \"[[A\":\n          keyName = \"f1\";\n          break;\n        case \"[[B\":\n          keyName = \"f2\";\n          break;\n        case \"[[C\":\n          keyName = \"f3\";\n          break;\n        case \"[[D\":\n          keyName = \"f4\";\n          break;\n        case \"[[E\":\n          keyName = \"f5\";\n          break;\n\n        /* common */\n        case \"[15~\":\n          keyName = \"f5\";\n          break;\n        case \"[17~\":\n          keyName = \"f6\";\n          break;\n        case \"[18~\":\n          keyName = \"f7\";\n          break;\n        case \"[19~\":\n          keyName = \"f8\";\n          break;\n        case \"[20~\":\n          keyName = \"f9\";\n          break;\n        case \"[21~\":\n          keyName = \"f10\";\n          break;\n        case \"[23~\":\n          keyName = \"f11\";\n          break;\n        case \"[24~\":\n          keyName = \"f12\";\n          break;\n\n        /* xterm ESC [ letter */\n        case \"[A\":\n          keyName = \"up\";\n          break;\n        case \"[B\":\n          keyName = \"down\";\n          break;\n        case \"[C\":\n          keyName = \"right\";\n          break;\n        case \"[D\":\n          keyName = \"left\";\n          break;\n        case \"[E\":\n          keyName = \"clear\";\n          break;\n        case \"[F\":\n          keyName = \"end\";\n          break;\n        case \"[H\":\n          keyName = \"home\";\n          break;\n\n        /* xterm/gnome ESC O letter */\n        case \"OA\":\n          keyName = \"up\";\n          break;\n        case \"OB\":\n          keyName = \"down\";\n          break;\n        case \"OC\":\n          keyName = \"right\";\n          break;\n        case \"OD\":\n          keyName = \"left\";\n          break;\n        case \"OE\":\n          keyName = \"clear\";\n          break;\n        case \"OF\":\n          keyName = \"end\";\n          break;\n        case \"OH\":\n          keyName = \"home\";\n          break;\n\n        /* xterm/rxvt ESC [ number ~ */\n        case \"[1~\":\n          keyName = \"home\";\n          break;\n        case \"[2~\":\n          keyName = \"insert\";\n          break;\n        case \"[3~\":\n          keyName = \"delete\";\n          break;\n        case \"[4~\":\n          keyName = \"end\";\n          break;\n        case \"[5~\":\n          keyName = \"pageup\";\n          break;\n        case \"[6~\":\n          keyName = \"pagedown\";\n          break;\n\n        /* putty */\n        case \"[[5~\":\n          keyName = \"pageup\";\n          break;\n        case \"[[6~\":\n          keyName = \"pagedown\";\n          break;\n\n        /* rxvt */\n        case \"[7~\":\n          keyName = \"home\";\n          break;\n        case \"[8~\":\n          keyName = \"end\";\n          break;\n\n        /* rxvt keys with modifiers */\n        case \"[a\":\n          keyName = \"up\";\n          keyShift = true;\n          break;\n        case \"[b\":\n          keyName = \"down\";\n          keyShift = true;\n          break;\n        case \"[c\":\n          keyName = \"right\";\n          keyShift = true;\n          break;\n        case \"[d\":\n          keyName = \"left\";\n          keyShift = true;\n          break;\n        case \"[e\":\n          keyName = \"clear\";\n          keyShift = true;\n          break;\n\n        case \"[2$\":\n          keyName = \"insert\";\n          keyShift = true;\n          break;\n        case \"[3$\":\n          keyName = \"delete\";\n          keyShift = true;\n          break;\n        case \"[5$\":\n          keyName = \"pageup\";\n          keyShift = true;\n          break;\n        case \"[6$\":\n          keyName = \"pagedown\";\n          keyShift = true;\n          break;\n        case \"[7$\":\n          keyName = \"home\";\n          keyShift = true;\n          break;\n        case \"[8$\":\n          keyName = \"end\";\n          keyShift = true;\n          break;\n\n        case \"Oa\":\n          keyName = \"up\";\n          keyCtrl = true;\n          break;\n        case \"Ob\":\n          keyName = \"down\";\n          keyCtrl = true;\n          break;\n        case \"Oc\":\n          keyName = \"right\";\n          keyCtrl = true;\n          break;\n        case \"Od\":\n          keyName = \"left\";\n          keyCtrl = true;\n          break;\n        case \"Oe\":\n          keyName = \"clear\";\n          keyCtrl = true;\n          break;\n\n        case \"[2^\":\n          keyName = \"insert\";\n          keyCtrl = true;\n          break;\n        case \"[3^\":\n          keyName = \"delete\";\n          keyCtrl = true;\n          break;\n        case \"[5^\":\n          keyName = \"pageup\";\n          keyCtrl = true;\n          break;\n        case \"[6^\":\n          keyName = \"pagedown\";\n          keyCtrl = true;\n          break;\n        case \"[7^\":\n          keyName = \"home\";\n          keyCtrl = true;\n          break;\n        case \"[8^\":\n          keyName = \"end\";\n          keyCtrl = true;\n          break;\n\n        /* misc. */\n        case \"[Z\":\n          keyName = \"tab\";\n          keyShift = true;\n          break;\n        default:\n          keyName = \"undefined\";\n          break;\n      }\n    } else if (ch === \"\\r\") {\n      // carriage return\n      keyName = \"return\";\n      keyMeta = escaped;\n    } else if (ch === \"\\n\") {\n      // Enter, should have been called linefeed\n      keyName = \"enter\";\n      keyMeta = escaped;\n    } else if (ch === \"\\t\") {\n      // tab\n      keyName = \"tab\";\n      keyMeta = escaped;\n    } else if (ch === \"\\b\" || ch === \"\\x7f\") {\n      // backspace or ctrl+h\n      keyName = \"backspace\";\n      keyMeta = escaped;\n    } else if (ch === kEscape) {\n      // escape key\n      keyName = \"escape\";\n      keyMeta = escaped;\n    } else if (ch === \" \") {\n      keyName = \"space\";\n      keyMeta = escaped;\n    } else if (!escaped && ch <= \"\\x1a\") {\n      // ctrl+letter\n      keyName = StringFromCharCode(StringPrototypeCharCodeAt.call(ch) + StringPrototypeCharCodeAt.call(\"a\") - 1);\n      keyCtrl = true;\n    } else if (RegExpPrototypeExec.call(/^[0-9A-Za-z]$/, ch) !== null) {\n      // Letter, number, shift+letter\n      keyName = StringPrototypeToLowerCase.call(ch);\n      keyShift = RegExpPrototypeExec.call(/^[A-Z]$/, ch) !== null;\n      keyMeta = escaped;\n    } else if (escaped) {\n      // Escape sequence timeout\n      keyName = ch.length ? undefined : \"escape\";\n      keyMeta = true;\n    }\n\n    keySeq = s;\n\n    if (s.length !== 0 && (keyName !== undefined || escaped)) {\n      /* Named character or sequence */\n      stream.emit(\"keypress\", escaped ? undefined : s, {\n        sequence: keySeq,\n        name: keyName,\n        ctrl: keyCtrl,\n        meta: keyMeta,\n        shift: keyShift,\n      });\n    } else if (charLengthAt(s, 0) === s.length) {\n      /* Single unnamed character, e.g. \".\" */\n      stream.emit(\"keypress\", s, {\n        sequence: keySeq,\n        name: keyName,\n        ctrl: keyCtrl,\n        meta: keyMeta,\n        shift: keyShift,\n      });\n    }\n    /* Unrecognized or broken escape sequence, don't emit anything */\n  }\n}\n\n// This runs in O(n log n).\nfunction commonPrefix(strings) {\n  if (strings.length === 0) {\n    return \"\";\n  }\n  if (strings.length === 1) {\n    return strings[0];\n  }\n  var sorted = ArrayPrototypeSort.call(ArrayPrototypeSlice.call(strings));\n  var min = sorted[0];\n  var max = sorted[sorted.length - 1];\n  for (var i = 0; i < min.length; i++) {\n    if (min[i] !== max[i]) {\n      return StringPrototypeSlice.call(min, 0, i);\n    }\n  }\n  return min;\n}\n\n// ----------------------------------------------------------------------------\n// Section: Cursor Functions\n// ----------------------------------------------------------------------------\n\n/**\n * moves the cursor to the x and y coordinate on the given stream\n */\n\nfunction cursorTo(stream, x, y, callback) {\n  if (callback !== undefined) {\n    validateFunction(callback, \"callback\");\n  }\n\n  if (typeof y === \"function\") {\n    callback = y;\n    y = undefined;\n  }\n\n  if (NumberIsNaN(x)) throw new ERR_INVALID_ARG_VALUE(\"x\", x);\n  if (NumberIsNaN(y)) throw new ERR_INVALID_ARG_VALUE(\"y\", y);\n\n  if (stream == null || (typeof x !== \"number\" && typeof y !== \"number\")) {\n    if (typeof callback === \"function\") process.nextTick(callback, null);\n    return true;\n  }\n\n  if (typeof x !== \"number\") throw new ERR_INVALID_CURSOR_POS();\n\n  var data = typeof y !== \"number\" ? CSI`${x + 1}G` : CSI`${y + 1};${x + 1}H`;\n  return stream.write(data, callback);\n}\n\n/**\n * moves the cursor relative to its current location\n */\n\nfunction moveCursor(stream, dx, dy, callback) {\n  if (callback !== undefined) {\n    validateFunction(callback, \"callback\");\n  }\n\n  if (stream == null || !(dx || dy)) {\n    if (typeof callback === \"function\") process.nextTick(callback, null);\n    return true;\n  }\n\n  var data = \"\";\n\n  if (dx < 0) {\n    data += CSI`${-dx}D`;\n  } else if (dx > 0) {\n    data += CSI`${dx}C`;\n  }\n\n  if (dy < 0) {\n    data += CSI`${-dy}A`;\n  } else if (dy > 0) {\n    data += CSI`${dy}B`;\n  }\n\n  return stream.write(data, callback);\n}\n\n/**\n * clears the current line the cursor is on:\n *   -1 for left of the cursor\n *   +1 for right of the cursor\n *    0 for the entire line\n */\n\nfunction clearLine(stream, dir, callback) {\n  if (callback !== undefined) {\n    validateFunction(callback, \"callback\");\n  }\n\n  if (stream === null || stream === undefined) {\n    if (typeof callback === \"function\") process.nextTick(callback, null);\n    return true;\n  }\n\n  var type = dir < 0 ? kClearToLineBeginning : dir > 0 ? kClearToLineEnd : kClearLine;\n  return stream.write(type, callback);\n}\n\n/**\n * clears the screen from the current position of the cursor down\n */\n\nfunction clearScreenDown(stream, callback) {\n  if (callback !== undefined) {\n    validateFunction(callback, \"callback\");\n  }\n\n  if (stream === null || stream === undefined) {\n    if (typeof callback === \"function\") process.nextTick(callback, null);\n    return true;\n  }\n\n  return stream.write(kClearScreenDown, callback);\n}\n\n// ----------------------------------------------------------------------------\n// Section: Emit keypress events\n// ----------------------------------------------------------------------------\n\nvar KEYPRESS_DECODER = Symbol(\"keypress-decoder\");\nvar ESCAPE_DECODER = Symbol(\"escape-decoder\");\n\n// GNU readline library - keyseq-timeout is 500ms (default)\nvar ESCAPE_CODE_TIMEOUT = 500;\n\n/**\n * accepts a readable Stream instance and makes it emit \"keypress\" events\n */\n\nfunction emitKeypressEvents(stream, iface = {}) {\n  if (stream[KEYPRESS_DECODER]) return;\n\n  stream[KEYPRESS_DECODER] = new StringDecoder(\"utf8\");\n\n  stream[ESCAPE_DECODER] = emitKeys(stream);\n  stream[ESCAPE_DECODER].next();\n\n  var triggerEscape = () => stream[ESCAPE_DECODER].next(\"\");\n  var { escapeCodeTimeout = ESCAPE_CODE_TIMEOUT } = iface;\n  var timeoutId;\n\n  function onData(input) {\n    if (stream.listenerCount(\"keypress\") > 0) {\n      var string = stream[KEYPRESS_DECODER].write(input);\n      if (string) {\n        clearTimeout(timeoutId);\n\n        // This supports characters of length 2.\n        iface[kSawKeyPress] = charLengthAt(string, 0) === string.length;\n        iface.isCompletionEnabled = false;\n\n        var length = 0;\n        for (var character of new SafeStringIterator(string)) {\n          length += character.length;\n          if (length === string.length) {\n            iface.isCompletionEnabled = true;\n          }\n\n          try {\n            stream[ESCAPE_DECODER].next(character);\n            // Escape letter at the tail position\n            if (length === string.length && character === kEscape) {\n              timeoutId = setTimeout(triggerEscape, escapeCodeTimeout);\n            }\n          } catch (err) {\n            // If the generator throws (it could happen in the `keypress`\n            // event), we need to restart it.\n            stream[ESCAPE_DECODER] = emitKeys(stream);\n            stream[ESCAPE_DECODER].next();\n            throw err;\n          }\n        }\n      }\n    } else {\n      // Nobody's watching anyway\n      stream.removeListener(\"data\", onData);\n      stream.on(\"newListener\", onNewListener);\n    }\n  }\n\n  function onNewListener(event) {\n    if (event === \"keypress\") {\n      stream.on(\"data\", onData);\n      stream.removeListener(\"newListener\", onNewListener);\n    }\n  }\n\n  if (stream.listenerCount(\"keypress\") > 0) {\n    stream.on(\"data\", onData);\n  } else {\n    stream.on(\"newListener\", onNewListener);\n  }\n}\n\n// ----------------------------------------------------------------------------\n// Section: Interface\n// ----------------------------------------------------------------------------\n\nvar kEmptyObject = ObjectFreeze(ObjectCreate(null));\n\n// Some constants regarding configuration of interface\nvar kHistorySize = 30;\nvar kMaxUndoRedoStackSize = 2048;\nvar kMincrlfDelay = 100;\n// \\r\\n, \\n, or \\r followed by something other than \\n\nvar lineEnding = /\\r?\\n|\\r(?!\\n)/g;\n\n// Max length of the kill ring\nvar kMaxLengthOfKillRing = 32;\n\n// Symbols\n\n// Public symbols\nvar kLineObjectStream = Symbol(\"line object stream\");\nvar kQuestionCancel = Symbol(\"kQuestionCancel\");\nvar kQuestion = Symbol(\"kQuestion\");\n\n// Private symbols\nvar kAddHistory = Symbol(\"_addHistory\");\nvar kBeforeEdit = Symbol(\"_beforeEdit\");\nvar kDecoder = Symbol(\"_decoder\");\nvar kDeleteLeft = Symbol(\"_deleteLeft\");\nvar kDeleteLineLeft = Symbol(\"_deleteLineLeft\");\nvar kDeleteLineRight = Symbol(\"_deleteLineRight\");\nvar kDeleteRight = Symbol(\"_deleteRight\");\nvar kDeleteWordLeft = Symbol(\"_deleteWordLeft\");\nvar kDeleteWordRight = Symbol(\"_deleteWordRight\");\nvar kGetDisplayPos = Symbol(\"_getDisplayPos\");\nvar kHistoryNext = Symbol(\"_historyNext\");\nvar kHistoryPrev = Symbol(\"_historyPrev\");\nvar kInsertString = Symbol(\"_insertString\");\nvar kLine = Symbol(\"_line\");\nvar kLine_buffer = Symbol(\"_line_buffer\");\nvar kKillRing = Symbol(\"_killRing\");\nvar kKillRingCursor = Symbol(\"_killRingCursor\");\nvar kMoveCursor = Symbol(\"_moveCursor\");\nvar kNormalWrite = Symbol(\"_normalWrite\");\nvar kOldPrompt = Symbol(\"_oldPrompt\");\nvar kOnLine = Symbol(\"_onLine\");\nvar kPreviousKey = Symbol(\"_previousKey\");\nvar kPrompt = Symbol(\"_prompt\");\nvar kPushToKillRing = Symbol(\"_pushToKillRing\");\nvar kPushToUndoStack = Symbol(\"_pushToUndoStack\");\nvar kQuestionCallback = Symbol(\"_questionCallback\");\nvar kRedo = Symbol(\"_redo\");\nvar kRedoStack = Symbol(\"_redoStack\");\nvar kRefreshLine = Symbol(\"_refreshLine\");\nvar kSawKeyPress = Symbol(\"_sawKeyPress\");\nvar kSawReturnAt = Symbol(\"_sawReturnAt\");\nvar kSetRawMode = Symbol(\"_setRawMode\");\nvar kTabComplete = Symbol(\"_tabComplete\");\nvar kTabCompleter = Symbol(\"_tabCompleter\");\nvar kTtyWrite = Symbol(\"_ttyWrite\");\nvar kUndo = Symbol(\"_undo\");\nvar kUndoStack = Symbol(\"_undoStack\");\nvar kWordLeft = Symbol(\"_wordLeft\");\nvar kWordRight = Symbol(\"_wordRight\");\nvar kWriteToOutput = Symbol(\"_writeToOutput\");\nvar kYank = Symbol(\"_yank\");\nvar kYanking = Symbol(\"_yanking\");\nvar kYankPop = Symbol(\"_yankPop\");\n\n// Event symbols\nvar kFirstEventParam = Symbol(\"nodejs.kFirstEventParam\");\n\n// class InterfaceConstructor extends EventEmitter {\n// #onSelfCloseWithTerminal;\n// #onSelfCloseWithoutTerminal;\n\n// #onError;\n// #onData;\n// #onEnd;\n// #onTermEnd;\n// #onKeyPress;\n// #onResize;\n\n// [kSawReturnAt];\n// isCompletionEnabled = true;\n// [kSawKeyPress];\n// [kPreviousKey];\n// escapeCodeTimeout;\n// tabSize;\n\n// line;\n// [kSubstringSearch];\n// output;\n// input;\n// [kUndoStack];\n// [kRedoStack];\n// history;\n// historySize;\n\n// [kKillRing];\n// [kKillRingCursor];\n\n// removeHistoryDuplicates;\n// crlfDelay;\n// completer;\n\n// terminal;\n// [kLineObjectStream];\n\n// cursor;\n// historyIndex;\n\n// constructor(input, output, completer, terminal) {\n//   super();\n\nvar kOnSelfCloseWithTerminal = Symbol(\"_onSelfCloseWithTerminal\");\nvar kOnSelfCloseWithoutTerminal = Symbol(\"_onSelfCloseWithoutTerminal\");\nvar kOnKeyPress = Symbol(\"_onKeyPress\");\nvar kOnError = Symbol(\"_onError\");\nvar kOnData = Symbol(\"_onData\");\nvar kOnEnd = Symbol(\"_onEnd\");\nvar kOnTermEnd = Symbol(\"_onTermEnd\");\nvar kOnResize = Symbol(\"_onResize\");\n\nfunction onSelfCloseWithTerminal() {\n  var input = this.input;\n  var output = this.output;\n\n  if (!input) throw new Error(\"Input not set, invalid state for readline!\");\n\n  input.removeListener(\"keypress\", this[kOnKeyPress]);\n  input.removeListener(\"error\", this[kOnError]);\n  input.removeListener(\"end\", this[kOnTermEnd]);\n  if (output !== null && output !== undefined) {\n    output.removeListener(\"resize\", this[kOnResize]);\n  }\n}\n\nfunction onSelfCloseWithoutTerminal() {\n  var input = this.input;\n  if (!input) throw new Error(\"Input not set, invalid state for readline!\");\n\n  input.removeListener(\"data\", this[kOnData]);\n  input.removeListener(\"error\", this[kOnError]);\n  input.removeListener(\"end\", this[kOnEnd]);\n}\n\nfunction onError(err) {\n  this.emit(\"error\", err);\n}\n\nfunction onData(data) {\n  debug(\"onData\");\n  this[kNormalWrite](data);\n}\n\nfunction onEnd() {\n  debug(\"onEnd\");\n  if (typeof this[kLine_buffer] === \"string\" && this[kLine_buffer].length > 0) {\n    this.emit(\"line\", this[kLine_buffer]);\n  }\n  this.close();\n}\n\nfunction onTermEnd() {\n  debug(\"onTermEnd\");\n  if (typeof this.line === \"string\" && this.line.length > 0) {\n    this.emit(\"line\", this.line);\n  }\n  this.close();\n}\n\nfunction onKeyPress(s, key) {\n  this[kTtyWrite](s, key);\n  if (key && key.sequence) {\n    // If the keySeq is half of a surrogate pair\n    // (>= 0xd800 and <= 0xdfff), refresh the line so\n    // the character is displayed appropriately.\n    var ch = StringPrototypeCodePointAt.call(key.sequence, 0);\n    if (ch >= 0xd800 && ch <= 0xdfff) this[kRefreshLine]();\n  }\n}\n\nfunction onResize() {\n  this[kRefreshLine]();\n}\n\nfunction InterfaceConstructor(input, output, completer, terminal) {\n  if (!(this instanceof InterfaceConstructor)) {\n    return new InterfaceConstructor(input, output, completer, terminal);\n  }\n\n  EventEmitter.call(this);\n\n  this[kOnSelfCloseWithoutTerminal] = onSelfCloseWithoutTerminal.bind(this);\n  this[kOnSelfCloseWithTerminal] = onSelfCloseWithTerminal.bind(this);\n\n  this[kOnError] = onError.bind(this);\n  this[kOnData] = onData.bind(this);\n  this[kOnEnd] = onEnd.bind(this);\n  this[kOnTermEnd] = onTermEnd.bind(this);\n  this[kOnKeyPress] = onKeyPress.bind(this);\n  this[kOnResize] = onResize.bind(this);\n\n  this[kSawReturnAt] = 0;\n  this.isCompletionEnabled = true;\n  this[kSawKeyPress] = false;\n  this[kPreviousKey] = null;\n  this.escapeCodeTimeout = ESCAPE_CODE_TIMEOUT;\n  this.tabSize = 8;\n\n  var history;\n  var historySize;\n  var removeHistoryDuplicates = false;\n  var crlfDelay;\n  var prompt = \"> \";\n  var signal;\n\n  if (input?.input) {\n    // An options object was given\n    output = input.output;\n    completer = input.completer;\n    terminal = input.terminal;\n    history = input.history;\n    historySize = input.historySize;\n    signal = input.signal;\n\n    var tabSize = input.tabSize;\n    if (tabSize !== undefined) {\n      validateUint32(tabSize, \"tabSize\", true);\n      this.tabSize = tabSize;\n    }\n    removeHistoryDuplicates = input.removeHistoryDuplicates;\n\n    var inputPrompt = input.prompt;\n    if (inputPrompt !== undefined) {\n      prompt = inputPrompt;\n    }\n\n    var inputEscapeCodeTimeout = input.escapeCodeTimeout;\n    if (inputEscapeCodeTimeout !== undefined) {\n      if (NumberIsFinite(inputEscapeCodeTimeout)) {\n        this.escapeCodeTimeout = inputEscapeCodeTimeout;\n      } else {\n        throw new ERR_INVALID_ARG_VALUE(\"input.escapeCodeTimeout\", this.escapeCodeTimeout);\n      }\n    }\n\n    if (signal) {\n      validateAbortSignal(signal, \"options.signal\");\n    }\n\n    crlfDelay = input.crlfDelay;\n    input = input.input;\n  }\n\n  if (completer !== undefined && typeof completer !== \"function\") {\n    throw new ERR_INVALID_ARG_VALUE(\"completer\", completer);\n  }\n\n  if (history === undefined) {\n    history = [];\n  } else {\n    validateArray(history, \"history\");\n  }\n\n  if (historySize === undefined) {\n    historySize = kHistorySize;\n  }\n\n  if (typeof historySize !== \"number\" || NumberIsNaN(historySize) || historySize < 0) {\n    throw new ERR_INVALID_ARG_VALUE(\"historySize\", historySize);\n  }\n\n  // Backwards compat; check the isTTY prop of the output stream\n  //  when `terminal` was not specified\n  if (terminal === undefined && !(output === null || output === undefined)) {\n    terminal = !!output.isTTY;\n  }\n\n  this.line = \"\";\n  this[kSubstringSearch] = null;\n  this.output = output;\n  this.input = input;\n  this[kUndoStack] = [];\n  this[kRedoStack] = [];\n  this.history = history;\n  this.historySize = historySize;\n\n  // The kill ring is a global list of blocks of text that were previously\n  // killed (deleted). If its size exceeds kMaxLengthOfKillRing, the oldest\n  // element will be removed to make room for the latest deletion. With kill\n  // ring, users are able to recall (yank) or cycle (yank pop) among previously\n  // killed texts, quite similar to the behavior of Emacs.\n  this[kKillRing] = [];\n  this[kKillRingCursor] = 0;\n\n  this.removeHistoryDuplicates = !!removeHistoryDuplicates;\n  this.crlfDelay = crlfDelay ? MathMax(kMincrlfDelay, crlfDelay) : kMincrlfDelay;\n  this.completer = completer;\n\n  this.setPrompt(prompt);\n\n  this.terminal = !!terminal;\n\n  this[kLineObjectStream] = undefined;\n\n  input.on(\"error\", this[kOnError]);\n\n  if (!this.terminal) {\n    input.on(\"data\", this[kOnData]);\n    input.on(\"end\", this[kOnEnd]);\n    this.once(\"close\", this[kOnSelfCloseWithoutTerminal]);\n    this[kDecoder] = new StringDecoder(\"utf8\");\n  } else {\n    emitKeypressEvents(input, this);\n\n    // `input` usually refers to stdin\n    input.on(\"keypress\", this[kOnKeyPress]);\n    input.on(\"end\", this[kOnTermEnd]);\n\n    this[kSetRawMode](true);\n    this.terminal = true;\n\n    // Cursor position on the line.\n    this.cursor = 0;\n    this.historyIndex = -1;\n\n    if (output !== null && output !== undefined) output.on(\"resize\", this[kOnResize]);\n\n    this.once(\"close\", this[kOnSelfCloseWithTerminal]);\n  }\n\n  if (signal) {\n    var onAborted = (() => this.close()).bind(this);\n    if (signal.aborted) {\n      process.nextTick(onAborted);\n    } else {\n      signal.addEventListener(\"abort\", onAborted, { once: true });\n      this.once(\"close\", () => signal.removeEventListener(\"abort\", onAborted));\n    }\n  }\n\n  // Current line\n  this.line = \"\";\n\n  input.resume();\n}\n\nObjectSetPrototypeOf(InterfaceConstructor.prototype, EventEmitter.prototype);\nObjectSetPrototypeOf(InterfaceConstructor, EventEmitter);\n\nvar _Interface = class Interface extends InterfaceConstructor {\n  // TODO: Enumerate all the properties of the class\n\n  // eslint-disable-next-line no-useless-constructor\n  constructor(input, output, completer, terminal) {\n    super(input, output, completer, terminal);\n  }\n  get columns() {\n    var output = this.output;\n    if (output && output.columns) return output.columns;\n    return Infinity;\n  }\n\n  /**\n   * Sets the prompt written to the output.\n   * @param {string} prompt\n   * @returns {void}\n   */\n  setPrompt(prompt) {\n    this[kPrompt] = prompt;\n  }\n\n  /**\n   * Returns the current prompt used by `rl.prompt()`.\n   * @returns {string}\n   */\n  getPrompt() {\n    return this[kPrompt];\n  }\n\n  [kSetRawMode](mode) {\n    var input = this.input;\n    var { setRawMode, wasInRawMode } = input;\n\n    // TODO: Make this work, for now just stub this and print debug\n    debug(\"setRawMode\", mode, \"set!\");\n    // if (typeof setRawMode === \"function\") {\n    //   setRawMode(mode);\n    // }\n\n    return wasInRawMode;\n  }\n\n  /**\n   * Writes the configured `prompt` to a new line in `output`.\n   * @param {boolean} [preserveCursor]\n   * @returns {void}\n   */\n  prompt(preserveCursor) {\n    if (this.paused) this.resume();\n    if (this.terminal && process.env.TERM !== \"dumb\") {\n      if (!preserveCursor) this.cursor = 0;\n      this[kRefreshLine]();\n    } else {\n      this[kWriteToOutput](this[kPrompt]);\n    }\n  }\n\n  [kQuestion](query, cb) {\n    if (this.closed) {\n      throw new ERR_USE_AFTER_CLOSE(\"readline\");\n    }\n    if (this[kQuestionCallback]) {\n      this.prompt();\n    } else {\n      this[kOldPrompt] = this[kPrompt];\n      this.setPrompt(query);\n      this[kQuestionCallback] = cb;\n      this.prompt();\n    }\n  }\n\n  [kOnLine](line) {\n    if (this[kQuestionCallback]) {\n      var cb = this[kQuestionCallback];\n      this[kQuestionCallback] = null;\n      this.setPrompt(this[kOldPrompt]);\n      cb(line);\n    } else {\n      this.emit(\"line\", line);\n    }\n  }\n\n  [kBeforeEdit](oldText, oldCursor) {\n    this[kPushToUndoStack](oldText, oldCursor);\n  }\n\n  [kQuestionCancel]() {\n    if (this[kQuestionCallback]) {\n      this[kQuestionCallback] = null;\n      this.setPrompt(this[kOldPrompt]);\n      this.clearLine();\n    }\n  }\n\n  [kWriteToOutput](stringToWrite) {\n    validateString(stringToWrite, \"stringToWrite\");\n\n    if (this.output !== null && this.output !== undefined) {\n      this.output.write(stringToWrite);\n    }\n  }\n\n  [kAddHistory]() {\n    if (this.line.length === 0) return \"\";\n\n    // If the history is disabled then return the line\n    if (this.historySize === 0) return this.line;\n\n    // If the trimmed line is empty then return the line\n    if (StringPrototypeTrim.call(this.line).length === 0) return this.line;\n\n    if (this.history.length === 0 || this.history[0] !== this.line) {\n      if (this.removeHistoryDuplicates) {\n        // Remove older history line if identical to new one\n        var dupIndex = ArrayPrototypeIndexOf.call(this.history, this.line);\n        if (dupIndex !== -1) ArrayPrototypeSplice.call(this.history, dupIndex, 1);\n      }\n\n      ArrayPrototypeUnshift.call(this.history, this.line);\n\n      // Only store so many\n      if (this.history.length > this.historySize) ArrayPrototypePop.call(this.history);\n    }\n\n    this.historyIndex = -1;\n\n    // The listener could change the history object, possibly\n    // to remove the last added entry if it is sensitive and should\n    // not be persisted in the history, like a password\n    var line = this.history[0];\n\n    // Emit history event to notify listeners of update\n    this.emit(\"history\", this.history);\n\n    return line;\n  }\n\n  [kRefreshLine]() {\n    // line length\n    var line = this[kPrompt] + this.line;\n    var dispPos = this[kGetDisplayPos](line);\n    var lineCols = dispPos.cols;\n    var lineRows = dispPos.rows;\n\n    // cursor position\n    var cursorPos = this.getCursorPos();\n\n    // First move to the bottom of the current line, based on cursor pos\n    var prevRows = this.prevRows || 0;\n    if (prevRows > 0) {\n      moveCursor(this.output, 0, -prevRows);\n    }\n\n    // Cursor to left edge.\n    cursorTo(this.output, 0);\n    // erase data\n    clearScreenDown(this.output);\n\n    // Write the prompt and the current buffer content.\n    this[kWriteToOutput](line);\n\n    // Force terminal to allocate a new line\n    if (lineCols === 0) {\n      this[kWriteToOutput](\" \");\n    }\n\n    // Move cursor to original position.\n    cursorTo(this.output, cursorPos.cols);\n\n    var diff = lineRows - cursorPos.rows;\n    if (diff > 0) {\n      moveCursor(this.output, 0, -diff);\n    }\n\n    this.prevRows = cursorPos.rows;\n  }\n\n  /**\n   * Closes the `readline.Interface` instance.\n   * @returns {void}\n   */\n  close() {\n    if (this.closed) return;\n    this.pause();\n    if (this.terminal) {\n      this[kSetRawMode](false);\n    }\n    this.closed = true;\n    this.emit(\"close\");\n  }\n\n  /**\n   * Pauses the `input` stream.\n   * @returns {void | Interface}\n   */\n  pause() {\n    if (this.paused) return;\n    this.input.pause();\n    this.paused = true;\n    this.emit(\"pause\");\n    return this;\n  }\n\n  /**\n   * Resumes the `input` stream if paused.\n   * @returns {void | Interface}\n   */\n  resume() {\n    if (!this.paused) return;\n    this.input.resume();\n    this.paused = false;\n    this.emit(\"resume\");\n    return this;\n  }\n\n  /**\n   * Writes either `data` or a `key` sequence identified by\n   * `key` to the `output`.\n   * @param {string} d\n   * @param {{\n   *   ctrl?: boolean;\n   *   meta?: boolean;\n   *   shift?: boolean;\n   *   name?: string;\n   *   }} [key]\n   * @returns {void}\n   */\n  write(d, key) {\n    if (this.paused) this.resume();\n    if (this.terminal) {\n      this[kTtyWrite](d, key);\n    } else {\n      this[kNormalWrite](d);\n    }\n  }\n\n  [kNormalWrite](b) {\n    if (b === undefined) {\n      return;\n    }\n    var string = this[kDecoder].write(b);\n    if (this[kSawReturnAt] && DateNow() - this[kSawReturnAt] <= this.crlfDelay) {\n      if (StringPrototypeCodePointAt.call(string) === 10) string = StringPrototypeSlice.call(string, 1);\n      this[kSawReturnAt] = 0;\n    }\n\n    // Run test() on the new string chunk, not on the entire line buffer.\n    var newPartContainsEnding = RegExpPrototypeExec.call(lineEnding, string);\n    if (newPartContainsEnding !== null) {\n      if (this[kLine_buffer]) {\n        string = this[kLine_buffer] + string;\n        this[kLine_buffer] = null;\n        newPartContainsEnding = RegExpPrototypeExec.call(lineEnding, string);\n      }\n      this[kSawReturnAt] = StringPrototypeEndsWith.call(string, \"\\r\") ? DateNow() : 0;\n\n      var indexes = [0, newPartContainsEnding.index, lineEnding.lastIndex];\n      var nextMatch;\n      while ((nextMatch = RegExpPrototypeExec.call(lineEnding, string)) !== null) {\n        ArrayPrototypePush.call(indexes, nextMatch.index, lineEnding.lastIndex);\n      }\n      var lastIndex = indexes.length - 1;\n      // Either '' or (conceivably) the unfinished portion of the next line\n      this[kLine_buffer] = StringPrototypeSlice.call(string, indexes[lastIndex]);\n      for (var i = 1; i < lastIndex; i += 2) {\n        this[kOnLine](StringPrototypeSlice.call(string, indexes[i - 1], indexes[i]));\n      }\n    } else if (string) {\n      // No newlines this time, save what we have for next time\n      if (this[kLine_buffer]) {\n        this[kLine_buffer] += string;\n      } else {\n        this[kLine_buffer] = string;\n      }\n    }\n  }\n\n  [kInsertString](c) {\n    this[kBeforeEdit](this.line, this.cursor);\n    if (this.cursor < this.line.length) {\n      var beg = StringPrototypeSlice.call(this.line, 0, this.cursor);\n      var end = StringPrototypeSlice.call(this.line, this.cursor, this.line.length);\n      this.line = beg + c + end;\n      this.cursor += c.length;\n      this[kRefreshLine]();\n    } else {\n      var oldPos = this.getCursorPos();\n      this.line += c;\n      this.cursor += c.length;\n      var newPos = this.getCursorPos();\n\n      if (oldPos.rows < newPos.rows) {\n        this[kRefreshLine]();\n      } else {\n        this[kWriteToOutput](c);\n      }\n    }\n  }\n\n  async [kTabComplete](lastKeypressWasTab) {\n    this.pause();\n    var string = StringPrototypeSlice.call(this.line, 0, this.cursor);\n    var value;\n    try {\n      value = await this.completer(string);\n    } catch (err) {\n      this[kWriteToOutput](`Tab completion error: ${inspect(err)}`);\n      return;\n    } finally {\n      this.resume();\n    }\n    this[kTabCompleter](lastKeypressWasTab, value);\n  }\n\n  [kTabCompleter](lastKeypressWasTab, { 0: completions, 1: completeOn }) {\n    // Result and the text that was completed.\n\n    if (!completions || completions.length === 0) {\n      return;\n    }\n\n    // If there is a common prefix to all matches, then apply that portion.\n    var prefix = commonPrefix(ArrayPrototypeFilter.call(completions, e => e !== \"\"));\n    if (StringPrototypeStartsWith.call(prefix, completeOn) && prefix.length > completeOn.length) {\n      this[kInsertString](StringPrototypeSlice.call(prefix, completeOn.length));\n      return;\n    } else if (!StringPrototypeStartsWith.call(completeOn, prefix)) {\n      this.line =\n        StringPrototypeSlice.call(this.line, 0, this.cursor - completeOn.length) +\n        prefix +\n        StringPrototypeSlice.call(this.line, this.cursor, this.line.length);\n      this.cursor = this.cursor - completeOn.length + prefix.length;\n      this._refreshLine();\n      return;\n    }\n\n    if (!lastKeypressWasTab) {\n      return;\n    }\n\n    this[kBeforeEdit](this.line, this.cursor);\n\n    // Apply/show completions.\n    var completionsWidth = ArrayPrototypeMap.call(completions, e => getStringWidth(e));\n    var width = MathMaxApply(completionsWidth) + 2; // 2 space padding\n    var maxColumns = MathFloor(this.columns / width) || 1;\n    if (maxColumns === Infinity) {\n      maxColumns = 1;\n    }\n    var output = \"\\r\\n\";\n    var lineIndex = 0;\n    var whitespace = 0;\n    for (var i = 0; i < completions.length; i++) {\n      var completion = completions[i];\n      if (completion === \"\" || lineIndex === maxColumns) {\n        output += \"\\r\\n\";\n        lineIndex = 0;\n        whitespace = 0;\n      } else {\n        output += StringPrototypeRepeat.call(\" \", whitespace);\n      }\n      if (completion !== \"\") {\n        output += completion;\n        whitespace = width - completionsWidth[i];\n        lineIndex++;\n      } else {\n        output += \"\\r\\n\";\n      }\n    }\n    if (lineIndex !== 0) {\n      output += \"\\r\\n\\r\\n\";\n    }\n    this[kWriteToOutput](output);\n    this[kRefreshLine]();\n  }\n\n  [kWordLeft]() {\n    if (this.cursor > 0) {\n      // Reverse the string and match a word near beginning\n      // to avoid quadratic time complexity\n      var leading = StringPrototypeSlice.call(this.line, 0, this.cursor);\n      var reversed = ArrayPrototypeJoin.call(ArrayPrototypeReverse.call(ArrayFrom(leading)), \"\");\n      var match = RegExpPrototypeExec.call(/^\\s*(?:[^\\w\\s]+|\\w+)?/, reversed);\n      this[kMoveCursor](-match[0].length);\n    }\n  }\n\n  [kWordRight]() {\n    if (this.cursor < this.line.length) {\n      var trailing = StringPrototypeSlice.call(this.line, this.cursor);\n      var match = RegExpPrototypeExec.call(/^(?:\\s+|[^\\w\\s]+|\\w+)\\s*/, trailing);\n      this[kMoveCursor](match[0].length);\n    }\n  }\n\n  [kDeleteLeft]() {\n    if (this.cursor > 0 && this.line.length > 0) {\n      this[kBeforeEdit](this.line, this.cursor);\n      // The number of UTF-16 units comprising the character to the left\n      var charSize = charLengthLeft(this.line, this.cursor);\n      this.line =\n        StringPrototypeSlice.call(this.line, 0, this.cursor - charSize) +\n        StringPrototypeSlice.call(this.line, this.cursor, this.line.length);\n\n      this.cursor -= charSize;\n      this[kRefreshLine]();\n    }\n  }\n\n  [kDeleteRight]() {\n    if (this.cursor < this.line.length) {\n      this[kBeforeEdit](this.line, this.cursor);\n      // The number of UTF-16 units comprising the character to the left\n      var charSize = charLengthAt(this.line, this.cursor);\n      this.line =\n        StringPrototypeSlice.call(this.line, 0, this.cursor) +\n        StringPrototypeSlice.call(this.line, this.cursor + charSize, this.line.length);\n      this[kRefreshLine]();\n    }\n  }\n\n  [kDeleteWordLeft]() {\n    if (this.cursor > 0) {\n      this[kBeforeEdit](this.line, this.cursor);\n      // Reverse the string and match a word near beginning\n      // to avoid quadratic time complexity\n      var leading = StringPrototypeSlice.call(this.line, 0, this.cursor);\n      var reversed = ArrayPrototypeJoin.call(ArrayPrototypeReverse.call(ArrayFrom(leading)), \"\");\n      var match = RegExpPrototypeExec.call(/^\\s*(?:[^\\w\\s]+|\\w+)?/, reversed);\n      leading = StringPrototypeSlice.call(leading, 0, leading.length - match[0].length);\n      this.line = leading + StringPrototypeSlice.call(this.line, this.cursor, this.line.length);\n      this.cursor = leading.length;\n      this[kRefreshLine]();\n    }\n  }\n\n  [kDeleteWordRight]() {\n    if (this.cursor < this.line.length) {\n      this[kBeforeEdit](this.line, this.cursor);\n      var trailing = StringPrototypeSlice.call(this.line, this.cursor);\n      var match = RegExpPrototypeExec.call(/^(?:\\s+|\\W+|\\w+)\\s*/, trailing);\n      this.line =\n        StringPrototypeSlice.call(this.line, 0, this.cursor) + StringPrototypeSlice.call(trailing, match[0].length);\n      this[kRefreshLine]();\n    }\n  }\n\n  [kDeleteLineLeft]() {\n    this[kBeforeEdit](this.line, this.cursor);\n    var del = StringPrototypeSlice.call(this.line, 0, this.cursor);\n    this.line = StringPrototypeSlice.call(this.line, this.cursor);\n    this.cursor = 0;\n    this[kPushToKillRing](del);\n    this[kRefreshLine]();\n  }\n\n  [kDeleteLineRight]() {\n    this[kBeforeEdit](this.line, this.cursor);\n    var del = StringPrototypeSlice.call(this.line, this.cursor);\n    this.line = StringPrototypeSlice.call(this.line, 0, this.cursor);\n    this[kPushToKillRing](del);\n    this[kRefreshLine]();\n  }\n\n  [kPushToKillRing](del) {\n    if (!del || del === this[kKillRing][0]) return;\n    ArrayPrototypeUnshift.call(this[kKillRing], del);\n    this[kKillRingCursor] = 0;\n    while (this[kKillRing].length > kMaxLengthOfKillRing) ArrayPrototypePop.call(this[kKillRing]);\n  }\n\n  [kYank]() {\n    if (this[kKillRing].length > 0) {\n      this[kYanking] = true;\n      this[kInsertString](this[kKillRing][this[kKillRingCursor]]);\n    }\n  }\n\n  [kYankPop]() {\n    if (!this[kYanking]) {\n      return;\n    }\n    if (this[kKillRing].length > 1) {\n      var lastYank = this[kKillRing][this[kKillRingCursor]];\n      this[kKillRingCursor]++;\n      if (this[kKillRingCursor] >= this[kKillRing].length) {\n        this[kKillRingCursor] = 0;\n      }\n      var currentYank = this[kKillRing][this[kKillRingCursor]];\n      var head = StringPrototypeSlice.call(this.line, 0, this.cursor - lastYank.length);\n      var tail = StringPrototypeSlice.call(this.line, this.cursor);\n      this.line = head + currentYank + tail;\n      this.cursor = head.length + currentYank.length;\n      this[kRefreshLine]();\n    }\n  }\n\n  clearLine() {\n    this[kMoveCursor](+Infinity);\n    this[kWriteToOutput](\"\\r\\n\");\n    this.line = \"\";\n    this.cursor = 0;\n    this.prevRows = 0;\n  }\n\n  [kLine]() {\n    var line = this[kAddHistory]();\n    this[kUndoStack] = [];\n    this[kRedoStack] = [];\n    this.clearLine();\n    this[kOnLine](line);\n  }\n\n  [kPushToUndoStack](text, cursor) {\n    if (ArrayPrototypePush.call(this[kUndoStack], { text, cursor }) > kMaxUndoRedoStackSize) {\n      ArrayPrototypeShift.call(this[kUndoStack]);\n    }\n  }\n\n  [kUndo]() {\n    if (this[kUndoStack].length <= 0) return;\n\n    ArrayPrototypePush.call(this[kRedoStack], {\n      text: this.line,\n      cursor: this.cursor,\n    });\n\n    var entry = ArrayPrototypePop.call(this[kUndoStack]);\n    this.line = entry.text;\n    this.cursor = entry.cursor;\n\n    this[kRefreshLine]();\n  }\n\n  [kRedo]() {\n    if (this[kRedoStack].length <= 0) return;\n\n    ArrayPrototypePush.call(this[kUndoStack], {\n      text: this.line,\n      cursor: this.cursor,\n    });\n\n    var entry = ArrayPrototypePop.call(this[kRedoStack]);\n    this.line = entry.text;\n    this.cursor = entry.cursor;\n\n    this[kRefreshLine]();\n  }\n\n  [kHistoryNext]() {\n    if (this.historyIndex >= 0) {\n      this[kBeforeEdit](this.line, this.cursor);\n      var search = this[kSubstringSearch] || \"\";\n      var index = this.historyIndex - 1;\n      while (\n        index >= 0 &&\n        (!StringPrototypeStartsWith.call(this.history[index], search) || this.line === this.history[index])\n      ) {\n        index--;\n      }\n      if (index === -1) {\n        this.line = search;\n      } else {\n        this.line = this.history[index];\n      }\n      this.historyIndex = index;\n      this.cursor = this.line.length; // Set cursor to end of line.\n      this[kRefreshLine]();\n    }\n  }\n\n  [kHistoryPrev]() {\n    if (this.historyIndex < this.history.length && this.history.length) {\n      this[kBeforeEdit](this.line, this.cursor);\n      var search = this[kSubstringSearch] || \"\";\n      var index = this.historyIndex + 1;\n      while (\n        index < this.history.length &&\n        (!StringPrototypeStartsWith.call(this.history[index], search) || this.line === this.history[index])\n      ) {\n        index++;\n      }\n      if (index === this.history.length) {\n        this.line = search;\n      } else {\n        this.line = this.history[index];\n      }\n      this.historyIndex = index;\n      this.cursor = this.line.length; // Set cursor to end of line.\n      this[kRefreshLine]();\n    }\n  }\n\n  // Returns the last character's display position of the given string\n  [kGetDisplayPos](str) {\n    var offset = 0;\n    var col = this.columns;\n    var rows = 0;\n    str = stripVTControlCharacters(str);\n    for (var char of new SafeStringIterator(str)) {\n      if (char === \"\\n\") {\n        // Rows must be incremented by 1 even if offset = 0 or col = +Infinity.\n        rows += MathCeil(offset / col) || 1;\n        offset = 0;\n        continue;\n      }\n      // Tabs must be aligned by an offset of the tab size.\n      if (char === \"\\t\") {\n        offset += this.tabSize - (offset % this.tabSize);\n        continue;\n      }\n      var width = getStringWidth(char, false /* stripVTControlCharacters */);\n      if (width === 0 || width === 1) {\n        offset += width;\n      } else {\n        // width === 2\n        if ((offset + 1) % col === 0) {\n          offset++;\n        }\n        offset += 2;\n      }\n    }\n    var cols = offset % col;\n    rows += (offset - cols) / col;\n    return { cols, rows };\n  }\n\n  /**\n   * Returns the real position of the cursor in relation\n   * to the input prompt + string.\n   * @returns {{\n   *   rows: number;\n   *   cols: number;\n   * }}\n   */\n  getCursorPos() {\n    var strBeforeCursor = this[kPrompt] + StringPrototypeSlice.call(this.line, 0, this.cursor);\n    return this[kGetDisplayPos](strBeforeCursor);\n  }\n\n  // This function moves cursor dx places to the right\n  // (-dx for left) and refreshes the line if it is needed.\n  [kMoveCursor](dx) {\n    if (dx === 0) {\n      return;\n    }\n    var oldPos = this.getCursorPos();\n    this.cursor += dx;\n\n    // Bounds check\n    if (this.cursor < 0) {\n      this.cursor = 0;\n    } else if (this.cursor > this.line.length) {\n      this.cursor = this.line.length;\n    }\n\n    var newPos = this.getCursorPos();\n\n    // Check if cursor stayed on the line.\n    if (oldPos.rows === newPos.rows) {\n      var diffWidth = newPos.cols - oldPos.cols;\n      moveCursor(this.output, diffWidth, 0);\n    } else {\n      this[kRefreshLine]();\n    }\n  }\n\n  // Handle a write from the tty\n  [kTtyWrite](s, key) {\n    var previousKey = this[kPreviousKey];\n    key = key || kEmptyObject;\n    this[kPreviousKey] = key;\n    var { name: keyName, meta: keyMeta, ctrl: keyCtrl, shift: keyShift, sequence: keySeq } = key;\n\n    if (!keyMeta || keyName !== \"y\") {\n      // Reset yanking state unless we are doing yank pop.\n      this[kYanking] = false;\n    }\n\n    // Activate or deactivate substring search.\n    if ((keyName === \"up\" || keyName === \"down\") && !keyCtrl && !keyMeta && !keyShift) {\n      if (this[kSubstringSearch] === null) {\n        this[kSubstringSearch] = StringPrototypeSlice.call(this.line, 0, this.cursor);\n      }\n    } else if (this[kSubstringSearch] !== null) {\n      this[kSubstringSearch] = null;\n      // Reset the index in case there's no match.\n      if (this.history.length === this.historyIndex) {\n        this.historyIndex = -1;\n      }\n    }\n\n    // Undo & Redo\n    if (typeof keySeq === \"string\") {\n      switch (StringPrototypeCodePointAt.call(keySeq, 0)) {\n        case 0x1f:\n          this[kUndo]();\n          return;\n        case 0x1e:\n          this[kRedo]();\n          return;\n        default:\n          break;\n      }\n    }\n\n    // Ignore escape key, fixes\n    // https://github.com/nodejs/node-v0.x-archive/issues/2876.\n    if (keyName === \"escape\") return;\n\n    if (keyCtrl && keyShift) {\n      /* Control and shift pressed */\n      switch (keyName) {\n        // TODO(BridgeAR): The transmitted escape sequence is `\\b` and that is\n        // identical to <ctrl>-h. It should have a unique escape sequence.\n        case \"backspace\":\n          this[kDeleteLineLeft]();\n          break;\n\n        case \"delete\":\n          this[kDeleteLineRight]();\n          break;\n      }\n    } else if (keyCtrl) {\n      /* Control key pressed */\n\n      switch (keyName) {\n        case \"c\":\n          if (this.listenerCount(\"SIGINT\") > 0) {\n            this.emit(\"SIGINT\");\n          } else {\n            // This readline instance is finished\n            this.close();\n          }\n          break;\n\n        case \"h\": // delete left\n          this[kDeleteLeft]();\n          break;\n\n        case \"d\": // delete right or EOF\n          if (this.cursor === 0 && this.line.length === 0) {\n            // This readline instance is finished\n            this.close();\n          } else if (this.cursor < this.line.length) {\n            this[kDeleteRight]();\n          }\n          break;\n\n        case \"u\": // Delete from current to start of line\n          this[kDeleteLineLeft]();\n          break;\n\n        case \"k\": // Delete from current to end of line\n          this[kDeleteLineRight]();\n          break;\n\n        case \"a\": // Go to the start of the line\n          this[kMoveCursor](-Infinity);\n          break;\n\n        case \"e\": // Go to the end of the line\n          this[kMoveCursor](+Infinity);\n          break;\n\n        case \"b\": // back one character\n          this[kMoveCursor](-charLengthLeft(this.line, this.cursor));\n          break;\n\n        case \"f\": // Forward one character\n          this[kMoveCursor](+charLengthAt(this.line, this.cursor));\n          break;\n\n        case \"l\": // Clear the whole screen\n          cursorTo(this.output, 0, 0);\n          clearScreenDown(this.output);\n          this[kRefreshLine]();\n          break;\n\n        case \"n\": // next history item\n          this[kHistoryNext]();\n          break;\n\n        case \"p\": // Previous history item\n          this[kHistoryPrev]();\n          break;\n\n        case \"y\": // Yank killed string\n          this[kYank]();\n          break;\n\n        case \"z\":\n          if (process.platform === \"win32\") break;\n          if (this.listenerCount(\"SIGTSTP\") > 0) {\n            this.emit(\"SIGTSTP\");\n          } else {\n            process.once(\"SIGCONT\", () => {\n              // Don't raise events if stream has already been abandoned.\n              if (!this.paused) {\n                // Stream must be paused and resumed after SIGCONT to catch\n                // SIGINT, SIGTSTP, and EOF.\n                this.pause();\n                this.emit(\"SIGCONT\");\n              }\n              // Explicitly re-enable \"raw mode\" and move the cursor to\n              // the correct position.\n              // See https://github.com/joyent/node/issues/3295.\n              this[kSetRawMode](true);\n              this[kRefreshLine]();\n            });\n            this[kSetRawMode](false);\n            process.kill(process.pid, \"SIGTSTP\");\n          }\n          break;\n\n        case \"w\": // Delete backwards to a word boundary\n        case \"backspace\":\n          this[kDeleteWordLeft]();\n          break;\n\n        case \"delete\": // Delete forward to a word boundary\n          this[kDeleteWordRight]();\n          break;\n\n        case \"left\":\n          this[kWordLeft]();\n          break;\n\n        case \"right\":\n          this[kWordRight]();\n          break;\n      }\n    } else if (keyMeta) {\n      /* Meta key pressed */\n\n      switch (keyName) {\n        case \"b\": // backward word\n          this[kWordLeft]();\n          break;\n\n        case \"f\": // forward word\n          this[kWordRight]();\n          break;\n\n        case \"d\": // delete forward word\n        case \"delete\":\n          this[kDeleteWordRight]();\n          break;\n\n        case \"backspace\": // Delete backwards to a word boundary\n          this[kDeleteWordLeft]();\n          break;\n\n        case \"y\": // Doing yank pop\n          this[kYankPop]();\n          break;\n      }\n    } else {\n      /* No modifier keys used */\n\n      // \\r bookkeeping is only relevant if a \\n comes right after.\n      if (this[kSawReturnAt] && keyName !== \"enter\") this[kSawReturnAt] = 0;\n\n      switch (keyName) {\n        case \"return\": // Carriage return, i.e. \\r\n          this[kSawReturnAt] = DateNow();\n          this[kLine]();\n          break;\n\n        case \"enter\":\n          // When key interval > crlfDelay\n          if (this[kSawReturnAt] === 0 || DateNow() - this[kSawReturnAt] > this.crlfDelay) {\n            this[kLine]();\n          }\n          this[kSawReturnAt] = 0;\n          break;\n\n        case \"backspace\":\n          this[kDeleteLeft]();\n          break;\n\n        case \"delete\":\n          this[kDeleteRight]();\n          break;\n\n        case \"left\":\n          // Obtain the code point to the left\n          this[kMoveCursor](-charLengthLeft(this.line, this.cursor));\n          break;\n\n        case \"right\":\n          this[kMoveCursor](+charLengthAt(this.line, this.cursor));\n          break;\n\n        case \"home\":\n          this[kMoveCursor](-Infinity);\n          break;\n\n        case \"end\":\n          this[kMoveCursor](+Infinity);\n          break;\n\n        case \"up\":\n          this[kHistoryPrev]();\n          break;\n\n        case \"down\":\n          this[kHistoryNext]();\n          break;\n\n        case \"tab\":\n          // If tab completion enabled, do that...\n          if (typeof this.completer === \"function\" && this.isCompletionEnabled) {\n            var lastKeypressWasTab = previousKey && previousKey.name === \"tab\";\n            this[kTabComplete](lastKeypressWasTab);\n            break;\n          }\n        // falls through\n        default:\n          if (typeof s === \"string\" && s) {\n            var nextMatch = RegExpPrototypeExec.call(lineEnding, s);\n            if (nextMatch !== null) {\n              this[kInsertString](StringPrototypeSlice.call(s, 0, nextMatch.index));\n              var { lastIndex } = lineEnding;\n              while ((nextMatch = RegExpPrototypeExec.call(lineEnding, s)) !== null) {\n                this[kLine]();\n                this[kInsertString](StringPrototypeSlice.call(s, lastIndex, nextMatch.index));\n                ({ lastIndex } = lineEnding);\n              }\n              if (lastIndex === s.length) this[kLine]();\n            } else {\n              this[kInsertString](s);\n            }\n          }\n      }\n    }\n  }\n\n  /**\n   * Creates an `AsyncIterator` object that iterates through\n   * each line in the input stream as a string.\n   * @typedef {{\n   *   [Symbol.asyncIterator]: () => InterfaceAsyncIterator,\n   *   next: () => Promise<string>\n   * }} InterfaceAsyncIterator\n   * @returns {InterfaceAsyncIterator}\n   */\n  [SymbolAsyncIterator]() {\n    if (this[kLineObjectStream] === undefined) {\n      this[kLineObjectStream] = EventEmitter.on(this, \"line\", {\n        close: [\"close\"],\n        highWatermark: 1024,\n        [kFirstEventParam]: true,\n      });\n    }\n    return this[kLineObjectStream];\n  }\n};\n\nfunction Interface(input, output, completer, terminal) {\n  if (!(this instanceof Interface)) {\n    return new Interface(input, output, completer, terminal);\n  }\n\n  if (input?.input && typeof input.completer === \"function\" && input.completer.length !== 2) {\n    var { completer } = input;\n    input.completer = (v, cb) => cb(null, completer(v));\n  } else if (typeof completer === \"function\" && completer.length !== 2) {\n    var realCompleter = completer;\n    completer = (v, cb) => cb(null, realCompleter(v));\n  }\n\n  InterfaceConstructor.call(this, input, output, completer, terminal);\n\n  // TODO: Test this\n  if (process.env.TERM === \"dumb\") {\n    this._ttyWrite = _ttyWriteDumb.bind(this);\n  }\n}\n\nObjectSetPrototypeOf(Interface.prototype, _Interface.prototype);\nObjectSetPrototypeOf(Interface, _Interface);\n\n/**\n * Displays `query` by writing it to the `output`.\n * @param {string} query\n * @param {{ signal?: AbortSignal; }} [options]\n * @param {Function} cb\n * @returns {void}\n */\nInterface.prototype.question = function question(query, options, cb) {\n  cb = typeof options === \"function\" ? options : cb;\n  if (options === null || typeof options !== \"object\") {\n    options = kEmptyObject;\n  }\n\n  var signal = options?.signal;\n  if (signal) {\n    validateAbortSignal(signal, \"options.signal\");\n    if (signal.aborted) {\n      return;\n    }\n\n    var onAbort = () => {\n      this[kQuestionCancel]();\n    };\n    signal.addEventListener(\"abort\", onAbort, { once: true });\n    var cleanup = () => {\n      signal.removeEventListener(\"abort\", onAbort);\n    };\n    var originalCb = cb;\n    cb =\n      typeof cb === \"function\"\n        ? answer => {\n            cleanup();\n            return originalCb(answer);\n          }\n        : cleanup;\n  }\n\n  if (typeof cb === \"function\") {\n    this[kQuestion](query, cb);\n  }\n};\n\nInterface.prototype.question[promisify.custom] = function question(query, options) {\n  if (options === null || typeof options !== \"object\") {\n    options = kEmptyObject;\n  }\n\n  var signal = options?.signal;\n\n  if (signal && signal.aborted) {\n    return PromiseReject(new AbortError(undefined, { cause: signal.reason }));\n  }\n\n  return new Promise((resolve, reject) => {\n    var cb = resolve;\n    if (signal) {\n      var onAbort = () => {\n        reject(new AbortError(undefined, { cause: signal.reason }));\n      };\n      signal.addEventListener(\"abort\", onAbort, { once: true });\n      cb = answer => {\n        signal.removeEventListener(\"abort\", onAbort);\n        resolve(answer);\n      };\n    }\n    this.question(query, options, cb);\n  });\n};\n\n/**\n * Creates a new `readline.Interface` instance.\n * @param {Readable | {\n *   input: Readable;\n *   output: Writable;\n *   completer?: Function;\n *   terminal?: boolean;\n *   history?: string[];\n *   historySize?: number;\n *   removeHistoryDuplicates?: boolean;\n *   prompt?: string;\n *   crlfDelay?: number;\n *   escapeCodeTimeout?: number;\n *   tabSize?: number;\n *   signal?: AbortSignal;\n *   }} input\n * @param {Writable} [output]\n * @param {Function} [completer]\n * @param {boolean} [terminal]\n * @returns {Interface}\n */\nfunction createInterface(input, output, completer, terminal) {\n  return new Interface(input, output, completer, terminal);\n}\n\nObjectDefineProperties(Interface.prototype, {\n  // Redirect internal prototype methods to the underscore notation for backward\n  // compatibility.\n  [kSetRawMode]: {\n    __proto__: null,\n    get() {\n      return this._setRawMode;\n    },\n  },\n  [kOnLine]: {\n    __proto__: null,\n    get() {\n      return this._onLine;\n    },\n  },\n  [kWriteToOutput]: {\n    __proto__: null,\n    get() {\n      return this._writeToOutput;\n    },\n  },\n  [kAddHistory]: {\n    __proto__: null,\n    get() {\n      return this._addHistory;\n    },\n  },\n  [kRefreshLine]: {\n    __proto__: null,\n    get() {\n      return this._refreshLine;\n    },\n  },\n  [kNormalWrite]: {\n    __proto__: null,\n    get() {\n      return this._normalWrite;\n    },\n  },\n  [kInsertString]: {\n    __proto__: null,\n    get() {\n      return this._insertString;\n    },\n  },\n  [kTabComplete]: {\n    __proto__: null,\n    get() {\n      return this._tabComplete;\n    },\n  },\n  [kWordLeft]: {\n    __proto__: null,\n    get() {\n      return this._wordLeft;\n    },\n  },\n  [kWordRight]: {\n    __proto__: null,\n    get() {\n      return this._wordRight;\n    },\n  },\n  [kDeleteLeft]: {\n    __proto__: null,\n    get() {\n      return this._deleteLeft;\n    },\n  },\n  [kDeleteRight]: {\n    __proto__: null,\n    get() {\n      return this._deleteRight;\n    },\n  },\n  [kDeleteWordLeft]: {\n    __proto__: null,\n    get() {\n      return this._deleteWordLeft;\n    },\n  },\n  [kDeleteWordRight]: {\n    __proto__: null,\n    get() {\n      return this._deleteWordRight;\n    },\n  },\n  [kDeleteLineLeft]: {\n    __proto__: null,\n    get() {\n      return this._deleteLineLeft;\n    },\n  },\n  [kDeleteLineRight]: {\n    __proto__: null,\n    get() {\n      return this._deleteLineRight;\n    },\n  },\n  [kLine]: {\n    __proto__: null,\n    get() {\n      return this._line;\n    },\n  },\n  [kHistoryNext]: {\n    __proto__: null,\n    get() {\n      return this._historyNext;\n    },\n  },\n  [kHistoryPrev]: {\n    __proto__: null,\n    get() {\n      return this._historyPrev;\n    },\n  },\n  [kGetDisplayPos]: {\n    __proto__: null,\n    get() {\n      return this._getDisplayPos;\n    },\n  },\n  [kMoveCursor]: {\n    __proto__: null,\n    get() {\n      return this._moveCursor;\n    },\n  },\n  [kTtyWrite]: {\n    __proto__: null,\n    get() {\n      return this._ttyWrite;\n    },\n  },\n\n  // Defining proxies for the internal instance properties for backward\n  // compatibility.\n  _decoder: {\n    __proto__: null,\n    get() {\n      return this[kDecoder];\n    },\n    set(value) {\n      this[kDecoder] = value;\n    },\n  },\n  _line_buffer: {\n    __proto__: null,\n    get() {\n      return this[kLine_buffer];\n    },\n    set(value) {\n      this[kLine_buffer] = value;\n    },\n  },\n  _oldPrompt: {\n    __proto__: null,\n    get() {\n      return this[kOldPrompt];\n    },\n    set(value) {\n      this[kOldPrompt] = value;\n    },\n  },\n  _previousKey: {\n    __proto__: null,\n    get() {\n      return this[kPreviousKey];\n    },\n    set(value) {\n      this[kPreviousKey] = value;\n    },\n  },\n  _prompt: {\n    __proto__: null,\n    get() {\n      return this[kPrompt];\n    },\n    set(value) {\n      this[kPrompt] = value;\n    },\n  },\n  _questionCallback: {\n    __proto__: null,\n    get() {\n      return this[kQuestionCallback];\n    },\n    set(value) {\n      this[kQuestionCallback] = value;\n    },\n  },\n  _sawKeyPress: {\n    __proto__: null,\n    get() {\n      return this[kSawKeyPress];\n    },\n    set(value) {\n      this[kSawKeyPress] = value;\n    },\n  },\n  _sawReturnAt: {\n    __proto__: null,\n    get() {\n      return this[kSawReturnAt];\n    },\n    set(value) {\n      this[kSawReturnAt] = value;\n    },\n  },\n});\n\n// Make internal methods public for backward compatibility.\nInterface.prototype._setRawMode = _Interface.prototype[kSetRawMode];\nInterface.prototype._onLine = _Interface.prototype[kOnLine];\nInterface.prototype._writeToOutput = _Interface.prototype[kWriteToOutput];\nInterface.prototype._addHistory = _Interface.prototype[kAddHistory];\nInterface.prototype._refreshLine = _Interface.prototype[kRefreshLine];\nInterface.prototype._normalWrite = _Interface.prototype[kNormalWrite];\nInterface.prototype._insertString = _Interface.prototype[kInsertString];\nInterface.prototype._tabComplete = function (lastKeypressWasTab) {\n  // Overriding parent method because `this.completer` in the legacy\n  // implementation takes a callback instead of being an async function.\n  this.pause();\n  var string = StringPrototypeSlice.call(this.line, 0, this.cursor);\n  this.completer(string, (err, value) => {\n    this.resume();\n\n    if (err) {\n      this._writeToOutput(`Tab completion error: ${inspect(err)}`);\n      return;\n    }\n\n    this[kTabCompleter](lastKeypressWasTab, value);\n  });\n};\nInterface.prototype._wordLeft = _Interface.prototype[kWordLeft];\nInterface.prototype._wordRight = _Interface.prototype[kWordRight];\nInterface.prototype._deleteLeft = _Interface.prototype[kDeleteLeft];\nInterface.prototype._deleteRight = _Interface.prototype[kDeleteRight];\nInterface.prototype._deleteWordLeft = _Interface.prototype[kDeleteWordLeft];\nInterface.prototype._deleteWordRight = _Interface.prototype[kDeleteWordRight];\nInterface.prototype._deleteLineLeft = _Interface.prototype[kDeleteLineLeft];\nInterface.prototype._deleteLineRight = _Interface.prototype[kDeleteLineRight];\nInterface.prototype._line = _Interface.prototype[kLine];\nInterface.prototype._historyNext = _Interface.prototype[kHistoryNext];\nInterface.prototype._historyPrev = _Interface.prototype[kHistoryPrev];\nInterface.prototype._getDisplayPos = _Interface.prototype[kGetDisplayPos];\nInterface.prototype._getCursorPos = _Interface.prototype.getCursorPos;\nInterface.prototype._moveCursor = _Interface.prototype[kMoveCursor];\nInterface.prototype._ttyWrite = _Interface.prototype[kTtyWrite];\n\nfunction _ttyWriteDumb(s, key) {\n  key = key || kEmptyObject;\n\n  if (key.name === \"escape\") return;\n\n  if (this[kSawReturnAt] && key.name !== \"enter\") this[kSawReturnAt] = 0;\n\n  if (keyCtrl) {\n    if (key.name === \"c\") {\n      if (this.listenerCount(\"SIGINT\") > 0) {\n        this.emit(\"SIGINT\");\n      } else {\n        // This readline instance is finished\n        this.close();\n      }\n\n      return;\n    } else if (key.name === \"d\") {\n      this.close();\n      return;\n    }\n  }\n\n  switch (key.name) {\n    case \"return\": // Carriage return, i.e. \\r\n      this[kSawReturnAt] = DateNow();\n      this._line();\n      break;\n\n    case \"enter\":\n      // When key interval > crlfDelay\n      if (this[kSawReturnAt] === 0 || DateNow() - this[kSawReturnAt] > this.crlfDelay) {\n        this._line();\n      }\n      this[kSawReturnAt] = 0;\n      break;\n\n    default:\n      if (typeof s === \"string\" && s) {\n        this.line += s;\n        this.cursor += s.length;\n        this._writeToOutput(s);\n      }\n  }\n}\n\nclass Readline {\n  #autoCommit = false;\n  #stream;\n  #todo = [];\n\n  constructor(stream, options = undefined) {\n    isWritable ??= import.meta.require(\"node:stream\").isWritable;\n    if (!isWritable(stream)) throw new ERR_INVALID_ARG_TYPE(\"stream\", \"Writable\", stream);\n    this.#stream = stream;\n    if (options?.autoCommit != null) {\n      validateBoolean(options.autoCommit, \"options.autoCommit\");\n      this.#autoCommit = options.autoCommit;\n    }\n  }\n\n  /**\n   * Moves the cursor to the x and y coordinate on the given stream.\n   * @param {integer} x\n   * @param {integer} [y]\n   * @returns {Readline} this\n   */\n  cursorTo(x, y = undefined) {\n    validateInteger(x, \"x\");\n    if (y != null) validateInteger(y, \"y\");\n\n    var data = y == null ? CSI`${x + 1}G` : CSI`${y + 1};${x + 1}H`;\n    if (this.#autoCommit) process.nextTick(() => this.#stream.write(data));\n    else ArrayPrototypePush.call(this.#todo, data);\n\n    return this;\n  }\n\n  /**\n   * Moves the cursor relative to its current location.\n   * @param {integer} dx\n   * @param {integer} dy\n   * @returns {Readline} this\n   */\n  moveCursor(dx, dy) {\n    if (dx || dy) {\n      validateInteger(dx, \"dx\");\n      validateInteger(dy, \"dy\");\n\n      var data = \"\";\n\n      if (dx < 0) {\n        data += CSI`${-dx}D`;\n      } else if (dx > 0) {\n        data += CSI`${dx}C`;\n      }\n\n      if (dy < 0) {\n        data += CSI`${-dy}A`;\n      } else if (dy > 0) {\n        data += CSI`${dy}B`;\n      }\n      if (this.#autoCommit) process.nextTick(() => this.#stream.write(data));\n      else ArrayPrototypePush.call(this.#todo, data);\n    }\n    return this;\n  }\n\n  /**\n   * Clears the current line the cursor is on.\n   * @param {-1|0|1} dir Direction to clear:\n   *   -1 for left of the cursor\n   *   +1 for right of the cursor\n   *    0 for the entire line\n   * @returns {Readline} this\n   */\n  clearLine(dir) {\n    validateInteger(dir, \"dir\", -1, 1);\n\n    var data = dir < 0 ? kClearToLineBeginning : dir > 0 ? kClearToLineEnd : kClearLine;\n    if (this.#autoCommit) process.nextTick(() => this.#stream.write(data));\n    else ArrayPrototypePush.call(this.#todo, data);\n    return this;\n  }\n\n  /**\n   * Clears the screen from the current position of the cursor down.\n   * @returns {Readline} this\n   */\n  clearScreenDown() {\n    if (this.#autoCommit) {\n      process.nextTick(() => this.#stream.write(kClearScreenDown));\n    } else {\n      ArrayPrototypePush.call(this.#todo, kClearScreenDown);\n    }\n    return this;\n  }\n\n  /**\n   * Sends all the pending actions to the associated `stream` and clears the\n   * internal list of pending actions.\n   * @returns {Promise<void>} Resolves when all pending actions have been\n   * flushed to the associated `stream`.\n   */\n  commit() {\n    return new Promise(resolve => {\n      this.#stream.write(ArrayPrototypeJoin.call(this.#todo, \"\"), resolve);\n      this.#todo = [];\n    });\n  }\n\n  /**\n   * Clears the internal list of pending actions without sending it to the\n   * associated `stream`.\n   * @returns {Readline} this\n   */\n  rollback() {\n    this.#todo = [];\n    return this;\n  }\n}\n\nvar PromisesInterface = class Interface extends _Interface {\n  // eslint-disable-next-line no-useless-constructor\n  constructor(input, output, completer, terminal) {\n    super(input, output, completer, terminal);\n  }\n  question(query, options = kEmptyObject) {\n    var signal = options?.signal;\n    if (signal) {\n      validateAbortSignal(signal, \"options.signal\");\n      if (signal.aborted) {\n        return PromiseReject(new AbortError(undefined, { cause: signal.reason }));\n      }\n    }\n    return new Promise((resolve, reject) => {\n      var cb = resolve;\n      if (options?.signal) {\n        var onAbort = () => {\n          this[kQuestionCancel]();\n          reject(new AbortError(undefined, { cause: signal.reason }));\n        };\n        signal.addEventListener(\"abort\", onAbort, { once: true });\n        cb = answer => {\n          signal.removeEventListener(\"abort\", onAbort);\n          resolve(answer);\n        };\n      }\n      this[kQuestion](query, cb);\n    });\n  }\n};\n\n// ----------------------------------------------------------------------------\n// Exports\n// ----------------------------------------------------------------------------\nexport var Interface = Interface;\nexport var clearLine = clearLine;\nexport var clearScreenDown = clearScreenDown;\nexport var createInterface = createInterface;\nexport var cursorTo = cursorTo;\nexport var emitKeypressEvents = emitKeypressEvents;\nexport var moveCursor = moveCursor;\nexport var promises = {\n  Readline,\n  Interface: PromisesInterface,\n  createInterface(input, output, completer, terminal) {\n    return new PromisesInterface(input, output, completer, terminal);\n  },\n};\n\nexport default {\n  Interface,\n  clearLine,\n  clearScreenDown,\n  createInterface,\n  cursorTo,\n  emitKeypressEvents,\n  moveCursor,\n  promises,\n\n  [SymbolFor(\"__BUN_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED__\")]: {\n    CSI,\n    utils: {\n      getStringWidth,\n      stripVTControlCharacters,\n    },\n  },\n  [SymbolFor(\"CommonJS\")]: 0,\n};\n",
  "// Hardcoded module \"node:readline\"\n// Attribution: Some parts of of this module are derived from code originating from the Node.js\n// readline module which is licensed under an MIT license:\n//\n// Copyright Node.js contributors. All rights reserved.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to\n// deal in the Software without restriction, including without limitation the\n// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n// sell copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n// IN THE SOFTWARE.\n\n// ----------------------------------------------------------------------------\n// Section: Imports\n// ----------------------------------------------------------------------------\nvar { Array, RegExp, String, Bun } = import.meta.primordials;\nvar EventEmitter = import.meta.require(\"node:events\");\nvar { clearTimeout, setTimeout } = import.meta.require(\"timers\");\nvar { StringDecoder } = import.meta.require(\"string_decoder\");\nvar isWritable;\n\nvar { inspect } = Bun;\nvar debug = process.env.BUN_JS_DEBUG ? console.log : () => {};\n\n// ----------------------------------------------------------------------------\n// Section: Preamble\n// ----------------------------------------------------------------------------\n\nvar SymbolAsyncIterator = Symbol.asyncIterator;\nvar SymbolIterator = Symbol.iterator;\nvar SymbolFor = Symbol.for;\nvar SymbolReplace = Symbol.replace;\nvar ArrayFrom = Array.from;\nvar ArrayIsArray = Array.isArray;\nvar ArrayPrototypeFilter = Array.prototype.filter;\nvar ArrayPrototypeSort = Array.prototype.sort;\nvar ArrayPrototypeIndexOf = Array.prototype.indexOf;\nvar ArrayPrototypeJoin = Array.prototype.join;\nvar ArrayPrototypeMap = Array.prototype.map;\nvar ArrayPrototypePop = Array.prototype.pop;\nvar ArrayPrototypePush = Array.prototype.push;\nvar ArrayPrototypeSlice = Array.prototype.slice;\nvar ArrayPrototypeSplice = Array.prototype.splice;\nvar ArrayPrototypeReverse = Array.prototype.reverse;\nvar ArrayPrototypeShift = Array.prototype.shift;\nvar ArrayPrototypeUnshift = Array.prototype.unshift;\nvar RegExpPrototypeExec = RegExp.prototype.exec;\nvar RegExpPrototypeSymbolReplace = RegExp.prototype[SymbolReplace];\nvar StringFromCharCode = String.fromCharCode;\nvar StringPrototypeCharCodeAt = String.prototype.charCodeAt;\nvar StringPrototypeCodePointAt = String.prototype.codePointAt;\nvar StringPrototypeSlice = String.prototype.slice;\nvar StringPrototypeToLowerCase = String.prototype.toLowerCase;\nvar StringPrototypeEndsWith = String.prototype.endsWith;\nvar StringPrototypeRepeat = String.prototype.repeat;\nvar StringPrototypeStartsWith = String.prototype.startsWith;\nvar StringPrototypeTrim = String.prototype.trim;\nvar StringPrototypeNormalize = String.prototype.normalize;\nvar NumberIsNaN = Number.isNaN;\nvar NumberIsFinite = Number.isFinite;\nvar NumberIsInteger = Number.isInteger;\nvar NumberMAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER;\nvar NumberMIN_SAFE_INTEGER = Number.MIN_SAFE_INTEGER;\nvar MathCeil = Math.ceil;\nvar MathFloor = Math.floor;\nvar MathMax = Math.max;\nvar MathMaxApply = Math.max.apply;\nvar DateNow = Date.now;\nvar FunctionPrototype = Function.prototype;\nvar StringPrototype = String.prototype;\nvar StringPrototypeSymbolIterator = StringPrototype[SymbolIterator];\nvar StringIteratorPrototypeNext = StringPrototypeSymbolIterator.call(\"\").next;\nvar ObjectSetPrototypeOf = Object.setPrototypeOf;\nvar ObjectDefineProperty = Object.defineProperty;\nvar ObjectDefineProperties = Object.defineProperties;\nvar ObjectFreeze = Object.freeze;\nvar ObjectAssign = Object.assign;\nvar ObjectCreate = Object.create;\nvar ObjectKeys = Object.keys;\nvar ObjectSeal = Object.seal;\n\nvar createSafeIterator = (factory, next) => {\n  class SafeIterator {\n    #iterator;\n    constructor(iterable) {\n      this.#iterator = factory.call(iterable);\n    }\n    next() {\n      return next.call(this.#iterator);\n    }\n    [SymbolIterator]() {\n      return this;\n    }\n  }\n  ObjectSetPrototypeOf(SafeIterator.prototype, null);\n  ObjectFreeze(SafeIterator.prototype);\n  ObjectFreeze(SafeIterator);\n  return SafeIterator;\n};\n\nvar SafeStringIterator = createSafeIterator(StringPrototypeSymbolIterator, StringIteratorPrototypeNext);\n\n// ----------------------------------------------------------------------------\n// Section: \"Internal\" modules\n// ----------------------------------------------------------------------------\n\n/**\n * Returns true if the character represented by a given\n * Unicode code point is full-width. Otherwise returns false.\n */\nvar isFullWidthCodePoint = code => {\n  // Code points are partially derived from:\n  // https://www.unicode.org/Public/UNIDATA/EastAsianWidth.txt\n  return (\n    code >= 0x1100 &&\n    (code <= 0x115f || // Hangul Jamo\n      code === 0x2329 || // LEFT-POINTING ANGLE BRACKET\n      code === 0x232a || // RIGHT-POINTING ANGLE BRACKET\n      // CJK Radicals Supplement .. Enclosed CJK Letters and Months\n      (code >= 0x2e80 && code <= 0x3247 && code !== 0x303f) ||\n      // Enclosed CJK Letters and Months .. CJK Unified Ideographs Extension A\n      (code >= 0x3250 && code <= 0x4dbf) ||\n      // CJK Unified Ideographs .. Yi Radicals\n      (code >= 0x4e00 && code <= 0xa4c6) ||\n      // Hangul Jamo Extended-A\n      (code >= 0xa960 && code <= 0xa97c) ||\n      // Hangul Syllables\n      (code >= 0xac00 && code <= 0xd7a3) ||\n      // CJK Compatibility Ideographs\n      (code >= 0xf900 && code <= 0xfaff) ||\n      // Vertical Forms\n      (code >= 0xfe10 && code <= 0xfe19) ||\n      // CJK Compatibility Forms .. Small Form Variants\n      (code >= 0xfe30 && code <= 0xfe6b) ||\n      // Halfwidth and Fullwidth Forms\n      (code >= 0xff01 && code <= 0xff60) ||\n      (code >= 0xffe0 && code <= 0xffe6) ||\n      // Kana Supplement\n      (code >= 0x1b000 && code <= 0x1b001) ||\n      // Enclosed Ideographic Supplement\n      (code >= 0x1f200 && code <= 0x1f251) ||\n      // Miscellaneous Symbols and Pictographs 0x1f300 - 0x1f5ff\n      // Emoticons 0x1f600 - 0x1f64f\n      (code >= 0x1f300 && code <= 0x1f64f) ||\n      // CJK Unified Ideographs Extension B .. Tertiary Ideographic Plane\n      (code >= 0x20000 && code <= 0x3fffd))\n  );\n};\n\nvar isZeroWidthCodePoint = code => {\n  return (\n    code <= 0x1f || // C0 control codes\n    (code >= 0x7f && code <= 0x9f) || // C1 control codes\n    (code >= 0x300 && code <= 0x36f) || // Combining Diacritical Marks\n    (code >= 0x200b && code <= 0x200f) || // Modifying Invisible Characters\n    // Combining Diacritical Marks for Symbols\n    (code >= 0x20d0 && code <= 0x20ff) ||\n    (code >= 0xfe00 && code <= 0xfe0f) || // Variation Selectors\n    (code >= 0xfe20 && code <= 0xfe2f) || // Combining Half Marks\n    (code >= 0xe0100 && code <= 0xe01ef)\n  ); // Variation Selectors\n};\n\n/**\n * Returns the number of columns required to display the given string.\n */\nvar getStringWidth = function getStringWidth(str, removeControlChars = true) {\n  var width = 0;\n\n  if (removeControlChars) str = stripVTControlCharacters(str);\n  str = StringPrototypeNormalize.call(str, \"NFC\");\n  for (var char of new SafeStringIterator(str)) {\n    var code = StringPrototypeCodePointAt.call(char, 0);\n    if (isFullWidthCodePoint(code)) {\n      width += 2;\n    } else if (!isZeroWidthCodePoint(code)) {\n      width++;\n    }\n  }\n\n  return width;\n};\n\n// Regex used for ansi escape code splitting\n// Adopted from https://github.com/chalk/ansi-regex/blob/HEAD/index.js\n// License: MIT, authors: @sindresorhus, Qix-, arjunmehta and LitoMore\n// Matches all ansi escape code sequences in a string\nvar ansiPattern =\n  \"[\\\\u001B\\\\u009B][[\\\\]()#;?]*\" +\n  \"(?:(?:(?:(?:;[-a-zA-Z\\\\d\\\\/#&.:=?%@~_]+)*\" +\n  \"|[a-zA-Z\\\\d]+(?:;[-a-zA-Z\\\\d\\\\/#&.:=?%@~_]*)*)?\\\\u0007)\" +\n  \"|(?:(?:\\\\d{1,4}(?:;\\\\d{0,4})*)?[\\\\dA-PR-TZcf-ntqry=><~]))\";\nvar ansi = new RegExp(ansiPattern, \"g\");\n\n/**\n * Remove all VT control characters. Use to estimate displayed string width.\n */\nfunction stripVTControlCharacters(str) {\n  validateString(str, \"str\");\n  return RegExpPrototypeSymbolReplace.call(ansi, str, \"\");\n}\n\n// Promisify\n\nvar kCustomPromisifiedSymbol = SymbolFor(\"nodejs.util.promisify.custom\");\nvar kCustomPromisifyArgsSymbol = Symbol(\"customPromisifyArgs\");\n\nfunction promisify(original) {\n  validateFunction(original, \"original\");\n\n  if (original[kCustomPromisifiedSymbol]) {\n    var fn = original[kCustomPromisifiedSymbol];\n\n    validateFunction(fn, \"util.promisify.custom\");\n\n    return ObjectDefineProperty(fn, kCustomPromisifiedSymbol, {\n      __proto__: null,\n      value: fn,\n      enumerable: false,\n      writable: false,\n      configurable: true,\n    });\n  }\n\n  // Names to create an object from in case the callback receives multiple\n  // arguments, e.g. ['bytesRead', 'buffer'] for fs.read.\n  var argumentNames = original[kCustomPromisifyArgsSymbol];\n\n  function fn(...args) {\n    return new Promise((resolve, reject) => {\n      ArrayPrototypePush.call(args, (err, ...values) => {\n        if (err) {\n          return reject(err);\n        }\n        if (argumentNames !== undefined && values.length > 1) {\n          var obj = {};\n          for (var i = 0; i < argumentNames.length; i++) obj[argumentNames[i]] = values[i];\n          resolve(obj);\n        } else {\n          resolve(values[0]);\n        }\n      });\n      ReflectApply(original, this, args);\n    });\n  }\n\n  ObjectSetPrototypeOf(fn, ObjectGetPrototypeOf(original));\n\n  ObjectDefineProperty(fn, kCustomPromisifiedSymbol, {\n    __proto__: null,\n    value: fn,\n    enumerable: false,\n    writable: false,\n    configurable: true,\n  });\n\n  var descriptors = ObjectGetOwnPropertyDescriptors(original);\n  var propertiesValues = ObjectValues(descriptors);\n  for (var i = 0; i < propertiesValues.length; i++) {\n    // We want to use null-prototype objects to not rely on globally mutable\n    // %Object.prototype%.\n    ObjectSetPrototypeOf(propertiesValues[i], null);\n  }\n  return ObjectDefineProperties(fn, descriptors);\n}\n\npromisify.custom = kCustomPromisifiedSymbol;\n\n// Constants\n\nvar kUTF16SurrogateThreshold = 0x10000; // 2 ** 16\nvar kEscape = \"\\x1b\";\nvar kSubstringSearch = Symbol(\"kSubstringSearch\");\n\nvar kIsNodeError = Symbol(\"kIsNodeError\");\n\n// Errors\nvar errorBases = {};\nvar VALID_NODE_ERROR_BASES = {\n  TypeError,\n  RangeError,\n  Error,\n};\n\nfunction getNodeErrorByName(typeName) {\n  var base = errorBases[typeName];\n  if (base) {\n    return base;\n  }\n  if (!ObjectKeys(VALID_NODE_ERROR_BASES).includes(typeName)) {\n    throw new Error(\"Invalid NodeError type\");\n  }\n\n  var Base = VALID_NODE_ERROR_BASES[typeName];\n\n  class NodeError extends Base {\n    [kIsNodeError] = true;\n    code;\n    constructor(msg, opts) {\n      super(msg, opts);\n      this.code = opts?.code || \"ERR_GENERIC\";\n    }\n\n    toString() {\n      return `${this.name} [${this.code}]: ${this.message}`;\n    }\n  }\n  errorBases[typeName] = NodeError;\n  return NodeError;\n}\n\nvar NodeError = getNodeErrorByName(\"Error\");\nvar NodeTypeError = getNodeErrorByName(\"TypeError\");\nvar NodeRangeError = getNodeErrorByName(\"RangeError\");\n\nclass ERR_INVALID_ARG_TYPE extends NodeTypeError {\n  constructor(name, type, value) {\n    super(`The \"${name}\" argument must be of type ${type}. Received type ${typeof value}`, {\n      code: \"ERR_INVALID_ARG_TYPE\",\n    });\n  }\n}\n\nclass ERR_INVALID_ARG_VALUE extends NodeTypeError {\n  constructor(name, value, reason = \"not specified\") {\n    super(`The value \"${String(value)}\" is invalid for argument '${name}'. Reason: ${reason}`, {\n      code: \"ERR_INVALID_ARG_VALUE\",\n    });\n  }\n}\n\nclass ERR_INVALID_CURSOR_POS extends NodeTypeError {\n  constructor() {\n    super(\"Cannot set cursor row without setting its column\", {\n      code: \"ERR_INVALID_CURSOR_POS\",\n    });\n  }\n}\n\nclass ERR_OUT_OF_RANGE extends NodeRangeError {\n  constructor(name, range, received) {\n    super(`The value of \"${name}\" is out of range. It must be ${range}. Received ${received}`, {\n      code: \"ERR_OUT_OF_RANGE\",\n    });\n  }\n}\n\nclass ERR_USE_AFTER_CLOSE extends NodeError {\n  constructor() {\n    super(\"This socket has been ended by the other party\", {\n      code: \"ERR_USE_AFTER_CLOSE\",\n    });\n  }\n}\n\nclass AbortError extends Error {\n  code;\n  constructor() {\n    super(\"The operation was aborted\");\n    this.code = \"ABORT_ERR\";\n  }\n}\n\n// Validators\n\n/**\n * @callback validateFunction\n * @param {*} value\n * @param {string} name\n * @returns {asserts value is Function}\n */\nfunction validateFunction(value, name) {\n  if (typeof value !== \"function\") throw new ERR_INVALID_ARG_TYPE(name, \"Function\", value);\n}\n\n/**\n * @callback validateAbortSignal\n * @param {*} signal\n * @param {string} name\n */\nfunction validateAbortSignal(signal, name) {\n  if (signal !== undefined && (signal === null || typeof signal !== \"object\" || !(\"aborted\" in signal))) {\n    throw new ERR_INVALID_ARG_TYPE(name, \"AbortSignal\", signal);\n  }\n}\n\n/**\n * @callback validateArray\n * @param {*} value\n * @param {string} name\n * @param {number} [minLength]\n * @returns {asserts value is any[]}\n */\nfunction validateArray(value, name, minLength = 0) {\n  // var validateArray = hideStackFrames((value, name, minLength = 0) => {\n  if (!ArrayIsArray(value)) {\n    throw new ERR_INVALID_ARG_TYPE(name, \"Array\", value);\n  }\n  if (value.length < minLength) {\n    var reason = `must be longer than ${minLength}`;\n    throw new ERR_INVALID_ARG_VALUE(name, value, reason);\n  }\n}\n\n/**\n * @callback validateString\n * @param {*} value\n * @param {string} name\n * @returns {asserts value is string}\n */\nfunction validateString(value, name) {\n  if (typeof value !== \"string\") throw new ERR_INVALID_ARG_TYPE(name, \"string\", value);\n}\n\n/**\n * @callback validateBoolean\n * @param {*} value\n * @param {string} name\n * @returns {asserts value is boolean}\n */\nfunction validateBoolean(value, name) {\n  if (typeof value !== \"boolean\") throw new ERR_INVALID_ARG_TYPE(name, \"boolean\", value);\n}\n\n/**\n * @callback validateObject\n * @param {*} value\n * @param {string} name\n * @param {{\n *   allowArray?: boolean,\n *   allowFunction?: boolean,\n *   nullable?: boolean\n * }} [options]\n */\nfunction validateObject(value, name, options = null) {\n  // var validateObject = hideStackFrames((value, name, options = null) => {\n  var allowArray = options?.allowArray ?? false;\n  var allowFunction = options?.allowFunction ?? false;\n  var nullable = options?.nullable ?? false;\n  if (\n    (!nullable && value === null) ||\n    (!allowArray && ArrayIsArray.call(value)) ||\n    (typeof value !== \"object\" && (!allowFunction || typeof value !== \"function\"))\n  ) {\n    throw new ERR_INVALID_ARG_TYPE(name, \"object\", value);\n  }\n}\n\n/**\n * @callback validateInteger\n * @param {*} value\n * @param {string} name\n * @param {number} [min]\n * @param {number} [max]\n * @returns {asserts value is number}\n */\nfunction validateInteger(value, name, min = NumberMIN_SAFE_INTEGER, max = NumberMAX_SAFE_INTEGER) {\n  if (typeof value !== \"number\") throw new ERR_INVALID_ARG_TYPE(name, \"number\", value);\n  if (!NumberIsInteger(value)) throw new ERR_OUT_OF_RANGE(name, \"an integer\", value);\n  if (value < min || value > max) throw new ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value);\n}\n\n/**\n * @callback validateUint32\n * @param {*} value\n * @param {string} name\n * @param {number|boolean} [positive=false]\n * @returns {asserts value is number}\n */\nfunction validateUint32(value, name, positive = false) {\n  if (typeof value !== \"number\") {\n    throw new ERR_INVALID_ARG_TYPE(name, \"number\", value);\n  }\n\n  if (!NumberIsInteger(value)) {\n    throw new ERR_OUT_OF_RANGE(name, \"an integer\", value);\n  }\n\n  var min = positive ? 1 : 0; // 2 ** 32 === 4294967296\n  var max = 4_294_967_295;\n\n  if (value < min || value > max) {\n    throw new ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value);\n  }\n}\n\n// ----------------------------------------------------------------------------\n// Section: Utils\n// ----------------------------------------------------------------------------\n\nfunction CSI(strings, ...args) {\n  var ret = `${kEscape}[`;\n  for (var n = 0; n < strings.length; n++) {\n    ret += strings[n];\n    if (n < args.length) ret += args[n];\n  }\n  return ret;\n}\n\nvar kClearLine, kClearScreenDown, kClearToLineBeginning, kClearToLineEnd;\n\nCSI.kEscape = kEscape;\nCSI.kClearLine = kClearLine = CSI`2K`;\nCSI.kClearScreenDown = kClearScreenDown = CSI`0J`;\nCSI.kClearToLineBeginning = kClearToLineBeginning = CSI`1K`;\nCSI.kClearToLineEnd = kClearToLineEnd = CSI`0K`;\n\nfunction charLengthLeft(str, i) {\n  if (i <= 0) return 0;\n  if (\n    (i > 1 && StringPrototypeCodePointAt.call(str, i - 2) >= kUTF16SurrogateThreshold) ||\n    StringPrototypeCodePointAt.call(str, i - 1) >= kUTF16SurrogateThreshold\n  ) {\n    return 2;\n  }\n  return 1;\n}\n\nfunction charLengthAt(str, i) {\n  if (str.length <= i) {\n    // Pretend to move to the right. This is necessary to autocomplete while\n    // moving to the right.\n    return 1;\n  }\n  return StringPrototypeCodePointAt.call(str, i) >= kUTF16SurrogateThreshold ? 2 : 1;\n}\n\n/*\n  Some patterns seen in terminal key escape codes, derived from combos seen\n  at http://www.midnight-commander.org/browser/lib/tty/key.c\n  ESC letter\n  ESC [ letter\n  ESC [ modifier letter\n  ESC [ 1 ; modifier letter\n  ESC [ num char\n  ESC [ num ; modifier char\n  ESC O letter\n  ESC O modifier letter\n  ESC O 1 ; modifier letter\n  ESC N letter\n  ESC [ [ num ; modifier char\n  ESC [ [ 1 ; modifier letter\n  ESC ESC [ num char\n  ESC ESC O letter\n  - char is usually ~ but $ and ^ also happen with rxvt\n  - modifier is 1 +\n                (shift     * 1) +\n                (left_alt  * 2) +\n                (ctrl      * 4) +\n                (right_alt * 8)\n  - two leading ESCs apparently mean the same as one leading ESC\n*/\nfunction* emitKeys(stream) {\n  while (true) {\n    var ch = yield;\n    var s = ch;\n    var escaped = false;\n\n    var keySeq = null;\n    var keyName;\n    var keyCtrl = false;\n    var keyMeta = false;\n    var keyShift = false;\n\n    // var key = {\n    //   sequence: null,\n    //   name: undefined,\n    //   ctrl: false,\n    //   meta: false,\n    //   shift: false,\n    // };\n\n    if (ch === kEscape) {\n      escaped = true;\n      s += ch = yield;\n\n      if (ch === kEscape) {\n        s += ch = yield;\n      }\n    }\n\n    if (escaped && (ch === \"O\" || ch === \"[\")) {\n      // ANSI escape sequence\n      var code = ch;\n      var modifier = 0;\n\n      if (ch === \"O\") {\n        // ESC O letter\n        // ESC O modifier letter\n        s += ch = yield;\n\n        if (ch >= \"0\" && ch <= \"9\") {\n          modifier = (ch >> 0) - 1;\n          s += ch = yield;\n        }\n\n        code += ch;\n      } else if (ch === \"[\") {\n        // ESC [ letter\n        // ESC [ modifier letter\n        // ESC [ [ modifier letter\n        // ESC [ [ num char\n        s += ch = yield;\n\n        if (ch === \"[\") {\n          // \\x1b[[A\n          //      ^--- escape codes might have a second bracket\n          code += ch;\n          s += ch = yield;\n        }\n\n        /*\n         * Here and later we try to buffer just enough data to get\n         * a complete ascii sequence.\n         *\n         * We have basically two classes of ascii characters to process:\n         *\n         *\n         * 1. `\\x1b[24;5~` should be parsed as { code: '[24~', modifier: 5 }\n         *\n         * This particular example is featuring Ctrl+F12 in xterm.\n         *\n         *  - `;5` part is optional, e.g. it could be `\\x1b[24~`\n         *  - first part can contain one or two digits\n         *\n         * So the generic regexp is like /^\\d\\d?(;\\d)?[~^$]$/\n         *\n         *\n         * 2. `\\x1b[1;5H` should be parsed as { code: '[H', modifier: 5 }\n         *\n         * This particular example is featuring Ctrl+Home in xterm.\n         *\n         *  - `1;5` part is optional, e.g. it could be `\\x1b[H`\n         *  - `1;` part is optional, e.g. it could be `\\x1b[5H`\n         *\n         * So the generic regexp is like /^((\\d;)?\\d)?[A-Za-z]$/\n         *\n         */\n        var cmdStart = s.length - 1;\n\n        // Skip one or two leading digits\n        if (ch >= \"0\" && ch <= \"9\") {\n          s += ch = yield;\n\n          if (ch >= \"0\" && ch <= \"9\") {\n            s += ch = yield;\n          }\n        }\n\n        // skip modifier\n        if (ch === \";\") {\n          s += ch = yield;\n\n          if (ch >= \"0\" && ch <= \"9\") {\n            s += yield;\n          }\n        }\n\n        /*\n         * We buffered enough data, now trying to extract code\n         * and modifier from it\n         */\n        var cmd = StringPrototypeSlice.call(s, cmdStart);\n        var match;\n\n        if ((match = RegExpPrototypeExec.call(/^(\\d\\d?)(;(\\d))?([~^$])$/, cmd))) {\n          code += match[1] + match[4];\n          modifier = (match[3] || 1) - 1;\n        } else if ((match = RegExpPrototypeExec.call(/^((\\d;)?(\\d))?([A-Za-z])$/, cmd))) {\n          code += match[4];\n          modifier = (match[3] || 1) - 1;\n        } else {\n          code += cmd;\n        }\n      }\n\n      // Parse the key modifier\n      keyCtrl = !!(modifier & 4);\n      keyMeta = !!(modifier & 10);\n      keyShift = !!(modifier & 1);\n      keyCode = code;\n\n      // Parse the key itself\n      switch (code) {\n        /* xterm/gnome ESC [ letter (with modifier) */\n        case \"[P\":\n          keyName = \"f1\";\n          break;\n        case \"[Q\":\n          keyName = \"f2\";\n          break;\n        case \"[R\":\n          keyName = \"f3\";\n          break;\n        case \"[S\":\n          keyName = \"f4\";\n          break;\n\n        /* xterm/gnome ESC O letter (without modifier) */\n        case \"OP\":\n          keyName = \"f1\";\n          break;\n        case \"OQ\":\n          keyName = \"f2\";\n          break;\n        case \"OR\":\n          keyName = \"f3\";\n          break;\n        case \"OS\":\n          keyName = \"f4\";\n          break;\n\n        /* xterm/rxvt ESC [ number ~ */\n        case \"[11~\":\n          keyName = \"f1\";\n          break;\n        case \"[12~\":\n          keyName = \"f2\";\n          break;\n        case \"[13~\":\n          keyName = \"f3\";\n          break;\n        case \"[14~\":\n          keyName = \"f4\";\n          break;\n\n        /* from Cygwin and used in libuv */\n        case \"[[A\":\n          keyName = \"f1\";\n          break;\n        case \"[[B\":\n          keyName = \"f2\";\n          break;\n        case \"[[C\":\n          keyName = \"f3\";\n          break;\n        case \"[[D\":\n          keyName = \"f4\";\n          break;\n        case \"[[E\":\n          keyName = \"f5\";\n          break;\n\n        /* common */\n        case \"[15~\":\n          keyName = \"f5\";\n          break;\n        case \"[17~\":\n          keyName = \"f6\";\n          break;\n        case \"[18~\":\n          keyName = \"f7\";\n          break;\n        case \"[19~\":\n          keyName = \"f8\";\n          break;\n        case \"[20~\":\n          keyName = \"f9\";\n          break;\n        case \"[21~\":\n          keyName = \"f10\";\n          break;\n        case \"[23~\":\n          keyName = \"f11\";\n          break;\n        case \"[24~\":\n          keyName = \"f12\";\n          break;\n\n        /* xterm ESC [ letter */\n        case \"[A\":\n          keyName = \"up\";\n          break;\n        case \"[B\":\n          keyName = \"down\";\n          break;\n        case \"[C\":\n          keyName = \"right\";\n          break;\n        case \"[D\":\n          keyName = \"left\";\n          break;\n        case \"[E\":\n          keyName = \"clear\";\n          break;\n        case \"[F\":\n          keyName = \"end\";\n          break;\n        case \"[H\":\n          keyName = \"home\";\n          break;\n\n        /* xterm/gnome ESC O letter */\n        case \"OA\":\n          keyName = \"up\";\n          break;\n        case \"OB\":\n          keyName = \"down\";\n          break;\n        case \"OC\":\n          keyName = \"right\";\n          break;\n        case \"OD\":\n          keyName = \"left\";\n          break;\n        case \"OE\":\n          keyName = \"clear\";\n          break;\n        case \"OF\":\n          keyName = \"end\";\n          break;\n        case \"OH\":\n          keyName = \"home\";\n          break;\n\n        /* xterm/rxvt ESC [ number ~ */\n        case \"[1~\":\n          keyName = \"home\";\n          break;\n        case \"[2~\":\n          keyName = \"insert\";\n          break;\n        case \"[3~\":\n          keyName = \"delete\";\n          break;\n        case \"[4~\":\n          keyName = \"end\";\n          break;\n        case \"[5~\":\n          keyName = \"pageup\";\n          break;\n        case \"[6~\":\n          keyName = \"pagedown\";\n          break;\n\n        /* putty */\n        case \"[[5~\":\n          keyName = \"pageup\";\n          break;\n        case \"[[6~\":\n          keyName = \"pagedown\";\n          break;\n\n        /* rxvt */\n        case \"[7~\":\n          keyName = \"home\";\n          break;\n        case \"[8~\":\n          keyName = \"end\";\n          break;\n\n        /* rxvt keys with modifiers */\n        case \"[a\":\n          keyName = \"up\";\n          keyShift = true;\n          break;\n        case \"[b\":\n          keyName = \"down\";\n          keyShift = true;\n          break;\n        case \"[c\":\n          keyName = \"right\";\n          keyShift = true;\n          break;\n        case \"[d\":\n          keyName = \"left\";\n          keyShift = true;\n          break;\n        case \"[e\":\n          keyName = \"clear\";\n          keyShift = true;\n          break;\n\n        case \"[2$\":\n          keyName = \"insert\";\n          keyShift = true;\n          break;\n        case \"[3$\":\n          keyName = \"delete\";\n          keyShift = true;\n          break;\n        case \"[5$\":\n          keyName = \"pageup\";\n          keyShift = true;\n          break;\n        case \"[6$\":\n          keyName = \"pagedown\";\n          keyShift = true;\n          break;\n        case \"[7$\":\n          keyName = \"home\";\n          keyShift = true;\n          break;\n        case \"[8$\":\n          keyName = \"end\";\n          keyShift = true;\n          break;\n\n        case \"Oa\":\n          keyName = \"up\";\n          keyCtrl = true;\n          break;\n        case \"Ob\":\n          keyName = \"down\";\n          keyCtrl = true;\n          break;\n        case \"Oc\":\n          keyName = \"right\";\n          keyCtrl = true;\n          break;\n        case \"Od\":\n          keyName = \"left\";\n          keyCtrl = true;\n          break;\n        case \"Oe\":\n          keyName = \"clear\";\n          keyCtrl = true;\n          break;\n\n        case \"[2^\":\n          keyName = \"insert\";\n          keyCtrl = true;\n          break;\n        case \"[3^\":\n          keyName = \"delete\";\n          keyCtrl = true;\n          break;\n        case \"[5^\":\n          keyName = \"pageup\";\n          keyCtrl = true;\n          break;\n        case \"[6^\":\n          keyName = \"pagedown\";\n          keyCtrl = true;\n          break;\n        case \"[7^\":\n          keyName = \"home\";\n          keyCtrl = true;\n          break;\n        case \"[8^\":\n          keyName = \"end\";\n          keyCtrl = true;\n          break;\n\n        /* misc. */\n        case \"[Z\":\n          keyName = \"tab\";\n          keyShift = true;\n          break;\n        default:\n          keyName = \"undefined\";\n          break;\n      }\n    } else if (ch === \"\\r\") {\n      // carriage return\n      keyName = \"return\";\n      keyMeta = escaped;\n    } else if (ch === \"\\n\") {\n      // Enter, should have been called linefeed\n      keyName = \"enter\";\n      keyMeta = escaped;\n    } else if (ch === \"\\t\") {\n      // tab\n      keyName = \"tab\";\n      keyMeta = escaped;\n    } else if (ch === \"\\b\" || ch === \"\\x7f\") {\n      // backspace or ctrl+h\n      keyName = \"backspace\";\n      keyMeta = escaped;\n    } else if (ch === kEscape) {\n      // escape key\n      keyName = \"escape\";\n      keyMeta = escaped;\n    } else if (ch === \" \") {\n      keyName = \"space\";\n      keyMeta = escaped;\n    } else if (!escaped && ch <= \"\\x1a\") {\n      // ctrl+letter\n      keyName = StringFromCharCode(StringPrototypeCharCodeAt.call(ch) + StringPrototypeCharCodeAt.call(\"a\") - 1);\n      keyCtrl = true;\n    } else if (RegExpPrototypeExec.call(/^[0-9A-Za-z]$/, ch) !== null) {\n      // Letter, number, shift+letter\n      keyName = StringPrototypeToLowerCase.call(ch);\n      keyShift = RegExpPrototypeExec.call(/^[A-Z]$/, ch) !== null;\n      keyMeta = escaped;\n    } else if (escaped) {\n      // Escape sequence timeout\n      keyName = ch.length ? undefined : \"escape\";\n      keyMeta = true;\n    }\n\n    keySeq = s;\n\n    if (s.length !== 0 && (keyName !== undefined || escaped)) {\n      /* Named character or sequence */\n      stream.emit(\"keypress\", escaped ? undefined : s, {\n        sequence: keySeq,\n        name: keyName,\n        ctrl: keyCtrl,\n        meta: keyMeta,\n        shift: keyShift,\n      });\n    } else if (charLengthAt(s, 0) === s.length) {\n      /* Single unnamed character, e.g. \".\" */\n      stream.emit(\"keypress\", s, {\n        sequence: keySeq,\n        name: keyName,\n        ctrl: keyCtrl,\n        meta: keyMeta,\n        shift: keyShift,\n      });\n    }\n    /* Unrecognized or broken escape sequence, don't emit anything */\n  }\n}\n\n// This runs in O(n log n).\nfunction commonPrefix(strings) {\n  if (strings.length === 0) {\n    return \"\";\n  }\n  if (strings.length === 1) {\n    return strings[0];\n  }\n  var sorted = ArrayPrototypeSort.call(ArrayPrototypeSlice.call(strings));\n  var min = sorted[0];\n  var max = sorted[sorted.length - 1];\n  for (var i = 0; i < min.length; i++) {\n    if (min[i] !== max[i]) {\n      return StringPrototypeSlice.call(min, 0, i);\n    }\n  }\n  return min;\n}\n\n// ----------------------------------------------------------------------------\n// Section: Cursor Functions\n// ----------------------------------------------------------------------------\n\n/**\n * moves the cursor to the x and y coordinate on the given stream\n */\n\nfunction cursorTo(stream, x, y, callback) {\n  if (callback !== undefined) {\n    validateFunction(callback, \"callback\");\n  }\n\n  if (typeof y === \"function\") {\n    callback = y;\n    y = undefined;\n  }\n\n  if (NumberIsNaN(x)) throw new ERR_INVALID_ARG_VALUE(\"x\", x);\n  if (NumberIsNaN(y)) throw new ERR_INVALID_ARG_VALUE(\"y\", y);\n\n  if (stream == null || (typeof x !== \"number\" && typeof y !== \"number\")) {\n    if (typeof callback === \"function\") process.nextTick(callback, null);\n    return true;\n  }\n\n  if (typeof x !== \"number\") throw new ERR_INVALID_CURSOR_POS();\n\n  var data = typeof y !== \"number\" ? CSI`${x + 1}G` : CSI`${y + 1};${x + 1}H`;\n  return stream.write(data, callback);\n}\n\n/**\n * moves the cursor relative to its current location\n */\n\nfunction moveCursor(stream, dx, dy, callback) {\n  if (callback !== undefined) {\n    validateFunction(callback, \"callback\");\n  }\n\n  if (stream == null || !(dx || dy)) {\n    if (typeof callback === \"function\") process.nextTick(callback, null);\n    return true;\n  }\n\n  var data = \"\";\n\n  if (dx < 0) {\n    data += CSI`${-dx}D`;\n  } else if (dx > 0) {\n    data += CSI`${dx}C`;\n  }\n\n  if (dy < 0) {\n    data += CSI`${-dy}A`;\n  } else if (dy > 0) {\n    data += CSI`${dy}B`;\n  }\n\n  return stream.write(data, callback);\n}\n\n/**\n * clears the current line the cursor is on:\n *   -1 for left of the cursor\n *   +1 for right of the cursor\n *    0 for the entire line\n */\n\nfunction clearLine(stream, dir, callback) {\n  if (callback !== undefined) {\n    validateFunction(callback, \"callback\");\n  }\n\n  if (stream === null || stream === undefined) {\n    if (typeof callback === \"function\") process.nextTick(callback, null);\n    return true;\n  }\n\n  var type = dir < 0 ? kClearToLineBeginning : dir > 0 ? kClearToLineEnd : kClearLine;\n  return stream.write(type, callback);\n}\n\n/**\n * clears the screen from the current position of the cursor down\n */\n\nfunction clearScreenDown(stream, callback) {\n  if (callback !== undefined) {\n    validateFunction(callback, \"callback\");\n  }\n\n  if (stream === null || stream === undefined) {\n    if (typeof callback === \"function\") process.nextTick(callback, null);\n    return true;\n  }\n\n  return stream.write(kClearScreenDown, callback);\n}\n\n// ----------------------------------------------------------------------------\n// Section: Emit keypress events\n// ----------------------------------------------------------------------------\n\nvar KEYPRESS_DECODER = Symbol(\"keypress-decoder\");\nvar ESCAPE_DECODER = Symbol(\"escape-decoder\");\n\n// GNU readline library - keyseq-timeout is 500ms (default)\nvar ESCAPE_CODE_TIMEOUT = 500;\n\n/**\n * accepts a readable Stream instance and makes it emit \"keypress\" events\n */\n\nfunction emitKeypressEvents(stream, iface = {}) {\n  if (stream[KEYPRESS_DECODER]) return;\n\n  stream[KEYPRESS_DECODER] = new StringDecoder(\"utf8\");\n\n  stream[ESCAPE_DECODER] = emitKeys(stream);\n  stream[ESCAPE_DECODER].next();\n\n  var triggerEscape = () => stream[ESCAPE_DECODER].next(\"\");\n  var { escapeCodeTimeout = ESCAPE_CODE_TIMEOUT } = iface;\n  var timeoutId;\n\n  function onData(input) {\n    if (stream.listenerCount(\"keypress\") > 0) {\n      var string = stream[KEYPRESS_DECODER].write(input);\n      if (string) {\n        clearTimeout(timeoutId);\n\n        // This supports characters of length 2.\n        iface[kSawKeyPress] = charLengthAt(string, 0) === string.length;\n        iface.isCompletionEnabled = false;\n\n        var length = 0;\n        for (var character of new SafeStringIterator(string)) {\n          length += character.length;\n          if (length === string.length) {\n            iface.isCompletionEnabled = true;\n          }\n\n          try {\n            stream[ESCAPE_DECODER].next(character);\n            // Escape letter at the tail position\n            if (length === string.length && character === kEscape) {\n              timeoutId = setTimeout(triggerEscape, escapeCodeTimeout);\n            }\n          } catch (err) {\n            // If the generator throws (it could happen in the `keypress`\n            // event), we need to restart it.\n            stream[ESCAPE_DECODER] = emitKeys(stream);\n            stream[ESCAPE_DECODER].next();\n            throw err;\n          }\n        }\n      }\n    } else {\n      // Nobody's watching anyway\n      stream.removeListener(\"data\", onData);\n      stream.on(\"newListener\", onNewListener);\n    }\n  }\n\n  function onNewListener(event) {\n    if (event === \"keypress\") {\n      stream.on(\"data\", onData);\n      stream.removeListener(\"newListener\", onNewListener);\n    }\n  }\n\n  if (stream.listenerCount(\"keypress\") > 0) {\n    stream.on(\"data\", onData);\n  } else {\n    stream.on(\"newListener\", onNewListener);\n  }\n}\n\n// ----------------------------------------------------------------------------\n// Section: Interface\n// ----------------------------------------------------------------------------\n\nvar kEmptyObject = ObjectFreeze(ObjectCreate(null));\n\n// Some constants regarding configuration of interface\nvar kHistorySize = 30;\nvar kMaxUndoRedoStackSize = 2048;\nvar kMincrlfDelay = 100;\n// \\r\\n, \\n, or \\r followed by something other than \\n\nvar lineEnding = /\\r?\\n|\\r(?!\\n)/g;\n\n// Max length of the kill ring\nvar kMaxLengthOfKillRing = 32;\n\n// Symbols\n\n// Public symbols\nvar kLineObjectStream = Symbol(\"line object stream\");\nvar kQuestionCancel = Symbol(\"kQuestionCancel\");\nvar kQuestion = Symbol(\"kQuestion\");\n\n// Private symbols\nvar kAddHistory = Symbol(\"_addHistory\");\nvar kBeforeEdit = Symbol(\"_beforeEdit\");\nvar kDecoder = Symbol(\"_decoder\");\nvar kDeleteLeft = Symbol(\"_deleteLeft\");\nvar kDeleteLineLeft = Symbol(\"_deleteLineLeft\");\nvar kDeleteLineRight = Symbol(\"_deleteLineRight\");\nvar kDeleteRight = Symbol(\"_deleteRight\");\nvar kDeleteWordLeft = Symbol(\"_deleteWordLeft\");\nvar kDeleteWordRight = Symbol(\"_deleteWordRight\");\nvar kGetDisplayPos = Symbol(\"_getDisplayPos\");\nvar kHistoryNext = Symbol(\"_historyNext\");\nvar kHistoryPrev = Symbol(\"_historyPrev\");\nvar kInsertString = Symbol(\"_insertString\");\nvar kLine = Symbol(\"_line\");\nvar kLine_buffer = Symbol(\"_line_buffer\");\nvar kKillRing = Symbol(\"_killRing\");\nvar kKillRingCursor = Symbol(\"_killRingCursor\");\nvar kMoveCursor = Symbol(\"_moveCursor\");\nvar kNormalWrite = Symbol(\"_normalWrite\");\nvar kOldPrompt = Symbol(\"_oldPrompt\");\nvar kOnLine = Symbol(\"_onLine\");\nvar kPreviousKey = Symbol(\"_previousKey\");\nvar kPrompt = Symbol(\"_prompt\");\nvar kPushToKillRing = Symbol(\"_pushToKillRing\");\nvar kPushToUndoStack = Symbol(\"_pushToUndoStack\");\nvar kQuestionCallback = Symbol(\"_questionCallback\");\nvar kRedo = Symbol(\"_redo\");\nvar kRedoStack = Symbol(\"_redoStack\");\nvar kRefreshLine = Symbol(\"_refreshLine\");\nvar kSawKeyPress = Symbol(\"_sawKeyPress\");\nvar kSawReturnAt = Symbol(\"_sawReturnAt\");\nvar kSetRawMode = Symbol(\"_setRawMode\");\nvar kTabComplete = Symbol(\"_tabComplete\");\nvar kTabCompleter = Symbol(\"_tabCompleter\");\nvar kTtyWrite = Symbol(\"_ttyWrite\");\nvar kUndo = Symbol(\"_undo\");\nvar kUndoStack = Symbol(\"_undoStack\");\nvar kWordLeft = Symbol(\"_wordLeft\");\nvar kWordRight = Symbol(\"_wordRight\");\nvar kWriteToOutput = Symbol(\"_writeToOutput\");\nvar kYank = Symbol(\"_yank\");\nvar kYanking = Symbol(\"_yanking\");\nvar kYankPop = Symbol(\"_yankPop\");\n\n// Event symbols\nvar kFirstEventParam = Symbol(\"nodejs.kFirstEventParam\");\n\n// class InterfaceConstructor extends EventEmitter {\n// #onSelfCloseWithTerminal;\n// #onSelfCloseWithoutTerminal;\n\n// #onError;\n// #onData;\n// #onEnd;\n// #onTermEnd;\n// #onKeyPress;\n// #onResize;\n\n// [kSawReturnAt];\n// isCompletionEnabled = true;\n// [kSawKeyPress];\n// [kPreviousKey];\n// escapeCodeTimeout;\n// tabSize;\n\n// line;\n// [kSubstringSearch];\n// output;\n// input;\n// [kUndoStack];\n// [kRedoStack];\n// history;\n// historySize;\n\n// [kKillRing];\n// [kKillRingCursor];\n\n// removeHistoryDuplicates;\n// crlfDelay;\n// completer;\n\n// terminal;\n// [kLineObjectStream];\n\n// cursor;\n// historyIndex;\n\n// constructor(input, output, completer, terminal) {\n//   super();\n\nvar kOnSelfCloseWithTerminal = Symbol(\"_onSelfCloseWithTerminal\");\nvar kOnSelfCloseWithoutTerminal = Symbol(\"_onSelfCloseWithoutTerminal\");\nvar kOnKeyPress = Symbol(\"_onKeyPress\");\nvar kOnError = Symbol(\"_onError\");\nvar kOnData = Symbol(\"_onData\");\nvar kOnEnd = Symbol(\"_onEnd\");\nvar kOnTermEnd = Symbol(\"_onTermEnd\");\nvar kOnResize = Symbol(\"_onResize\");\n\nfunction onSelfCloseWithTerminal() {\n  var input = this.input;\n  var output = this.output;\n\n  if (!input) throw new Error(\"Input not set, invalid state for readline!\");\n\n  input.removeListener(\"keypress\", this[kOnKeyPress]);\n  input.removeListener(\"error\", this[kOnError]);\n  input.removeListener(\"end\", this[kOnTermEnd]);\n  if (output !== null && output !== undefined) {\n    output.removeListener(\"resize\", this[kOnResize]);\n  }\n}\n\nfunction onSelfCloseWithoutTerminal() {\n  var input = this.input;\n  if (!input) throw new Error(\"Input not set, invalid state for readline!\");\n\n  input.removeListener(\"data\", this[kOnData]);\n  input.removeListener(\"error\", this[kOnError]);\n  input.removeListener(\"end\", this[kOnEnd]);\n}\n\nfunction onError(err) {\n  this.emit(\"error\", err);\n}\n\nfunction onData(data) {\n  debug(\"onData\");\n  this[kNormalWrite](data);\n}\n\nfunction onEnd() {\n  debug(\"onEnd\");\n  if (typeof this[kLine_buffer] === \"string\" && this[kLine_buffer].length > 0) {\n    this.emit(\"line\", this[kLine_buffer]);\n  }\n  this.close();\n}\n\nfunction onTermEnd() {\n  debug(\"onTermEnd\");\n  if (typeof this.line === \"string\" && this.line.length > 0) {\n    this.emit(\"line\", this.line);\n  }\n  this.close();\n}\n\nfunction onKeyPress(s, key) {\n  this[kTtyWrite](s, key);\n  if (key && key.sequence) {\n    // If the keySeq is half of a surrogate pair\n    // (>= 0xd800 and <= 0xdfff), refresh the line so\n    // the character is displayed appropriately.\n    var ch = StringPrototypeCodePointAt.call(key.sequence, 0);\n    if (ch >= 0xd800 && ch <= 0xdfff) this[kRefreshLine]();\n  }\n}\n\nfunction onResize() {\n  this[kRefreshLine]();\n}\n\nfunction InterfaceConstructor(input, output, completer, terminal) {\n  if (!(this instanceof InterfaceConstructor)) {\n    return new InterfaceConstructor(input, output, completer, terminal);\n  }\n\n  EventEmitter.call(this);\n\n  this[kOnSelfCloseWithoutTerminal] = onSelfCloseWithoutTerminal.bind(this);\n  this[kOnSelfCloseWithTerminal] = onSelfCloseWithTerminal.bind(this);\n\n  this[kOnError] = onError.bind(this);\n  this[kOnData] = onData.bind(this);\n  this[kOnEnd] = onEnd.bind(this);\n  this[kOnTermEnd] = onTermEnd.bind(this);\n  this[kOnKeyPress] = onKeyPress.bind(this);\n  this[kOnResize] = onResize.bind(this);\n\n  this[kSawReturnAt] = 0;\n  this.isCompletionEnabled = true;\n  this[kSawKeyPress] = false;\n  this[kPreviousKey] = null;\n  this.escapeCodeTimeout = ESCAPE_CODE_TIMEOUT;\n  this.tabSize = 8;\n\n  var history;\n  var historySize;\n  var removeHistoryDuplicates = false;\n  var crlfDelay;\n  var prompt = \"> \";\n  var signal;\n\n  if (input?.input) {\n    // An options object was given\n    output = input.output;\n    completer = input.completer;\n    terminal = input.terminal;\n    history = input.history;\n    historySize = input.historySize;\n    signal = input.signal;\n\n    var tabSize = input.tabSize;\n    if (tabSize !== undefined) {\n      validateUint32(tabSize, \"tabSize\", true);\n      this.tabSize = tabSize;\n    }\n    removeHistoryDuplicates = input.removeHistoryDuplicates;\n\n    var inputPrompt = input.prompt;\n    if (inputPrompt !== undefined) {\n      prompt = inputPrompt;\n    }\n\n    var inputEscapeCodeTimeout = input.escapeCodeTimeout;\n    if (inputEscapeCodeTimeout !== undefined) {\n      if (NumberIsFinite(inputEscapeCodeTimeout)) {\n        this.escapeCodeTimeout = inputEscapeCodeTimeout;\n      } else {\n        throw new ERR_INVALID_ARG_VALUE(\"input.escapeCodeTimeout\", this.escapeCodeTimeout);\n      }\n    }\n\n    if (signal) {\n      validateAbortSignal(signal, \"options.signal\");\n    }\n\n    crlfDelay = input.crlfDelay;\n    input = input.input;\n  }\n\n  if (completer !== undefined && typeof completer !== \"function\") {\n    throw new ERR_INVALID_ARG_VALUE(\"completer\", completer);\n  }\n\n  if (history === undefined) {\n    history = [];\n  } else {\n    validateArray(history, \"history\");\n  }\n\n  if (historySize === undefined) {\n    historySize = kHistorySize;\n  }\n\n  if (typeof historySize !== \"number\" || NumberIsNaN(historySize) || historySize < 0) {\n    throw new ERR_INVALID_ARG_VALUE(\"historySize\", historySize);\n  }\n\n  // Backwards compat; check the isTTY prop of the output stream\n  //  when `terminal` was not specified\n  if (terminal === undefined && !(output === null || output === undefined)) {\n    terminal = !!output.isTTY;\n  }\n\n  this.line = \"\";\n  this[kSubstringSearch] = null;\n  this.output = output;\n  this.input = input;\n  this[kUndoStack] = [];\n  this[kRedoStack] = [];\n  this.history = history;\n  this.historySize = historySize;\n\n  // The kill ring is a global list of blocks of text that were previously\n  // killed (deleted). If its size exceeds kMaxLengthOfKillRing, the oldest\n  // element will be removed to make room for the latest deletion. With kill\n  // ring, users are able to recall (yank) or cycle (yank pop) among previously\n  // killed texts, quite similar to the behavior of Emacs.\n  this[kKillRing] = [];\n  this[kKillRingCursor] = 0;\n\n  this.removeHistoryDuplicates = !!removeHistoryDuplicates;\n  this.crlfDelay = crlfDelay ? MathMax(kMincrlfDelay, crlfDelay) : kMincrlfDelay;\n  this.completer = completer;\n\n  this.setPrompt(prompt);\n\n  this.terminal = !!terminal;\n\n  this[kLineObjectStream] = undefined;\n\n  input.on(\"error\", this[kOnError]);\n\n  if (!this.terminal) {\n    input.on(\"data\", this[kOnData]);\n    input.on(\"end\", this[kOnEnd]);\n    this.once(\"close\", this[kOnSelfCloseWithoutTerminal]);\n    this[kDecoder] = new StringDecoder(\"utf8\");\n  } else {\n    emitKeypressEvents(input, this);\n\n    // `input` usually refers to stdin\n    input.on(\"keypress\", this[kOnKeyPress]);\n    input.on(\"end\", this[kOnTermEnd]);\n\n    this[kSetRawMode](true);\n    this.terminal = true;\n\n    // Cursor position on the line.\n    this.cursor = 0;\n    this.historyIndex = -1;\n\n    if (output !== null && output !== undefined) output.on(\"resize\", this[kOnResize]);\n\n    this.once(\"close\", this[kOnSelfCloseWithTerminal]);\n  }\n\n  if (signal) {\n    var onAborted = (() => this.close()).bind(this);\n    if (signal.aborted) {\n      process.nextTick(onAborted);\n    } else {\n      signal.addEventListener(\"abort\", onAborted, { once: true });\n      this.once(\"close\", () => signal.removeEventListener(\"abort\", onAborted));\n    }\n  }\n\n  // Current line\n  this.line = \"\";\n\n  input.resume();\n}\n\nObjectSetPrototypeOf(InterfaceConstructor.prototype, EventEmitter.prototype);\nObjectSetPrototypeOf(InterfaceConstructor, EventEmitter);\n\nvar _Interface = class Interface extends InterfaceConstructor {\n  // TODO: Enumerate all the properties of the class\n\n  // eslint-disable-next-line no-useless-constructor\n  constructor(input, output, completer, terminal) {\n    super(input, output, completer, terminal);\n  }\n  get columns() {\n    var output = this.output;\n    if (output && output.columns) return output.columns;\n    return Infinity;\n  }\n\n  /**\n   * Sets the prompt written to the output.\n   * @param {string} prompt\n   * @returns {void}\n   */\n  setPrompt(prompt) {\n    this[kPrompt] = prompt;\n  }\n\n  /**\n   * Returns the current prompt used by `rl.prompt()`.\n   * @returns {string}\n   */\n  getPrompt() {\n    return this[kPrompt];\n  }\n\n  [kSetRawMode](mode) {\n    var input = this.input;\n    var { setRawMode, wasInRawMode } = input;\n\n    // TODO: Make this work, for now just stub this and print debug\n    debug(\"setRawMode\", mode, \"set!\");\n    // if (typeof setRawMode === \"function\") {\n    //   setRawMode(mode);\n    // }\n\n    return wasInRawMode;\n  }\n\n  /**\n   * Writes the configured `prompt` to a new line in `output`.\n   * @param {boolean} [preserveCursor]\n   * @returns {void}\n   */\n  prompt(preserveCursor) {\n    if (this.paused) this.resume();\n    if (this.terminal && process.env.TERM !== \"dumb\") {\n      if (!preserveCursor) this.cursor = 0;\n      this[kRefreshLine]();\n    } else {\n      this[kWriteToOutput](this[kPrompt]);\n    }\n  }\n\n  [kQuestion](query, cb) {\n    if (this.closed) {\n      throw new ERR_USE_AFTER_CLOSE(\"readline\");\n    }\n    if (this[kQuestionCallback]) {\n      this.prompt();\n    } else {\n      this[kOldPrompt] = this[kPrompt];\n      this.setPrompt(query);\n      this[kQuestionCallback] = cb;\n      this.prompt();\n    }\n  }\n\n  [kOnLine](line) {\n    if (this[kQuestionCallback]) {\n      var cb = this[kQuestionCallback];\n      this[kQuestionCallback] = null;\n      this.setPrompt(this[kOldPrompt]);\n      cb(line);\n    } else {\n      this.emit(\"line\", line);\n    }\n  }\n\n  [kBeforeEdit](oldText, oldCursor) {\n    this[kPushToUndoStack](oldText, oldCursor);\n  }\n\n  [kQuestionCancel]() {\n    if (this[kQuestionCallback]) {\n      this[kQuestionCallback] = null;\n      this.setPrompt(this[kOldPrompt]);\n      this.clearLine();\n    }\n  }\n\n  [kWriteToOutput](stringToWrite) {\n    validateString(stringToWrite, \"stringToWrite\");\n\n    if (this.output !== null && this.output !== undefined) {\n      this.output.write(stringToWrite);\n    }\n  }\n\n  [kAddHistory]() {\n    if (this.line.length === 0) return \"\";\n\n    // If the history is disabled then return the line\n    if (this.historySize === 0) return this.line;\n\n    // If the trimmed line is empty then return the line\n    if (StringPrototypeTrim.call(this.line).length === 0) return this.line;\n\n    if (this.history.length === 0 || this.history[0] !== this.line) {\n      if (this.removeHistoryDuplicates) {\n        // Remove older history line if identical to new one\n        var dupIndex = ArrayPrototypeIndexOf.call(this.history, this.line);\n        if (dupIndex !== -1) ArrayPrototypeSplice.call(this.history, dupIndex, 1);\n      }\n\n      ArrayPrototypeUnshift.call(this.history, this.line);\n\n      // Only store so many\n      if (this.history.length > this.historySize) ArrayPrototypePop.call(this.history);\n    }\n\n    this.historyIndex = -1;\n\n    // The listener could change the history object, possibly\n    // to remove the last added entry if it is sensitive and should\n    // not be persisted in the history, like a password\n    var line = this.history[0];\n\n    // Emit history event to notify listeners of update\n    this.emit(\"history\", this.history);\n\n    return line;\n  }\n\n  [kRefreshLine]() {\n    // line length\n    var line = this[kPrompt] + this.line;\n    var dispPos = this[kGetDisplayPos](line);\n    var lineCols = dispPos.cols;\n    var lineRows = dispPos.rows;\n\n    // cursor position\n    var cursorPos = this.getCursorPos();\n\n    // First move to the bottom of the current line, based on cursor pos\n    var prevRows = this.prevRows || 0;\n    if (prevRows > 0) {\n      moveCursor(this.output, 0, -prevRows);\n    }\n\n    // Cursor to left edge.\n    cursorTo(this.output, 0);\n    // erase data\n    clearScreenDown(this.output);\n\n    // Write the prompt and the current buffer content.\n    this[kWriteToOutput](line);\n\n    // Force terminal to allocate a new line\n    if (lineCols === 0) {\n      this[kWriteToOutput](\" \");\n    }\n\n    // Move cursor to original position.\n    cursorTo(this.output, cursorPos.cols);\n\n    var diff = lineRows - cursorPos.rows;\n    if (diff > 0) {\n      moveCursor(this.output, 0, -diff);\n    }\n\n    this.prevRows = cursorPos.rows;\n  }\n\n  /**\n   * Closes the `readline.Interface` instance.\n   * @returns {void}\n   */\n  close() {\n    if (this.closed) return;\n    this.pause();\n    if (this.terminal) {\n      this[kSetRawMode](false);\n    }\n    this.closed = true;\n    this.emit(\"close\");\n  }\n\n  /**\n   * Pauses the `input` stream.\n   * @returns {void | Interface}\n   */\n  pause() {\n    if (this.paused) return;\n    this.input.pause();\n    this.paused = true;\n    this.emit(\"pause\");\n    return this;\n  }\n\n  /**\n   * Resumes the `input` stream if paused.\n   * @returns {void | Interface}\n   */\n  resume() {\n    if (!this.paused) return;\n    this.input.resume();\n    this.paused = false;\n    this.emit(\"resume\");\n    return this;\n  }\n\n  /**\n   * Writes either `data` or a `key` sequence identified by\n   * `key` to the `output`.\n   * @param {string} d\n   * @param {{\n   *   ctrl?: boolean;\n   *   meta?: boolean;\n   *   shift?: boolean;\n   *   name?: string;\n   *   }} [key]\n   * @returns {void}\n   */\n  write(d, key) {\n    if (this.paused) this.resume();\n    if (this.terminal) {\n      this[kTtyWrite](d, key);\n    } else {\n      this[kNormalWrite](d);\n    }\n  }\n\n  [kNormalWrite](b) {\n    if (b === undefined) {\n      return;\n    }\n    var string = this[kDecoder].write(b);\n    if (this[kSawReturnAt] && DateNow() - this[kSawReturnAt] <= this.crlfDelay) {\n      if (StringPrototypeCodePointAt.call(string) === 10) string = StringPrototypeSlice.call(string, 1);\n      this[kSawReturnAt] = 0;\n    }\n\n    // Run test() on the new string chunk, not on the entire line buffer.\n    var newPartContainsEnding = RegExpPrototypeExec.call(lineEnding, string);\n    if (newPartContainsEnding !== null) {\n      if (this[kLine_buffer]) {\n        string = this[kLine_buffer] + string;\n        this[kLine_buffer] = null;\n        newPartContainsEnding = RegExpPrototypeExec.call(lineEnding, string);\n      }\n      this[kSawReturnAt] = StringPrototypeEndsWith.call(string, \"\\r\") ? DateNow() : 0;\n\n      var indexes = [0, newPartContainsEnding.index, lineEnding.lastIndex];\n      var nextMatch;\n      while ((nextMatch = RegExpPrototypeExec.call(lineEnding, string)) !== null) {\n        ArrayPrototypePush.call(indexes, nextMatch.index, lineEnding.lastIndex);\n      }\n      var lastIndex = indexes.length - 1;\n      // Either '' or (conceivably) the unfinished portion of the next line\n      this[kLine_buffer] = StringPrototypeSlice.call(string, indexes[lastIndex]);\n      for (var i = 1; i < lastIndex; i += 2) {\n        this[kOnLine](StringPrototypeSlice.call(string, indexes[i - 1], indexes[i]));\n      }\n    } else if (string) {\n      // No newlines this time, save what we have for next time\n      if (this[kLine_buffer]) {\n        this[kLine_buffer] += string;\n      } else {\n        this[kLine_buffer] = string;\n      }\n    }\n  }\n\n  [kInsertString](c) {\n    this[kBeforeEdit](this.line, this.cursor);\n    if (this.cursor < this.line.length) {\n      var beg = StringPrototypeSlice.call(this.line, 0, this.cursor);\n      var end = StringPrototypeSlice.call(this.line, this.cursor, this.line.length);\n      this.line = beg + c + end;\n      this.cursor += c.length;\n      this[kRefreshLine]();\n    } else {\n      var oldPos = this.getCursorPos();\n      this.line += c;\n      this.cursor += c.length;\n      var newPos = this.getCursorPos();\n\n      if (oldPos.rows < newPos.rows) {\n        this[kRefreshLine]();\n      } else {\n        this[kWriteToOutput](c);\n      }\n    }\n  }\n\n  async [kTabComplete](lastKeypressWasTab) {\n    this.pause();\n    var string = StringPrototypeSlice.call(this.line, 0, this.cursor);\n    var value;\n    try {\n      value = await this.completer(string);\n    } catch (err) {\n      this[kWriteToOutput](`Tab completion error: ${inspect(err)}`);\n      return;\n    } finally {\n      this.resume();\n    }\n    this[kTabCompleter](lastKeypressWasTab, value);\n  }\n\n  [kTabCompleter](lastKeypressWasTab, { 0: completions, 1: completeOn }) {\n    // Result and the text that was completed.\n\n    if (!completions || completions.length === 0) {\n      return;\n    }\n\n    // If there is a common prefix to all matches, then apply that portion.\n    var prefix = commonPrefix(ArrayPrototypeFilter.call(completions, e => e !== \"\"));\n    if (StringPrototypeStartsWith.call(prefix, completeOn) && prefix.length > completeOn.length) {\n      this[kInsertString](StringPrototypeSlice.call(prefix, completeOn.length));\n      return;\n    } else if (!StringPrototypeStartsWith.call(completeOn, prefix)) {\n      this.line =\n        StringPrototypeSlice.call(this.line, 0, this.cursor - completeOn.length) +\n        prefix +\n        StringPrototypeSlice.call(this.line, this.cursor, this.line.length);\n      this.cursor = this.cursor - completeOn.length + prefix.length;\n      this._refreshLine();\n      return;\n    }\n\n    if (!lastKeypressWasTab) {\n      return;\n    }\n\n    this[kBeforeEdit](this.line, this.cursor);\n\n    // Apply/show completions.\n    var completionsWidth = ArrayPrototypeMap.call(completions, e => getStringWidth(e));\n    var width = MathMaxApply(completionsWidth) + 2; // 2 space padding\n    var maxColumns = MathFloor(this.columns / width) || 1;\n    if (maxColumns === Infinity) {\n      maxColumns = 1;\n    }\n    var output = \"\\r\\n\";\n    var lineIndex = 0;\n    var whitespace = 0;\n    for (var i = 0; i < completions.length; i++) {\n      var completion = completions[i];\n      if (completion === \"\" || lineIndex === maxColumns) {\n        output += \"\\r\\n\";\n        lineIndex = 0;\n        whitespace = 0;\n      } else {\n        output += StringPrototypeRepeat.call(\" \", whitespace);\n      }\n      if (completion !== \"\") {\n        output += completion;\n        whitespace = width - completionsWidth[i];\n        lineIndex++;\n      } else {\n        output += \"\\r\\n\";\n      }\n    }\n    if (lineIndex !== 0) {\n      output += \"\\r\\n\\r\\n\";\n    }\n    this[kWriteToOutput](output);\n    this[kRefreshLine]();\n  }\n\n  [kWordLeft]() {\n    if (this.cursor > 0) {\n      // Reverse the string and match a word near beginning\n      // to avoid quadratic time complexity\n      var leading = StringPrototypeSlice.call(this.line, 0, this.cursor);\n      var reversed = ArrayPrototypeJoin.call(ArrayPrototypeReverse.call(ArrayFrom(leading)), \"\");\n      var match = RegExpPrototypeExec.call(/^\\s*(?:[^\\w\\s]+|\\w+)?/, reversed);\n      this[kMoveCursor](-match[0].length);\n    }\n  }\n\n  [kWordRight]() {\n    if (this.cursor < this.line.length) {\n      var trailing = StringPrototypeSlice.call(this.line, this.cursor);\n      var match = RegExpPrototypeExec.call(/^(?:\\s+|[^\\w\\s]+|\\w+)\\s*/, trailing);\n      this[kMoveCursor](match[0].length);\n    }\n  }\n\n  [kDeleteLeft]() {\n    if (this.cursor > 0 && this.line.length > 0) {\n      this[kBeforeEdit](this.line, this.cursor);\n      // The number of UTF-16 units comprising the character to the left\n      var charSize = charLengthLeft(this.line, this.cursor);\n      this.line =\n        StringPrototypeSlice.call(this.line, 0, this.cursor - charSize) +\n        StringPrototypeSlice.call(this.line, this.cursor, this.line.length);\n\n      this.cursor -= charSize;\n      this[kRefreshLine]();\n    }\n  }\n\n  [kDeleteRight]() {\n    if (this.cursor < this.line.length) {\n      this[kBeforeEdit](this.line, this.cursor);\n      // The number of UTF-16 units comprising the character to the left\n      var charSize = charLengthAt(this.line, this.cursor);\n      this.line =\n        StringPrototypeSlice.call(this.line, 0, this.cursor) +\n        StringPrototypeSlice.call(this.line, this.cursor + charSize, this.line.length);\n      this[kRefreshLine]();\n    }\n  }\n\n  [kDeleteWordLeft]() {\n    if (this.cursor > 0) {\n      this[kBeforeEdit](this.line, this.cursor);\n      // Reverse the string and match a word near beginning\n      // to avoid quadratic time complexity\n      var leading = StringPrototypeSlice.call(this.line, 0, this.cursor);\n      var reversed = ArrayPrototypeJoin.call(ArrayPrototypeReverse.call(ArrayFrom(leading)), \"\");\n      var match = RegExpPrototypeExec.call(/^\\s*(?:[^\\w\\s]+|\\w+)?/, reversed);\n      leading = StringPrototypeSlice.call(leading, 0, leading.length - match[0].length);\n      this.line = leading + StringPrototypeSlice.call(this.line, this.cursor, this.line.length);\n      this.cursor = leading.length;\n      this[kRefreshLine]();\n    }\n  }\n\n  [kDeleteWordRight]() {\n    if (this.cursor < this.line.length) {\n      this[kBeforeEdit](this.line, this.cursor);\n      var trailing = StringPrototypeSlice.call(this.line, this.cursor);\n      var match = RegExpPrototypeExec.call(/^(?:\\s+|\\W+|\\w+)\\s*/, trailing);\n      this.line =\n        StringPrototypeSlice.call(this.line, 0, this.cursor) + StringPrototypeSlice.call(trailing, match[0].length);\n      this[kRefreshLine]();\n    }\n  }\n\n  [kDeleteLineLeft]() {\n    this[kBeforeEdit](this.line, this.cursor);\n    var del = StringPrototypeSlice.call(this.line, 0, this.cursor);\n    this.line = StringPrototypeSlice.call(this.line, this.cursor);\n    this.cursor = 0;\n    this[kPushToKillRing](del);\n    this[kRefreshLine]();\n  }\n\n  [kDeleteLineRight]() {\n    this[kBeforeEdit](this.line, this.cursor);\n    var del = StringPrototypeSlice.call(this.line, this.cursor);\n    this.line = StringPrototypeSlice.call(this.line, 0, this.cursor);\n    this[kPushToKillRing](del);\n    this[kRefreshLine]();\n  }\n\n  [kPushToKillRing](del) {\n    if (!del || del === this[kKillRing][0]) return;\n    ArrayPrototypeUnshift.call(this[kKillRing], del);\n    this[kKillRingCursor] = 0;\n    while (this[kKillRing].length > kMaxLengthOfKillRing) ArrayPrototypePop.call(this[kKillRing]);\n  }\n\n  [kYank]() {\n    if (this[kKillRing].length > 0) {\n      this[kYanking] = true;\n      this[kInsertString](this[kKillRing][this[kKillRingCursor]]);\n    }\n  }\n\n  [kYankPop]() {\n    if (!this[kYanking]) {\n      return;\n    }\n    if (this[kKillRing].length > 1) {\n      var lastYank = this[kKillRing][this[kKillRingCursor]];\n      this[kKillRingCursor]++;\n      if (this[kKillRingCursor] >= this[kKillRing].length) {\n        this[kKillRingCursor] = 0;\n      }\n      var currentYank = this[kKillRing][this[kKillRingCursor]];\n      var head = StringPrototypeSlice.call(this.line, 0, this.cursor - lastYank.length);\n      var tail = StringPrototypeSlice.call(this.line, this.cursor);\n      this.line = head + currentYank + tail;\n      this.cursor = head.length + currentYank.length;\n      this[kRefreshLine]();\n    }\n  }\n\n  clearLine() {\n    this[kMoveCursor](+Infinity);\n    this[kWriteToOutput](\"\\r\\n\");\n    this.line = \"\";\n    this.cursor = 0;\n    this.prevRows = 0;\n  }\n\n  [kLine]() {\n    var line = this[kAddHistory]();\n    this[kUndoStack] = [];\n    this[kRedoStack] = [];\n    this.clearLine();\n    this[kOnLine](line);\n  }\n\n  [kPushToUndoStack](text, cursor) {\n    if (ArrayPrototypePush.call(this[kUndoStack], { text, cursor }) > kMaxUndoRedoStackSize) {\n      ArrayPrototypeShift.call(this[kUndoStack]);\n    }\n  }\n\n  [kUndo]() {\n    if (this[kUndoStack].length <= 0) return;\n\n    ArrayPrototypePush.call(this[kRedoStack], {\n      text: this.line,\n      cursor: this.cursor,\n    });\n\n    var entry = ArrayPrototypePop.call(this[kUndoStack]);\n    this.line = entry.text;\n    this.cursor = entry.cursor;\n\n    this[kRefreshLine]();\n  }\n\n  [kRedo]() {\n    if (this[kRedoStack].length <= 0) return;\n\n    ArrayPrototypePush.call(this[kUndoStack], {\n      text: this.line,\n      cursor: this.cursor,\n    });\n\n    var entry = ArrayPrototypePop.call(this[kRedoStack]);\n    this.line = entry.text;\n    this.cursor = entry.cursor;\n\n    this[kRefreshLine]();\n  }\n\n  [kHistoryNext]() {\n    if (this.historyIndex >= 0) {\n      this[kBeforeEdit](this.line, this.cursor);\n      var search = this[kSubstringSearch] || \"\";\n      var index = this.historyIndex - 1;\n      while (\n        index >= 0 &&\n        (!StringPrototypeStartsWith.call(this.history[index], search) || this.line === this.history[index])\n      ) {\n        index--;\n      }\n      if (index === -1) {\n        this.line = search;\n      } else {\n        this.line = this.history[index];\n      }\n      this.historyIndex = index;\n      this.cursor = this.line.length; // Set cursor to end of line.\n      this[kRefreshLine]();\n    }\n  }\n\n  [kHistoryPrev]() {\n    if (this.historyIndex < this.history.length && this.history.length) {\n      this[kBeforeEdit](this.line, this.cursor);\n      var search = this[kSubstringSearch] || \"\";\n      var index = this.historyIndex + 1;\n      while (\n        index < this.history.length &&\n        (!StringPrototypeStartsWith.call(this.history[index], search) || this.line === this.history[index])\n      ) {\n        index++;\n      }\n      if (index === this.history.length) {\n        this.line = search;\n      } else {\n        this.line = this.history[index];\n      }\n      this.historyIndex = index;\n      this.cursor = this.line.length; // Set cursor to end of line.\n      this[kRefreshLine]();\n    }\n  }\n\n  // Returns the last character's display position of the given string\n  [kGetDisplayPos](str) {\n    var offset = 0;\n    var col = this.columns;\n    var rows = 0;\n    str = stripVTControlCharacters(str);\n    for (var char of new SafeStringIterator(str)) {\n      if (char === \"\\n\") {\n        // Rows must be incremented by 1 even if offset = 0 or col = +Infinity.\n        rows += MathCeil(offset / col) || 1;\n        offset = 0;\n        continue;\n      }\n      // Tabs must be aligned by an offset of the tab size.\n      if (char === \"\\t\") {\n        offset += this.tabSize - (offset % this.tabSize);\n        continue;\n      }\n      var width = getStringWidth(char, false /* stripVTControlCharacters */);\n      if (width === 0 || width === 1) {\n        offset += width;\n      } else {\n        // width === 2\n        if ((offset + 1) % col === 0) {\n          offset++;\n        }\n        offset += 2;\n      }\n    }\n    var cols = offset % col;\n    rows += (offset - cols) / col;\n    return { cols, rows };\n  }\n\n  /**\n   * Returns the real position of the cursor in relation\n   * to the input prompt + string.\n   * @returns {{\n   *   rows: number;\n   *   cols: number;\n   * }}\n   */\n  getCursorPos() {\n    var strBeforeCursor = this[kPrompt] + StringPrototypeSlice.call(this.line, 0, this.cursor);\n    return this[kGetDisplayPos](strBeforeCursor);\n  }\n\n  // This function moves cursor dx places to the right\n  // (-dx for left) and refreshes the line if it is needed.\n  [kMoveCursor](dx) {\n    if (dx === 0) {\n      return;\n    }\n    var oldPos = this.getCursorPos();\n    this.cursor += dx;\n\n    // Bounds check\n    if (this.cursor < 0) {\n      this.cursor = 0;\n    } else if (this.cursor > this.line.length) {\n      this.cursor = this.line.length;\n    }\n\n    var newPos = this.getCursorPos();\n\n    // Check if cursor stayed on the line.\n    if (oldPos.rows === newPos.rows) {\n      var diffWidth = newPos.cols - oldPos.cols;\n      moveCursor(this.output, diffWidth, 0);\n    } else {\n      this[kRefreshLine]();\n    }\n  }\n\n  // Handle a write from the tty\n  [kTtyWrite](s, key) {\n    var previousKey = this[kPreviousKey];\n    key = key || kEmptyObject;\n    this[kPreviousKey] = key;\n    var { name: keyName, meta: keyMeta, ctrl: keyCtrl, shift: keyShift, sequence: keySeq } = key;\n\n    if (!keyMeta || keyName !== \"y\") {\n      // Reset yanking state unless we are doing yank pop.\n      this[kYanking] = false;\n    }\n\n    // Activate or deactivate substring search.\n    if ((keyName === \"up\" || keyName === \"down\") && !keyCtrl && !keyMeta && !keyShift) {\n      if (this[kSubstringSearch] === null) {\n        this[kSubstringSearch] = StringPrototypeSlice.call(this.line, 0, this.cursor);\n      }\n    } else if (this[kSubstringSearch] !== null) {\n      this[kSubstringSearch] = null;\n      // Reset the index in case there's no match.\n      if (this.history.length === this.historyIndex) {\n        this.historyIndex = -1;\n      }\n    }\n\n    // Undo & Redo\n    if (typeof keySeq === \"string\") {\n      switch (StringPrototypeCodePointAt.call(keySeq, 0)) {\n        case 0x1f:\n          this[kUndo]();\n          return;\n        case 0x1e:\n          this[kRedo]();\n          return;\n        default:\n          break;\n      }\n    }\n\n    // Ignore escape key, fixes\n    // https://github.com/nodejs/node-v0.x-archive/issues/2876.\n    if (keyName === \"escape\") return;\n\n    if (keyCtrl && keyShift) {\n      /* Control and shift pressed */\n      switch (keyName) {\n        // TODO(BridgeAR): The transmitted escape sequence is `\\b` and that is\n        // identical to <ctrl>-h. It should have a unique escape sequence.\n        case \"backspace\":\n          this[kDeleteLineLeft]();\n          break;\n\n        case \"delete\":\n          this[kDeleteLineRight]();\n          break;\n      }\n    } else if (keyCtrl) {\n      /* Control key pressed */\n\n      switch (keyName) {\n        case \"c\":\n          if (this.listenerCount(\"SIGINT\") > 0) {\n            this.emit(\"SIGINT\");\n          } else {\n            // This readline instance is finished\n            this.close();\n          }\n          break;\n\n        case \"h\": // delete left\n          this[kDeleteLeft]();\n          break;\n\n        case \"d\": // delete right or EOF\n          if (this.cursor === 0 && this.line.length === 0) {\n            // This readline instance is finished\n            this.close();\n          } else if (this.cursor < this.line.length) {\n            this[kDeleteRight]();\n          }\n          break;\n\n        case \"u\": // Delete from current to start of line\n          this[kDeleteLineLeft]();\n          break;\n\n        case \"k\": // Delete from current to end of line\n          this[kDeleteLineRight]();\n          break;\n\n        case \"a\": // Go to the start of the line\n          this[kMoveCursor](-Infinity);\n          break;\n\n        case \"e\": // Go to the end of the line\n          this[kMoveCursor](+Infinity);\n          break;\n\n        case \"b\": // back one character\n          this[kMoveCursor](-charLengthLeft(this.line, this.cursor));\n          break;\n\n        case \"f\": // Forward one character\n          this[kMoveCursor](+charLengthAt(this.line, this.cursor));\n          break;\n\n        case \"l\": // Clear the whole screen\n          cursorTo(this.output, 0, 0);\n          clearScreenDown(this.output);\n          this[kRefreshLine]();\n          break;\n\n        case \"n\": // next history item\n          this[kHistoryNext]();\n          break;\n\n        case \"p\": // Previous history item\n          this[kHistoryPrev]();\n          break;\n\n        case \"y\": // Yank killed string\n          this[kYank]();\n          break;\n\n        case \"z\":\n          if (process.platform === \"win32\") break;\n          if (this.listenerCount(\"SIGTSTP\") > 0) {\n            this.emit(\"SIGTSTP\");\n          } else {\n            process.once(\"SIGCONT\", () => {\n              // Don't raise events if stream has already been abandoned.\n              if (!this.paused) {\n                // Stream must be paused and resumed after SIGCONT to catch\n                // SIGINT, SIGTSTP, and EOF.\n                this.pause();\n                this.emit(\"SIGCONT\");\n              }\n              // Explicitly re-enable \"raw mode\" and move the cursor to\n              // the correct position.\n              // See https://github.com/joyent/node/issues/3295.\n              this[kSetRawMode](true);\n              this[kRefreshLine]();\n            });\n            this[kSetRawMode](false);\n            process.kill(process.pid, \"SIGTSTP\");\n          }\n          break;\n\n        case \"w\": // Delete backwards to a word boundary\n        case \"backspace\":\n          this[kDeleteWordLeft]();\n          break;\n\n        case \"delete\": // Delete forward to a word boundary\n          this[kDeleteWordRight]();\n          break;\n\n        case \"left\":\n          this[kWordLeft]();\n          break;\n\n        case \"right\":\n          this[kWordRight]();\n          break;\n      }\n    } else if (keyMeta) {\n      /* Meta key pressed */\n\n      switch (keyName) {\n        case \"b\": // backward word\n          this[kWordLeft]();\n          break;\n\n        case \"f\": // forward word\n          this[kWordRight]();\n          break;\n\n        case \"d\": // delete forward word\n        case \"delete\":\n          this[kDeleteWordRight]();\n          break;\n\n        case \"backspace\": // Delete backwards to a word boundary\n          this[kDeleteWordLeft]();\n          break;\n\n        case \"y\": // Doing yank pop\n          this[kYankPop]();\n          break;\n      }\n    } else {\n      /* No modifier keys used */\n\n      // \\r bookkeeping is only relevant if a \\n comes right after.\n      if (this[kSawReturnAt] && keyName !== \"enter\") this[kSawReturnAt] = 0;\n\n      switch (keyName) {\n        case \"return\": // Carriage return, i.e. \\r\n          this[kSawReturnAt] = DateNow();\n          this[kLine]();\n          break;\n\n        case \"enter\":\n          // When key interval > crlfDelay\n          if (this[kSawReturnAt] === 0 || DateNow() - this[kSawReturnAt] > this.crlfDelay) {\n            this[kLine]();\n          }\n          this[kSawReturnAt] = 0;\n          break;\n\n        case \"backspace\":\n          this[kDeleteLeft]();\n          break;\n\n        case \"delete\":\n          this[kDeleteRight]();\n          break;\n\n        case \"left\":\n          // Obtain the code point to the left\n          this[kMoveCursor](-charLengthLeft(this.line, this.cursor));\n          break;\n\n        case \"right\":\n          this[kMoveCursor](+charLengthAt(this.line, this.cursor));\n          break;\n\n        case \"home\":\n          this[kMoveCursor](-Infinity);\n          break;\n\n        case \"end\":\n          this[kMoveCursor](+Infinity);\n          break;\n\n        case \"up\":\n          this[kHistoryPrev]();\n          break;\n\n        case \"down\":\n          this[kHistoryNext]();\n          break;\n\n        case \"tab\":\n          // If tab completion enabled, do that...\n          if (typeof this.completer === \"function\" && this.isCompletionEnabled) {\n            var lastKeypressWasTab = previousKey && previousKey.name === \"tab\";\n            this[kTabComplete](lastKeypressWasTab);\n            break;\n          }\n        // falls through\n        default:\n          if (typeof s === \"string\" && s) {\n            var nextMatch = RegExpPrototypeExec.call(lineEnding, s);\n            if (nextMatch !== null) {\n              this[kInsertString](StringPrototypeSlice.call(s, 0, nextMatch.index));\n              var { lastIndex } = lineEnding;\n              while ((nextMatch = RegExpPrototypeExec.call(lineEnding, s)) !== null) {\n                this[kLine]();\n                this[kInsertString](StringPrototypeSlice.call(s, lastIndex, nextMatch.index));\n                ({ lastIndex } = lineEnding);\n              }\n              if (lastIndex === s.length) this[kLine]();\n            } else {\n              this[kInsertString](s);\n            }\n          }\n      }\n    }\n  }\n\n  /**\n   * Creates an `AsyncIterator` object that iterates through\n   * each line in the input stream as a string.\n   * @typedef {{\n   *   [Symbol.asyncIterator]: () => InterfaceAsyncIterator,\n   *   next: () => Promise<string>\n   * }} InterfaceAsyncIterator\n   * @returns {InterfaceAsyncIterator}\n   */\n  [SymbolAsyncIterator]() {\n    if (this[kLineObjectStream] === undefined) {\n      this[kLineObjectStream] = EventEmitter.on(this, \"line\", {\n        close: [\"close\"],\n        highWatermark: 1024,\n        [kFirstEventParam]: true,\n      });\n    }\n    return this[kLineObjectStream];\n  }\n};\n\nfunction Interface(input, output, completer, terminal) {\n  if (!(this instanceof Interface)) {\n    return new Interface(input, output, completer, terminal);\n  }\n\n  if (input?.input && typeof input.completer === \"function\" && input.completer.length !== 2) {\n    var { completer } = input;\n    input.completer = (v, cb) => cb(null, completer(v));\n  } else if (typeof completer === \"function\" && completer.length !== 2) {\n    var realCompleter = completer;\n    completer = (v, cb) => cb(null, realCompleter(v));\n  }\n\n  InterfaceConstructor.call(this, input, output, completer, terminal);\n\n  // TODO: Test this\n  if (process.env.TERM === \"dumb\") {\n    this._ttyWrite = _ttyWriteDumb.bind(this);\n  }\n}\n\nObjectSetPrototypeOf(Interface.prototype, _Interface.prototype);\nObjectSetPrototypeOf(Interface, _Interface);\n\n/**\n * Displays `query` by writing it to the `output`.\n * @param {string} query\n * @param {{ signal?: AbortSignal; }} [options]\n * @param {Function} cb\n * @returns {void}\n */\nInterface.prototype.question = function question(query, options, cb) {\n  cb = typeof options === \"function\" ? options : cb;\n  if (options === null || typeof options !== \"object\") {\n    options = kEmptyObject;\n  }\n\n  var signal = options?.signal;\n  if (signal) {\n    validateAbortSignal(signal, \"options.signal\");\n    if (signal.aborted) {\n      return;\n    }\n\n    var onAbort = () => {\n      this[kQuestionCancel]();\n    };\n    signal.addEventListener(\"abort\", onAbort, { once: true });\n    var cleanup = () => {\n      signal.removeEventListener(\"abort\", onAbort);\n    };\n    var originalCb = cb;\n    cb =\n      typeof cb === \"function\"\n        ? answer => {\n            cleanup();\n            return originalCb(answer);\n          }\n        : cleanup;\n  }\n\n  if (typeof cb === \"function\") {\n    this[kQuestion](query, cb);\n  }\n};\n\nInterface.prototype.question[promisify.custom] = function question(query, options) {\n  if (options === null || typeof options !== \"object\") {\n    options = kEmptyObject;\n  }\n\n  var signal = options?.signal;\n\n  if (signal && signal.aborted) {\n    return PromiseReject(new AbortError(undefined, { cause: signal.reason }));\n  }\n\n  return new Promise((resolve, reject) => {\n    var cb = resolve;\n    if (signal) {\n      var onAbort = () => {\n        reject(new AbortError(undefined, { cause: signal.reason }));\n      };\n      signal.addEventListener(\"abort\", onAbort, { once: true });\n      cb = answer => {\n        signal.removeEventListener(\"abort\", onAbort);\n        resolve(answer);\n      };\n    }\n    this.question(query, options, cb);\n  });\n};\n\n/**\n * Creates a new `readline.Interface` instance.\n * @param {Readable | {\n *   input: Readable;\n *   output: Writable;\n *   completer?: Function;\n *   terminal?: boolean;\n *   history?: string[];\n *   historySize?: number;\n *   removeHistoryDuplicates?: boolean;\n *   prompt?: string;\n *   crlfDelay?: number;\n *   escapeCodeTimeout?: number;\n *   tabSize?: number;\n *   signal?: AbortSignal;\n *   }} input\n * @param {Writable} [output]\n * @param {Function} [completer]\n * @param {boolean} [terminal]\n * @returns {Interface}\n */\nfunction createInterface(input, output, completer, terminal) {\n  return new Interface(input, output, completer, terminal);\n}\n\nObjectDefineProperties(Interface.prototype, {\n  // Redirect internal prototype methods to the underscore notation for backward\n  // compatibility.\n  [kSetRawMode]: {\n    __proto__: null,\n    get() {\n      return this._setRawMode;\n    },\n  },\n  [kOnLine]: {\n    __proto__: null,\n    get() {\n      return this._onLine;\n    },\n  },\n  [kWriteToOutput]: {\n    __proto__: null,\n    get() {\n      return this._writeToOutput;\n    },\n  },\n  [kAddHistory]: {\n    __proto__: null,\n    get() {\n      return this._addHistory;\n    },\n  },\n  [kRefreshLine]: {\n    __proto__: null,\n    get() {\n      return this._refreshLine;\n    },\n  },\n  [kNormalWrite]: {\n    __proto__: null,\n    get() {\n      return this._normalWrite;\n    },\n  },\n  [kInsertString]: {\n    __proto__: null,\n    get() {\n      return this._insertString;\n    },\n  },\n  [kTabComplete]: {\n    __proto__: null,\n    get() {\n      return this._tabComplete;\n    },\n  },\n  [kWordLeft]: {\n    __proto__: null,\n    get() {\n      return this._wordLeft;\n    },\n  },\n  [kWordRight]: {\n    __proto__: null,\n    get() {\n      return this._wordRight;\n    },\n  },\n  [kDeleteLeft]: {\n    __proto__: null,\n    get() {\n      return this._deleteLeft;\n    },\n  },\n  [kDeleteRight]: {\n    __proto__: null,\n    get() {\n      return this._deleteRight;\n    },\n  },\n  [kDeleteWordLeft]: {\n    __proto__: null,\n    get() {\n      return this._deleteWordLeft;\n    },\n  },\n  [kDeleteWordRight]: {\n    __proto__: null,\n    get() {\n      return this._deleteWordRight;\n    },\n  },\n  [kDeleteLineLeft]: {\n    __proto__: null,\n    get() {\n      return this._deleteLineLeft;\n    },\n  },\n  [kDeleteLineRight]: {\n    __proto__: null,\n    get() {\n      return this._deleteLineRight;\n    },\n  },\n  [kLine]: {\n    __proto__: null,\n    get() {\n      return this._line;\n    },\n  },\n  [kHistoryNext]: {\n    __proto__: null,\n    get() {\n      return this._historyNext;\n    },\n  },\n  [kHistoryPrev]: {\n    __proto__: null,\n    get() {\n      return this._historyPrev;\n    },\n  },\n  [kGetDisplayPos]: {\n    __proto__: null,\n    get() {\n      return this._getDisplayPos;\n    },\n  },\n  [kMoveCursor]: {\n    __proto__: null,\n    get() {\n      return this._moveCursor;\n    },\n  },\n  [kTtyWrite]: {\n    __proto__: null,\n    get() {\n      return this._ttyWrite;\n    },\n  },\n\n  // Defining proxies for the internal instance properties for backward\n  // compatibility.\n  _decoder: {\n    __proto__: null,\n    get() {\n      return this[kDecoder];\n    },\n    set(value) {\n      this[kDecoder] = value;\n    },\n  },\n  _line_buffer: {\n    __proto__: null,\n    get() {\n      return this[kLine_buffer];\n    },\n    set(value) {\n      this[kLine_buffer] = value;\n    },\n  },\n  _oldPrompt: {\n    __proto__: null,\n    get() {\n      return this[kOldPrompt];\n    },\n    set(value) {\n      this[kOldPrompt] = value;\n    },\n  },\n  _previousKey: {\n    __proto__: null,\n    get() {\n      return this[kPreviousKey];\n    },\n    set(value) {\n      this[kPreviousKey] = value;\n    },\n  },\n  _prompt: {\n    __proto__: null,\n    get() {\n      return this[kPrompt];\n    },\n    set(value) {\n      this[kPrompt] = value;\n    },\n  },\n  _questionCallback: {\n    __proto__: null,\n    get() {\n      return this[kQuestionCallback];\n    },\n    set(value) {\n      this[kQuestionCallback] = value;\n    },\n  },\n  _sawKeyPress: {\n    __proto__: null,\n    get() {\n      return this[kSawKeyPress];\n    },\n    set(value) {\n      this[kSawKeyPress] = value;\n    },\n  },\n  _sawReturnAt: {\n    __proto__: null,\n    get() {\n      return this[kSawReturnAt];\n    },\n    set(value) {\n      this[kSawReturnAt] = value;\n    },\n  },\n});\n\n// Make internal methods public for backward compatibility.\nInterface.prototype._setRawMode = _Interface.prototype[kSetRawMode];\nInterface.prototype._onLine = _Interface.prototype[kOnLine];\nInterface.prototype._writeToOutput = _Interface.prototype[kWriteToOutput];\nInterface.prototype._addHistory = _Interface.prototype[kAddHistory];\nInterface.prototype._refreshLine = _Interface.prototype[kRefreshLine];\nInterface.prototype._normalWrite = _Interface.prototype[kNormalWrite];\nInterface.prototype._insertString = _Interface.prototype[kInsertString];\nInterface.prototype._tabComplete = function (lastKeypressWasTab) {\n  // Overriding parent method because `this.completer` in the legacy\n  // implementation takes a callback instead of being an async function.\n  this.pause();\n  var string = StringPrototypeSlice.call(this.line, 0, this.cursor);\n  this.completer(string, (err, value) => {\n    this.resume();\n\n    if (err) {\n      this._writeToOutput(`Tab completion error: ${inspect(err)}`);\n      return;\n    }\n\n    this[kTabCompleter](lastKeypressWasTab, value);\n  });\n};\nInterface.prototype._wordLeft = _Interface.prototype[kWordLeft];\nInterface.prototype._wordRight = _Interface.prototype[kWordRight];\nInterface.prototype._deleteLeft = _Interface.prototype[kDeleteLeft];\nInterface.prototype._deleteRight = _Interface.prototype[kDeleteRight];\nInterface.prototype._deleteWordLeft = _Interface.prototype[kDeleteWordLeft];\nInterface.prototype._deleteWordRight = _Interface.prototype[kDeleteWordRight];\nInterface.prototype._deleteLineLeft = _Interface.prototype[kDeleteLineLeft];\nInterface.prototype._deleteLineRight = _Interface.prototype[kDeleteLineRight];\nInterface.prototype._line = _Interface.prototype[kLine];\nInterface.prototype._historyNext = _Interface.prototype[kHistoryNext];\nInterface.prototype._historyPrev = _Interface.prototype[kHistoryPrev];\nInterface.prototype._getDisplayPos = _Interface.prototype[kGetDisplayPos];\nInterface.prototype._getCursorPos = _Interface.prototype.getCursorPos;\nInterface.prototype._moveCursor = _Interface.prototype[kMoveCursor];\nInterface.prototype._ttyWrite = _Interface.prototype[kTtyWrite];\n\nfunction _ttyWriteDumb(s, key) {\n  key = key || kEmptyObject;\n\n  if (key.name === \"escape\") return;\n\n  if (this[kSawReturnAt] && key.name !== \"enter\") this[kSawReturnAt] = 0;\n\n  if (keyCtrl) {\n    if (key.name === \"c\") {\n      if (this.listenerCount(\"SIGINT\") > 0) {\n        this.emit(\"SIGINT\");\n      } else {\n        // This readline instance is finished\n        this.close();\n      }\n\n      return;\n    } else if (key.name === \"d\") {\n      this.close();\n      return;\n    }\n  }\n\n  switch (key.name) {\n    case \"return\": // Carriage return, i.e. \\r\n      this[kSawReturnAt] = DateNow();\n      this._line();\n      break;\n\n    case \"enter\":\n      // When key interval > crlfDelay\n      if (this[kSawReturnAt] === 0 || DateNow() - this[kSawReturnAt] > this.crlfDelay) {\n        this._line();\n      }\n      this[kSawReturnAt] = 0;\n      break;\n\n    default:\n      if (typeof s === \"string\" && s) {\n        this.line += s;\n        this.cursor += s.length;\n        this._writeToOutput(s);\n      }\n  }\n}\n\nclass Readline {\n  #autoCommit = false;\n  #stream;\n  #todo = [];\n\n  constructor(stream, options = undefined) {\n    isWritable ??= import.meta.require(\"node:stream\").isWritable;\n    if (!isWritable(stream)) throw new ERR_INVALID_ARG_TYPE(\"stream\", \"Writable\", stream);\n    this.#stream = stream;\n    if (options?.autoCommit != null) {\n      validateBoolean(options.autoCommit, \"options.autoCommit\");\n      this.#autoCommit = options.autoCommit;\n    }\n  }\n\n  /**\n   * Moves the cursor to the x and y coordinate on the given stream.\n   * @param {integer} x\n   * @param {integer} [y]\n   * @returns {Readline} this\n   */\n  cursorTo(x, y = undefined) {\n    validateInteger(x, \"x\");\n    if (y != null) validateInteger(y, \"y\");\n\n    var data = y == null ? CSI`${x + 1}G` : CSI`${y + 1};${x + 1}H`;\n    if (this.#autoCommit) process.nextTick(() => this.#stream.write(data));\n    else ArrayPrototypePush.call(this.#todo, data);\n\n    return this;\n  }\n\n  /**\n   * Moves the cursor relative to its current location.\n   * @param {integer} dx\n   * @param {integer} dy\n   * @returns {Readline} this\n   */\n  moveCursor(dx, dy) {\n    if (dx || dy) {\n      validateInteger(dx, \"dx\");\n      validateInteger(dy, \"dy\");\n\n      var data = \"\";\n\n      if (dx < 0) {\n        data += CSI`${-dx}D`;\n      } else if (dx > 0) {\n        data += CSI`${dx}C`;\n      }\n\n      if (dy < 0) {\n        data += CSI`${-dy}A`;\n      } else if (dy > 0) {\n        data += CSI`${dy}B`;\n      }\n      if (this.#autoCommit) process.nextTick(() => this.#stream.write(data));\n      else ArrayPrototypePush.call(this.#todo, data);\n    }\n    return this;\n  }\n\n  /**\n   * Clears the current line the cursor is on.\n   * @param {-1|0|1} dir Direction to clear:\n   *   -1 for left of the cursor\n   *   +1 for right of the cursor\n   *    0 for the entire line\n   * @returns {Readline} this\n   */\n  clearLine(dir) {\n    validateInteger(dir, \"dir\", -1, 1);\n\n    var data = dir < 0 ? kClearToLineBeginning : dir > 0 ? kClearToLineEnd : kClearLine;\n    if (this.#autoCommit) process.nextTick(() => this.#stream.write(data));\n    else ArrayPrototypePush.call(this.#todo, data);\n    return this;\n  }\n\n  /**\n   * Clears the screen from the current position of the cursor down.\n   * @returns {Readline} this\n   */\n  clearScreenDown() {\n    if (this.#autoCommit) {\n      process.nextTick(() => this.#stream.write(kClearScreenDown));\n    } else {\n      ArrayPrototypePush.call(this.#todo, kClearScreenDown);\n    }\n    return this;\n  }\n\n  /**\n   * Sends all the pending actions to the associated `stream` and clears the\n   * internal list of pending actions.\n   * @returns {Promise<void>} Resolves when all pending actions have been\n   * flushed to the associated `stream`.\n   */\n  commit() {\n    return new Promise(resolve => {\n      this.#stream.write(ArrayPrototypeJoin.call(this.#todo, \"\"), resolve);\n      this.#todo = [];\n    });\n  }\n\n  /**\n   * Clears the internal list of pending actions without sending it to the\n   * associated `stream`.\n   * @returns {Readline} this\n   */\n  rollback() {\n    this.#todo = [];\n    return this;\n  }\n}\n\nvar PromisesInterface = class Interface extends _Interface {\n  // eslint-disable-next-line no-useless-constructor\n  constructor(input, output, completer, terminal) {\n    super(input, output, completer, terminal);\n  }\n  question(query, options = kEmptyObject) {\n    var signal = options?.signal;\n    if (signal) {\n      validateAbortSignal(signal, \"options.signal\");\n      if (signal.aborted) {\n        return PromiseReject(new AbortError(undefined, { cause: signal.reason }));\n      }\n    }\n    return new Promise((resolve, reject) => {\n      var cb = resolve;\n      if (options?.signal) {\n        var onAbort = () => {\n          this[kQuestionCancel]();\n          reject(new AbortError(undefined, { cause: signal.reason }));\n        };\n        signal.addEventListener(\"abort\", onAbort, { once: true });\n        cb = answer => {\n          signal.removeEventListener(\"abort\", onAbort);\n          resolve(answer);\n        };\n      }\n      this[kQuestion](query, cb);\n    });\n  }\n};\n\n// ----------------------------------------------------------------------------\n// Exports\n// ----------------------------------------------------------------------------\nexport var Interface = Interface;\nexport var clearLine = clearLine;\nexport var clearScreenDown = clearScreenDown;\nexport var createInterface = createInterface;\nexport var cursorTo = cursorTo;\nexport var emitKeypressEvents = emitKeypressEvents;\nexport var moveCursor = moveCursor;\nexport var promises = {\n  Readline,\n  Interface: PromisesInterface,\n  createInterface(input, output, completer, terminal) {\n    return new PromisesInterface(input, output, completer, terminal);\n  },\n};\n\nexport default {\n  Interface,\n  clearLine,\n  clearScreenDown,\n  createInterface,\n  cursorTo,\n  emitKeypressEvents,\n  moveCursor,\n  promises,\n\n  [SymbolFor(\"__BUN_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED__\")]: {\n    CSI,\n    utils: {\n      getStringWidth,\n      stripVTControlCharacters,\n    },\n  },\n  [SymbolFor(\"CommonJS\")]: 0,\n};\n",
  "// Hardcoded module \"node:readline\"\n// Attribution: Some parts of of this module are derived from code originating from the Node.js\n// readline module which is licensed under an MIT license:\n//\n// Copyright Node.js contributors. All rights reserved.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to\n// deal in the Software without restriction, including without limitation the\n// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n// sell copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n// IN THE SOFTWARE.\n\n// ----------------------------------------------------------------------------\n// Section: Imports\n// ----------------------------------------------------------------------------\nvar { Array, RegExp, String, Bun } = import.meta.primordials;\nvar EventEmitter = import.meta.require(\"node:events\");\nvar { clearTimeout, setTimeout } = import.meta.require(\"timers\");\nvar { StringDecoder } = import.meta.require(\"string_decoder\");\nvar isWritable;\n\nvar { inspect } = Bun;\nvar debug = process.env.BUN_JS_DEBUG ? console.log : () => {};\n\n// ----------------------------------------------------------------------------\n// Section: Preamble\n// ----------------------------------------------------------------------------\n\nvar SymbolAsyncIterator = Symbol.asyncIterator;\nvar SymbolIterator = Symbol.iterator;\nvar SymbolFor = Symbol.for;\nvar SymbolReplace = Symbol.replace;\nvar ArrayFrom = Array.from;\nvar ArrayIsArray = Array.isArray;\nvar ArrayPrototypeFilter = Array.prototype.filter;\nvar ArrayPrototypeSort = Array.prototype.sort;\nvar ArrayPrototypeIndexOf = Array.prototype.indexOf;\nvar ArrayPrototypeJoin = Array.prototype.join;\nvar ArrayPrototypeMap = Array.prototype.map;\nvar ArrayPrototypePop = Array.prototype.pop;\nvar ArrayPrototypePush = Array.prototype.push;\nvar ArrayPrototypeSlice = Array.prototype.slice;\nvar ArrayPrototypeSplice = Array.prototype.splice;\nvar ArrayPrototypeReverse = Array.prototype.reverse;\nvar ArrayPrototypeShift = Array.prototype.shift;\nvar ArrayPrototypeUnshift = Array.prototype.unshift;\nvar RegExpPrototypeExec = RegExp.prototype.exec;\nvar RegExpPrototypeSymbolReplace = RegExp.prototype[SymbolReplace];\nvar StringFromCharCode = String.fromCharCode;\nvar StringPrototypeCharCodeAt = String.prototype.charCodeAt;\nvar StringPrototypeCodePointAt = String.prototype.codePointAt;\nvar StringPrototypeSlice = String.prototype.slice;\nvar StringPrototypeToLowerCase = String.prototype.toLowerCase;\nvar StringPrototypeEndsWith = String.prototype.endsWith;\nvar StringPrototypeRepeat = String.prototype.repeat;\nvar StringPrototypeStartsWith = String.prototype.startsWith;\nvar StringPrototypeTrim = String.prototype.trim;\nvar StringPrototypeNormalize = String.prototype.normalize;\nvar NumberIsNaN = Number.isNaN;\nvar NumberIsFinite = Number.isFinite;\nvar NumberIsInteger = Number.isInteger;\nvar NumberMAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER;\nvar NumberMIN_SAFE_INTEGER = Number.MIN_SAFE_INTEGER;\nvar MathCeil = Math.ceil;\nvar MathFloor = Math.floor;\nvar MathMax = Math.max;\nvar MathMaxApply = Math.max.apply;\nvar DateNow = Date.now;\nvar FunctionPrototype = Function.prototype;\nvar StringPrototype = String.prototype;\nvar StringPrototypeSymbolIterator = StringPrototype[SymbolIterator];\nvar StringIteratorPrototypeNext = StringPrototypeSymbolIterator.call(\"\").next;\nvar ObjectSetPrototypeOf = Object.setPrototypeOf;\nvar ObjectDefineProperty = Object.defineProperty;\nvar ObjectDefineProperties = Object.defineProperties;\nvar ObjectFreeze = Object.freeze;\nvar ObjectAssign = Object.assign;\nvar ObjectCreate = Object.create;\nvar ObjectKeys = Object.keys;\nvar ObjectSeal = Object.seal;\n\nvar createSafeIterator = (factory, next) => {\n  class SafeIterator {\n    #iterator;\n    constructor(iterable) {\n      this.#iterator = factory.call(iterable);\n    }\n    next() {\n      return next.call(this.#iterator);\n    }\n    [SymbolIterator]() {\n      return this;\n    }\n  }\n  ObjectSetPrototypeOf(SafeIterator.prototype, null);\n  ObjectFreeze(SafeIterator.prototype);\n  ObjectFreeze(SafeIterator);\n  return SafeIterator;\n};\n\nvar SafeStringIterator = createSafeIterator(StringPrototypeSymbolIterator, StringIteratorPrototypeNext);\n\n// ----------------------------------------------------------------------------\n// Section: \"Internal\" modules\n// ----------------------------------------------------------------------------\n\n/**\n * Returns true if the character represented by a given\n * Unicode code point is full-width. Otherwise returns false.\n */\nvar isFullWidthCodePoint = code => {\n  // Code points are partially derived from:\n  // https://www.unicode.org/Public/UNIDATA/EastAsianWidth.txt\n  return (\n    code >= 0x1100 &&\n    (code <= 0x115f || // Hangul Jamo\n      code === 0x2329 || // LEFT-POINTING ANGLE BRACKET\n      code === 0x232a || // RIGHT-POINTING ANGLE BRACKET\n      // CJK Radicals Supplement .. Enclosed CJK Letters and Months\n      (code >= 0x2e80 && code <= 0x3247 && code !== 0x303f) ||\n      // Enclosed CJK Letters and Months .. CJK Unified Ideographs Extension A\n      (code >= 0x3250 && code <= 0x4dbf) ||\n      // CJK Unified Ideographs .. Yi Radicals\n      (code >= 0x4e00 && code <= 0xa4c6) ||\n      // Hangul Jamo Extended-A\n      (code >= 0xa960 && code <= 0xa97c) ||\n      // Hangul Syllables\n      (code >= 0xac00 && code <= 0xd7a3) ||\n      // CJK Compatibility Ideographs\n      (code >= 0xf900 && code <= 0xfaff) ||\n      // Vertical Forms\n      (code >= 0xfe10 && code <= 0xfe19) ||\n      // CJK Compatibility Forms .. Small Form Variants\n      (code >= 0xfe30 && code <= 0xfe6b) ||\n      // Halfwidth and Fullwidth Forms\n      (code >= 0xff01 && code <= 0xff60) ||\n      (code >= 0xffe0 && code <= 0xffe6) ||\n      // Kana Supplement\n      (code >= 0x1b000 && code <= 0x1b001) ||\n      // Enclosed Ideographic Supplement\n      (code >= 0x1f200 && code <= 0x1f251) ||\n      // Miscellaneous Symbols and Pictographs 0x1f300 - 0x1f5ff\n      // Emoticons 0x1f600 - 0x1f64f\n      (code >= 0x1f300 && code <= 0x1f64f) ||\n      // CJK Unified Ideographs Extension B .. Tertiary Ideographic Plane\n      (code >= 0x20000 && code <= 0x3fffd))\n  );\n};\n\nvar isZeroWidthCodePoint = code => {\n  return (\n    code <= 0x1f || // C0 control codes\n    (code >= 0x7f && code <= 0x9f) || // C1 control codes\n    (code >= 0x300 && code <= 0x36f) || // Combining Diacritical Marks\n    (code >= 0x200b && code <= 0x200f) || // Modifying Invisible Characters\n    // Combining Diacritical Marks for Symbols\n    (code >= 0x20d0 && code <= 0x20ff) ||\n    (code >= 0xfe00 && code <= 0xfe0f) || // Variation Selectors\n    (code >= 0xfe20 && code <= 0xfe2f) || // Combining Half Marks\n    (code >= 0xe0100 && code <= 0xe01ef)\n  ); // Variation Selectors\n};\n\n/**\n * Returns the number of columns required to display the given string.\n */\nvar getStringWidth = function getStringWidth(str, removeControlChars = true) {\n  var width = 0;\n\n  if (removeControlChars) str = stripVTControlCharacters(str);\n  str = StringPrototypeNormalize.call(str, \"NFC\");\n  for (var char of new SafeStringIterator(str)) {\n    var code = StringPrototypeCodePointAt.call(char, 0);\n    if (isFullWidthCodePoint(code)) {\n      width += 2;\n    } else if (!isZeroWidthCodePoint(code)) {\n      width++;\n    }\n  }\n\n  return width;\n};\n\n// Regex used for ansi escape code splitting\n// Adopted from https://github.com/chalk/ansi-regex/blob/HEAD/index.js\n// License: MIT, authors: @sindresorhus, Qix-, arjunmehta and LitoMore\n// Matches all ansi escape code sequences in a string\nvar ansiPattern =\n  \"[\\\\u001B\\\\u009B][[\\\\]()#;?]*\" +\n  \"(?:(?:(?:(?:;[-a-zA-Z\\\\d\\\\/#&.:=?%@~_]+)*\" +\n  \"|[a-zA-Z\\\\d]+(?:;[-a-zA-Z\\\\d\\\\/#&.:=?%@~_]*)*)?\\\\u0007)\" +\n  \"|(?:(?:\\\\d{1,4}(?:;\\\\d{0,4})*)?[\\\\dA-PR-TZcf-ntqry=><~]))\";\nvar ansi = new RegExp(ansiPattern, \"g\");\n\n/**\n * Remove all VT control characters. Use to estimate displayed string width.\n */\nfunction stripVTControlCharacters(str) {\n  validateString(str, \"str\");\n  return RegExpPrototypeSymbolReplace.call(ansi, str, \"\");\n}\n\n// Promisify\n\nvar kCustomPromisifiedSymbol = SymbolFor(\"nodejs.util.promisify.custom\");\nvar kCustomPromisifyArgsSymbol = Symbol(\"customPromisifyArgs\");\n\nfunction promisify(original) {\n  validateFunction(original, \"original\");\n\n  if (original[kCustomPromisifiedSymbol]) {\n    var fn = original[kCustomPromisifiedSymbol];\n\n    validateFunction(fn, \"util.promisify.custom\");\n\n    return ObjectDefineProperty(fn, kCustomPromisifiedSymbol, {\n      __proto__: null,\n      value: fn,\n      enumerable: false,\n      writable: false,\n      configurable: true,\n    });\n  }\n\n  // Names to create an object from in case the callback receives multiple\n  // arguments, e.g. ['bytesRead', 'buffer'] for fs.read.\n  var argumentNames = original[kCustomPromisifyArgsSymbol];\n\n  function fn(...args) {\n    return new Promise((resolve, reject) => {\n      ArrayPrototypePush.call(args, (err, ...values) => {\n        if (err) {\n          return reject(err);\n        }\n        if (argumentNames !== undefined && values.length > 1) {\n          var obj = {};\n          for (var i = 0; i < argumentNames.length; i++) obj[argumentNames[i]] = values[i];\n          resolve(obj);\n        } else {\n          resolve(values[0]);\n        }\n      });\n      ReflectApply(original, this, args);\n    });\n  }\n\n  ObjectSetPrototypeOf(fn, ObjectGetPrototypeOf(original));\n\n  ObjectDefineProperty(fn, kCustomPromisifiedSymbol, {\n    __proto__: null,\n    value: fn,\n    enumerable: false,\n    writable: false,\n    configurable: true,\n  });\n\n  var descriptors = ObjectGetOwnPropertyDescriptors(original);\n  var propertiesValues = ObjectValues(descriptors);\n  for (var i = 0; i < propertiesValues.length; i++) {\n    // We want to use null-prototype objects to not rely on globally mutable\n    // %Object.prototype%.\n    ObjectSetPrototypeOf(propertiesValues[i], null);\n  }\n  return ObjectDefineProperties(fn, descriptors);\n}\n\npromisify.custom = kCustomPromisifiedSymbol;\n\n// Constants\n\nvar kUTF16SurrogateThreshold = 0x10000; // 2 ** 16\nvar kEscape = \"\\x1b\";\nvar kSubstringSearch = Symbol(\"kSubstringSearch\");\n\nvar kIsNodeError = Symbol(\"kIsNodeError\");\n\n// Errors\nvar errorBases = {};\nvar VALID_NODE_ERROR_BASES = {\n  TypeError,\n  RangeError,\n  Error,\n};\n\nfunction getNodeErrorByName(typeName) {\n  var base = errorBases[typeName];\n  if (base) {\n    return base;\n  }\n  if (!ObjectKeys(VALID_NODE_ERROR_BASES).includes(typeName)) {\n    throw new Error(\"Invalid NodeError type\");\n  }\n\n  var Base = VALID_NODE_ERROR_BASES[typeName];\n\n  class NodeError extends Base {\n    [kIsNodeError] = true;\n    code;\n    constructor(msg, opts) {\n      super(msg, opts);\n      this.code = opts?.code || \"ERR_GENERIC\";\n    }\n\n    toString() {\n      return `${this.name} [${this.code}]: ${this.message}`;\n    }\n  }\n  errorBases[typeName] = NodeError;\n  return NodeError;\n}\n\nvar NodeError = getNodeErrorByName(\"Error\");\nvar NodeTypeError = getNodeErrorByName(\"TypeError\");\nvar NodeRangeError = getNodeErrorByName(\"RangeError\");\n\nclass ERR_INVALID_ARG_TYPE extends NodeTypeError {\n  constructor(name, type, value) {\n    super(`The \"${name}\" argument must be of type ${type}. Received type ${typeof value}`, {\n      code: \"ERR_INVALID_ARG_TYPE\",\n    });\n  }\n}\n\nclass ERR_INVALID_ARG_VALUE extends NodeTypeError {\n  constructor(name, value, reason = \"not specified\") {\n    super(`The value \"${String(value)}\" is invalid for argument '${name}'. Reason: ${reason}`, {\n      code: \"ERR_INVALID_ARG_VALUE\",\n    });\n  }\n}\n\nclass ERR_INVALID_CURSOR_POS extends NodeTypeError {\n  constructor() {\n    super(\"Cannot set cursor row without setting its column\", {\n      code: \"ERR_INVALID_CURSOR_POS\",\n    });\n  }\n}\n\nclass ERR_OUT_OF_RANGE extends NodeRangeError {\n  constructor(name, range, received) {\n    super(`The value of \"${name}\" is out of range. It must be ${range}. Received ${received}`, {\n      code: \"ERR_OUT_OF_RANGE\",\n    });\n  }\n}\n\nclass ERR_USE_AFTER_CLOSE extends NodeError {\n  constructor() {\n    super(\"This socket has been ended by the other party\", {\n      code: \"ERR_USE_AFTER_CLOSE\",\n    });\n  }\n}\n\nclass AbortError extends Error {\n  code;\n  constructor() {\n    super(\"The operation was aborted\");\n    this.code = \"ABORT_ERR\";\n  }\n}\n\n// Validators\n\n/**\n * @callback validateFunction\n * @param {*} value\n * @param {string} name\n * @returns {asserts value is Function}\n */\nfunction validateFunction(value, name) {\n  if (typeof value !== \"function\") throw new ERR_INVALID_ARG_TYPE(name, \"Function\", value);\n}\n\n/**\n * @callback validateAbortSignal\n * @param {*} signal\n * @param {string} name\n */\nfunction validateAbortSignal(signal, name) {\n  if (signal !== undefined && (signal === null || typeof signal !== \"object\" || !(\"aborted\" in signal))) {\n    throw new ERR_INVALID_ARG_TYPE(name, \"AbortSignal\", signal);\n  }\n}\n\n/**\n * @callback validateArray\n * @param {*} value\n * @param {string} name\n * @param {number} [minLength]\n * @returns {asserts value is any[]}\n */\nfunction validateArray(value, name, minLength = 0) {\n  // var validateArray = hideStackFrames((value, name, minLength = 0) => {\n  if (!ArrayIsArray(value)) {\n    throw new ERR_INVALID_ARG_TYPE(name, \"Array\", value);\n  }\n  if (value.length < minLength) {\n    var reason = `must be longer than ${minLength}`;\n    throw new ERR_INVALID_ARG_VALUE(name, value, reason);\n  }\n}\n\n/**\n * @callback validateString\n * @param {*} value\n * @param {string} name\n * @returns {asserts value is string}\n */\nfunction validateString(value, name) {\n  if (typeof value !== \"string\") throw new ERR_INVALID_ARG_TYPE(name, \"string\", value);\n}\n\n/**\n * @callback validateBoolean\n * @param {*} value\n * @param {string} name\n * @returns {asserts value is boolean}\n */\nfunction validateBoolean(value, name) {\n  if (typeof value !== \"boolean\") throw new ERR_INVALID_ARG_TYPE(name, \"boolean\", value);\n}\n\n/**\n * @callback validateObject\n * @param {*} value\n * @param {string} name\n * @param {{\n *   allowArray?: boolean,\n *   allowFunction?: boolean,\n *   nullable?: boolean\n * }} [options]\n */\nfunction validateObject(value, name, options = null) {\n  // var validateObject = hideStackFrames((value, name, options = null) => {\n  var allowArray = options?.allowArray ?? false;\n  var allowFunction = options?.allowFunction ?? false;\n  var nullable = options?.nullable ?? false;\n  if (\n    (!nullable && value === null) ||\n    (!allowArray && ArrayIsArray.call(value)) ||\n    (typeof value !== \"object\" && (!allowFunction || typeof value !== \"function\"))\n  ) {\n    throw new ERR_INVALID_ARG_TYPE(name, \"object\", value);\n  }\n}\n\n/**\n * @callback validateInteger\n * @param {*} value\n * @param {string} name\n * @param {number} [min]\n * @param {number} [max]\n * @returns {asserts value is number}\n */\nfunction validateInteger(value, name, min = NumberMIN_SAFE_INTEGER, max = NumberMAX_SAFE_INTEGER) {\n  if (typeof value !== \"number\") throw new ERR_INVALID_ARG_TYPE(name, \"number\", value);\n  if (!NumberIsInteger(value)) throw new ERR_OUT_OF_RANGE(name, \"an integer\", value);\n  if (value < min || value > max) throw new ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value);\n}\n\n/**\n * @callback validateUint32\n * @param {*} value\n * @param {string} name\n * @param {number|boolean} [positive=false]\n * @returns {asserts value is number}\n */\nfunction validateUint32(value, name, positive = false) {\n  if (typeof value !== \"number\") {\n    throw new ERR_INVALID_ARG_TYPE(name, \"number\", value);\n  }\n\n  if (!NumberIsInteger(value)) {\n    throw new ERR_OUT_OF_RANGE(name, \"an integer\", value);\n  }\n\n  var min = positive ? 1 : 0; // 2 ** 32 === 4294967296\n  var max = 4_294_967_295;\n\n  if (value < min || value > max) {\n    throw new ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value);\n  }\n}\n\n// ----------------------------------------------------------------------------\n// Section: Utils\n// ----------------------------------------------------------------------------\n\nfunction CSI(strings, ...args) {\n  var ret = `${kEscape}[`;\n  for (var n = 0; n < strings.length; n++) {\n    ret += strings[n];\n    if (n < args.length) ret += args[n];\n  }\n  return ret;\n}\n\nvar kClearLine, kClearScreenDown, kClearToLineBeginning, kClearToLineEnd;\n\nCSI.kEscape = kEscape;\nCSI.kClearLine = kClearLine = CSI`2K`;\nCSI.kClearScreenDown = kClearScreenDown = CSI`0J`;\nCSI.kClearToLineBeginning = kClearToLineBeginning = CSI`1K`;\nCSI.kClearToLineEnd = kClearToLineEnd = CSI`0K`;\n\nfunction charLengthLeft(str, i) {\n  if (i <= 0) return 0;\n  if (\n    (i > 1 && StringPrototypeCodePointAt.call(str, i - 2) >= kUTF16SurrogateThreshold) ||\n    StringPrototypeCodePointAt.call(str, i - 1) >= kUTF16SurrogateThreshold\n  ) {\n    return 2;\n  }\n  return 1;\n}\n\nfunction charLengthAt(str, i) {\n  if (str.length <= i) {\n    // Pretend to move to the right. This is necessary to autocomplete while\n    // moving to the right.\n    return 1;\n  }\n  return StringPrototypeCodePointAt.call(str, i) >= kUTF16SurrogateThreshold ? 2 : 1;\n}\n\n/*\n  Some patterns seen in terminal key escape codes, derived from combos seen\n  at http://www.midnight-commander.org/browser/lib/tty/key.c\n  ESC letter\n  ESC [ letter\n  ESC [ modifier letter\n  ESC [ 1 ; modifier letter\n  ESC [ num char\n  ESC [ num ; modifier char\n  ESC O letter\n  ESC O modifier letter\n  ESC O 1 ; modifier letter\n  ESC N letter\n  ESC [ [ num ; modifier char\n  ESC [ [ 1 ; modifier letter\n  ESC ESC [ num char\n  ESC ESC O letter\n  - char is usually ~ but $ and ^ also happen with rxvt\n  - modifier is 1 +\n                (shift     * 1) +\n                (left_alt  * 2) +\n                (ctrl      * 4) +\n                (right_alt * 8)\n  - two leading ESCs apparently mean the same as one leading ESC\n*/\nfunction* emitKeys(stream) {\n  while (true) {\n    var ch = yield;\n    var s = ch;\n    var escaped = false;\n\n    var keySeq = null;\n    var keyName;\n    var keyCtrl = false;\n    var keyMeta = false;\n    var keyShift = false;\n\n    // var key = {\n    //   sequence: null,\n    //   name: undefined,\n    //   ctrl: false,\n    //   meta: false,\n    //   shift: false,\n    // };\n\n    if (ch === kEscape) {\n      escaped = true;\n      s += ch = yield;\n\n      if (ch === kEscape) {\n        s += ch = yield;\n      }\n    }\n\n    if (escaped && (ch === \"O\" || ch === \"[\")) {\n      // ANSI escape sequence\n      var code = ch;\n      var modifier = 0;\n\n      if (ch === \"O\") {\n        // ESC O letter\n        // ESC O modifier letter\n        s += ch = yield;\n\n        if (ch >= \"0\" && ch <= \"9\") {\n          modifier = (ch >> 0) - 1;\n          s += ch = yield;\n        }\n\n        code += ch;\n      } else if (ch === \"[\") {\n        // ESC [ letter\n        // ESC [ modifier letter\n        // ESC [ [ modifier letter\n        // ESC [ [ num char\n        s += ch = yield;\n\n        if (ch === \"[\") {\n          // \\x1b[[A\n          //      ^--- escape codes might have a second bracket\n          code += ch;\n          s += ch = yield;\n        }\n\n        /*\n         * Here and later we try to buffer just enough data to get\n         * a complete ascii sequence.\n         *\n         * We have basically two classes of ascii characters to process:\n         *\n         *\n         * 1. `\\x1b[24;5~` should be parsed as { code: '[24~', modifier: 5 }\n         *\n         * This particular example is featuring Ctrl+F12 in xterm.\n         *\n         *  - `;5` part is optional, e.g. it could be `\\x1b[24~`\n         *  - first part can contain one or two digits\n         *\n         * So the generic regexp is like /^\\d\\d?(;\\d)?[~^$]$/\n         *\n         *\n         * 2. `\\x1b[1;5H` should be parsed as { code: '[H', modifier: 5 }\n         *\n         * This particular example is featuring Ctrl+Home in xterm.\n         *\n         *  - `1;5` part is optional, e.g. it could be `\\x1b[H`\n         *  - `1;` part is optional, e.g. it could be `\\x1b[5H`\n         *\n         * So the generic regexp is like /^((\\d;)?\\d)?[A-Za-z]$/\n         *\n         */\n        var cmdStart = s.length - 1;\n\n        // Skip one or two leading digits\n        if (ch >= \"0\" && ch <= \"9\") {\n          s += ch = yield;\n\n          if (ch >= \"0\" && ch <= \"9\") {\n            s += ch = yield;\n          }\n        }\n\n        // skip modifier\n        if (ch === \";\") {\n          s += ch = yield;\n\n          if (ch >= \"0\" && ch <= \"9\") {\n            s += yield;\n          }\n        }\n\n        /*\n         * We buffered enough data, now trying to extract code\n         * and modifier from it\n         */\n        var cmd = StringPrototypeSlice.call(s, cmdStart);\n        var match;\n\n        if ((match = RegExpPrototypeExec.call(/^(\\d\\d?)(;(\\d))?([~^$])$/, cmd))) {\n          code += match[1] + match[4];\n          modifier = (match[3] || 1) - 1;\n        } else if ((match = RegExpPrototypeExec.call(/^((\\d;)?(\\d))?([A-Za-z])$/, cmd))) {\n          code += match[4];\n          modifier = (match[3] || 1) - 1;\n        } else {\n          code += cmd;\n        }\n      }\n\n      // Parse the key modifier\n      keyCtrl = !!(modifier & 4);\n      keyMeta = !!(modifier & 10);\n      keyShift = !!(modifier & 1);\n      keyCode = code;\n\n      // Parse the key itself\n      switch (code) {\n        /* xterm/gnome ESC [ letter (with modifier) */\n        case \"[P\":\n          keyName = \"f1\";\n          break;\n        case \"[Q\":\n          keyName = \"f2\";\n          break;\n        case \"[R\":\n          keyName = \"f3\";\n          break;\n        case \"[S\":\n          keyName = \"f4\";\n          break;\n\n        /* xterm/gnome ESC O letter (without modifier) */\n        case \"OP\":\n          keyName = \"f1\";\n          break;\n        case \"OQ\":\n          keyName = \"f2\";\n          break;\n        case \"OR\":\n          keyName = \"f3\";\n          break;\n        case \"OS\":\n          keyName = \"f4\";\n          break;\n\n        /* xterm/rxvt ESC [ number ~ */\n        case \"[11~\":\n          keyName = \"f1\";\n          break;\n        case \"[12~\":\n          keyName = \"f2\";\n          break;\n        case \"[13~\":\n          keyName = \"f3\";\n          break;\n        case \"[14~\":\n          keyName = \"f4\";\n          break;\n\n        /* from Cygwin and used in libuv */\n        case \"[[A\":\n          keyName = \"f1\";\n          break;\n        case \"[[B\":\n          keyName = \"f2\";\n          break;\n        case \"[[C\":\n          keyName = \"f3\";\n          break;\n        case \"[[D\":\n          keyName = \"f4\";\n          break;\n        case \"[[E\":\n          keyName = \"f5\";\n          break;\n\n        /* common */\n        case \"[15~\":\n          keyName = \"f5\";\n          break;\n        case \"[17~\":\n          keyName = \"f6\";\n          break;\n        case \"[18~\":\n          keyName = \"f7\";\n          break;\n        case \"[19~\":\n          keyName = \"f8\";\n          break;\n        case \"[20~\":\n          keyName = \"f9\";\n          break;\n        case \"[21~\":\n          keyName = \"f10\";\n          break;\n        case \"[23~\":\n          keyName = \"f11\";\n          break;\n        case \"[24~\":\n          keyName = \"f12\";\n          break;\n\n        /* xterm ESC [ letter */\n        case \"[A\":\n          keyName = \"up\";\n          break;\n        case \"[B\":\n          keyName = \"down\";\n          break;\n        case \"[C\":\n          keyName = \"right\";\n          break;\n        case \"[D\":\n          keyName = \"left\";\n          break;\n        case \"[E\":\n          keyName = \"clear\";\n          break;\n        case \"[F\":\n          keyName = \"end\";\n          break;\n        case \"[H\":\n          keyName = \"home\";\n          break;\n\n        /* xterm/gnome ESC O letter */\n        case \"OA\":\n          keyName = \"up\";\n          break;\n        case \"OB\":\n          keyName = \"down\";\n          break;\n        case \"OC\":\n          keyName = \"right\";\n          break;\n        case \"OD\":\n          keyName = \"left\";\n          break;\n        case \"OE\":\n          keyName = \"clear\";\n          break;\n        case \"OF\":\n          keyName = \"end\";\n          break;\n        case \"OH\":\n          keyName = \"home\";\n          break;\n\n        /* xterm/rxvt ESC [ number ~ */\n        case \"[1~\":\n          keyName = \"home\";\n          break;\n        case \"[2~\":\n          keyName = \"insert\";\n          break;\n        case \"[3~\":\n          keyName = \"delete\";\n          break;\n        case \"[4~\":\n          keyName = \"end\";\n          break;\n        case \"[5~\":\n          keyName = \"pageup\";\n          break;\n        case \"[6~\":\n          keyName = \"pagedown\";\n          break;\n\n        /* putty */\n        case \"[[5~\":\n          keyName = \"pageup\";\n          break;\n        case \"[[6~\":\n          keyName = \"pagedown\";\n          break;\n\n        /* rxvt */\n        case \"[7~\":\n          keyName = \"home\";\n          break;\n        case \"[8~\":\n          keyName = \"end\";\n          break;\n\n        /* rxvt keys with modifiers */\n        case \"[a\":\n          keyName = \"up\";\n          keyShift = true;\n          break;\n        case \"[b\":\n          keyName = \"down\";\n          keyShift = true;\n          break;\n        case \"[c\":\n          keyName = \"right\";\n          keyShift = true;\n          break;\n        case \"[d\":\n          keyName = \"left\";\n          keyShift = true;\n          break;\n        case \"[e\":\n          keyName = \"clear\";\n          keyShift = true;\n          break;\n\n        case \"[2$\":\n          keyName = \"insert\";\n          keyShift = true;\n          break;\n        case \"[3$\":\n          keyName = \"delete\";\n          keyShift = true;\n          break;\n        case \"[5$\":\n          keyName = \"pageup\";\n          keyShift = true;\n          break;\n        case \"[6$\":\n          keyName = \"pagedown\";\n          keyShift = true;\n          break;\n        case \"[7$\":\n          keyName = \"home\";\n          keyShift = true;\n          break;\n        case \"[8$\":\n          keyName = \"end\";\n          keyShift = true;\n          break;\n\n        case \"Oa\":\n          keyName = \"up\";\n          keyCtrl = true;\n          break;\n        case \"Ob\":\n          keyName = \"down\";\n          keyCtrl = true;\n          break;\n        case \"Oc\":\n          keyName = \"right\";\n          keyCtrl = true;\n          break;\n        case \"Od\":\n          keyName = \"left\";\n          keyCtrl = true;\n          break;\n        case \"Oe\":\n          keyName = \"clear\";\n          keyCtrl = true;\n          break;\n\n        case \"[2^\":\n          keyName = \"insert\";\n          keyCtrl = true;\n          break;\n        case \"[3^\":\n          keyName = \"delete\";\n          keyCtrl = true;\n          break;\n        case \"[5^\":\n          keyName = \"pageup\";\n          keyCtrl = true;\n          break;\n        case \"[6^\":\n          keyName = \"pagedown\";\n          keyCtrl = true;\n          break;\n        case \"[7^\":\n          keyName = \"home\";\n          keyCtrl = true;\n          break;\n        case \"[8^\":\n          keyName = \"end\";\n          keyCtrl = true;\n          break;\n\n        /* misc. */\n        case \"[Z\":\n          keyName = \"tab\";\n          keyShift = true;\n          break;\n        default:\n          keyName = \"undefined\";\n          break;\n      }\n    } else if (ch === \"\\r\") {\n      // carriage return\n      keyName = \"return\";\n      keyMeta = escaped;\n    } else if (ch === \"\\n\") {\n      // Enter, should have been called linefeed\n      keyName = \"enter\";\n      keyMeta = escaped;\n    } else if (ch === \"\\t\") {\n      // tab\n      keyName = \"tab\";\n      keyMeta = escaped;\n    } else if (ch === \"\\b\" || ch === \"\\x7f\") {\n      // backspace or ctrl+h\n      keyName = \"backspace\";\n      keyMeta = escaped;\n    } else if (ch === kEscape) {\n      // escape key\n      keyName = \"escape\";\n      keyMeta = escaped;\n    } else if (ch === \" \") {\n      keyName = \"space\";\n      keyMeta = escaped;\n    } else if (!escaped && ch <= \"\\x1a\") {\n      // ctrl+letter\n      keyName = StringFromCharCode(StringPrototypeCharCodeAt.call(ch) + StringPrototypeCharCodeAt.call(\"a\") - 1);\n      keyCtrl = true;\n    } else if (RegExpPrototypeExec.call(/^[0-9A-Za-z]$/, ch) !== null) {\n      // Letter, number, shift+letter\n      keyName = StringPrototypeToLowerCase.call(ch);\n      keyShift = RegExpPrototypeExec.call(/^[A-Z]$/, ch) !== null;\n      keyMeta = escaped;\n    } else if (escaped) {\n      // Escape sequence timeout\n      keyName = ch.length ? undefined : \"escape\";\n      keyMeta = true;\n    }\n\n    keySeq = s;\n\n    if (s.length !== 0 && (keyName !== undefined || escaped)) {\n      /* Named character or sequence */\n      stream.emit(\"keypress\", escaped ? undefined : s, {\n        sequence: keySeq,\n        name: keyName,\n        ctrl: keyCtrl,\n        meta: keyMeta,\n        shift: keyShift,\n      });\n    } else if (charLengthAt(s, 0) === s.length) {\n      /* Single unnamed character, e.g. \".\" */\n      stream.emit(\"keypress\", s, {\n        sequence: keySeq,\n        name: keyName,\n        ctrl: keyCtrl,\n        meta: keyMeta,\n        shift: keyShift,\n      });\n    }\n    /* Unrecognized or broken escape sequence, don't emit anything */\n  }\n}\n\n// This runs in O(n log n).\nfunction commonPrefix(strings) {\n  if (strings.length === 0) {\n    return \"\";\n  }\n  if (strings.length === 1) {\n    return strings[0];\n  }\n  var sorted = ArrayPrototypeSort.call(ArrayPrototypeSlice.call(strings));\n  var min = sorted[0];\n  var max = sorted[sorted.length - 1];\n  for (var i = 0; i < min.length; i++) {\n    if (min[i] !== max[i]) {\n      return StringPrototypeSlice.call(min, 0, i);\n    }\n  }\n  return min;\n}\n\n// ----------------------------------------------------------------------------\n// Section: Cursor Functions\n// ----------------------------------------------------------------------------\n\n/**\n * moves the cursor to the x and y coordinate on the given stream\n */\n\nfunction cursorTo(stream, x, y, callback) {\n  if (callback !== undefined) {\n    validateFunction(callback, \"callback\");\n  }\n\n  if (typeof y === \"function\") {\n    callback = y;\n    y = undefined;\n  }\n\n  if (NumberIsNaN(x)) throw new ERR_INVALID_ARG_VALUE(\"x\", x);\n  if (NumberIsNaN(y)) throw new ERR_INVALID_ARG_VALUE(\"y\", y);\n\n  if (stream == null || (typeof x !== \"number\" && typeof y !== \"number\")) {\n    if (typeof callback === \"function\") process.nextTick(callback, null);\n    return true;\n  }\n\n  if (typeof x !== \"number\") throw new ERR_INVALID_CURSOR_POS();\n\n  var data = typeof y !== \"number\" ? CSI`${x + 1}G` : CSI`${y + 1};${x + 1}H`;\n  return stream.write(data, callback);\n}\n\n/**\n * moves the cursor relative to its current location\n */\n\nfunction moveCursor(stream, dx, dy, callback) {\n  if (callback !== undefined) {\n    validateFunction(callback, \"callback\");\n  }\n\n  if (stream == null || !(dx || dy)) {\n    if (typeof callback === \"function\") process.nextTick(callback, null);\n    return true;\n  }\n\n  var data = \"\";\n\n  if (dx < 0) {\n    data += CSI`${-dx}D`;\n  } else if (dx > 0) {\n    data += CSI`${dx}C`;\n  }\n\n  if (dy < 0) {\n    data += CSI`${-dy}A`;\n  } else if (dy > 0) {\n    data += CSI`${dy}B`;\n  }\n\n  return stream.write(data, callback);\n}\n\n/**\n * clears the current line the cursor is on:\n *   -1 for left of the cursor\n *   +1 for right of the cursor\n *    0 for the entire line\n */\n\nfunction clearLine(stream, dir, callback) {\n  if (callback !== undefined) {\n    validateFunction(callback, \"callback\");\n  }\n\n  if (stream === null || stream === undefined) {\n    if (typeof callback === \"function\") process.nextTick(callback, null);\n    return true;\n  }\n\n  var type = dir < 0 ? kClearToLineBeginning : dir > 0 ? kClearToLineEnd : kClearLine;\n  return stream.write(type, callback);\n}\n\n/**\n * clears the screen from the current position of the cursor down\n */\n\nfunction clearScreenDown(stream, callback) {\n  if (callback !== undefined) {\n    validateFunction(callback, \"callback\");\n  }\n\n  if (stream === null || stream === undefined) {\n    if (typeof callback === \"function\") process.nextTick(callback, null);\n    return true;\n  }\n\n  return stream.write(kClearScreenDown, callback);\n}\n\n// ----------------------------------------------------------------------------\n// Section: Emit keypress events\n// ----------------------------------------------------------------------------\n\nvar KEYPRESS_DECODER = Symbol(\"keypress-decoder\");\nvar ESCAPE_DECODER = Symbol(\"escape-decoder\");\n\n// GNU readline library - keyseq-timeout is 500ms (default)\nvar ESCAPE_CODE_TIMEOUT = 500;\n\n/**\n * accepts a readable Stream instance and makes it emit \"keypress\" events\n */\n\nfunction emitKeypressEvents(stream, iface = {}) {\n  if (stream[KEYPRESS_DECODER]) return;\n\n  stream[KEYPRESS_DECODER] = new StringDecoder(\"utf8\");\n\n  stream[ESCAPE_DECODER] = emitKeys(stream);\n  stream[ESCAPE_DECODER].next();\n\n  var triggerEscape = () => stream[ESCAPE_DECODER].next(\"\");\n  var { escapeCodeTimeout = ESCAPE_CODE_TIMEOUT } = iface;\n  var timeoutId;\n\n  function onData(input) {\n    if (stream.listenerCount(\"keypress\") > 0) {\n      var string = stream[KEYPRESS_DECODER].write(input);\n      if (string) {\n        clearTimeout(timeoutId);\n\n        // This supports characters of length 2.\n        iface[kSawKeyPress] = charLengthAt(string, 0) === string.length;\n        iface.isCompletionEnabled = false;\n\n        var length = 0;\n        for (var character of new SafeStringIterator(string)) {\n          length += character.length;\n          if (length === string.length) {\n            iface.isCompletionEnabled = true;\n          }\n\n          try {\n            stream[ESCAPE_DECODER].next(character);\n            // Escape letter at the tail position\n            if (length === string.length && character === kEscape) {\n              timeoutId = setTimeout(triggerEscape, escapeCodeTimeout);\n            }\n          } catch (err) {\n            // If the generator throws (it could happen in the `keypress`\n            // event), we need to restart it.\n            stream[ESCAPE_DECODER] = emitKeys(stream);\n            stream[ESCAPE_DECODER].next();\n            throw err;\n          }\n        }\n      }\n    } else {\n      // Nobody's watching anyway\n      stream.removeListener(\"data\", onData);\n      stream.on(\"newListener\", onNewListener);\n    }\n  }\n\n  function onNewListener(event) {\n    if (event === \"keypress\") {\n      stream.on(\"data\", onData);\n      stream.removeListener(\"newListener\", onNewListener);\n    }\n  }\n\n  if (stream.listenerCount(\"keypress\") > 0) {\n    stream.on(\"data\", onData);\n  } else {\n    stream.on(\"newListener\", onNewListener);\n  }\n}\n\n// ----------------------------------------------------------------------------\n// Section: Interface\n// ----------------------------------------------------------------------------\n\nvar kEmptyObject = ObjectFreeze(ObjectCreate(null));\n\n// Some constants regarding configuration of interface\nvar kHistorySize = 30;\nvar kMaxUndoRedoStackSize = 2048;\nvar kMincrlfDelay = 100;\n// \\r\\n, \\n, or \\r followed by something other than \\n\nvar lineEnding = /\\r?\\n|\\r(?!\\n)/g;\n\n// Max length of the kill ring\nvar kMaxLengthOfKillRing = 32;\n\n// Symbols\n\n// Public symbols\nvar kLineObjectStream = Symbol(\"line object stream\");\nvar kQuestionCancel = Symbol(\"kQuestionCancel\");\nvar kQuestion = Symbol(\"kQuestion\");\n\n// Private symbols\nvar kAddHistory = Symbol(\"_addHistory\");\nvar kBeforeEdit = Symbol(\"_beforeEdit\");\nvar kDecoder = Symbol(\"_decoder\");\nvar kDeleteLeft = Symbol(\"_deleteLeft\");\nvar kDeleteLineLeft = Symbol(\"_deleteLineLeft\");\nvar kDeleteLineRight = Symbol(\"_deleteLineRight\");\nvar kDeleteRight = Symbol(\"_deleteRight\");\nvar kDeleteWordLeft = Symbol(\"_deleteWordLeft\");\nvar kDeleteWordRight = Symbol(\"_deleteWordRight\");\nvar kGetDisplayPos = Symbol(\"_getDisplayPos\");\nvar kHistoryNext = Symbol(\"_historyNext\");\nvar kHistoryPrev = Symbol(\"_historyPrev\");\nvar kInsertString = Symbol(\"_insertString\");\nvar kLine = Symbol(\"_line\");\nvar kLine_buffer = Symbol(\"_line_buffer\");\nvar kKillRing = Symbol(\"_killRing\");\nvar kKillRingCursor = Symbol(\"_killRingCursor\");\nvar kMoveCursor = Symbol(\"_moveCursor\");\nvar kNormalWrite = Symbol(\"_normalWrite\");\nvar kOldPrompt = Symbol(\"_oldPrompt\");\nvar kOnLine = Symbol(\"_onLine\");\nvar kPreviousKey = Symbol(\"_previousKey\");\nvar kPrompt = Symbol(\"_prompt\");\nvar kPushToKillRing = Symbol(\"_pushToKillRing\");\nvar kPushToUndoStack = Symbol(\"_pushToUndoStack\");\nvar kQuestionCallback = Symbol(\"_questionCallback\");\nvar kRedo = Symbol(\"_redo\");\nvar kRedoStack = Symbol(\"_redoStack\");\nvar kRefreshLine = Symbol(\"_refreshLine\");\nvar kSawKeyPress = Symbol(\"_sawKeyPress\");\nvar kSawReturnAt = Symbol(\"_sawReturnAt\");\nvar kSetRawMode = Symbol(\"_setRawMode\");\nvar kTabComplete = Symbol(\"_tabComplete\");\nvar kTabCompleter = Symbol(\"_tabCompleter\");\nvar kTtyWrite = Symbol(\"_ttyWrite\");\nvar kUndo = Symbol(\"_undo\");\nvar kUndoStack = Symbol(\"_undoStack\");\nvar kWordLeft = Symbol(\"_wordLeft\");\nvar kWordRight = Symbol(\"_wordRight\");\nvar kWriteToOutput = Symbol(\"_writeToOutput\");\nvar kYank = Symbol(\"_yank\");\nvar kYanking = Symbol(\"_yanking\");\nvar kYankPop = Symbol(\"_yankPop\");\n\n// Event symbols\nvar kFirstEventParam = Symbol(\"nodejs.kFirstEventParam\");\n\n// class InterfaceConstructor extends EventEmitter {\n// #onSelfCloseWithTerminal;\n// #onSelfCloseWithoutTerminal;\n\n// #onError;\n// #onData;\n// #onEnd;\n// #onTermEnd;\n// #onKeyPress;\n// #onResize;\n\n// [kSawReturnAt];\n// isCompletionEnabled = true;\n// [kSawKeyPress];\n// [kPreviousKey];\n// escapeCodeTimeout;\n// tabSize;\n\n// line;\n// [kSubstringSearch];\n// output;\n// input;\n// [kUndoStack];\n// [kRedoStack];\n// history;\n// historySize;\n\n// [kKillRing];\n// [kKillRingCursor];\n\n// removeHistoryDuplicates;\n// crlfDelay;\n// completer;\n\n// terminal;\n// [kLineObjectStream];\n\n// cursor;\n// historyIndex;\n\n// constructor(input, output, completer, terminal) {\n//   super();\n\nvar kOnSelfCloseWithTerminal = Symbol(\"_onSelfCloseWithTerminal\");\nvar kOnSelfCloseWithoutTerminal = Symbol(\"_onSelfCloseWithoutTerminal\");\nvar kOnKeyPress = Symbol(\"_onKeyPress\");\nvar kOnError = Symbol(\"_onError\");\nvar kOnData = Symbol(\"_onData\");\nvar kOnEnd = Symbol(\"_onEnd\");\nvar kOnTermEnd = Symbol(\"_onTermEnd\");\nvar kOnResize = Symbol(\"_onResize\");\n\nfunction onSelfCloseWithTerminal() {\n  var input = this.input;\n  var output = this.output;\n\n  if (!input) throw new Error(\"Input not set, invalid state for readline!\");\n\n  input.removeListener(\"keypress\", this[kOnKeyPress]);\n  input.removeListener(\"error\", this[kOnError]);\n  input.removeListener(\"end\", this[kOnTermEnd]);\n  if (output !== null && output !== undefined) {\n    output.removeListener(\"resize\", this[kOnResize]);\n  }\n}\n\nfunction onSelfCloseWithoutTerminal() {\n  var input = this.input;\n  if (!input) throw new Error(\"Input not set, invalid state for readline!\");\n\n  input.removeListener(\"data\", this[kOnData]);\n  input.removeListener(\"error\", this[kOnError]);\n  input.removeListener(\"end\", this[kOnEnd]);\n}\n\nfunction onError(err) {\n  this.emit(\"error\", err);\n}\n\nfunction onData(data) {\n  debug(\"onData\");\n  this[kNormalWrite](data);\n}\n\nfunction onEnd() {\n  debug(\"onEnd\");\n  if (typeof this[kLine_buffer] === \"string\" && this[kLine_buffer].length > 0) {\n    this.emit(\"line\", this[kLine_buffer]);\n  }\n  this.close();\n}\n\nfunction onTermEnd() {\n  debug(\"onTermEnd\");\n  if (typeof this.line === \"string\" && this.line.length > 0) {\n    this.emit(\"line\", this.line);\n  }\n  this.close();\n}\n\nfunction onKeyPress(s, key) {\n  this[kTtyWrite](s, key);\n  if (key && key.sequence) {\n    // If the keySeq is half of a surrogate pair\n    // (>= 0xd800 and <= 0xdfff), refresh the line so\n    // the character is displayed appropriately.\n    var ch = StringPrototypeCodePointAt.call(key.sequence, 0);\n    if (ch >= 0xd800 && ch <= 0xdfff) this[kRefreshLine]();\n  }\n}\n\nfunction onResize() {\n  this[kRefreshLine]();\n}\n\nfunction InterfaceConstructor(input, output, completer, terminal) {\n  if (!(this instanceof InterfaceConstructor)) {\n    return new InterfaceConstructor(input, output, completer, terminal);\n  }\n\n  EventEmitter.call(this);\n\n  this[kOnSelfCloseWithoutTerminal] = onSelfCloseWithoutTerminal.bind(this);\n  this[kOnSelfCloseWithTerminal] = onSelfCloseWithTerminal.bind(this);\n\n  this[kOnError] = onError.bind(this);\n  this[kOnData] = onData.bind(this);\n  this[kOnEnd] = onEnd.bind(this);\n  this[kOnTermEnd] = onTermEnd.bind(this);\n  this[kOnKeyPress] = onKeyPress.bind(this);\n  this[kOnResize] = onResize.bind(this);\n\n  this[kSawReturnAt] = 0;\n  this.isCompletionEnabled = true;\n  this[kSawKeyPress] = false;\n  this[kPreviousKey] = null;\n  this.escapeCodeTimeout = ESCAPE_CODE_TIMEOUT;\n  this.tabSize = 8;\n\n  var history;\n  var historySize;\n  var removeHistoryDuplicates = false;\n  var crlfDelay;\n  var prompt = \"> \";\n  var signal;\n\n  if (input?.input) {\n    // An options object was given\n    output = input.output;\n    completer = input.completer;\n    terminal = input.terminal;\n    history = input.history;\n    historySize = input.historySize;\n    signal = input.signal;\n\n    var tabSize = input.tabSize;\n    if (tabSize !== undefined) {\n      validateUint32(tabSize, \"tabSize\", true);\n      this.tabSize = tabSize;\n    }\n    removeHistoryDuplicates = input.removeHistoryDuplicates;\n\n    var inputPrompt = input.prompt;\n    if (inputPrompt !== undefined) {\n      prompt = inputPrompt;\n    }\n\n    var inputEscapeCodeTimeout = input.escapeCodeTimeout;\n    if (inputEscapeCodeTimeout !== undefined) {\n      if (NumberIsFinite(inputEscapeCodeTimeout)) {\n        this.escapeCodeTimeout = inputEscapeCodeTimeout;\n      } else {\n        throw new ERR_INVALID_ARG_VALUE(\"input.escapeCodeTimeout\", this.escapeCodeTimeout);\n      }\n    }\n\n    if (signal) {\n      validateAbortSignal(signal, \"options.signal\");\n    }\n\n    crlfDelay = input.crlfDelay;\n    input = input.input;\n  }\n\n  if (completer !== undefined && typeof completer !== \"function\") {\n    throw new ERR_INVALID_ARG_VALUE(\"completer\", completer);\n  }\n\n  if (history === undefined) {\n    history = [];\n  } else {\n    validateArray(history, \"history\");\n  }\n\n  if (historySize === undefined) {\n    historySize = kHistorySize;\n  }\n\n  if (typeof historySize !== \"number\" || NumberIsNaN(historySize) || historySize < 0) {\n    throw new ERR_INVALID_ARG_VALUE(\"historySize\", historySize);\n  }\n\n  // Backwards compat; check the isTTY prop of the output stream\n  //  when `terminal` was not specified\n  if (terminal === undefined && !(output === null || output === undefined)) {\n    terminal = !!output.isTTY;\n  }\n\n  this.line = \"\";\n  this[kSubstringSearch] = null;\n  this.output = output;\n  this.input = input;\n  this[kUndoStack] = [];\n  this[kRedoStack] = [];\n  this.history = history;\n  this.historySize = historySize;\n\n  // The kill ring is a global list of blocks of text that were previously\n  // killed (deleted). If its size exceeds kMaxLengthOfKillRing, the oldest\n  // element will be removed to make room for the latest deletion. With kill\n  // ring, users are able to recall (yank) or cycle (yank pop) among previously\n  // killed texts, quite similar to the behavior of Emacs.\n  this[kKillRing] = [];\n  this[kKillRingCursor] = 0;\n\n  this.removeHistoryDuplicates = !!removeHistoryDuplicates;\n  this.crlfDelay = crlfDelay ? MathMax(kMincrlfDelay, crlfDelay) : kMincrlfDelay;\n  this.completer = completer;\n\n  this.setPrompt(prompt);\n\n  this.terminal = !!terminal;\n\n  this[kLineObjectStream] = undefined;\n\n  input.on(\"error\", this[kOnError]);\n\n  if (!this.terminal) {\n    input.on(\"data\", this[kOnData]);\n    input.on(\"end\", this[kOnEnd]);\n    this.once(\"close\", this[kOnSelfCloseWithoutTerminal]);\n    this[kDecoder] = new StringDecoder(\"utf8\");\n  } else {\n    emitKeypressEvents(input, this);\n\n    // `input` usually refers to stdin\n    input.on(\"keypress\", this[kOnKeyPress]);\n    input.on(\"end\", this[kOnTermEnd]);\n\n    this[kSetRawMode](true);\n    this.terminal = true;\n\n    // Cursor position on the line.\n    this.cursor = 0;\n    this.historyIndex = -1;\n\n    if (output !== null && output !== undefined) output.on(\"resize\", this[kOnResize]);\n\n    this.once(\"close\", this[kOnSelfCloseWithTerminal]);\n  }\n\n  if (signal) {\n    var onAborted = (() => this.close()).bind(this);\n    if (signal.aborted) {\n      process.nextTick(onAborted);\n    } else {\n      signal.addEventListener(\"abort\", onAborted, { once: true });\n      this.once(\"close\", () => signal.removeEventListener(\"abort\", onAborted));\n    }\n  }\n\n  // Current line\n  this.line = \"\";\n\n  input.resume();\n}\n\nObjectSetPrototypeOf(InterfaceConstructor.prototype, EventEmitter.prototype);\nObjectSetPrototypeOf(InterfaceConstructor, EventEmitter);\n\nvar _Interface = class Interface extends InterfaceConstructor {\n  // TODO: Enumerate all the properties of the class\n\n  // eslint-disable-next-line no-useless-constructor\n  constructor(input, output, completer, terminal) {\n    super(input, output, completer, terminal);\n  }\n  get columns() {\n    var output = this.output;\n    if (output && output.columns) return output.columns;\n    return Infinity;\n  }\n\n  /**\n   * Sets the prompt written to the output.\n   * @param {string} prompt\n   * @returns {void}\n   */\n  setPrompt(prompt) {\n    this[kPrompt] = prompt;\n  }\n\n  /**\n   * Returns the current prompt used by `rl.prompt()`.\n   * @returns {string}\n   */\n  getPrompt() {\n    return this[kPrompt];\n  }\n\n  [kSetRawMode](mode) {\n    var input = this.input;\n    var { setRawMode, wasInRawMode } = input;\n\n    // TODO: Make this work, for now just stub this and print debug\n    debug(\"setRawMode\", mode, \"set!\");\n    // if (typeof setRawMode === \"function\") {\n    //   setRawMode(mode);\n    // }\n\n    return wasInRawMode;\n  }\n\n  /**\n   * Writes the configured `prompt` to a new line in `output`.\n   * @param {boolean} [preserveCursor]\n   * @returns {void}\n   */\n  prompt(preserveCursor) {\n    if (this.paused) this.resume();\n    if (this.terminal && process.env.TERM !== \"dumb\") {\n      if (!preserveCursor) this.cursor = 0;\n      this[kRefreshLine]();\n    } else {\n      this[kWriteToOutput](this[kPrompt]);\n    }\n  }\n\n  [kQuestion](query, cb) {\n    if (this.closed) {\n      throw new ERR_USE_AFTER_CLOSE(\"readline\");\n    }\n    if (this[kQuestionCallback]) {\n      this.prompt();\n    } else {\n      this[kOldPrompt] = this[kPrompt];\n      this.setPrompt(query);\n      this[kQuestionCallback] = cb;\n      this.prompt();\n    }\n  }\n\n  [kOnLine](line) {\n    if (this[kQuestionCallback]) {\n      var cb = this[kQuestionCallback];\n      this[kQuestionCallback] = null;\n      this.setPrompt(this[kOldPrompt]);\n      cb(line);\n    } else {\n      this.emit(\"line\", line);\n    }\n  }\n\n  [kBeforeEdit](oldText, oldCursor) {\n    this[kPushToUndoStack](oldText, oldCursor);\n  }\n\n  [kQuestionCancel]() {\n    if (this[kQuestionCallback]) {\n      this[kQuestionCallback] = null;\n      this.setPrompt(this[kOldPrompt]);\n      this.clearLine();\n    }\n  }\n\n  [kWriteToOutput](stringToWrite) {\n    validateString(stringToWrite, \"stringToWrite\");\n\n    if (this.output !== null && this.output !== undefined) {\n      this.output.write(stringToWrite);\n    }\n  }\n\n  [kAddHistory]() {\n    if (this.line.length === 0) return \"\";\n\n    // If the history is disabled then return the line\n    if (this.historySize === 0) return this.line;\n\n    // If the trimmed line is empty then return the line\n    if (StringPrototypeTrim.call(this.line).length === 0) return this.line;\n\n    if (this.history.length === 0 || this.history[0] !== this.line) {\n      if (this.removeHistoryDuplicates) {\n        // Remove older history line if identical to new one\n        var dupIndex = ArrayPrototypeIndexOf.call(this.history, this.line);\n        if (dupIndex !== -1) ArrayPrototypeSplice.call(this.history, dupIndex, 1);\n      }\n\n      ArrayPrototypeUnshift.call(this.history, this.line);\n\n      // Only store so many\n      if (this.history.length > this.historySize) ArrayPrototypePop.call(this.history);\n    }\n\n    this.historyIndex = -1;\n\n    // The listener could change the history object, possibly\n    // to remove the last added entry if it is sensitive and should\n    // not be persisted in the history, like a password\n    var line = this.history[0];\n\n    // Emit history event to notify listeners of update\n    this.emit(\"history\", this.history);\n\n    return line;\n  }\n\n  [kRefreshLine]() {\n    // line length\n    var line = this[kPrompt] + this.line;\n    var dispPos = this[kGetDisplayPos](line);\n    var lineCols = dispPos.cols;\n    var lineRows = dispPos.rows;\n\n    // cursor position\n    var cursorPos = this.getCursorPos();\n\n    // First move to the bottom of the current line, based on cursor pos\n    var prevRows = this.prevRows || 0;\n    if (prevRows > 0) {\n      moveCursor(this.output, 0, -prevRows);\n    }\n\n    // Cursor to left edge.\n    cursorTo(this.output, 0);\n    // erase data\n    clearScreenDown(this.output);\n\n    // Write the prompt and the current buffer content.\n    this[kWriteToOutput](line);\n\n    // Force terminal to allocate a new line\n    if (lineCols === 0) {\n      this[kWriteToOutput](\" \");\n    }\n\n    // Move cursor to original position.\n    cursorTo(this.output, cursorPos.cols);\n\n    var diff = lineRows - cursorPos.rows;\n    if (diff > 0) {\n      moveCursor(this.output, 0, -diff);\n    }\n\n    this.prevRows = cursorPos.rows;\n  }\n\n  /**\n   * Closes the `readline.Interface` instance.\n   * @returns {void}\n   */\n  close() {\n    if (this.closed) return;\n    this.pause();\n    if (this.terminal) {\n      this[kSetRawMode](false);\n    }\n    this.closed = true;\n    this.emit(\"close\");\n  }\n\n  /**\n   * Pauses the `input` stream.\n   * @returns {void | Interface}\n   */\n  pause() {\n    if (this.paused) return;\n    this.input.pause();\n    this.paused = true;\n    this.emit(\"pause\");\n    return this;\n  }\n\n  /**\n   * Resumes the `input` stream if paused.\n   * @returns {void | Interface}\n   */\n  resume() {\n    if (!this.paused) return;\n    this.input.resume();\n    this.paused = false;\n    this.emit(\"resume\");\n    return this;\n  }\n\n  /**\n   * Writes either `data` or a `key` sequence identified by\n   * `key` to the `output`.\n   * @param {string} d\n   * @param {{\n   *   ctrl?: boolean;\n   *   meta?: boolean;\n   *   shift?: boolean;\n   *   name?: string;\n   *   }} [key]\n   * @returns {void}\n   */\n  write(d, key) {\n    if (this.paused) this.resume();\n    if (this.terminal) {\n      this[kTtyWrite](d, key);\n    } else {\n      this[kNormalWrite](d);\n    }\n  }\n\n  [kNormalWrite](b) {\n    if (b === undefined) {\n      return;\n    }\n    var string = this[kDecoder].write(b);\n    if (this[kSawReturnAt] && DateNow() - this[kSawReturnAt] <= this.crlfDelay) {\n      if (StringPrototypeCodePointAt.call(string) === 10) string = StringPrototypeSlice.call(string, 1);\n      this[kSawReturnAt] = 0;\n    }\n\n    // Run test() on the new string chunk, not on the entire line buffer.\n    var newPartContainsEnding = RegExpPrototypeExec.call(lineEnding, string);\n    if (newPartContainsEnding !== null) {\n      if (this[kLine_buffer]) {\n        string = this[kLine_buffer] + string;\n        this[kLine_buffer] = null;\n        newPartContainsEnding = RegExpPrototypeExec.call(lineEnding, string);\n      }\n      this[kSawReturnAt] = StringPrototypeEndsWith.call(string, \"\\r\") ? DateNow() : 0;\n\n      var indexes = [0, newPartContainsEnding.index, lineEnding.lastIndex];\n      var nextMatch;\n      while ((nextMatch = RegExpPrototypeExec.call(lineEnding, string)) !== null) {\n        ArrayPrototypePush.call(indexes, nextMatch.index, lineEnding.lastIndex);\n      }\n      var lastIndex = indexes.length - 1;\n      // Either '' or (conceivably) the unfinished portion of the next line\n      this[kLine_buffer] = StringPrototypeSlice.call(string, indexes[lastIndex]);\n      for (var i = 1; i < lastIndex; i += 2) {\n        this[kOnLine](StringPrototypeSlice.call(string, indexes[i - 1], indexes[i]));\n      }\n    } else if (string) {\n      // No newlines this time, save what we have for next time\n      if (this[kLine_buffer]) {\n        this[kLine_buffer] += string;\n      } else {\n        this[kLine_buffer] = string;\n      }\n    }\n  }\n\n  [kInsertString](c) {\n    this[kBeforeEdit](this.line, this.cursor);\n    if (this.cursor < this.line.length) {\n      var beg = StringPrototypeSlice.call(this.line, 0, this.cursor);\n      var end = StringPrototypeSlice.call(this.line, this.cursor, this.line.length);\n      this.line = beg + c + end;\n      this.cursor += c.length;\n      this[kRefreshLine]();\n    } else {\n      var oldPos = this.getCursorPos();\n      this.line += c;\n      this.cursor += c.length;\n      var newPos = this.getCursorPos();\n\n      if (oldPos.rows < newPos.rows) {\n        this[kRefreshLine]();\n      } else {\n        this[kWriteToOutput](c);\n      }\n    }\n  }\n\n  async [kTabComplete](lastKeypressWasTab) {\n    this.pause();\n    var string = StringPrototypeSlice.call(this.line, 0, this.cursor);\n    var value;\n    try {\n      value = await this.completer(string);\n    } catch (err) {\n      this[kWriteToOutput](`Tab completion error: ${inspect(err)}`);\n      return;\n    } finally {\n      this.resume();\n    }\n    this[kTabCompleter](lastKeypressWasTab, value);\n  }\n\n  [kTabCompleter](lastKeypressWasTab, { 0: completions, 1: completeOn }) {\n    // Result and the text that was completed.\n\n    if (!completions || completions.length === 0) {\n      return;\n    }\n\n    // If there is a common prefix to all matches, then apply that portion.\n    var prefix = commonPrefix(ArrayPrototypeFilter.call(completions, e => e !== \"\"));\n    if (StringPrototypeStartsWith.call(prefix, completeOn) && prefix.length > completeOn.length) {\n      this[kInsertString](StringPrototypeSlice.call(prefix, completeOn.length));\n      return;\n    } else if (!StringPrototypeStartsWith.call(completeOn, prefix)) {\n      this.line =\n        StringPrototypeSlice.call(this.line, 0, this.cursor - completeOn.length) +\n        prefix +\n        StringPrototypeSlice.call(this.line, this.cursor, this.line.length);\n      this.cursor = this.cursor - completeOn.length + prefix.length;\n      this._refreshLine();\n      return;\n    }\n\n    if (!lastKeypressWasTab) {\n      return;\n    }\n\n    this[kBeforeEdit](this.line, this.cursor);\n\n    // Apply/show completions.\n    var completionsWidth = ArrayPrototypeMap.call(completions, e => getStringWidth(e));\n    var width = MathMaxApply(completionsWidth) + 2; // 2 space padding\n    var maxColumns = MathFloor(this.columns / width) || 1;\n    if (maxColumns === Infinity) {\n      maxColumns = 1;\n    }\n    var output = \"\\r\\n\";\n    var lineIndex = 0;\n    var whitespace = 0;\n    for (var i = 0; i < completions.length; i++) {\n      var completion = completions[i];\n      if (completion === \"\" || lineIndex === maxColumns) {\n        output += \"\\r\\n\";\n        lineIndex = 0;\n        whitespace = 0;\n      } else {\n        output += StringPrototypeRepeat.call(\" \", whitespace);\n      }\n      if (completion !== \"\") {\n        output += completion;\n        whitespace = width - completionsWidth[i];\n        lineIndex++;\n      } else {\n        output += \"\\r\\n\";\n      }\n    }\n    if (lineIndex !== 0) {\n      output += \"\\r\\n\\r\\n\";\n    }\n    this[kWriteToOutput](output);\n    this[kRefreshLine]();\n  }\n\n  [kWordLeft]() {\n    if (this.cursor > 0) {\n      // Reverse the string and match a word near beginning\n      // to avoid quadratic time complexity\n      var leading = StringPrototypeSlice.call(this.line, 0, this.cursor);\n      var reversed = ArrayPrototypeJoin.call(ArrayPrototypeReverse.call(ArrayFrom(leading)), \"\");\n      var match = RegExpPrototypeExec.call(/^\\s*(?:[^\\w\\s]+|\\w+)?/, reversed);\n      this[kMoveCursor](-match[0].length);\n    }\n  }\n\n  [kWordRight]() {\n    if (this.cursor < this.line.length) {\n      var trailing = StringPrototypeSlice.call(this.line, this.cursor);\n      var match = RegExpPrototypeExec.call(/^(?:\\s+|[^\\w\\s]+|\\w+)\\s*/, trailing);\n      this[kMoveCursor](match[0].length);\n    }\n  }\n\n  [kDeleteLeft]() {\n    if (this.cursor > 0 && this.line.length > 0) {\n      this[kBeforeEdit](this.line, this.cursor);\n      // The number of UTF-16 units comprising the character to the left\n      var charSize = charLengthLeft(this.line, this.cursor);\n      this.line =\n        StringPrototypeSlice.call(this.line, 0, this.cursor - charSize) +\n        StringPrototypeSlice.call(this.line, this.cursor, this.line.length);\n\n      this.cursor -= charSize;\n      this[kRefreshLine]();\n    }\n  }\n\n  [kDeleteRight]() {\n    if (this.cursor < this.line.length) {\n      this[kBeforeEdit](this.line, this.cursor);\n      // The number of UTF-16 units comprising the character to the left\n      var charSize = charLengthAt(this.line, this.cursor);\n      this.line =\n        StringPrototypeSlice.call(this.line, 0, this.cursor) +\n        StringPrototypeSlice.call(this.line, this.cursor + charSize, this.line.length);\n      this[kRefreshLine]();\n    }\n  }\n\n  [kDeleteWordLeft]() {\n    if (this.cursor > 0) {\n      this[kBeforeEdit](this.line, this.cursor);\n      // Reverse the string and match a word near beginning\n      // to avoid quadratic time complexity\n      var leading = StringPrototypeSlice.call(this.line, 0, this.cursor);\n      var reversed = ArrayPrototypeJoin.call(ArrayPrototypeReverse.call(ArrayFrom(leading)), \"\");\n      var match = RegExpPrototypeExec.call(/^\\s*(?:[^\\w\\s]+|\\w+)?/, reversed);\n      leading = StringPrototypeSlice.call(leading, 0, leading.length - match[0].length);\n      this.line = leading + StringPrototypeSlice.call(this.line, this.cursor, this.line.length);\n      this.cursor = leading.length;\n      this[kRefreshLine]();\n    }\n  }\n\n  [kDeleteWordRight]() {\n    if (this.cursor < this.line.length) {\n      this[kBeforeEdit](this.line, this.cursor);\n      var trailing = StringPrototypeSlice.call(this.line, this.cursor);\n      var match = RegExpPrototypeExec.call(/^(?:\\s+|\\W+|\\w+)\\s*/, trailing);\n      this.line =\n        StringPrototypeSlice.call(this.line, 0, this.cursor) + StringPrototypeSlice.call(trailing, match[0].length);\n      this[kRefreshLine]();\n    }\n  }\n\n  [kDeleteLineLeft]() {\n    this[kBeforeEdit](this.line, this.cursor);\n    var del = StringPrototypeSlice.call(this.line, 0, this.cursor);\n    this.line = StringPrototypeSlice.call(this.line, this.cursor);\n    this.cursor = 0;\n    this[kPushToKillRing](del);\n    this[kRefreshLine]();\n  }\n\n  [kDeleteLineRight]() {\n    this[kBeforeEdit](this.line, this.cursor);\n    var del = StringPrototypeSlice.call(this.line, this.cursor);\n    this.line = StringPrototypeSlice.call(this.line, 0, this.cursor);\n    this[kPushToKillRing](del);\n    this[kRefreshLine]();\n  }\n\n  [kPushToKillRing](del) {\n    if (!del || del === this[kKillRing][0]) return;\n    ArrayPrototypeUnshift.call(this[kKillRing], del);\n    this[kKillRingCursor] = 0;\n    while (this[kKillRing].length > kMaxLengthOfKillRing) ArrayPrototypePop.call(this[kKillRing]);\n  }\n\n  [kYank]() {\n    if (this[kKillRing].length > 0) {\n      this[kYanking] = true;\n      this[kInsertString](this[kKillRing][this[kKillRingCursor]]);\n    }\n  }\n\n  [kYankPop]() {\n    if (!this[kYanking]) {\n      return;\n    }\n    if (this[kKillRing].length > 1) {\n      var lastYank = this[kKillRing][this[kKillRingCursor]];\n      this[kKillRingCursor]++;\n      if (this[kKillRingCursor] >= this[kKillRing].length) {\n        this[kKillRingCursor] = 0;\n      }\n      var currentYank = this[kKillRing][this[kKillRingCursor]];\n      var head = StringPrototypeSlice.call(this.line, 0, this.cursor - lastYank.length);\n      var tail = StringPrototypeSlice.call(this.line, this.cursor);\n      this.line = head + currentYank + tail;\n      this.cursor = head.length + currentYank.length;\n      this[kRefreshLine]();\n    }\n  }\n\n  clearLine() {\n    this[kMoveCursor](+Infinity);\n    this[kWriteToOutput](\"\\r\\n\");\n    this.line = \"\";\n    this.cursor = 0;\n    this.prevRows = 0;\n  }\n\n  [kLine]() {\n    var line = this[kAddHistory]();\n    this[kUndoStack] = [];\n    this[kRedoStack] = [];\n    this.clearLine();\n    this[kOnLine](line);\n  }\n\n  [kPushToUndoStack](text, cursor) {\n    if (ArrayPrototypePush.call(this[kUndoStack], { text, cursor }) > kMaxUndoRedoStackSize) {\n      ArrayPrototypeShift.call(this[kUndoStack]);\n    }\n  }\n\n  [kUndo]() {\n    if (this[kUndoStack].length <= 0) return;\n\n    ArrayPrototypePush.call(this[kRedoStack], {\n      text: this.line,\n      cursor: this.cursor,\n    });\n\n    var entry = ArrayPrototypePop.call(this[kUndoStack]);\n    this.line = entry.text;\n    this.cursor = entry.cursor;\n\n    this[kRefreshLine]();\n  }\n\n  [kRedo]() {\n    if (this[kRedoStack].length <= 0) return;\n\n    ArrayPrototypePush.call(this[kUndoStack], {\n      text: this.line,\n      cursor: this.cursor,\n    });\n\n    var entry = ArrayPrototypePop.call(this[kRedoStack]);\n    this.line = entry.text;\n    this.cursor = entry.cursor;\n\n    this[kRefreshLine]();\n  }\n\n  [kHistoryNext]() {\n    if (this.historyIndex >= 0) {\n      this[kBeforeEdit](this.line, this.cursor);\n      var search = this[kSubstringSearch] || \"\";\n      var index = this.historyIndex - 1;\n      while (\n        index >= 0 &&\n        (!StringPrototypeStartsWith.call(this.history[index], search) || this.line === this.history[index])\n      ) {\n        index--;\n      }\n      if (index === -1) {\n        this.line = search;\n      } else {\n        this.line = this.history[index];\n      }\n      this.historyIndex = index;\n      this.cursor = this.line.length; // Set cursor to end of line.\n      this[kRefreshLine]();\n    }\n  }\n\n  [kHistoryPrev]() {\n    if (this.historyIndex < this.history.length && this.history.length) {\n      this[kBeforeEdit](this.line, this.cursor);\n      var search = this[kSubstringSearch] || \"\";\n      var index = this.historyIndex + 1;\n      while (\n        index < this.history.length &&\n        (!StringPrototypeStartsWith.call(this.history[index], search) || this.line === this.history[index])\n      ) {\n        index++;\n      }\n      if (index === this.history.length) {\n        this.line = search;\n      } else {\n        this.line = this.history[index];\n      }\n      this.historyIndex = index;\n      this.cursor = this.line.length; // Set cursor to end of line.\n      this[kRefreshLine]();\n    }\n  }\n\n  // Returns the last character's display position of the given string\n  [kGetDisplayPos](str) {\n    var offset = 0;\n    var col = this.columns;\n    var rows = 0;\n    str = stripVTControlCharacters(str);\n    for (var char of new SafeStringIterator(str)) {\n      if (char === \"\\n\") {\n        // Rows must be incremented by 1 even if offset = 0 or col = +Infinity.\n        rows += MathCeil(offset / col) || 1;\n        offset = 0;\n        continue;\n      }\n      // Tabs must be aligned by an offset of the tab size.\n      if (char === \"\\t\") {\n        offset += this.tabSize - (offset % this.tabSize);\n        continue;\n      }\n      var width = getStringWidth(char, false /* stripVTControlCharacters */);\n      if (width === 0 || width === 1) {\n        offset += width;\n      } else {\n        // width === 2\n        if ((offset + 1) % col === 0) {\n          offset++;\n        }\n        offset += 2;\n      }\n    }\n    var cols = offset % col;\n    rows += (offset - cols) / col;\n    return { cols, rows };\n  }\n\n  /**\n   * Returns the real position of the cursor in relation\n   * to the input prompt + string.\n   * @returns {{\n   *   rows: number;\n   *   cols: number;\n   * }}\n   */\n  getCursorPos() {\n    var strBeforeCursor = this[kPrompt] + StringPrototypeSlice.call(this.line, 0, this.cursor);\n    return this[kGetDisplayPos](strBeforeCursor);\n  }\n\n  // This function moves cursor dx places to the right\n  // (-dx for left) and refreshes the line if it is needed.\n  [kMoveCursor](dx) {\n    if (dx === 0) {\n      return;\n    }\n    var oldPos = this.getCursorPos();\n    this.cursor += dx;\n\n    // Bounds check\n    if (this.cursor < 0) {\n      this.cursor = 0;\n    } else if (this.cursor > this.line.length) {\n      this.cursor = this.line.length;\n    }\n\n    var newPos = this.getCursorPos();\n\n    // Check if cursor stayed on the line.\n    if (oldPos.rows === newPos.rows) {\n      var diffWidth = newPos.cols - oldPos.cols;\n      moveCursor(this.output, diffWidth, 0);\n    } else {\n      this[kRefreshLine]();\n    }\n  }\n\n  // Handle a write from the tty\n  [kTtyWrite](s, key) {\n    var previousKey = this[kPreviousKey];\n    key = key || kEmptyObject;\n    this[kPreviousKey] = key;\n    var { name: keyName, meta: keyMeta, ctrl: keyCtrl, shift: keyShift, sequence: keySeq } = key;\n\n    if (!keyMeta || keyName !== \"y\") {\n      // Reset yanking state unless we are doing yank pop.\n      this[kYanking] = false;\n    }\n\n    // Activate or deactivate substring search.\n    if ((keyName === \"up\" || keyName === \"down\") && !keyCtrl && !keyMeta && !keyShift) {\n      if (this[kSubstringSearch] === null) {\n        this[kSubstringSearch] = StringPrototypeSlice.call(this.line, 0, this.cursor);\n      }\n    } else if (this[kSubstringSearch] !== null) {\n      this[kSubstringSearch] = null;\n      // Reset the index in case there's no match.\n      if (this.history.length === this.historyIndex) {\n        this.historyIndex = -1;\n      }\n    }\n\n    // Undo & Redo\n    if (typeof keySeq === \"string\") {\n      switch (StringPrototypeCodePointAt.call(keySeq, 0)) {\n        case 0x1f:\n          this[kUndo]();\n          return;\n        case 0x1e:\n          this[kRedo]();\n          return;\n        default:\n          break;\n      }\n    }\n\n    // Ignore escape key, fixes\n    // https://github.com/nodejs/node-v0.x-archive/issues/2876.\n    if (keyName === \"escape\") return;\n\n    if (keyCtrl && keyShift) {\n      /* Control and shift pressed */\n      switch (keyName) {\n        // TODO(BridgeAR): The transmitted escape sequence is `\\b` and that is\n        // identical to <ctrl>-h. It should have a unique escape sequence.\n        case \"backspace\":\n          this[kDeleteLineLeft]();\n          break;\n\n        case \"delete\":\n          this[kDeleteLineRight]();\n          break;\n      }\n    } else if (keyCtrl) {\n      /* Control key pressed */\n\n      switch (keyName) {\n        case \"c\":\n          if (this.listenerCount(\"SIGINT\") > 0) {\n            this.emit(\"SIGINT\");\n          } else {\n            // This readline instance is finished\n            this.close();\n          }\n          break;\n\n        case \"h\": // delete left\n          this[kDeleteLeft]();\n          break;\n\n        case \"d\": // delete right or EOF\n          if (this.cursor === 0 && this.line.length === 0) {\n            // This readline instance is finished\n            this.close();\n          } else if (this.cursor < this.line.length) {\n            this[kDeleteRight]();\n          }\n          break;\n\n        case \"u\": // Delete from current to start of line\n          this[kDeleteLineLeft]();\n          break;\n\n        case \"k\": // Delete from current to end of line\n          this[kDeleteLineRight]();\n          break;\n\n        case \"a\": // Go to the start of the line\n          this[kMoveCursor](-Infinity);\n          break;\n\n        case \"e\": // Go to the end of the line\n          this[kMoveCursor](+Infinity);\n          break;\n\n        case \"b\": // back one character\n          this[kMoveCursor](-charLengthLeft(this.line, this.cursor));\n          break;\n\n        case \"f\": // Forward one character\n          this[kMoveCursor](+charLengthAt(this.line, this.cursor));\n          break;\n\n        case \"l\": // Clear the whole screen\n          cursorTo(this.output, 0, 0);\n          clearScreenDown(this.output);\n          this[kRefreshLine]();\n          break;\n\n        case \"n\": // next history item\n          this[kHistoryNext]();\n          break;\n\n        case \"p\": // Previous history item\n          this[kHistoryPrev]();\n          break;\n\n        case \"y\": // Yank killed string\n          this[kYank]();\n          break;\n\n        case \"z\":\n          if (process.platform === \"win32\") break;\n          if (this.listenerCount(\"SIGTSTP\") > 0) {\n            this.emit(\"SIGTSTP\");\n          } else {\n            process.once(\"SIGCONT\", () => {\n              // Don't raise events if stream has already been abandoned.\n              if (!this.paused) {\n                // Stream must be paused and resumed after SIGCONT to catch\n                // SIGINT, SIGTSTP, and EOF.\n                this.pause();\n                this.emit(\"SIGCONT\");\n              }\n              // Explicitly re-enable \"raw mode\" and move the cursor to\n              // the correct position.\n              // See https://github.com/joyent/node/issues/3295.\n              this[kSetRawMode](true);\n              this[kRefreshLine]();\n            });\n            this[kSetRawMode](false);\n            process.kill(process.pid, \"SIGTSTP\");\n          }\n          break;\n\n        case \"w\": // Delete backwards to a word boundary\n        case \"backspace\":\n          this[kDeleteWordLeft]();\n          break;\n\n        case \"delete\": // Delete forward to a word boundary\n          this[kDeleteWordRight]();\n          break;\n\n        case \"left\":\n          this[kWordLeft]();\n          break;\n\n        case \"right\":\n          this[kWordRight]();\n          break;\n      }\n    } else if (keyMeta) {\n      /* Meta key pressed */\n\n      switch (keyName) {\n        case \"b\": // backward word\n          this[kWordLeft]();\n          break;\n\n        case \"f\": // forward word\n          this[kWordRight]();\n          break;\n\n        case \"d\": // delete forward word\n        case \"delete\":\n          this[kDeleteWordRight]();\n          break;\n\n        case \"backspace\": // Delete backwards to a word boundary\n          this[kDeleteWordLeft]();\n          break;\n\n        case \"y\": // Doing yank pop\n          this[kYankPop]();\n          break;\n      }\n    } else {\n      /* No modifier keys used */\n\n      // \\r bookkeeping is only relevant if a \\n comes right after.\n      if (this[kSawReturnAt] && keyName !== \"enter\") this[kSawReturnAt] = 0;\n\n      switch (keyName) {\n        case \"return\": // Carriage return, i.e. \\r\n          this[kSawReturnAt] = DateNow();\n          this[kLine]();\n          break;\n\n        case \"enter\":\n          // When key interval > crlfDelay\n          if (this[kSawReturnAt] === 0 || DateNow() - this[kSawReturnAt] > this.crlfDelay) {\n            this[kLine]();\n          }\n          this[kSawReturnAt] = 0;\n          break;\n\n        case \"backspace\":\n          this[kDeleteLeft]();\n          break;\n\n        case \"delete\":\n          this[kDeleteRight]();\n          break;\n\n        case \"left\":\n          // Obtain the code point to the left\n          this[kMoveCursor](-charLengthLeft(this.line, this.cursor));\n          break;\n\n        case \"right\":\n          this[kMoveCursor](+charLengthAt(this.line, this.cursor));\n          break;\n\n        case \"home\":\n          this[kMoveCursor](-Infinity);\n          break;\n\n        case \"end\":\n          this[kMoveCursor](+Infinity);\n          break;\n\n        case \"up\":\n          this[kHistoryPrev]();\n          break;\n\n        case \"down\":\n          this[kHistoryNext]();\n          break;\n\n        case \"tab\":\n          // If tab completion enabled, do that...\n          if (typeof this.completer === \"function\" && this.isCompletionEnabled) {\n            var lastKeypressWasTab = previousKey && previousKey.name === \"tab\";\n            this[kTabComplete](lastKeypressWasTab);\n            break;\n          }\n        // falls through\n        default:\n          if (typeof s === \"string\" && s) {\n            var nextMatch = RegExpPrototypeExec.call(lineEnding, s);\n            if (nextMatch !== null) {\n              this[kInsertString](StringPrototypeSlice.call(s, 0, nextMatch.index));\n              var { lastIndex } = lineEnding;\n              while ((nextMatch = RegExpPrototypeExec.call(lineEnding, s)) !== null) {\n                this[kLine]();\n                this[kInsertString](StringPrototypeSlice.call(s, lastIndex, nextMatch.index));\n                ({ lastIndex } = lineEnding);\n              }\n              if (lastIndex === s.length) this[kLine]();\n            } else {\n              this[kInsertString](s);\n            }\n          }\n      }\n    }\n  }\n\n  /**\n   * Creates an `AsyncIterator` object that iterates through\n   * each line in the input stream as a string.\n   * @typedef {{\n   *   [Symbol.asyncIterator]: () => InterfaceAsyncIterator,\n   *   next: () => Promise<string>\n   * }} InterfaceAsyncIterator\n   * @returns {InterfaceAsyncIterator}\n   */\n  [SymbolAsyncIterator]() {\n    if (this[kLineObjectStream] === undefined) {\n      this[kLineObjectStream] = EventEmitter.on(this, \"line\", {\n        close: [\"close\"],\n        highWatermark: 1024,\n        [kFirstEventParam]: true,\n      });\n    }\n    return this[kLineObjectStream];\n  }\n};\n\nfunction Interface(input, output, completer, terminal) {\n  if (!(this instanceof Interface)) {\n    return new Interface(input, output, completer, terminal);\n  }\n\n  if (input?.input && typeof input.completer === \"function\" && input.completer.length !== 2) {\n    var { completer } = input;\n    input.completer = (v, cb) => cb(null, completer(v));\n  } else if (typeof completer === \"function\" && completer.length !== 2) {\n    var realCompleter = completer;\n    completer = (v, cb) => cb(null, realCompleter(v));\n  }\n\n  InterfaceConstructor.call(this, input, output, completer, terminal);\n\n  // TODO: Test this\n  if (process.env.TERM === \"dumb\") {\n    this._ttyWrite = _ttyWriteDumb.bind(this);\n  }\n}\n\nObjectSetPrototypeOf(Interface.prototype, _Interface.prototype);\nObjectSetPrototypeOf(Interface, _Interface);\n\n/**\n * Displays `query` by writing it to the `output`.\n * @param {string} query\n * @param {{ signal?: AbortSignal; }} [options]\n * @param {Function} cb\n * @returns {void}\n */\nInterface.prototype.question = function question(query, options, cb) {\n  cb = typeof options === \"function\" ? options : cb;\n  if (options === null || typeof options !== \"object\") {\n    options = kEmptyObject;\n  }\n\n  var signal = options?.signal;\n  if (signal) {\n    validateAbortSignal(signal, \"options.signal\");\n    if (signal.aborted) {\n      return;\n    }\n\n    var onAbort = () => {\n      this[kQuestionCancel]();\n    };\n    signal.addEventListener(\"abort\", onAbort, { once: true });\n    var cleanup = () => {\n      signal.removeEventListener(\"abort\", onAbort);\n    };\n    var originalCb = cb;\n    cb =\n      typeof cb === \"function\"\n        ? answer => {\n            cleanup();\n            return originalCb(answer);\n          }\n        : cleanup;\n  }\n\n  if (typeof cb === \"function\") {\n    this[kQuestion](query, cb);\n  }\n};\n\nInterface.prototype.question[promisify.custom] = function question(query, options) {\n  if (options === null || typeof options !== \"object\") {\n    options = kEmptyObject;\n  }\n\n  var signal = options?.signal;\n\n  if (signal && signal.aborted) {\n    return PromiseReject(new AbortError(undefined, { cause: signal.reason }));\n  }\n\n  return new Promise((resolve, reject) => {\n    var cb = resolve;\n    if (signal) {\n      var onAbort = () => {\n        reject(new AbortError(undefined, { cause: signal.reason }));\n      };\n      signal.addEventListener(\"abort\", onAbort, { once: true });\n      cb = answer => {\n        signal.removeEventListener(\"abort\", onAbort);\n        resolve(answer);\n      };\n    }\n    this.question(query, options, cb);\n  });\n};\n\n/**\n * Creates a new `readline.Interface` instance.\n * @param {Readable | {\n *   input: Readable;\n *   output: Writable;\n *   completer?: Function;\n *   terminal?: boolean;\n *   history?: string[];\n *   historySize?: number;\n *   removeHistoryDuplicates?: boolean;\n *   prompt?: string;\n *   crlfDelay?: number;\n *   escapeCodeTimeout?: number;\n *   tabSize?: number;\n *   signal?: AbortSignal;\n *   }} input\n * @param {Writable} [output]\n * @param {Function} [completer]\n * @param {boolean} [terminal]\n * @returns {Interface}\n */\nfunction createInterface(input, output, completer, terminal) {\n  return new Interface(input, output, completer, terminal);\n}\n\nObjectDefineProperties(Interface.prototype, {\n  // Redirect internal prototype methods to the underscore notation for backward\n  // compatibility.\n  [kSetRawMode]: {\n    __proto__: null,\n    get() {\n      return this._setRawMode;\n    },\n  },\n  [kOnLine]: {\n    __proto__: null,\n    get() {\n      return this._onLine;\n    },\n  },\n  [kWriteToOutput]: {\n    __proto__: null,\n    get() {\n      return this._writeToOutput;\n    },\n  },\n  [kAddHistory]: {\n    __proto__: null,\n    get() {\n      return this._addHistory;\n    },\n  },\n  [kRefreshLine]: {\n    __proto__: null,\n    get() {\n      return this._refreshLine;\n    },\n  },\n  [kNormalWrite]: {\n    __proto__: null,\n    get() {\n      return this._normalWrite;\n    },\n  },\n  [kInsertString]: {\n    __proto__: null,\n    get() {\n      return this._insertString;\n    },\n  },\n  [kTabComplete]: {\n    __proto__: null,\n    get() {\n      return this._tabComplete;\n    },\n  },\n  [kWordLeft]: {\n    __proto__: null,\n    get() {\n      return this._wordLeft;\n    },\n  },\n  [kWordRight]: {\n    __proto__: null,\n    get() {\n      return this._wordRight;\n    },\n  },\n  [kDeleteLeft]: {\n    __proto__: null,\n    get() {\n      return this._deleteLeft;\n    },\n  },\n  [kDeleteRight]: {\n    __proto__: null,\n    get() {\n      return this._deleteRight;\n    },\n  },\n  [kDeleteWordLeft]: {\n    __proto__: null,\n    get() {\n      return this._deleteWordLeft;\n    },\n  },\n  [kDeleteWordRight]: {\n    __proto__: null,\n    get() {\n      return this._deleteWordRight;\n    },\n  },\n  [kDeleteLineLeft]: {\n    __proto__: null,\n    get() {\n      return this._deleteLineLeft;\n    },\n  },\n  [kDeleteLineRight]: {\n    __proto__: null,\n    get() {\n      return this._deleteLineRight;\n    },\n  },\n  [kLine]: {\n    __proto__: null,\n    get() {\n      return this._line;\n    },\n  },\n  [kHistoryNext]: {\n    __proto__: null,\n    get() {\n      return this._historyNext;\n    },\n  },\n  [kHistoryPrev]: {\n    __proto__: null,\n    get() {\n      return this._historyPrev;\n    },\n  },\n  [kGetDisplayPos]: {\n    __proto__: null,\n    get() {\n      return this._getDisplayPos;\n    },\n  },\n  [kMoveCursor]: {\n    __proto__: null,\n    get() {\n      return this._moveCursor;\n    },\n  },\n  [kTtyWrite]: {\n    __proto__: null,\n    get() {\n      return this._ttyWrite;\n    },\n  },\n\n  // Defining proxies for the internal instance properties for backward\n  // compatibility.\n  _decoder: {\n    __proto__: null,\n    get() {\n      return this[kDecoder];\n    },\n    set(value) {\n      this[kDecoder] = value;\n    },\n  },\n  _line_buffer: {\n    __proto__: null,\n    get() {\n      return this[kLine_buffer];\n    },\n    set(value) {\n      this[kLine_buffer] = value;\n    },\n  },\n  _oldPrompt: {\n    __proto__: null,\n    get() {\n      return this[kOldPrompt];\n    },\n    set(value) {\n      this[kOldPrompt] = value;\n    },\n  },\n  _previousKey: {\n    __proto__: null,\n    get() {\n      return this[kPreviousKey];\n    },\n    set(value) {\n      this[kPreviousKey] = value;\n    },\n  },\n  _prompt: {\n    __proto__: null,\n    get() {\n      return this[kPrompt];\n    },\n    set(value) {\n      this[kPrompt] = value;\n    },\n  },\n  _questionCallback: {\n    __proto__: null,\n    get() {\n      return this[kQuestionCallback];\n    },\n    set(value) {\n      this[kQuestionCallback] = value;\n    },\n  },\n  _sawKeyPress: {\n    __proto__: null,\n    get() {\n      return this[kSawKeyPress];\n    },\n    set(value) {\n      this[kSawKeyPress] = value;\n    },\n  },\n  _sawReturnAt: {\n    __proto__: null,\n    get() {\n      return this[kSawReturnAt];\n    },\n    set(value) {\n      this[kSawReturnAt] = value;\n    },\n  },\n});\n\n// Make internal methods public for backward compatibility.\nInterface.prototype._setRawMode = _Interface.prototype[kSetRawMode];\nInterface.prototype._onLine = _Interface.prototype[kOnLine];\nInterface.prototype._writeToOutput = _Interface.prototype[kWriteToOutput];\nInterface.prototype._addHistory = _Interface.prototype[kAddHistory];\nInterface.prototype._refreshLine = _Interface.prototype[kRefreshLine];\nInterface.prototype._normalWrite = _Interface.prototype[kNormalWrite];\nInterface.prototype._insertString = _Interface.prototype[kInsertString];\nInterface.prototype._tabComplete = function (lastKeypressWasTab) {\n  // Overriding parent method because `this.completer` in the legacy\n  // implementation takes a callback instead of being an async function.\n  this.pause();\n  var string = StringPrototypeSlice.call(this.line, 0, this.cursor);\n  this.completer(string, (err, value) => {\n    this.resume();\n\n    if (err) {\n      this._writeToOutput(`Tab completion error: ${inspect(err)}`);\n      return;\n    }\n\n    this[kTabCompleter](lastKeypressWasTab, value);\n  });\n};\nInterface.prototype._wordLeft = _Interface.prototype[kWordLeft];\nInterface.prototype._wordRight = _Interface.prototype[kWordRight];\nInterface.prototype._deleteLeft = _Interface.prototype[kDeleteLeft];\nInterface.prototype._deleteRight = _Interface.prototype[kDeleteRight];\nInterface.prototype._deleteWordLeft = _Interface.prototype[kDeleteWordLeft];\nInterface.prototype._deleteWordRight = _Interface.prototype[kDeleteWordRight];\nInterface.prototype._deleteLineLeft = _Interface.prototype[kDeleteLineLeft];\nInterface.prototype._deleteLineRight = _Interface.prototype[kDeleteLineRight];\nInterface.prototype._line = _Interface.prototype[kLine];\nInterface.prototype._historyNext = _Interface.prototype[kHistoryNext];\nInterface.prototype._historyPrev = _Interface.prototype[kHistoryPrev];\nInterface.prototype._getDisplayPos = _Interface.prototype[kGetDisplayPos];\nInterface.prototype._getCursorPos = _Interface.prototype.getCursorPos;\nInterface.prototype._moveCursor = _Interface.prototype[kMoveCursor];\nInterface.prototype._ttyWrite = _Interface.prototype[kTtyWrite];\n\nfunction _ttyWriteDumb(s, key) {\n  key = key || kEmptyObject;\n\n  if (key.name === \"escape\") return;\n\n  if (this[kSawReturnAt] && key.name !== \"enter\") this[kSawReturnAt] = 0;\n\n  if (keyCtrl) {\n    if (key.name === \"c\") {\n      if (this.listenerCount(\"SIGINT\") > 0) {\n        this.emit(\"SIGINT\");\n      } else {\n        // This readline instance is finished\n        this.close();\n      }\n\n      return;\n    } else if (key.name === \"d\") {\n      this.close();\n      return;\n    }\n  }\n\n  switch (key.name) {\n    case \"return\": // Carriage return, i.e. \\r\n      this[kSawReturnAt] = DateNow();\n      this._line();\n      break;\n\n    case \"enter\":\n      // When key interval > crlfDelay\n      if (this[kSawReturnAt] === 0 || DateNow() - this[kSawReturnAt] > this.crlfDelay) {\n        this._line();\n      }\n      this[kSawReturnAt] = 0;\n      break;\n\n    default:\n      if (typeof s === \"string\" && s) {\n        this.line += s;\n        this.cursor += s.length;\n        this._writeToOutput(s);\n      }\n  }\n}\n\nclass Readline {\n  #autoCommit = false;\n  #stream;\n  #todo = [];\n\n  constructor(stream, options = undefined) {\n    isWritable ??= import.meta.require(\"node:stream\").isWritable;\n    if (!isWritable(stream)) throw new ERR_INVALID_ARG_TYPE(\"stream\", \"Writable\", stream);\n    this.#stream = stream;\n    if (options?.autoCommit != null) {\n      validateBoolean(options.autoCommit, \"options.autoCommit\");\n      this.#autoCommit = options.autoCommit;\n    }\n  }\n\n  /**\n   * Moves the cursor to the x and y coordinate on the given stream.\n   * @param {integer} x\n   * @param {integer} [y]\n   * @returns {Readline} this\n   */\n  cursorTo(x, y = undefined) {\n    validateInteger(x, \"x\");\n    if (y != null) validateInteger(y, \"y\");\n\n    var data = y == null ? CSI`${x + 1}G` : CSI`${y + 1};${x + 1}H`;\n    if (this.#autoCommit) process.nextTick(() => this.#stream.write(data));\n    else ArrayPrototypePush.call(this.#todo, data);\n\n    return this;\n  }\n\n  /**\n   * Moves the cursor relative to its current location.\n   * @param {integer} dx\n   * @param {integer} dy\n   * @returns {Readline} this\n   */\n  moveCursor(dx, dy) {\n    if (dx || dy) {\n      validateInteger(dx, \"dx\");\n      validateInteger(dy, \"dy\");\n\n      var data = \"\";\n\n      if (dx < 0) {\n        data += CSI`${-dx}D`;\n      } else if (dx > 0) {\n        data += CSI`${dx}C`;\n      }\n\n      if (dy < 0) {\n        data += CSI`${-dy}A`;\n      } else if (dy > 0) {\n        data += CSI`${dy}B`;\n      }\n      if (this.#autoCommit) process.nextTick(() => this.#stream.write(data));\n      else ArrayPrototypePush.call(this.#todo, data);\n    }\n    return this;\n  }\n\n  /**\n   * Clears the current line the cursor is on.\n   * @param {-1|0|1} dir Direction to clear:\n   *   -1 for left of the cursor\n   *   +1 for right of the cursor\n   *    0 for the entire line\n   * @returns {Readline} this\n   */\n  clearLine(dir) {\n    validateInteger(dir, \"dir\", -1, 1);\n\n    var data = dir < 0 ? kClearToLineBeginning : dir > 0 ? kClearToLineEnd : kClearLine;\n    if (this.#autoCommit) process.nextTick(() => this.#stream.write(data));\n    else ArrayPrototypePush.call(this.#todo, data);\n    return this;\n  }\n\n  /**\n   * Clears the screen from the current position of the cursor down.\n   * @returns {Readline} this\n   */\n  clearScreenDown() {\n    if (this.#autoCommit) {\n      process.nextTick(() => this.#stream.write(kClearScreenDown));\n    } else {\n      ArrayPrototypePush.call(this.#todo, kClearScreenDown);\n    }\n    return this;\n  }\n\n  /**\n   * Sends all the pending actions to the associated `stream` and clears the\n   * internal list of pending actions.\n   * @returns {Promise<void>} Resolves when all pending actions have been\n   * flushed to the associated `stream`.\n   */\n  commit() {\n    return new Promise(resolve => {\n      this.#stream.write(ArrayPrototypeJoin.call(this.#todo, \"\"), resolve);\n      this.#todo = [];\n    });\n  }\n\n  /**\n   * Clears the internal list of pending actions without sending it to the\n   * associated `stream`.\n   * @returns {Readline} this\n   */\n  rollback() {\n    this.#todo = [];\n    return this;\n  }\n}\n\nvar PromisesInterface = class Interface extends _Interface {\n  // eslint-disable-next-line no-useless-constructor\n  constructor(input, output, completer, terminal) {\n    super(input, output, completer, terminal);\n  }\n  question(query, options = kEmptyObject) {\n    var signal = options?.signal;\n    if (signal) {\n      validateAbortSignal(signal, \"options.signal\");\n      if (signal.aborted) {\n        return PromiseReject(new AbortError(undefined, { cause: signal.reason }));\n      }\n    }\n    return new Promise((resolve, reject) => {\n      var cb = resolve;\n      if (options?.signal) {\n        var onAbort = () => {\n          this[kQuestionCancel]();\n          reject(new AbortError(undefined, { cause: signal.reason }));\n        };\n        signal.addEventListener(\"abort\", onAbort, { once: true });\n        cb = answer => {\n          signal.removeEventListener(\"abort\", onAbort);\n          resolve(answer);\n        };\n      }\n      this[kQuestion](query, cb);\n    });\n  }\n};\n\n// ----------------------------------------------------------------------------\n// Exports\n// ----------------------------------------------------------------------------\nexport var Interface = Interface;\nexport var clearLine = clearLine;\nexport var clearScreenDown = clearScreenDown;\nexport var createInterface = createInterface;\nexport var cursorTo = cursorTo;\nexport var emitKeypressEvents = emitKeypressEvents;\nexport var moveCursor = moveCursor;\nexport var promises = {\n  Readline,\n  Interface: PromisesInterface,\n  createInterface(input, output, completer, terminal) {\n    return new PromisesInterface(input, output, completer, terminal);\n  },\n};\n\nexport default {\n  Interface,\n  clearLine,\n  clearScreenDown,\n  createInterface,\n  cursorTo,\n  emitKeypressEvents,\n  moveCursor,\n  promises,\n\n  [SymbolFor(\"__BUN_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED__\")]: {\n    CSI,\n    utils: {\n      getStringWidth,\n      stripVTControlCharacters,\n    },\n  },\n  [SymbolFor(\"CommonJS\")]: 0,\n};\n"
  ],
  "mappings": ";;A//////DAiNA,IAAS,mCAAwB,CAAC,KAAK;AAErC,SADA,eAAe,KAAK,KAAK,GAClB,6BAA6B,KAAK,MAAM,KAAK,EAAE;AAAA,GAQ/C,oBAAS,CAAC,UAAU;AAG3B,MAFA,iBAAiB,UAAU,UAAU,GAEjC,SAAS,2BAA2B;AACtC,QAAI,KAAK,SAAS;AAIlB,WAFA,iBAAiB,IAAI,uBAAuB,GAErC,qBAAqB,IAAI,0BAA0B;AAAA,MACxD,WAAW;AAAA,MACX,OAAO;AAAA,MACP,YAAY;AAAA,MACZ,UAAU;AAAA,MACV,cAAc;AAAA,IAChB,CAAC;AAAA;AAKH,MAAI,gBAAgB,SAAS;AAE7B,WAAS,EAAE,IAAI,MAAM;AACnB,WAAO,IAAI,QAAQ,CAAC,SAAS,WAAW;AACtC,yBAAmB,KAAK,MAAM,CAAC,QAAQ,WAAW;AAChD,YAAI;AACF,iBAAO,OAAO,GAAG;AAEnB,YAAI,kBAAkB,UAAa,OAAO,SAAS,GAAG;AACpD,cAAI,MAAM,CAAC;AACX,mBAAS,KAAI,EAAG,KAAI,cAAc,QAAQ;AAAK,gBAAI,cAAc,OAAM,OAAO;AAC9E,kBAAQ,GAAG;AAAA;AAEX,kBAAQ,OAAO,EAAE;AAAA,OAEpB,GACD,aAAa,UAAU,MAAM,IAAI;AAAA,KAClC;AAAA;AAGH,uBAAqB,IAAI,qBAAqB,QAAQ,CAAC,GAEvD,qBAAqB,IAAI,0BAA0B;AAAA,IACjD,WAAW;AAAA,IACX,OAAO;AAAA,IACP,YAAY;AAAA,IACZ,UAAU;AAAA,IACV,cAAc;AAAA,EAChB,CAAC;AAED,MAAI,cAAc,gCAAgC,QAAQ,GACtD,mBAAmB,aAAa,WAAW;AAC/C,WAAS,IAAI,EAAG,IAAI,iBAAiB,QAAQ;AAG3C,yBAAqB,iBAAiB,IAAI,IAAI;AAEhD,SAAO,uBAAuB,IAAI,WAAW;AAAA,GAqBtC,6BAAkB,CAAC,UAAU;AACpC,MAAI,OAAO,WAAW;AACtB,MAAI;AACF,WAAO;AAET,OAAK,WAAW,sBAAsB,EAAE,SAAS,QAAQ;AACvD,UAAM,IAAI,MAAM,wBAAwB;AAG1C,MAAI,OAAO,uBAAuB;AAElC;AAAA,QAAM,kBAAkB,KAAK;AAAA,KAC1B,gBAAgB;AAAA,IACjB;AAAA,IACA,WAAW,CAAC,KAAK,MAAM;AACrB,YAAM,KAAK,IAAI;AACf,WAAK,OAAO,MAAM,QAAQ;AAAA;AAAA,IAG5B,QAAQ,GAAG;AACT,aAAO,GAAG,KAAK,SAAS,KAAK,UAAU,KAAK;AAAA;AAAA,EAEhD;AAEA,SADA,WAAW,YAAY,WAChB;AAAA,GA+DA,2BAAgB,CAAC,OAAO,MAAM;AACrC,aAAW,UAAU;AAAY,UAAM,IAAI,qBAAqB,MAAM,YAAY,KAAK;AAAA,GAQhF,8BAAmB,CAAC,QAAQ,MAAM;AACzC,MAAI,WAAW,WAAc,WAAW,eAAe,WAAW,cAAc,aAAa;AAC3F,UAAM,IAAI,qBAAqB,MAAM,eAAe,MAAM;AAAA,GAWrD,wBAAa,CAAC,OAAO,MAAM,YAAY,GAAG;AAEjD,OAAK,aAAa,KAAK;AACrB,UAAM,IAAI,qBAAqB,MAAM,SAAS,KAAK;AAErD,MAAI,MAAM,SAAS,WAAW;AAC5B,QAAI,SAAS,uBAAuB;AACpC,UAAM,IAAI,sBAAsB,MAAM,OAAO,MAAM;AAAA;AAAA,GAU9C,yBAAc,CAAC,OAAO,MAAM;AACnC,aAAW,UAAU;AAAU,UAAM,IAAI,qBAAqB,MAAM,UAAU,KAAK;AAAA,GAS5E,0BAAe,CAAC,OAAO,MAAM;AACpC,aAAW,UAAU;AAAW,UAAM,IAAI,qBAAqB,MAAM,WAAW,KAAK;AAAA;",
  "debugId": "5BDE0B4B2FE1B52064756e2164756e21",
  "names": []
}