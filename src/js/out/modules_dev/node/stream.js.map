{
  "version": 3,
  "sources": ["src/js/node/stream.js", "src/js/node/stream.js", "src/js/node/stream.js", "src/js/node/stream.js"],
  "sourcesContent": [
    "// Hardcoded module \"node:stream\" / \"readable-stream\"\n// \"readable-stream\" npm package\n// just transpiled\nvar { isPromise, isCallable, direct, Object } = import.meta.primordials;\n\nglobalThis.__IDS_TO_TRACK = process.env.DEBUG_TRACK_EE?.length\n  ? process.env.DEBUG_TRACK_EE.split(\",\")\n  : process.env.DEBUG_STREAMS?.length\n  ? process.env.DEBUG_STREAMS.split(\",\")\n  : null;\n\n// Separating DEBUG, DEBUG_STREAMS and DEBUG_TRACK_EE env vars makes it easier to focus on the\n// events in this file rather than all debug output across all files\n\n// You can include comma-delimited IDs as the value to either DEBUG_STREAMS or DEBUG_TRACK_EE and it will track\n// The events and/or all of the outputs for the given stream IDs assigned at stream construction\n// By default, child_process gives\n\nconst __TRACK_EE__ = !!process.env.DEBUG_TRACK_EE;\nconst __DEBUG__ = !!(process.env.DEBUG || process.env.DEBUG_STREAMS || __TRACK_EE__);\n\nvar debug = __DEBUG__\n  ? globalThis.__IDS_TO_TRACK\n    ? // If we are tracking IDs for debug event emitters, we should prefix the debug output with the ID\n      (...args) => {\n        const lastItem = args[args.length - 1];\n        if (!globalThis.__IDS_TO_TRACK.includes(lastItem)) return;\n        console.log(`ID: ${lastItem}`, ...args.slice(0, -1));\n      }\n    : (...args) => console.log(...args.slice(0, -1))\n  : () => {};\n\nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __ObjectSetPrototypeOf = Object.setPrototypeOf;\nvar __require = x => import.meta.require(x);\n\nvar _EE = __require(\"bun:events_native\");\n\nfunction DebugEventEmitter(opts) {\n  if (!(this instanceof DebugEventEmitter)) return new DebugEventEmitter(opts);\n  _EE.call(this, opts);\n  const __id = opts.__id;\n  if (__id) {\n    __defProp(this, \"__id\", {\n      value: __id,\n      readable: true,\n      writable: false,\n      enumerable: false,\n    });\n  }\n}\n\n__ObjectSetPrototypeOf(DebugEventEmitter.prototype, _EE.prototype);\n__ObjectSetPrototypeOf(DebugEventEmitter, _EE);\n\nDebugEventEmitter.prototype.emit = function (event, ...args) {\n  var __id = this.__id;\n  if (__id) {\n    debug(\"emit\", event, ...args, __id);\n  } else {\n    debug(\"emit\", event, ...args);\n  }\n  return _EE.prototype.emit.call(this, event, ...args);\n};\nDebugEventEmitter.prototype.on = function (event, handler) {\n  var __id = this.__id;\n  if (__id) {\n    debug(\"on\", event, \"added\", __id);\n  } else {\n    debug(\"on\", event, \"added\");\n  }\n  return _EE.prototype.on.call(this, event, handler);\n};\nDebugEventEmitter.prototype.addListener = function (event, handler) {\n  return this.on(event, handler);\n};\n\nvar __commonJS = (cb, mod) =>\n  function __require2() {\n    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;\n  };\nvar __copyProps = (to, from, except, desc) => {\n  if ((from && typeof from === \"object\") || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, {\n          get: () => from[key],\n          set: val => (from[key] = val),\n          enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable,\n          configurable: true,\n        });\n  }\n  return to;\n};\n\nvar runOnNextTick = process.nextTick;\n\nfunction isReadableStream(value) {\n  return typeof value === \"object\" && value !== null && value instanceof ReadableStream;\n}\n\nfunction validateBoolean(value, name) {\n  if (typeof value !== \"boolean\") throw new ERR_INVALID_ARG_TYPE(name, \"boolean\", value);\n}\n\n/**\n * @callback validateObject\n * @param {*} value\n * @param {string} name\n * @param {{\n *   allowArray?: boolean,\n *   allowFunction?: boolean,\n *   nullable?: boolean\n * }} [options]\n */\n\n/** @type {validateObject} */\nconst validateObject = (value, name, options = null) => {\n  const allowArray = options?.allowArray ?? false;\n  const allowFunction = options?.allowFunction ?? false;\n  const nullable = options?.nullable ?? false;\n  if (\n    (!nullable && value === null) ||\n    (!allowArray && ArrayIsArray(value)) ||\n    (typeof value !== \"object\" && (!allowFunction || typeof value !== \"function\"))\n  ) {\n    throw new ERR_INVALID_ARG_TYPE(name, \"Object\", value);\n  }\n};\n\n/**\n * @callback validateString\n * @param {*} value\n * @param {string} name\n * @returns {asserts value is string}\n */\n\n/** @type {validateString} */\nfunction validateString(value, name) {\n  if (typeof value !== \"string\") throw new ERR_INVALID_ARG_TYPE(name, \"string\", value);\n}\n\nvar ArrayIsArray = Array.isArray;\n\n//------------------------------------------------------------------------------\n// Node error polyfills\n//------------------------------------------------------------------------------\n\nfunction ERR_INVALID_ARG_TYPE(name, type, value) {\n  return new Error(`The argument '${name}' is invalid. Received '${value}' for type '${type}'`);\n}\n\nfunction ERR_INVALID_ARG_VALUE(name, value, reason) {\n  return new Error(`The value '${value}' is invalid for argument '${name}'. Reason: ${reason}`);\n}\n\n// node_modules/readable-stream/lib/ours/primordials.js\nvar require_primordials = __commonJS({\n  \"node_modules/readable-stream/lib/ours/primordials.js\"(exports, module) {\n    \"use strict\";\n    module.exports = {\n      ArrayIsArray(self) {\n        return Array.isArray(self);\n      },\n      ArrayPrototypeIncludes(self, el) {\n        return self.includes(el);\n      },\n      ArrayPrototypeIndexOf(self, el) {\n        return self.indexOf(el);\n      },\n      ArrayPrototypeJoin(self, sep) {\n        return self.join(sep);\n      },\n      ArrayPrototypeMap(self, fn) {\n        return self.map(fn);\n      },\n      ArrayPrototypePop(self, el) {\n        return self.pop(el);\n      },\n      ArrayPrototypePush(self, el) {\n        return self.push(el);\n      },\n      ArrayPrototypeSlice(self, start, end) {\n        return self.slice(start, end);\n      },\n      Error,\n      FunctionPrototypeCall(fn, thisArgs, ...args) {\n        return fn.call(thisArgs, ...args);\n      },\n      FunctionPrototypeSymbolHasInstance(self, instance) {\n        return Function.prototype[Symbol.hasInstance].call(self, instance);\n      },\n      MathFloor: Math.floor,\n      Number,\n      NumberIsInteger: Number.isInteger,\n      NumberIsNaN: Number.isNaN,\n      NumberMAX_SAFE_INTEGER: Number.MAX_SAFE_INTEGER,\n      NumberMIN_SAFE_INTEGER: Number.MIN_SAFE_INTEGER,\n      NumberParseInt: Number.parseInt,\n      ObjectDefineProperties(self, props) {\n        return Object.defineProperties(self, props);\n      },\n      ObjectDefineProperty(self, name, prop) {\n        return Object.defineProperty(self, name, prop);\n      },\n      ObjectGetOwnPropertyDescriptor(self, name) {\n        return Object.getOwnPropertyDescriptor(self, name);\n      },\n      ObjectKeys(obj) {\n        return Object.keys(obj);\n      },\n      ObjectSetPrototypeOf(target, proto) {\n        return Object.setPrototypeOf(target, proto);\n      },\n      Promise,\n      PromisePrototypeCatch(self, fn) {\n        return self.catch(fn);\n      },\n      PromisePrototypeThen(self, thenFn, catchFn) {\n        return self.then(thenFn, catchFn);\n      },\n      PromiseReject(err) {\n        return Promise.reject(err);\n      },\n      ReflectApply: Reflect.apply,\n      RegExpPrototypeTest(self, value) {\n        return self.test(value);\n      },\n      SafeSet: Set,\n      String,\n      StringPrototypeSlice(self, start, end) {\n        return self.slice(start, end);\n      },\n      StringPrototypeToLowerCase(self) {\n        return self.toLowerCase();\n      },\n      StringPrototypeToUpperCase(self) {\n        return self.toUpperCase();\n      },\n      StringPrototypeTrim(self) {\n        return self.trim();\n      },\n      Symbol,\n      SymbolAsyncIterator: Symbol.asyncIterator,\n      SymbolHasInstance: Symbol.hasInstance,\n      SymbolIterator: Symbol.iterator,\n      TypedArrayPrototypeSet(self, buf, len) {\n        return self.set(buf, len);\n      },\n      Uint8Array,\n    };\n  },\n});\n// node_modules/readable-stream/lib/ours/util.js\nvar require_util = __commonJS({\n  \"node_modules/readable-stream/lib/ours/util.js\"(exports, module) {\n    \"use strict\";\n    var bufferModule = __require(\"buffer\");\n    var AsyncFunction = Object.getPrototypeOf(async function () {}).constructor;\n    var Blob = globalThis.Blob || bufferModule.Blob;\n    var isBlob =\n      typeof Blob !== \"undefined\"\n        ? function isBlob2(b) {\n            return b instanceof Blob;\n          }\n        : function isBlob2(b) {\n            return false;\n          };\n    var AggregateError = class extends Error {\n      constructor(errors) {\n        if (!Array.isArray(errors)) {\n          throw new TypeError(`Expected input to be an Array, got ${typeof errors}`);\n        }\n        let message = \"\";\n        for (let i = 0; i < errors.length; i++) {\n          message += `    ${errors[i].stack}\n`;\n        }\n        super(message);\n        this.name = \"AggregateError\";\n        this.errors = errors;\n      }\n    };\n    module.exports = {\n      AggregateError,\n      once(callback) {\n        let called = false;\n        return function (...args) {\n          if (called) {\n            return;\n          }\n          called = true;\n          callback.apply(this, args);\n        };\n      },\n      createDeferredPromise: function () {\n        let resolve;\n        let reject;\n        const promise = new Promise((res, rej) => {\n          resolve = res;\n          reject = rej;\n        });\n        return {\n          promise,\n          resolve,\n          reject,\n        };\n      },\n      promisify(fn) {\n        return new Promise((resolve, reject) => {\n          fn((err, ...args) => {\n            if (err) {\n              return reject(err);\n            }\n            return resolve(...args);\n          });\n        });\n      },\n      debuglog() {\n        return function () {};\n      },\n      format(format, ...args) {\n        return format.replace(/%([sdifj])/g, function (...[_unused, type]) {\n          const replacement = args.shift();\n          if (type === \"f\") {\n            return replacement.toFixed(6);\n          } else if (type === \"j\") {\n            return JSON.stringify(replacement);\n          } else if (type === \"s\" && typeof replacement === \"object\") {\n            const ctor = replacement.constructor !== Object ? replacement.constructor.name : \"\";\n            return `${ctor} {}`.trim();\n          } else {\n            return replacement.toString();\n          }\n        });\n      },\n      inspect(value) {\n        switch (typeof value) {\n          case \"string\":\n            if (value.includes(\"'\")) {\n              if (!value.includes('\"')) {\n                return `\"${value}\"`;\n              } else if (!value.includes(\"`\") && !value.includes(\"${\")) {\n                return `\\`${value}\\``;\n              }\n            }\n            return `'${value}'`;\n          case \"number\":\n            if (isNaN(value)) {\n              return \"NaN\";\n            } else if (Object.is(value, -0)) {\n              return String(value);\n            }\n            return value;\n          case \"bigint\":\n            return `${String(value)}n`;\n          case \"boolean\":\n          case \"undefined\":\n            return String(value);\n          case \"object\":\n            return \"{}\";\n        }\n      },\n      types: {\n        isAsyncFunction(fn) {\n          return fn instanceof AsyncFunction;\n        },\n        isArrayBufferView(arr) {\n          return ArrayBuffer.isView(arr);\n        },\n      },\n      isBlob,\n    };\n    module.exports.promisify.custom = Symbol.for(\"nodejs.util.promisify.custom\");\n  },\n});\n\n// node_modules/readable-stream/lib/ours/errors.js\nvar require_errors = __commonJS({\n  \"node_modules/readable-stream/lib/ours/errors.js\"(exports, module) {\n    \"use strict\";\n    var { format, inspect, AggregateError: CustomAggregateError } = require_util();\n    var AggregateError = globalThis.AggregateError || CustomAggregateError;\n    var kIsNodeError = Symbol(\"kIsNodeError\");\n    var kTypes = [\"string\", \"function\", \"number\", \"object\", \"Function\", \"Object\", \"boolean\", \"bigint\", \"symbol\"];\n    var classRegExp = /^([A-Z][a-z0-9]*)+$/;\n    var nodeInternalPrefix = \"__node_internal_\";\n    var codes = {};\n    function assert(value, message) {\n      if (!value) {\n        throw new codes.ERR_INTERNAL_ASSERTION(message);\n      }\n    }\n    function addNumericalSeparator(val) {\n      let res = \"\";\n      let i = val.length;\n      const start = val[0] === \"-\" ? 1 : 0;\n      for (; i >= start + 4; i -= 3) {\n        res = `_${val.slice(i - 3, i)}${res}`;\n      }\n      return `${val.slice(0, i)}${res}`;\n    }\n    function getMessage(key, msg, args) {\n      if (typeof msg === \"function\") {\n        assert(\n          msg.length <= args.length,\n          `Code: ${key}; The provided arguments length (${args.length}) does not match the required ones (${msg.length}).`,\n        );\n        return msg(...args);\n      }\n      const expectedLength = (msg.match(/%[dfijoOs]/g) || []).length;\n      assert(\n        expectedLength === args.length,\n        `Code: ${key}; The provided arguments length (${args.length}) does not match the required ones (${expectedLength}).`,\n      );\n      if (args.length === 0) {\n        return msg;\n      }\n      return format(msg, ...args);\n    }\n    function E(code, message, Base) {\n      if (!Base) {\n        Base = Error;\n      }\n      class NodeError extends Base {\n        constructor(...args) {\n          super(getMessage(code, message, args));\n        }\n        toString() {\n          return `${this.name} [${code}]: ${this.message}`;\n        }\n      }\n      Object.defineProperties(NodeError.prototype, {\n        name: {\n          value: Base.name,\n          writable: true,\n          enumerable: false,\n          configurable: true,\n        },\n        toString: {\n          value() {\n            return `${this.name} [${code}]: ${this.message}`;\n          },\n          writable: true,\n          enumerable: false,\n          configurable: true,\n        },\n      });\n      NodeError.prototype.code = code;\n      NodeError.prototype[kIsNodeError] = true;\n      codes[code] = NodeError;\n    }\n    function hideStackFrames(fn) {\n      const hidden = nodeInternalPrefix + fn.name;\n      Object.defineProperty(fn, \"name\", {\n        value: hidden,\n      });\n      return fn;\n    }\n    function aggregateTwoErrors(innerError, outerError) {\n      if (innerError && outerError && innerError !== outerError) {\n        if (Array.isArray(outerError.errors)) {\n          outerError.errors.push(innerError);\n          return outerError;\n        }\n        const err = new AggregateError([outerError, innerError], outerError.message);\n        err.code = outerError.code;\n        return err;\n      }\n      return innerError || outerError;\n    }\n    var AbortError = class extends Error {\n      constructor(message = \"The operation was aborted\", options = void 0) {\n        if (options !== void 0 && typeof options !== \"object\") {\n          throw new codes.ERR_INVALID_ARG_TYPE(\"options\", \"Object\", options);\n        }\n        super(message, options);\n        this.code = \"ABORT_ERR\";\n        this.name = \"AbortError\";\n      }\n    };\n    E(\"ERR_ASSERTION\", \"%s\", Error);\n    E(\n      \"ERR_INVALID_ARG_TYPE\",\n      (name, expected, actual) => {\n        assert(typeof name === \"string\", \"'name' must be a string\");\n        if (!Array.isArray(expected)) {\n          expected = [expected];\n        }\n        let msg = \"The \";\n        if (name.endsWith(\" argument\")) {\n          msg += `${name} `;\n        } else {\n          msg += `\"${name}\" ${name.includes(\".\") ? \"property\" : \"argument\"} `;\n        }\n        msg += \"must be \";\n        const types = [];\n        const instances = [];\n        const other = [];\n        for (const value of expected) {\n          assert(typeof value === \"string\", \"All expected entries have to be of type string\");\n          if (kTypes.includes(value)) {\n            types.push(value.toLowerCase());\n          } else if (classRegExp.test(value)) {\n            instances.push(value);\n          } else {\n            assert(value !== \"object\", 'The value \"object\" should be written as \"Object\"');\n            other.push(value);\n          }\n        }\n        if (instances.length > 0) {\n          const pos = types.indexOf(\"object\");\n          if (pos !== -1) {\n            types.splice(types, pos, 1);\n            instances.push(\"Object\");\n          }\n        }\n        if (types.length > 0) {\n          switch (types.length) {\n            case 1:\n              msg += `of type ${types[0]}`;\n              break;\n            case 2:\n              msg += `one of type ${types[0]} or ${types[1]}`;\n              break;\n            default: {\n              const last = types.pop();\n              msg += `one of type ${types.join(\", \")}, or ${last}`;\n            }\n          }\n          if (instances.length > 0 || other.length > 0) {\n            msg += \" or \";\n          }\n        }\n        if (instances.length > 0) {\n          switch (instances.length) {\n            case 1:\n              msg += `an instance of ${instances[0]}`;\n              break;\n            case 2:\n              msg += `an instance of ${instances[0]} or ${instances[1]}`;\n              break;\n            default: {\n              const last = instances.pop();\n              msg += `an instance of ${instances.join(\", \")}, or ${last}`;\n            }\n          }\n          if (other.length > 0) {\n            msg += \" or \";\n          }\n        }\n        switch (other.length) {\n          case 0:\n            break;\n          case 1:\n            if (other[0].toLowerCase() !== other[0]) {\n              msg += \"an \";\n            }\n            msg += `${other[0]}`;\n            break;\n          case 2:\n            msg += `one of ${other[0]} or ${other[1]}`;\n            break;\n          default: {\n            const last = other.pop();\n            msg += `one of ${other.join(\", \")}, or ${last}`;\n          }\n        }\n        if (actual == null) {\n          msg += `. Received ${actual}`;\n        } else if (typeof actual === \"function\" && actual.name) {\n          msg += `. Received function ${actual.name}`;\n        } else if (typeof actual === \"object\") {\n          var _actual$constructor;\n          if (\n            (_actual$constructor = actual.constructor) !== null &&\n            _actual$constructor !== void 0 &&\n            _actual$constructor.name\n          ) {\n            msg += `. Received an instance of ${actual.constructor.name}`;\n          } else {\n            const inspected = inspect(actual, {\n              depth: -1,\n            });\n            msg += `. Received ${inspected}`;\n          }\n        } else {\n          let inspected = inspect(actual, {\n            colors: false,\n          });\n          if (inspected.length > 25) {\n            inspected = `${inspected.slice(0, 25)}...`;\n          }\n          msg += `. Received type ${typeof actual} (${inspected})`;\n        }\n        return msg;\n      },\n      TypeError,\n    );\n    E(\n      \"ERR_INVALID_ARG_VALUE\",\n      (name, value, reason = \"is invalid\") => {\n        let inspected = inspect(value);\n        if (inspected.length > 128) {\n          inspected = inspected.slice(0, 128) + \"...\";\n        }\n        const type = name.includes(\".\") ? \"property\" : \"argument\";\n        return `The ${type} '${name}' ${reason}. Received ${inspected}`;\n      },\n      TypeError,\n    );\n    E(\n      \"ERR_INVALID_RETURN_VALUE\",\n      (input, name, value) => {\n        var _value$constructor;\n        const type =\n          value !== null &&\n          value !== void 0 &&\n          (_value$constructor = value.constructor) !== null &&\n          _value$constructor !== void 0 &&\n          _value$constructor.name\n            ? `instance of ${value.constructor.name}`\n            : `type ${typeof value}`;\n        return `Expected ${input} to be returned from the \"${name}\" function but got ${type}.`;\n      },\n      TypeError,\n    );\n    E(\n      \"ERR_MISSING_ARGS\",\n      (...args) => {\n        assert(args.length > 0, \"At least one arg needs to be specified\");\n        let msg;\n        const len = args.length;\n        args = (Array.isArray(args) ? args : [args]).map(a => `\"${a}\"`).join(\" or \");\n        switch (len) {\n          case 1:\n            msg += `The ${args[0]} argument`;\n            break;\n          case 2:\n            msg += `The ${args[0]} and ${args[1]} arguments`;\n            break;\n          default:\n            {\n              const last = args.pop();\n              msg += `The ${args.join(\", \")}, and ${last} arguments`;\n            }\n            break;\n        }\n        return `${msg} must be specified`;\n      },\n      TypeError,\n    );\n    E(\n      \"ERR_OUT_OF_RANGE\",\n      (str, range, input) => {\n        assert(range, 'Missing \"range\" argument');\n        let received;\n        if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {\n          received = addNumericalSeparator(String(input));\n        } else if (typeof input === \"bigint\") {\n          received = String(input);\n          if (input > 2n ** 32n || input < -(2n ** 32n)) {\n            received = addNumericalSeparator(received);\n          }\n          received += \"n\";\n        } else {\n          received = inspect(input);\n        }\n        return `The value of \"${str}\" is out of range. It must be ${range}. Received ${received}`;\n      },\n      RangeError,\n    );\n    E(\"ERR_MULTIPLE_CALLBACK\", \"Callback called multiple times\", Error);\n    E(\"ERR_METHOD_NOT_IMPLEMENTED\", \"The %s method is not implemented\", Error);\n    E(\"ERR_STREAM_ALREADY_FINISHED\", \"Cannot call %s after a stream was finished\", Error);\n    E(\"ERR_STREAM_CANNOT_PIPE\", \"Cannot pipe, not readable\", Error);\n    E(\"ERR_STREAM_DESTROYED\", \"Cannot call %s after a stream was destroyed\", Error);\n    E(\"ERR_STREAM_NULL_VALUES\", \"May not write null values to stream\", TypeError);\n    E(\"ERR_STREAM_PREMATURE_CLOSE\", \"Premature close\", Error);\n    E(\"ERR_STREAM_PUSH_AFTER_EOF\", \"stream.push() after EOF\", Error);\n    E(\"ERR_STREAM_UNSHIFT_AFTER_END_EVENT\", \"stream.unshift() after end event\", Error);\n    E(\"ERR_STREAM_WRITE_AFTER_END\", \"write after end\", Error);\n    E(\"ERR_UNKNOWN_ENCODING\", \"Unknown encoding: %s\", TypeError);\n    module.exports = {\n      AbortError,\n      aggregateTwoErrors: hideStackFrames(aggregateTwoErrors),\n      hideStackFrames,\n      codes,\n    };\n  },\n});\n\n// node_modules/readable-stream/lib/internal/validators.js\nvar require_validators = __commonJS({\n  \"node_modules/readable-stream/lib/internal/validators.js\"(exports, module) {\n    \"use strict\";\n    var {\n      ArrayIsArray,\n      ArrayPrototypeIncludes,\n      ArrayPrototypeJoin,\n      ArrayPrototypeMap,\n      NumberIsInteger,\n      NumberMAX_SAFE_INTEGER,\n      NumberMIN_SAFE_INTEGER,\n      NumberParseInt,\n      RegExpPrototypeTest,\n      String: String2,\n      StringPrototypeToUpperCase,\n      StringPrototypeTrim,\n    } = require_primordials();\n    var {\n      hideStackFrames,\n      codes: { ERR_SOCKET_BAD_PORT, ERR_INVALID_ARG_TYPE, ERR_INVALID_ARG_VALUE, ERR_OUT_OF_RANGE, ERR_UNKNOWN_SIGNAL },\n    } = require_errors();\n    var { normalizeEncoding } = require_util();\n    var { isAsyncFunction, isArrayBufferView } = require_util().types;\n    var signals = {};\n    function isInt32(value) {\n      return value === (value | 0);\n    }\n    function isUint32(value) {\n      return value === value >>> 0;\n    }\n    var octalReg = /^[0-7]+$/;\n    var modeDesc = \"must be a 32-bit unsigned integer or an octal string\";\n    function parseFileMode(value, name, def) {\n      if (typeof value === \"undefined\") {\n        value = def;\n      }\n      if (typeof value === \"string\") {\n        if (!RegExpPrototypeTest(octalReg, value)) {\n          throw new ERR_INVALID_ARG_VALUE(name, value, modeDesc);\n        }\n        value = NumberParseInt(value, 8);\n      }\n      validateInt32(value, name, 0, 2 ** 32 - 1);\n      return value;\n    }\n    var validateInteger = hideStackFrames((value, name, min = NumberMIN_SAFE_INTEGER, max = NumberMAX_SAFE_INTEGER) => {\n      if (typeof value !== \"number\") throw new ERR_INVALID_ARG_TYPE(name, \"number\", value);\n      if (!NumberIsInteger(value)) throw new ERR_OUT_OF_RANGE(name, \"an integer\", value);\n      if (value < min || value > max) throw new ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value);\n    });\n    var validateInt32 = hideStackFrames((value, name, min = -2147483648, max = 2147483647) => {\n      if (typeof value !== \"number\") {\n        throw new ERR_INVALID_ARG_TYPE(name, \"number\", value);\n      }\n      if (!isInt32(value)) {\n        if (!NumberIsInteger(value)) {\n          throw new ERR_OUT_OF_RANGE(name, \"an integer\", value);\n        }\n        throw new ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value);\n      }\n      if (value < min || value > max) {\n        throw new ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value);\n      }\n    });\n    var validateUint32 = hideStackFrames((value, name, positive) => {\n      if (typeof value !== \"number\") {\n        throw new ERR_INVALID_ARG_TYPE(name, \"number\", value);\n      }\n      if (!isUint32(value)) {\n        if (!NumberIsInteger(value)) {\n          throw new ERR_OUT_OF_RANGE(name, \"an integer\", value);\n        }\n        const min = positive ? 1 : 0;\n        throw new ERR_OUT_OF_RANGE(name, `>= ${min} && < 4294967296`, value);\n      }\n      if (positive && value === 0) {\n        throw new ERR_OUT_OF_RANGE(name, \">= 1 && < 4294967296\", value);\n      }\n    });\n    function validateString(value, name) {\n      if (typeof value !== \"string\") throw new ERR_INVALID_ARG_TYPE(name, \"string\", value);\n    }\n    function validateNumber(value, name) {\n      if (typeof value !== \"number\") throw new ERR_INVALID_ARG_TYPE(name, \"number\", value);\n    }\n    var validateOneOf = hideStackFrames((value, name, oneOf) => {\n      if (!ArrayPrototypeIncludes(oneOf, value)) {\n        const allowed = ArrayPrototypeJoin(\n          ArrayPrototypeMap(oneOf, v => (typeof v === \"string\" ? `'${v}'` : String2(v))),\n          \", \",\n        );\n        const reason = \"must be one of: \" + allowed;\n        throw new ERR_INVALID_ARG_VALUE(name, value, reason);\n      }\n    });\n    function validateBoolean(value, name) {\n      if (typeof value !== \"boolean\") throw new ERR_INVALID_ARG_TYPE(name, \"boolean\", value);\n    }\n    var validateObject = hideStackFrames((value, name, options) => {\n      const useDefaultOptions = options == null;\n      const allowArray = useDefaultOptions ? false : options.allowArray;\n      const allowFunction = useDefaultOptions ? false : options.allowFunction;\n      const nullable = useDefaultOptions ? false : options.nullable;\n      if (\n        (!nullable && value === null) ||\n        (!allowArray && ArrayIsArray(value)) ||\n        (typeof value !== \"object\" && (!allowFunction || typeof value !== \"function\"))\n      ) {\n        throw new ERR_INVALID_ARG_TYPE(name, \"Object\", value);\n      }\n    });\n    var validateArray = hideStackFrames((value, name, minLength = 0) => {\n      if (!ArrayIsArray(value)) {\n        throw new ERR_INVALID_ARG_TYPE(name, \"Array\", value);\n      }\n      if (value.length < minLength) {\n        const reason = `must be longer than ${minLength}`;\n        throw new ERR_INVALID_ARG_VALUE(name, value, reason);\n      }\n    });\n    function validateSignalName(signal, name = \"signal\") {\n      validateString(signal, name);\n      if (signals[signal] === void 0) {\n        if (signals[StringPrototypeToUpperCase(signal)] !== void 0) {\n          throw new ERR_UNKNOWN_SIGNAL(signal + \" (signals must use all capital letters)\");\n        }\n        throw new ERR_UNKNOWN_SIGNAL(signal);\n      }\n    }\n    var validateBuffer = hideStackFrames((buffer, name = \"buffer\") => {\n      if (!isArrayBufferView(buffer)) {\n        throw new ERR_INVALID_ARG_TYPE(name, [\"Buffer\", \"TypedArray\", \"DataView\"], buffer);\n      }\n    });\n    function validateEncoding(data, encoding) {\n      const normalizedEncoding = normalizeEncoding(encoding);\n      const length = data.length;\n      if (normalizedEncoding === \"hex\" && length % 2 !== 0) {\n        throw new ERR_INVALID_ARG_VALUE(\"encoding\", encoding, `is invalid for data of length ${length}`);\n      }\n    }\n    function validatePort(port, name = \"Port\", allowZero = true) {\n      if (\n        (typeof port !== \"number\" && typeof port !== \"string\") ||\n        (typeof port === \"string\" && StringPrototypeTrim(port).length === 0) ||\n        +port !== +port >>> 0 ||\n        port > 65535 ||\n        (port === 0 && !allowZero)\n      ) {\n        throw new ERR_SOCKET_BAD_PORT(name, port, allowZero);\n      }\n      return port | 0;\n    }\n    var validateAbortSignal = hideStackFrames((signal, name) => {\n      if (signal !== void 0 && (signal === null || typeof signal !== \"object\" || !(\"aborted\" in signal))) {\n        throw new ERR_INVALID_ARG_TYPE(name, \"AbortSignal\", signal);\n      }\n    });\n    var validateFunction = hideStackFrames((value, name) => {\n      if (typeof value !== \"function\") throw new ERR_INVALID_ARG_TYPE(name, \"Function\", value);\n    });\n    var validatePlainFunction = hideStackFrames((value, name) => {\n      if (typeof value !== \"function\" || isAsyncFunction(value))\n        throw new ERR_INVALID_ARG_TYPE(name, \"Function\", value);\n    });\n    var validateUndefined = hideStackFrames((value, name) => {\n      if (value !== void 0) throw new ERR_INVALID_ARG_TYPE(name, \"undefined\", value);\n    });\n    module.exports = {\n      isInt32,\n      isUint32,\n      parseFileMode,\n      validateArray,\n      validateBoolean,\n      validateBuffer,\n      validateEncoding,\n      validateFunction,\n      validateInt32,\n      validateInteger,\n      validateNumber,\n      validateObject,\n      validateOneOf,\n      validatePlainFunction,\n      validatePort,\n      validateSignalName,\n      validateString,\n      validateUint32,\n      validateUndefined,\n      validateAbortSignal,\n    };\n  },\n});\n\n// node_modules/readable-stream/lib/internal/streams/utils.js\nvar require_utils = __commonJS({\n  \"node_modules/readable-stream/lib/internal/streams/utils.js\"(exports, module) {\n    \"use strict\";\n    var { Symbol: Symbol2, SymbolAsyncIterator, SymbolIterator } = require_primordials();\n    var kDestroyed = Symbol2(\"kDestroyed\");\n    var kIsErrored = Symbol2(\"kIsErrored\");\n    var kIsReadable = Symbol2(\"kIsReadable\");\n    var kIsDisturbed = Symbol2(\"kIsDisturbed\");\n    function isReadableNodeStream(obj, strict = false) {\n      var _obj$_readableState;\n      return !!(\n        obj &&\n        typeof obj.pipe === \"function\" &&\n        typeof obj.on === \"function\" &&\n        (!strict || (typeof obj.pause === \"function\" && typeof obj.resume === \"function\")) &&\n        (!obj._writableState ||\n          ((_obj$_readableState = obj._readableState) === null || _obj$_readableState === void 0\n            ? void 0\n            : _obj$_readableState.readable) !== false) &&\n        (!obj._writableState || obj._readableState)\n      );\n    }\n    function isWritableNodeStream(obj) {\n      var _obj$_writableState;\n      return !!(\n        obj &&\n        typeof obj.write === \"function\" &&\n        typeof obj.on === \"function\" &&\n        (!obj._readableState ||\n          ((_obj$_writableState = obj._writableState) === null || _obj$_writableState === void 0\n            ? void 0\n            : _obj$_writableState.writable) !== false)\n      );\n    }\n    function isDuplexNodeStream(obj) {\n      return !!(\n        obj &&\n        typeof obj.pipe === \"function\" &&\n        obj._readableState &&\n        typeof obj.on === \"function\" &&\n        typeof obj.write === \"function\"\n      );\n    }\n    function isNodeStream(obj) {\n      return (\n        obj &&\n        (obj._readableState ||\n          obj._writableState ||\n          (typeof obj.write === \"function\" && typeof obj.on === \"function\") ||\n          (typeof obj.pipe === \"function\" && typeof obj.on === \"function\"))\n      );\n    }\n    function isIterable(obj, isAsync) {\n      if (obj == null) return false;\n      if (isAsync === true) return typeof obj[SymbolAsyncIterator] === \"function\";\n      if (isAsync === false) return typeof obj[SymbolIterator] === \"function\";\n      return typeof obj[SymbolAsyncIterator] === \"function\" || typeof obj[SymbolIterator] === \"function\";\n    }\n    function isDestroyed(stream) {\n      if (!isNodeStream(stream)) return null;\n      const wState = stream._writableState;\n      const rState = stream._readableState;\n      const state = wState || rState;\n      return !!(stream.destroyed || stream[kDestroyed] || (state !== null && state !== void 0 && state.destroyed));\n    }\n    function isWritableEnded(stream) {\n      if (!isWritableNodeStream(stream)) return null;\n      if (stream.writableEnded === true) return true;\n      const wState = stream._writableState;\n      if (wState !== null && wState !== void 0 && wState.errored) return false;\n      if (typeof (wState === null || wState === void 0 ? void 0 : wState.ended) !== \"boolean\") return null;\n      return wState.ended;\n    }\n    function isWritableFinished(stream, strict) {\n      if (!isWritableNodeStream(stream)) return null;\n      if (stream.writableFinished === true) return true;\n      const wState = stream._writableState;\n      if (wState !== null && wState !== void 0 && wState.errored) return false;\n      if (typeof (wState === null || wState === void 0 ? void 0 : wState.finished) !== \"boolean\") return null;\n      return !!(wState.finished || (strict === false && wState.ended === true && wState.length === 0));\n    }\n    function isReadableEnded(stream) {\n      if (!isReadableNodeStream(stream)) return null;\n      if (stream.readableEnded === true) return true;\n      const rState = stream._readableState;\n      if (!rState || rState.errored) return false;\n      if (typeof (rState === null || rState === void 0 ? void 0 : rState.ended) !== \"boolean\") return null;\n      return rState.ended;\n    }\n    function isReadableFinished(stream, strict) {\n      if (!isReadableNodeStream(stream)) return null;\n      const rState = stream._readableState;\n      if (rState !== null && rState !== void 0 && rState.errored) return false;\n      if (typeof (rState === null || rState === void 0 ? void 0 : rState.endEmitted) !== \"boolean\") return null;\n      return !!(rState.endEmitted || (strict === false && rState.ended === true && rState.length === 0));\n    }\n    function isReadable(stream) {\n      if (stream && stream[kIsReadable] != null) return stream[kIsReadable];\n      if (typeof (stream === null || stream === void 0 ? void 0 : stream.readable) !== \"boolean\") return null;\n      if (isDestroyed(stream)) return false;\n      return isReadableNodeStream(stream) && stream.readable && !isReadableFinished(stream);\n    }\n    function isWritable(stream) {\n      if (typeof (stream === null || stream === void 0 ? void 0 : stream.writable) !== \"boolean\") return null;\n      if (isDestroyed(stream)) return false;\n      return isWritableNodeStream(stream) && stream.writable && !isWritableEnded(stream);\n    }\n    function isFinished(stream, opts) {\n      if (!isNodeStream(stream)) {\n        return null;\n      }\n      if (isDestroyed(stream)) {\n        return true;\n      }\n      if ((opts === null || opts === void 0 ? void 0 : opts.readable) !== false && isReadable(stream)) {\n        return false;\n      }\n      if ((opts === null || opts === void 0 ? void 0 : opts.writable) !== false && isWritable(stream)) {\n        return false;\n      }\n      return true;\n    }\n    function isWritableErrored(stream) {\n      var _stream$_writableStat, _stream$_writableStat2;\n      if (!isNodeStream(stream)) {\n        return null;\n      }\n      if (stream.writableErrored) {\n        return stream.writableErrored;\n      }\n      return (_stream$_writableStat =\n        (_stream$_writableStat2 = stream._writableState) === null || _stream$_writableStat2 === void 0\n          ? void 0\n          : _stream$_writableStat2.errored) !== null && _stream$_writableStat !== void 0\n        ? _stream$_writableStat\n        : null;\n    }\n    function isReadableErrored(stream) {\n      var _stream$_readableStat, _stream$_readableStat2;\n      if (!isNodeStream(stream)) {\n        return null;\n      }\n      if (stream.readableErrored) {\n        return stream.readableErrored;\n      }\n      return (_stream$_readableStat =\n        (_stream$_readableStat2 = stream._readableState) === null || _stream$_readableStat2 === void 0\n          ? void 0\n          : _stream$_readableStat2.errored) !== null && _stream$_readableStat !== void 0\n        ? _stream$_readableStat\n        : null;\n    }\n    function isClosed(stream) {\n      if (!isNodeStream(stream)) {\n        return null;\n      }\n      if (typeof stream.closed === \"boolean\") {\n        return stream.closed;\n      }\n      const wState = stream._writableState;\n      const rState = stream._readableState;\n      if (\n        typeof (wState === null || wState === void 0 ? void 0 : wState.closed) === \"boolean\" ||\n        typeof (rState === null || rState === void 0 ? void 0 : rState.closed) === \"boolean\"\n      ) {\n        return (\n          (wState === null || wState === void 0 ? void 0 : wState.closed) ||\n          (rState === null || rState === void 0 ? void 0 : rState.closed)\n        );\n      }\n      if (typeof stream._closed === \"boolean\" && isOutgoingMessage(stream)) {\n        return stream._closed;\n      }\n      return null;\n    }\n    function isOutgoingMessage(stream) {\n      return (\n        typeof stream._closed === \"boolean\" &&\n        typeof stream._defaultKeepAlive === \"boolean\" &&\n        typeof stream._removedConnection === \"boolean\" &&\n        typeof stream._removedContLen === \"boolean\"\n      );\n    }\n    function isServerResponse(stream) {\n      return typeof stream._sent100 === \"boolean\" && isOutgoingMessage(stream);\n    }\n    function isServerRequest(stream) {\n      var _stream$req;\n      return (\n        typeof stream._consuming === \"boolean\" &&\n        typeof stream._dumped === \"boolean\" &&\n        ((_stream$req = stream.req) === null || _stream$req === void 0 ? void 0 : _stream$req.upgradeOrConnect) ===\n          void 0\n      );\n    }\n    function willEmitClose(stream) {\n      if (!isNodeStream(stream)) return null;\n      const wState = stream._writableState;\n      const rState = stream._readableState;\n      const state = wState || rState;\n      return (\n        (!state && isServerResponse(stream)) ||\n        !!(state && state.autoDestroy && state.emitClose && state.closed === false)\n      );\n    }\n    function isDisturbed(stream) {\n      var _stream$kIsDisturbed;\n      return !!(\n        stream &&\n        ((_stream$kIsDisturbed = stream[kIsDisturbed]) !== null && _stream$kIsDisturbed !== void 0\n          ? _stream$kIsDisturbed\n          : stream.readableDidRead || stream.readableAborted)\n      );\n    }\n    function isErrored(stream) {\n      var _ref,\n        _ref2,\n        _ref3,\n        _ref4,\n        _ref5,\n        _stream$kIsErrored,\n        _stream$_readableStat3,\n        _stream$_writableStat3,\n        _stream$_readableStat4,\n        _stream$_writableStat4;\n      return !!(\n        stream &&\n        ((_ref =\n          (_ref2 =\n            (_ref3 =\n              (_ref4 =\n                (_ref5 =\n                  (_stream$kIsErrored = stream[kIsErrored]) !== null && _stream$kIsErrored !== void 0\n                    ? _stream$kIsErrored\n                    : stream.readableErrored) !== null && _ref5 !== void 0\n                  ? _ref5\n                  : stream.writableErrored) !== null && _ref4 !== void 0\n                ? _ref4\n                : (_stream$_readableStat3 = stream._readableState) === null || _stream$_readableStat3 === void 0\n                ? void 0\n                : _stream$_readableStat3.errorEmitted) !== null && _ref3 !== void 0\n              ? _ref3\n              : (_stream$_writableStat3 = stream._writableState) === null || _stream$_writableStat3 === void 0\n              ? void 0\n              : _stream$_writableStat3.errorEmitted) !== null && _ref2 !== void 0\n            ? _ref2\n            : (_stream$_readableStat4 = stream._readableState) === null || _stream$_readableStat4 === void 0\n            ? void 0\n            : _stream$_readableStat4.errored) !== null && _ref !== void 0\n          ? _ref\n          : (_stream$_writableStat4 = stream._writableState) === null || _stream$_writableStat4 === void 0\n          ? void 0\n          : _stream$_writableStat4.errored)\n      );\n    }\n    module.exports = {\n      kDestroyed,\n      isDisturbed,\n      kIsDisturbed,\n      isErrored,\n      kIsErrored,\n      isReadable,\n      kIsReadable,\n      isClosed,\n      isDestroyed,\n      isDuplexNodeStream,\n      isFinished,\n      isIterable,\n      isReadableNodeStream,\n      isReadableEnded,\n      isReadableFinished,\n      isReadableErrored,\n      isNodeStream,\n      isWritable,\n      isWritableNodeStream,\n      isWritableEnded,\n      isWritableFinished,\n      isWritableErrored,\n      isServerRequest,\n      isServerResponse,\n      willEmitClose,\n    };\n  },\n});\n\n// node_modules/readable-stream/lib/internal/streams/end-of-stream.js\nvar require_end_of_stream = __commonJS({\n  \"node_modules/readable-stream/lib/internal/streams/end-of-stream.js\"(exports, module) {\n    \"use strict\";\n    var { AbortError, codes } = require_errors();\n    var { ERR_INVALID_ARG_TYPE, ERR_STREAM_PREMATURE_CLOSE } = codes;\n    var { once } = require_util();\n    var { validateAbortSignal, validateFunction, validateObject } = require_validators();\n    var { Promise: Promise2 } = require_primordials();\n    var {\n      isClosed,\n      isReadable,\n      isReadableNodeStream,\n      isReadableFinished,\n      isReadableErrored,\n      isWritable,\n      isWritableNodeStream,\n      isWritableFinished,\n      isWritableErrored,\n      isNodeStream,\n      willEmitClose: _willEmitClose,\n    } = require_utils();\n    function isRequest(stream) {\n      return stream.setHeader && typeof stream.abort === \"function\";\n    }\n    var nop = () => {};\n    function eos(stream, options, callback) {\n      var _options$readable, _options$writable;\n      if (arguments.length === 2) {\n        callback = options;\n        options = {};\n      } else if (options == null) {\n        options = {};\n      } else {\n        validateObject(options, \"options\");\n      }\n      validateFunction(callback, \"callback\");\n      validateAbortSignal(options.signal, \"options.signal\");\n      callback = once(callback);\n      const readable =\n        (_options$readable = options.readable) !== null && _options$readable !== void 0\n          ? _options$readable\n          : isReadableNodeStream(stream);\n      const writable =\n        (_options$writable = options.writable) !== null && _options$writable !== void 0\n          ? _options$writable\n          : isWritableNodeStream(stream);\n      if (!isNodeStream(stream)) {\n        throw new ERR_INVALID_ARG_TYPE(\"stream\", \"Stream\", stream);\n      }\n      const wState = stream._writableState;\n      const rState = stream._readableState;\n      const onlegacyfinish = () => {\n        if (!stream.writable) {\n          onfinish();\n        }\n      };\n      let willEmitClose =\n        _willEmitClose(stream) &&\n        isReadableNodeStream(stream) === readable &&\n        isWritableNodeStream(stream) === writable;\n      let writableFinished = isWritableFinished(stream, false);\n      const onfinish = () => {\n        writableFinished = true;\n        if (stream.destroyed) {\n          willEmitClose = false;\n        }\n        if (willEmitClose && (!stream.readable || readable)) {\n          return;\n        }\n        if (!readable || readableFinished) {\n          callback.call(stream);\n        }\n      };\n      let readableFinished = isReadableFinished(stream, false);\n      const onend = () => {\n        readableFinished = true;\n        if (stream.destroyed) {\n          willEmitClose = false;\n        }\n        if (willEmitClose && (!stream.writable || writable)) {\n          return;\n        }\n        if (!writable || writableFinished) {\n          callback.call(stream);\n        }\n      };\n      const onerror = err => {\n        callback.call(stream, err);\n      };\n      let closed = isClosed(stream);\n      const onclose = () => {\n        closed = true;\n        const errored = isWritableErrored(stream) || isReadableErrored(stream);\n        if (errored && typeof errored !== \"boolean\") {\n          return callback.call(stream, errored);\n        }\n        if (readable && !readableFinished && isReadableNodeStream(stream, true)) {\n          if (!isReadableFinished(stream, false)) return callback.call(stream, new ERR_STREAM_PREMATURE_CLOSE());\n        }\n        if (writable && !writableFinished) {\n          if (!isWritableFinished(stream, false)) return callback.call(stream, new ERR_STREAM_PREMATURE_CLOSE());\n        }\n        callback.call(stream);\n      };\n      const onrequest = () => {\n        stream.req.on(\"finish\", onfinish);\n      };\n      if (isRequest(stream)) {\n        stream.on(\"complete\", onfinish);\n        if (!willEmitClose) {\n          stream.on(\"abort\", onclose);\n        }\n        if (stream.req) {\n          onrequest();\n        } else {\n          stream.on(\"request\", onrequest);\n        }\n      } else if (writable && !wState) {\n        stream.on(\"end\", onlegacyfinish);\n        stream.on(\"close\", onlegacyfinish);\n      }\n      if (!willEmitClose && typeof stream.aborted === \"boolean\") {\n        stream.on(\"aborted\", onclose);\n      }\n      stream.on(\"end\", onend);\n      stream.on(\"finish\", onfinish);\n      if (options.error !== false) {\n        stream.on(\"error\", onerror);\n      }\n      stream.on(\"close\", onclose);\n      if (closed) {\n        runOnNextTick(onclose);\n      } else if (\n        (wState !== null && wState !== void 0 && wState.errorEmitted) ||\n        (rState !== null && rState !== void 0 && rState.errorEmitted)\n      ) {\n        if (!willEmitClose) {\n          runOnNextTick(onclose);\n        }\n      } else if (\n        !readable &&\n        (!willEmitClose || isReadable(stream)) &&\n        (writableFinished || isWritable(stream) === false)\n      ) {\n        runOnNextTick(onclose);\n      } else if (\n        !writable &&\n        (!willEmitClose || isWritable(stream)) &&\n        (readableFinished || isReadable(stream) === false)\n      ) {\n        runOnNextTick(onclose);\n      } else if (rState && stream.req && stream.aborted) {\n        runOnNextTick(onclose);\n      }\n      const cleanup = () => {\n        callback = nop;\n        stream.removeListener(\"aborted\", onclose);\n        stream.removeListener(\"complete\", onfinish);\n        stream.removeListener(\"abort\", onclose);\n        stream.removeListener(\"request\", onrequest);\n        if (stream.req) stream.req.removeListener(\"finish\", onfinish);\n        stream.removeListener(\"end\", onlegacyfinish);\n        stream.removeListener(\"close\", onlegacyfinish);\n        stream.removeListener(\"finish\", onfinish);\n        stream.removeListener(\"end\", onend);\n        stream.removeListener(\"error\", onerror);\n        stream.removeListener(\"close\", onclose);\n      };\n      if (options.signal && !closed) {\n        const abort = () => {\n          const endCallback = callback;\n          cleanup();\n          endCallback.call(\n            stream,\n            new AbortError(void 0, {\n              cause: options.signal.reason,\n            }),\n          );\n        };\n        if (options.signal.aborted) {\n          runOnNextTick(abort);\n        } else {\n          const originalCallback = callback;\n          callback = once((...args) => {\n            options.signal.removeEventListener(\"abort\", abort);\n            originalCallback.apply(stream, args);\n          });\n          options.signal.addEventListener(\"abort\", abort);\n        }\n      }\n      return cleanup;\n    }\n    function finished(stream, opts) {\n      return new Promise2((resolve, reject) => {\n        eos(stream, opts, err => {\n          if (err) {\n            reject(err);\n          } else {\n            resolve();\n          }\n        });\n      });\n    }\n    module.exports = eos;\n    module.exports.finished = finished;\n  },\n});\n\n// node_modules/readable-stream/lib/internal/streams/operators.js\nvar require_operators = __commonJS({\n  \"node_modules/readable-stream/lib/internal/streams/operators.js\"(exports, module) {\n    \"use strict\";\n    var AbortController = globalThis.AbortController || __require(\"abort-controller\").AbortController;\n    var {\n      codes: { ERR_INVALID_ARG_TYPE, ERR_MISSING_ARGS, ERR_OUT_OF_RANGE },\n      AbortError,\n    } = require_errors();\n    var { validateAbortSignal, validateInteger, validateObject } = require_validators();\n    var kWeakHandler = require_primordials().Symbol(\"kWeak\");\n    var { finished } = require_end_of_stream();\n    var {\n      ArrayPrototypePush,\n      MathFloor,\n      Number: Number2,\n      NumberIsNaN,\n      Promise: Promise2,\n      PromiseReject,\n      PromisePrototypeCatch,\n      Symbol: Symbol2,\n    } = require_primordials();\n    var kEmpty = Symbol2(\"kEmpty\");\n    var kEof = Symbol2(\"kEof\");\n    function map(fn, options) {\n      if (typeof fn !== \"function\") {\n        throw new ERR_INVALID_ARG_TYPE(\"fn\", [\"Function\", \"AsyncFunction\"], fn);\n      }\n      if (options != null) {\n        validateObject(options, \"options\");\n      }\n      if ((options === null || options === void 0 ? void 0 : options.signal) != null) {\n        validateAbortSignal(options.signal, \"options.signal\");\n      }\n      let concurrency = 1;\n      if ((options === null || options === void 0 ? void 0 : options.concurrency) != null) {\n        concurrency = MathFloor(options.concurrency);\n      }\n      validateInteger(concurrency, \"concurrency\", 1);\n      return async function* map2() {\n        var _options$signal, _options$signal2;\n        const ac = new AbortController();\n        const stream = this;\n        const queue = [];\n        const signal = ac.signal;\n        const signalOpt = {\n          signal,\n        };\n        const abort = () => ac.abort();\n        if (\n          options !== null &&\n          options !== void 0 &&\n          (_options$signal = options.signal) !== null &&\n          _options$signal !== void 0 &&\n          _options$signal.aborted\n        ) {\n          abort();\n        }\n        options === null || options === void 0\n          ? void 0\n          : (_options$signal2 = options.signal) === null || _options$signal2 === void 0\n          ? void 0\n          : _options$signal2.addEventListener(\"abort\", abort);\n        let next;\n        let resume;\n        let done = false;\n        function onDone() {\n          done = true;\n        }\n        async function pump() {\n          try {\n            for await (let val of stream) {\n              var _val;\n              if (done) {\n                return;\n              }\n              if (signal.aborted) {\n                throw new AbortError();\n              }\n              try {\n                val = fn(val, signalOpt);\n              } catch (err) {\n                val = PromiseReject(err);\n              }\n              if (val === kEmpty) {\n                continue;\n              }\n              if (typeof ((_val = val) === null || _val === void 0 ? void 0 : _val.catch) === \"function\") {\n                val.catch(onDone);\n              }\n              queue.push(val);\n              if (next) {\n                next();\n                next = null;\n              }\n              if (!done && queue.length && queue.length >= concurrency) {\n                await new Promise2(resolve => {\n                  resume = resolve;\n                });\n              }\n            }\n            queue.push(kEof);\n          } catch (err) {\n            const val = PromiseReject(err);\n            PromisePrototypeCatch(val, onDone);\n            queue.push(val);\n          } finally {\n            var _options$signal3;\n            done = true;\n            if (next) {\n              next();\n              next = null;\n            }\n            options === null || options === void 0\n              ? void 0\n              : (_options$signal3 = options.signal) === null || _options$signal3 === void 0\n              ? void 0\n              : _options$signal3.removeEventListener(\"abort\", abort);\n          }\n        }\n        pump();\n        try {\n          while (true) {\n            while (queue.length > 0) {\n              const val = await queue[0];\n              if (val === kEof) {\n                return;\n              }\n              if (signal.aborted) {\n                throw new AbortError();\n              }\n              if (val !== kEmpty) {\n                yield val;\n              }\n              queue.shift();\n              if (resume) {\n                resume();\n                resume = null;\n              }\n            }\n            await new Promise2(resolve => {\n              next = resolve;\n            });\n          }\n        } finally {\n          ac.abort();\n          done = true;\n          if (resume) {\n            resume();\n            resume = null;\n          }\n        }\n      }.call(this);\n    }\n    function asIndexedPairs(options = void 0) {\n      if (options != null) {\n        validateObject(options, \"options\");\n      }\n      if ((options === null || options === void 0 ? void 0 : options.signal) != null) {\n        validateAbortSignal(options.signal, \"options.signal\");\n      }\n      return async function* asIndexedPairs2() {\n        let index = 0;\n        for await (const val of this) {\n          var _options$signal4;\n          if (\n            options !== null &&\n            options !== void 0 &&\n            (_options$signal4 = options.signal) !== null &&\n            _options$signal4 !== void 0 &&\n            _options$signal4.aborted\n          ) {\n            throw new AbortError({\n              cause: options.signal.reason,\n            });\n          }\n          yield [index++, val];\n        }\n      }.call(this);\n    }\n    async function some(fn, options = void 0) {\n      for await (const unused of filter.call(this, fn, options)) {\n        return true;\n      }\n      return false;\n    }\n    async function every(fn, options = void 0) {\n      if (typeof fn !== \"function\") {\n        throw new ERR_INVALID_ARG_TYPE(\"fn\", [\"Function\", \"AsyncFunction\"], fn);\n      }\n      return !(await some.call(\n        this,\n        async (...args) => {\n          return !(await fn(...args));\n        },\n        options,\n      ));\n    }\n    async function find(fn, options) {\n      for await (const result of filter.call(this, fn, options)) {\n        return result;\n      }\n      return void 0;\n    }\n    async function forEach(fn, options) {\n      if (typeof fn !== \"function\") {\n        throw new ERR_INVALID_ARG_TYPE(\"fn\", [\"Function\", \"AsyncFunction\"], fn);\n      }\n      async function forEachFn(value, options2) {\n        await fn(value, options2);\n        return kEmpty;\n      }\n      for await (const unused of map.call(this, forEachFn, options));\n    }\n    function filter(fn, options) {\n      if (typeof fn !== \"function\") {\n        throw new ERR_INVALID_ARG_TYPE(\"fn\", [\"Function\", \"AsyncFunction\"], fn);\n      }\n      async function filterFn(value, options2) {\n        if (await fn(value, options2)) {\n          return value;\n        }\n        return kEmpty;\n      }\n      return map.call(this, filterFn, options);\n    }\n    var ReduceAwareErrMissingArgs = class extends ERR_MISSING_ARGS {\n      constructor() {\n        super(\"reduce\");\n        this.message = \"Reduce of an empty stream requires an initial value\";\n      }\n    };\n    async function reduce(reducer, initialValue, options) {\n      var _options$signal5;\n      if (typeof reducer !== \"function\") {\n        throw new ERR_INVALID_ARG_TYPE(\"reducer\", [\"Function\", \"AsyncFunction\"], reducer);\n      }\n      if (options != null) {\n        validateObject(options, \"options\");\n      }\n      if ((options === null || options === void 0 ? void 0 : options.signal) != null) {\n        validateAbortSignal(options.signal, \"options.signal\");\n      }\n      let hasInitialValue = arguments.length > 1;\n      if (\n        options !== null &&\n        options !== void 0 &&\n        (_options$signal5 = options.signal) !== null &&\n        _options$signal5 !== void 0 &&\n        _options$signal5.aborted\n      ) {\n        const err = new AbortError(void 0, {\n          cause: options.signal.reason,\n        });\n        this.once(\"error\", () => {});\n        await finished(this.destroy(err));\n        throw err;\n      }\n      const ac = new AbortController();\n      const signal = ac.signal;\n      if (options !== null && options !== void 0 && options.signal) {\n        const opts = {\n          once: true,\n          [kWeakHandler]: this,\n        };\n        options.signal.addEventListener(\"abort\", () => ac.abort(), opts);\n      }\n      let gotAnyItemFromStream = false;\n      try {\n        for await (const value of this) {\n          var _options$signal6;\n          gotAnyItemFromStream = true;\n          if (\n            options !== null &&\n            options !== void 0 &&\n            (_options$signal6 = options.signal) !== null &&\n            _options$signal6 !== void 0 &&\n            _options$signal6.aborted\n          ) {\n            throw new AbortError();\n          }\n          if (!hasInitialValue) {\n            initialValue = value;\n            hasInitialValue = true;\n          } else {\n            initialValue = await reducer(initialValue, value, {\n              signal,\n            });\n          }\n        }\n        if (!gotAnyItemFromStream && !hasInitialValue) {\n          throw new ReduceAwareErrMissingArgs();\n        }\n      } finally {\n        ac.abort();\n      }\n      return initialValue;\n    }\n    async function toArray(options) {\n      if (options != null) {\n        validateObject(options, \"options\");\n      }\n      if ((options === null || options === void 0 ? void 0 : options.signal) != null) {\n        validateAbortSignal(options.signal, \"options.signal\");\n      }\n      const result = [];\n      for await (const val of this) {\n        var _options$signal7;\n        if (\n          options !== null &&\n          options !== void 0 &&\n          (_options$signal7 = options.signal) !== null &&\n          _options$signal7 !== void 0 &&\n          _options$signal7.aborted\n        ) {\n          throw new AbortError(void 0, {\n            cause: options.signal.reason,\n          });\n        }\n        ArrayPrototypePush(result, val);\n      }\n      return result;\n    }\n    function flatMap(fn, options) {\n      const values = map.call(this, fn, options);\n      return async function* flatMap2() {\n        for await (const val of values) {\n          yield* val;\n        }\n      }.call(this);\n    }\n    function toIntegerOrInfinity(number) {\n      number = Number2(number);\n      if (NumberIsNaN(number)) {\n        return 0;\n      }\n      if (number < 0) {\n        throw new ERR_OUT_OF_RANGE(\"number\", \">= 0\", number);\n      }\n      return number;\n    }\n    function drop(number, options = void 0) {\n      if (options != null) {\n        validateObject(options, \"options\");\n      }\n      if ((options === null || options === void 0 ? void 0 : options.signal) != null) {\n        validateAbortSignal(options.signal, \"options.signal\");\n      }\n      number = toIntegerOrInfinity(number);\n      return async function* drop2() {\n        var _options$signal8;\n        if (\n          options !== null &&\n          options !== void 0 &&\n          (_options$signal8 = options.signal) !== null &&\n          _options$signal8 !== void 0 &&\n          _options$signal8.aborted\n        ) {\n          throw new AbortError();\n        }\n        for await (const val of this) {\n          var _options$signal9;\n          if (\n            options !== null &&\n            options !== void 0 &&\n            (_options$signal9 = options.signal) !== null &&\n            _options$signal9 !== void 0 &&\n            _options$signal9.aborted\n          ) {\n            throw new AbortError();\n          }\n          if (number-- <= 0) {\n            yield val;\n          }\n        }\n      }.call(this);\n    }\n    function take(number, options = void 0) {\n      if (options != null) {\n        validateObject(options, \"options\");\n      }\n      if ((options === null || options === void 0 ? void 0 : options.signal) != null) {\n        validateAbortSignal(options.signal, \"options.signal\");\n      }\n      number = toIntegerOrInfinity(number);\n      return async function* take2() {\n        var _options$signal10;\n        if (\n          options !== null &&\n          options !== void 0 &&\n          (_options$signal10 = options.signal) !== null &&\n          _options$signal10 !== void 0 &&\n          _options$signal10.aborted\n        ) {\n          throw new AbortError();\n        }\n        for await (const val of this) {\n          var _options$signal11;\n          if (\n            options !== null &&\n            options !== void 0 &&\n            (_options$signal11 = options.signal) !== null &&\n            _options$signal11 !== void 0 &&\n            _options$signal11.aborted\n          ) {\n            throw new AbortError();\n          }\n          if (number-- > 0) {\n            yield val;\n          } else {\n            return;\n          }\n        }\n      }.call(this);\n    }\n    module.exports.streamReturningOperators = {\n      asIndexedPairs,\n      drop,\n      filter,\n      flatMap,\n      map,\n      take,\n    };\n    module.exports.promiseReturningOperators = {\n      every,\n      forEach,\n      reduce,\n      toArray,\n      some,\n      find,\n    };\n  },\n});\n\n// node_modules/readable-stream/lib/internal/streams/destroy.js\nvar require_destroy = __commonJS({\n  \"node_modules/readable-stream/lib/internal/streams/destroy.js\"(exports, module) {\n    \"use strict\";\n    var {\n      aggregateTwoErrors,\n      codes: { ERR_MULTIPLE_CALLBACK },\n      AbortError,\n    } = require_errors();\n    var { Symbol: Symbol2 } = require_primordials();\n    var { kDestroyed, isDestroyed, isFinished, isServerRequest } = require_utils();\n    var kDestroy = \"#kDestroy\";\n    var kConstruct = \"#kConstruct\";\n    function checkError(err, w, r) {\n      if (err) {\n        err.stack;\n        if (w && !w.errored) {\n          w.errored = err;\n        }\n        if (r && !r.errored) {\n          r.errored = err;\n        }\n      }\n    }\n    function destroy(err, cb) {\n      const r = this._readableState;\n      const w = this._writableState;\n      const s = w || r;\n      if ((w && w.destroyed) || (r && r.destroyed)) {\n        if (typeof cb === \"function\") {\n          cb();\n        }\n        return this;\n      }\n      checkError(err, w, r);\n      if (w) {\n        w.destroyed = true;\n      }\n      if (r) {\n        r.destroyed = true;\n      }\n      if (!s.constructed) {\n        this.once(kDestroy, er => {\n          _destroy(this, aggregateTwoErrors(er, err), cb);\n        });\n      } else {\n        _destroy(this, err, cb);\n      }\n      return this;\n    }\n    function _destroy(self, err, cb) {\n      let called = false;\n      function onDestroy(err2) {\n        if (called) {\n          return;\n        }\n        called = true;\n        const r = self._readableState;\n        const w = self._writableState;\n        checkError(err2, w, r);\n        if (w) {\n          w.closed = true;\n        }\n        if (r) {\n          r.closed = true;\n        }\n        if (typeof cb === \"function\") {\n          cb(err2);\n        }\n        if (err2) {\n          runOnNextTick(emitErrorCloseNT, self, err2);\n        } else {\n          runOnNextTick(emitCloseNT, self);\n        }\n      }\n      try {\n        self._destroy(err || null, onDestroy);\n      } catch (err2) {\n        onDestroy(err2);\n      }\n    }\n    function emitErrorCloseNT(self, err) {\n      emitErrorNT(self, err);\n      emitCloseNT(self);\n    }\n    function emitCloseNT(self) {\n      const r = self._readableState;\n      const w = self._writableState;\n      if (w) {\n        w.closeEmitted = true;\n      }\n      if (r) {\n        r.closeEmitted = true;\n      }\n      if ((w && w.emitClose) || (r && r.emitClose)) {\n        self.emit(\"close\");\n      }\n    }\n    function emitErrorNT(self, err) {\n      const r = self?._readableState;\n      const w = self?._writableState;\n      if (w?.errorEmitted || r?.errorEmitted) {\n        return;\n      }\n      if (w) {\n        w.errorEmitted = true;\n      }\n      if (r) {\n        r.errorEmitted = true;\n      }\n      self?.emit?.(\"error\", err);\n    }\n    function undestroy() {\n      const r = this._readableState;\n      const w = this._writableState;\n      if (r) {\n        r.constructed = true;\n        r.closed = false;\n        r.closeEmitted = false;\n        r.destroyed = false;\n        r.errored = null;\n        r.errorEmitted = false;\n        r.reading = false;\n        r.ended = r.readable === false;\n        r.endEmitted = r.readable === false;\n      }\n      if (w) {\n        w.constructed = true;\n        w.destroyed = false;\n        w.closed = false;\n        w.closeEmitted = false;\n        w.errored = null;\n        w.errorEmitted = false;\n        w.finalCalled = false;\n        w.prefinished = false;\n        w.ended = w.writable === false;\n        w.ending = w.writable === false;\n        w.finished = w.writable === false;\n      }\n    }\n    function errorOrDestroy(stream, err, sync) {\n      const r = stream?._readableState;\n      const w = stream?._writableState;\n      if ((w && w.destroyed) || (r && r.destroyed)) {\n        return this;\n      }\n      if ((r && r.autoDestroy) || (w && w.autoDestroy)) stream.destroy(err);\n      else if (err) {\n        Error.captureStackTrace(err);\n        if (w && !w.errored) {\n          w.errored = err;\n        }\n        if (r && !r.errored) {\n          r.errored = err;\n        }\n        if (sync) {\n          runOnNextTick(emitErrorNT, stream, err);\n        } else {\n          emitErrorNT(stream, err);\n        }\n      }\n    }\n    function construct(stream, cb) {\n      if (typeof stream._construct !== \"function\") {\n        return;\n      }\n      const r = stream._readableState;\n      const w = stream._writableState;\n      if (r) {\n        r.constructed = false;\n      }\n      if (w) {\n        w.constructed = false;\n      }\n      stream.once(kConstruct, cb);\n      if (stream.listenerCount(kConstruct) > 1) {\n        return;\n      }\n      runOnNextTick(constructNT, stream);\n    }\n    function constructNT(stream) {\n      let called = false;\n      function onConstruct(err) {\n        if (called) {\n          errorOrDestroy(stream, err !== null && err !== void 0 ? err : new ERR_MULTIPLE_CALLBACK());\n          return;\n        }\n        called = true;\n        const r = stream._readableState;\n        const w = stream._writableState;\n        const s = w || r;\n        if (r) {\n          r.constructed = true;\n        }\n        if (w) {\n          w.constructed = true;\n        }\n        if (s.destroyed) {\n          stream.emit(kDestroy, err);\n        } else if (err) {\n          errorOrDestroy(stream, err, true);\n        } else {\n          runOnNextTick(emitConstructNT, stream);\n        }\n      }\n      try {\n        stream._construct(onConstruct);\n      } catch (err) {\n        onConstruct(err);\n      }\n    }\n    function emitConstructNT(stream) {\n      stream.emit(kConstruct);\n    }\n    function isRequest(stream) {\n      return stream && stream.setHeader && typeof stream.abort === \"function\";\n    }\n    function emitCloseLegacy(stream) {\n      stream.emit(\"close\");\n    }\n    function emitErrorCloseLegacy(stream, err) {\n      stream.emit(\"error\", err);\n      runOnNextTick(emitCloseLegacy, stream);\n    }\n    function destroyer(stream, err) {\n      if (!stream || isDestroyed(stream)) {\n        return;\n      }\n      if (!err && !isFinished(stream)) {\n        err = new AbortError();\n      }\n      if (isServerRequest(stream)) {\n        stream.socket = null;\n        stream.destroy(err);\n      } else if (isRequest(stream)) {\n        stream.abort();\n      } else if (isRequest(stream.req)) {\n        stream.req.abort();\n      } else if (typeof stream.destroy === \"function\") {\n        stream.destroy(err);\n      } else if (typeof stream.close === \"function\") {\n        stream.close();\n      } else if (err) {\n        runOnNextTick(emitErrorCloseLegacy, stream);\n      } else {\n        runOnNextTick(emitCloseLegacy, stream);\n      }\n      if (!stream.destroyed) {\n        stream[kDestroyed] = true;\n      }\n    }\n    module.exports = {\n      construct,\n      destroyer,\n      destroy,\n      undestroy,\n      errorOrDestroy,\n    };\n  },\n});\n\n// node_modules/readable-stream/lib/internal/streams/legacy.js\nvar require_legacy = __commonJS({\n  \"node_modules/readable-stream/lib/internal/streams/legacy.js\"(exports, module) {\n    \"use strict\";\n    var { ArrayIsArray, ObjectSetPrototypeOf } = require_primordials();\n    var { EventEmitter: _EE } = __require(\"bun:events_native\");\n    var EE;\n    if (__TRACK_EE__) {\n      EE = DebugEventEmitter;\n    } else {\n      EE = _EE;\n    }\n\n    function Stream(options) {\n      if (!(this instanceof Stream)) return new Stream(options);\n      EE.call(this, options);\n    }\n    ObjectSetPrototypeOf(Stream.prototype, EE.prototype);\n    ObjectSetPrototypeOf(Stream, EE);\n\n    Stream.prototype.pipe = function (dest, options) {\n      const source = this;\n      function ondata(chunk) {\n        if (dest.writable && dest.write(chunk) === false && source.pause) {\n          source.pause();\n        }\n      }\n      source.on(\"data\", ondata);\n      function ondrain() {\n        if (source.readable && source.resume) {\n          source.resume();\n        }\n      }\n      dest.on(\"drain\", ondrain);\n      if (!dest._isStdio && (!options || options.end !== false)) {\n        source.on(\"end\", onend);\n        source.on(\"close\", onclose);\n      }\n      let didOnEnd = false;\n      function onend() {\n        if (didOnEnd) return;\n        didOnEnd = true;\n        dest.end();\n      }\n      function onclose() {\n        if (didOnEnd) return;\n        didOnEnd = true;\n        if (typeof dest.destroy === \"function\") dest.destroy();\n      }\n      function onerror(er) {\n        cleanup();\n        if (EE.listenerCount(this, \"error\") === 0) {\n          this.emit(\"error\", er);\n        }\n      }\n      prependListener(source, \"error\", onerror);\n      prependListener(dest, \"error\", onerror);\n      function cleanup() {\n        source.removeListener(\"data\", ondata);\n        dest.removeListener(\"drain\", ondrain);\n        source.removeListener(\"end\", onend);\n        source.removeListener(\"close\", onclose);\n        source.removeListener(\"error\", onerror);\n        dest.removeListener(\"error\", onerror);\n        source.removeListener(\"end\", cleanup);\n        source.removeListener(\"close\", cleanup);\n        dest.removeListener(\"close\", cleanup);\n      }\n      source.on(\"end\", cleanup);\n      source.on(\"close\", cleanup);\n      dest.on(\"close\", cleanup);\n      dest.emit(\"pipe\", source);\n      return dest;\n    };\n    function prependListener(emitter, event, fn) {\n      if (typeof emitter.prependListener === \"function\") return emitter.prependListener(event, fn);\n      if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);\n      else if (ArrayIsArray(emitter._events[event])) emitter._events[event].unshift(fn);\n      else emitter._events[event] = [fn, emitter._events[event]];\n    }\n    module.exports = {\n      Stream,\n      prependListener,\n    };\n  },\n});\n\n// node_modules/readable-stream/lib/internal/streams/add-abort-signal.js\nvar require_add_abort_signal = __commonJS({\n  \"node_modules/readable-stream/lib/internal/streams/add-abort-signal.js\"(exports, module) {\n    \"use strict\";\n    var { AbortError, codes } = require_errors();\n    var eos = require_end_of_stream();\n    var { ERR_INVALID_ARG_TYPE } = codes;\n    var validateAbortSignal = (signal, name) => {\n      if (typeof signal !== \"object\" || !(\"aborted\" in signal)) {\n        throw new ERR_INVALID_ARG_TYPE(name, \"AbortSignal\", signal);\n      }\n    };\n    function isNodeStream(obj) {\n      return !!(obj && typeof obj.pipe === \"function\");\n    }\n    module.exports.addAbortSignal = function addAbortSignal(signal, stream) {\n      validateAbortSignal(signal, \"signal\");\n      if (!isNodeStream(stream)) {\n        throw new ERR_INVALID_ARG_TYPE(\"stream\", \"stream.Stream\", stream);\n      }\n      return module.exports.addAbortSignalNoValidate(signal, stream);\n    };\n    module.exports.addAbortSignalNoValidate = function (signal, stream) {\n      if (typeof signal !== \"object\" || !(\"aborted\" in signal)) {\n        return stream;\n      }\n      const onAbort = () => {\n        stream.destroy(\n          new AbortError(void 0, {\n            cause: signal.reason,\n          }),\n        );\n      };\n      if (signal.aborted) {\n        onAbort();\n      } else {\n        signal.addEventListener(\"abort\", onAbort);\n        eos(stream, () => signal.removeEventListener(\"abort\", onAbort));\n      }\n      return stream;\n    };\n  },\n});\n\n// node_modules/readable-stream/lib/internal/streams/state.js\nvar require_state = __commonJS({\n  \"node_modules/readable-stream/lib/internal/streams/state.js\"(exports, module) {\n    \"use strict\";\n    var { MathFloor, NumberIsInteger } = require_primordials();\n    var { ERR_INVALID_ARG_VALUE } = require_errors().codes;\n    function highWaterMarkFrom(options, isDuplex, duplexKey) {\n      return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;\n    }\n    function getDefaultHighWaterMark(objectMode) {\n      return objectMode ? 16 : 16 * 1024;\n    }\n    function getHighWaterMark(state, options, duplexKey, isDuplex) {\n      const hwm = highWaterMarkFrom(options, isDuplex, duplexKey);\n      if (hwm != null) {\n        if (!NumberIsInteger(hwm) || hwm < 0) {\n          const name = isDuplex ? `options.${duplexKey}` : \"options.highWaterMark\";\n          throw new ERR_INVALID_ARG_VALUE(name, hwm);\n        }\n        return MathFloor(hwm);\n      }\n      return getDefaultHighWaterMark(state.objectMode);\n    }\n    module.exports = {\n      getHighWaterMark,\n      getDefaultHighWaterMark,\n    };\n  },\n});\n\n// node_modules/readable-stream/lib/internal/streams/from.js\nvar require_from = __commonJS({\n  \"node_modules/readable-stream/lib/internal/streams/from.js\"(exports, module) {\n    \"use strict\";\n    var { PromisePrototypeThen, SymbolAsyncIterator, SymbolIterator } = require_primordials();\n    var { ERR_INVALID_ARG_TYPE, ERR_STREAM_NULL_VALUES } = require_errors().codes;\n    function from(Readable, iterable, opts) {\n      let iterator;\n      if (typeof iterable === \"string\" || iterable instanceof Buffer) {\n        return new Readable({\n          objectMode: true,\n          ...opts,\n          read() {\n            this.push(iterable);\n            this.push(null);\n          },\n        });\n      }\n      let isAsync;\n      if (iterable && iterable[SymbolAsyncIterator]) {\n        isAsync = true;\n        iterator = iterable[SymbolAsyncIterator]();\n      } else if (iterable && iterable[SymbolIterator]) {\n        isAsync = false;\n        iterator = iterable[SymbolIterator]();\n      } else {\n        throw new ERR_INVALID_ARG_TYPE(\"iterable\", [\"Iterable\"], iterable);\n      }\n      const readable = new Readable({\n        objectMode: true,\n        highWaterMark: 1,\n        ...opts,\n      });\n      let reading = false;\n      readable._read = function () {\n        if (!reading) {\n          reading = true;\n          next();\n        }\n      };\n      readable._destroy = function (error, cb) {\n        PromisePrototypeThen(\n          close(error),\n          () => runOnNextTick(cb, error),\n          e => runOnNextTick(cb, e || error),\n        );\n      };\n      async function close(error) {\n        const hadError = error !== void 0 && error !== null;\n        const hasThrow = typeof iterator.throw === \"function\";\n        if (hadError && hasThrow) {\n          const { value, done } = await iterator.throw(error);\n          await value;\n          if (done) {\n            return;\n          }\n        }\n        if (typeof iterator.return === \"function\") {\n          const { value } = await iterator.return();\n          await value;\n        }\n      }\n      async function next() {\n        for (;;) {\n          try {\n            const { value, done } = isAsync ? await iterator.next() : iterator.next();\n            if (done) {\n              readable.push(null);\n            } else {\n              const res = value && typeof value.then === \"function\" ? await value : value;\n              if (res === null) {\n                reading = false;\n                throw new ERR_STREAM_NULL_VALUES();\n              } else if (readable.push(res)) {\n                continue;\n              } else {\n                reading = false;\n              }\n            }\n          } catch (err) {\n            readable.destroy(err);\n          }\n          break;\n        }\n      }\n      return readable;\n    }\n    module.exports = from;\n  },\n});\n\nvar _ReadableFromWeb;\n\n// node_modules/readable-stream/lib/internal/streams/readable.js\nvar require_readable = __commonJS({\n  \"node_modules/readable-stream/lib/internal/streams/readable.js\"(exports, module) {\n    \"use strict\";\n    var {\n      ArrayPrototypeIndexOf,\n      NumberIsInteger,\n      NumberIsNaN,\n      NumberParseInt,\n      ObjectDefineProperties,\n      ObjectKeys,\n      ObjectSetPrototypeOf,\n      Promise: Promise2,\n      SafeSet,\n      SymbolAsyncIterator,\n      Symbol: Symbol2,\n    } = require_primordials();\n\n    var ReadableState = globalThis[Symbol.for(\"Bun.lazy\")](\"bun:stream\").ReadableState;\n    var { EventEmitter: EE } = __require(\"bun:events_native\");\n    var { Stream, prependListener } = require_legacy();\n\n    function Readable(options) {\n      if (!(this instanceof Readable)) return new Readable(options);\n      const isDuplex = this instanceof require_duplex();\n      this._readableState = new ReadableState(options, this, isDuplex);\n      if (options) {\n        const { read, destroy, construct, signal } = options;\n        if (typeof read === \"function\") this._read = read;\n        if (typeof destroy === \"function\") this._destroy = destroy;\n        if (typeof construct === \"function\") this._construct = construct;\n        if (signal && !isDuplex) addAbortSignal(signal, this);\n      }\n      Stream.call(this, options);\n\n      destroyImpl.construct(this, () => {\n        if (this._readableState.needReadable) {\n          maybeReadMore(this, this._readableState);\n        }\n      });\n    }\n    ObjectSetPrototypeOf(Readable.prototype, Stream.prototype);\n    ObjectSetPrototypeOf(Readable, Stream);\n\n    Readable.prototype.on = function (ev, fn) {\n      const res = Stream.prototype.on.call(this, ev, fn);\n      const state = this._readableState;\n      if (ev === \"data\") {\n        state.readableListening = this.listenerCount(\"readable\") > 0;\n        if (state.flowing !== false) {\n          __DEBUG__ && debug(\"in flowing mode!\", this.__id);\n          this.resume();\n        } else {\n          __DEBUG__ && debug(\"in readable mode!\", this.__id);\n        }\n      } else if (ev === \"readable\") {\n        __DEBUG__ && debug(\"readable listener added!\", this.__id);\n        if (!state.endEmitted && !state.readableListening) {\n          state.readableListening = state.needReadable = true;\n          state.flowing = false;\n          state.emittedReadable = false;\n          __DEBUG__ &&\n            debug(\n              \"on readable - state.length, reading, emittedReadable\",\n              state.length,\n              state.reading,\n              state.emittedReadable,\n              this.__id,\n            );\n          if (state.length) {\n            emitReadable(this, state);\n          } else if (!state.reading) {\n            runOnNextTick(nReadingNextTick, this);\n          }\n        } else if (state.endEmitted) {\n          __DEBUG__ && debug(\"end already emitted...\", this.__id);\n        }\n      }\n      return res;\n    };\n\n    class ReadableFromWeb extends Readable {\n      #reader;\n      #closed;\n      #pendingChunks;\n      #stream;\n\n      constructor(options, stream) {\n        const { objectMode, highWaterMark, encoding, signal } = options;\n        super({\n          objectMode,\n          highWaterMark,\n          encoding,\n          signal,\n        });\n        this.#pendingChunks = [];\n        this.#reader = undefined;\n        this.#stream = stream;\n        this.#closed = false;\n      }\n\n      #drainPending() {\n        var pendingChunks = this.#pendingChunks,\n          pendingChunksI = 0,\n          pendingChunksCount = pendingChunks.length;\n\n        for (; pendingChunksI < pendingChunksCount; pendingChunksI++) {\n          const chunk = pendingChunks[pendingChunksI];\n          pendingChunks[pendingChunksI] = undefined;\n          if (!this.push(chunk, undefined)) {\n            this.#pendingChunks = pendingChunks.slice(pendingChunksI + 1);\n            return true;\n          }\n        }\n\n        if (pendingChunksCount > 0) {\n          this.#pendingChunks = [];\n        }\n\n        return false;\n      }\n\n      #handleDone(reader) {\n        reader.releaseLock();\n        this.#reader = undefined;\n        this.#closed = true;\n        this.push(null);\n        return;\n      }\n\n      async _read() {\n        __DEBUG__ && debug(\"ReadableFromWeb _read()\", this.__id);\n        var stream = this.#stream,\n          reader = this.#reader;\n        if (stream) {\n          reader = this.#reader = stream.getReader();\n          this.#stream = undefined;\n        } else if (this.#drainPending()) {\n          return;\n        }\n\n        var deferredError;\n        try {\n          do {\n            var done = false,\n              value;\n            const firstResult = reader.readMany();\n\n            if (isPromise(firstResult)) {\n              ({ done, value } = await firstResult);\n\n              if (this.#closed) {\n                this.#pendingChunks.push(...value);\n                return;\n              }\n            } else {\n              ({ done, value } = firstResult);\n            }\n\n            if (done) {\n              this.#handleDone(reader);\n              return;\n            }\n\n            if (!this.push(value[0])) {\n              this.#pendingChunks = value.slice(1);\n              return;\n            }\n\n            for (let i = 1, count = value.length; i < count; i++) {\n              if (!this.push(value[i])) {\n                this.#pendingChunks = value.slice(i + 1);\n                return;\n              }\n            }\n          } while (!this.#closed);\n        } catch (e) {\n          deferredError = e;\n        } finally {\n          if (deferredError) throw deferredError;\n        }\n      }\n\n      _destroy(error, callback) {\n        if (!this.#closed) {\n          var reader = this.#reader;\n          if (reader) {\n            this.#reader = undefined;\n            reader.cancel(error).finally(() => {\n              this.#closed = true;\n              callback(error);\n            });\n          }\n\n          return;\n        }\n        try {\n          callback(error);\n        } catch (error) {\n          globalThis.reportError(error);\n        }\n      }\n    }\n\n    /**\n     * @param {ReadableStream} readableStream\n     * @param {{\n     *   highWaterMark? : number,\n     *   encoding? : string,\n     *   objectMode? : boolean,\n     *   signal? : AbortSignal,\n     * }} [options]\n     * @returns {Readable}\n     */\n    function newStreamReadableFromReadableStream(readableStream, options = {}) {\n      if (!isReadableStream(readableStream)) {\n        throw new ERR_INVALID_ARG_TYPE(\"readableStream\", \"ReadableStream\", readableStream);\n      }\n\n      validateObject(options, \"options\");\n      const {\n        highWaterMark,\n        encoding,\n        objectMode = false,\n        signal,\n        // native = true,\n      } = options;\n\n      if (encoding !== undefined && !Buffer.isEncoding(encoding))\n        throw new ERR_INVALID_ARG_VALUE(encoding, \"options.encoding\");\n      validateBoolean(objectMode, \"options.objectMode\");\n\n      // validateBoolean(native, \"options.native\");\n\n      // if (!native) {\n      //   return new ReadableFromWeb(\n      //     {\n      //       highWaterMark,\n      //       encoding,\n      //       objectMode,\n      //       signal,\n      //     },\n      //     readableStream,\n      //   );\n      // }\n\n      const nativeStream = getNativeReadableStream(Readable, readableStream, options);\n\n      return (\n        nativeStream ||\n        new ReadableFromWeb(\n          {\n            highWaterMark,\n            encoding,\n            objectMode,\n            signal,\n          },\n          readableStream,\n        )\n      );\n    }\n\n    module.exports = Readable;\n    _ReadableFromWeb = ReadableFromWeb;\n\n    var { addAbortSignal } = require_add_abort_signal();\n    var eos = require_end_of_stream();\n    const {\n      maybeReadMore: _maybeReadMore,\n      resume,\n      emitReadable: _emitReadable,\n      onEofChunk,\n    } = globalThis[Symbol.for(\"Bun.lazy\")](\"bun:stream\");\n    function maybeReadMore(stream, state) {\n      process.nextTick(_maybeReadMore, stream, state);\n    }\n    // REVERT ME\n    function emitReadable(stream, state) {\n      __DEBUG__ && debug(\"NativeReadable - emitReadable\", stream.__id);\n      _emitReadable(stream, state);\n    }\n    var destroyImpl = require_destroy();\n    var {\n      aggregateTwoErrors,\n      codes: {\n        ERR_INVALID_ARG_TYPE,\n        ERR_METHOD_NOT_IMPLEMENTED,\n        ERR_OUT_OF_RANGE,\n        ERR_STREAM_PUSH_AFTER_EOF,\n        ERR_STREAM_UNSHIFT_AFTER_END_EVENT,\n      },\n    } = require_errors();\n    var { validateObject } = require_validators();\n    var { StringDecoder } = __require(\"string_decoder\");\n    var from = require_from();\n    var nop = () => {};\n    var { errorOrDestroy } = destroyImpl;\n\n    Readable.prototype.destroy = destroyImpl.destroy;\n    Readable.prototype._undestroy = destroyImpl.undestroy;\n    Readable.prototype._destroy = function (err, cb) {\n      cb(err);\n    };\n    Readable.prototype[EE.captureRejectionSymbol] = function (err) {\n      this.destroy(err);\n    };\n    Readable.prototype.push = function (chunk, encoding) {\n      return readableAddChunk(this, chunk, encoding, false);\n    };\n    Readable.prototype.unshift = function (chunk, encoding) {\n      return readableAddChunk(this, chunk, encoding, true);\n    };\n    function readableAddChunk(stream, chunk, encoding, addToFront) {\n      __DEBUG__ && debug(\"readableAddChunk\", chunk, stream.__id);\n      const state = stream._readableState;\n      let err;\n      if (!state.objectMode) {\n        if (typeof chunk === \"string\") {\n          encoding = encoding || state.defaultEncoding;\n          if (state.encoding !== encoding) {\n            if (addToFront && state.encoding) {\n              chunk = Buffer.from(chunk, encoding).toString(state.encoding);\n            } else {\n              chunk = Buffer.from(chunk, encoding);\n              encoding = \"\";\n            }\n          }\n        } else if (chunk instanceof Buffer) {\n          encoding = \"\";\n        } else if (Stream._isUint8Array(chunk)) {\n          if (addToFront || !state.decoder) {\n            chunk = Stream._uint8ArrayToBuffer(chunk);\n          }\n          encoding = \"\";\n        } else if (chunk != null) {\n          err = new ERR_INVALID_ARG_TYPE(\"chunk\", [\"string\", \"Buffer\", \"Uint8Array\"], chunk);\n        }\n      }\n      if (err) {\n        errorOrDestroy(stream, err);\n      } else if (chunk === null) {\n        state.reading = false;\n        onEofChunk(stream, state);\n      } else if (state.objectMode || (chunk && chunk.length > 0)) {\n        if (addToFront) {\n          if (state.endEmitted) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());\n          else if (state.destroyed || state.errored) return false;\n          else addChunk(stream, state, chunk, true);\n        } else if (state.ended) {\n          errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());\n        } else if (state.destroyed || state.errored) {\n          return false;\n        } else {\n          state.reading = false;\n          if (state.decoder && !encoding) {\n            chunk = state.decoder.write(chunk);\n            if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);\n            else maybeReadMore(stream, state);\n          } else {\n            addChunk(stream, state, chunk, false);\n          }\n        }\n      } else if (!addToFront) {\n        state.reading = false;\n        maybeReadMore(stream, state);\n      }\n      return !state.ended && (state.length < state.highWaterMark || state.length === 0);\n    }\n    function addChunk(stream, state, chunk, addToFront) {\n      __DEBUG__ && debug(\"adding chunk\", stream.__id);\n      __DEBUG__ && debug(\"chunk\", chunk.toString(), stream.__id);\n      if (state.flowing && state.length === 0 && !state.sync && stream.listenerCount(\"data\") > 0) {\n        if (state.multiAwaitDrain) {\n          state.awaitDrainWriters.clear();\n        } else {\n          state.awaitDrainWriters = null;\n        }\n        state.dataEmitted = true;\n        stream.emit(\"data\", chunk);\n      } else {\n        state.length += state.objectMode ? 1 : chunk.length;\n        if (addToFront) state.buffer.unshift(chunk);\n        else state.buffer.push(chunk);\n        __DEBUG__ && debug(\"needReadable @ addChunk\", state.needReadable, stream.__id);\n        if (state.needReadable) emitReadable(stream, state);\n      }\n      maybeReadMore(stream, state);\n    }\n    Readable.prototype.isPaused = function () {\n      const state = this._readableState;\n      return state.paused === true || state.flowing === false;\n    };\n    Readable.prototype.setEncoding = function (enc) {\n      const decoder = new StringDecoder(enc);\n      this._readableState.decoder = decoder;\n      this._readableState.encoding = this._readableState.decoder.encoding;\n      const buffer = this._readableState.buffer;\n      let content = \"\";\n      // BufferList does not support iterator now, and iterator is slow in JSC.\n      // for (const data of buffer) {\n      //   content += decoder.write(data);\n      // }\n      // buffer.clear();\n      for (let i = buffer.length; i > 0; i--) {\n        content += decoder.write(buffer.shift());\n      }\n      if (content !== \"\") buffer.push(content);\n      this._readableState.length = content.length;\n      return this;\n    };\n    var MAX_HWM = 1073741824;\n    function computeNewHighWaterMark(n) {\n      if (n > MAX_HWM) {\n        throw new ERR_OUT_OF_RANGE(\"size\", \"<= 1GiB\", n);\n      } else {\n        n--;\n        n |= n >>> 1;\n        n |= n >>> 2;\n        n |= n >>> 4;\n        n |= n >>> 8;\n        n |= n >>> 16;\n        n++;\n      }\n      return n;\n    }\n    function howMuchToRead(n, state) {\n      if (n <= 0 || (state.length === 0 && state.ended)) return 0;\n      if (state.objectMode) return 1;\n      if (NumberIsNaN(n)) {\n        if (state.flowing && state.length) return state.buffer.first().length;\n        return state.length;\n      }\n      if (n <= state.length) return n;\n      return state.ended ? state.length : 0;\n    }\n    // You can override either this method, or the async _read(n) below.\n    Readable.prototype.read = function (n) {\n      __DEBUG__ && debug(\"read - n =\", n, this.__id);\n      if (!NumberIsInteger(n)) {\n        n = NumberParseInt(n, 10);\n      }\n      const state = this._readableState;\n      const nOrig = n;\n\n      // If we're asking for more than the current hwm, then raise the hwm.\n      if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);\n\n      if (n !== 0) state.emittedReadable = false;\n\n      // If we're doing read(0) to trigger a readable event, but we\n      // already have a bunch of data in the buffer, then just trigger\n      // the 'readable' event and move on.\n      if (\n        n === 0 &&\n        state.needReadable &&\n        ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)\n      ) {\n        __DEBUG__ && debug(\"read: emitReadable or endReadable\", state.length, state.ended, this.__id);\n        if (state.length === 0 && state.ended) endReadable(this);\n        else emitReadable(this, state);\n        return null;\n      }\n\n      n = howMuchToRead(n, state);\n\n      // If we've ended, and we're now clear, then finish it up.\n      if (n === 0 && state.ended) {\n        __DEBUG__ &&\n          debug(\"read: calling endReadable if length 0 -- length, state.ended\", state.length, state.ended, this.__id);\n        if (state.length === 0) endReadable(this);\n        return null;\n      }\n\n      // All the actual chunk generation logic needs to be\n      // *below* the call to _read.  The reason is that in certain\n      // synthetic stream cases, such as passthrough streams, _read\n      // may be a completely synchronous operation which may change\n      // the state of the read buffer, providing enough data when\n      // before there was *not* enough.\n      //\n      // So, the steps are:\n      // 1. Figure out what the state of things will be after we do\n      // a read from the buffer.\n      //\n      // 2. If that resulting state will trigger a _read, then call _read.\n      // Note that this may be asynchronous, or synchronous.  Yes, it is\n      // deeply ugly to write APIs this way, but that still doesn't mean\n      // that the Readable class should behave improperly, as streams are\n      // designed to be sync/async agnostic.\n      // Take note if the _read call is sync or async (ie, if the read call\n      // has returned yet), so that we know whether or not it's safe to emit\n      // 'readable' etc.\n      //\n      // 3. Actually pull the requested chunks out of the buffer and return.\n\n      // if we need a readable event, then we need to do some reading.\n      let doRead = state.needReadable;\n      __DEBUG__ && debug(\"need readable\", doRead, this.__id);\n\n      // If we currently have less than the highWaterMark, then also read some.\n      if (state.length === 0 || state.length - n < state.highWaterMark) {\n        doRead = true;\n        __DEBUG__ && debug(\"length less than watermark\", doRead, this.__id);\n      }\n\n      // However, if we've ended, then there's no point, if we're already\n      // reading, then it's unnecessary, if we're constructing we have to wait,\n      // and if we're destroyed or errored, then it's not allowed,\n      if (state.ended || state.reading || state.destroyed || state.errored || !state.constructed) {\n        __DEBUG__ && debug(\"state.constructed?\", state.constructed, this.__id);\n        doRead = false;\n        __DEBUG__ && debug(\"reading, ended or constructing\", doRead, this.__id);\n      } else if (doRead) {\n        __DEBUG__ && debug(\"do read\", this.__id);\n        state.reading = true;\n        state.sync = true;\n        // If the length is currently zero, then we *need* a readable event.\n        if (state.length === 0) state.needReadable = true;\n\n        // Call internal read method\n        try {\n          var result = this._read(state.highWaterMark);\n          if (isPromise(result)) {\n            __DEBUG__ && debug(\"async _read\", this.__id);\n            const peeked = Bun.peek(result);\n            __DEBUG__ && debug(\"peeked promise\", peeked, this.__id);\n            if (peeked !== result) {\n              result = peeked;\n            }\n          }\n\n          if (isPromise(result) && result?.then && isCallable(result.then)) {\n            __DEBUG__ && debug(\"async _read result.then setup\", this.__id);\n            result.then(nop, function (err) {\n              errorOrDestroy(this, err);\n            });\n          }\n        } catch (err) {\n          errorOrDestroy(this, err);\n        }\n\n        state.sync = false;\n        // If _read pushed data synchronously, then `reading` will be false,\n        // and we need to re-evaluate how much data we can return to the user.\n        if (!state.reading) n = howMuchToRead(nOrig, state);\n      }\n\n      __DEBUG__ && debug(\"n @ fromList\", n, this.__id);\n      let ret;\n      if (n > 0) ret = fromList(n, state);\n      else ret = null;\n\n      __DEBUG__ && debug(\"ret @ read\", ret, this.__id);\n\n      if (ret === null) {\n        state.needReadable = state.length <= state.highWaterMark;\n        __DEBUG__ && debug(\"state.length while ret = null\", state.length, this.__id);\n        n = 0;\n      } else {\n        state.length -= n;\n        if (state.multiAwaitDrain) {\n          state.awaitDrainWriters.clear();\n        } else {\n          state.awaitDrainWriters = null;\n        }\n      }\n\n      if (state.length === 0) {\n        // If we have nothing in the buffer, then we want to know\n        // as soon as we *do* get something into the buffer.\n        if (!state.ended) state.needReadable = true;\n\n        // If we tried to read() past the EOF, then emit end on the next tick.\n        if (nOrig !== n && state.ended) endReadable(this);\n      }\n\n      if (ret !== null && !state.errorEmitted && !state.closeEmitted) {\n        state.dataEmitted = true;\n        this.emit(\"data\", ret);\n      }\n\n      return ret;\n    };\n    Readable.prototype._read = function (n) {\n      throw new ERR_METHOD_NOT_IMPLEMENTED(\"_read()\");\n    };\n    Readable.prototype.pipe = function (dest, pipeOpts) {\n      const src = this;\n      const state = this._readableState;\n      if (state.pipes.length === 1) {\n        if (!state.multiAwaitDrain) {\n          state.multiAwaitDrain = true;\n          state.awaitDrainWriters = new SafeSet(state.awaitDrainWriters ? [state.awaitDrainWriters] : []);\n        }\n      }\n      state.pipes.push(dest);\n      __DEBUG__ && debug(\"pipe count=%d opts=%j\", state.pipes.length, pipeOpts, src.__id);\n      const doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;\n      const endFn = doEnd ? onend : unpipe;\n      if (state.endEmitted) runOnNextTick(endFn);\n      else src.once(\"end\", endFn);\n      dest.on(\"unpipe\", onunpipe);\n      function onunpipe(readable, unpipeInfo) {\n        __DEBUG__ && debug(\"onunpipe\", src.__id);\n        if (readable === src) {\n          if (unpipeInfo && unpipeInfo.hasUnpiped === false) {\n            unpipeInfo.hasUnpiped = true;\n            cleanup();\n          }\n        }\n      }\n      function onend() {\n        __DEBUG__ && debug(\"onend\", src.__id);\n        dest.end();\n      }\n      let ondrain;\n      let cleanedUp = false;\n      function cleanup() {\n        __DEBUG__ && debug(\"cleanup\", src.__id);\n        dest.removeListener(\"close\", onclose);\n        dest.removeListener(\"finish\", onfinish);\n        if (ondrain) {\n          dest.removeListener(\"drain\", ondrain);\n        }\n        dest.removeListener(\"error\", onerror);\n        dest.removeListener(\"unpipe\", onunpipe);\n        src.removeListener(\"end\", onend);\n        src.removeListener(\"end\", unpipe);\n        src.removeListener(\"data\", ondata);\n        cleanedUp = true;\n        if (ondrain && state.awaitDrainWriters && (!dest._writableState || dest._writableState.needDrain)) ondrain();\n      }\n      function pause() {\n        if (!cleanedUp) {\n          if (state.pipes.length === 1 && state.pipes[0] === dest) {\n            __DEBUG__ && debug(\"false write response, pause\", 0, src.__id);\n            state.awaitDrainWriters = dest;\n            state.multiAwaitDrain = false;\n          } else if (state.pipes.length > 1 && state.pipes.includes(dest)) {\n            __DEBUG__ && debug(\"false write response, pause\", state.awaitDrainWriters.size, src.__id);\n            state.awaitDrainWriters.add(dest);\n          }\n          src.pause();\n        }\n        if (!ondrain) {\n          ondrain = pipeOnDrain(src, dest);\n          dest.on(\"drain\", ondrain);\n        }\n      }\n      src.on(\"data\", ondata);\n      function ondata(chunk) {\n        __DEBUG__ && debug(\"ondata\", src.__id);\n        const ret = dest.write(chunk);\n        __DEBUG__ && debug(\"dest.write\", ret, src.__id);\n        if (ret === false) {\n          pause();\n        }\n      }\n      function onerror(er) {\n        debug(\"onerror\", er);\n        unpipe();\n        dest.removeListener(\"error\", onerror);\n        if (dest.listenerCount(\"error\") === 0) {\n          const s = dest._writableState || dest._readableState;\n          if (s && !s.errorEmitted) {\n            errorOrDestroy(dest, er);\n          } else {\n            dest.emit(\"error\", er);\n          }\n        }\n      }\n      prependListener(dest, \"error\", onerror);\n      function onclose() {\n        dest.removeListener(\"finish\", onfinish);\n        unpipe();\n      }\n      dest.once(\"close\", onclose);\n      function onfinish() {\n        debug(\"onfinish\");\n        dest.removeListener(\"close\", onclose);\n        unpipe();\n      }\n      dest.once(\"finish\", onfinish);\n      function unpipe() {\n        debug(\"unpipe\");\n        src.unpipe(dest);\n      }\n      dest.emit(\"pipe\", src);\n      if (dest.writableNeedDrain === true) {\n        if (state.flowing) {\n          pause();\n        }\n      } else if (!state.flowing) {\n        debug(\"pipe resume\");\n        src.resume();\n      }\n      return dest;\n    };\n    function pipeOnDrain(src, dest) {\n      return function pipeOnDrainFunctionResult() {\n        const state = src._readableState;\n        if (state.awaitDrainWriters === dest) {\n          debug(\"pipeOnDrain\", 1);\n          state.awaitDrainWriters = null;\n        } else if (state.multiAwaitDrain) {\n          debug(\"pipeOnDrain\", state.awaitDrainWriters.size);\n          state.awaitDrainWriters.delete(dest);\n        }\n        if ((!state.awaitDrainWriters || state.awaitDrainWriters.size === 0) && src.listenerCount(\"data\")) {\n          src.resume();\n        }\n      };\n    }\n    Readable.prototype.unpipe = function (dest) {\n      const state = this._readableState;\n      const unpipeInfo = {\n        hasUnpiped: false,\n      };\n      if (state.pipes.length === 0) return this;\n      if (!dest) {\n        const dests = state.pipes;\n        state.pipes = [];\n        this.pause();\n        for (let i = 0; i < dests.length; i++)\n          dests[i].emit(\"unpipe\", this, {\n            hasUnpiped: false,\n          });\n        return this;\n      }\n      const index = ArrayPrototypeIndexOf(state.pipes, dest);\n      if (index === -1) return this;\n      state.pipes.splice(index, 1);\n      if (state.pipes.length === 0) this.pause();\n      dest.emit(\"unpipe\", this, unpipeInfo);\n      return this;\n    };\n    Readable.prototype.addListener = Readable.prototype.on;\n    Readable.prototype.removeListener = function (ev, fn) {\n      const res = Stream.prototype.removeListener.call(this, ev, fn);\n      if (ev === \"readable\") {\n        runOnNextTick(updateReadableListening, this);\n      }\n      return res;\n    };\n    Readable.prototype.off = Readable.prototype.removeListener;\n    Readable.prototype.removeAllListeners = function (ev) {\n      const res = Stream.prototype.removeAllListeners.apply(this, arguments);\n      if (ev === \"readable\" || ev === void 0) {\n        runOnNextTick(updateReadableListening, this);\n      }\n      return res;\n    };\n    function updateReadableListening(self) {\n      const state = self._readableState;\n      state.readableListening = self.listenerCount(\"readable\") > 0;\n      if (state.resumeScheduled && state.paused === false) {\n        state.flowing = true;\n      } else if (self.listenerCount(\"data\") > 0) {\n        self.resume();\n      } else if (!state.readableListening) {\n        state.flowing = null;\n      }\n    }\n    function nReadingNextTick(self) {\n      __DEBUG__ && debug(\"on readable nextTick, calling read(0)\", self.__id);\n      self.read(0);\n    }\n    Readable.prototype.resume = function () {\n      const state = this._readableState;\n      if (!state.flowing) {\n        __DEBUG__ && debug(\"resume\", this.__id);\n        state.flowing = !state.readableListening;\n        resume(this, state);\n      }\n      state.paused = false;\n      return this;\n    };\n    Readable.prototype.pause = function () {\n      __DEBUG__ && debug(\"call pause flowing=%j\", this._readableState.flowing, this.__id);\n      if (this._readableState.flowing !== false) {\n        __DEBUG__ && debug(\"pause\", this.__id);\n        this._readableState.flowing = false;\n        this.emit(\"pause\");\n      }\n      this._readableState.paused = true;\n      return this;\n    };\n    Readable.prototype.wrap = function (stream) {\n      let paused = false;\n      stream.on(\"data\", chunk => {\n        if (!this.push(chunk) && stream.pause) {\n          paused = true;\n          stream.pause();\n        }\n      });\n      stream.on(\"end\", () => {\n        this.push(null);\n      });\n      stream.on(\"error\", err => {\n        errorOrDestroy(this, err);\n      });\n      stream.on(\"close\", () => {\n        this.destroy();\n      });\n      stream.on(\"destroy\", () => {\n        this.destroy();\n      });\n      this._read = () => {\n        if (paused && stream.resume) {\n          paused = false;\n          stream.resume();\n        }\n      };\n      const streamKeys = ObjectKeys(stream);\n      for (let j = 1; j < streamKeys.length; j++) {\n        const i = streamKeys[j];\n        if (this[i] === void 0 && typeof stream[i] === \"function\") {\n          this[i] = stream[i].bind(stream);\n        }\n      }\n      return this;\n    };\n    Readable.prototype[SymbolAsyncIterator] = function () {\n      return streamToAsyncIterator(this);\n    };\n    Readable.prototype.iterator = function (options) {\n      if (options !== void 0) {\n        validateObject(options, \"options\");\n      }\n      return streamToAsyncIterator(this, options);\n    };\n    function streamToAsyncIterator(stream, options) {\n      if (typeof stream.read !== \"function\") {\n        stream = Readable.wrap(stream, {\n          objectMode: true,\n        });\n      }\n      const iter = createAsyncIterator(stream, options);\n      iter.stream = stream;\n      return iter;\n    }\n    async function* createAsyncIterator(stream, options) {\n      let callback = nop;\n      function next(resolve) {\n        if (this === stream) {\n          callback();\n          callback = nop;\n        } else {\n          callback = resolve;\n        }\n      }\n      stream.on(\"readable\", next);\n      let error;\n      const cleanup = eos(\n        stream,\n        {\n          writable: false,\n        },\n        err => {\n          error = err ? aggregateTwoErrors(error, err) : null;\n          callback();\n          callback = nop;\n        },\n      );\n      try {\n        while (true) {\n          const chunk = stream.destroyed ? null : stream.read();\n          if (chunk !== null) {\n            yield chunk;\n          } else if (error) {\n            throw error;\n          } else if (error === null) {\n            return;\n          } else {\n            await new Promise2(next);\n          }\n        }\n      } catch (err) {\n        error = aggregateTwoErrors(error, err);\n        throw error;\n      } finally {\n        if (\n          (error || (options === null || options === void 0 ? void 0 : options.destroyOnReturn) !== false) &&\n          (error === void 0 || stream._readableState.autoDestroy)\n        ) {\n          destroyImpl.destroyer(stream, null);\n        } else {\n          stream.off(\"readable\", next);\n          cleanup();\n        }\n      }\n    }\n    ObjectDefineProperties(Readable.prototype, {\n      readable: {\n        get() {\n          const r = this._readableState;\n          return !!r && r.readable !== false && !r.destroyed && !r.errorEmitted && !r.endEmitted;\n        },\n        set(val) {\n          if (this._readableState) {\n            this._readableState.readable = !!val;\n          }\n        },\n      },\n      readableDidRead: {\n        enumerable: false,\n        get: function () {\n          return this._readableState.dataEmitted;\n        },\n      },\n      readableAborted: {\n        enumerable: false,\n        get: function () {\n          return !!(\n            this._readableState.readable !== false &&\n            (this._readableState.destroyed || this._readableState.errored) &&\n            !this._readableState.endEmitted\n          );\n        },\n      },\n      readableHighWaterMark: {\n        enumerable: false,\n        get: function () {\n          return this._readableState.highWaterMark;\n        },\n      },\n      readableBuffer: {\n        enumerable: false,\n        get: function () {\n          return this._readableState && this._readableState.buffer;\n        },\n      },\n      readableFlowing: {\n        enumerable: false,\n        get: function () {\n          return this._readableState.flowing;\n        },\n        set: function (state) {\n          if (this._readableState) {\n            this._readableState.flowing = state;\n          }\n        },\n      },\n      readableLength: {\n        enumerable: false,\n        get() {\n          return this._readableState.length;\n        },\n      },\n      readableObjectMode: {\n        enumerable: false,\n        get() {\n          return this._readableState ? this._readableState.objectMode : false;\n        },\n      },\n      readableEncoding: {\n        enumerable: false,\n        get() {\n          return this._readableState ? this._readableState.encoding : null;\n        },\n      },\n      errored: {\n        enumerable: false,\n        get() {\n          return this._readableState ? this._readableState.errored : null;\n        },\n      },\n      closed: {\n        get() {\n          return this._readableState ? this._readableState.closed : false;\n        },\n      },\n      destroyed: {\n        enumerable: false,\n        get() {\n          return this._readableState ? this._readableState.destroyed : false;\n        },\n        set(value) {\n          if (!this._readableState) {\n            return;\n          }\n          this._readableState.destroyed = value;\n        },\n      },\n      readableEnded: {\n        enumerable: false,\n        get() {\n          return this._readableState ? this._readableState.endEmitted : false;\n        },\n      },\n    });\n    Readable._fromList = fromList;\n    function fromList(n, state) {\n      if (state.length === 0) return null;\n      let ret;\n      if (state.objectMode) ret = state.buffer.shift();\n      else if (!n || n >= state.length) {\n        if (state.decoder) ret = state.buffer.join(\"\");\n        else if (state.buffer.length === 1) ret = state.buffer.first();\n        else ret = state.buffer.concat(state.length);\n        state.buffer.clear();\n      } else {\n        ret = state.buffer.consume(n, state.decoder);\n      }\n      return ret;\n    }\n    function endReadable(stream) {\n      const state = stream._readableState;\n      __DEBUG__ && debug(\"endEmitted @ endReadable\", state.endEmitted, stream.__id);\n      if (!state.endEmitted) {\n        state.ended = true;\n        runOnNextTick(endReadableNT, state, stream);\n      }\n    }\n    function endReadableNT(state, stream) {\n      __DEBUG__ && debug(\"endReadableNT -- endEmitted, state.length\", state.endEmitted, state.length, stream.__id);\n      if (!state.errored && !state.closeEmitted && !state.endEmitted && state.length === 0) {\n        state.endEmitted = true;\n        stream.emit(\"end\");\n        __DEBUG__ && debug(\"end emitted @ endReadableNT\", stream.__id);\n        if (stream.writable && stream.allowHalfOpen === false) {\n          runOnNextTick(endWritableNT, stream);\n        } else if (state.autoDestroy) {\n          const wState = stream._writableState;\n          const autoDestroy = !wState || (wState.autoDestroy && (wState.finished || wState.writable === false));\n          if (autoDestroy) {\n            stream.destroy();\n          }\n        }\n      }\n    }\n    function endWritableNT(stream) {\n      const writable = stream.writable && !stream.writableEnded && !stream.destroyed;\n      if (writable) {\n        stream.end();\n      }\n    }\n    Readable.from = function (iterable, opts) {\n      return from(Readable, iterable, opts);\n    };\n    var webStreamsAdapters = {\n      newStreamReadableFromReadableStream,\n    };\n    function lazyWebStreams() {\n      if (webStreamsAdapters === void 0) webStreamsAdapters = {};\n      return webStreamsAdapters;\n    }\n    Readable.fromWeb = function (readableStream, options) {\n      return lazyWebStreams().newStreamReadableFromReadableStream(readableStream, options);\n    };\n    Readable.toWeb = function (streamReadable) {\n      return lazyWebStreams().newReadableStreamFromStreamReadable(streamReadable);\n    };\n    Readable.wrap = function (src, options) {\n      var _ref, _src$readableObjectMo;\n      return new Readable({\n        objectMode:\n          (_ref =\n            (_src$readableObjectMo = src.readableObjectMode) !== null && _src$readableObjectMo !== void 0\n              ? _src$readableObjectMo\n              : src.objectMode) !== null && _ref !== void 0\n            ? _ref\n            : true,\n        ...options,\n        destroy(err, callback) {\n          destroyImpl.destroyer(src, err);\n          callback(err);\n        },\n      }).wrap(src);\n    };\n  },\n});\n\n// node_modules/readable-stream/lib/internal/streams/writable.js\nvar require_writable = __commonJS({\n  \"node_modules/readable-stream/lib/internal/streams/writable.js\"(exports, module) {\n    \"use strict\";\n    var {\n      ArrayPrototypeSlice,\n      Error: Error2,\n      FunctionPrototypeSymbolHasInstance,\n      ObjectDefineProperty,\n      ObjectDefineProperties,\n      ObjectSetPrototypeOf,\n      StringPrototypeToLowerCase,\n      Symbol: Symbol2,\n      SymbolHasInstance,\n    } = require_primordials();\n\n    var { EventEmitter: EE } = __require(\"bun:events_native\");\n    var Stream = require_legacy().Stream;\n    var destroyImpl = require_destroy();\n    var { addAbortSignal } = require_add_abort_signal();\n    var { getHighWaterMark, getDefaultHighWaterMark } = require_state();\n    var {\n      ERR_INVALID_ARG_TYPE,\n      ERR_METHOD_NOT_IMPLEMENTED,\n      ERR_MULTIPLE_CALLBACK,\n      ERR_STREAM_CANNOT_PIPE,\n      ERR_STREAM_DESTROYED,\n      ERR_STREAM_ALREADY_FINISHED,\n      ERR_STREAM_NULL_VALUES,\n      ERR_STREAM_WRITE_AFTER_END,\n      ERR_UNKNOWN_ENCODING,\n    } = require_errors().codes;\n    var { errorOrDestroy } = destroyImpl;\n\n    function Writable(options = {}) {\n      const isDuplex = this instanceof require_duplex();\n      if (!isDuplex && !FunctionPrototypeSymbolHasInstance(Writable, this)) return new Writable(options);\n      this._writableState = new WritableState(options, this, isDuplex);\n      if (options) {\n        if (typeof options.write === \"function\") this._write = options.write;\n        if (typeof options.writev === \"function\") this._writev = options.writev;\n        if (typeof options.destroy === \"function\") this._destroy = options.destroy;\n        if (typeof options.final === \"function\") this._final = options.final;\n        if (typeof options.construct === \"function\") this._construct = options.construct;\n        if (options.signal) addAbortSignal(options.signal, this);\n      }\n      Stream.call(this, options);\n\n      destroyImpl.construct(this, () => {\n        const state = this._writableState;\n        if (!state.writing) {\n          clearBuffer(this, state);\n        }\n        finishMaybe(this, state);\n      });\n    }\n    ObjectSetPrototypeOf(Writable.prototype, Stream.prototype);\n    ObjectSetPrototypeOf(Writable, Stream);\n    module.exports = Writable;\n\n    function nop() {}\n    var kOnFinished = Symbol2(\"kOnFinished\");\n    function WritableState(options, stream, isDuplex) {\n      if (typeof isDuplex !== \"boolean\") isDuplex = stream instanceof require_duplex();\n      this.objectMode = !!(options && options.objectMode);\n      if (isDuplex) this.objectMode = this.objectMode || !!(options && options.writableObjectMode);\n      this.highWaterMark = options\n        ? getHighWaterMark(this, options, \"writableHighWaterMark\", isDuplex)\n        : getDefaultHighWaterMark(false);\n      this.finalCalled = false;\n      this.needDrain = false;\n      this.ending = false;\n      this.ended = false;\n      this.finished = false;\n      this.destroyed = false;\n      const noDecode = !!(options && options.decodeStrings === false);\n      this.decodeStrings = !noDecode;\n      this.defaultEncoding = (options && options.defaultEncoding) || \"utf8\";\n      this.length = 0;\n      this.writing = false;\n      this.corked = 0;\n      this.sync = true;\n      this.bufferProcessing = false;\n      this.onwrite = onwrite.bind(void 0, stream);\n      this.writecb = null;\n      this.writelen = 0;\n      this.afterWriteTickInfo = null;\n      resetBuffer(this);\n      this.pendingcb = 0;\n      this.constructed = true;\n      this.prefinished = false;\n      this.errorEmitted = false;\n      this.emitClose = !options || options.emitClose !== false;\n      this.autoDestroy = !options || options.autoDestroy !== false;\n      this.errored = null;\n      this.closed = false;\n      this.closeEmitted = false;\n      this[kOnFinished] = [];\n    }\n    function resetBuffer(state) {\n      state.buffered = [];\n      state.bufferedIndex = 0;\n      state.allBuffers = true;\n      state.allNoop = true;\n    }\n    WritableState.prototype.getBuffer = function getBuffer() {\n      return ArrayPrototypeSlice(this.buffered, this.bufferedIndex);\n    };\n    ObjectDefineProperty(WritableState.prototype, \"bufferedRequestCount\", {\n      get() {\n        return this.buffered.length - this.bufferedIndex;\n      },\n    });\n\n    ObjectDefineProperty(Writable, SymbolHasInstance, {\n      value: function (object) {\n        if (FunctionPrototypeSymbolHasInstance(this, object)) return true;\n        if (this !== Writable) return false;\n        return object && object._writableState instanceof WritableState;\n      },\n    });\n    Writable.prototype.pipe = function () {\n      errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());\n    };\n    function _write(stream, chunk, encoding, cb) {\n      const state = stream._writableState;\n      if (typeof encoding === \"function\") {\n        cb = encoding;\n        encoding = state.defaultEncoding;\n      } else {\n        if (!encoding) encoding = state.defaultEncoding;\n        else if (encoding !== \"buffer\" && !Buffer.isEncoding(encoding)) throw new ERR_UNKNOWN_ENCODING(encoding);\n        if (typeof cb !== \"function\") cb = nop;\n      }\n      if (chunk === null) {\n        throw new ERR_STREAM_NULL_VALUES();\n      } else if (!state.objectMode) {\n        if (typeof chunk === \"string\") {\n          if (state.decodeStrings !== false) {\n            chunk = Buffer.from(chunk, encoding);\n            encoding = \"buffer\";\n          }\n        } else if (chunk instanceof Buffer) {\n          encoding = \"buffer\";\n        } else if (Stream._isUint8Array(chunk)) {\n          chunk = Stream._uint8ArrayToBuffer(chunk);\n          encoding = \"buffer\";\n        } else {\n          throw new ERR_INVALID_ARG_TYPE(\"chunk\", [\"string\", \"Buffer\", \"Uint8Array\"], chunk);\n        }\n      }\n      let err;\n      if (state.ending) {\n        err = new ERR_STREAM_WRITE_AFTER_END();\n      } else if (state.destroyed) {\n        err = new ERR_STREAM_DESTROYED(\"write\");\n      }\n      if (err) {\n        runOnNextTick(cb, err);\n        errorOrDestroy(stream, err, true);\n        return err;\n      }\n      state.pendingcb++;\n      return writeOrBuffer(stream, state, chunk, encoding, cb);\n    }\n    Writable.prototype.write = function (chunk, encoding, cb) {\n      return _write(this, chunk, encoding, cb) === true;\n    };\n    Writable.prototype.cork = function () {\n      this._writableState.corked++;\n    };\n    Writable.prototype.uncork = function () {\n      const state = this._writableState;\n      if (state.corked) {\n        state.corked--;\n        if (!state.writing) clearBuffer(this, state);\n      }\n    };\n    Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {\n      if (typeof encoding === \"string\") encoding = StringPrototypeToLowerCase(encoding);\n      if (!Buffer.isEncoding(encoding)) throw new ERR_UNKNOWN_ENCODING(encoding);\n      this._writableState.defaultEncoding = encoding;\n      return this;\n    };\n    function writeOrBuffer(stream, state, chunk, encoding, callback) {\n      const len = state.objectMode ? 1 : chunk.length;\n      state.length += len;\n      const ret = state.length < state.highWaterMark;\n      if (!ret) state.needDrain = true;\n      if (state.writing || state.corked || state.errored || !state.constructed) {\n        state.buffered.push({\n          chunk,\n          encoding,\n          callback,\n        });\n        if (state.allBuffers && encoding !== \"buffer\") {\n          state.allBuffers = false;\n        }\n        if (state.allNoop && callback !== nop) {\n          state.allNoop = false;\n        }\n      } else {\n        state.writelen = len;\n        state.writecb = callback;\n        state.writing = true;\n        state.sync = true;\n        stream._write(chunk, encoding, state.onwrite);\n        state.sync = false;\n      }\n      return ret && !state.errored && !state.destroyed;\n    }\n    function doWrite(stream, state, writev, len, chunk, encoding, cb) {\n      state.writelen = len;\n      state.writecb = cb;\n      state.writing = true;\n      state.sync = true;\n      if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED(\"write\"));\n      else if (writev) stream._writev(chunk, state.onwrite);\n      else stream._write(chunk, encoding, state.onwrite);\n      state.sync = false;\n    }\n    function onwriteError(stream, state, er, cb) {\n      --state.pendingcb;\n      cb(er);\n      errorBuffer(state);\n      errorOrDestroy(stream, er);\n    }\n    function onwrite(stream, er) {\n      const state = stream._writableState;\n      const sync = state.sync;\n      const cb = state.writecb;\n      if (typeof cb !== \"function\") {\n        errorOrDestroy(stream, new ERR_MULTIPLE_CALLBACK());\n        return;\n      }\n      state.writing = false;\n      state.writecb = null;\n      state.length -= state.writelen;\n      state.writelen = 0;\n      if (er) {\n        Error.captureStackTrace(er);\n        if (!state.errored) {\n          state.errored = er;\n        }\n        if (stream._readableState && !stream._readableState.errored) {\n          stream._readableState.errored = er;\n        }\n        if (sync) {\n          runOnNextTick(onwriteError, stream, state, er, cb);\n        } else {\n          onwriteError(stream, state, er, cb);\n        }\n      } else {\n        if (state.buffered.length > state.bufferedIndex) {\n          clearBuffer(stream, state);\n        }\n        if (sync) {\n          if (state.afterWriteTickInfo !== null && state.afterWriteTickInfo.cb === cb) {\n            state.afterWriteTickInfo.count++;\n          } else {\n            state.afterWriteTickInfo = {\n              count: 1,\n              cb,\n              stream,\n              state,\n            };\n            runOnNextTick(afterWriteTick, state.afterWriteTickInfo);\n          }\n        } else {\n          afterWrite(stream, state, 1, cb);\n        }\n      }\n    }\n    function afterWriteTick({ stream, state, count, cb }) {\n      state.afterWriteTickInfo = null;\n      return afterWrite(stream, state, count, cb);\n    }\n    function afterWrite(stream, state, count, cb) {\n      const needDrain = !state.ending && !stream.destroyed && state.length === 0 && state.needDrain;\n      if (needDrain) {\n        state.needDrain = false;\n        stream.emit(\"drain\");\n      }\n      while (count-- > 0) {\n        state.pendingcb--;\n        cb();\n      }\n      if (state.destroyed) {\n        errorBuffer(state);\n      }\n      finishMaybe(stream, state);\n    }\n    function errorBuffer(state) {\n      if (state.writing) {\n        return;\n      }\n      for (let n = state.bufferedIndex; n < state.buffered.length; ++n) {\n        var _state$errored;\n        const { chunk, callback } = state.buffered[n];\n        const len = state.objectMode ? 1 : chunk.length;\n        state.length -= len;\n        callback(\n          (_state$errored = state.errored) !== null && _state$errored !== void 0\n            ? _state$errored\n            : new ERR_STREAM_DESTROYED(\"write\"),\n        );\n      }\n      const onfinishCallbacks = state[kOnFinished].splice(0);\n      for (let i = 0; i < onfinishCallbacks.length; i++) {\n        var _state$errored2;\n        onfinishCallbacks[i](\n          (_state$errored2 = state.errored) !== null && _state$errored2 !== void 0\n            ? _state$errored2\n            : new ERR_STREAM_DESTROYED(\"end\"),\n        );\n      }\n      resetBuffer(state);\n    }\n    function clearBuffer(stream, state) {\n      if (state.corked || state.bufferProcessing || state.destroyed || !state.constructed) {\n        return;\n      }\n      const { buffered, bufferedIndex, objectMode } = state;\n      const bufferedLength = buffered.length - bufferedIndex;\n      if (!bufferedLength) {\n        return;\n      }\n      let i = bufferedIndex;\n      state.bufferProcessing = true;\n      if (bufferedLength > 1 && stream._writev) {\n        state.pendingcb -= bufferedLength - 1;\n        const callback = state.allNoop\n          ? nop\n          : err => {\n              for (let n = i; n < buffered.length; ++n) {\n                buffered[n].callback(err);\n              }\n            };\n        const chunks = state.allNoop && i === 0 ? buffered : ArrayPrototypeSlice(buffered, i);\n        chunks.allBuffers = state.allBuffers;\n        doWrite(stream, state, true, state.length, chunks, \"\", callback);\n        resetBuffer(state);\n      } else {\n        do {\n          const { chunk, encoding, callback } = buffered[i];\n          buffered[i++] = null;\n          const len = objectMode ? 1 : chunk.length;\n          doWrite(stream, state, false, len, chunk, encoding, callback);\n        } while (i < buffered.length && !state.writing);\n        if (i === buffered.length) {\n          resetBuffer(state);\n        } else if (i > 256) {\n          buffered.splice(0, i);\n          state.bufferedIndex = 0;\n        } else {\n          state.bufferedIndex = i;\n        }\n      }\n      state.bufferProcessing = false;\n    }\n    Writable.prototype._write = function (chunk, encoding, cb) {\n      if (this._writev) {\n        this._writev(\n          [\n            {\n              chunk,\n              encoding,\n            },\n          ],\n          cb,\n        );\n      } else {\n        throw new ERR_METHOD_NOT_IMPLEMENTED(\"_write()\");\n      }\n    };\n    Writable.prototype._writev = null;\n    Writable.prototype.end = function (chunk, encoding, cb, native = false) {\n      const state = this._writableState;\n      __DEBUG__ && debug(\"end\", state, this.__id);\n      if (typeof chunk === \"function\") {\n        cb = chunk;\n        chunk = null;\n        encoding = null;\n      } else if (typeof encoding === \"function\") {\n        cb = encoding;\n        encoding = null;\n      }\n      let err;\n      if (chunk !== null && chunk !== void 0) {\n        let ret;\n        if (!native) {\n          ret = _write(this, chunk, encoding);\n        } else {\n          ret = this.write(chunk, encoding);\n        }\n        if (ret instanceof Error2) {\n          err = ret;\n        }\n      }\n      if (state.corked) {\n        state.corked = 1;\n        this.uncork();\n      }\n      if (err) {\n        this.emit(\"error\", err);\n      } else if (!state.errored && !state.ending) {\n        state.ending = true;\n        finishMaybe(this, state, true);\n        state.ended = true;\n      } else if (state.finished) {\n        err = new ERR_STREAM_ALREADY_FINISHED(\"end\");\n      } else if (state.destroyed) {\n        err = new ERR_STREAM_DESTROYED(\"end\");\n      }\n      if (typeof cb === \"function\") {\n        if (err || state.finished) {\n          runOnNextTick(cb, err);\n        } else {\n          state[kOnFinished].push(cb);\n        }\n      }\n      return this;\n    };\n    function needFinish(state, tag) {\n      var needFinish =\n        state.ending &&\n        !state.destroyed &&\n        state.constructed &&\n        state.length === 0 &&\n        !state.errored &&\n        state.buffered.length === 0 &&\n        !state.finished &&\n        !state.writing &&\n        !state.errorEmitted &&\n        !state.closeEmitted;\n      debug(\"needFinish\", needFinish, tag);\n      return needFinish;\n    }\n    function callFinal(stream, state) {\n      let called = false;\n      function onFinish(err) {\n        if (called) {\n          errorOrDestroy(stream, err !== null && err !== void 0 ? err : ERR_MULTIPLE_CALLBACK());\n          return;\n        }\n        called = true;\n        state.pendingcb--;\n        if (err) {\n          const onfinishCallbacks = state[kOnFinished].splice(0);\n          for (let i = 0; i < onfinishCallbacks.length; i++) {\n            onfinishCallbacks[i](err);\n          }\n          errorOrDestroy(stream, err, state.sync);\n        } else if (needFinish(state)) {\n          state.prefinished = true;\n          stream.emit(\"prefinish\");\n          state.pendingcb++;\n          runOnNextTick(finish, stream, state);\n        }\n      }\n      state.sync = true;\n      state.pendingcb++;\n      try {\n        stream._final(onFinish);\n      } catch (err) {\n        onFinish(err);\n      }\n      state.sync = false;\n    }\n    function prefinish(stream, state) {\n      if (!state.prefinished && !state.finalCalled) {\n        if (typeof stream._final === \"function\" && !state.destroyed) {\n          state.finalCalled = true;\n          callFinal(stream, state);\n        } else {\n          state.prefinished = true;\n          stream.emit(\"prefinish\");\n        }\n      }\n    }\n    function finishMaybe(stream, state, sync) {\n      __DEBUG__ && debug(\"finishMaybe -- state, sync\", state, sync, stream.__id);\n\n      if (!needFinish(state, stream.__id)) return;\n\n      prefinish(stream, state);\n      if (state.pendingcb === 0) {\n        if (sync) {\n          state.pendingcb++;\n          runOnNextTick(\n            (stream2, state2) => {\n              if (needFinish(state2)) {\n                finish(stream2, state2);\n              } else {\n                state2.pendingcb--;\n              }\n            },\n            stream,\n            state,\n          );\n        } else if (needFinish(state)) {\n          state.pendingcb++;\n          finish(stream, state);\n        }\n      }\n    }\n    function finish(stream, state) {\n      state.pendingcb--;\n      state.finished = true;\n      const onfinishCallbacks = state[kOnFinished].splice(0);\n      for (let i = 0; i < onfinishCallbacks.length; i++) {\n        onfinishCallbacks[i]();\n      }\n      stream.emit(\"finish\");\n      if (state.autoDestroy) {\n        const rState = stream._readableState;\n        const autoDestroy = !rState || (rState.autoDestroy && (rState.endEmitted || rState.readable === false));\n        if (autoDestroy) {\n          stream.destroy();\n        }\n      }\n    }\n    ObjectDefineProperties(Writable.prototype, {\n      closed: {\n        get() {\n          return this._writableState ? this._writableState.closed : false;\n        },\n      },\n      destroyed: {\n        get() {\n          return this._writableState ? this._writableState.destroyed : false;\n        },\n        set(value) {\n          if (this._writableState) {\n            this._writableState.destroyed = value;\n          }\n        },\n      },\n      writable: {\n        get() {\n          const w = this._writableState;\n          return !!w && w.writable !== false && !w.destroyed && !w.errored && !w.ending && !w.ended;\n        },\n        set(val) {\n          if (this._writableState) {\n            this._writableState.writable = !!val;\n          }\n        },\n      },\n      writableFinished: {\n        get() {\n          return this._writableState ? this._writableState.finished : false;\n        },\n      },\n      writableObjectMode: {\n        get() {\n          return this._writableState ? this._writableState.objectMode : false;\n        },\n      },\n      writableBuffer: {\n        get() {\n          return this._writableState && this._writableState.getBuffer();\n        },\n      },\n      writableEnded: {\n        get() {\n          return this._writableState ? this._writableState.ending : false;\n        },\n      },\n      writableNeedDrain: {\n        get() {\n          const wState = this._writableState;\n          if (!wState) return false;\n          return !wState.destroyed && !wState.ending && wState.needDrain;\n        },\n      },\n      writableHighWaterMark: {\n        get() {\n          return this._writableState && this._writableState.highWaterMark;\n        },\n      },\n      writableCorked: {\n        get() {\n          return this._writableState ? this._writableState.corked : 0;\n        },\n      },\n      writableLength: {\n        get() {\n          return this._writableState && this._writableState.length;\n        },\n      },\n      errored: {\n        enumerable: false,\n        get() {\n          return this._writableState ? this._writableState.errored : null;\n        },\n      },\n      writableAborted: {\n        enumerable: false,\n        get: function () {\n          return !!(\n            this._writableState.writable !== false &&\n            (this._writableState.destroyed || this._writableState.errored) &&\n            !this._writableState.finished\n          );\n        },\n      },\n    });\n    var destroy = destroyImpl.destroy;\n    Writable.prototype.destroy = function (err, cb) {\n      const state = this._writableState;\n      if (!state.destroyed && (state.bufferedIndex < state.buffered.length || state[kOnFinished].length)) {\n        runOnNextTick(errorBuffer, state);\n      }\n      destroy.call(this, err, cb);\n      return this;\n    };\n    Writable.prototype._undestroy = destroyImpl.undestroy;\n    Writable.prototype._destroy = function (err, cb) {\n      cb(err);\n    };\n    Writable.prototype[EE.captureRejectionSymbol] = function (err) {\n      this.destroy(err);\n    };\n    var webStreamsAdapters;\n    function lazyWebStreams() {\n      if (webStreamsAdapters === void 0) webStreamsAdapters = {};\n      return webStreamsAdapters;\n    }\n    Writable.fromWeb = function (writableStream, options) {\n      return lazyWebStreams().newStreamWritableFromWritableStream(writableStream, options);\n    };\n    Writable.toWeb = function (streamWritable) {\n      return lazyWebStreams().newWritableStreamFromStreamWritable(streamWritable);\n    };\n  },\n});\n\n// node_modules/readable-stream/lib/internal/streams/duplexify.js\nvar require_duplexify = __commonJS({\n  \"node_modules/readable-stream/lib/internal/streams/duplexify.js\"(exports, module) {\n    \"use strict\";\n    var bufferModule = __require(\"buffer\");\n    var {\n      isReadable,\n      isWritable,\n      isIterable,\n      isNodeStream,\n      isReadableNodeStream,\n      isWritableNodeStream,\n      isDuplexNodeStream,\n    } = require_utils();\n    var eos = require_end_of_stream();\n    var {\n      AbortError,\n      codes: { ERR_INVALID_ARG_TYPE, ERR_INVALID_RETURN_VALUE },\n    } = require_errors();\n    var { destroyer } = require_destroy();\n    var Duplex = require_duplex();\n    var Readable = require_readable();\n    var { createDeferredPromise } = require_util();\n    var from = require_from();\n    var Blob = globalThis.Blob || bufferModule.Blob;\n    var isBlob =\n      typeof Blob !== \"undefined\"\n        ? function isBlob2(b) {\n            return b instanceof Blob;\n          }\n        : function isBlob2(b) {\n            return false;\n          };\n    var AbortController = globalThis.AbortController || __require(\"abort-controller\").AbortController;\n    var { FunctionPrototypeCall } = require_primordials();\n    class Duplexify extends Duplex {\n      constructor(options) {\n        super(options);\n\n        // https://github.com/nodejs/node/pull/34385\n\n        if ((options === null || options === undefined ? undefined : options.readable) === false) {\n          this._readableState.readable = false;\n          this._readableState.ended = true;\n          this._readableState.endEmitted = true;\n        }\n        if ((options === null || options === undefined ? undefined : options.writable) === false) {\n          this._writableState.writable = false;\n          this._writableState.ending = true;\n          this._writableState.ended = true;\n          this._writableState.finished = true;\n        }\n      }\n    }\n    module.exports = function duplexify(body, name) {\n      if (isDuplexNodeStream(body)) {\n        return body;\n      }\n      if (isReadableNodeStream(body)) {\n        return _duplexify({\n          readable: body,\n        });\n      }\n      if (isWritableNodeStream(body)) {\n        return _duplexify({\n          writable: body,\n        });\n      }\n      if (isNodeStream(body)) {\n        return _duplexify({\n          writable: false,\n          readable: false,\n        });\n      }\n      if (typeof body === \"function\") {\n        const { value, write, final, destroy } = fromAsyncGen(body);\n        if (isIterable(value)) {\n          return from(Duplexify, value, {\n            objectMode: true,\n            write,\n            final,\n            destroy,\n          });\n        }\n        const then2 = value === null || value === void 0 ? void 0 : value.then;\n        if (typeof then2 === \"function\") {\n          let d;\n          const promise = FunctionPrototypeCall(\n            then2,\n            value,\n            val => {\n              if (val != null) {\n                throw new ERR_INVALID_RETURN_VALUE(\"nully\", \"body\", val);\n              }\n            },\n            err => {\n              destroyer(d, err);\n            },\n          );\n          return (d = new Duplexify({\n            objectMode: true,\n            readable: false,\n            write,\n            final(cb) {\n              final(async () => {\n                try {\n                  await promise;\n                  runOnNextTick(cb, null);\n                } catch (err) {\n                  runOnNextTick(cb, err);\n                }\n              });\n            },\n            destroy,\n          }));\n        }\n        throw new ERR_INVALID_RETURN_VALUE(\"Iterable, AsyncIterable or AsyncFunction\", name, value);\n      }\n      if (isBlob(body)) {\n        return duplexify(body.arrayBuffer());\n      }\n      if (isIterable(body)) {\n        return from(Duplexify, body, {\n          objectMode: true,\n          writable: false,\n        });\n      }\n      if (\n        typeof (body === null || body === void 0 ? void 0 : body.writable) === \"object\" ||\n        typeof (body === null || body === void 0 ? void 0 : body.readable) === \"object\"\n      ) {\n        const readable =\n          body !== null && body !== void 0 && body.readable\n            ? isReadableNodeStream(body === null || body === void 0 ? void 0 : body.readable)\n              ? body === null || body === void 0\n                ? void 0\n                : body.readable\n              : duplexify(body.readable)\n            : void 0;\n        const writable =\n          body !== null && body !== void 0 && body.writable\n            ? isWritableNodeStream(body === null || body === void 0 ? void 0 : body.writable)\n              ? body === null || body === void 0\n                ? void 0\n                : body.writable\n              : duplexify(body.writable)\n            : void 0;\n        return _duplexify({\n          readable,\n          writable,\n        });\n      }\n      const then = body === null || body === void 0 ? void 0 : body.then;\n      if (typeof then === \"function\") {\n        let d;\n        FunctionPrototypeCall(\n          then,\n          body,\n          val => {\n            if (val != null) {\n              d.push(val);\n            }\n            d.push(null);\n          },\n          err => {\n            destroyer(d, err);\n          },\n        );\n        return (d = new Duplexify({\n          objectMode: true,\n          writable: false,\n          read() {},\n        }));\n      }\n      throw new ERR_INVALID_ARG_TYPE(\n        name,\n        [\n          \"Blob\",\n          \"ReadableStream\",\n          \"WritableStream\",\n          \"Stream\",\n          \"Iterable\",\n          \"AsyncIterable\",\n          \"Function\",\n          \"{ readable, writable } pair\",\n          \"Promise\",\n        ],\n        body,\n      );\n    };\n    function fromAsyncGen(fn) {\n      let { promise, resolve } = createDeferredPromise();\n      const ac = new AbortController();\n      const signal = ac.signal;\n      const value = fn(\n        (async function* () {\n          while (true) {\n            const _promise = promise;\n            promise = null;\n            const { chunk, done, cb } = await _promise;\n            runOnNextTick(cb);\n            if (done) return;\n            if (signal.aborted)\n              throw new AbortError(void 0, {\n                cause: signal.reason,\n              });\n            ({ promise, resolve } = createDeferredPromise());\n            yield chunk;\n          }\n        })(),\n        {\n          signal,\n        },\n      );\n      return {\n        value,\n        write(chunk, encoding, cb) {\n          const _resolve = resolve;\n          resolve = null;\n          _resolve({\n            chunk,\n            done: false,\n            cb,\n          });\n        },\n        final(cb) {\n          const _resolve = resolve;\n          resolve = null;\n          _resolve({\n            done: true,\n            cb,\n          });\n        },\n        destroy(err, cb) {\n          ac.abort();\n          cb(err);\n        },\n      };\n    }\n    function _duplexify(pair) {\n      const r =\n        pair.readable && typeof pair.readable.read !== \"function\" ? Readable.wrap(pair.readable) : pair.readable;\n      const w = pair.writable;\n      let readable = !!isReadable(r);\n      let writable = !!isWritable(w);\n      let ondrain;\n      let onfinish;\n      let onreadable;\n      let onclose;\n      let d;\n      function onfinished(err) {\n        const cb = onclose;\n        onclose = null;\n        if (cb) {\n          cb(err);\n        } else if (err) {\n          d.destroy(err);\n        } else if (!readable && !writable) {\n          d.destroy();\n        }\n      }\n      d = new Duplexify({\n        readableObjectMode: !!(r !== null && r !== void 0 && r.readableObjectMode),\n        writableObjectMode: !!(w !== null && w !== void 0 && w.writableObjectMode),\n        readable,\n        writable,\n      });\n      if (writable) {\n        eos(w, err => {\n          writable = false;\n          if (err) {\n            destroyer(r, err);\n          }\n          onfinished(err);\n        });\n        d._write = function (chunk, encoding, callback) {\n          if (w.write(chunk, encoding)) {\n            callback();\n          } else {\n            ondrain = callback;\n          }\n        };\n        d._final = function (callback) {\n          w.end();\n          onfinish = callback;\n        };\n        w.on(\"drain\", function () {\n          if (ondrain) {\n            const cb = ondrain;\n            ondrain = null;\n            cb();\n          }\n        });\n        w.on(\"finish\", function () {\n          if (onfinish) {\n            const cb = onfinish;\n            onfinish = null;\n            cb();\n          }\n        });\n      }\n      if (readable) {\n        eos(r, err => {\n          readable = false;\n          if (err) {\n            destroyer(r, err);\n          }\n          onfinished(err);\n        });\n        r.on(\"readable\", function () {\n          if (onreadable) {\n            const cb = onreadable;\n            onreadable = null;\n            cb();\n          }\n        });\n        r.on(\"end\", function () {\n          d.push(null);\n        });\n        d._read = function () {\n          while (true) {\n            const buf = r.read();\n            if (buf === null) {\n              onreadable = d._read;\n              return;\n            }\n            if (!d.push(buf)) {\n              return;\n            }\n          }\n        };\n      }\n      d._destroy = function (err, callback) {\n        if (!err && onclose !== null) {\n          err = new AbortError();\n        }\n        onreadable = null;\n        ondrain = null;\n        onfinish = null;\n        if (onclose === null) {\n          callback(err);\n        } else {\n          onclose = callback;\n          destroyer(w, err);\n          destroyer(r, err);\n        }\n      };\n      return d;\n    }\n  },\n});\n\n// node_modules/readable-stream/lib/internal/streams/duplex.js\nvar require_duplex = __commonJS({\n  \"node_modules/readable-stream/lib/internal/streams/duplex.js\"(exports, module) {\n    \"use strict\";\n    var { ObjectDefineProperties, ObjectGetOwnPropertyDescriptor, ObjectKeys, ObjectSetPrototypeOf } =\n      require_primordials();\n\n    var Readable = require_readable();\n\n    function Duplex(options) {\n      if (!(this instanceof Duplex)) return new Duplex(options);\n      Readable.call(this, options);\n      Writable.call(this, options);\n\n      if (options) {\n        this.allowHalfOpen = options.allowHalfOpen !== false;\n        if (options.readable === false) {\n          this._readableState.readable = false;\n          this._readableState.ended = true;\n          this._readableState.endEmitted = true;\n        }\n        if (options.writable === false) {\n          this._writableState.writable = false;\n          this._writableState.ending = true;\n          this._writableState.ended = true;\n          this._writableState.finished = true;\n        }\n      } else {\n        this.allowHalfOpen = true;\n      }\n    }\n    module.exports = Duplex;\n\n    ObjectSetPrototypeOf(Duplex.prototype, Readable.prototype);\n    ObjectSetPrototypeOf(Duplex, Readable);\n\n    {\n      for (var method in Writable.prototype) {\n        if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];\n      }\n    }\n\n    ObjectDefineProperties(Duplex.prototype, {\n      writable: ObjectGetOwnPropertyDescriptor(Writable.prototype, \"writable\"),\n      writableHighWaterMark: ObjectGetOwnPropertyDescriptor(Writable.prototype, \"writableHighWaterMark\"),\n      writableObjectMode: ObjectGetOwnPropertyDescriptor(Writable.prototype, \"writableObjectMode\"),\n      writableBuffer: ObjectGetOwnPropertyDescriptor(Writable.prototype, \"writableBuffer\"),\n      writableLength: ObjectGetOwnPropertyDescriptor(Writable.prototype, \"writableLength\"),\n      writableFinished: ObjectGetOwnPropertyDescriptor(Writable.prototype, \"writableFinished\"),\n      writableCorked: ObjectGetOwnPropertyDescriptor(Writable.prototype, \"writableCorked\"),\n      writableEnded: ObjectGetOwnPropertyDescriptor(Writable.prototype, \"writableEnded\"),\n      writableNeedDrain: ObjectGetOwnPropertyDescriptor(Writable.prototype, \"writableNeedDrain\"),\n      destroyed: {\n        get() {\n          if (this._readableState === void 0 || this._writableState === void 0) {\n            return false;\n          }\n          return this._readableState.destroyed && this._writableState.destroyed;\n        },\n        set(value) {\n          if (this._readableState && this._writableState) {\n            this._readableState.destroyed = value;\n            this._writableState.destroyed = value;\n          }\n        },\n      },\n    });\n    var webStreamsAdapters;\n    function lazyWebStreams() {\n      if (webStreamsAdapters === void 0) webStreamsAdapters = {};\n      return webStreamsAdapters;\n    }\n    Duplex.fromWeb = function (pair, options) {\n      return lazyWebStreams().newStreamDuplexFromReadableWritablePair(pair, options);\n    };\n    Duplex.toWeb = function (duplex) {\n      return lazyWebStreams().newReadableWritablePairFromDuplex(duplex);\n    };\n    var duplexify;\n    Duplex.from = function (body) {\n      if (!duplexify) {\n        duplexify = require_duplexify();\n      }\n      return duplexify(body, \"body\");\n    };\n  },\n});\n\n// node_modules/readable-stream/lib/internal/streams/transform.js\nvar require_transform = __commonJS({\n  \"node_modules/readable-stream/lib/internal/streams/transform.js\"(exports, module) {\n    \"use strict\";\n    var { ObjectSetPrototypeOf, Symbol: Symbol2 } = require_primordials();\n    var { ERR_METHOD_NOT_IMPLEMENTED } = require_errors().codes;\n    var Duplex = require_duplex();\n    function Transform(options) {\n      if (!(this instanceof Transform)) return new Transform(options);\n      Duplex.call(this, options);\n\n      this._readableState.sync = false;\n      this[kCallback] = null;\n\n      if (options) {\n        if (typeof options.transform === \"function\") this._transform = options.transform;\n        if (typeof options.flush === \"function\") this._flush = options.flush;\n      }\n\n      this.on(\"prefinish\", prefinish.bind(this));\n    }\n    ObjectSetPrototypeOf(Transform.prototype, Duplex.prototype);\n    ObjectSetPrototypeOf(Transform, Duplex);\n\n    module.exports = Transform;\n    var kCallback = Symbol2(\"kCallback\");\n    function final(cb) {\n      if (typeof this._flush === \"function\" && !this.destroyed) {\n        this._flush((er, data) => {\n          if (er) {\n            if (cb) {\n              cb(er);\n            } else {\n              this.destroy(er);\n            }\n            return;\n          }\n          if (data != null) {\n            this.push(data);\n          }\n          this.push(null);\n          if (cb) {\n            cb();\n          }\n        });\n      } else {\n        this.push(null);\n        if (cb) {\n          cb();\n        }\n      }\n    }\n    function prefinish() {\n      if (this._final !== final) {\n        final.call(this);\n      }\n    }\n    Transform.prototype._final = final;\n    Transform.prototype._transform = function (chunk, encoding, callback) {\n      throw new ERR_METHOD_NOT_IMPLEMENTED(\"_transform()\");\n    };\n    Transform.prototype._write = function (chunk, encoding, callback) {\n      const rState = this._readableState;\n      const wState = this._writableState;\n      const length = rState.length;\n      this._transform(chunk, encoding, (err, val) => {\n        if (err) {\n          callback(err);\n          return;\n        }\n        if (val != null) {\n          this.push(val);\n        }\n        if (\n          wState.ended ||\n          length === rState.length ||\n          rState.length < rState.highWaterMark ||\n          rState.highWaterMark === 0 ||\n          rState.length === 0\n        ) {\n          callback();\n        } else {\n          this[kCallback] = callback;\n        }\n      });\n    };\n    Transform.prototype._read = function () {\n      if (this[kCallback]) {\n        const callback = this[kCallback];\n        this[kCallback] = null;\n        callback();\n      }\n    };\n  },\n});\n\n// node_modules/readable-stream/lib/internal/streams/passthrough.js\nvar require_passthrough = __commonJS({\n  \"node_modules/readable-stream/lib/internal/streams/passthrough.js\"(exports, module) {\n    \"use strict\";\n    var { ObjectSetPrototypeOf } = require_primordials();\n    var Transform = require_transform();\n\n    function PassThrough(options) {\n      if (!(this instanceof PassThrough)) return new PassThrough(options);\n      Transform.call(this, options);\n    }\n\n    ObjectSetPrototypeOf(PassThrough.prototype, Transform.prototype);\n    ObjectSetPrototypeOf(PassThrough, Transform);\n\n    PassThrough.prototype._transform = function (chunk, encoding, cb) {\n      cb(null, chunk);\n    };\n\n    module.exports = PassThrough;\n  },\n});\n\n// node_modules/readable-stream/lib/internal/streams/pipeline.js\nvar require_pipeline = __commonJS({\n  \"node_modules/readable-stream/lib/internal/streams/pipeline.js\"(exports, module) {\n    \"use strict\";\n    var { ArrayIsArray, Promise: Promise2, SymbolAsyncIterator } = require_primordials();\n    var eos = require_end_of_stream();\n    var { once } = require_util();\n    var destroyImpl = require_destroy();\n    var Duplex = require_duplex();\n    var {\n      aggregateTwoErrors,\n      codes: { ERR_INVALID_ARG_TYPE, ERR_INVALID_RETURN_VALUE, ERR_MISSING_ARGS, ERR_STREAM_DESTROYED },\n      AbortError,\n    } = require_errors();\n    var { validateFunction, validateAbortSignal } = require_validators();\n    var { isIterable, isReadable, isReadableNodeStream, isNodeStream } = require_utils();\n    var AbortController = globalThis.AbortController || __require(\"abort-controller\").AbortController;\n    var PassThrough;\n    var Readable;\n    function destroyer(stream, reading, writing) {\n      let finished = false;\n      stream.on(\"close\", () => {\n        finished = true;\n      });\n      const cleanup = eos(\n        stream,\n        {\n          readable: reading,\n          writable: writing,\n        },\n        err => {\n          finished = !err;\n        },\n      );\n      return {\n        destroy: err => {\n          if (finished) return;\n          finished = true;\n          destroyImpl.destroyer(stream, err || new ERR_STREAM_DESTROYED(\"pipe\"));\n        },\n        cleanup,\n      };\n    }\n    function popCallback(streams) {\n      validateFunction(streams[streams.length - 1], \"streams[stream.length - 1]\");\n      return streams.pop();\n    }\n    function makeAsyncIterable(val) {\n      if (isIterable(val)) {\n        return val;\n      } else if (isReadableNodeStream(val)) {\n        return fromReadable(val);\n      }\n      throw new ERR_INVALID_ARG_TYPE(\"val\", [\"Readable\", \"Iterable\", \"AsyncIterable\"], val);\n    }\n    async function* fromReadable(val) {\n      if (!Readable) {\n        Readable = require_readable();\n      }\n      yield* Readable.prototype[SymbolAsyncIterator].call(val);\n    }\n    async function pump(iterable, writable, finish, { end }) {\n      let error;\n      let onresolve = null;\n      const resume = err => {\n        if (err) {\n          error = err;\n        }\n        if (onresolve) {\n          const callback = onresolve;\n          onresolve = null;\n          callback();\n        }\n      };\n      const wait = () =>\n        new Promise2((resolve, reject) => {\n          if (error) {\n            reject(error);\n          } else {\n            onresolve = () => {\n              if (error) {\n                reject(error);\n              } else {\n                resolve();\n              }\n            };\n          }\n        });\n      writable.on(\"drain\", resume);\n      const cleanup = eos(\n        writable,\n        {\n          readable: false,\n        },\n        resume,\n      );\n      try {\n        if (writable.writableNeedDrain) {\n          await wait();\n        }\n        for await (const chunk of iterable) {\n          if (!writable.write(chunk)) {\n            await wait();\n          }\n        }\n        if (end) {\n          writable.end();\n        }\n        await wait();\n        finish();\n      } catch (err) {\n        finish(error !== err ? aggregateTwoErrors(error, err) : err);\n      } finally {\n        cleanup();\n        writable.off(\"drain\", resume);\n      }\n    }\n    function pipeline(...streams) {\n      return pipelineImpl(streams, once(popCallback(streams)));\n    }\n    function pipelineImpl(streams, callback, opts) {\n      if (streams.length === 1 && ArrayIsArray(streams[0])) {\n        streams = streams[0];\n      }\n      if (streams.length < 2) {\n        throw new ERR_MISSING_ARGS(\"streams\");\n      }\n      const ac = new AbortController();\n      const signal = ac.signal;\n      const outerSignal = opts === null || opts === void 0 ? void 0 : opts.signal;\n      const lastStreamCleanup = [];\n      validateAbortSignal(outerSignal, \"options.signal\");\n      function abort() {\n        finishImpl(new AbortError());\n      }\n      outerSignal === null || outerSignal === void 0 ? void 0 : outerSignal.addEventListener(\"abort\", abort);\n      let error;\n      let value;\n      const destroys = [];\n      let finishCount = 0;\n      function finish(err) {\n        finishImpl(err, --finishCount === 0);\n      }\n      function finishImpl(err, final) {\n        if (err && (!error || error.code === \"ERR_STREAM_PREMATURE_CLOSE\")) {\n          error = err;\n        }\n        if (!error && !final) {\n          return;\n        }\n        while (destroys.length) {\n          destroys.shift()(error);\n        }\n        outerSignal === null || outerSignal === void 0 ? void 0 : outerSignal.removeEventListener(\"abort\", abort);\n        ac.abort();\n        if (final) {\n          if (!error) {\n            lastStreamCleanup.forEach(fn => fn());\n          }\n          runOnNextTick(callback, error, value);\n        }\n      }\n      let ret;\n      for (let i = 0; i < streams.length; i++) {\n        const stream = streams[i];\n        const reading = i < streams.length - 1;\n        const writing = i > 0;\n        const end = reading || (opts === null || opts === void 0 ? void 0 : opts.end) !== false;\n        const isLastStream = i === streams.length - 1;\n        if (isNodeStream(stream)) {\n          let onError = function (err) {\n            if (err && err.name !== \"AbortError\" && err.code !== \"ERR_STREAM_PREMATURE_CLOSE\") {\n              finish(err);\n            }\n          };\n          if (end) {\n            const { destroy, cleanup } = destroyer(stream, reading, writing);\n            destroys.push(destroy);\n            if (isReadable(stream) && isLastStream) {\n              lastStreamCleanup.push(cleanup);\n            }\n          }\n          stream.on(\"error\", onError);\n          if (isReadable(stream) && isLastStream) {\n            lastStreamCleanup.push(() => {\n              stream.removeListener(\"error\", onError);\n            });\n          }\n        }\n        if (i === 0) {\n          if (typeof stream === \"function\") {\n            ret = stream({\n              signal,\n            });\n            if (!isIterable(ret)) {\n              throw new ERR_INVALID_RETURN_VALUE(\"Iterable, AsyncIterable or Stream\", \"source\", ret);\n            }\n          } else if (isIterable(stream) || isReadableNodeStream(stream)) {\n            ret = stream;\n          } else {\n            ret = Duplex.from(stream);\n          }\n        } else if (typeof stream === \"function\") {\n          ret = makeAsyncIterable(ret);\n          ret = stream(ret, {\n            signal,\n          });\n          if (reading) {\n            if (!isIterable(ret, true)) {\n              throw new ERR_INVALID_RETURN_VALUE(\"AsyncIterable\", `transform[${i - 1}]`, ret);\n            }\n          } else {\n            var _ret;\n            if (!PassThrough) {\n              PassThrough = require_passthrough();\n            }\n            const pt = new PassThrough({\n              objectMode: true,\n            });\n            const then = (_ret = ret) === null || _ret === void 0 ? void 0 : _ret.then;\n            if (typeof then === \"function\") {\n              finishCount++;\n              then.call(\n                ret,\n                val => {\n                  value = val;\n                  if (val != null) {\n                    pt.write(val);\n                  }\n                  if (end) {\n                    pt.end();\n                  }\n                  runOnNextTick(finish);\n                },\n                err => {\n                  pt.destroy(err);\n                  runOnNextTick(finish, err);\n                },\n              );\n            } else if (isIterable(ret, true)) {\n              finishCount++;\n              pump(ret, pt, finish, {\n                end,\n              });\n            } else {\n              throw new ERR_INVALID_RETURN_VALUE(\"AsyncIterable or Promise\", \"destination\", ret);\n            }\n            ret = pt;\n            const { destroy, cleanup } = destroyer(ret, false, true);\n            destroys.push(destroy);\n            if (isLastStream) {\n              lastStreamCleanup.push(cleanup);\n            }\n          }\n        } else if (isNodeStream(stream)) {\n          if (isReadableNodeStream(ret)) {\n            finishCount += 2;\n            const cleanup = pipe(ret, stream, finish, {\n              end,\n            });\n            if (isReadable(stream) && isLastStream) {\n              lastStreamCleanup.push(cleanup);\n            }\n          } else if (isIterable(ret)) {\n            finishCount++;\n            pump(ret, stream, finish, {\n              end,\n            });\n          } else {\n            throw new ERR_INVALID_ARG_TYPE(\"val\", [\"Readable\", \"Iterable\", \"AsyncIterable\"], ret);\n          }\n          ret = stream;\n        } else {\n          ret = Duplex.from(stream);\n        }\n      }\n      if (\n        (signal !== null && signal !== void 0 && signal.aborted) ||\n        (outerSignal !== null && outerSignal !== void 0 && outerSignal.aborted)\n      ) {\n        runOnNextTick(abort);\n      }\n      return ret;\n    }\n    function pipe(src, dst, finish, { end }) {\n      src.pipe(dst, {\n        end,\n      });\n      if (end) {\n        src.once(\"end\", () => dst.end());\n      } else {\n        finish();\n      }\n      eos(\n        src,\n        {\n          readable: true,\n          writable: false,\n        },\n        err => {\n          const rState = src._readableState;\n          if (\n            err &&\n            err.code === \"ERR_STREAM_PREMATURE_CLOSE\" &&\n            rState &&\n            rState.ended &&\n            !rState.errored &&\n            !rState.errorEmitted\n          ) {\n            src.once(\"end\", finish).once(\"error\", finish);\n          } else {\n            finish(err);\n          }\n        },\n      );\n      return eos(\n        dst,\n        {\n          readable: false,\n          writable: true,\n        },\n        finish,\n      );\n    }\n    module.exports = {\n      pipelineImpl,\n      pipeline,\n    };\n  },\n});\n\n// node_modules/readable-stream/lib/internal/streams/compose.js\nvar require_compose = __commonJS({\n  \"node_modules/readable-stream/lib/internal/streams/compose.js\"(exports, module) {\n    \"use strict\";\n    var { pipeline } = require_pipeline();\n    var Duplex = require_duplex();\n    var { destroyer } = require_destroy();\n    var { isNodeStream, isReadable, isWritable } = require_utils();\n    var {\n      AbortError,\n      codes: { ERR_INVALID_ARG_VALUE, ERR_MISSING_ARGS },\n    } = require_errors();\n    module.exports = function compose(...streams) {\n      if (streams.length === 0) {\n        throw new ERR_MISSING_ARGS(\"streams\");\n      }\n      if (streams.length === 1) {\n        return Duplex.from(streams[0]);\n      }\n      const orgStreams = [...streams];\n      if (typeof streams[0] === \"function\") {\n        streams[0] = Duplex.from(streams[0]);\n      }\n      if (typeof streams[streams.length - 1] === \"function\") {\n        const idx = streams.length - 1;\n        streams[idx] = Duplex.from(streams[idx]);\n      }\n      for (let n = 0; n < streams.length; ++n) {\n        if (!isNodeStream(streams[n])) {\n          continue;\n        }\n        if (n < streams.length - 1 && !isReadable(streams[n])) {\n          throw new ERR_INVALID_ARG_VALUE(`streams[${n}]`, orgStreams[n], \"must be readable\");\n        }\n        if (n > 0 && !isWritable(streams[n])) {\n          throw new ERR_INVALID_ARG_VALUE(`streams[${n}]`, orgStreams[n], \"must be writable\");\n        }\n      }\n      let ondrain;\n      let onfinish;\n      let onreadable;\n      let onclose;\n      let d;\n      function onfinished(err) {\n        const cb = onclose;\n        onclose = null;\n        if (cb) {\n          cb(err);\n        } else if (err) {\n          d.destroy(err);\n        } else if (!readable && !writable) {\n          d.destroy();\n        }\n      }\n      const head = streams[0];\n      const tail = pipeline(streams, onfinished);\n      const writable = !!isWritable(head);\n      const readable = !!isReadable(tail);\n      d = new Duplex({\n        writableObjectMode: !!(head !== null && head !== void 0 && head.writableObjectMode),\n        readableObjectMode: !!(tail !== null && tail !== void 0 && tail.writableObjectMode),\n        writable,\n        readable,\n      });\n      if (writable) {\n        d._write = function (chunk, encoding, callback) {\n          if (head.write(chunk, encoding)) {\n            callback();\n          } else {\n            ondrain = callback;\n          }\n        };\n        d._final = function (callback) {\n          head.end();\n          onfinish = callback;\n        };\n        head.on(\"drain\", function () {\n          if (ondrain) {\n            const cb = ondrain;\n            ondrain = null;\n            cb();\n          }\n        });\n        tail.on(\"finish\", function () {\n          if (onfinish) {\n            const cb = onfinish;\n            onfinish = null;\n            cb();\n          }\n        });\n      }\n      if (readable) {\n        tail.on(\"readable\", function () {\n          if (onreadable) {\n            const cb = onreadable;\n            onreadable = null;\n            cb();\n          }\n        });\n        tail.on(\"end\", function () {\n          d.push(null);\n        });\n        d._read = function () {\n          while (true) {\n            const buf = tail.read();\n            if (buf === null) {\n              onreadable = d._read;\n              return;\n            }\n            if (!d.push(buf)) {\n              return;\n            }\n          }\n        };\n      }\n      d._destroy = function (err, callback) {\n        if (!err && onclose !== null) {\n          err = new AbortError();\n        }\n        onreadable = null;\n        ondrain = null;\n        onfinish = null;\n        if (onclose === null) {\n          callback(err);\n        } else {\n          onclose = callback;\n          destroyer(tail, err);\n        }\n      };\n      return d;\n    };\n  },\n});\n\n// node_modules/readable-stream/lib/stream/promises.js\nvar require_promises = __commonJS({\n  \"node_modules/readable-stream/lib/stream/promises.js\"(exports, module) {\n    \"use strict\";\n    var { ArrayPrototypePop, Promise: Promise2 } = require_primordials();\n    var { isIterable, isNodeStream } = require_utils();\n    var { pipelineImpl: pl } = require_pipeline();\n    var { finished } = require_end_of_stream();\n    function pipeline(...streams) {\n      return new Promise2((resolve, reject) => {\n        let signal;\n        let end;\n        const lastArg = streams[streams.length - 1];\n        if (lastArg && typeof lastArg === \"object\" && !isNodeStream(lastArg) && !isIterable(lastArg)) {\n          const options = ArrayPrototypePop(streams);\n          signal = options.signal;\n          end = options.end;\n        }\n        pl(\n          streams,\n          (err, value) => {\n            if (err) {\n              reject(err);\n            } else {\n              resolve(value);\n            }\n          },\n          {\n            signal,\n            end,\n          },\n        );\n      });\n    }\n    module.exports = {\n      finished,\n      pipeline,\n    };\n  },\n});\n// node_modules/readable-stream/lib/stream.js\nvar require_stream = __commonJS({\n  \"node_modules/readable-stream/lib/stream.js\"(exports, module) {\n    \"use strict\";\n    var { ObjectDefineProperty, ObjectKeys, ReflectApply } = require_primordials();\n    var {\n      promisify: { custom: customPromisify },\n    } = require_util();\n\n    var { streamReturningOperators, promiseReturningOperators } = require_operators();\n    var {\n      codes: { ERR_ILLEGAL_CONSTRUCTOR },\n    } = require_errors();\n    var compose = require_compose();\n    var { pipeline } = require_pipeline();\n    var { destroyer } = require_destroy();\n    var eos = require_end_of_stream();\n    var promises = require_promises();\n    var utils = require_utils();\n    var Stream = (module.exports = require_legacy().Stream);\n    Stream.isDisturbed = utils.isDisturbed;\n    Stream.isErrored = utils.isErrored;\n    Stream.isWritable = utils.isWritable;\n    Stream.isReadable = utils.isReadable;\n    Stream.Readable = require_readable();\n    for (const key of ObjectKeys(streamReturningOperators)) {\n      let fn = function (...args) {\n        if (new.target) {\n          throw ERR_ILLEGAL_CONSTRUCTOR();\n        }\n        return Stream.Readable.from(ReflectApply(op, this, args));\n      };\n      const op = streamReturningOperators[key];\n      ObjectDefineProperty(fn, \"name\", {\n        value: op.name,\n      });\n      ObjectDefineProperty(fn, \"length\", {\n        value: op.length,\n      });\n      ObjectDefineProperty(Stream.Readable.prototype, key, {\n        value: fn,\n        enumerable: false,\n        configurable: true,\n        writable: true,\n      });\n    }\n    for (const key of ObjectKeys(promiseReturningOperators)) {\n      let fn = function (...args) {\n        if (new.target) {\n          throw ERR_ILLEGAL_CONSTRUCTOR();\n        }\n        return ReflectApply(op, this, args);\n      };\n      const op = promiseReturningOperators[key];\n      ObjectDefineProperty(fn, \"name\", {\n        value: op.name,\n      });\n      ObjectDefineProperty(fn, \"length\", {\n        value: op.length,\n      });\n      ObjectDefineProperty(Stream.Readable.prototype, key, {\n        value: fn,\n        enumerable: false,\n        configurable: true,\n        writable: true,\n      });\n    }\n    Stream.Writable = require_writable();\n    Stream.Duplex = require_duplex();\n    Stream.Transform = require_transform();\n    Stream.PassThrough = require_passthrough();\n    Stream.pipeline = pipeline;\n    var { addAbortSignal } = require_add_abort_signal();\n    Stream.addAbortSignal = addAbortSignal;\n    Stream.finished = eos;\n    Stream.destroy = destroyer;\n    Stream.compose = compose;\n    ObjectDefineProperty(Stream, \"promises\", {\n      configurable: true,\n      enumerable: true,\n      get() {\n        return promises;\n      },\n    });\n    ObjectDefineProperty(pipeline, customPromisify, {\n      enumerable: true,\n      get() {\n        return promises.pipeline;\n      },\n    });\n    ObjectDefineProperty(eos, customPromisify, {\n      enumerable: true,\n      get() {\n        return promises.finished;\n      },\n    });\n    Stream.Stream = Stream;\n    Stream._isUint8Array = function isUint8Array(value) {\n      return value instanceof Uint8Array;\n    };\n    Stream._uint8ArrayToBuffer = function _uint8ArrayToBuffer(chunk) {\n      return new Buffer(chunk.buffer, chunk.byteOffset, chunk.byteLength);\n    };\n  },\n});\n\n// node_modules/readable-stream/lib/ours/index.js\nvar require_ours = __commonJS({\n  \"node_modules/readable-stream/lib/ours/index.js\"(exports, module) {\n    \"use strict\";\n    const CustomStream = require_stream();\n    const promises = require_promises();\n    const originalDestroy = CustomStream.Readable.destroy;\n    module.exports = CustomStream;\n    module.exports._uint8ArrayToBuffer = CustomStream._uint8ArrayToBuffer;\n    module.exports._isUint8Array = CustomStream._isUint8Array;\n    module.exports.isDisturbed = CustomStream.isDisturbed;\n    module.exports.isErrored = CustomStream.isErrored;\n    module.exports.isWritable = CustomStream.isWritable;\n    module.exports.isReadable = CustomStream.isReadable;\n    module.exports.Readable = CustomStream.Readable;\n    module.exports.Writable = CustomStream.Writable;\n    module.exports.Duplex = CustomStream.Duplex;\n    module.exports.Transform = CustomStream.Transform;\n    module.exports.PassThrough = CustomStream.PassThrough;\n    module.exports.addAbortSignal = CustomStream.addAbortSignal;\n    module.exports.finished = CustomStream.finished;\n    module.exports.destroy = CustomStream.destroy;\n    module.exports.destroy = originalDestroy;\n    module.exports.pipeline = CustomStream.pipeline;\n    module.exports.compose = CustomStream.compose;\n\n    module.exports._getNativeReadableStreamPrototype = getNativeReadableStreamPrototype;\n    module.exports.NativeWritable = NativeWritable;\n\n    Object.defineProperty(CustomStream, \"promises\", {\n      configurable: true,\n      enumerable: true,\n      get() {\n        return promises;\n      },\n    });\n    module.exports.Stream = CustomStream.Stream;\n    module.exports.default = module.exports;\n  },\n});\n\n/**\n * Bun native stream wrapper\n *\n * This glue code lets us avoid using ReadableStreams to wrap Bun internal streams\n *\n */\nfunction createNativeStreamReadable(nativeType, Readable) {\n  var [pull, start, cancel, setClose, deinit, updateRef, drainFn] = globalThis[Symbol.for(\"Bun.lazy\")](nativeType);\n\n  var closer = [false];\n  var handleNumberResult = function (nativeReadable, result, view, isClosed) {\n    if (result > 0) {\n      const slice = view.subarray(0, result);\n      const remainder = view.subarray(result);\n      if (slice.byteLength > 0) {\n        nativeReadable.push(slice);\n      }\n\n      if (isClosed) {\n        nativeReadable.push(null);\n      }\n\n      return remainder.byteLength > 0 ? remainder : undefined;\n    }\n\n    if (isClosed) {\n      nativeReadable.push(null);\n    }\n\n    return view;\n  };\n\n  var handleArrayBufferViewResult = function (nativeReadable, result, view, isClosed) {\n    if (result.byteLength > 0) {\n      nativeReadable.push(result);\n    }\n\n    if (isClosed) {\n      nativeReadable.push(null);\n    }\n\n    return view;\n  };\n\n  var DYNAMICALLY_ADJUST_CHUNK_SIZE = process.env.BUN_DISABLE_DYNAMIC_CHUNK_SIZE !== \"1\";\n\n  const finalizer = new FinalizationRegistry(ptr => ptr && deinit(ptr));\n  const MIN_BUFFER_SIZE = 512;\n  var NativeReadable = class NativeReadable extends Readable {\n    #ptr;\n    #refCount = 1;\n    #constructed = false;\n    #remainingChunk = undefined;\n    #highWaterMark;\n    #pendingRead = false;\n    #hasResized = !DYNAMICALLY_ADJUST_CHUNK_SIZE;\n    #unregisterToken;\n    constructor(ptr, options = {}) {\n      super(options);\n      if (typeof options.highWaterMark === \"number\") {\n        this.#highWaterMark = options.highWaterMark;\n      } else {\n        this.#highWaterMark = 256 * 1024;\n      }\n      this.#ptr = ptr;\n      this.#constructed = false;\n      this.#remainingChunk = undefined;\n      this.#pendingRead = false;\n      this.#unregisterToken = {};\n      finalizer.register(this, this.#ptr, this.#unregisterToken);\n    }\n\n    // maxToRead is by default the highWaterMark passed from the Readable.read call to this fn\n    // However, in the case of an fs.ReadStream, we can pass the number of bytes we want to read\n    // which may be significantly less than the actual highWaterMark\n    _read(maxToRead) {\n      __DEBUG__ && debug(\"NativeReadable._read\", this.__id);\n      if (this.#pendingRead) {\n        __DEBUG__ && debug(\"pendingRead is true\", this.__id);\n        return;\n      }\n\n      var ptr = this.#ptr;\n      __DEBUG__ && debug(\"ptr @ NativeReadable._read\", ptr, this.__id);\n      if (ptr === 0) {\n        this.push(null);\n        return;\n      }\n\n      if (!this.#constructed) {\n        __DEBUG__ && debug(\"NativeReadable not constructed yet\", this.__id);\n        this.#internalConstruct(ptr);\n      }\n\n      return this.#internalRead(this.#getRemainingChunk(maxToRead), ptr);\n      // const internalReadRes = this.#internalRead(\n      //   this.#getRemainingChunk(),\n      //   ptr,\n      // );\n      // // REVERT ME\n      // const wrap = new Promise((resolve) => {\n      //   if (!this.internalReadRes?.then) {\n      //     debug(\"internalReadRes not promise\");\n      //     resolve(internalReadRes);\n      //     return;\n      //   }\n      //   internalReadRes.then((result) => {\n      //     debug(\"internalReadRes done\");\n      //     resolve(result);\n      //   });\n      // });\n      // return wrap;\n    }\n\n    #internalConstruct(ptr) {\n      this.#constructed = true;\n      const result = start(ptr, this.#highWaterMark);\n      __DEBUG__ && debug(\"NativeReadable internal `start` result\", result, this.__id);\n\n      if (typeof result === \"number\" && result > 1) {\n        this.#hasResized = true;\n        __DEBUG__ && debug(\"NativeReadable resized\", this.__id);\n\n        this.#highWaterMark = Math.min(this.#highWaterMark, result);\n      }\n\n      if (drainFn) {\n        const drainResult = drainFn(ptr);\n        __DEBUG__ && debug(\"NativeReadable drain result\", drainResult, this.__id);\n        if ((drainResult?.byteLength ?? 0) > 0) {\n          this.push(drainResult);\n        }\n      }\n    }\n\n    // maxToRead can be the highWaterMark (by default) or the remaining amount of the stream to read\n    // This is so the the consumer of the stream can terminate the stream early if they know\n    // how many bytes they want to read (ie. when reading only part of a file)\n    #getRemainingChunk(maxToRead = this.#highWaterMark) {\n      var chunk = this.#remainingChunk;\n      __DEBUG__ && debug(\"chunk @ #getRemainingChunk\", chunk, this.__id);\n      if (chunk?.byteLength ?? 0 < MIN_BUFFER_SIZE) {\n        var size = maxToRead > MIN_BUFFER_SIZE ? maxToRead : MIN_BUFFER_SIZE;\n        this.#remainingChunk = chunk = new Buffer(size);\n      }\n      return chunk;\n    }\n\n    push(result, encoding) {\n      __DEBUG__ && debug(\"NativeReadable push -- result, encoding\", result, encoding, this.__id);\n      return super.push(...arguments);\n    }\n\n    #handleResult(result, view, isClosed) {\n      __DEBUG__ && debug(\"result, isClosed @ #handleResult\", result, isClosed, this.__id);\n\n      if (typeof result === \"number\") {\n        if (result >= this.#highWaterMark && !this.#hasResized && !isClosed) {\n          this.#highWaterMark *= 2;\n          this.#hasResized = true;\n        }\n\n        return handleNumberResult(this, result, view, isClosed);\n      } else if (typeof result === \"boolean\") {\n        this.push(null);\n        return view?.byteLength ?? 0 > 0 ? view : undefined;\n      } else if (ArrayBuffer.isView(result)) {\n        if (result.byteLength >= this.#highWaterMark && !this.#hasResized && !isClosed) {\n          this.#highWaterMark *= 2;\n          this.#hasResized = true;\n          __DEBUG__ && debug(\"Resized\", this.__id);\n        }\n\n        return handleArrayBufferViewResult(this, result, view, isClosed);\n      } else {\n        __DEBUG__ && debug(\"Unknown result type\", result, this.__id);\n        throw new Error(\"Invalid result from pull\");\n      }\n    }\n\n    #internalRead(view, ptr) {\n      __DEBUG__ && debug(\"#internalRead()\", this.__id);\n      closer[0] = false;\n      var result = pull(ptr, view, closer);\n      if (isPromise(result)) {\n        this.#pendingRead = true;\n        return result.then(\n          result => {\n            this.#pendingRead = false;\n            __DEBUG__ && debug(\"pending no longerrrrrrrr (result returned from pull)\", this.__id);\n            this.#remainingChunk = this.#handleResult(result, view, closer[0]);\n          },\n          reason => {\n            __DEBUG__ && debug(\"error from pull\", reason, this.__id);\n            errorOrDestroy(this, reason);\n          },\n        );\n      } else {\n        this.#remainingChunk = this.#handleResult(result, view, closer[0]);\n      }\n    }\n\n    _destroy(error, callback) {\n      var ptr = this.#ptr;\n      if (ptr === 0) {\n        callback(error);\n        return;\n      }\n\n      finalizer.unregister(this.#unregisterToken);\n      this.#ptr = 0;\n      if (updateRef) {\n        updateRef(ptr, false);\n      }\n      __DEBUG__ && debug(\"NativeReadable destroyed\", this.__id);\n      cancel(ptr, error);\n      callback(error);\n    }\n\n    ref() {\n      var ptr = this.#ptr;\n      if (ptr === 0) return;\n      if (this.#refCount++ === 0) {\n        updateRef(ptr, true);\n      }\n    }\n\n    unref() {\n      var ptr = this.#ptr;\n      if (ptr === 0) return;\n      if (this.#refCount-- === 1) {\n        updateRef(ptr, false);\n      }\n    }\n  };\n\n  if (!updateRef) {\n    NativeReadable.prototype.ref = undefined;\n    NativeReadable.prototype.unref = undefined;\n  }\n\n  return NativeReadable;\n}\n\nvar nativeReadableStreamPrototypes = {\n  0: undefined,\n  1: undefined,\n  2: undefined,\n  3: undefined,\n  4: undefined,\n  5: undefined,\n};\nfunction getNativeReadableStreamPrototype(nativeType, Readable) {\n  return (nativeReadableStreamPrototypes[nativeType] ||= createNativeStreamReadable(nativeType, Readable));\n}\n\nfunction getNativeReadableStream(Readable, stream, options) {\n  if (!(stream && typeof stream === \"object\" && stream instanceof ReadableStream)) {\n    return undefined;\n  }\n\n  const native = direct(stream);\n  if (!native) {\n    debug(\"no native readable stream\");\n    return undefined;\n  }\n  const { stream: ptr, data: type } = native;\n\n  const NativeReadable = getNativeReadableStreamPrototype(type, Readable);\n\n  return new NativeReadable(ptr, options);\n}\n/** --- Bun native stream wrapper ---  */\n\nvar Writable = require_writable();\nvar NativeWritable = class NativeWritable extends Writable {\n  #pathOrFdOrSink;\n  #fileSink;\n  #native = true;\n\n  _construct;\n  _destroy;\n  _final;\n\n  constructor(pathOrFdOrSink, options = {}) {\n    super(options);\n\n    this._construct = this.#internalConstruct;\n    this._destroy = this.#internalDestroy;\n    this._final = this.#internalFinal;\n\n    this.#pathOrFdOrSink = pathOrFdOrSink;\n  }\n\n  // These are confusingly two different fns for construct which initially were the same thing because\n  // `_construct` is part of the lifecycle of Writable and is not called lazily,\n  // so we need to separate our _construct for Writable state and actual construction of the write stream\n  #internalConstruct(cb) {\n    this._writableState.constructed = true;\n    this.constructed = true;\n    cb();\n  }\n\n  #lazyConstruct() {\n    // TODO: Turn this check into check for instanceof FileSink\n    if (typeof this.#pathOrFdOrSink === \"object\") {\n      if (typeof this.#pathOrFdOrSink.write === \"function\") {\n        this.#fileSink = this.#pathOrFdOrSink;\n      } else {\n        throw new Error(\"Invalid FileSink\");\n      }\n    } else {\n      this.#fileSink = Bun.file(this.#pathOrFdOrSink).writer();\n    }\n  }\n\n  write(chunk, encoding, cb, native = this.#native) {\n    if (!native) {\n      this.#native = false;\n      return super.write(chunk, encoding, cb);\n    }\n\n    if (!this.#fileSink) {\n      this.#lazyConstruct();\n    }\n    var fileSink = this.#fileSink;\n    var result = fileSink.write(chunk);\n\n    if (isPromise(result)) {\n      // var writePromises = this.#writePromises;\n      // var i = writePromises.length;\n      // writePromises[i] = result;\n      result.then(() => {\n        this.emit(\"drain\");\n        fileSink.flush(true);\n        // // We can't naively use i here because we don't know when writes will resolve necessarily\n        // writePromises.splice(writePromises.indexOf(result), 1);\n      });\n      return false;\n    }\n    fileSink.flush(true);\n    // TODO: Should we just have a calculation based on encoding and length of chunk?\n    if (cb) cb(null, chunk.byteLength);\n    return true;\n  }\n\n  end(chunk, encoding, cb, native = this.#native) {\n    return super.end(chunk, encoding, cb, native);\n  }\n\n  #internalDestroy(error, cb) {\n    this._writableState.destroyed = true;\n    if (cb) cb(error);\n  }\n\n  #internalFinal(cb) {\n    if (this.#fileSink) {\n      this.#fileSink.end();\n    }\n    if (cb) cb();\n  }\n\n  ref() {\n    if (!this.#fileSink) {\n      this.#lazyConstruct();\n    }\n    this.#fileSink.ref();\n  }\n\n  unref() {\n    if (!this.#fileSink) return;\n    this.#fileSink.unref();\n  }\n};\n\nconst stream_exports = require_ours();\nstream_exports[Symbol.for(\"CommonJS\")] = 0;\nstream_exports[Symbol.for(\"::bunternal::\")] = { _ReadableFromWeb };\nexport default stream_exports;\nexport var _uint8ArrayToBuffer = stream_exports._uint8ArrayToBuffer;\nexport var _isUint8Array = stream_exports._isUint8Array;\nexport var isDisturbed = stream_exports.isDisturbed;\nexport var isErrored = stream_exports.isErrored;\nexport var isWritable = stream_exports.isWritable;\nexport var isReadable = stream_exports.isReadable;\nexport var Readable = stream_exports.Readable;\nexport var Writable = stream_exports.Writable;\nexport var Duplex = stream_exports.Duplex;\nexport var Transform = stream_exports.Transform;\nexport var PassThrough = stream_exports.PassThrough;\nexport var addAbortSignal = stream_exports.addAbortSignal;\nexport var finished = stream_exports.finished;\nexport var destroy = stream_exports.destroy;\nexport var pipeline = stream_exports.pipeline;\nexport var compose = stream_exports.compose;\nexport var Stream = stream_exports.Stream;\nexport var eos = (stream_exports[\"eos\"] = require_end_of_stream);\nexport var _getNativeReadableStreamPrototype = stream_exports._getNativeReadableStreamPrototype;\nexport var NativeWritable = stream_exports.NativeWritable;\nexport var promises = Stream.promise;\n",
  "// Hardcoded module \"node:stream\" / \"readable-stream\"\n// \"readable-stream\" npm package\n// just transpiled\nvar { isPromise, isCallable, direct, Object } = import.meta.primordials;\n\nglobalThis.__IDS_TO_TRACK = process.env.DEBUG_TRACK_EE?.length\n  ? process.env.DEBUG_TRACK_EE.split(\",\")\n  : process.env.DEBUG_STREAMS?.length\n  ? process.env.DEBUG_STREAMS.split(\",\")\n  : null;\n\n// Separating DEBUG, DEBUG_STREAMS and DEBUG_TRACK_EE env vars makes it easier to focus on the\n// events in this file rather than all debug output across all files\n\n// You can include comma-delimited IDs as the value to either DEBUG_STREAMS or DEBUG_TRACK_EE and it will track\n// The events and/or all of the outputs for the given stream IDs assigned at stream construction\n// By default, child_process gives\n\nconst __TRACK_EE__ = !!process.env.DEBUG_TRACK_EE;\nconst __DEBUG__ = !!(process.env.DEBUG || process.env.DEBUG_STREAMS || __TRACK_EE__);\n\nvar debug = __DEBUG__\n  ? globalThis.__IDS_TO_TRACK\n    ? // If we are tracking IDs for debug event emitters, we should prefix the debug output with the ID\n      (...args) => {\n        const lastItem = args[args.length - 1];\n        if (!globalThis.__IDS_TO_TRACK.includes(lastItem)) return;\n        console.log(`ID: ${lastItem}`, ...args.slice(0, -1));\n      }\n    : (...args) => console.log(...args.slice(0, -1))\n  : () => {};\n\nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __ObjectSetPrototypeOf = Object.setPrototypeOf;\nvar __require = x => import.meta.require(x);\n\nvar _EE = __require(\"bun:events_native\");\n\nfunction DebugEventEmitter(opts) {\n  if (!(this instanceof DebugEventEmitter)) return new DebugEventEmitter(opts);\n  _EE.call(this, opts);\n  const __id = opts.__id;\n  if (__id) {\n    __defProp(this, \"__id\", {\n      value: __id,\n      readable: true,\n      writable: false,\n      enumerable: false,\n    });\n  }\n}\n\n__ObjectSetPrototypeOf(DebugEventEmitter.prototype, _EE.prototype);\n__ObjectSetPrototypeOf(DebugEventEmitter, _EE);\n\nDebugEventEmitter.prototype.emit = function (event, ...args) {\n  var __id = this.__id;\n  if (__id) {\n    debug(\"emit\", event, ...args, __id);\n  } else {\n    debug(\"emit\", event, ...args);\n  }\n  return _EE.prototype.emit.call(this, event, ...args);\n};\nDebugEventEmitter.prototype.on = function (event, handler) {\n  var __id = this.__id;\n  if (__id) {\n    debug(\"on\", event, \"added\", __id);\n  } else {\n    debug(\"on\", event, \"added\");\n  }\n  return _EE.prototype.on.call(this, event, handler);\n};\nDebugEventEmitter.prototype.addListener = function (event, handler) {\n  return this.on(event, handler);\n};\n\nvar __commonJS = (cb, mod) =>\n  function __require2() {\n    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;\n  };\nvar __copyProps = (to, from, except, desc) => {\n  if ((from && typeof from === \"object\") || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, {\n          get: () => from[key],\n          set: val => (from[key] = val),\n          enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable,\n          configurable: true,\n        });\n  }\n  return to;\n};\n\nvar runOnNextTick = process.nextTick;\n\nfunction isReadableStream(value) {\n  return typeof value === \"object\" && value !== null && value instanceof ReadableStream;\n}\n\nfunction validateBoolean(value, name) {\n  if (typeof value !== \"boolean\") throw new ERR_INVALID_ARG_TYPE(name, \"boolean\", value);\n}\n\n/**\n * @callback validateObject\n * @param {*} value\n * @param {string} name\n * @param {{\n *   allowArray?: boolean,\n *   allowFunction?: boolean,\n *   nullable?: boolean\n * }} [options]\n */\n\n/** @type {validateObject} */\nconst validateObject = (value, name, options = null) => {\n  const allowArray = options?.allowArray ?? false;\n  const allowFunction = options?.allowFunction ?? false;\n  const nullable = options?.nullable ?? false;\n  if (\n    (!nullable && value === null) ||\n    (!allowArray && ArrayIsArray(value)) ||\n    (typeof value !== \"object\" && (!allowFunction || typeof value !== \"function\"))\n  ) {\n    throw new ERR_INVALID_ARG_TYPE(name, \"Object\", value);\n  }\n};\n\n/**\n * @callback validateString\n * @param {*} value\n * @param {string} name\n * @returns {asserts value is string}\n */\n\n/** @type {validateString} */\nfunction validateString(value, name) {\n  if (typeof value !== \"string\") throw new ERR_INVALID_ARG_TYPE(name, \"string\", value);\n}\n\nvar ArrayIsArray = Array.isArray;\n\n//------------------------------------------------------------------------------\n// Node error polyfills\n//------------------------------------------------------------------------------\n\nfunction ERR_INVALID_ARG_TYPE(name, type, value) {\n  return new Error(`The argument '${name}' is invalid. Received '${value}' for type '${type}'`);\n}\n\nfunction ERR_INVALID_ARG_VALUE(name, value, reason) {\n  return new Error(`The value '${value}' is invalid for argument '${name}'. Reason: ${reason}`);\n}\n\n// node_modules/readable-stream/lib/ours/primordials.js\nvar require_primordials = __commonJS({\n  \"node_modules/readable-stream/lib/ours/primordials.js\"(exports, module) {\n    \"use strict\";\n    module.exports = {\n      ArrayIsArray(self) {\n        return Array.isArray(self);\n      },\n      ArrayPrototypeIncludes(self, el) {\n        return self.includes(el);\n      },\n      ArrayPrototypeIndexOf(self, el) {\n        return self.indexOf(el);\n      },\n      ArrayPrototypeJoin(self, sep) {\n        return self.join(sep);\n      },\n      ArrayPrototypeMap(self, fn) {\n        return self.map(fn);\n      },\n      ArrayPrototypePop(self, el) {\n        return self.pop(el);\n      },\n      ArrayPrototypePush(self, el) {\n        return self.push(el);\n      },\n      ArrayPrototypeSlice(self, start, end) {\n        return self.slice(start, end);\n      },\n      Error,\n      FunctionPrototypeCall(fn, thisArgs, ...args) {\n        return fn.call(thisArgs, ...args);\n      },\n      FunctionPrototypeSymbolHasInstance(self, instance) {\n        return Function.prototype[Symbol.hasInstance].call(self, instance);\n      },\n      MathFloor: Math.floor,\n      Number,\n      NumberIsInteger: Number.isInteger,\n      NumberIsNaN: Number.isNaN,\n      NumberMAX_SAFE_INTEGER: Number.MAX_SAFE_INTEGER,\n      NumberMIN_SAFE_INTEGER: Number.MIN_SAFE_INTEGER,\n      NumberParseInt: Number.parseInt,\n      ObjectDefineProperties(self, props) {\n        return Object.defineProperties(self, props);\n      },\n      ObjectDefineProperty(self, name, prop) {\n        return Object.defineProperty(self, name, prop);\n      },\n      ObjectGetOwnPropertyDescriptor(self, name) {\n        return Object.getOwnPropertyDescriptor(self, name);\n      },\n      ObjectKeys(obj) {\n        return Object.keys(obj);\n      },\n      ObjectSetPrototypeOf(target, proto) {\n        return Object.setPrototypeOf(target, proto);\n      },\n      Promise,\n      PromisePrototypeCatch(self, fn) {\n        return self.catch(fn);\n      },\n      PromisePrototypeThen(self, thenFn, catchFn) {\n        return self.then(thenFn, catchFn);\n      },\n      PromiseReject(err) {\n        return Promise.reject(err);\n      },\n      ReflectApply: Reflect.apply,\n      RegExpPrototypeTest(self, value) {\n        return self.test(value);\n      },\n      SafeSet: Set,\n      String,\n      StringPrototypeSlice(self, start, end) {\n        return self.slice(start, end);\n      },\n      StringPrototypeToLowerCase(self) {\n        return self.toLowerCase();\n      },\n      StringPrototypeToUpperCase(self) {\n        return self.toUpperCase();\n      },\n      StringPrototypeTrim(self) {\n        return self.trim();\n      },\n      Symbol,\n      SymbolAsyncIterator: Symbol.asyncIterator,\n      SymbolHasInstance: Symbol.hasInstance,\n      SymbolIterator: Symbol.iterator,\n      TypedArrayPrototypeSet(self, buf, len) {\n        return self.set(buf, len);\n      },\n      Uint8Array,\n    };\n  },\n});\n// node_modules/readable-stream/lib/ours/util.js\nvar require_util = __commonJS({\n  \"node_modules/readable-stream/lib/ours/util.js\"(exports, module) {\n    \"use strict\";\n    var bufferModule = __require(\"buffer\");\n    var AsyncFunction = Object.getPrototypeOf(async function () {}).constructor;\n    var Blob = globalThis.Blob || bufferModule.Blob;\n    var isBlob =\n      typeof Blob !== \"undefined\"\n        ? function isBlob2(b) {\n            return b instanceof Blob;\n          }\n        : function isBlob2(b) {\n            return false;\n          };\n    var AggregateError = class extends Error {\n      constructor(errors) {\n        if (!Array.isArray(errors)) {\n          throw new TypeError(`Expected input to be an Array, got ${typeof errors}`);\n        }\n        let message = \"\";\n        for (let i = 0; i < errors.length; i++) {\n          message += `    ${errors[i].stack}\n`;\n        }\n        super(message);\n        this.name = \"AggregateError\";\n        this.errors = errors;\n      }\n    };\n    module.exports = {\n      AggregateError,\n      once(callback) {\n        let called = false;\n        return function (...args) {\n          if (called) {\n            return;\n          }\n          called = true;\n          callback.apply(this, args);\n        };\n      },\n      createDeferredPromise: function () {\n        let resolve;\n        let reject;\n        const promise = new Promise((res, rej) => {\n          resolve = res;\n          reject = rej;\n        });\n        return {\n          promise,\n          resolve,\n          reject,\n        };\n      },\n      promisify(fn) {\n        return new Promise((resolve, reject) => {\n          fn((err, ...args) => {\n            if (err) {\n              return reject(err);\n            }\n            return resolve(...args);\n          });\n        });\n      },\n      debuglog() {\n        return function () {};\n      },\n      format(format, ...args) {\n        return format.replace(/%([sdifj])/g, function (...[_unused, type]) {\n          const replacement = args.shift();\n          if (type === \"f\") {\n            return replacement.toFixed(6);\n          } else if (type === \"j\") {\n            return JSON.stringify(replacement);\n          } else if (type === \"s\" && typeof replacement === \"object\") {\n            const ctor = replacement.constructor !== Object ? replacement.constructor.name : \"\";\n            return `${ctor} {}`.trim();\n          } else {\n            return replacement.toString();\n          }\n        });\n      },\n      inspect(value) {\n        switch (typeof value) {\n          case \"string\":\n            if (value.includes(\"'\")) {\n              if (!value.includes('\"')) {\n                return `\"${value}\"`;\n              } else if (!value.includes(\"`\") && !value.includes(\"${\")) {\n                return `\\`${value}\\``;\n              }\n            }\n            return `'${value}'`;\n          case \"number\":\n            if (isNaN(value)) {\n              return \"NaN\";\n            } else if (Object.is(value, -0)) {\n              return String(value);\n            }\n            return value;\n          case \"bigint\":\n            return `${String(value)}n`;\n          case \"boolean\":\n          case \"undefined\":\n            return String(value);\n          case \"object\":\n            return \"{}\";\n        }\n      },\n      types: {\n        isAsyncFunction(fn) {\n          return fn instanceof AsyncFunction;\n        },\n        isArrayBufferView(arr) {\n          return ArrayBuffer.isView(arr);\n        },\n      },\n      isBlob,\n    };\n    module.exports.promisify.custom = Symbol.for(\"nodejs.util.promisify.custom\");\n  },\n});\n\n// node_modules/readable-stream/lib/ours/errors.js\nvar require_errors = __commonJS({\n  \"node_modules/readable-stream/lib/ours/errors.js\"(exports, module) {\n    \"use strict\";\n    var { format, inspect, AggregateError: CustomAggregateError } = require_util();\n    var AggregateError = globalThis.AggregateError || CustomAggregateError;\n    var kIsNodeError = Symbol(\"kIsNodeError\");\n    var kTypes = [\"string\", \"function\", \"number\", \"object\", \"Function\", \"Object\", \"boolean\", \"bigint\", \"symbol\"];\n    var classRegExp = /^([A-Z][a-z0-9]*)+$/;\n    var nodeInternalPrefix = \"__node_internal_\";\n    var codes = {};\n    function assert(value, message) {\n      if (!value) {\n        throw new codes.ERR_INTERNAL_ASSERTION(message);\n      }\n    }\n    function addNumericalSeparator(val) {\n      let res = \"\";\n      let i = val.length;\n      const start = val[0] === \"-\" ? 1 : 0;\n      for (; i >= start + 4; i -= 3) {\n        res = `_${val.slice(i - 3, i)}${res}`;\n      }\n      return `${val.slice(0, i)}${res}`;\n    }\n    function getMessage(key, msg, args) {\n      if (typeof msg === \"function\") {\n        assert(\n          msg.length <= args.length,\n          `Code: ${key}; The provided arguments length (${args.length}) does not match the required ones (${msg.length}).`,\n        );\n        return msg(...args);\n      }\n      const expectedLength = (msg.match(/%[dfijoOs]/g) || []).length;\n      assert(\n        expectedLength === args.length,\n        `Code: ${key}; The provided arguments length (${args.length}) does not match the required ones (${expectedLength}).`,\n      );\n      if (args.length === 0) {\n        return msg;\n      }\n      return format(msg, ...args);\n    }\n    function E(code, message, Base) {\n      if (!Base) {\n        Base = Error;\n      }\n      class NodeError extends Base {\n        constructor(...args) {\n          super(getMessage(code, message, args));\n        }\n        toString() {\n          return `${this.name} [${code}]: ${this.message}`;\n        }\n      }\n      Object.defineProperties(NodeError.prototype, {\n        name: {\n          value: Base.name,\n          writable: true,\n          enumerable: false,\n          configurable: true,\n        },\n        toString: {\n          value() {\n            return `${this.name} [${code}]: ${this.message}`;\n          },\n          writable: true,\n          enumerable: false,\n          configurable: true,\n        },\n      });\n      NodeError.prototype.code = code;\n      NodeError.prototype[kIsNodeError] = true;\n      codes[code] = NodeError;\n    }\n    function hideStackFrames(fn) {\n      const hidden = nodeInternalPrefix + fn.name;\n      Object.defineProperty(fn, \"name\", {\n        value: hidden,\n      });\n      return fn;\n    }\n    function aggregateTwoErrors(innerError, outerError) {\n      if (innerError && outerError && innerError !== outerError) {\n        if (Array.isArray(outerError.errors)) {\n          outerError.errors.push(innerError);\n          return outerError;\n        }\n        const err = new AggregateError([outerError, innerError], outerError.message);\n        err.code = outerError.code;\n        return err;\n      }\n      return innerError || outerError;\n    }\n    var AbortError = class extends Error {\n      constructor(message = \"The operation was aborted\", options = void 0) {\n        if (options !== void 0 && typeof options !== \"object\") {\n          throw new codes.ERR_INVALID_ARG_TYPE(\"options\", \"Object\", options);\n        }\n        super(message, options);\n        this.code = \"ABORT_ERR\";\n        this.name = \"AbortError\";\n      }\n    };\n    E(\"ERR_ASSERTION\", \"%s\", Error);\n    E(\n      \"ERR_INVALID_ARG_TYPE\",\n      (name, expected, actual) => {\n        assert(typeof name === \"string\", \"'name' must be a string\");\n        if (!Array.isArray(expected)) {\n          expected = [expected];\n        }\n        let msg = \"The \";\n        if (name.endsWith(\" argument\")) {\n          msg += `${name} `;\n        } else {\n          msg += `\"${name}\" ${name.includes(\".\") ? \"property\" : \"argument\"} `;\n        }\n        msg += \"must be \";\n        const types = [];\n        const instances = [];\n        const other = [];\n        for (const value of expected) {\n          assert(typeof value === \"string\", \"All expected entries have to be of type string\");\n          if (kTypes.includes(value)) {\n            types.push(value.toLowerCase());\n          } else if (classRegExp.test(value)) {\n            instances.push(value);\n          } else {\n            assert(value !== \"object\", 'The value \"object\" should be written as \"Object\"');\n            other.push(value);\n          }\n        }\n        if (instances.length > 0) {\n          const pos = types.indexOf(\"object\");\n          if (pos !== -1) {\n            types.splice(types, pos, 1);\n            instances.push(\"Object\");\n          }\n        }\n        if (types.length > 0) {\n          switch (types.length) {\n            case 1:\n              msg += `of type ${types[0]}`;\n              break;\n            case 2:\n              msg += `one of type ${types[0]} or ${types[1]}`;\n              break;\n            default: {\n              const last = types.pop();\n              msg += `one of type ${types.join(\", \")}, or ${last}`;\n            }\n          }\n          if (instances.length > 0 || other.length > 0) {\n            msg += \" or \";\n          }\n        }\n        if (instances.length > 0) {\n          switch (instances.length) {\n            case 1:\n              msg += `an instance of ${instances[0]}`;\n              break;\n            case 2:\n              msg += `an instance of ${instances[0]} or ${instances[1]}`;\n              break;\n            default: {\n              const last = instances.pop();\n              msg += `an instance of ${instances.join(\", \")}, or ${last}`;\n            }\n          }\n          if (other.length > 0) {\n            msg += \" or \";\n          }\n        }\n        switch (other.length) {\n          case 0:\n            break;\n          case 1:\n            if (other[0].toLowerCase() !== other[0]) {\n              msg += \"an \";\n            }\n            msg += `${other[0]}`;\n            break;\n          case 2:\n            msg += `one of ${other[0]} or ${other[1]}`;\n            break;\n          default: {\n            const last = other.pop();\n            msg += `one of ${other.join(\", \")}, or ${last}`;\n          }\n        }\n        if (actual == null) {\n          msg += `. Received ${actual}`;\n        } else if (typeof actual === \"function\" && actual.name) {\n          msg += `. Received function ${actual.name}`;\n        } else if (typeof actual === \"object\") {\n          var _actual$constructor;\n          if (\n            (_actual$constructor = actual.constructor) !== null &&\n            _actual$constructor !== void 0 &&\n            _actual$constructor.name\n          ) {\n            msg += `. Received an instance of ${actual.constructor.name}`;\n          } else {\n            const inspected = inspect(actual, {\n              depth: -1,\n            });\n            msg += `. Received ${inspected}`;\n          }\n        } else {\n          let inspected = inspect(actual, {\n            colors: false,\n          });\n          if (inspected.length > 25) {\n            inspected = `${inspected.slice(0, 25)}...`;\n          }\n          msg += `. Received type ${typeof actual} (${inspected})`;\n        }\n        return msg;\n      },\n      TypeError,\n    );\n    E(\n      \"ERR_INVALID_ARG_VALUE\",\n      (name, value, reason = \"is invalid\") => {\n        let inspected = inspect(value);\n        if (inspected.length > 128) {\n          inspected = inspected.slice(0, 128) + \"...\";\n        }\n        const type = name.includes(\".\") ? \"property\" : \"argument\";\n        return `The ${type} '${name}' ${reason}. Received ${inspected}`;\n      },\n      TypeError,\n    );\n    E(\n      \"ERR_INVALID_RETURN_VALUE\",\n      (input, name, value) => {\n        var _value$constructor;\n        const type =\n          value !== null &&\n          value !== void 0 &&\n          (_value$constructor = value.constructor) !== null &&\n          _value$constructor !== void 0 &&\n          _value$constructor.name\n            ? `instance of ${value.constructor.name}`\n            : `type ${typeof value}`;\n        return `Expected ${input} to be returned from the \"${name}\" function but got ${type}.`;\n      },\n      TypeError,\n    );\n    E(\n      \"ERR_MISSING_ARGS\",\n      (...args) => {\n        assert(args.length > 0, \"At least one arg needs to be specified\");\n        let msg;\n        const len = args.length;\n        args = (Array.isArray(args) ? args : [args]).map(a => `\"${a}\"`).join(\" or \");\n        switch (len) {\n          case 1:\n            msg += `The ${args[0]} argument`;\n            break;\n          case 2:\n            msg += `The ${args[0]} and ${args[1]} arguments`;\n            break;\n          default:\n            {\n              const last = args.pop();\n              msg += `The ${args.join(\", \")}, and ${last} arguments`;\n            }\n            break;\n        }\n        return `${msg} must be specified`;\n      },\n      TypeError,\n    );\n    E(\n      \"ERR_OUT_OF_RANGE\",\n      (str, range, input) => {\n        assert(range, 'Missing \"range\" argument');\n        let received;\n        if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {\n          received = addNumericalSeparator(String(input));\n        } else if (typeof input === \"bigint\") {\n          received = String(input);\n          if (input > 2n ** 32n || input < -(2n ** 32n)) {\n            received = addNumericalSeparator(received);\n          }\n          received += \"n\";\n        } else {\n          received = inspect(input);\n        }\n        return `The value of \"${str}\" is out of range. It must be ${range}. Received ${received}`;\n      },\n      RangeError,\n    );\n    E(\"ERR_MULTIPLE_CALLBACK\", \"Callback called multiple times\", Error);\n    E(\"ERR_METHOD_NOT_IMPLEMENTED\", \"The %s method is not implemented\", Error);\n    E(\"ERR_STREAM_ALREADY_FINISHED\", \"Cannot call %s after a stream was finished\", Error);\n    E(\"ERR_STREAM_CANNOT_PIPE\", \"Cannot pipe, not readable\", Error);\n    E(\"ERR_STREAM_DESTROYED\", \"Cannot call %s after a stream was destroyed\", Error);\n    E(\"ERR_STREAM_NULL_VALUES\", \"May not write null values to stream\", TypeError);\n    E(\"ERR_STREAM_PREMATURE_CLOSE\", \"Premature close\", Error);\n    E(\"ERR_STREAM_PUSH_AFTER_EOF\", \"stream.push() after EOF\", Error);\n    E(\"ERR_STREAM_UNSHIFT_AFTER_END_EVENT\", \"stream.unshift() after end event\", Error);\n    E(\"ERR_STREAM_WRITE_AFTER_END\", \"write after end\", Error);\n    E(\"ERR_UNKNOWN_ENCODING\", \"Unknown encoding: %s\", TypeError);\n    module.exports = {\n      AbortError,\n      aggregateTwoErrors: hideStackFrames(aggregateTwoErrors),\n      hideStackFrames,\n      codes,\n    };\n  },\n});\n\n// node_modules/readable-stream/lib/internal/validators.js\nvar require_validators = __commonJS({\n  \"node_modules/readable-stream/lib/internal/validators.js\"(exports, module) {\n    \"use strict\";\n    var {\n      ArrayIsArray,\n      ArrayPrototypeIncludes,\n      ArrayPrototypeJoin,\n      ArrayPrototypeMap,\n      NumberIsInteger,\n      NumberMAX_SAFE_INTEGER,\n      NumberMIN_SAFE_INTEGER,\n      NumberParseInt,\n      RegExpPrototypeTest,\n      String: String2,\n      StringPrototypeToUpperCase,\n      StringPrototypeTrim,\n    } = require_primordials();\n    var {\n      hideStackFrames,\n      codes: { ERR_SOCKET_BAD_PORT, ERR_INVALID_ARG_TYPE, ERR_INVALID_ARG_VALUE, ERR_OUT_OF_RANGE, ERR_UNKNOWN_SIGNAL },\n    } = require_errors();\n    var { normalizeEncoding } = require_util();\n    var { isAsyncFunction, isArrayBufferView } = require_util().types;\n    var signals = {};\n    function isInt32(value) {\n      return value === (value | 0);\n    }\n    function isUint32(value) {\n      return value === value >>> 0;\n    }\n    var octalReg = /^[0-7]+$/;\n    var modeDesc = \"must be a 32-bit unsigned integer or an octal string\";\n    function parseFileMode(value, name, def) {\n      if (typeof value === \"undefined\") {\n        value = def;\n      }\n      if (typeof value === \"string\") {\n        if (!RegExpPrototypeTest(octalReg, value)) {\n          throw new ERR_INVALID_ARG_VALUE(name, value, modeDesc);\n        }\n        value = NumberParseInt(value, 8);\n      }\n      validateInt32(value, name, 0, 2 ** 32 - 1);\n      return value;\n    }\n    var validateInteger = hideStackFrames((value, name, min = NumberMIN_SAFE_INTEGER, max = NumberMAX_SAFE_INTEGER) => {\n      if (typeof value !== \"number\") throw new ERR_INVALID_ARG_TYPE(name, \"number\", value);\n      if (!NumberIsInteger(value)) throw new ERR_OUT_OF_RANGE(name, \"an integer\", value);\n      if (value < min || value > max) throw new ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value);\n    });\n    var validateInt32 = hideStackFrames((value, name, min = -2147483648, max = 2147483647) => {\n      if (typeof value !== \"number\") {\n        throw new ERR_INVALID_ARG_TYPE(name, \"number\", value);\n      }\n      if (!isInt32(value)) {\n        if (!NumberIsInteger(value)) {\n          throw new ERR_OUT_OF_RANGE(name, \"an integer\", value);\n        }\n        throw new ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value);\n      }\n      if (value < min || value > max) {\n        throw new ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value);\n      }\n    });\n    var validateUint32 = hideStackFrames((value, name, positive) => {\n      if (typeof value !== \"number\") {\n        throw new ERR_INVALID_ARG_TYPE(name, \"number\", value);\n      }\n      if (!isUint32(value)) {\n        if (!NumberIsInteger(value)) {\n          throw new ERR_OUT_OF_RANGE(name, \"an integer\", value);\n        }\n        const min = positive ? 1 : 0;\n        throw new ERR_OUT_OF_RANGE(name, `>= ${min} && < 4294967296`, value);\n      }\n      if (positive && value === 0) {\n        throw new ERR_OUT_OF_RANGE(name, \">= 1 && < 4294967296\", value);\n      }\n    });\n    function validateString(value, name) {\n      if (typeof value !== \"string\") throw new ERR_INVALID_ARG_TYPE(name, \"string\", value);\n    }\n    function validateNumber(value, name) {\n      if (typeof value !== \"number\") throw new ERR_INVALID_ARG_TYPE(name, \"number\", value);\n    }\n    var validateOneOf = hideStackFrames((value, name, oneOf) => {\n      if (!ArrayPrototypeIncludes(oneOf, value)) {\n        const allowed = ArrayPrototypeJoin(\n          ArrayPrototypeMap(oneOf, v => (typeof v === \"string\" ? `'${v}'` : String2(v))),\n          \", \",\n        );\n        const reason = \"must be one of: \" + allowed;\n        throw new ERR_INVALID_ARG_VALUE(name, value, reason);\n      }\n    });\n    function validateBoolean(value, name) {\n      if (typeof value !== \"boolean\") throw new ERR_INVALID_ARG_TYPE(name, \"boolean\", value);\n    }\n    var validateObject = hideStackFrames((value, name, options) => {\n      const useDefaultOptions = options == null;\n      const allowArray = useDefaultOptions ? false : options.allowArray;\n      const allowFunction = useDefaultOptions ? false : options.allowFunction;\n      const nullable = useDefaultOptions ? false : options.nullable;\n      if (\n        (!nullable && value === null) ||\n        (!allowArray && ArrayIsArray(value)) ||\n        (typeof value !== \"object\" && (!allowFunction || typeof value !== \"function\"))\n      ) {\n        throw new ERR_INVALID_ARG_TYPE(name, \"Object\", value);\n      }\n    });\n    var validateArray = hideStackFrames((value, name, minLength = 0) => {\n      if (!ArrayIsArray(value)) {\n        throw new ERR_INVALID_ARG_TYPE(name, \"Array\", value);\n      }\n      if (value.length < minLength) {\n        const reason = `must be longer than ${minLength}`;\n        throw new ERR_INVALID_ARG_VALUE(name, value, reason);\n      }\n    });\n    function validateSignalName(signal, name = \"signal\") {\n      validateString(signal, name);\n      if (signals[signal] === void 0) {\n        if (signals[StringPrototypeToUpperCase(signal)] !== void 0) {\n          throw new ERR_UNKNOWN_SIGNAL(signal + \" (signals must use all capital letters)\");\n        }\n        throw new ERR_UNKNOWN_SIGNAL(signal);\n      }\n    }\n    var validateBuffer = hideStackFrames((buffer, name = \"buffer\") => {\n      if (!isArrayBufferView(buffer)) {\n        throw new ERR_INVALID_ARG_TYPE(name, [\"Buffer\", \"TypedArray\", \"DataView\"], buffer);\n      }\n    });\n    function validateEncoding(data, encoding) {\n      const normalizedEncoding = normalizeEncoding(encoding);\n      const length = data.length;\n      if (normalizedEncoding === \"hex\" && length % 2 !== 0) {\n        throw new ERR_INVALID_ARG_VALUE(\"encoding\", encoding, `is invalid for data of length ${length}`);\n      }\n    }\n    function validatePort(port, name = \"Port\", allowZero = true) {\n      if (\n        (typeof port !== \"number\" && typeof port !== \"string\") ||\n        (typeof port === \"string\" && StringPrototypeTrim(port).length === 0) ||\n        +port !== +port >>> 0 ||\n        port > 65535 ||\n        (port === 0 && !allowZero)\n      ) {\n        throw new ERR_SOCKET_BAD_PORT(name, port, allowZero);\n      }\n      return port | 0;\n    }\n    var validateAbortSignal = hideStackFrames((signal, name) => {\n      if (signal !== void 0 && (signal === null || typeof signal !== \"object\" || !(\"aborted\" in signal))) {\n        throw new ERR_INVALID_ARG_TYPE(name, \"AbortSignal\", signal);\n      }\n    });\n    var validateFunction = hideStackFrames((value, name) => {\n      if (typeof value !== \"function\") throw new ERR_INVALID_ARG_TYPE(name, \"Function\", value);\n    });\n    var validatePlainFunction = hideStackFrames((value, name) => {\n      if (typeof value !== \"function\" || isAsyncFunction(value))\n        throw new ERR_INVALID_ARG_TYPE(name, \"Function\", value);\n    });\n    var validateUndefined = hideStackFrames((value, name) => {\n      if (value !== void 0) throw new ERR_INVALID_ARG_TYPE(name, \"undefined\", value);\n    });\n    module.exports = {\n      isInt32,\n      isUint32,\n      parseFileMode,\n      validateArray,\n      validateBoolean,\n      validateBuffer,\n      validateEncoding,\n      validateFunction,\n      validateInt32,\n      validateInteger,\n      validateNumber,\n      validateObject,\n      validateOneOf,\n      validatePlainFunction,\n      validatePort,\n      validateSignalName,\n      validateString,\n      validateUint32,\n      validateUndefined,\n      validateAbortSignal,\n    };\n  },\n});\n\n// node_modules/readable-stream/lib/internal/streams/utils.js\nvar require_utils = __commonJS({\n  \"node_modules/readable-stream/lib/internal/streams/utils.js\"(exports, module) {\n    \"use strict\";\n    var { Symbol: Symbol2, SymbolAsyncIterator, SymbolIterator } = require_primordials();\n    var kDestroyed = Symbol2(\"kDestroyed\");\n    var kIsErrored = Symbol2(\"kIsErrored\");\n    var kIsReadable = Symbol2(\"kIsReadable\");\n    var kIsDisturbed = Symbol2(\"kIsDisturbed\");\n    function isReadableNodeStream(obj, strict = false) {\n      var _obj$_readableState;\n      return !!(\n        obj &&\n        typeof obj.pipe === \"function\" &&\n        typeof obj.on === \"function\" &&\n        (!strict || (typeof obj.pause === \"function\" && typeof obj.resume === \"function\")) &&\n        (!obj._writableState ||\n          ((_obj$_readableState = obj._readableState) === null || _obj$_readableState === void 0\n            ? void 0\n            : _obj$_readableState.readable) !== false) &&\n        (!obj._writableState || obj._readableState)\n      );\n    }\n    function isWritableNodeStream(obj) {\n      var _obj$_writableState;\n      return !!(\n        obj &&\n        typeof obj.write === \"function\" &&\n        typeof obj.on === \"function\" &&\n        (!obj._readableState ||\n          ((_obj$_writableState = obj._writableState) === null || _obj$_writableState === void 0\n            ? void 0\n            : _obj$_writableState.writable) !== false)\n      );\n    }\n    function isDuplexNodeStream(obj) {\n      return !!(\n        obj &&\n        typeof obj.pipe === \"function\" &&\n        obj._readableState &&\n        typeof obj.on === \"function\" &&\n        typeof obj.write === \"function\"\n      );\n    }\n    function isNodeStream(obj) {\n      return (\n        obj &&\n        (obj._readableState ||\n          obj._writableState ||\n          (typeof obj.write === \"function\" && typeof obj.on === \"function\") ||\n          (typeof obj.pipe === \"function\" && typeof obj.on === \"function\"))\n      );\n    }\n    function isIterable(obj, isAsync) {\n      if (obj == null) return false;\n      if (isAsync === true) return typeof obj[SymbolAsyncIterator] === \"function\";\n      if (isAsync === false) return typeof obj[SymbolIterator] === \"function\";\n      return typeof obj[SymbolAsyncIterator] === \"function\" || typeof obj[SymbolIterator] === \"function\";\n    }\n    function isDestroyed(stream) {\n      if (!isNodeStream(stream)) return null;\n      const wState = stream._writableState;\n      const rState = stream._readableState;\n      const state = wState || rState;\n      return !!(stream.destroyed || stream[kDestroyed] || (state !== null && state !== void 0 && state.destroyed));\n    }\n    function isWritableEnded(stream) {\n      if (!isWritableNodeStream(stream)) return null;\n      if (stream.writableEnded === true) return true;\n      const wState = stream._writableState;\n      if (wState !== null && wState !== void 0 && wState.errored) return false;\n      if (typeof (wState === null || wState === void 0 ? void 0 : wState.ended) !== \"boolean\") return null;\n      return wState.ended;\n    }\n    function isWritableFinished(stream, strict) {\n      if (!isWritableNodeStream(stream)) return null;\n      if (stream.writableFinished === true) return true;\n      const wState = stream._writableState;\n      if (wState !== null && wState !== void 0 && wState.errored) return false;\n      if (typeof (wState === null || wState === void 0 ? void 0 : wState.finished) !== \"boolean\") return null;\n      return !!(wState.finished || (strict === false && wState.ended === true && wState.length === 0));\n    }\n    function isReadableEnded(stream) {\n      if (!isReadableNodeStream(stream)) return null;\n      if (stream.readableEnded === true) return true;\n      const rState = stream._readableState;\n      if (!rState || rState.errored) return false;\n      if (typeof (rState === null || rState === void 0 ? void 0 : rState.ended) !== \"boolean\") return null;\n      return rState.ended;\n    }\n    function isReadableFinished(stream, strict) {\n      if (!isReadableNodeStream(stream)) return null;\n      const rState = stream._readableState;\n      if (rState !== null && rState !== void 0 && rState.errored) return false;\n      if (typeof (rState === null || rState === void 0 ? void 0 : rState.endEmitted) !== \"boolean\") return null;\n      return !!(rState.endEmitted || (strict === false && rState.ended === true && rState.length === 0));\n    }\n    function isReadable(stream) {\n      if (stream && stream[kIsReadable] != null) return stream[kIsReadable];\n      if (typeof (stream === null || stream === void 0 ? void 0 : stream.readable) !== \"boolean\") return null;\n      if (isDestroyed(stream)) return false;\n      return isReadableNodeStream(stream) && stream.readable && !isReadableFinished(stream);\n    }\n    function isWritable(stream) {\n      if (typeof (stream === null || stream === void 0 ? void 0 : stream.writable) !== \"boolean\") return null;\n      if (isDestroyed(stream)) return false;\n      return isWritableNodeStream(stream) && stream.writable && !isWritableEnded(stream);\n    }\n    function isFinished(stream, opts) {\n      if (!isNodeStream(stream)) {\n        return null;\n      }\n      if (isDestroyed(stream)) {\n        return true;\n      }\n      if ((opts === null || opts === void 0 ? void 0 : opts.readable) !== false && isReadable(stream)) {\n        return false;\n      }\n      if ((opts === null || opts === void 0 ? void 0 : opts.writable) !== false && isWritable(stream)) {\n        return false;\n      }\n      return true;\n    }\n    function isWritableErrored(stream) {\n      var _stream$_writableStat, _stream$_writableStat2;\n      if (!isNodeStream(stream)) {\n        return null;\n      }\n      if (stream.writableErrored) {\n        return stream.writableErrored;\n      }\n      return (_stream$_writableStat =\n        (_stream$_writableStat2 = stream._writableState) === null || _stream$_writableStat2 === void 0\n          ? void 0\n          : _stream$_writableStat2.errored) !== null && _stream$_writableStat !== void 0\n        ? _stream$_writableStat\n        : null;\n    }\n    function isReadableErrored(stream) {\n      var _stream$_readableStat, _stream$_readableStat2;\n      if (!isNodeStream(stream)) {\n        return null;\n      }\n      if (stream.readableErrored) {\n        return stream.readableErrored;\n      }\n      return (_stream$_readableStat =\n        (_stream$_readableStat2 = stream._readableState) === null || _stream$_readableStat2 === void 0\n          ? void 0\n          : _stream$_readableStat2.errored) !== null && _stream$_readableStat !== void 0\n        ? _stream$_readableStat\n        : null;\n    }\n    function isClosed(stream) {\n      if (!isNodeStream(stream)) {\n        return null;\n      }\n      if (typeof stream.closed === \"boolean\") {\n        return stream.closed;\n      }\n      const wState = stream._writableState;\n      const rState = stream._readableState;\n      if (\n        typeof (wState === null || wState === void 0 ? void 0 : wState.closed) === \"boolean\" ||\n        typeof (rState === null || rState === void 0 ? void 0 : rState.closed) === \"boolean\"\n      ) {\n        return (\n          (wState === null || wState === void 0 ? void 0 : wState.closed) ||\n          (rState === null || rState === void 0 ? void 0 : rState.closed)\n        );\n      }\n      if (typeof stream._closed === \"boolean\" && isOutgoingMessage(stream)) {\n        return stream._closed;\n      }\n      return null;\n    }\n    function isOutgoingMessage(stream) {\n      return (\n        typeof stream._closed === \"boolean\" &&\n        typeof stream._defaultKeepAlive === \"boolean\" &&\n        typeof stream._removedConnection === \"boolean\" &&\n        typeof stream._removedContLen === \"boolean\"\n      );\n    }\n    function isServerResponse(stream) {\n      return typeof stream._sent100 === \"boolean\" && isOutgoingMessage(stream);\n    }\n    function isServerRequest(stream) {\n      var _stream$req;\n      return (\n        typeof stream._consuming === \"boolean\" &&\n        typeof stream._dumped === \"boolean\" &&\n        ((_stream$req = stream.req) === null || _stream$req === void 0 ? void 0 : _stream$req.upgradeOrConnect) ===\n          void 0\n      );\n    }\n    function willEmitClose(stream) {\n      if (!isNodeStream(stream)) return null;\n      const wState = stream._writableState;\n      const rState = stream._readableState;\n      const state = wState || rState;\n      return (\n        (!state && isServerResponse(stream)) ||\n        !!(state && state.autoDestroy && state.emitClose && state.closed === false)\n      );\n    }\n    function isDisturbed(stream) {\n      var _stream$kIsDisturbed;\n      return !!(\n        stream &&\n        ((_stream$kIsDisturbed = stream[kIsDisturbed]) !== null && _stream$kIsDisturbed !== void 0\n          ? _stream$kIsDisturbed\n          : stream.readableDidRead || stream.readableAborted)\n      );\n    }\n    function isErrored(stream) {\n      var _ref,\n        _ref2,\n        _ref3,\n        _ref4,\n        _ref5,\n        _stream$kIsErrored,\n        _stream$_readableStat3,\n        _stream$_writableStat3,\n        _stream$_readableStat4,\n        _stream$_writableStat4;\n      return !!(\n        stream &&\n        ((_ref =\n          (_ref2 =\n            (_ref3 =\n              (_ref4 =\n                (_ref5 =\n                  (_stream$kIsErrored = stream[kIsErrored]) !== null && _stream$kIsErrored !== void 0\n                    ? _stream$kIsErrored\n                    : stream.readableErrored) !== null && _ref5 !== void 0\n                  ? _ref5\n                  : stream.writableErrored) !== null && _ref4 !== void 0\n                ? _ref4\n                : (_stream$_readableStat3 = stream._readableState) === null || _stream$_readableStat3 === void 0\n                ? void 0\n                : _stream$_readableStat3.errorEmitted) !== null && _ref3 !== void 0\n              ? _ref3\n              : (_stream$_writableStat3 = stream._writableState) === null || _stream$_writableStat3 === void 0\n              ? void 0\n              : _stream$_writableStat3.errorEmitted) !== null && _ref2 !== void 0\n            ? _ref2\n            : (_stream$_readableStat4 = stream._readableState) === null || _stream$_readableStat4 === void 0\n            ? void 0\n            : _stream$_readableStat4.errored) !== null && _ref !== void 0\n          ? _ref\n          : (_stream$_writableStat4 = stream._writableState) === null || _stream$_writableStat4 === void 0\n          ? void 0\n          : _stream$_writableStat4.errored)\n      );\n    }\n    module.exports = {\n      kDestroyed,\n      isDisturbed,\n      kIsDisturbed,\n      isErrored,\n      kIsErrored,\n      isReadable,\n      kIsReadable,\n      isClosed,\n      isDestroyed,\n      isDuplexNodeStream,\n      isFinished,\n      isIterable,\n      isReadableNodeStream,\n      isReadableEnded,\n      isReadableFinished,\n      isReadableErrored,\n      isNodeStream,\n      isWritable,\n      isWritableNodeStream,\n      isWritableEnded,\n      isWritableFinished,\n      isWritableErrored,\n      isServerRequest,\n      isServerResponse,\n      willEmitClose,\n    };\n  },\n});\n\n// node_modules/readable-stream/lib/internal/streams/end-of-stream.js\nvar require_end_of_stream = __commonJS({\n  \"node_modules/readable-stream/lib/internal/streams/end-of-stream.js\"(exports, module) {\n    \"use strict\";\n    var { AbortError, codes } = require_errors();\n    var { ERR_INVALID_ARG_TYPE, ERR_STREAM_PREMATURE_CLOSE } = codes;\n    var { once } = require_util();\n    var { validateAbortSignal, validateFunction, validateObject } = require_validators();\n    var { Promise: Promise2 } = require_primordials();\n    var {\n      isClosed,\n      isReadable,\n      isReadableNodeStream,\n      isReadableFinished,\n      isReadableErrored,\n      isWritable,\n      isWritableNodeStream,\n      isWritableFinished,\n      isWritableErrored,\n      isNodeStream,\n      willEmitClose: _willEmitClose,\n    } = require_utils();\n    function isRequest(stream) {\n      return stream.setHeader && typeof stream.abort === \"function\";\n    }\n    var nop = () => {};\n    function eos(stream, options, callback) {\n      var _options$readable, _options$writable;\n      if (arguments.length === 2) {\n        callback = options;\n        options = {};\n      } else if (options == null) {\n        options = {};\n      } else {\n        validateObject(options, \"options\");\n      }\n      validateFunction(callback, \"callback\");\n      validateAbortSignal(options.signal, \"options.signal\");\n      callback = once(callback);\n      const readable =\n        (_options$readable = options.readable) !== null && _options$readable !== void 0\n          ? _options$readable\n          : isReadableNodeStream(stream);\n      const writable =\n        (_options$writable = options.writable) !== null && _options$writable !== void 0\n          ? _options$writable\n          : isWritableNodeStream(stream);\n      if (!isNodeStream(stream)) {\n        throw new ERR_INVALID_ARG_TYPE(\"stream\", \"Stream\", stream);\n      }\n      const wState = stream._writableState;\n      const rState = stream._readableState;\n      const onlegacyfinish = () => {\n        if (!stream.writable) {\n          onfinish();\n        }\n      };\n      let willEmitClose =\n        _willEmitClose(stream) &&\n        isReadableNodeStream(stream) === readable &&\n        isWritableNodeStream(stream) === writable;\n      let writableFinished = isWritableFinished(stream, false);\n      const onfinish = () => {\n        writableFinished = true;\n        if (stream.destroyed) {\n          willEmitClose = false;\n        }\n        if (willEmitClose && (!stream.readable || readable)) {\n          return;\n        }\n        if (!readable || readableFinished) {\n          callback.call(stream);\n        }\n      };\n      let readableFinished = isReadableFinished(stream, false);\n      const onend = () => {\n        readableFinished = true;\n        if (stream.destroyed) {\n          willEmitClose = false;\n        }\n        if (willEmitClose && (!stream.writable || writable)) {\n          return;\n        }\n        if (!writable || writableFinished) {\n          callback.call(stream);\n        }\n      };\n      const onerror = err => {\n        callback.call(stream, err);\n      };\n      let closed = isClosed(stream);\n      const onclose = () => {\n        closed = true;\n        const errored = isWritableErrored(stream) || isReadableErrored(stream);\n        if (errored && typeof errored !== \"boolean\") {\n          return callback.call(stream, errored);\n        }\n        if (readable && !readableFinished && isReadableNodeStream(stream, true)) {\n          if (!isReadableFinished(stream, false)) return callback.call(stream, new ERR_STREAM_PREMATURE_CLOSE());\n        }\n        if (writable && !writableFinished) {\n          if (!isWritableFinished(stream, false)) return callback.call(stream, new ERR_STREAM_PREMATURE_CLOSE());\n        }\n        callback.call(stream);\n      };\n      const onrequest = () => {\n        stream.req.on(\"finish\", onfinish);\n      };\n      if (isRequest(stream)) {\n        stream.on(\"complete\", onfinish);\n        if (!willEmitClose) {\n          stream.on(\"abort\", onclose);\n        }\n        if (stream.req) {\n          onrequest();\n        } else {\n          stream.on(\"request\", onrequest);\n        }\n      } else if (writable && !wState) {\n        stream.on(\"end\", onlegacyfinish);\n        stream.on(\"close\", onlegacyfinish);\n      }\n      if (!willEmitClose && typeof stream.aborted === \"boolean\") {\n        stream.on(\"aborted\", onclose);\n      }\n      stream.on(\"end\", onend);\n      stream.on(\"finish\", onfinish);\n      if (options.error !== false) {\n        stream.on(\"error\", onerror);\n      }\n      stream.on(\"close\", onclose);\n      if (closed) {\n        runOnNextTick(onclose);\n      } else if (\n        (wState !== null && wState !== void 0 && wState.errorEmitted) ||\n        (rState !== null && rState !== void 0 && rState.errorEmitted)\n      ) {\n        if (!willEmitClose) {\n          runOnNextTick(onclose);\n        }\n      } else if (\n        !readable &&\n        (!willEmitClose || isReadable(stream)) &&\n        (writableFinished || isWritable(stream) === false)\n      ) {\n        runOnNextTick(onclose);\n      } else if (\n        !writable &&\n        (!willEmitClose || isWritable(stream)) &&\n        (readableFinished || isReadable(stream) === false)\n      ) {\n        runOnNextTick(onclose);\n      } else if (rState && stream.req && stream.aborted) {\n        runOnNextTick(onclose);\n      }\n      const cleanup = () => {\n        callback = nop;\n        stream.removeListener(\"aborted\", onclose);\n        stream.removeListener(\"complete\", onfinish);\n        stream.removeListener(\"abort\", onclose);\n        stream.removeListener(\"request\", onrequest);\n        if (stream.req) stream.req.removeListener(\"finish\", onfinish);\n        stream.removeListener(\"end\", onlegacyfinish);\n        stream.removeListener(\"close\", onlegacyfinish);\n        stream.removeListener(\"finish\", onfinish);\n        stream.removeListener(\"end\", onend);\n        stream.removeListener(\"error\", onerror);\n        stream.removeListener(\"close\", onclose);\n      };\n      if (options.signal && !closed) {\n        const abort = () => {\n          const endCallback = callback;\n          cleanup();\n          endCallback.call(\n            stream,\n            new AbortError(void 0, {\n              cause: options.signal.reason,\n            }),\n          );\n        };\n        if (options.signal.aborted) {\n          runOnNextTick(abort);\n        } else {\n          const originalCallback = callback;\n          callback = once((...args) => {\n            options.signal.removeEventListener(\"abort\", abort);\n            originalCallback.apply(stream, args);\n          });\n          options.signal.addEventListener(\"abort\", abort);\n        }\n      }\n      return cleanup;\n    }\n    function finished(stream, opts) {\n      return new Promise2((resolve, reject) => {\n        eos(stream, opts, err => {\n          if (err) {\n            reject(err);\n          } else {\n            resolve();\n          }\n        });\n      });\n    }\n    module.exports = eos;\n    module.exports.finished = finished;\n  },\n});\n\n// node_modules/readable-stream/lib/internal/streams/operators.js\nvar require_operators = __commonJS({\n  \"node_modules/readable-stream/lib/internal/streams/operators.js\"(exports, module) {\n    \"use strict\";\n    var AbortController = globalThis.AbortController || __require(\"abort-controller\").AbortController;\n    var {\n      codes: { ERR_INVALID_ARG_TYPE, ERR_MISSING_ARGS, ERR_OUT_OF_RANGE },\n      AbortError,\n    } = require_errors();\n    var { validateAbortSignal, validateInteger, validateObject } = require_validators();\n    var kWeakHandler = require_primordials().Symbol(\"kWeak\");\n    var { finished } = require_end_of_stream();\n    var {\n      ArrayPrototypePush,\n      MathFloor,\n      Number: Number2,\n      NumberIsNaN,\n      Promise: Promise2,\n      PromiseReject,\n      PromisePrototypeCatch,\n      Symbol: Symbol2,\n    } = require_primordials();\n    var kEmpty = Symbol2(\"kEmpty\");\n    var kEof = Symbol2(\"kEof\");\n    function map(fn, options) {\n      if (typeof fn !== \"function\") {\n        throw new ERR_INVALID_ARG_TYPE(\"fn\", [\"Function\", \"AsyncFunction\"], fn);\n      }\n      if (options != null) {\n        validateObject(options, \"options\");\n      }\n      if ((options === null || options === void 0 ? void 0 : options.signal) != null) {\n        validateAbortSignal(options.signal, \"options.signal\");\n      }\n      let concurrency = 1;\n      if ((options === null || options === void 0 ? void 0 : options.concurrency) != null) {\n        concurrency = MathFloor(options.concurrency);\n      }\n      validateInteger(concurrency, \"concurrency\", 1);\n      return async function* map2() {\n        var _options$signal, _options$signal2;\n        const ac = new AbortController();\n        const stream = this;\n        const queue = [];\n        const signal = ac.signal;\n        const signalOpt = {\n          signal,\n        };\n        const abort = () => ac.abort();\n        if (\n          options !== null &&\n          options !== void 0 &&\n          (_options$signal = options.signal) !== null &&\n          _options$signal !== void 0 &&\n          _options$signal.aborted\n        ) {\n          abort();\n        }\n        options === null || options === void 0\n          ? void 0\n          : (_options$signal2 = options.signal) === null || _options$signal2 === void 0\n          ? void 0\n          : _options$signal2.addEventListener(\"abort\", abort);\n        let next;\n        let resume;\n        let done = false;\n        function onDone() {\n          done = true;\n        }\n        async function pump() {\n          try {\n            for await (let val of stream) {\n              var _val;\n              if (done) {\n                return;\n              }\n              if (signal.aborted) {\n                throw new AbortError();\n              }\n              try {\n                val = fn(val, signalOpt);\n              } catch (err) {\n                val = PromiseReject(err);\n              }\n              if (val === kEmpty) {\n                continue;\n              }\n              if (typeof ((_val = val) === null || _val === void 0 ? void 0 : _val.catch) === \"function\") {\n                val.catch(onDone);\n              }\n              queue.push(val);\n              if (next) {\n                next();\n                next = null;\n              }\n              if (!done && queue.length && queue.length >= concurrency) {\n                await new Promise2(resolve => {\n                  resume = resolve;\n                });\n              }\n            }\n            queue.push(kEof);\n          } catch (err) {\n            const val = PromiseReject(err);\n            PromisePrototypeCatch(val, onDone);\n            queue.push(val);\n          } finally {\n            var _options$signal3;\n            done = true;\n            if (next) {\n              next();\n              next = null;\n            }\n            options === null || options === void 0\n              ? void 0\n              : (_options$signal3 = options.signal) === null || _options$signal3 === void 0\n              ? void 0\n              : _options$signal3.removeEventListener(\"abort\", abort);\n          }\n        }\n        pump();\n        try {\n          while (true) {\n            while (queue.length > 0) {\n              const val = await queue[0];\n              if (val === kEof) {\n                return;\n              }\n              if (signal.aborted) {\n                throw new AbortError();\n              }\n              if (val !== kEmpty) {\n                yield val;\n              }\n              queue.shift();\n              if (resume) {\n                resume();\n                resume = null;\n              }\n            }\n            await new Promise2(resolve => {\n              next = resolve;\n            });\n          }\n        } finally {\n          ac.abort();\n          done = true;\n          if (resume) {\n            resume();\n            resume = null;\n          }\n        }\n      }.call(this);\n    }\n    function asIndexedPairs(options = void 0) {\n      if (options != null) {\n        validateObject(options, \"options\");\n      }\n      if ((options === null || options === void 0 ? void 0 : options.signal) != null) {\n        validateAbortSignal(options.signal, \"options.signal\");\n      }\n      return async function* asIndexedPairs2() {\n        let index = 0;\n        for await (const val of this) {\n          var _options$signal4;\n          if (\n            options !== null &&\n            options !== void 0 &&\n            (_options$signal4 = options.signal) !== null &&\n            _options$signal4 !== void 0 &&\n            _options$signal4.aborted\n          ) {\n            throw new AbortError({\n              cause: options.signal.reason,\n            });\n          }\n          yield [index++, val];\n        }\n      }.call(this);\n    }\n    async function some(fn, options = void 0) {\n      for await (const unused of filter.call(this, fn, options)) {\n        return true;\n      }\n      return false;\n    }\n    async function every(fn, options = void 0) {\n      if (typeof fn !== \"function\") {\n        throw new ERR_INVALID_ARG_TYPE(\"fn\", [\"Function\", \"AsyncFunction\"], fn);\n      }\n      return !(await some.call(\n        this,\n        async (...args) => {\n          return !(await fn(...args));\n        },\n        options,\n      ));\n    }\n    async function find(fn, options) {\n      for await (const result of filter.call(this, fn, options)) {\n        return result;\n      }\n      return void 0;\n    }\n    async function forEach(fn, options) {\n      if (typeof fn !== \"function\") {\n        throw new ERR_INVALID_ARG_TYPE(\"fn\", [\"Function\", \"AsyncFunction\"], fn);\n      }\n      async function forEachFn(value, options2) {\n        await fn(value, options2);\n        return kEmpty;\n      }\n      for await (const unused of map.call(this, forEachFn, options));\n    }\n    function filter(fn, options) {\n      if (typeof fn !== \"function\") {\n        throw new ERR_INVALID_ARG_TYPE(\"fn\", [\"Function\", \"AsyncFunction\"], fn);\n      }\n      async function filterFn(value, options2) {\n        if (await fn(value, options2)) {\n          return value;\n        }\n        return kEmpty;\n      }\n      return map.call(this, filterFn, options);\n    }\n    var ReduceAwareErrMissingArgs = class extends ERR_MISSING_ARGS {\n      constructor() {\n        super(\"reduce\");\n        this.message = \"Reduce of an empty stream requires an initial value\";\n      }\n    };\n    async function reduce(reducer, initialValue, options) {\n      var _options$signal5;\n      if (typeof reducer !== \"function\") {\n        throw new ERR_INVALID_ARG_TYPE(\"reducer\", [\"Function\", \"AsyncFunction\"], reducer);\n      }\n      if (options != null) {\n        validateObject(options, \"options\");\n      }\n      if ((options === null || options === void 0 ? void 0 : options.signal) != null) {\n        validateAbortSignal(options.signal, \"options.signal\");\n      }\n      let hasInitialValue = arguments.length > 1;\n      if (\n        options !== null &&\n        options !== void 0 &&\n        (_options$signal5 = options.signal) !== null &&\n        _options$signal5 !== void 0 &&\n        _options$signal5.aborted\n      ) {\n        const err = new AbortError(void 0, {\n          cause: options.signal.reason,\n        });\n        this.once(\"error\", () => {});\n        await finished(this.destroy(err));\n        throw err;\n      }\n      const ac = new AbortController();\n      const signal = ac.signal;\n      if (options !== null && options !== void 0 && options.signal) {\n        const opts = {\n          once: true,\n          [kWeakHandler]: this,\n        };\n        options.signal.addEventListener(\"abort\", () => ac.abort(), opts);\n      }\n      let gotAnyItemFromStream = false;\n      try {\n        for await (const value of this) {\n          var _options$signal6;\n          gotAnyItemFromStream = true;\n          if (\n            options !== null &&\n            options !== void 0 &&\n            (_options$signal6 = options.signal) !== null &&\n            _options$signal6 !== void 0 &&\n            _options$signal6.aborted\n          ) {\n            throw new AbortError();\n          }\n          if (!hasInitialValue) {\n            initialValue = value;\n            hasInitialValue = true;\n          } else {\n            initialValue = await reducer(initialValue, value, {\n              signal,\n            });\n          }\n        }\n        if (!gotAnyItemFromStream && !hasInitialValue) {\n          throw new ReduceAwareErrMissingArgs();\n        }\n      } finally {\n        ac.abort();\n      }\n      return initialValue;\n    }\n    async function toArray(options) {\n      if (options != null) {\n        validateObject(options, \"options\");\n      }\n      if ((options === null || options === void 0 ? void 0 : options.signal) != null) {\n        validateAbortSignal(options.signal, \"options.signal\");\n      }\n      const result = [];\n      for await (const val of this) {\n        var _options$signal7;\n        if (\n          options !== null &&\n          options !== void 0 &&\n          (_options$signal7 = options.signal) !== null &&\n          _options$signal7 !== void 0 &&\n          _options$signal7.aborted\n        ) {\n          throw new AbortError(void 0, {\n            cause: options.signal.reason,\n          });\n        }\n        ArrayPrototypePush(result, val);\n      }\n      return result;\n    }\n    function flatMap(fn, options) {\n      const values = map.call(this, fn, options);\n      return async function* flatMap2() {\n        for await (const val of values) {\n          yield* val;\n        }\n      }.call(this);\n    }\n    function toIntegerOrInfinity(number) {\n      number = Number2(number);\n      if (NumberIsNaN(number)) {\n        return 0;\n      }\n      if (number < 0) {\n        throw new ERR_OUT_OF_RANGE(\"number\", \">= 0\", number);\n      }\n      return number;\n    }\n    function drop(number, options = void 0) {\n      if (options != null) {\n        validateObject(options, \"options\");\n      }\n      if ((options === null || options === void 0 ? void 0 : options.signal) != null) {\n        validateAbortSignal(options.signal, \"options.signal\");\n      }\n      number = toIntegerOrInfinity(number);\n      return async function* drop2() {\n        var _options$signal8;\n        if (\n          options !== null &&\n          options !== void 0 &&\n          (_options$signal8 = options.signal) !== null &&\n          _options$signal8 !== void 0 &&\n          _options$signal8.aborted\n        ) {\n          throw new AbortError();\n        }\n        for await (const val of this) {\n          var _options$signal9;\n          if (\n            options !== null &&\n            options !== void 0 &&\n            (_options$signal9 = options.signal) !== null &&\n            _options$signal9 !== void 0 &&\n            _options$signal9.aborted\n          ) {\n            throw new AbortError();\n          }\n          if (number-- <= 0) {\n            yield val;\n          }\n        }\n      }.call(this);\n    }\n    function take(number, options = void 0) {\n      if (options != null) {\n        validateObject(options, \"options\");\n      }\n      if ((options === null || options === void 0 ? void 0 : options.signal) != null) {\n        validateAbortSignal(options.signal, \"options.signal\");\n      }\n      number = toIntegerOrInfinity(number);\n      return async function* take2() {\n        var _options$signal10;\n        if (\n          options !== null &&\n          options !== void 0 &&\n          (_options$signal10 = options.signal) !== null &&\n          _options$signal10 !== void 0 &&\n          _options$signal10.aborted\n        ) {\n          throw new AbortError();\n        }\n        for await (const val of this) {\n          var _options$signal11;\n          if (\n            options !== null &&\n            options !== void 0 &&\n            (_options$signal11 = options.signal) !== null &&\n            _options$signal11 !== void 0 &&\n            _options$signal11.aborted\n          ) {\n            throw new AbortError();\n          }\n          if (number-- > 0) {\n            yield val;\n          } else {\n            return;\n          }\n        }\n      }.call(this);\n    }\n    module.exports.streamReturningOperators = {\n      asIndexedPairs,\n      drop,\n      filter,\n      flatMap,\n      map,\n      take,\n    };\n    module.exports.promiseReturningOperators = {\n      every,\n      forEach,\n      reduce,\n      toArray,\n      some,\n      find,\n    };\n  },\n});\n\n// node_modules/readable-stream/lib/internal/streams/destroy.js\nvar require_destroy = __commonJS({\n  \"node_modules/readable-stream/lib/internal/streams/destroy.js\"(exports, module) {\n    \"use strict\";\n    var {\n      aggregateTwoErrors,\n      codes: { ERR_MULTIPLE_CALLBACK },\n      AbortError,\n    } = require_errors();\n    var { Symbol: Symbol2 } = require_primordials();\n    var { kDestroyed, isDestroyed, isFinished, isServerRequest } = require_utils();\n    var kDestroy = \"#kDestroy\";\n    var kConstruct = \"#kConstruct\";\n    function checkError(err, w, r) {\n      if (err) {\n        err.stack;\n        if (w && !w.errored) {\n          w.errored = err;\n        }\n        if (r && !r.errored) {\n          r.errored = err;\n        }\n      }\n    }\n    function destroy(err, cb) {\n      const r = this._readableState;\n      const w = this._writableState;\n      const s = w || r;\n      if ((w && w.destroyed) || (r && r.destroyed)) {\n        if (typeof cb === \"function\") {\n          cb();\n        }\n        return this;\n      }\n      checkError(err, w, r);\n      if (w) {\n        w.destroyed = true;\n      }\n      if (r) {\n        r.destroyed = true;\n      }\n      if (!s.constructed) {\n        this.once(kDestroy, er => {\n          _destroy(this, aggregateTwoErrors(er, err), cb);\n        });\n      } else {\n        _destroy(this, err, cb);\n      }\n      return this;\n    }\n    function _destroy(self, err, cb) {\n      let called = false;\n      function onDestroy(err2) {\n        if (called) {\n          return;\n        }\n        called = true;\n        const r = self._readableState;\n        const w = self._writableState;\n        checkError(err2, w, r);\n        if (w) {\n          w.closed = true;\n        }\n        if (r) {\n          r.closed = true;\n        }\n        if (typeof cb === \"function\") {\n          cb(err2);\n        }\n        if (err2) {\n          runOnNextTick(emitErrorCloseNT, self, err2);\n        } else {\n          runOnNextTick(emitCloseNT, self);\n        }\n      }\n      try {\n        self._destroy(err || null, onDestroy);\n      } catch (err2) {\n        onDestroy(err2);\n      }\n    }\n    function emitErrorCloseNT(self, err) {\n      emitErrorNT(self, err);\n      emitCloseNT(self);\n    }\n    function emitCloseNT(self) {\n      const r = self._readableState;\n      const w = self._writableState;\n      if (w) {\n        w.closeEmitted = true;\n      }\n      if (r) {\n        r.closeEmitted = true;\n      }\n      if ((w && w.emitClose) || (r && r.emitClose)) {\n        self.emit(\"close\");\n      }\n    }\n    function emitErrorNT(self, err) {\n      const r = self?._readableState;\n      const w = self?._writableState;\n      if (w?.errorEmitted || r?.errorEmitted) {\n        return;\n      }\n      if (w) {\n        w.errorEmitted = true;\n      }\n      if (r) {\n        r.errorEmitted = true;\n      }\n      self?.emit?.(\"error\", err);\n    }\n    function undestroy() {\n      const r = this._readableState;\n      const w = this._writableState;\n      if (r) {\n        r.constructed = true;\n        r.closed = false;\n        r.closeEmitted = false;\n        r.destroyed = false;\n        r.errored = null;\n        r.errorEmitted = false;\n        r.reading = false;\n        r.ended = r.readable === false;\n        r.endEmitted = r.readable === false;\n      }\n      if (w) {\n        w.constructed = true;\n        w.destroyed = false;\n        w.closed = false;\n        w.closeEmitted = false;\n        w.errored = null;\n        w.errorEmitted = false;\n        w.finalCalled = false;\n        w.prefinished = false;\n        w.ended = w.writable === false;\n        w.ending = w.writable === false;\n        w.finished = w.writable === false;\n      }\n    }\n    function errorOrDestroy(stream, err, sync) {\n      const r = stream?._readableState;\n      const w = stream?._writableState;\n      if ((w && w.destroyed) || (r && r.destroyed)) {\n        return this;\n      }\n      if ((r && r.autoDestroy) || (w && w.autoDestroy)) stream.destroy(err);\n      else if (err) {\n        Error.captureStackTrace(err);\n        if (w && !w.errored) {\n          w.errored = err;\n        }\n        if (r && !r.errored) {\n          r.errored = err;\n        }\n        if (sync) {\n          runOnNextTick(emitErrorNT, stream, err);\n        } else {\n          emitErrorNT(stream, err);\n        }\n      }\n    }\n    function construct(stream, cb) {\n      if (typeof stream._construct !== \"function\") {\n        return;\n      }\n      const r = stream._readableState;\n      const w = stream._writableState;\n      if (r) {\n        r.constructed = false;\n      }\n      if (w) {\n        w.constructed = false;\n      }\n      stream.once(kConstruct, cb);\n      if (stream.listenerCount(kConstruct) > 1) {\n        return;\n      }\n      runOnNextTick(constructNT, stream);\n    }\n    function constructNT(stream) {\n      let called = false;\n      function onConstruct(err) {\n        if (called) {\n          errorOrDestroy(stream, err !== null && err !== void 0 ? err : new ERR_MULTIPLE_CALLBACK());\n          return;\n        }\n        called = true;\n        const r = stream._readableState;\n        const w = stream._writableState;\n        const s = w || r;\n        if (r) {\n          r.constructed = true;\n        }\n        if (w) {\n          w.constructed = true;\n        }\n        if (s.destroyed) {\n          stream.emit(kDestroy, err);\n        } else if (err) {\n          errorOrDestroy(stream, err, true);\n        } else {\n          runOnNextTick(emitConstructNT, stream);\n        }\n      }\n      try {\n        stream._construct(onConstruct);\n      } catch (err) {\n        onConstruct(err);\n      }\n    }\n    function emitConstructNT(stream) {\n      stream.emit(kConstruct);\n    }\n    function isRequest(stream) {\n      return stream && stream.setHeader && typeof stream.abort === \"function\";\n    }\n    function emitCloseLegacy(stream) {\n      stream.emit(\"close\");\n    }\n    function emitErrorCloseLegacy(stream, err) {\n      stream.emit(\"error\", err);\n      runOnNextTick(emitCloseLegacy, stream);\n    }\n    function destroyer(stream, err) {\n      if (!stream || isDestroyed(stream)) {\n        return;\n      }\n      if (!err && !isFinished(stream)) {\n        err = new AbortError();\n      }\n      if (isServerRequest(stream)) {\n        stream.socket = null;\n        stream.destroy(err);\n      } else if (isRequest(stream)) {\n        stream.abort();\n      } else if (isRequest(stream.req)) {\n        stream.req.abort();\n      } else if (typeof stream.destroy === \"function\") {\n        stream.destroy(err);\n      } else if (typeof stream.close === \"function\") {\n        stream.close();\n      } else if (err) {\n        runOnNextTick(emitErrorCloseLegacy, stream);\n      } else {\n        runOnNextTick(emitCloseLegacy, stream);\n      }\n      if (!stream.destroyed) {\n        stream[kDestroyed] = true;\n      }\n    }\n    module.exports = {\n      construct,\n      destroyer,\n      destroy,\n      undestroy,\n      errorOrDestroy,\n    };\n  },\n});\n\n// node_modules/readable-stream/lib/internal/streams/legacy.js\nvar require_legacy = __commonJS({\n  \"node_modules/readable-stream/lib/internal/streams/legacy.js\"(exports, module) {\n    \"use strict\";\n    var { ArrayIsArray, ObjectSetPrototypeOf } = require_primordials();\n    var { EventEmitter: _EE } = __require(\"bun:events_native\");\n    var EE;\n    if (__TRACK_EE__) {\n      EE = DebugEventEmitter;\n    } else {\n      EE = _EE;\n    }\n\n    function Stream(options) {\n      if (!(this instanceof Stream)) return new Stream(options);\n      EE.call(this, options);\n    }\n    ObjectSetPrototypeOf(Stream.prototype, EE.prototype);\n    ObjectSetPrototypeOf(Stream, EE);\n\n    Stream.prototype.pipe = function (dest, options) {\n      const source = this;\n      function ondata(chunk) {\n        if (dest.writable && dest.write(chunk) === false && source.pause) {\n          source.pause();\n        }\n      }\n      source.on(\"data\", ondata);\n      function ondrain() {\n        if (source.readable && source.resume) {\n          source.resume();\n        }\n      }\n      dest.on(\"drain\", ondrain);\n      if (!dest._isStdio && (!options || options.end !== false)) {\n        source.on(\"end\", onend);\n        source.on(\"close\", onclose);\n      }\n      let didOnEnd = false;\n      function onend() {\n        if (didOnEnd) return;\n        didOnEnd = true;\n        dest.end();\n      }\n      function onclose() {\n        if (didOnEnd) return;\n        didOnEnd = true;\n        if (typeof dest.destroy === \"function\") dest.destroy();\n      }\n      function onerror(er) {\n        cleanup();\n        if (EE.listenerCount(this, \"error\") === 0) {\n          this.emit(\"error\", er);\n        }\n      }\n      prependListener(source, \"error\", onerror);\n      prependListener(dest, \"error\", onerror);\n      function cleanup() {\n        source.removeListener(\"data\", ondata);\n        dest.removeListener(\"drain\", ondrain);\n        source.removeListener(\"end\", onend);\n        source.removeListener(\"close\", onclose);\n        source.removeListener(\"error\", onerror);\n        dest.removeListener(\"error\", onerror);\n        source.removeListener(\"end\", cleanup);\n        source.removeListener(\"close\", cleanup);\n        dest.removeListener(\"close\", cleanup);\n      }\n      source.on(\"end\", cleanup);\n      source.on(\"close\", cleanup);\n      dest.on(\"close\", cleanup);\n      dest.emit(\"pipe\", source);\n      return dest;\n    };\n    function prependListener(emitter, event, fn) {\n      if (typeof emitter.prependListener === \"function\") return emitter.prependListener(event, fn);\n      if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);\n      else if (ArrayIsArray(emitter._events[event])) emitter._events[event].unshift(fn);\n      else emitter._events[event] = [fn, emitter._events[event]];\n    }\n    module.exports = {\n      Stream,\n      prependListener,\n    };\n  },\n});\n\n// node_modules/readable-stream/lib/internal/streams/add-abort-signal.js\nvar require_add_abort_signal = __commonJS({\n  \"node_modules/readable-stream/lib/internal/streams/add-abort-signal.js\"(exports, module) {\n    \"use strict\";\n    var { AbortError, codes } = require_errors();\n    var eos = require_end_of_stream();\n    var { ERR_INVALID_ARG_TYPE } = codes;\n    var validateAbortSignal = (signal, name) => {\n      if (typeof signal !== \"object\" || !(\"aborted\" in signal)) {\n        throw new ERR_INVALID_ARG_TYPE(name, \"AbortSignal\", signal);\n      }\n    };\n    function isNodeStream(obj) {\n      return !!(obj && typeof obj.pipe === \"function\");\n    }\n    module.exports.addAbortSignal = function addAbortSignal(signal, stream) {\n      validateAbortSignal(signal, \"signal\");\n      if (!isNodeStream(stream)) {\n        throw new ERR_INVALID_ARG_TYPE(\"stream\", \"stream.Stream\", stream);\n      }\n      return module.exports.addAbortSignalNoValidate(signal, stream);\n    };\n    module.exports.addAbortSignalNoValidate = function (signal, stream) {\n      if (typeof signal !== \"object\" || !(\"aborted\" in signal)) {\n        return stream;\n      }\n      const onAbort = () => {\n        stream.destroy(\n          new AbortError(void 0, {\n            cause: signal.reason,\n          }),\n        );\n      };\n      if (signal.aborted) {\n        onAbort();\n      } else {\n        signal.addEventListener(\"abort\", onAbort);\n        eos(stream, () => signal.removeEventListener(\"abort\", onAbort));\n      }\n      return stream;\n    };\n  },\n});\n\n// node_modules/readable-stream/lib/internal/streams/state.js\nvar require_state = __commonJS({\n  \"node_modules/readable-stream/lib/internal/streams/state.js\"(exports, module) {\n    \"use strict\";\n    var { MathFloor, NumberIsInteger } = require_primordials();\n    var { ERR_INVALID_ARG_VALUE } = require_errors().codes;\n    function highWaterMarkFrom(options, isDuplex, duplexKey) {\n      return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;\n    }\n    function getDefaultHighWaterMark(objectMode) {\n      return objectMode ? 16 : 16 * 1024;\n    }\n    function getHighWaterMark(state, options, duplexKey, isDuplex) {\n      const hwm = highWaterMarkFrom(options, isDuplex, duplexKey);\n      if (hwm != null) {\n        if (!NumberIsInteger(hwm) || hwm < 0) {\n          const name = isDuplex ? `options.${duplexKey}` : \"options.highWaterMark\";\n          throw new ERR_INVALID_ARG_VALUE(name, hwm);\n        }\n        return MathFloor(hwm);\n      }\n      return getDefaultHighWaterMark(state.objectMode);\n    }\n    module.exports = {\n      getHighWaterMark,\n      getDefaultHighWaterMark,\n    };\n  },\n});\n\n// node_modules/readable-stream/lib/internal/streams/from.js\nvar require_from = __commonJS({\n  \"node_modules/readable-stream/lib/internal/streams/from.js\"(exports, module) {\n    \"use strict\";\n    var { PromisePrototypeThen, SymbolAsyncIterator, SymbolIterator } = require_primordials();\n    var { ERR_INVALID_ARG_TYPE, ERR_STREAM_NULL_VALUES } = require_errors().codes;\n    function from(Readable, iterable, opts) {\n      let iterator;\n      if (typeof iterable === \"string\" || iterable instanceof Buffer) {\n        return new Readable({\n          objectMode: true,\n          ...opts,\n          read() {\n            this.push(iterable);\n            this.push(null);\n          },\n        });\n      }\n      let isAsync;\n      if (iterable && iterable[SymbolAsyncIterator]) {\n        isAsync = true;\n        iterator = iterable[SymbolAsyncIterator]();\n      } else if (iterable && iterable[SymbolIterator]) {\n        isAsync = false;\n        iterator = iterable[SymbolIterator]();\n      } else {\n        throw new ERR_INVALID_ARG_TYPE(\"iterable\", [\"Iterable\"], iterable);\n      }\n      const readable = new Readable({\n        objectMode: true,\n        highWaterMark: 1,\n        ...opts,\n      });\n      let reading = false;\n      readable._read = function () {\n        if (!reading) {\n          reading = true;\n          next();\n        }\n      };\n      readable._destroy = function (error, cb) {\n        PromisePrototypeThen(\n          close(error),\n          () => runOnNextTick(cb, error),\n          e => runOnNextTick(cb, e || error),\n        );\n      };\n      async function close(error) {\n        const hadError = error !== void 0 && error !== null;\n        const hasThrow = typeof iterator.throw === \"function\";\n        if (hadError && hasThrow) {\n          const { value, done } = await iterator.throw(error);\n          await value;\n          if (done) {\n            return;\n          }\n        }\n        if (typeof iterator.return === \"function\") {\n          const { value } = await iterator.return();\n          await value;\n        }\n      }\n      async function next() {\n        for (;;) {\n          try {\n            const { value, done } = isAsync ? await iterator.next() : iterator.next();\n            if (done) {\n              readable.push(null);\n            } else {\n              const res = value && typeof value.then === \"function\" ? await value : value;\n              if (res === null) {\n                reading = false;\n                throw new ERR_STREAM_NULL_VALUES();\n              } else if (readable.push(res)) {\n                continue;\n              } else {\n                reading = false;\n              }\n            }\n          } catch (err) {\n            readable.destroy(err);\n          }\n          break;\n        }\n      }\n      return readable;\n    }\n    module.exports = from;\n  },\n});\n\nvar _ReadableFromWeb;\n\n// node_modules/readable-stream/lib/internal/streams/readable.js\nvar require_readable = __commonJS({\n  \"node_modules/readable-stream/lib/internal/streams/readable.js\"(exports, module) {\n    \"use strict\";\n    var {\n      ArrayPrototypeIndexOf,\n      NumberIsInteger,\n      NumberIsNaN,\n      NumberParseInt,\n      ObjectDefineProperties,\n      ObjectKeys,\n      ObjectSetPrototypeOf,\n      Promise: Promise2,\n      SafeSet,\n      SymbolAsyncIterator,\n      Symbol: Symbol2,\n    } = require_primordials();\n\n    var ReadableState = globalThis[Symbol.for(\"Bun.lazy\")](\"bun:stream\").ReadableState;\n    var { EventEmitter: EE } = __require(\"bun:events_native\");\n    var { Stream, prependListener } = require_legacy();\n\n    function Readable(options) {\n      if (!(this instanceof Readable)) return new Readable(options);\n      const isDuplex = this instanceof require_duplex();\n      this._readableState = new ReadableState(options, this, isDuplex);\n      if (options) {\n        const { read, destroy, construct, signal } = options;\n        if (typeof read === \"function\") this._read = read;\n        if (typeof destroy === \"function\") this._destroy = destroy;\n        if (typeof construct === \"function\") this._construct = construct;\n        if (signal && !isDuplex) addAbortSignal(signal, this);\n      }\n      Stream.call(this, options);\n\n      destroyImpl.construct(this, () => {\n        if (this._readableState.needReadable) {\n          maybeReadMore(this, this._readableState);\n        }\n      });\n    }\n    ObjectSetPrototypeOf(Readable.prototype, Stream.prototype);\n    ObjectSetPrototypeOf(Readable, Stream);\n\n    Readable.prototype.on = function (ev, fn) {\n      const res = Stream.prototype.on.call(this, ev, fn);\n      const state = this._readableState;\n      if (ev === \"data\") {\n        state.readableListening = this.listenerCount(\"readable\") > 0;\n        if (state.flowing !== false) {\n          __DEBUG__ && debug(\"in flowing mode!\", this.__id);\n          this.resume();\n        } else {\n          __DEBUG__ && debug(\"in readable mode!\", this.__id);\n        }\n      } else if (ev === \"readable\") {\n        __DEBUG__ && debug(\"readable listener added!\", this.__id);\n        if (!state.endEmitted && !state.readableListening) {\n          state.readableListening = state.needReadable = true;\n          state.flowing = false;\n          state.emittedReadable = false;\n          __DEBUG__ &&\n            debug(\n              \"on readable - state.length, reading, emittedReadable\",\n              state.length,\n              state.reading,\n              state.emittedReadable,\n              this.__id,\n            );\n          if (state.length) {\n            emitReadable(this, state);\n          } else if (!state.reading) {\n            runOnNextTick(nReadingNextTick, this);\n          }\n        } else if (state.endEmitted) {\n          __DEBUG__ && debug(\"end already emitted...\", this.__id);\n        }\n      }\n      return res;\n    };\n\n    class ReadableFromWeb extends Readable {\n      #reader;\n      #closed;\n      #pendingChunks;\n      #stream;\n\n      constructor(options, stream) {\n        const { objectMode, highWaterMark, encoding, signal } = options;\n        super({\n          objectMode,\n          highWaterMark,\n          encoding,\n          signal,\n        });\n        this.#pendingChunks = [];\n        this.#reader = undefined;\n        this.#stream = stream;\n        this.#closed = false;\n      }\n\n      #drainPending() {\n        var pendingChunks = this.#pendingChunks,\n          pendingChunksI = 0,\n          pendingChunksCount = pendingChunks.length;\n\n        for (; pendingChunksI < pendingChunksCount; pendingChunksI++) {\n          const chunk = pendingChunks[pendingChunksI];\n          pendingChunks[pendingChunksI] = undefined;\n          if (!this.push(chunk, undefined)) {\n            this.#pendingChunks = pendingChunks.slice(pendingChunksI + 1);\n            return true;\n          }\n        }\n\n        if (pendingChunksCount > 0) {\n          this.#pendingChunks = [];\n        }\n\n        return false;\n      }\n\n      #handleDone(reader) {\n        reader.releaseLock();\n        this.#reader = undefined;\n        this.#closed = true;\n        this.push(null);\n        return;\n      }\n\n      async _read() {\n        __DEBUG__ && debug(\"ReadableFromWeb _read()\", this.__id);\n        var stream = this.#stream,\n          reader = this.#reader;\n        if (stream) {\n          reader = this.#reader = stream.getReader();\n          this.#stream = undefined;\n        } else if (this.#drainPending()) {\n          return;\n        }\n\n        var deferredError;\n        try {\n          do {\n            var done = false,\n              value;\n            const firstResult = reader.readMany();\n\n            if (isPromise(firstResult)) {\n              ({ done, value } = await firstResult);\n\n              if (this.#closed) {\n                this.#pendingChunks.push(...value);\n                return;\n              }\n            } else {\n              ({ done, value } = firstResult);\n            }\n\n            if (done) {\n              this.#handleDone(reader);\n              return;\n            }\n\n            if (!this.push(value[0])) {\n              this.#pendingChunks = value.slice(1);\n              return;\n            }\n\n            for (let i = 1, count = value.length; i < count; i++) {\n              if (!this.push(value[i])) {\n                this.#pendingChunks = value.slice(i + 1);\n                return;\n              }\n            }\n          } while (!this.#closed);\n        } catch (e) {\n          deferredError = e;\n        } finally {\n          if (deferredError) throw deferredError;\n        }\n      }\n\n      _destroy(error, callback) {\n        if (!this.#closed) {\n          var reader = this.#reader;\n          if (reader) {\n            this.#reader = undefined;\n            reader.cancel(error).finally(() => {\n              this.#closed = true;\n              callback(error);\n            });\n          }\n\n          return;\n        }\n        try {\n          callback(error);\n        } catch (error) {\n          globalThis.reportError(error);\n        }\n      }\n    }\n\n    /**\n     * @param {ReadableStream} readableStream\n     * @param {{\n     *   highWaterMark? : number,\n     *   encoding? : string,\n     *   objectMode? : boolean,\n     *   signal? : AbortSignal,\n     * }} [options]\n     * @returns {Readable}\n     */\n    function newStreamReadableFromReadableStream(readableStream, options = {}) {\n      if (!isReadableStream(readableStream)) {\n        throw new ERR_INVALID_ARG_TYPE(\"readableStream\", \"ReadableStream\", readableStream);\n      }\n\n      validateObject(options, \"options\");\n      const {\n        highWaterMark,\n        encoding,\n        objectMode = false,\n        signal,\n        // native = true,\n      } = options;\n\n      if (encoding !== undefined && !Buffer.isEncoding(encoding))\n        throw new ERR_INVALID_ARG_VALUE(encoding, \"options.encoding\");\n      validateBoolean(objectMode, \"options.objectMode\");\n\n      // validateBoolean(native, \"options.native\");\n\n      // if (!native) {\n      //   return new ReadableFromWeb(\n      //     {\n      //       highWaterMark,\n      //       encoding,\n      //       objectMode,\n      //       signal,\n      //     },\n      //     readableStream,\n      //   );\n      // }\n\n      const nativeStream = getNativeReadableStream(Readable, readableStream, options);\n\n      return (\n        nativeStream ||\n        new ReadableFromWeb(\n          {\n            highWaterMark,\n            encoding,\n            objectMode,\n            signal,\n          },\n          readableStream,\n        )\n      );\n    }\n\n    module.exports = Readable;\n    _ReadableFromWeb = ReadableFromWeb;\n\n    var { addAbortSignal } = require_add_abort_signal();\n    var eos = require_end_of_stream();\n    const {\n      maybeReadMore: _maybeReadMore,\n      resume,\n      emitReadable: _emitReadable,\n      onEofChunk,\n    } = globalThis[Symbol.for(\"Bun.lazy\")](\"bun:stream\");\n    function maybeReadMore(stream, state) {\n      process.nextTick(_maybeReadMore, stream, state);\n    }\n    // REVERT ME\n    function emitReadable(stream, state) {\n      __DEBUG__ && debug(\"NativeReadable - emitReadable\", stream.__id);\n      _emitReadable(stream, state);\n    }\n    var destroyImpl = require_destroy();\n    var {\n      aggregateTwoErrors,\n      codes: {\n        ERR_INVALID_ARG_TYPE,\n        ERR_METHOD_NOT_IMPLEMENTED,\n        ERR_OUT_OF_RANGE,\n        ERR_STREAM_PUSH_AFTER_EOF,\n        ERR_STREAM_UNSHIFT_AFTER_END_EVENT,\n      },\n    } = require_errors();\n    var { validateObject } = require_validators();\n    var { StringDecoder } = __require(\"string_decoder\");\n    var from = require_from();\n    var nop = () => {};\n    var { errorOrDestroy } = destroyImpl;\n\n    Readable.prototype.destroy = destroyImpl.destroy;\n    Readable.prototype._undestroy = destroyImpl.undestroy;\n    Readable.prototype._destroy = function (err, cb) {\n      cb(err);\n    };\n    Readable.prototype[EE.captureRejectionSymbol] = function (err) {\n      this.destroy(err);\n    };\n    Readable.prototype.push = function (chunk, encoding) {\n      return readableAddChunk(this, chunk, encoding, false);\n    };\n    Readable.prototype.unshift = function (chunk, encoding) {\n      return readableAddChunk(this, chunk, encoding, true);\n    };\n    function readableAddChunk(stream, chunk, encoding, addToFront) {\n      __DEBUG__ && debug(\"readableAddChunk\", chunk, stream.__id);\n      const state = stream._readableState;\n      let err;\n      if (!state.objectMode) {\n        if (typeof chunk === \"string\") {\n          encoding = encoding || state.defaultEncoding;\n          if (state.encoding !== encoding) {\n            if (addToFront && state.encoding) {\n              chunk = Buffer.from(chunk, encoding).toString(state.encoding);\n            } else {\n              chunk = Buffer.from(chunk, encoding);\n              encoding = \"\";\n            }\n          }\n        } else if (chunk instanceof Buffer) {\n          encoding = \"\";\n        } else if (Stream._isUint8Array(chunk)) {\n          if (addToFront || !state.decoder) {\n            chunk = Stream._uint8ArrayToBuffer(chunk);\n          }\n          encoding = \"\";\n        } else if (chunk != null) {\n          err = new ERR_INVALID_ARG_TYPE(\"chunk\", [\"string\", \"Buffer\", \"Uint8Array\"], chunk);\n        }\n      }\n      if (err) {\n        errorOrDestroy(stream, err);\n      } else if (chunk === null) {\n        state.reading = false;\n        onEofChunk(stream, state);\n      } else if (state.objectMode || (chunk && chunk.length > 0)) {\n        if (addToFront) {\n          if (state.endEmitted) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());\n          else if (state.destroyed || state.errored) return false;\n          else addChunk(stream, state, chunk, true);\n        } else if (state.ended) {\n          errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());\n        } else if (state.destroyed || state.errored) {\n          return false;\n        } else {\n          state.reading = false;\n          if (state.decoder && !encoding) {\n            chunk = state.decoder.write(chunk);\n            if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);\n            else maybeReadMore(stream, state);\n          } else {\n            addChunk(stream, state, chunk, false);\n          }\n        }\n      } else if (!addToFront) {\n        state.reading = false;\n        maybeReadMore(stream, state);\n      }\n      return !state.ended && (state.length < state.highWaterMark || state.length === 0);\n    }\n    function addChunk(stream, state, chunk, addToFront) {\n      __DEBUG__ && debug(\"adding chunk\", stream.__id);\n      __DEBUG__ && debug(\"chunk\", chunk.toString(), stream.__id);\n      if (state.flowing && state.length === 0 && !state.sync && stream.listenerCount(\"data\") > 0) {\n        if (state.multiAwaitDrain) {\n          state.awaitDrainWriters.clear();\n        } else {\n          state.awaitDrainWriters = null;\n        }\n        state.dataEmitted = true;\n        stream.emit(\"data\", chunk);\n      } else {\n        state.length += state.objectMode ? 1 : chunk.length;\n        if (addToFront) state.buffer.unshift(chunk);\n        else state.buffer.push(chunk);\n        __DEBUG__ && debug(\"needReadable @ addChunk\", state.needReadable, stream.__id);\n        if (state.needReadable) emitReadable(stream, state);\n      }\n      maybeReadMore(stream, state);\n    }\n    Readable.prototype.isPaused = function () {\n      const state = this._readableState;\n      return state.paused === true || state.flowing === false;\n    };\n    Readable.prototype.setEncoding = function (enc) {\n      const decoder = new StringDecoder(enc);\n      this._readableState.decoder = decoder;\n      this._readableState.encoding = this._readableState.decoder.encoding;\n      const buffer = this._readableState.buffer;\n      let content = \"\";\n      // BufferList does not support iterator now, and iterator is slow in JSC.\n      // for (const data of buffer) {\n      //   content += decoder.write(data);\n      // }\n      // buffer.clear();\n      for (let i = buffer.length; i > 0; i--) {\n        content += decoder.write(buffer.shift());\n      }\n      if (content !== \"\") buffer.push(content);\n      this._readableState.length = content.length;\n      return this;\n    };\n    var MAX_HWM = 1073741824;\n    function computeNewHighWaterMark(n) {\n      if (n > MAX_HWM) {\n        throw new ERR_OUT_OF_RANGE(\"size\", \"<= 1GiB\", n);\n      } else {\n        n--;\n        n |= n >>> 1;\n        n |= n >>> 2;\n        n |= n >>> 4;\n        n |= n >>> 8;\n        n |= n >>> 16;\n        n++;\n      }\n      return n;\n    }\n    function howMuchToRead(n, state) {\n      if (n <= 0 || (state.length === 0 && state.ended)) return 0;\n      if (state.objectMode) return 1;\n      if (NumberIsNaN(n)) {\n        if (state.flowing && state.length) return state.buffer.first().length;\n        return state.length;\n      }\n      if (n <= state.length) return n;\n      return state.ended ? state.length : 0;\n    }\n    // You can override either this method, or the async _read(n) below.\n    Readable.prototype.read = function (n) {\n      __DEBUG__ && debug(\"read - n =\", n, this.__id);\n      if (!NumberIsInteger(n)) {\n        n = NumberParseInt(n, 10);\n      }\n      const state = this._readableState;\n      const nOrig = n;\n\n      // If we're asking for more than the current hwm, then raise the hwm.\n      if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);\n\n      if (n !== 0) state.emittedReadable = false;\n\n      // If we're doing read(0) to trigger a readable event, but we\n      // already have a bunch of data in the buffer, then just trigger\n      // the 'readable' event and move on.\n      if (\n        n === 0 &&\n        state.needReadable &&\n        ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)\n      ) {\n        __DEBUG__ && debug(\"read: emitReadable or endReadable\", state.length, state.ended, this.__id);\n        if (state.length === 0 && state.ended) endReadable(this);\n        else emitReadable(this, state);\n        return null;\n      }\n\n      n = howMuchToRead(n, state);\n\n      // If we've ended, and we're now clear, then finish it up.\n      if (n === 0 && state.ended) {\n        __DEBUG__ &&\n          debug(\"read: calling endReadable if length 0 -- length, state.ended\", state.length, state.ended, this.__id);\n        if (state.length === 0) endReadable(this);\n        return null;\n      }\n\n      // All the actual chunk generation logic needs to be\n      // *below* the call to _read.  The reason is that in certain\n      // synthetic stream cases, such as passthrough streams, _read\n      // may be a completely synchronous operation which may change\n      // the state of the read buffer, providing enough data when\n      // before there was *not* enough.\n      //\n      // So, the steps are:\n      // 1. Figure out what the state of things will be after we do\n      // a read from the buffer.\n      //\n      // 2. If that resulting state will trigger a _read, then call _read.\n      // Note that this may be asynchronous, or synchronous.  Yes, it is\n      // deeply ugly to write APIs this way, but that still doesn't mean\n      // that the Readable class should behave improperly, as streams are\n      // designed to be sync/async agnostic.\n      // Take note if the _read call is sync or async (ie, if the read call\n      // has returned yet), so that we know whether or not it's safe to emit\n      // 'readable' etc.\n      //\n      // 3. Actually pull the requested chunks out of the buffer and return.\n\n      // if we need a readable event, then we need to do some reading.\n      let doRead = state.needReadable;\n      __DEBUG__ && debug(\"need readable\", doRead, this.__id);\n\n      // If we currently have less than the highWaterMark, then also read some.\n      if (state.length === 0 || state.length - n < state.highWaterMark) {\n        doRead = true;\n        __DEBUG__ && debug(\"length less than watermark\", doRead, this.__id);\n      }\n\n      // However, if we've ended, then there's no point, if we're already\n      // reading, then it's unnecessary, if we're constructing we have to wait,\n      // and if we're destroyed or errored, then it's not allowed,\n      if (state.ended || state.reading || state.destroyed || state.errored || !state.constructed) {\n        __DEBUG__ && debug(\"state.constructed?\", state.constructed, this.__id);\n        doRead = false;\n        __DEBUG__ && debug(\"reading, ended or constructing\", doRead, this.__id);\n      } else if (doRead) {\n        __DEBUG__ && debug(\"do read\", this.__id);\n        state.reading = true;\n        state.sync = true;\n        // If the length is currently zero, then we *need* a readable event.\n        if (state.length === 0) state.needReadable = true;\n\n        // Call internal read method\n        try {\n          var result = this._read(state.highWaterMark);\n          if (isPromise(result)) {\n            __DEBUG__ && debug(\"async _read\", this.__id);\n            const peeked = Bun.peek(result);\n            __DEBUG__ && debug(\"peeked promise\", peeked, this.__id);\n            if (peeked !== result) {\n              result = peeked;\n            }\n          }\n\n          if (isPromise(result) && result?.then && isCallable(result.then)) {\n            __DEBUG__ && debug(\"async _read result.then setup\", this.__id);\n            result.then(nop, function (err) {\n              errorOrDestroy(this, err);\n            });\n          }\n        } catch (err) {\n          errorOrDestroy(this, err);\n        }\n\n        state.sync = false;\n        // If _read pushed data synchronously, then `reading` will be false,\n        // and we need to re-evaluate how much data we can return to the user.\n        if (!state.reading) n = howMuchToRead(nOrig, state);\n      }\n\n      __DEBUG__ && debug(\"n @ fromList\", n, this.__id);\n      let ret;\n      if (n > 0) ret = fromList(n, state);\n      else ret = null;\n\n      __DEBUG__ && debug(\"ret @ read\", ret, this.__id);\n\n      if (ret === null) {\n        state.needReadable = state.length <= state.highWaterMark;\n        __DEBUG__ && debug(\"state.length while ret = null\", state.length, this.__id);\n        n = 0;\n      } else {\n        state.length -= n;\n        if (state.multiAwaitDrain) {\n          state.awaitDrainWriters.clear();\n        } else {\n          state.awaitDrainWriters = null;\n        }\n      }\n\n      if (state.length === 0) {\n        // If we have nothing in the buffer, then we want to know\n        // as soon as we *do* get something into the buffer.\n        if (!state.ended) state.needReadable = true;\n\n        // If we tried to read() past the EOF, then emit end on the next tick.\n        if (nOrig !== n && state.ended) endReadable(this);\n      }\n\n      if (ret !== null && !state.errorEmitted && !state.closeEmitted) {\n        state.dataEmitted = true;\n        this.emit(\"data\", ret);\n      }\n\n      return ret;\n    };\n    Readable.prototype._read = function (n) {\n      throw new ERR_METHOD_NOT_IMPLEMENTED(\"_read()\");\n    };\n    Readable.prototype.pipe = function (dest, pipeOpts) {\n      const src = this;\n      const state = this._readableState;\n      if (state.pipes.length === 1) {\n        if (!state.multiAwaitDrain) {\n          state.multiAwaitDrain = true;\n          state.awaitDrainWriters = new SafeSet(state.awaitDrainWriters ? [state.awaitDrainWriters] : []);\n        }\n      }\n      state.pipes.push(dest);\n      __DEBUG__ && debug(\"pipe count=%d opts=%j\", state.pipes.length, pipeOpts, src.__id);\n      const doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;\n      const endFn = doEnd ? onend : unpipe;\n      if (state.endEmitted) runOnNextTick(endFn);\n      else src.once(\"end\", endFn);\n      dest.on(\"unpipe\", onunpipe);\n      function onunpipe(readable, unpipeInfo) {\n        __DEBUG__ && debug(\"onunpipe\", src.__id);\n        if (readable === src) {\n          if (unpipeInfo && unpipeInfo.hasUnpiped === false) {\n            unpipeInfo.hasUnpiped = true;\n            cleanup();\n          }\n        }\n      }\n      function onend() {\n        __DEBUG__ && debug(\"onend\", src.__id);\n        dest.end();\n      }\n      let ondrain;\n      let cleanedUp = false;\n      function cleanup() {\n        __DEBUG__ && debug(\"cleanup\", src.__id);\n        dest.removeListener(\"close\", onclose);\n        dest.removeListener(\"finish\", onfinish);\n        if (ondrain) {\n          dest.removeListener(\"drain\", ondrain);\n        }\n        dest.removeListener(\"error\", onerror);\n        dest.removeListener(\"unpipe\", onunpipe);\n        src.removeListener(\"end\", onend);\n        src.removeListener(\"end\", unpipe);\n        src.removeListener(\"data\", ondata);\n        cleanedUp = true;\n        if (ondrain && state.awaitDrainWriters && (!dest._writableState || dest._writableState.needDrain)) ondrain();\n      }\n      function pause() {\n        if (!cleanedUp) {\n          if (state.pipes.length === 1 && state.pipes[0] === dest) {\n            __DEBUG__ && debug(\"false write response, pause\", 0, src.__id);\n            state.awaitDrainWriters = dest;\n            state.multiAwaitDrain = false;\n          } else if (state.pipes.length > 1 && state.pipes.includes(dest)) {\n            __DEBUG__ && debug(\"false write response, pause\", state.awaitDrainWriters.size, src.__id);\n            state.awaitDrainWriters.add(dest);\n          }\n          src.pause();\n        }\n        if (!ondrain) {\n          ondrain = pipeOnDrain(src, dest);\n          dest.on(\"drain\", ondrain);\n        }\n      }\n      src.on(\"data\", ondata);\n      function ondata(chunk) {\n        __DEBUG__ && debug(\"ondata\", src.__id);\n        const ret = dest.write(chunk);\n        __DEBUG__ && debug(\"dest.write\", ret, src.__id);\n        if (ret === false) {\n          pause();\n        }\n      }\n      function onerror(er) {\n        debug(\"onerror\", er);\n        unpipe();\n        dest.removeListener(\"error\", onerror);\n        if (dest.listenerCount(\"error\") === 0) {\n          const s = dest._writableState || dest._readableState;\n          if (s && !s.errorEmitted) {\n            errorOrDestroy(dest, er);\n          } else {\n            dest.emit(\"error\", er);\n          }\n        }\n      }\n      prependListener(dest, \"error\", onerror);\n      function onclose() {\n        dest.removeListener(\"finish\", onfinish);\n        unpipe();\n      }\n      dest.once(\"close\", onclose);\n      function onfinish() {\n        debug(\"onfinish\");\n        dest.removeListener(\"close\", onclose);\n        unpipe();\n      }\n      dest.once(\"finish\", onfinish);\n      function unpipe() {\n        debug(\"unpipe\");\n        src.unpipe(dest);\n      }\n      dest.emit(\"pipe\", src);\n      if (dest.writableNeedDrain === true) {\n        if (state.flowing) {\n          pause();\n        }\n      } else if (!state.flowing) {\n        debug(\"pipe resume\");\n        src.resume();\n      }\n      return dest;\n    };\n    function pipeOnDrain(src, dest) {\n      return function pipeOnDrainFunctionResult() {\n        const state = src._readableState;\n        if (state.awaitDrainWriters === dest) {\n          debug(\"pipeOnDrain\", 1);\n          state.awaitDrainWriters = null;\n        } else if (state.multiAwaitDrain) {\n          debug(\"pipeOnDrain\", state.awaitDrainWriters.size);\n          state.awaitDrainWriters.delete(dest);\n        }\n        if ((!state.awaitDrainWriters || state.awaitDrainWriters.size === 0) && src.listenerCount(\"data\")) {\n          src.resume();\n        }\n      };\n    }\n    Readable.prototype.unpipe = function (dest) {\n      const state = this._readableState;\n      const unpipeInfo = {\n        hasUnpiped: false,\n      };\n      if (state.pipes.length === 0) return this;\n      if (!dest) {\n        const dests = state.pipes;\n        state.pipes = [];\n        this.pause();\n        for (let i = 0; i < dests.length; i++)\n          dests[i].emit(\"unpipe\", this, {\n            hasUnpiped: false,\n          });\n        return this;\n      }\n      const index = ArrayPrototypeIndexOf(state.pipes, dest);\n      if (index === -1) return this;\n      state.pipes.splice(index, 1);\n      if (state.pipes.length === 0) this.pause();\n      dest.emit(\"unpipe\", this, unpipeInfo);\n      return this;\n    };\n    Readable.prototype.addListener = Readable.prototype.on;\n    Readable.prototype.removeListener = function (ev, fn) {\n      const res = Stream.prototype.removeListener.call(this, ev, fn);\n      if (ev === \"readable\") {\n        runOnNextTick(updateReadableListening, this);\n      }\n      return res;\n    };\n    Readable.prototype.off = Readable.prototype.removeListener;\n    Readable.prototype.removeAllListeners = function (ev) {\n      const res = Stream.prototype.removeAllListeners.apply(this, arguments);\n      if (ev === \"readable\" || ev === void 0) {\n        runOnNextTick(updateReadableListening, this);\n      }\n      return res;\n    };\n    function updateReadableListening(self) {\n      const state = self._readableState;\n      state.readableListening = self.listenerCount(\"readable\") > 0;\n      if (state.resumeScheduled && state.paused === false) {\n        state.flowing = true;\n      } else if (self.listenerCount(\"data\") > 0) {\n        self.resume();\n      } else if (!state.readableListening) {\n        state.flowing = null;\n      }\n    }\n    function nReadingNextTick(self) {\n      __DEBUG__ && debug(\"on readable nextTick, calling read(0)\", self.__id);\n      self.read(0);\n    }\n    Readable.prototype.resume = function () {\n      const state = this._readableState;\n      if (!state.flowing) {\n        __DEBUG__ && debug(\"resume\", this.__id);\n        state.flowing = !state.readableListening;\n        resume(this, state);\n      }\n      state.paused = false;\n      return this;\n    };\n    Readable.prototype.pause = function () {\n      __DEBUG__ && debug(\"call pause flowing=%j\", this._readableState.flowing, this.__id);\n      if (this._readableState.flowing !== false) {\n        __DEBUG__ && debug(\"pause\", this.__id);\n        this._readableState.flowing = false;\n        this.emit(\"pause\");\n      }\n      this._readableState.paused = true;\n      return this;\n    };\n    Readable.prototype.wrap = function (stream) {\n      let paused = false;\n      stream.on(\"data\", chunk => {\n        if (!this.push(chunk) && stream.pause) {\n          paused = true;\n          stream.pause();\n        }\n      });\n      stream.on(\"end\", () => {\n        this.push(null);\n      });\n      stream.on(\"error\", err => {\n        errorOrDestroy(this, err);\n      });\n      stream.on(\"close\", () => {\n        this.destroy();\n      });\n      stream.on(\"destroy\", () => {\n        this.destroy();\n      });\n      this._read = () => {\n        if (paused && stream.resume) {\n          paused = false;\n          stream.resume();\n        }\n      };\n      const streamKeys = ObjectKeys(stream);\n      for (let j = 1; j < streamKeys.length; j++) {\n        const i = streamKeys[j];\n        if (this[i] === void 0 && typeof stream[i] === \"function\") {\n          this[i] = stream[i].bind(stream);\n        }\n      }\n      return this;\n    };\n    Readable.prototype[SymbolAsyncIterator] = function () {\n      return streamToAsyncIterator(this);\n    };\n    Readable.prototype.iterator = function (options) {\n      if (options !== void 0) {\n        validateObject(options, \"options\");\n      }\n      return streamToAsyncIterator(this, options);\n    };\n    function streamToAsyncIterator(stream, options) {\n      if (typeof stream.read !== \"function\") {\n        stream = Readable.wrap(stream, {\n          objectMode: true,\n        });\n      }\n      const iter = createAsyncIterator(stream, options);\n      iter.stream = stream;\n      return iter;\n    }\n    async function* createAsyncIterator(stream, options) {\n      let callback = nop;\n      function next(resolve) {\n        if (this === stream) {\n          callback();\n          callback = nop;\n        } else {\n          callback = resolve;\n        }\n      }\n      stream.on(\"readable\", next);\n      let error;\n      const cleanup = eos(\n        stream,\n        {\n          writable: false,\n        },\n        err => {\n          error = err ? aggregateTwoErrors(error, err) : null;\n          callback();\n          callback = nop;\n        },\n      );\n      try {\n        while (true) {\n          const chunk = stream.destroyed ? null : stream.read();\n          if (chunk !== null) {\n            yield chunk;\n          } else if (error) {\n            throw error;\n          } else if (error === null) {\n            return;\n          } else {\n            await new Promise2(next);\n          }\n        }\n      } catch (err) {\n        error = aggregateTwoErrors(error, err);\n        throw error;\n      } finally {\n        if (\n          (error || (options === null || options === void 0 ? void 0 : options.destroyOnReturn) !== false) &&\n          (error === void 0 || stream._readableState.autoDestroy)\n        ) {\n          destroyImpl.destroyer(stream, null);\n        } else {\n          stream.off(\"readable\", next);\n          cleanup();\n        }\n      }\n    }\n    ObjectDefineProperties(Readable.prototype, {\n      readable: {\n        get() {\n          const r = this._readableState;\n          return !!r && r.readable !== false && !r.destroyed && !r.errorEmitted && !r.endEmitted;\n        },\n        set(val) {\n          if (this._readableState) {\n            this._readableState.readable = !!val;\n          }\n        },\n      },\n      readableDidRead: {\n        enumerable: false,\n        get: function () {\n          return this._readableState.dataEmitted;\n        },\n      },\n      readableAborted: {\n        enumerable: false,\n        get: function () {\n          return !!(\n            this._readableState.readable !== false &&\n            (this._readableState.destroyed || this._readableState.errored) &&\n            !this._readableState.endEmitted\n          );\n        },\n      },\n      readableHighWaterMark: {\n        enumerable: false,\n        get: function () {\n          return this._readableState.highWaterMark;\n        },\n      },\n      readableBuffer: {\n        enumerable: false,\n        get: function () {\n          return this._readableState && this._readableState.buffer;\n        },\n      },\n      readableFlowing: {\n        enumerable: false,\n        get: function () {\n          return this._readableState.flowing;\n        },\n        set: function (state) {\n          if (this._readableState) {\n            this._readableState.flowing = state;\n          }\n        },\n      },\n      readableLength: {\n        enumerable: false,\n        get() {\n          return this._readableState.length;\n        },\n      },\n      readableObjectMode: {\n        enumerable: false,\n        get() {\n          return this._readableState ? this._readableState.objectMode : false;\n        },\n      },\n      readableEncoding: {\n        enumerable: false,\n        get() {\n          return this._readableState ? this._readableState.encoding : null;\n        },\n      },\n      errored: {\n        enumerable: false,\n        get() {\n          return this._readableState ? this._readableState.errored : null;\n        },\n      },\n      closed: {\n        get() {\n          return this._readableState ? this._readableState.closed : false;\n        },\n      },\n      destroyed: {\n        enumerable: false,\n        get() {\n          return this._readableState ? this._readableState.destroyed : false;\n        },\n        set(value) {\n          if (!this._readableState) {\n            return;\n          }\n          this._readableState.destroyed = value;\n        },\n      },\n      readableEnded: {\n        enumerable: false,\n        get() {\n          return this._readableState ? this._readableState.endEmitted : false;\n        },\n      },\n    });\n    Readable._fromList = fromList;\n    function fromList(n, state) {\n      if (state.length === 0) return null;\n      let ret;\n      if (state.objectMode) ret = state.buffer.shift();\n      else if (!n || n >= state.length) {\n        if (state.decoder) ret = state.buffer.join(\"\");\n        else if (state.buffer.length === 1) ret = state.buffer.first();\n        else ret = state.buffer.concat(state.length);\n        state.buffer.clear();\n      } else {\n        ret = state.buffer.consume(n, state.decoder);\n      }\n      return ret;\n    }\n    function endReadable(stream) {\n      const state = stream._readableState;\n      __DEBUG__ && debug(\"endEmitted @ endReadable\", state.endEmitted, stream.__id);\n      if (!state.endEmitted) {\n        state.ended = true;\n        runOnNextTick(endReadableNT, state, stream);\n      }\n    }\n    function endReadableNT(state, stream) {\n      __DEBUG__ && debug(\"endReadableNT -- endEmitted, state.length\", state.endEmitted, state.length, stream.__id);\n      if (!state.errored && !state.closeEmitted && !state.endEmitted && state.length === 0) {\n        state.endEmitted = true;\n        stream.emit(\"end\");\n        __DEBUG__ && debug(\"end emitted @ endReadableNT\", stream.__id);\n        if (stream.writable && stream.allowHalfOpen === false) {\n          runOnNextTick(endWritableNT, stream);\n        } else if (state.autoDestroy) {\n          const wState = stream._writableState;\n          const autoDestroy = !wState || (wState.autoDestroy && (wState.finished || wState.writable === false));\n          if (autoDestroy) {\n            stream.destroy();\n          }\n        }\n      }\n    }\n    function endWritableNT(stream) {\n      const writable = stream.writable && !stream.writableEnded && !stream.destroyed;\n      if (writable) {\n        stream.end();\n      }\n    }\n    Readable.from = function (iterable, opts) {\n      return from(Readable, iterable, opts);\n    };\n    var webStreamsAdapters = {\n      newStreamReadableFromReadableStream,\n    };\n    function lazyWebStreams() {\n      if (webStreamsAdapters === void 0) webStreamsAdapters = {};\n      return webStreamsAdapters;\n    }\n    Readable.fromWeb = function (readableStream, options) {\n      return lazyWebStreams().newStreamReadableFromReadableStream(readableStream, options);\n    };\n    Readable.toWeb = function (streamReadable) {\n      return lazyWebStreams().newReadableStreamFromStreamReadable(streamReadable);\n    };\n    Readable.wrap = function (src, options) {\n      var _ref, _src$readableObjectMo;\n      return new Readable({\n        objectMode:\n          (_ref =\n            (_src$readableObjectMo = src.readableObjectMode) !== null && _src$readableObjectMo !== void 0\n              ? _src$readableObjectMo\n              : src.objectMode) !== null && _ref !== void 0\n            ? _ref\n            : true,\n        ...options,\n        destroy(err, callback) {\n          destroyImpl.destroyer(src, err);\n          callback(err);\n        },\n      }).wrap(src);\n    };\n  },\n});\n\n// node_modules/readable-stream/lib/internal/streams/writable.js\nvar require_writable = __commonJS({\n  \"node_modules/readable-stream/lib/internal/streams/writable.js\"(exports, module) {\n    \"use strict\";\n    var {\n      ArrayPrototypeSlice,\n      Error: Error2,\n      FunctionPrototypeSymbolHasInstance,\n      ObjectDefineProperty,\n      ObjectDefineProperties,\n      ObjectSetPrototypeOf,\n      StringPrototypeToLowerCase,\n      Symbol: Symbol2,\n      SymbolHasInstance,\n    } = require_primordials();\n\n    var { EventEmitter: EE } = __require(\"bun:events_native\");\n    var Stream = require_legacy().Stream;\n    var destroyImpl = require_destroy();\n    var { addAbortSignal } = require_add_abort_signal();\n    var { getHighWaterMark, getDefaultHighWaterMark } = require_state();\n    var {\n      ERR_INVALID_ARG_TYPE,\n      ERR_METHOD_NOT_IMPLEMENTED,\n      ERR_MULTIPLE_CALLBACK,\n      ERR_STREAM_CANNOT_PIPE,\n      ERR_STREAM_DESTROYED,\n      ERR_STREAM_ALREADY_FINISHED,\n      ERR_STREAM_NULL_VALUES,\n      ERR_STREAM_WRITE_AFTER_END,\n      ERR_UNKNOWN_ENCODING,\n    } = require_errors().codes;\n    var { errorOrDestroy } = destroyImpl;\n\n    function Writable(options = {}) {\n      const isDuplex = this instanceof require_duplex();\n      if (!isDuplex && !FunctionPrototypeSymbolHasInstance(Writable, this)) return new Writable(options);\n      this._writableState = new WritableState(options, this, isDuplex);\n      if (options) {\n        if (typeof options.write === \"function\") this._write = options.write;\n        if (typeof options.writev === \"function\") this._writev = options.writev;\n        if (typeof options.destroy === \"function\") this._destroy = options.destroy;\n        if (typeof options.final === \"function\") this._final = options.final;\n        if (typeof options.construct === \"function\") this._construct = options.construct;\n        if (options.signal) addAbortSignal(options.signal, this);\n      }\n      Stream.call(this, options);\n\n      destroyImpl.construct(this, () => {\n        const state = this._writableState;\n        if (!state.writing) {\n          clearBuffer(this, state);\n        }\n        finishMaybe(this, state);\n      });\n    }\n    ObjectSetPrototypeOf(Writable.prototype, Stream.prototype);\n    ObjectSetPrototypeOf(Writable, Stream);\n    module.exports = Writable;\n\n    function nop() {}\n    var kOnFinished = Symbol2(\"kOnFinished\");\n    function WritableState(options, stream, isDuplex) {\n      if (typeof isDuplex !== \"boolean\") isDuplex = stream instanceof require_duplex();\n      this.objectMode = !!(options && options.objectMode);\n      if (isDuplex) this.objectMode = this.objectMode || !!(options && options.writableObjectMode);\n      this.highWaterMark = options\n        ? getHighWaterMark(this, options, \"writableHighWaterMark\", isDuplex)\n        : getDefaultHighWaterMark(false);\n      this.finalCalled = false;\n      this.needDrain = false;\n      this.ending = false;\n      this.ended = false;\n      this.finished = false;\n      this.destroyed = false;\n      const noDecode = !!(options && options.decodeStrings === false);\n      this.decodeStrings = !noDecode;\n      this.defaultEncoding = (options && options.defaultEncoding) || \"utf8\";\n      this.length = 0;\n      this.writing = false;\n      this.corked = 0;\n      this.sync = true;\n      this.bufferProcessing = false;\n      this.onwrite = onwrite.bind(void 0, stream);\n      this.writecb = null;\n      this.writelen = 0;\n      this.afterWriteTickInfo = null;\n      resetBuffer(this);\n      this.pendingcb = 0;\n      this.constructed = true;\n      this.prefinished = false;\n      this.errorEmitted = false;\n      this.emitClose = !options || options.emitClose !== false;\n      this.autoDestroy = !options || options.autoDestroy !== false;\n      this.errored = null;\n      this.closed = false;\n      this.closeEmitted = false;\n      this[kOnFinished] = [];\n    }\n    function resetBuffer(state) {\n      state.buffered = [];\n      state.bufferedIndex = 0;\n      state.allBuffers = true;\n      state.allNoop = true;\n    }\n    WritableState.prototype.getBuffer = function getBuffer() {\n      return ArrayPrototypeSlice(this.buffered, this.bufferedIndex);\n    };\n    ObjectDefineProperty(WritableState.prototype, \"bufferedRequestCount\", {\n      get() {\n        return this.buffered.length - this.bufferedIndex;\n      },\n    });\n\n    ObjectDefineProperty(Writable, SymbolHasInstance, {\n      value: function (object) {\n        if (FunctionPrototypeSymbolHasInstance(this, object)) return true;\n        if (this !== Writable) return false;\n        return object && object._writableState instanceof WritableState;\n      },\n    });\n    Writable.prototype.pipe = function () {\n      errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());\n    };\n    function _write(stream, chunk, encoding, cb) {\n      const state = stream._writableState;\n      if (typeof encoding === \"function\") {\n        cb = encoding;\n        encoding = state.defaultEncoding;\n      } else {\n        if (!encoding) encoding = state.defaultEncoding;\n        else if (encoding !== \"buffer\" && !Buffer.isEncoding(encoding)) throw new ERR_UNKNOWN_ENCODING(encoding);\n        if (typeof cb !== \"function\") cb = nop;\n      }\n      if (chunk === null) {\n        throw new ERR_STREAM_NULL_VALUES();\n      } else if (!state.objectMode) {\n        if (typeof chunk === \"string\") {\n          if (state.decodeStrings !== false) {\n            chunk = Buffer.from(chunk, encoding);\n            encoding = \"buffer\";\n          }\n        } else if (chunk instanceof Buffer) {\n          encoding = \"buffer\";\n        } else if (Stream._isUint8Array(chunk)) {\n          chunk = Stream._uint8ArrayToBuffer(chunk);\n          encoding = \"buffer\";\n        } else {\n          throw new ERR_INVALID_ARG_TYPE(\"chunk\", [\"string\", \"Buffer\", \"Uint8Array\"], chunk);\n        }\n      }\n      let err;\n      if (state.ending) {\n        err = new ERR_STREAM_WRITE_AFTER_END();\n      } else if (state.destroyed) {\n        err = new ERR_STREAM_DESTROYED(\"write\");\n      }\n      if (err) {\n        runOnNextTick(cb, err);\n        errorOrDestroy(stream, err, true);\n        return err;\n      }\n      state.pendingcb++;\n      return writeOrBuffer(stream, state, chunk, encoding, cb);\n    }\n    Writable.prototype.write = function (chunk, encoding, cb) {\n      return _write(this, chunk, encoding, cb) === true;\n    };\n    Writable.prototype.cork = function () {\n      this._writableState.corked++;\n    };\n    Writable.prototype.uncork = function () {\n      const state = this._writableState;\n      if (state.corked) {\n        state.corked--;\n        if (!state.writing) clearBuffer(this, state);\n      }\n    };\n    Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {\n      if (typeof encoding === \"string\") encoding = StringPrototypeToLowerCase(encoding);\n      if (!Buffer.isEncoding(encoding)) throw new ERR_UNKNOWN_ENCODING(encoding);\n      this._writableState.defaultEncoding = encoding;\n      return this;\n    };\n    function writeOrBuffer(stream, state, chunk, encoding, callback) {\n      const len = state.objectMode ? 1 : chunk.length;\n      state.length += len;\n      const ret = state.length < state.highWaterMark;\n      if (!ret) state.needDrain = true;\n      if (state.writing || state.corked || state.errored || !state.constructed) {\n        state.buffered.push({\n          chunk,\n          encoding,\n          callback,\n        });\n        if (state.allBuffers && encoding !== \"buffer\") {\n          state.allBuffers = false;\n        }\n        if (state.allNoop && callback !== nop) {\n          state.allNoop = false;\n        }\n      } else {\n        state.writelen = len;\n        state.writecb = callback;\n        state.writing = true;\n        state.sync = true;\n        stream._write(chunk, encoding, state.onwrite);\n        state.sync = false;\n      }\n      return ret && !state.errored && !state.destroyed;\n    }\n    function doWrite(stream, state, writev, len, chunk, encoding, cb) {\n      state.writelen = len;\n      state.writecb = cb;\n      state.writing = true;\n      state.sync = true;\n      if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED(\"write\"));\n      else if (writev) stream._writev(chunk, state.onwrite);\n      else stream._write(chunk, encoding, state.onwrite);\n      state.sync = false;\n    }\n    function onwriteError(stream, state, er, cb) {\n      --state.pendingcb;\n      cb(er);\n      errorBuffer(state);\n      errorOrDestroy(stream, er);\n    }\n    function onwrite(stream, er) {\n      const state = stream._writableState;\n      const sync = state.sync;\n      const cb = state.writecb;\n      if (typeof cb !== \"function\") {\n        errorOrDestroy(stream, new ERR_MULTIPLE_CALLBACK());\n        return;\n      }\n      state.writing = false;\n      state.writecb = null;\n      state.length -= state.writelen;\n      state.writelen = 0;\n      if (er) {\n        Error.captureStackTrace(er);\n        if (!state.errored) {\n          state.errored = er;\n        }\n        if (stream._readableState && !stream._readableState.errored) {\n          stream._readableState.errored = er;\n        }\n        if (sync) {\n          runOnNextTick(onwriteError, stream, state, er, cb);\n        } else {\n          onwriteError(stream, state, er, cb);\n        }\n      } else {\n        if (state.buffered.length > state.bufferedIndex) {\n          clearBuffer(stream, state);\n        }\n        if (sync) {\n          if (state.afterWriteTickInfo !== null && state.afterWriteTickInfo.cb === cb) {\n            state.afterWriteTickInfo.count++;\n          } else {\n            state.afterWriteTickInfo = {\n              count: 1,\n              cb,\n              stream,\n              state,\n            };\n            runOnNextTick(afterWriteTick, state.afterWriteTickInfo);\n          }\n        } else {\n          afterWrite(stream, state, 1, cb);\n        }\n      }\n    }\n    function afterWriteTick({ stream, state, count, cb }) {\n      state.afterWriteTickInfo = null;\n      return afterWrite(stream, state, count, cb);\n    }\n    function afterWrite(stream, state, count, cb) {\n      const needDrain = !state.ending && !stream.destroyed && state.length === 0 && state.needDrain;\n      if (needDrain) {\n        state.needDrain = false;\n        stream.emit(\"drain\");\n      }\n      while (count-- > 0) {\n        state.pendingcb--;\n        cb();\n      }\n      if (state.destroyed) {\n        errorBuffer(state);\n      }\n      finishMaybe(stream, state);\n    }\n    function errorBuffer(state) {\n      if (state.writing) {\n        return;\n      }\n      for (let n = state.bufferedIndex; n < state.buffered.length; ++n) {\n        var _state$errored;\n        const { chunk, callback } = state.buffered[n];\n        const len = state.objectMode ? 1 : chunk.length;\n        state.length -= len;\n        callback(\n          (_state$errored = state.errored) !== null && _state$errored !== void 0\n            ? _state$errored\n            : new ERR_STREAM_DESTROYED(\"write\"),\n        );\n      }\n      const onfinishCallbacks = state[kOnFinished].splice(0);\n      for (let i = 0; i < onfinishCallbacks.length; i++) {\n        var _state$errored2;\n        onfinishCallbacks[i](\n          (_state$errored2 = state.errored) !== null && _state$errored2 !== void 0\n            ? _state$errored2\n            : new ERR_STREAM_DESTROYED(\"end\"),\n        );\n      }\n      resetBuffer(state);\n    }\n    function clearBuffer(stream, state) {\n      if (state.corked || state.bufferProcessing || state.destroyed || !state.constructed) {\n        return;\n      }\n      const { buffered, bufferedIndex, objectMode } = state;\n      const bufferedLength = buffered.length - bufferedIndex;\n      if (!bufferedLength) {\n        return;\n      }\n      let i = bufferedIndex;\n      state.bufferProcessing = true;\n      if (bufferedLength > 1 && stream._writev) {\n        state.pendingcb -= bufferedLength - 1;\n        const callback = state.allNoop\n          ? nop\n          : err => {\n              for (let n = i; n < buffered.length; ++n) {\n                buffered[n].callback(err);\n              }\n            };\n        const chunks = state.allNoop && i === 0 ? buffered : ArrayPrototypeSlice(buffered, i);\n        chunks.allBuffers = state.allBuffers;\n        doWrite(stream, state, true, state.length, chunks, \"\", callback);\n        resetBuffer(state);\n      } else {\n        do {\n          const { chunk, encoding, callback } = buffered[i];\n          buffered[i++] = null;\n          const len = objectMode ? 1 : chunk.length;\n          doWrite(stream, state, false, len, chunk, encoding, callback);\n        } while (i < buffered.length && !state.writing);\n        if (i === buffered.length) {\n          resetBuffer(state);\n        } else if (i > 256) {\n          buffered.splice(0, i);\n          state.bufferedIndex = 0;\n        } else {\n          state.bufferedIndex = i;\n        }\n      }\n      state.bufferProcessing = false;\n    }\n    Writable.prototype._write = function (chunk, encoding, cb) {\n      if (this._writev) {\n        this._writev(\n          [\n            {\n              chunk,\n              encoding,\n            },\n          ],\n          cb,\n        );\n      } else {\n        throw new ERR_METHOD_NOT_IMPLEMENTED(\"_write()\");\n      }\n    };\n    Writable.prototype._writev = null;\n    Writable.prototype.end = function (chunk, encoding, cb, native = false) {\n      const state = this._writableState;\n      __DEBUG__ && debug(\"end\", state, this.__id);\n      if (typeof chunk === \"function\") {\n        cb = chunk;\n        chunk = null;\n        encoding = null;\n      } else if (typeof encoding === \"function\") {\n        cb = encoding;\n        encoding = null;\n      }\n      let err;\n      if (chunk !== null && chunk !== void 0) {\n        let ret;\n        if (!native) {\n          ret = _write(this, chunk, encoding);\n        } else {\n          ret = this.write(chunk, encoding);\n        }\n        if (ret instanceof Error2) {\n          err = ret;\n        }\n      }\n      if (state.corked) {\n        state.corked = 1;\n        this.uncork();\n      }\n      if (err) {\n        this.emit(\"error\", err);\n      } else if (!state.errored && !state.ending) {\n        state.ending = true;\n        finishMaybe(this, state, true);\n        state.ended = true;\n      } else if (state.finished) {\n        err = new ERR_STREAM_ALREADY_FINISHED(\"end\");\n      } else if (state.destroyed) {\n        err = new ERR_STREAM_DESTROYED(\"end\");\n      }\n      if (typeof cb === \"function\") {\n        if (err || state.finished) {\n          runOnNextTick(cb, err);\n        } else {\n          state[kOnFinished].push(cb);\n        }\n      }\n      return this;\n    };\n    function needFinish(state, tag) {\n      var needFinish =\n        state.ending &&\n        !state.destroyed &&\n        state.constructed &&\n        state.length === 0 &&\n        !state.errored &&\n        state.buffered.length === 0 &&\n        !state.finished &&\n        !state.writing &&\n        !state.errorEmitted &&\n        !state.closeEmitted;\n      debug(\"needFinish\", needFinish, tag);\n      return needFinish;\n    }\n    function callFinal(stream, state) {\n      let called = false;\n      function onFinish(err) {\n        if (called) {\n          errorOrDestroy(stream, err !== null && err !== void 0 ? err : ERR_MULTIPLE_CALLBACK());\n          return;\n        }\n        called = true;\n        state.pendingcb--;\n        if (err) {\n          const onfinishCallbacks = state[kOnFinished].splice(0);\n          for (let i = 0; i < onfinishCallbacks.length; i++) {\n            onfinishCallbacks[i](err);\n          }\n          errorOrDestroy(stream, err, state.sync);\n        } else if (needFinish(state)) {\n          state.prefinished = true;\n          stream.emit(\"prefinish\");\n          state.pendingcb++;\n          runOnNextTick(finish, stream, state);\n        }\n      }\n      state.sync = true;\n      state.pendingcb++;\n      try {\n        stream._final(onFinish);\n      } catch (err) {\n        onFinish(err);\n      }\n      state.sync = false;\n    }\n    function prefinish(stream, state) {\n      if (!state.prefinished && !state.finalCalled) {\n        if (typeof stream._final === \"function\" && !state.destroyed) {\n          state.finalCalled = true;\n          callFinal(stream, state);\n        } else {\n          state.prefinished = true;\n          stream.emit(\"prefinish\");\n        }\n      }\n    }\n    function finishMaybe(stream, state, sync) {\n      __DEBUG__ && debug(\"finishMaybe -- state, sync\", state, sync, stream.__id);\n\n      if (!needFinish(state, stream.__id)) return;\n\n      prefinish(stream, state);\n      if (state.pendingcb === 0) {\n        if (sync) {\n          state.pendingcb++;\n          runOnNextTick(\n            (stream2, state2) => {\n              if (needFinish(state2)) {\n                finish(stream2, state2);\n              } else {\n                state2.pendingcb--;\n              }\n            },\n            stream,\n            state,\n          );\n        } else if (needFinish(state)) {\n          state.pendingcb++;\n          finish(stream, state);\n        }\n      }\n    }\n    function finish(stream, state) {\n      state.pendingcb--;\n      state.finished = true;\n      const onfinishCallbacks = state[kOnFinished].splice(0);\n      for (let i = 0; i < onfinishCallbacks.length; i++) {\n        onfinishCallbacks[i]();\n      }\n      stream.emit(\"finish\");\n      if (state.autoDestroy) {\n        const rState = stream._readableState;\n        const autoDestroy = !rState || (rState.autoDestroy && (rState.endEmitted || rState.readable === false));\n        if (autoDestroy) {\n          stream.destroy();\n        }\n      }\n    }\n    ObjectDefineProperties(Writable.prototype, {\n      closed: {\n        get() {\n          return this._writableState ? this._writableState.closed : false;\n        },\n      },\n      destroyed: {\n        get() {\n          return this._writableState ? this._writableState.destroyed : false;\n        },\n        set(value) {\n          if (this._writableState) {\n            this._writableState.destroyed = value;\n          }\n        },\n      },\n      writable: {\n        get() {\n          const w = this._writableState;\n          return !!w && w.writable !== false && !w.destroyed && !w.errored && !w.ending && !w.ended;\n        },\n        set(val) {\n          if (this._writableState) {\n            this._writableState.writable = !!val;\n          }\n        },\n      },\n      writableFinished: {\n        get() {\n          return this._writableState ? this._writableState.finished : false;\n        },\n      },\n      writableObjectMode: {\n        get() {\n          return this._writableState ? this._writableState.objectMode : false;\n        },\n      },\n      writableBuffer: {\n        get() {\n          return this._writableState && this._writableState.getBuffer();\n        },\n      },\n      writableEnded: {\n        get() {\n          return this._writableState ? this._writableState.ending : false;\n        },\n      },\n      writableNeedDrain: {\n        get() {\n          const wState = this._writableState;\n          if (!wState) return false;\n          return !wState.destroyed && !wState.ending && wState.needDrain;\n        },\n      },\n      writableHighWaterMark: {\n        get() {\n          return this._writableState && this._writableState.highWaterMark;\n        },\n      },\n      writableCorked: {\n        get() {\n          return this._writableState ? this._writableState.corked : 0;\n        },\n      },\n      writableLength: {\n        get() {\n          return this._writableState && this._writableState.length;\n        },\n      },\n      errored: {\n        enumerable: false,\n        get() {\n          return this._writableState ? this._writableState.errored : null;\n        },\n      },\n      writableAborted: {\n        enumerable: false,\n        get: function () {\n          return !!(\n            this._writableState.writable !== false &&\n            (this._writableState.destroyed || this._writableState.errored) &&\n            !this._writableState.finished\n          );\n        },\n      },\n    });\n    var destroy = destroyImpl.destroy;\n    Writable.prototype.destroy = function (err, cb) {\n      const state = this._writableState;\n      if (!state.destroyed && (state.bufferedIndex < state.buffered.length || state[kOnFinished].length)) {\n        runOnNextTick(errorBuffer, state);\n      }\n      destroy.call(this, err, cb);\n      return this;\n    };\n    Writable.prototype._undestroy = destroyImpl.undestroy;\n    Writable.prototype._destroy = function (err, cb) {\n      cb(err);\n    };\n    Writable.prototype[EE.captureRejectionSymbol] = function (err) {\n      this.destroy(err);\n    };\n    var webStreamsAdapters;\n    function lazyWebStreams() {\n      if (webStreamsAdapters === void 0) webStreamsAdapters = {};\n      return webStreamsAdapters;\n    }\n    Writable.fromWeb = function (writableStream, options) {\n      return lazyWebStreams().newStreamWritableFromWritableStream(writableStream, options);\n    };\n    Writable.toWeb = function (streamWritable) {\n      return lazyWebStreams().newWritableStreamFromStreamWritable(streamWritable);\n    };\n  },\n});\n\n// node_modules/readable-stream/lib/internal/streams/duplexify.js\nvar require_duplexify = __commonJS({\n  \"node_modules/readable-stream/lib/internal/streams/duplexify.js\"(exports, module) {\n    \"use strict\";\n    var bufferModule = __require(\"buffer\");\n    var {\n      isReadable,\n      isWritable,\n      isIterable,\n      isNodeStream,\n      isReadableNodeStream,\n      isWritableNodeStream,\n      isDuplexNodeStream,\n    } = require_utils();\n    var eos = require_end_of_stream();\n    var {\n      AbortError,\n      codes: { ERR_INVALID_ARG_TYPE, ERR_INVALID_RETURN_VALUE },\n    } = require_errors();\n    var { destroyer } = require_destroy();\n    var Duplex = require_duplex();\n    var Readable = require_readable();\n    var { createDeferredPromise } = require_util();\n    var from = require_from();\n    var Blob = globalThis.Blob || bufferModule.Blob;\n    var isBlob =\n      typeof Blob !== \"undefined\"\n        ? function isBlob2(b) {\n            return b instanceof Blob;\n          }\n        : function isBlob2(b) {\n            return false;\n          };\n    var AbortController = globalThis.AbortController || __require(\"abort-controller\").AbortController;\n    var { FunctionPrototypeCall } = require_primordials();\n    class Duplexify extends Duplex {\n      constructor(options) {\n        super(options);\n\n        // https://github.com/nodejs/node/pull/34385\n\n        if ((options === null || options === undefined ? undefined : options.readable) === false) {\n          this._readableState.readable = false;\n          this._readableState.ended = true;\n          this._readableState.endEmitted = true;\n        }\n        if ((options === null || options === undefined ? undefined : options.writable) === false) {\n          this._writableState.writable = false;\n          this._writableState.ending = true;\n          this._writableState.ended = true;\n          this._writableState.finished = true;\n        }\n      }\n    }\n    module.exports = function duplexify(body, name) {\n      if (isDuplexNodeStream(body)) {\n        return body;\n      }\n      if (isReadableNodeStream(body)) {\n        return _duplexify({\n          readable: body,\n        });\n      }\n      if (isWritableNodeStream(body)) {\n        return _duplexify({\n          writable: body,\n        });\n      }\n      if (isNodeStream(body)) {\n        return _duplexify({\n          writable: false,\n          readable: false,\n        });\n      }\n      if (typeof body === \"function\") {\n        const { value, write, final, destroy } = fromAsyncGen(body);\n        if (isIterable(value)) {\n          return from(Duplexify, value, {\n            objectMode: true,\n            write,\n            final,\n            destroy,\n          });\n        }\n        const then2 = value === null || value === void 0 ? void 0 : value.then;\n        if (typeof then2 === \"function\") {\n          let d;\n          const promise = FunctionPrototypeCall(\n            then2,\n            value,\n            val => {\n              if (val != null) {\n                throw new ERR_INVALID_RETURN_VALUE(\"nully\", \"body\", val);\n              }\n            },\n            err => {\n              destroyer(d, err);\n            },\n          );\n          return (d = new Duplexify({\n            objectMode: true,\n            readable: false,\n            write,\n            final(cb) {\n              final(async () => {\n                try {\n                  await promise;\n                  runOnNextTick(cb, null);\n                } catch (err) {\n                  runOnNextTick(cb, err);\n                }\n              });\n            },\n            destroy,\n          }));\n        }\n        throw new ERR_INVALID_RETURN_VALUE(\"Iterable, AsyncIterable or AsyncFunction\", name, value);\n      }\n      if (isBlob(body)) {\n        return duplexify(body.arrayBuffer());\n      }\n      if (isIterable(body)) {\n        return from(Duplexify, body, {\n          objectMode: true,\n          writable: false,\n        });\n      }\n      if (\n        typeof (body === null || body === void 0 ? void 0 : body.writable) === \"object\" ||\n        typeof (body === null || body === void 0 ? void 0 : body.readable) === \"object\"\n      ) {\n        const readable =\n          body !== null && body !== void 0 && body.readable\n            ? isReadableNodeStream(body === null || body === void 0 ? void 0 : body.readable)\n              ? body === null || body === void 0\n                ? void 0\n                : body.readable\n              : duplexify(body.readable)\n            : void 0;\n        const writable =\n          body !== null && body !== void 0 && body.writable\n            ? isWritableNodeStream(body === null || body === void 0 ? void 0 : body.writable)\n              ? body === null || body === void 0\n                ? void 0\n                : body.writable\n              : duplexify(body.writable)\n            : void 0;\n        return _duplexify({\n          readable,\n          writable,\n        });\n      }\n      const then = body === null || body === void 0 ? void 0 : body.then;\n      if (typeof then === \"function\") {\n        let d;\n        FunctionPrototypeCall(\n          then,\n          body,\n          val => {\n            if (val != null) {\n              d.push(val);\n            }\n            d.push(null);\n          },\n          err => {\n            destroyer(d, err);\n          },\n        );\n        return (d = new Duplexify({\n          objectMode: true,\n          writable: false,\n          read() {},\n        }));\n      }\n      throw new ERR_INVALID_ARG_TYPE(\n        name,\n        [\n          \"Blob\",\n          \"ReadableStream\",\n          \"WritableStream\",\n          \"Stream\",\n          \"Iterable\",\n          \"AsyncIterable\",\n          \"Function\",\n          \"{ readable, writable } pair\",\n          \"Promise\",\n        ],\n        body,\n      );\n    };\n    function fromAsyncGen(fn) {\n      let { promise, resolve } = createDeferredPromise();\n      const ac = new AbortController();\n      const signal = ac.signal;\n      const value = fn(\n        (async function* () {\n          while (true) {\n            const _promise = promise;\n            promise = null;\n            const { chunk, done, cb } = await _promise;\n            runOnNextTick(cb);\n            if (done) return;\n            if (signal.aborted)\n              throw new AbortError(void 0, {\n                cause: signal.reason,\n              });\n            ({ promise, resolve } = createDeferredPromise());\n            yield chunk;\n          }\n        })(),\n        {\n          signal,\n        },\n      );\n      return {\n        value,\n        write(chunk, encoding, cb) {\n          const _resolve = resolve;\n          resolve = null;\n          _resolve({\n            chunk,\n            done: false,\n            cb,\n          });\n        },\n        final(cb) {\n          const _resolve = resolve;\n          resolve = null;\n          _resolve({\n            done: true,\n            cb,\n          });\n        },\n        destroy(err, cb) {\n          ac.abort();\n          cb(err);\n        },\n      };\n    }\n    function _duplexify(pair) {\n      const r =\n        pair.readable && typeof pair.readable.read !== \"function\" ? Readable.wrap(pair.readable) : pair.readable;\n      const w = pair.writable;\n      let readable = !!isReadable(r);\n      let writable = !!isWritable(w);\n      let ondrain;\n      let onfinish;\n      let onreadable;\n      let onclose;\n      let d;\n      function onfinished(err) {\n        const cb = onclose;\n        onclose = null;\n        if (cb) {\n          cb(err);\n        } else if (err) {\n          d.destroy(err);\n        } else if (!readable && !writable) {\n          d.destroy();\n        }\n      }\n      d = new Duplexify({\n        readableObjectMode: !!(r !== null && r !== void 0 && r.readableObjectMode),\n        writableObjectMode: !!(w !== null && w !== void 0 && w.writableObjectMode),\n        readable,\n        writable,\n      });\n      if (writable) {\n        eos(w, err => {\n          writable = false;\n          if (err) {\n            destroyer(r, err);\n          }\n          onfinished(err);\n        });\n        d._write = function (chunk, encoding, callback) {\n          if (w.write(chunk, encoding)) {\n            callback();\n          } else {\n            ondrain = callback;\n          }\n        };\n        d._final = function (callback) {\n          w.end();\n          onfinish = callback;\n        };\n        w.on(\"drain\", function () {\n          if (ondrain) {\n            const cb = ondrain;\n            ondrain = null;\n            cb();\n          }\n        });\n        w.on(\"finish\", function () {\n          if (onfinish) {\n            const cb = onfinish;\n            onfinish = null;\n            cb();\n          }\n        });\n      }\n      if (readable) {\n        eos(r, err => {\n          readable = false;\n          if (err) {\n            destroyer(r, err);\n          }\n          onfinished(err);\n        });\n        r.on(\"readable\", function () {\n          if (onreadable) {\n            const cb = onreadable;\n            onreadable = null;\n            cb();\n          }\n        });\n        r.on(\"end\", function () {\n          d.push(null);\n        });\n        d._read = function () {\n          while (true) {\n            const buf = r.read();\n            if (buf === null) {\n              onreadable = d._read;\n              return;\n            }\n            if (!d.push(buf)) {\n              return;\n            }\n          }\n        };\n      }\n      d._destroy = function (err, callback) {\n        if (!err && onclose !== null) {\n          err = new AbortError();\n        }\n        onreadable = null;\n        ondrain = null;\n        onfinish = null;\n        if (onclose === null) {\n          callback(err);\n        } else {\n          onclose = callback;\n          destroyer(w, err);\n          destroyer(r, err);\n        }\n      };\n      return d;\n    }\n  },\n});\n\n// node_modules/readable-stream/lib/internal/streams/duplex.js\nvar require_duplex = __commonJS({\n  \"node_modules/readable-stream/lib/internal/streams/duplex.js\"(exports, module) {\n    \"use strict\";\n    var { ObjectDefineProperties, ObjectGetOwnPropertyDescriptor, ObjectKeys, ObjectSetPrototypeOf } =\n      require_primordials();\n\n    var Readable = require_readable();\n\n    function Duplex(options) {\n      if (!(this instanceof Duplex)) return new Duplex(options);\n      Readable.call(this, options);\n      Writable.call(this, options);\n\n      if (options) {\n        this.allowHalfOpen = options.allowHalfOpen !== false;\n        if (options.readable === false) {\n          this._readableState.readable = false;\n          this._readableState.ended = true;\n          this._readableState.endEmitted = true;\n        }\n        if (options.writable === false) {\n          this._writableState.writable = false;\n          this._writableState.ending = true;\n          this._writableState.ended = true;\n          this._writableState.finished = true;\n        }\n      } else {\n        this.allowHalfOpen = true;\n      }\n    }\n    module.exports = Duplex;\n\n    ObjectSetPrototypeOf(Duplex.prototype, Readable.prototype);\n    ObjectSetPrototypeOf(Duplex, Readable);\n\n    {\n      for (var method in Writable.prototype) {\n        if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];\n      }\n    }\n\n    ObjectDefineProperties(Duplex.prototype, {\n      writable: ObjectGetOwnPropertyDescriptor(Writable.prototype, \"writable\"),\n      writableHighWaterMark: ObjectGetOwnPropertyDescriptor(Writable.prototype, \"writableHighWaterMark\"),\n      writableObjectMode: ObjectGetOwnPropertyDescriptor(Writable.prototype, \"writableObjectMode\"),\n      writableBuffer: ObjectGetOwnPropertyDescriptor(Writable.prototype, \"writableBuffer\"),\n      writableLength: ObjectGetOwnPropertyDescriptor(Writable.prototype, \"writableLength\"),\n      writableFinished: ObjectGetOwnPropertyDescriptor(Writable.prototype, \"writableFinished\"),\n      writableCorked: ObjectGetOwnPropertyDescriptor(Writable.prototype, \"writableCorked\"),\n      writableEnded: ObjectGetOwnPropertyDescriptor(Writable.prototype, \"writableEnded\"),\n      writableNeedDrain: ObjectGetOwnPropertyDescriptor(Writable.prototype, \"writableNeedDrain\"),\n      destroyed: {\n        get() {\n          if (this._readableState === void 0 || this._writableState === void 0) {\n            return false;\n          }\n          return this._readableState.destroyed && this._writableState.destroyed;\n        },\n        set(value) {\n          if (this._readableState && this._writableState) {\n            this._readableState.destroyed = value;\n            this._writableState.destroyed = value;\n          }\n        },\n      },\n    });\n    var webStreamsAdapters;\n    function lazyWebStreams() {\n      if (webStreamsAdapters === void 0) webStreamsAdapters = {};\n      return webStreamsAdapters;\n    }\n    Duplex.fromWeb = function (pair, options) {\n      return lazyWebStreams().newStreamDuplexFromReadableWritablePair(pair, options);\n    };\n    Duplex.toWeb = function (duplex) {\n      return lazyWebStreams().newReadableWritablePairFromDuplex(duplex);\n    };\n    var duplexify;\n    Duplex.from = function (body) {\n      if (!duplexify) {\n        duplexify = require_duplexify();\n      }\n      return duplexify(body, \"body\");\n    };\n  },\n});\n\n// node_modules/readable-stream/lib/internal/streams/transform.js\nvar require_transform = __commonJS({\n  \"node_modules/readable-stream/lib/internal/streams/transform.js\"(exports, module) {\n    \"use strict\";\n    var { ObjectSetPrototypeOf, Symbol: Symbol2 } = require_primordials();\n    var { ERR_METHOD_NOT_IMPLEMENTED } = require_errors().codes;\n    var Duplex = require_duplex();\n    function Transform(options) {\n      if (!(this instanceof Transform)) return new Transform(options);\n      Duplex.call(this, options);\n\n      this._readableState.sync = false;\n      this[kCallback] = null;\n\n      if (options) {\n        if (typeof options.transform === \"function\") this._transform = options.transform;\n        if (typeof options.flush === \"function\") this._flush = options.flush;\n      }\n\n      this.on(\"prefinish\", prefinish.bind(this));\n    }\n    ObjectSetPrototypeOf(Transform.prototype, Duplex.prototype);\n    ObjectSetPrototypeOf(Transform, Duplex);\n\n    module.exports = Transform;\n    var kCallback = Symbol2(\"kCallback\");\n    function final(cb) {\n      if (typeof this._flush === \"function\" && !this.destroyed) {\n        this._flush((er, data) => {\n          if (er) {\n            if (cb) {\n              cb(er);\n            } else {\n              this.destroy(er);\n            }\n            return;\n          }\n          if (data != null) {\n            this.push(data);\n          }\n          this.push(null);\n          if (cb) {\n            cb();\n          }\n        });\n      } else {\n        this.push(null);\n        if (cb) {\n          cb();\n        }\n      }\n    }\n    function prefinish() {\n      if (this._final !== final) {\n        final.call(this);\n      }\n    }\n    Transform.prototype._final = final;\n    Transform.prototype._transform = function (chunk, encoding, callback) {\n      throw new ERR_METHOD_NOT_IMPLEMENTED(\"_transform()\");\n    };\n    Transform.prototype._write = function (chunk, encoding, callback) {\n      const rState = this._readableState;\n      const wState = this._writableState;\n      const length = rState.length;\n      this._transform(chunk, encoding, (err, val) => {\n        if (err) {\n          callback(err);\n          return;\n        }\n        if (val != null) {\n          this.push(val);\n        }\n        if (\n          wState.ended ||\n          length === rState.length ||\n          rState.length < rState.highWaterMark ||\n          rState.highWaterMark === 0 ||\n          rState.length === 0\n        ) {\n          callback();\n        } else {\n          this[kCallback] = callback;\n        }\n      });\n    };\n    Transform.prototype._read = function () {\n      if (this[kCallback]) {\n        const callback = this[kCallback];\n        this[kCallback] = null;\n        callback();\n      }\n    };\n  },\n});\n\n// node_modules/readable-stream/lib/internal/streams/passthrough.js\nvar require_passthrough = __commonJS({\n  \"node_modules/readable-stream/lib/internal/streams/passthrough.js\"(exports, module) {\n    \"use strict\";\n    var { ObjectSetPrototypeOf } = require_primordials();\n    var Transform = require_transform();\n\n    function PassThrough(options) {\n      if (!(this instanceof PassThrough)) return new PassThrough(options);\n      Transform.call(this, options);\n    }\n\n    ObjectSetPrototypeOf(PassThrough.prototype, Transform.prototype);\n    ObjectSetPrototypeOf(PassThrough, Transform);\n\n    PassThrough.prototype._transform = function (chunk, encoding, cb) {\n      cb(null, chunk);\n    };\n\n    module.exports = PassThrough;\n  },\n});\n\n// node_modules/readable-stream/lib/internal/streams/pipeline.js\nvar require_pipeline = __commonJS({\n  \"node_modules/readable-stream/lib/internal/streams/pipeline.js\"(exports, module) {\n    \"use strict\";\n    var { ArrayIsArray, Promise: Promise2, SymbolAsyncIterator } = require_primordials();\n    var eos = require_end_of_stream();\n    var { once } = require_util();\n    var destroyImpl = require_destroy();\n    var Duplex = require_duplex();\n    var {\n      aggregateTwoErrors,\n      codes: { ERR_INVALID_ARG_TYPE, ERR_INVALID_RETURN_VALUE, ERR_MISSING_ARGS, ERR_STREAM_DESTROYED },\n      AbortError,\n    } = require_errors();\n    var { validateFunction, validateAbortSignal } = require_validators();\n    var { isIterable, isReadable, isReadableNodeStream, isNodeStream } = require_utils();\n    var AbortController = globalThis.AbortController || __require(\"abort-controller\").AbortController;\n    var PassThrough;\n    var Readable;\n    function destroyer(stream, reading, writing) {\n      let finished = false;\n      stream.on(\"close\", () => {\n        finished = true;\n      });\n      const cleanup = eos(\n        stream,\n        {\n          readable: reading,\n          writable: writing,\n        },\n        err => {\n          finished = !err;\n        },\n      );\n      return {\n        destroy: err => {\n          if (finished) return;\n          finished = true;\n          destroyImpl.destroyer(stream, err || new ERR_STREAM_DESTROYED(\"pipe\"));\n        },\n        cleanup,\n      };\n    }\n    function popCallback(streams) {\n      validateFunction(streams[streams.length - 1], \"streams[stream.length - 1]\");\n      return streams.pop();\n    }\n    function makeAsyncIterable(val) {\n      if (isIterable(val)) {\n        return val;\n      } else if (isReadableNodeStream(val)) {\n        return fromReadable(val);\n      }\n      throw new ERR_INVALID_ARG_TYPE(\"val\", [\"Readable\", \"Iterable\", \"AsyncIterable\"], val);\n    }\n    async function* fromReadable(val) {\n      if (!Readable) {\n        Readable = require_readable();\n      }\n      yield* Readable.prototype[SymbolAsyncIterator].call(val);\n    }\n    async function pump(iterable, writable, finish, { end }) {\n      let error;\n      let onresolve = null;\n      const resume = err => {\n        if (err) {\n          error = err;\n        }\n        if (onresolve) {\n          const callback = onresolve;\n          onresolve = null;\n          callback();\n        }\n      };\n      const wait = () =>\n        new Promise2((resolve, reject) => {\n          if (error) {\n            reject(error);\n          } else {\n            onresolve = () => {\n              if (error) {\n                reject(error);\n              } else {\n                resolve();\n              }\n            };\n          }\n        });\n      writable.on(\"drain\", resume);\n      const cleanup = eos(\n        writable,\n        {\n          readable: false,\n        },\n        resume,\n      );\n      try {\n        if (writable.writableNeedDrain) {\n          await wait();\n        }\n        for await (const chunk of iterable) {\n          if (!writable.write(chunk)) {\n            await wait();\n          }\n        }\n        if (end) {\n          writable.end();\n        }\n        await wait();\n        finish();\n      } catch (err) {\n        finish(error !== err ? aggregateTwoErrors(error, err) : err);\n      } finally {\n        cleanup();\n        writable.off(\"drain\", resume);\n      }\n    }\n    function pipeline(...streams) {\n      return pipelineImpl(streams, once(popCallback(streams)));\n    }\n    function pipelineImpl(streams, callback, opts) {\n      if (streams.length === 1 && ArrayIsArray(streams[0])) {\n        streams = streams[0];\n      }\n      if (streams.length < 2) {\n        throw new ERR_MISSING_ARGS(\"streams\");\n      }\n      const ac = new AbortController();\n      const signal = ac.signal;\n      const outerSignal = opts === null || opts === void 0 ? void 0 : opts.signal;\n      const lastStreamCleanup = [];\n      validateAbortSignal(outerSignal, \"options.signal\");\n      function abort() {\n        finishImpl(new AbortError());\n      }\n      outerSignal === null || outerSignal === void 0 ? void 0 : outerSignal.addEventListener(\"abort\", abort);\n      let error;\n      let value;\n      const destroys = [];\n      let finishCount = 0;\n      function finish(err) {\n        finishImpl(err, --finishCount === 0);\n      }\n      function finishImpl(err, final) {\n        if (err && (!error || error.code === \"ERR_STREAM_PREMATURE_CLOSE\")) {\n          error = err;\n        }\n        if (!error && !final) {\n          return;\n        }\n        while (destroys.length) {\n          destroys.shift()(error);\n        }\n        outerSignal === null || outerSignal === void 0 ? void 0 : outerSignal.removeEventListener(\"abort\", abort);\n        ac.abort();\n        if (final) {\n          if (!error) {\n            lastStreamCleanup.forEach(fn => fn());\n          }\n          runOnNextTick(callback, error, value);\n        }\n      }\n      let ret;\n      for (let i = 0; i < streams.length; i++) {\n        const stream = streams[i];\n        const reading = i < streams.length - 1;\n        const writing = i > 0;\n        const end = reading || (opts === null || opts === void 0 ? void 0 : opts.end) !== false;\n        const isLastStream = i === streams.length - 1;\n        if (isNodeStream(stream)) {\n          let onError = function (err) {\n            if (err && err.name !== \"AbortError\" && err.code !== \"ERR_STREAM_PREMATURE_CLOSE\") {\n              finish(err);\n            }\n          };\n          if (end) {\n            const { destroy, cleanup } = destroyer(stream, reading, writing);\n            destroys.push(destroy);\n            if (isReadable(stream) && isLastStream) {\n              lastStreamCleanup.push(cleanup);\n            }\n          }\n          stream.on(\"error\", onError);\n          if (isReadable(stream) && isLastStream) {\n            lastStreamCleanup.push(() => {\n              stream.removeListener(\"error\", onError);\n            });\n          }\n        }\n        if (i === 0) {\n          if (typeof stream === \"function\") {\n            ret = stream({\n              signal,\n            });\n            if (!isIterable(ret)) {\n              throw new ERR_INVALID_RETURN_VALUE(\"Iterable, AsyncIterable or Stream\", \"source\", ret);\n            }\n          } else if (isIterable(stream) || isReadableNodeStream(stream)) {\n            ret = stream;\n          } else {\n            ret = Duplex.from(stream);\n          }\n        } else if (typeof stream === \"function\") {\n          ret = makeAsyncIterable(ret);\n          ret = stream(ret, {\n            signal,\n          });\n          if (reading) {\n            if (!isIterable(ret, true)) {\n              throw new ERR_INVALID_RETURN_VALUE(\"AsyncIterable\", `transform[${i - 1}]`, ret);\n            }\n          } else {\n            var _ret;\n            if (!PassThrough) {\n              PassThrough = require_passthrough();\n            }\n            const pt = new PassThrough({\n              objectMode: true,\n            });\n            const then = (_ret = ret) === null || _ret === void 0 ? void 0 : _ret.then;\n            if (typeof then === \"function\") {\n              finishCount++;\n              then.call(\n                ret,\n                val => {\n                  value = val;\n                  if (val != null) {\n                    pt.write(val);\n                  }\n                  if (end) {\n                    pt.end();\n                  }\n                  runOnNextTick(finish);\n                },\n                err => {\n                  pt.destroy(err);\n                  runOnNextTick(finish, err);\n                },\n              );\n            } else if (isIterable(ret, true)) {\n              finishCount++;\n              pump(ret, pt, finish, {\n                end,\n              });\n            } else {\n              throw new ERR_INVALID_RETURN_VALUE(\"AsyncIterable or Promise\", \"destination\", ret);\n            }\n            ret = pt;\n            const { destroy, cleanup } = destroyer(ret, false, true);\n            destroys.push(destroy);\n            if (isLastStream) {\n              lastStreamCleanup.push(cleanup);\n            }\n          }\n        } else if (isNodeStream(stream)) {\n          if (isReadableNodeStream(ret)) {\n            finishCount += 2;\n            const cleanup = pipe(ret, stream, finish, {\n              end,\n            });\n            if (isReadable(stream) && isLastStream) {\n              lastStreamCleanup.push(cleanup);\n            }\n          } else if (isIterable(ret)) {\n            finishCount++;\n            pump(ret, stream, finish, {\n              end,\n            });\n          } else {\n            throw new ERR_INVALID_ARG_TYPE(\"val\", [\"Readable\", \"Iterable\", \"AsyncIterable\"], ret);\n          }\n          ret = stream;\n        } else {\n          ret = Duplex.from(stream);\n        }\n      }\n      if (\n        (signal !== null && signal !== void 0 && signal.aborted) ||\n        (outerSignal !== null && outerSignal !== void 0 && outerSignal.aborted)\n      ) {\n        runOnNextTick(abort);\n      }\n      return ret;\n    }\n    function pipe(src, dst, finish, { end }) {\n      src.pipe(dst, {\n        end,\n      });\n      if (end) {\n        src.once(\"end\", () => dst.end());\n      } else {\n        finish();\n      }\n      eos(\n        src,\n        {\n          readable: true,\n          writable: false,\n        },\n        err => {\n          const rState = src._readableState;\n          if (\n            err &&\n            err.code === \"ERR_STREAM_PREMATURE_CLOSE\" &&\n            rState &&\n            rState.ended &&\n            !rState.errored &&\n            !rState.errorEmitted\n          ) {\n            src.once(\"end\", finish).once(\"error\", finish);\n          } else {\n            finish(err);\n          }\n        },\n      );\n      return eos(\n        dst,\n        {\n          readable: false,\n          writable: true,\n        },\n        finish,\n      );\n    }\n    module.exports = {\n      pipelineImpl,\n      pipeline,\n    };\n  },\n});\n\n// node_modules/readable-stream/lib/internal/streams/compose.js\nvar require_compose = __commonJS({\n  \"node_modules/readable-stream/lib/internal/streams/compose.js\"(exports, module) {\n    \"use strict\";\n    var { pipeline } = require_pipeline();\n    var Duplex = require_duplex();\n    var { destroyer } = require_destroy();\n    var { isNodeStream, isReadable, isWritable } = require_utils();\n    var {\n      AbortError,\n      codes: { ERR_INVALID_ARG_VALUE, ERR_MISSING_ARGS },\n    } = require_errors();\n    module.exports = function compose(...streams) {\n      if (streams.length === 0) {\n        throw new ERR_MISSING_ARGS(\"streams\");\n      }\n      if (streams.length === 1) {\n        return Duplex.from(streams[0]);\n      }\n      const orgStreams = [...streams];\n      if (typeof streams[0] === \"function\") {\n        streams[0] = Duplex.from(streams[0]);\n      }\n      if (typeof streams[streams.length - 1] === \"function\") {\n        const idx = streams.length - 1;\n        streams[idx] = Duplex.from(streams[idx]);\n      }\n      for (let n = 0; n < streams.length; ++n) {\n        if (!isNodeStream(streams[n])) {\n          continue;\n        }\n        if (n < streams.length - 1 && !isReadable(streams[n])) {\n          throw new ERR_INVALID_ARG_VALUE(`streams[${n}]`, orgStreams[n], \"must be readable\");\n        }\n        if (n > 0 && !isWritable(streams[n])) {\n          throw new ERR_INVALID_ARG_VALUE(`streams[${n}]`, orgStreams[n], \"must be writable\");\n        }\n      }\n      let ondrain;\n      let onfinish;\n      let onreadable;\n      let onclose;\n      let d;\n      function onfinished(err) {\n        const cb = onclose;\n        onclose = null;\n        if (cb) {\n          cb(err);\n        } else if (err) {\n          d.destroy(err);\n        } else if (!readable && !writable) {\n          d.destroy();\n        }\n      }\n      const head = streams[0];\n      const tail = pipeline(streams, onfinished);\n      const writable = !!isWritable(head);\n      const readable = !!isReadable(tail);\n      d = new Duplex({\n        writableObjectMode: !!(head !== null && head !== void 0 && head.writableObjectMode),\n        readableObjectMode: !!(tail !== null && tail !== void 0 && tail.writableObjectMode),\n        writable,\n        readable,\n      });\n      if (writable) {\n        d._write = function (chunk, encoding, callback) {\n          if (head.write(chunk, encoding)) {\n            callback();\n          } else {\n            ondrain = callback;\n          }\n        };\n        d._final = function (callback) {\n          head.end();\n          onfinish = callback;\n        };\n        head.on(\"drain\", function () {\n          if (ondrain) {\n            const cb = ondrain;\n            ondrain = null;\n            cb();\n          }\n        });\n        tail.on(\"finish\", function () {\n          if (onfinish) {\n            const cb = onfinish;\n            onfinish = null;\n            cb();\n          }\n        });\n      }\n      if (readable) {\n        tail.on(\"readable\", function () {\n          if (onreadable) {\n            const cb = onreadable;\n            onreadable = null;\n            cb();\n          }\n        });\n        tail.on(\"end\", function () {\n          d.push(null);\n        });\n        d._read = function () {\n          while (true) {\n            const buf = tail.read();\n            if (buf === null) {\n              onreadable = d._read;\n              return;\n            }\n            if (!d.push(buf)) {\n              return;\n            }\n          }\n        };\n      }\n      d._destroy = function (err, callback) {\n        if (!err && onclose !== null) {\n          err = new AbortError();\n        }\n        onreadable = null;\n        ondrain = null;\n        onfinish = null;\n        if (onclose === null) {\n          callback(err);\n        } else {\n          onclose = callback;\n          destroyer(tail, err);\n        }\n      };\n      return d;\n    };\n  },\n});\n\n// node_modules/readable-stream/lib/stream/promises.js\nvar require_promises = __commonJS({\n  \"node_modules/readable-stream/lib/stream/promises.js\"(exports, module) {\n    \"use strict\";\n    var { ArrayPrototypePop, Promise: Promise2 } = require_primordials();\n    var { isIterable, isNodeStream } = require_utils();\n    var { pipelineImpl: pl } = require_pipeline();\n    var { finished } = require_end_of_stream();\n    function pipeline(...streams) {\n      return new Promise2((resolve, reject) => {\n        let signal;\n        let end;\n        const lastArg = streams[streams.length - 1];\n        if (lastArg && typeof lastArg === \"object\" && !isNodeStream(lastArg) && !isIterable(lastArg)) {\n          const options = ArrayPrototypePop(streams);\n          signal = options.signal;\n          end = options.end;\n        }\n        pl(\n          streams,\n          (err, value) => {\n            if (err) {\n              reject(err);\n            } else {\n              resolve(value);\n            }\n          },\n          {\n            signal,\n            end,\n          },\n        );\n      });\n    }\n    module.exports = {\n      finished,\n      pipeline,\n    };\n  },\n});\n// node_modules/readable-stream/lib/stream.js\nvar require_stream = __commonJS({\n  \"node_modules/readable-stream/lib/stream.js\"(exports, module) {\n    \"use strict\";\n    var { ObjectDefineProperty, ObjectKeys, ReflectApply } = require_primordials();\n    var {\n      promisify: { custom: customPromisify },\n    } = require_util();\n\n    var { streamReturningOperators, promiseReturningOperators } = require_operators();\n    var {\n      codes: { ERR_ILLEGAL_CONSTRUCTOR },\n    } = require_errors();\n    var compose = require_compose();\n    var { pipeline } = require_pipeline();\n    var { destroyer } = require_destroy();\n    var eos = require_end_of_stream();\n    var promises = require_promises();\n    var utils = require_utils();\n    var Stream = (module.exports = require_legacy().Stream);\n    Stream.isDisturbed = utils.isDisturbed;\n    Stream.isErrored = utils.isErrored;\n    Stream.isWritable = utils.isWritable;\n    Stream.isReadable = utils.isReadable;\n    Stream.Readable = require_readable();\n    for (const key of ObjectKeys(streamReturningOperators)) {\n      let fn = function (...args) {\n        if (new.target) {\n          throw ERR_ILLEGAL_CONSTRUCTOR();\n        }\n        return Stream.Readable.from(ReflectApply(op, this, args));\n      };\n      const op = streamReturningOperators[key];\n      ObjectDefineProperty(fn, \"name\", {\n        value: op.name,\n      });\n      ObjectDefineProperty(fn, \"length\", {\n        value: op.length,\n      });\n      ObjectDefineProperty(Stream.Readable.prototype, key, {\n        value: fn,\n        enumerable: false,\n        configurable: true,\n        writable: true,\n      });\n    }\n    for (const key of ObjectKeys(promiseReturningOperators)) {\n      let fn = function (...args) {\n        if (new.target) {\n          throw ERR_ILLEGAL_CONSTRUCTOR();\n        }\n        return ReflectApply(op, this, args);\n      };\n      const op = promiseReturningOperators[key];\n      ObjectDefineProperty(fn, \"name\", {\n        value: op.name,\n      });\n      ObjectDefineProperty(fn, \"length\", {\n        value: op.length,\n      });\n      ObjectDefineProperty(Stream.Readable.prototype, key, {\n        value: fn,\n        enumerable: false,\n        configurable: true,\n        writable: true,\n      });\n    }\n    Stream.Writable = require_writable();\n    Stream.Duplex = require_duplex();\n    Stream.Transform = require_transform();\n    Stream.PassThrough = require_passthrough();\n    Stream.pipeline = pipeline;\n    var { addAbortSignal } = require_add_abort_signal();\n    Stream.addAbortSignal = addAbortSignal;\n    Stream.finished = eos;\n    Stream.destroy = destroyer;\n    Stream.compose = compose;\n    ObjectDefineProperty(Stream, \"promises\", {\n      configurable: true,\n      enumerable: true,\n      get() {\n        return promises;\n      },\n    });\n    ObjectDefineProperty(pipeline, customPromisify, {\n      enumerable: true,\n      get() {\n        return promises.pipeline;\n      },\n    });\n    ObjectDefineProperty(eos, customPromisify, {\n      enumerable: true,\n      get() {\n        return promises.finished;\n      },\n    });\n    Stream.Stream = Stream;\n    Stream._isUint8Array = function isUint8Array(value) {\n      return value instanceof Uint8Array;\n    };\n    Stream._uint8ArrayToBuffer = function _uint8ArrayToBuffer(chunk) {\n      return new Buffer(chunk.buffer, chunk.byteOffset, chunk.byteLength);\n    };\n  },\n});\n\n// node_modules/readable-stream/lib/ours/index.js\nvar require_ours = __commonJS({\n  \"node_modules/readable-stream/lib/ours/index.js\"(exports, module) {\n    \"use strict\";\n    const CustomStream = require_stream();\n    const promises = require_promises();\n    const originalDestroy = CustomStream.Readable.destroy;\n    module.exports = CustomStream;\n    module.exports._uint8ArrayToBuffer = CustomStream._uint8ArrayToBuffer;\n    module.exports._isUint8Array = CustomStream._isUint8Array;\n    module.exports.isDisturbed = CustomStream.isDisturbed;\n    module.exports.isErrored = CustomStream.isErrored;\n    module.exports.isWritable = CustomStream.isWritable;\n    module.exports.isReadable = CustomStream.isReadable;\n    module.exports.Readable = CustomStream.Readable;\n    module.exports.Writable = CustomStream.Writable;\n    module.exports.Duplex = CustomStream.Duplex;\n    module.exports.Transform = CustomStream.Transform;\n    module.exports.PassThrough = CustomStream.PassThrough;\n    module.exports.addAbortSignal = CustomStream.addAbortSignal;\n    module.exports.finished = CustomStream.finished;\n    module.exports.destroy = CustomStream.destroy;\n    module.exports.destroy = originalDestroy;\n    module.exports.pipeline = CustomStream.pipeline;\n    module.exports.compose = CustomStream.compose;\n\n    module.exports._getNativeReadableStreamPrototype = getNativeReadableStreamPrototype;\n    module.exports.NativeWritable = NativeWritable;\n\n    Object.defineProperty(CustomStream, \"promises\", {\n      configurable: true,\n      enumerable: true,\n      get() {\n        return promises;\n      },\n    });\n    module.exports.Stream = CustomStream.Stream;\n    module.exports.default = module.exports;\n  },\n});\n\n/**\n * Bun native stream wrapper\n *\n * This glue code lets us avoid using ReadableStreams to wrap Bun internal streams\n *\n */\nfunction createNativeStreamReadable(nativeType, Readable) {\n  var [pull, start, cancel, setClose, deinit, updateRef, drainFn] = globalThis[Symbol.for(\"Bun.lazy\")](nativeType);\n\n  var closer = [false];\n  var handleNumberResult = function (nativeReadable, result, view, isClosed) {\n    if (result > 0) {\n      const slice = view.subarray(0, result);\n      const remainder = view.subarray(result);\n      if (slice.byteLength > 0) {\n        nativeReadable.push(slice);\n      }\n\n      if (isClosed) {\n        nativeReadable.push(null);\n      }\n\n      return remainder.byteLength > 0 ? remainder : undefined;\n    }\n\n    if (isClosed) {\n      nativeReadable.push(null);\n    }\n\n    return view;\n  };\n\n  var handleArrayBufferViewResult = function (nativeReadable, result, view, isClosed) {\n    if (result.byteLength > 0) {\n      nativeReadable.push(result);\n    }\n\n    if (isClosed) {\n      nativeReadable.push(null);\n    }\n\n    return view;\n  };\n\n  var DYNAMICALLY_ADJUST_CHUNK_SIZE = process.env.BUN_DISABLE_DYNAMIC_CHUNK_SIZE !== \"1\";\n\n  const finalizer = new FinalizationRegistry(ptr => ptr && deinit(ptr));\n  const MIN_BUFFER_SIZE = 512;\n  var NativeReadable = class NativeReadable extends Readable {\n    #ptr;\n    #refCount = 1;\n    #constructed = false;\n    #remainingChunk = undefined;\n    #highWaterMark;\n    #pendingRead = false;\n    #hasResized = !DYNAMICALLY_ADJUST_CHUNK_SIZE;\n    #unregisterToken;\n    constructor(ptr, options = {}) {\n      super(options);\n      if (typeof options.highWaterMark === \"number\") {\n        this.#highWaterMark = options.highWaterMark;\n      } else {\n        this.#highWaterMark = 256 * 1024;\n      }\n      this.#ptr = ptr;\n      this.#constructed = false;\n      this.#remainingChunk = undefined;\n      this.#pendingRead = false;\n      this.#unregisterToken = {};\n      finalizer.register(this, this.#ptr, this.#unregisterToken);\n    }\n\n    // maxToRead is by default the highWaterMark passed from the Readable.read call to this fn\n    // However, in the case of an fs.ReadStream, we can pass the number of bytes we want to read\n    // which may be significantly less than the actual highWaterMark\n    _read(maxToRead) {\n      __DEBUG__ && debug(\"NativeReadable._read\", this.__id);\n      if (this.#pendingRead) {\n        __DEBUG__ && debug(\"pendingRead is true\", this.__id);\n        return;\n      }\n\n      var ptr = this.#ptr;\n      __DEBUG__ && debug(\"ptr @ NativeReadable._read\", ptr, this.__id);\n      if (ptr === 0) {\n        this.push(null);\n        return;\n      }\n\n      if (!this.#constructed) {\n        __DEBUG__ && debug(\"NativeReadable not constructed yet\", this.__id);\n        this.#internalConstruct(ptr);\n      }\n\n      return this.#internalRead(this.#getRemainingChunk(maxToRead), ptr);\n      // const internalReadRes = this.#internalRead(\n      //   this.#getRemainingChunk(),\n      //   ptr,\n      // );\n      // // REVERT ME\n      // const wrap = new Promise((resolve) => {\n      //   if (!this.internalReadRes?.then) {\n      //     debug(\"internalReadRes not promise\");\n      //     resolve(internalReadRes);\n      //     return;\n      //   }\n      //   internalReadRes.then((result) => {\n      //     debug(\"internalReadRes done\");\n      //     resolve(result);\n      //   });\n      // });\n      // return wrap;\n    }\n\n    #internalConstruct(ptr) {\n      this.#constructed = true;\n      const result = start(ptr, this.#highWaterMark);\n      __DEBUG__ && debug(\"NativeReadable internal `start` result\", result, this.__id);\n\n      if (typeof result === \"number\" && result > 1) {\n        this.#hasResized = true;\n        __DEBUG__ && debug(\"NativeReadable resized\", this.__id);\n\n        this.#highWaterMark = Math.min(this.#highWaterMark, result);\n      }\n\n      if (drainFn) {\n        const drainResult = drainFn(ptr);\n        __DEBUG__ && debug(\"NativeReadable drain result\", drainResult, this.__id);\n        if ((drainResult?.byteLength ?? 0) > 0) {\n          this.push(drainResult);\n        }\n      }\n    }\n\n    // maxToRead can be the highWaterMark (by default) or the remaining amount of the stream to read\n    // This is so the the consumer of the stream can terminate the stream early if they know\n    // how many bytes they want to read (ie. when reading only part of a file)\n    #getRemainingChunk(maxToRead = this.#highWaterMark) {\n      var chunk = this.#remainingChunk;\n      __DEBUG__ && debug(\"chunk @ #getRemainingChunk\", chunk, this.__id);\n      if (chunk?.byteLength ?? 0 < MIN_BUFFER_SIZE) {\n        var size = maxToRead > MIN_BUFFER_SIZE ? maxToRead : MIN_BUFFER_SIZE;\n        this.#remainingChunk = chunk = new Buffer(size);\n      }\n      return chunk;\n    }\n\n    push(result, encoding) {\n      __DEBUG__ && debug(\"NativeReadable push -- result, encoding\", result, encoding, this.__id);\n      return super.push(...arguments);\n    }\n\n    #handleResult(result, view, isClosed) {\n      __DEBUG__ && debug(\"result, isClosed @ #handleResult\", result, isClosed, this.__id);\n\n      if (typeof result === \"number\") {\n        if (result >= this.#highWaterMark && !this.#hasResized && !isClosed) {\n          this.#highWaterMark *= 2;\n          this.#hasResized = true;\n        }\n\n        return handleNumberResult(this, result, view, isClosed);\n      } else if (typeof result === \"boolean\") {\n        this.push(null);\n        return view?.byteLength ?? 0 > 0 ? view : undefined;\n      } else if (ArrayBuffer.isView(result)) {\n        if (result.byteLength >= this.#highWaterMark && !this.#hasResized && !isClosed) {\n          this.#highWaterMark *= 2;\n          this.#hasResized = true;\n          __DEBUG__ && debug(\"Resized\", this.__id);\n        }\n\n        return handleArrayBufferViewResult(this, result, view, isClosed);\n      } else {\n        __DEBUG__ && debug(\"Unknown result type\", result, this.__id);\n        throw new Error(\"Invalid result from pull\");\n      }\n    }\n\n    #internalRead(view, ptr) {\n      __DEBUG__ && debug(\"#internalRead()\", this.__id);\n      closer[0] = false;\n      var result = pull(ptr, view, closer);\n      if (isPromise(result)) {\n        this.#pendingRead = true;\n        return result.then(\n          result => {\n            this.#pendingRead = false;\n            __DEBUG__ && debug(\"pending no longerrrrrrrr (result returned from pull)\", this.__id);\n            this.#remainingChunk = this.#handleResult(result, view, closer[0]);\n          },\n          reason => {\n            __DEBUG__ && debug(\"error from pull\", reason, this.__id);\n            errorOrDestroy(this, reason);\n          },\n        );\n      } else {\n        this.#remainingChunk = this.#handleResult(result, view, closer[0]);\n      }\n    }\n\n    _destroy(error, callback) {\n      var ptr = this.#ptr;\n      if (ptr === 0) {\n        callback(error);\n        return;\n      }\n\n      finalizer.unregister(this.#unregisterToken);\n      this.#ptr = 0;\n      if (updateRef) {\n        updateRef(ptr, false);\n      }\n      __DEBUG__ && debug(\"NativeReadable destroyed\", this.__id);\n      cancel(ptr, error);\n      callback(error);\n    }\n\n    ref() {\n      var ptr = this.#ptr;\n      if (ptr === 0) return;\n      if (this.#refCount++ === 0) {\n        updateRef(ptr, true);\n      }\n    }\n\n    unref() {\n      var ptr = this.#ptr;\n      if (ptr === 0) return;\n      if (this.#refCount-- === 1) {\n        updateRef(ptr, false);\n      }\n    }\n  };\n\n  if (!updateRef) {\n    NativeReadable.prototype.ref = undefined;\n    NativeReadable.prototype.unref = undefined;\n  }\n\n  return NativeReadable;\n}\n\nvar nativeReadableStreamPrototypes = {\n  0: undefined,\n  1: undefined,\n  2: undefined,\n  3: undefined,\n  4: undefined,\n  5: undefined,\n};\nfunction getNativeReadableStreamPrototype(nativeType, Readable) {\n  return (nativeReadableStreamPrototypes[nativeType] ||= createNativeStreamReadable(nativeType, Readable));\n}\n\nfunction getNativeReadableStream(Readable, stream, options) {\n  if (!(stream && typeof stream === \"object\" && stream instanceof ReadableStream)) {\n    return undefined;\n  }\n\n  const native = direct(stream);\n  if (!native) {\n    debug(\"no native readable stream\");\n    return undefined;\n  }\n  const { stream: ptr, data: type } = native;\n\n  const NativeReadable = getNativeReadableStreamPrototype(type, Readable);\n\n  return new NativeReadable(ptr, options);\n}\n/** --- Bun native stream wrapper ---  */\n\nvar Writable = require_writable();\nvar NativeWritable = class NativeWritable extends Writable {\n  #pathOrFdOrSink;\n  #fileSink;\n  #native = true;\n\n  _construct;\n  _destroy;\n  _final;\n\n  constructor(pathOrFdOrSink, options = {}) {\n    super(options);\n\n    this._construct = this.#internalConstruct;\n    this._destroy = this.#internalDestroy;\n    this._final = this.#internalFinal;\n\n    this.#pathOrFdOrSink = pathOrFdOrSink;\n  }\n\n  // These are confusingly two different fns for construct which initially were the same thing because\n  // `_construct` is part of the lifecycle of Writable and is not called lazily,\n  // so we need to separate our _construct for Writable state and actual construction of the write stream\n  #internalConstruct(cb) {\n    this._writableState.constructed = true;\n    this.constructed = true;\n    cb();\n  }\n\n  #lazyConstruct() {\n    // TODO: Turn this check into check for instanceof FileSink\n    if (typeof this.#pathOrFdOrSink === \"object\") {\n      if (typeof this.#pathOrFdOrSink.write === \"function\") {\n        this.#fileSink = this.#pathOrFdOrSink;\n      } else {\n        throw new Error(\"Invalid FileSink\");\n      }\n    } else {\n      this.#fileSink = Bun.file(this.#pathOrFdOrSink).writer();\n    }\n  }\n\n  write(chunk, encoding, cb, native = this.#native) {\n    if (!native) {\n      this.#native = false;\n      return super.write(chunk, encoding, cb);\n    }\n\n    if (!this.#fileSink) {\n      this.#lazyConstruct();\n    }\n    var fileSink = this.#fileSink;\n    var result = fileSink.write(chunk);\n\n    if (isPromise(result)) {\n      // var writePromises = this.#writePromises;\n      // var i = writePromises.length;\n      // writePromises[i] = result;\n      result.then(() => {\n        this.emit(\"drain\");\n        fileSink.flush(true);\n        // // We can't naively use i here because we don't know when writes will resolve necessarily\n        // writePromises.splice(writePromises.indexOf(result), 1);\n      });\n      return false;\n    }\n    fileSink.flush(true);\n    // TODO: Should we just have a calculation based on encoding and length of chunk?\n    if (cb) cb(null, chunk.byteLength);\n    return true;\n  }\n\n  end(chunk, encoding, cb, native = this.#native) {\n    return super.end(chunk, encoding, cb, native);\n  }\n\n  #internalDestroy(error, cb) {\n    this._writableState.destroyed = true;\n    if (cb) cb(error);\n  }\n\n  #internalFinal(cb) {\n    if (this.#fileSink) {\n      this.#fileSink.end();\n    }\n    if (cb) cb();\n  }\n\n  ref() {\n    if (!this.#fileSink) {\n      this.#lazyConstruct();\n    }\n    this.#fileSink.ref();\n  }\n\n  unref() {\n    if (!this.#fileSink) return;\n    this.#fileSink.unref();\n  }\n};\n\nconst stream_exports = require_ours();\nstream_exports[Symbol.for(\"CommonJS\")] = 0;\nstream_exports[Symbol.for(\"::bunternal::\")] = { _ReadableFromWeb };\nexport default stream_exports;\nexport var _uint8ArrayToBuffer = stream_exports._uint8ArrayToBuffer;\nexport var _isUint8Array = stream_exports._isUint8Array;\nexport var isDisturbed = stream_exports.isDisturbed;\nexport var isErrored = stream_exports.isErrored;\nexport var isWritable = stream_exports.isWritable;\nexport var isReadable = stream_exports.isReadable;\nexport var Readable = stream_exports.Readable;\nexport var Writable = stream_exports.Writable;\nexport var Duplex = stream_exports.Duplex;\nexport var Transform = stream_exports.Transform;\nexport var PassThrough = stream_exports.PassThrough;\nexport var addAbortSignal = stream_exports.addAbortSignal;\nexport var finished = stream_exports.finished;\nexport var destroy = stream_exports.destroy;\nexport var pipeline = stream_exports.pipeline;\nexport var compose = stream_exports.compose;\nexport var Stream = stream_exports.Stream;\nexport var eos = (stream_exports[\"eos\"] = require_end_of_stream);\nexport var _getNativeReadableStreamPrototype = stream_exports._getNativeReadableStreamPrototype;\nexport var NativeWritable = stream_exports.NativeWritable;\nexport var promises = Stream.promise;\n",
  "// Hardcoded module \"node:stream\" / \"readable-stream\"\n// \"readable-stream\" npm package\n// just transpiled\nvar { isPromise, isCallable, direct, Object } = import.meta.primordials;\n\nglobalThis.__IDS_TO_TRACK = process.env.DEBUG_TRACK_EE?.length\n  ? process.env.DEBUG_TRACK_EE.split(\",\")\n  : process.env.DEBUG_STREAMS?.length\n  ? process.env.DEBUG_STREAMS.split(\",\")\n  : null;\n\n// Separating DEBUG, DEBUG_STREAMS and DEBUG_TRACK_EE env vars makes it easier to focus on the\n// events in this file rather than all debug output across all files\n\n// You can include comma-delimited IDs as the value to either DEBUG_STREAMS or DEBUG_TRACK_EE and it will track\n// The events and/or all of the outputs for the given stream IDs assigned at stream construction\n// By default, child_process gives\n\nconst __TRACK_EE__ = !!process.env.DEBUG_TRACK_EE;\nconst __DEBUG__ = !!(process.env.DEBUG || process.env.DEBUG_STREAMS || __TRACK_EE__);\n\nvar debug = __DEBUG__\n  ? globalThis.__IDS_TO_TRACK\n    ? // If we are tracking IDs for debug event emitters, we should prefix the debug output with the ID\n      (...args) => {\n        const lastItem = args[args.length - 1];\n        if (!globalThis.__IDS_TO_TRACK.includes(lastItem)) return;\n        console.log(`ID: ${lastItem}`, ...args.slice(0, -1));\n      }\n    : (...args) => console.log(...args.slice(0, -1))\n  : () => {};\n\nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __ObjectSetPrototypeOf = Object.setPrototypeOf;\nvar __require = x => import.meta.require(x);\n\nvar _EE = __require(\"bun:events_native\");\n\nfunction DebugEventEmitter(opts) {\n  if (!(this instanceof DebugEventEmitter)) return new DebugEventEmitter(opts);\n  _EE.call(this, opts);\n  const __id = opts.__id;\n  if (__id) {\n    __defProp(this, \"__id\", {\n      value: __id,\n      readable: true,\n      writable: false,\n      enumerable: false,\n    });\n  }\n}\n\n__ObjectSetPrototypeOf(DebugEventEmitter.prototype, _EE.prototype);\n__ObjectSetPrototypeOf(DebugEventEmitter, _EE);\n\nDebugEventEmitter.prototype.emit = function (event, ...args) {\n  var __id = this.__id;\n  if (__id) {\n    debug(\"emit\", event, ...args, __id);\n  } else {\n    debug(\"emit\", event, ...args);\n  }\n  return _EE.prototype.emit.call(this, event, ...args);\n};\nDebugEventEmitter.prototype.on = function (event, handler) {\n  var __id = this.__id;\n  if (__id) {\n    debug(\"on\", event, \"added\", __id);\n  } else {\n    debug(\"on\", event, \"added\");\n  }\n  return _EE.prototype.on.call(this, event, handler);\n};\nDebugEventEmitter.prototype.addListener = function (event, handler) {\n  return this.on(event, handler);\n};\n\nvar __commonJS = (cb, mod) =>\n  function __require2() {\n    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;\n  };\nvar __copyProps = (to, from, except, desc) => {\n  if ((from && typeof from === \"object\") || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, {\n          get: () => from[key],\n          set: val => (from[key] = val),\n          enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable,\n          configurable: true,\n        });\n  }\n  return to;\n};\n\nvar runOnNextTick = process.nextTick;\n\nfunction isReadableStream(value) {\n  return typeof value === \"object\" && value !== null && value instanceof ReadableStream;\n}\n\nfunction validateBoolean(value, name) {\n  if (typeof value !== \"boolean\") throw new ERR_INVALID_ARG_TYPE(name, \"boolean\", value);\n}\n\n/**\n * @callback validateObject\n * @param {*} value\n * @param {string} name\n * @param {{\n *   allowArray?: boolean,\n *   allowFunction?: boolean,\n *   nullable?: boolean\n * }} [options]\n */\n\n/** @type {validateObject} */\nconst validateObject = (value, name, options = null) => {\n  const allowArray = options?.allowArray ?? false;\n  const allowFunction = options?.allowFunction ?? false;\n  const nullable = options?.nullable ?? false;\n  if (\n    (!nullable && value === null) ||\n    (!allowArray && ArrayIsArray(value)) ||\n    (typeof value !== \"object\" && (!allowFunction || typeof value !== \"function\"))\n  ) {\n    throw new ERR_INVALID_ARG_TYPE(name, \"Object\", value);\n  }\n};\n\n/**\n * @callback validateString\n * @param {*} value\n * @param {string} name\n * @returns {asserts value is string}\n */\n\n/** @type {validateString} */\nfunction validateString(value, name) {\n  if (typeof value !== \"string\") throw new ERR_INVALID_ARG_TYPE(name, \"string\", value);\n}\n\nvar ArrayIsArray = Array.isArray;\n\n//------------------------------------------------------------------------------\n// Node error polyfills\n//------------------------------------------------------------------------------\n\nfunction ERR_INVALID_ARG_TYPE(name, type, value) {\n  return new Error(`The argument '${name}' is invalid. Received '${value}' for type '${type}'`);\n}\n\nfunction ERR_INVALID_ARG_VALUE(name, value, reason) {\n  return new Error(`The value '${value}' is invalid for argument '${name}'. Reason: ${reason}`);\n}\n\n// node_modules/readable-stream/lib/ours/primordials.js\nvar require_primordials = __commonJS({\n  \"node_modules/readable-stream/lib/ours/primordials.js\"(exports, module) {\n    \"use strict\";\n    module.exports = {\n      ArrayIsArray(self) {\n        return Array.isArray(self);\n      },\n      ArrayPrototypeIncludes(self, el) {\n        return self.includes(el);\n      },\n      ArrayPrototypeIndexOf(self, el) {\n        return self.indexOf(el);\n      },\n      ArrayPrototypeJoin(self, sep) {\n        return self.join(sep);\n      },\n      ArrayPrototypeMap(self, fn) {\n        return self.map(fn);\n      },\n      ArrayPrototypePop(self, el) {\n        return self.pop(el);\n      },\n      ArrayPrototypePush(self, el) {\n        return self.push(el);\n      },\n      ArrayPrototypeSlice(self, start, end) {\n        return self.slice(start, end);\n      },\n      Error,\n      FunctionPrototypeCall(fn, thisArgs, ...args) {\n        return fn.call(thisArgs, ...args);\n      },\n      FunctionPrototypeSymbolHasInstance(self, instance) {\n        return Function.prototype[Symbol.hasInstance].call(self, instance);\n      },\n      MathFloor: Math.floor,\n      Number,\n      NumberIsInteger: Number.isInteger,\n      NumberIsNaN: Number.isNaN,\n      NumberMAX_SAFE_INTEGER: Number.MAX_SAFE_INTEGER,\n      NumberMIN_SAFE_INTEGER: Number.MIN_SAFE_INTEGER,\n      NumberParseInt: Number.parseInt,\n      ObjectDefineProperties(self, props) {\n        return Object.defineProperties(self, props);\n      },\n      ObjectDefineProperty(self, name, prop) {\n        return Object.defineProperty(self, name, prop);\n      },\n      ObjectGetOwnPropertyDescriptor(self, name) {\n        return Object.getOwnPropertyDescriptor(self, name);\n      },\n      ObjectKeys(obj) {\n        return Object.keys(obj);\n      },\n      ObjectSetPrototypeOf(target, proto) {\n        return Object.setPrototypeOf(target, proto);\n      },\n      Promise,\n      PromisePrototypeCatch(self, fn) {\n        return self.catch(fn);\n      },\n      PromisePrototypeThen(self, thenFn, catchFn) {\n        return self.then(thenFn, catchFn);\n      },\n      PromiseReject(err) {\n        return Promise.reject(err);\n      },\n      ReflectApply: Reflect.apply,\n      RegExpPrototypeTest(self, value) {\n        return self.test(value);\n      },\n      SafeSet: Set,\n      String,\n      StringPrototypeSlice(self, start, end) {\n        return self.slice(start, end);\n      },\n      StringPrototypeToLowerCase(self) {\n        return self.toLowerCase();\n      },\n      StringPrototypeToUpperCase(self) {\n        return self.toUpperCase();\n      },\n      StringPrototypeTrim(self) {\n        return self.trim();\n      },\n      Symbol,\n      SymbolAsyncIterator: Symbol.asyncIterator,\n      SymbolHasInstance: Symbol.hasInstance,\n      SymbolIterator: Symbol.iterator,\n      TypedArrayPrototypeSet(self, buf, len) {\n        return self.set(buf, len);\n      },\n      Uint8Array,\n    };\n  },\n});\n// node_modules/readable-stream/lib/ours/util.js\nvar require_util = __commonJS({\n  \"node_modules/readable-stream/lib/ours/util.js\"(exports, module) {\n    \"use strict\";\n    var bufferModule = __require(\"buffer\");\n    var AsyncFunction = Object.getPrototypeOf(async function () {}).constructor;\n    var Blob = globalThis.Blob || bufferModule.Blob;\n    var isBlob =\n      typeof Blob !== \"undefined\"\n        ? function isBlob2(b) {\n            return b instanceof Blob;\n          }\n        : function isBlob2(b) {\n            return false;\n          };\n    var AggregateError = class extends Error {\n      constructor(errors) {\n        if (!Array.isArray(errors)) {\n          throw new TypeError(`Expected input to be an Array, got ${typeof errors}`);\n        }\n        let message = \"\";\n        for (let i = 0; i < errors.length; i++) {\n          message += `    ${errors[i].stack}\n`;\n        }\n        super(message);\n        this.name = \"AggregateError\";\n        this.errors = errors;\n      }\n    };\n    module.exports = {\n      AggregateError,\n      once(callback) {\n        let called = false;\n        return function (...args) {\n          if (called) {\n            return;\n          }\n          called = true;\n          callback.apply(this, args);\n        };\n      },\n      createDeferredPromise: function () {\n        let resolve;\n        let reject;\n        const promise = new Promise((res, rej) => {\n          resolve = res;\n          reject = rej;\n        });\n        return {\n          promise,\n          resolve,\n          reject,\n        };\n      },\n      promisify(fn) {\n        return new Promise((resolve, reject) => {\n          fn((err, ...args) => {\n            if (err) {\n              return reject(err);\n            }\n            return resolve(...args);\n          });\n        });\n      },\n      debuglog() {\n        return function () {};\n      },\n      format(format, ...args) {\n        return format.replace(/%([sdifj])/g, function (...[_unused, type]) {\n          const replacement = args.shift();\n          if (type === \"f\") {\n            return replacement.toFixed(6);\n          } else if (type === \"j\") {\n            return JSON.stringify(replacement);\n          } else if (type === \"s\" && typeof replacement === \"object\") {\n            const ctor = replacement.constructor !== Object ? replacement.constructor.name : \"\";\n            return `${ctor} {}`.trim();\n          } else {\n            return replacement.toString();\n          }\n        });\n      },\n      inspect(value) {\n        switch (typeof value) {\n          case \"string\":\n            if (value.includes(\"'\")) {\n              if (!value.includes('\"')) {\n                return `\"${value}\"`;\n              } else if (!value.includes(\"`\") && !value.includes(\"${\")) {\n                return `\\`${value}\\``;\n              }\n            }\n            return `'${value}'`;\n          case \"number\":\n            if (isNaN(value)) {\n              return \"NaN\";\n            } else if (Object.is(value, -0)) {\n              return String(value);\n            }\n            return value;\n          case \"bigint\":\n            return `${String(value)}n`;\n          case \"boolean\":\n          case \"undefined\":\n            return String(value);\n          case \"object\":\n            return \"{}\";\n        }\n      },\n      types: {\n        isAsyncFunction(fn) {\n          return fn instanceof AsyncFunction;\n        },\n        isArrayBufferView(arr) {\n          return ArrayBuffer.isView(arr);\n        },\n      },\n      isBlob,\n    };\n    module.exports.promisify.custom = Symbol.for(\"nodejs.util.promisify.custom\");\n  },\n});\n\n// node_modules/readable-stream/lib/ours/errors.js\nvar require_errors = __commonJS({\n  \"node_modules/readable-stream/lib/ours/errors.js\"(exports, module) {\n    \"use strict\";\n    var { format, inspect, AggregateError: CustomAggregateError } = require_util();\n    var AggregateError = globalThis.AggregateError || CustomAggregateError;\n    var kIsNodeError = Symbol(\"kIsNodeError\");\n    var kTypes = [\"string\", \"function\", \"number\", \"object\", \"Function\", \"Object\", \"boolean\", \"bigint\", \"symbol\"];\n    var classRegExp = /^([A-Z][a-z0-9]*)+$/;\n    var nodeInternalPrefix = \"__node_internal_\";\n    var codes = {};\n    function assert(value, message) {\n      if (!value) {\n        throw new codes.ERR_INTERNAL_ASSERTION(message);\n      }\n    }\n    function addNumericalSeparator(val) {\n      let res = \"\";\n      let i = val.length;\n      const start = val[0] === \"-\" ? 1 : 0;\n      for (; i >= start + 4; i -= 3) {\n        res = `_${val.slice(i - 3, i)}${res}`;\n      }\n      return `${val.slice(0, i)}${res}`;\n    }\n    function getMessage(key, msg, args) {\n      if (typeof msg === \"function\") {\n        assert(\n          msg.length <= args.length,\n          `Code: ${key}; The provided arguments length (${args.length}) does not match the required ones (${msg.length}).`,\n        );\n        return msg(...args);\n      }\n      const expectedLength = (msg.match(/%[dfijoOs]/g) || []).length;\n      assert(\n        expectedLength === args.length,\n        `Code: ${key}; The provided arguments length (${args.length}) does not match the required ones (${expectedLength}).`,\n      );\n      if (args.length === 0) {\n        return msg;\n      }\n      return format(msg, ...args);\n    }\n    function E(code, message, Base) {\n      if (!Base) {\n        Base = Error;\n      }\n      class NodeError extends Base {\n        constructor(...args) {\n          super(getMessage(code, message, args));\n        }\n        toString() {\n          return `${this.name} [${code}]: ${this.message}`;\n        }\n      }\n      Object.defineProperties(NodeError.prototype, {\n        name: {\n          value: Base.name,\n          writable: true,\n          enumerable: false,\n          configurable: true,\n        },\n        toString: {\n          value() {\n            return `${this.name} [${code}]: ${this.message}`;\n          },\n          writable: true,\n          enumerable: false,\n          configurable: true,\n        },\n      });\n      NodeError.prototype.code = code;\n      NodeError.prototype[kIsNodeError] = true;\n      codes[code] = NodeError;\n    }\n    function hideStackFrames(fn) {\n      const hidden = nodeInternalPrefix + fn.name;\n      Object.defineProperty(fn, \"name\", {\n        value: hidden,\n      });\n      return fn;\n    }\n    function aggregateTwoErrors(innerError, outerError) {\n      if (innerError && outerError && innerError !== outerError) {\n        if (Array.isArray(outerError.errors)) {\n          outerError.errors.push(innerError);\n          return outerError;\n        }\n        const err = new AggregateError([outerError, innerError], outerError.message);\n        err.code = outerError.code;\n        return err;\n      }\n      return innerError || outerError;\n    }\n    var AbortError = class extends Error {\n      constructor(message = \"The operation was aborted\", options = void 0) {\n        if (options !== void 0 && typeof options !== \"object\") {\n          throw new codes.ERR_INVALID_ARG_TYPE(\"options\", \"Object\", options);\n        }\n        super(message, options);\n        this.code = \"ABORT_ERR\";\n        this.name = \"AbortError\";\n      }\n    };\n    E(\"ERR_ASSERTION\", \"%s\", Error);\n    E(\n      \"ERR_INVALID_ARG_TYPE\",\n      (name, expected, actual) => {\n        assert(typeof name === \"string\", \"'name' must be a string\");\n        if (!Array.isArray(expected)) {\n          expected = [expected];\n        }\n        let msg = \"The \";\n        if (name.endsWith(\" argument\")) {\n          msg += `${name} `;\n        } else {\n          msg += `\"${name}\" ${name.includes(\".\") ? \"property\" : \"argument\"} `;\n        }\n        msg += \"must be \";\n        const types = [];\n        const instances = [];\n        const other = [];\n        for (const value of expected) {\n          assert(typeof value === \"string\", \"All expected entries have to be of type string\");\n          if (kTypes.includes(value)) {\n            types.push(value.toLowerCase());\n          } else if (classRegExp.test(value)) {\n            instances.push(value);\n          } else {\n            assert(value !== \"object\", 'The value \"object\" should be written as \"Object\"');\n            other.push(value);\n          }\n        }\n        if (instances.length > 0) {\n          const pos = types.indexOf(\"object\");\n          if (pos !== -1) {\n            types.splice(types, pos, 1);\n            instances.push(\"Object\");\n          }\n        }\n        if (types.length > 0) {\n          switch (types.length) {\n            case 1:\n              msg += `of type ${types[0]}`;\n              break;\n            case 2:\n              msg += `one of type ${types[0]} or ${types[1]}`;\n              break;\n            default: {\n              const last = types.pop();\n              msg += `one of type ${types.join(\", \")}, or ${last}`;\n            }\n          }\n          if (instances.length > 0 || other.length > 0) {\n            msg += \" or \";\n          }\n        }\n        if (instances.length > 0) {\n          switch (instances.length) {\n            case 1:\n              msg += `an instance of ${instances[0]}`;\n              break;\n            case 2:\n              msg += `an instance of ${instances[0]} or ${instances[1]}`;\n              break;\n            default: {\n              const last = instances.pop();\n              msg += `an instance of ${instances.join(\", \")}, or ${last}`;\n            }\n          }\n          if (other.length > 0) {\n            msg += \" or \";\n          }\n        }\n        switch (other.length) {\n          case 0:\n            break;\n          case 1:\n            if (other[0].toLowerCase() !== other[0]) {\n              msg += \"an \";\n            }\n            msg += `${other[0]}`;\n            break;\n          case 2:\n            msg += `one of ${other[0]} or ${other[1]}`;\n            break;\n          default: {\n            const last = other.pop();\n            msg += `one of ${other.join(\", \")}, or ${last}`;\n          }\n        }\n        if (actual == null) {\n          msg += `. Received ${actual}`;\n        } else if (typeof actual === \"function\" && actual.name) {\n          msg += `. Received function ${actual.name}`;\n        } else if (typeof actual === \"object\") {\n          var _actual$constructor;\n          if (\n            (_actual$constructor = actual.constructor) !== null &&\n            _actual$constructor !== void 0 &&\n            _actual$constructor.name\n          ) {\n            msg += `. Received an instance of ${actual.constructor.name}`;\n          } else {\n            const inspected = inspect(actual, {\n              depth: -1,\n            });\n            msg += `. Received ${inspected}`;\n          }\n        } else {\n          let inspected = inspect(actual, {\n            colors: false,\n          });\n          if (inspected.length > 25) {\n            inspected = `${inspected.slice(0, 25)}...`;\n          }\n          msg += `. Received type ${typeof actual} (${inspected})`;\n        }\n        return msg;\n      },\n      TypeError,\n    );\n    E(\n      \"ERR_INVALID_ARG_VALUE\",\n      (name, value, reason = \"is invalid\") => {\n        let inspected = inspect(value);\n        if (inspected.length > 128) {\n          inspected = inspected.slice(0, 128) + \"...\";\n        }\n        const type = name.includes(\".\") ? \"property\" : \"argument\";\n        return `The ${type} '${name}' ${reason}. Received ${inspected}`;\n      },\n      TypeError,\n    );\n    E(\n      \"ERR_INVALID_RETURN_VALUE\",\n      (input, name, value) => {\n        var _value$constructor;\n        const type =\n          value !== null &&\n          value !== void 0 &&\n          (_value$constructor = value.constructor) !== null &&\n          _value$constructor !== void 0 &&\n          _value$constructor.name\n            ? `instance of ${value.constructor.name}`\n            : `type ${typeof value}`;\n        return `Expected ${input} to be returned from the \"${name}\" function but got ${type}.`;\n      },\n      TypeError,\n    );\n    E(\n      \"ERR_MISSING_ARGS\",\n      (...args) => {\n        assert(args.length > 0, \"At least one arg needs to be specified\");\n        let msg;\n        const len = args.length;\n        args = (Array.isArray(args) ? args : [args]).map(a => `\"${a}\"`).join(\" or \");\n        switch (len) {\n          case 1:\n            msg += `The ${args[0]} argument`;\n            break;\n          case 2:\n            msg += `The ${args[0]} and ${args[1]} arguments`;\n            break;\n          default:\n            {\n              const last = args.pop();\n              msg += `The ${args.join(\", \")}, and ${last} arguments`;\n            }\n            break;\n        }\n        return `${msg} must be specified`;\n      },\n      TypeError,\n    );\n    E(\n      \"ERR_OUT_OF_RANGE\",\n      (str, range, input) => {\n        assert(range, 'Missing \"range\" argument');\n        let received;\n        if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {\n          received = addNumericalSeparator(String(input));\n        } else if (typeof input === \"bigint\") {\n          received = String(input);\n          if (input > 2n ** 32n || input < -(2n ** 32n)) {\n            received = addNumericalSeparator(received);\n          }\n          received += \"n\";\n        } else {\n          received = inspect(input);\n        }\n        return `The value of \"${str}\" is out of range. It must be ${range}. Received ${received}`;\n      },\n      RangeError,\n    );\n    E(\"ERR_MULTIPLE_CALLBACK\", \"Callback called multiple times\", Error);\n    E(\"ERR_METHOD_NOT_IMPLEMENTED\", \"The %s method is not implemented\", Error);\n    E(\"ERR_STREAM_ALREADY_FINISHED\", \"Cannot call %s after a stream was finished\", Error);\n    E(\"ERR_STREAM_CANNOT_PIPE\", \"Cannot pipe, not readable\", Error);\n    E(\"ERR_STREAM_DESTROYED\", \"Cannot call %s after a stream was destroyed\", Error);\n    E(\"ERR_STREAM_NULL_VALUES\", \"May not write null values to stream\", TypeError);\n    E(\"ERR_STREAM_PREMATURE_CLOSE\", \"Premature close\", Error);\n    E(\"ERR_STREAM_PUSH_AFTER_EOF\", \"stream.push() after EOF\", Error);\n    E(\"ERR_STREAM_UNSHIFT_AFTER_END_EVENT\", \"stream.unshift() after end event\", Error);\n    E(\"ERR_STREAM_WRITE_AFTER_END\", \"write after end\", Error);\n    E(\"ERR_UNKNOWN_ENCODING\", \"Unknown encoding: %s\", TypeError);\n    module.exports = {\n      AbortError,\n      aggregateTwoErrors: hideStackFrames(aggregateTwoErrors),\n      hideStackFrames,\n      codes,\n    };\n  },\n});\n\n// node_modules/readable-stream/lib/internal/validators.js\nvar require_validators = __commonJS({\n  \"node_modules/readable-stream/lib/internal/validators.js\"(exports, module) {\n    \"use strict\";\n    var {\n      ArrayIsArray,\n      ArrayPrototypeIncludes,\n      ArrayPrototypeJoin,\n      ArrayPrototypeMap,\n      NumberIsInteger,\n      NumberMAX_SAFE_INTEGER,\n      NumberMIN_SAFE_INTEGER,\n      NumberParseInt,\n      RegExpPrototypeTest,\n      String: String2,\n      StringPrototypeToUpperCase,\n      StringPrototypeTrim,\n    } = require_primordials();\n    var {\n      hideStackFrames,\n      codes: { ERR_SOCKET_BAD_PORT, ERR_INVALID_ARG_TYPE, ERR_INVALID_ARG_VALUE, ERR_OUT_OF_RANGE, ERR_UNKNOWN_SIGNAL },\n    } = require_errors();\n    var { normalizeEncoding } = require_util();\n    var { isAsyncFunction, isArrayBufferView } = require_util().types;\n    var signals = {};\n    function isInt32(value) {\n      return value === (value | 0);\n    }\n    function isUint32(value) {\n      return value === value >>> 0;\n    }\n    var octalReg = /^[0-7]+$/;\n    var modeDesc = \"must be a 32-bit unsigned integer or an octal string\";\n    function parseFileMode(value, name, def) {\n      if (typeof value === \"undefined\") {\n        value = def;\n      }\n      if (typeof value === \"string\") {\n        if (!RegExpPrototypeTest(octalReg, value)) {\n          throw new ERR_INVALID_ARG_VALUE(name, value, modeDesc);\n        }\n        value = NumberParseInt(value, 8);\n      }\n      validateInt32(value, name, 0, 2 ** 32 - 1);\n      return value;\n    }\n    var validateInteger = hideStackFrames((value, name, min = NumberMIN_SAFE_INTEGER, max = NumberMAX_SAFE_INTEGER) => {\n      if (typeof value !== \"number\") throw new ERR_INVALID_ARG_TYPE(name, \"number\", value);\n      if (!NumberIsInteger(value)) throw new ERR_OUT_OF_RANGE(name, \"an integer\", value);\n      if (value < min || value > max) throw new ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value);\n    });\n    var validateInt32 = hideStackFrames((value, name, min = -2147483648, max = 2147483647) => {\n      if (typeof value !== \"number\") {\n        throw new ERR_INVALID_ARG_TYPE(name, \"number\", value);\n      }\n      if (!isInt32(value)) {\n        if (!NumberIsInteger(value)) {\n          throw new ERR_OUT_OF_RANGE(name, \"an integer\", value);\n        }\n        throw new ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value);\n      }\n      if (value < min || value > max) {\n        throw new ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value);\n      }\n    });\n    var validateUint32 = hideStackFrames((value, name, positive) => {\n      if (typeof value !== \"number\") {\n        throw new ERR_INVALID_ARG_TYPE(name, \"number\", value);\n      }\n      if (!isUint32(value)) {\n        if (!NumberIsInteger(value)) {\n          throw new ERR_OUT_OF_RANGE(name, \"an integer\", value);\n        }\n        const min = positive ? 1 : 0;\n        throw new ERR_OUT_OF_RANGE(name, `>= ${min} && < 4294967296`, value);\n      }\n      if (positive && value === 0) {\n        throw new ERR_OUT_OF_RANGE(name, \">= 1 && < 4294967296\", value);\n      }\n    });\n    function validateString(value, name) {\n      if (typeof value !== \"string\") throw new ERR_INVALID_ARG_TYPE(name, \"string\", value);\n    }\n    function validateNumber(value, name) {\n      if (typeof value !== \"number\") throw new ERR_INVALID_ARG_TYPE(name, \"number\", value);\n    }\n    var validateOneOf = hideStackFrames((value, name, oneOf) => {\n      if (!ArrayPrototypeIncludes(oneOf, value)) {\n        const allowed = ArrayPrototypeJoin(\n          ArrayPrototypeMap(oneOf, v => (typeof v === \"string\" ? `'${v}'` : String2(v))),\n          \", \",\n        );\n        const reason = \"must be one of: \" + allowed;\n        throw new ERR_INVALID_ARG_VALUE(name, value, reason);\n      }\n    });\n    function validateBoolean(value, name) {\n      if (typeof value !== \"boolean\") throw new ERR_INVALID_ARG_TYPE(name, \"boolean\", value);\n    }\n    var validateObject = hideStackFrames((value, name, options) => {\n      const useDefaultOptions = options == null;\n      const allowArray = useDefaultOptions ? false : options.allowArray;\n      const allowFunction = useDefaultOptions ? false : options.allowFunction;\n      const nullable = useDefaultOptions ? false : options.nullable;\n      if (\n        (!nullable && value === null) ||\n        (!allowArray && ArrayIsArray(value)) ||\n        (typeof value !== \"object\" && (!allowFunction || typeof value !== \"function\"))\n      ) {\n        throw new ERR_INVALID_ARG_TYPE(name, \"Object\", value);\n      }\n    });\n    var validateArray = hideStackFrames((value, name, minLength = 0) => {\n      if (!ArrayIsArray(value)) {\n        throw new ERR_INVALID_ARG_TYPE(name, \"Array\", value);\n      }\n      if (value.length < minLength) {\n        const reason = `must be longer than ${minLength}`;\n        throw new ERR_INVALID_ARG_VALUE(name, value, reason);\n      }\n    });\n    function validateSignalName(signal, name = \"signal\") {\n      validateString(signal, name);\n      if (signals[signal] === void 0) {\n        if (signals[StringPrototypeToUpperCase(signal)] !== void 0) {\n          throw new ERR_UNKNOWN_SIGNAL(signal + \" (signals must use all capital letters)\");\n        }\n        throw new ERR_UNKNOWN_SIGNAL(signal);\n      }\n    }\n    var validateBuffer = hideStackFrames((buffer, name = \"buffer\") => {\n      if (!isArrayBufferView(buffer)) {\n        throw new ERR_INVALID_ARG_TYPE(name, [\"Buffer\", \"TypedArray\", \"DataView\"], buffer);\n      }\n    });\n    function validateEncoding(data, encoding) {\n      const normalizedEncoding = normalizeEncoding(encoding);\n      const length = data.length;\n      if (normalizedEncoding === \"hex\" && length % 2 !== 0) {\n        throw new ERR_INVALID_ARG_VALUE(\"encoding\", encoding, `is invalid for data of length ${length}`);\n      }\n    }\n    function validatePort(port, name = \"Port\", allowZero = true) {\n      if (\n        (typeof port !== \"number\" && typeof port !== \"string\") ||\n        (typeof port === \"string\" && StringPrototypeTrim(port).length === 0) ||\n        +port !== +port >>> 0 ||\n        port > 65535 ||\n        (port === 0 && !allowZero)\n      ) {\n        throw new ERR_SOCKET_BAD_PORT(name, port, allowZero);\n      }\n      return port | 0;\n    }\n    var validateAbortSignal = hideStackFrames((signal, name) => {\n      if (signal !== void 0 && (signal === null || typeof signal !== \"object\" || !(\"aborted\" in signal))) {\n        throw new ERR_INVALID_ARG_TYPE(name, \"AbortSignal\", signal);\n      }\n    });\n    var validateFunction = hideStackFrames((value, name) => {\n      if (typeof value !== \"function\") throw new ERR_INVALID_ARG_TYPE(name, \"Function\", value);\n    });\n    var validatePlainFunction = hideStackFrames((value, name) => {\n      if (typeof value !== \"function\" || isAsyncFunction(value))\n        throw new ERR_INVALID_ARG_TYPE(name, \"Function\", value);\n    });\n    var validateUndefined = hideStackFrames((value, name) => {\n      if (value !== void 0) throw new ERR_INVALID_ARG_TYPE(name, \"undefined\", value);\n    });\n    module.exports = {\n      isInt32,\n      isUint32,\n      parseFileMode,\n      validateArray,\n      validateBoolean,\n      validateBuffer,\n      validateEncoding,\n      validateFunction,\n      validateInt32,\n      validateInteger,\n      validateNumber,\n      validateObject,\n      validateOneOf,\n      validatePlainFunction,\n      validatePort,\n      validateSignalName,\n      validateString,\n      validateUint32,\n      validateUndefined,\n      validateAbortSignal,\n    };\n  },\n});\n\n// node_modules/readable-stream/lib/internal/streams/utils.js\nvar require_utils = __commonJS({\n  \"node_modules/readable-stream/lib/internal/streams/utils.js\"(exports, module) {\n    \"use strict\";\n    var { Symbol: Symbol2, SymbolAsyncIterator, SymbolIterator } = require_primordials();\n    var kDestroyed = Symbol2(\"kDestroyed\");\n    var kIsErrored = Symbol2(\"kIsErrored\");\n    var kIsReadable = Symbol2(\"kIsReadable\");\n    var kIsDisturbed = Symbol2(\"kIsDisturbed\");\n    function isReadableNodeStream(obj, strict = false) {\n      var _obj$_readableState;\n      return !!(\n        obj &&\n        typeof obj.pipe === \"function\" &&\n        typeof obj.on === \"function\" &&\n        (!strict || (typeof obj.pause === \"function\" && typeof obj.resume === \"function\")) &&\n        (!obj._writableState ||\n          ((_obj$_readableState = obj._readableState) === null || _obj$_readableState === void 0\n            ? void 0\n            : _obj$_readableState.readable) !== false) &&\n        (!obj._writableState || obj._readableState)\n      );\n    }\n    function isWritableNodeStream(obj) {\n      var _obj$_writableState;\n      return !!(\n        obj &&\n        typeof obj.write === \"function\" &&\n        typeof obj.on === \"function\" &&\n        (!obj._readableState ||\n          ((_obj$_writableState = obj._writableState) === null || _obj$_writableState === void 0\n            ? void 0\n            : _obj$_writableState.writable) !== false)\n      );\n    }\n    function isDuplexNodeStream(obj) {\n      return !!(\n        obj &&\n        typeof obj.pipe === \"function\" &&\n        obj._readableState &&\n        typeof obj.on === \"function\" &&\n        typeof obj.write === \"function\"\n      );\n    }\n    function isNodeStream(obj) {\n      return (\n        obj &&\n        (obj._readableState ||\n          obj._writableState ||\n          (typeof obj.write === \"function\" && typeof obj.on === \"function\") ||\n          (typeof obj.pipe === \"function\" && typeof obj.on === \"function\"))\n      );\n    }\n    function isIterable(obj, isAsync) {\n      if (obj == null) return false;\n      if (isAsync === true) return typeof obj[SymbolAsyncIterator] === \"function\";\n      if (isAsync === false) return typeof obj[SymbolIterator] === \"function\";\n      return typeof obj[SymbolAsyncIterator] === \"function\" || typeof obj[SymbolIterator] === \"function\";\n    }\n    function isDestroyed(stream) {\n      if (!isNodeStream(stream)) return null;\n      const wState = stream._writableState;\n      const rState = stream._readableState;\n      const state = wState || rState;\n      return !!(stream.destroyed || stream[kDestroyed] || (state !== null && state !== void 0 && state.destroyed));\n    }\n    function isWritableEnded(stream) {\n      if (!isWritableNodeStream(stream)) return null;\n      if (stream.writableEnded === true) return true;\n      const wState = stream._writableState;\n      if (wState !== null && wState !== void 0 && wState.errored) return false;\n      if (typeof (wState === null || wState === void 0 ? void 0 : wState.ended) !== \"boolean\") return null;\n      return wState.ended;\n    }\n    function isWritableFinished(stream, strict) {\n      if (!isWritableNodeStream(stream)) return null;\n      if (stream.writableFinished === true) return true;\n      const wState = stream._writableState;\n      if (wState !== null && wState !== void 0 && wState.errored) return false;\n      if (typeof (wState === null || wState === void 0 ? void 0 : wState.finished) !== \"boolean\") return null;\n      return !!(wState.finished || (strict === false && wState.ended === true && wState.length === 0));\n    }\n    function isReadableEnded(stream) {\n      if (!isReadableNodeStream(stream)) return null;\n      if (stream.readableEnded === true) return true;\n      const rState = stream._readableState;\n      if (!rState || rState.errored) return false;\n      if (typeof (rState === null || rState === void 0 ? void 0 : rState.ended) !== \"boolean\") return null;\n      return rState.ended;\n    }\n    function isReadableFinished(stream, strict) {\n      if (!isReadableNodeStream(stream)) return null;\n      const rState = stream._readableState;\n      if (rState !== null && rState !== void 0 && rState.errored) return false;\n      if (typeof (rState === null || rState === void 0 ? void 0 : rState.endEmitted) !== \"boolean\") return null;\n      return !!(rState.endEmitted || (strict === false && rState.ended === true && rState.length === 0));\n    }\n    function isReadable(stream) {\n      if (stream && stream[kIsReadable] != null) return stream[kIsReadable];\n      if (typeof (stream === null || stream === void 0 ? void 0 : stream.readable) !== \"boolean\") return null;\n      if (isDestroyed(stream)) return false;\n      return isReadableNodeStream(stream) && stream.readable && !isReadableFinished(stream);\n    }\n    function isWritable(stream) {\n      if (typeof (stream === null || stream === void 0 ? void 0 : stream.writable) !== \"boolean\") return null;\n      if (isDestroyed(stream)) return false;\n      return isWritableNodeStream(stream) && stream.writable && !isWritableEnded(stream);\n    }\n    function isFinished(stream, opts) {\n      if (!isNodeStream(stream)) {\n        return null;\n      }\n      if (isDestroyed(stream)) {\n        return true;\n      }\n      if ((opts === null || opts === void 0 ? void 0 : opts.readable) !== false && isReadable(stream)) {\n        return false;\n      }\n      if ((opts === null || opts === void 0 ? void 0 : opts.writable) !== false && isWritable(stream)) {\n        return false;\n      }\n      return true;\n    }\n    function isWritableErrored(stream) {\n      var _stream$_writableStat, _stream$_writableStat2;\n      if (!isNodeStream(stream)) {\n        return null;\n      }\n      if (stream.writableErrored) {\n        return stream.writableErrored;\n      }\n      return (_stream$_writableStat =\n        (_stream$_writableStat2 = stream._writableState) === null || _stream$_writableStat2 === void 0\n          ? void 0\n          : _stream$_writableStat2.errored) !== null && _stream$_writableStat !== void 0\n        ? _stream$_writableStat\n        : null;\n    }\n    function isReadableErrored(stream) {\n      var _stream$_readableStat, _stream$_readableStat2;\n      if (!isNodeStream(stream)) {\n        return null;\n      }\n      if (stream.readableErrored) {\n        return stream.readableErrored;\n      }\n      return (_stream$_readableStat =\n        (_stream$_readableStat2 = stream._readableState) === null || _stream$_readableStat2 === void 0\n          ? void 0\n          : _stream$_readableStat2.errored) !== null && _stream$_readableStat !== void 0\n        ? _stream$_readableStat\n        : null;\n    }\n    function isClosed(stream) {\n      if (!isNodeStream(stream)) {\n        return null;\n      }\n      if (typeof stream.closed === \"boolean\") {\n        return stream.closed;\n      }\n      const wState = stream._writableState;\n      const rState = stream._readableState;\n      if (\n        typeof (wState === null || wState === void 0 ? void 0 : wState.closed) === \"boolean\" ||\n        typeof (rState === null || rState === void 0 ? void 0 : rState.closed) === \"boolean\"\n      ) {\n        return (\n          (wState === null || wState === void 0 ? void 0 : wState.closed) ||\n          (rState === null || rState === void 0 ? void 0 : rState.closed)\n        );\n      }\n      if (typeof stream._closed === \"boolean\" && isOutgoingMessage(stream)) {\n        return stream._closed;\n      }\n      return null;\n    }\n    function isOutgoingMessage(stream) {\n      return (\n        typeof stream._closed === \"boolean\" &&\n        typeof stream._defaultKeepAlive === \"boolean\" &&\n        typeof stream._removedConnection === \"boolean\" &&\n        typeof stream._removedContLen === \"boolean\"\n      );\n    }\n    function isServerResponse(stream) {\n      return typeof stream._sent100 === \"boolean\" && isOutgoingMessage(stream);\n    }\n    function isServerRequest(stream) {\n      var _stream$req;\n      return (\n        typeof stream._consuming === \"boolean\" &&\n        typeof stream._dumped === \"boolean\" &&\n        ((_stream$req = stream.req) === null || _stream$req === void 0 ? void 0 : _stream$req.upgradeOrConnect) ===\n          void 0\n      );\n    }\n    function willEmitClose(stream) {\n      if (!isNodeStream(stream)) return null;\n      const wState = stream._writableState;\n      const rState = stream._readableState;\n      const state = wState || rState;\n      return (\n        (!state && isServerResponse(stream)) ||\n        !!(state && state.autoDestroy && state.emitClose && state.closed === false)\n      );\n    }\n    function isDisturbed(stream) {\n      var _stream$kIsDisturbed;\n      return !!(\n        stream &&\n        ((_stream$kIsDisturbed = stream[kIsDisturbed]) !== null && _stream$kIsDisturbed !== void 0\n          ? _stream$kIsDisturbed\n          : stream.readableDidRead || stream.readableAborted)\n      );\n    }\n    function isErrored(stream) {\n      var _ref,\n        _ref2,\n        _ref3,\n        _ref4,\n        _ref5,\n        _stream$kIsErrored,\n        _stream$_readableStat3,\n        _stream$_writableStat3,\n        _stream$_readableStat4,\n        _stream$_writableStat4;\n      return !!(\n        stream &&\n        ((_ref =\n          (_ref2 =\n            (_ref3 =\n              (_ref4 =\n                (_ref5 =\n                  (_stream$kIsErrored = stream[kIsErrored]) !== null && _stream$kIsErrored !== void 0\n                    ? _stream$kIsErrored\n                    : stream.readableErrored) !== null && _ref5 !== void 0\n                  ? _ref5\n                  : stream.writableErrored) !== null && _ref4 !== void 0\n                ? _ref4\n                : (_stream$_readableStat3 = stream._readableState) === null || _stream$_readableStat3 === void 0\n                ? void 0\n                : _stream$_readableStat3.errorEmitted) !== null && _ref3 !== void 0\n              ? _ref3\n              : (_stream$_writableStat3 = stream._writableState) === null || _stream$_writableStat3 === void 0\n              ? void 0\n              : _stream$_writableStat3.errorEmitted) !== null && _ref2 !== void 0\n            ? _ref2\n            : (_stream$_readableStat4 = stream._readableState) === null || _stream$_readableStat4 === void 0\n            ? void 0\n            : _stream$_readableStat4.errored) !== null && _ref !== void 0\n          ? _ref\n          : (_stream$_writableStat4 = stream._writableState) === null || _stream$_writableStat4 === void 0\n          ? void 0\n          : _stream$_writableStat4.errored)\n      );\n    }\n    module.exports = {\n      kDestroyed,\n      isDisturbed,\n      kIsDisturbed,\n      isErrored,\n      kIsErrored,\n      isReadable,\n      kIsReadable,\n      isClosed,\n      isDestroyed,\n      isDuplexNodeStream,\n      isFinished,\n      isIterable,\n      isReadableNodeStream,\n      isReadableEnded,\n      isReadableFinished,\n      isReadableErrored,\n      isNodeStream,\n      isWritable,\n      isWritableNodeStream,\n      isWritableEnded,\n      isWritableFinished,\n      isWritableErrored,\n      isServerRequest,\n      isServerResponse,\n      willEmitClose,\n    };\n  },\n});\n\n// node_modules/readable-stream/lib/internal/streams/end-of-stream.js\nvar require_end_of_stream = __commonJS({\n  \"node_modules/readable-stream/lib/internal/streams/end-of-stream.js\"(exports, module) {\n    \"use strict\";\n    var { AbortError, codes } = require_errors();\n    var { ERR_INVALID_ARG_TYPE, ERR_STREAM_PREMATURE_CLOSE } = codes;\n    var { once } = require_util();\n    var { validateAbortSignal, validateFunction, validateObject } = require_validators();\n    var { Promise: Promise2 } = require_primordials();\n    var {\n      isClosed,\n      isReadable,\n      isReadableNodeStream,\n      isReadableFinished,\n      isReadableErrored,\n      isWritable,\n      isWritableNodeStream,\n      isWritableFinished,\n      isWritableErrored,\n      isNodeStream,\n      willEmitClose: _willEmitClose,\n    } = require_utils();\n    function isRequest(stream) {\n      return stream.setHeader && typeof stream.abort === \"function\";\n    }\n    var nop = () => {};\n    function eos(stream, options, callback) {\n      var _options$readable, _options$writable;\n      if (arguments.length === 2) {\n        callback = options;\n        options = {};\n      } else if (options == null) {\n        options = {};\n      } else {\n        validateObject(options, \"options\");\n      }\n      validateFunction(callback, \"callback\");\n      validateAbortSignal(options.signal, \"options.signal\");\n      callback = once(callback);\n      const readable =\n        (_options$readable = options.readable) !== null && _options$readable !== void 0\n          ? _options$readable\n          : isReadableNodeStream(stream);\n      const writable =\n        (_options$writable = options.writable) !== null && _options$writable !== void 0\n          ? _options$writable\n          : isWritableNodeStream(stream);\n      if (!isNodeStream(stream)) {\n        throw new ERR_INVALID_ARG_TYPE(\"stream\", \"Stream\", stream);\n      }\n      const wState = stream._writableState;\n      const rState = stream._readableState;\n      const onlegacyfinish = () => {\n        if (!stream.writable) {\n          onfinish();\n        }\n      };\n      let willEmitClose =\n        _willEmitClose(stream) &&\n        isReadableNodeStream(stream) === readable &&\n        isWritableNodeStream(stream) === writable;\n      let writableFinished = isWritableFinished(stream, false);\n      const onfinish = () => {\n        writableFinished = true;\n        if (stream.destroyed) {\n          willEmitClose = false;\n        }\n        if (willEmitClose && (!stream.readable || readable)) {\n          return;\n        }\n        if (!readable || readableFinished) {\n          callback.call(stream);\n        }\n      };\n      let readableFinished = isReadableFinished(stream, false);\n      const onend = () => {\n        readableFinished = true;\n        if (stream.destroyed) {\n          willEmitClose = false;\n        }\n        if (willEmitClose && (!stream.writable || writable)) {\n          return;\n        }\n        if (!writable || writableFinished) {\n          callback.call(stream);\n        }\n      };\n      const onerror = err => {\n        callback.call(stream, err);\n      };\n      let closed = isClosed(stream);\n      const onclose = () => {\n        closed = true;\n        const errored = isWritableErrored(stream) || isReadableErrored(stream);\n        if (errored && typeof errored !== \"boolean\") {\n          return callback.call(stream, errored);\n        }\n        if (readable && !readableFinished && isReadableNodeStream(stream, true)) {\n          if (!isReadableFinished(stream, false)) return callback.call(stream, new ERR_STREAM_PREMATURE_CLOSE());\n        }\n        if (writable && !writableFinished) {\n          if (!isWritableFinished(stream, false)) return callback.call(stream, new ERR_STREAM_PREMATURE_CLOSE());\n        }\n        callback.call(stream);\n      };\n      const onrequest = () => {\n        stream.req.on(\"finish\", onfinish);\n      };\n      if (isRequest(stream)) {\n        stream.on(\"complete\", onfinish);\n        if (!willEmitClose) {\n          stream.on(\"abort\", onclose);\n        }\n        if (stream.req) {\n          onrequest();\n        } else {\n          stream.on(\"request\", onrequest);\n        }\n      } else if (writable && !wState) {\n        stream.on(\"end\", onlegacyfinish);\n        stream.on(\"close\", onlegacyfinish);\n      }\n      if (!willEmitClose && typeof stream.aborted === \"boolean\") {\n        stream.on(\"aborted\", onclose);\n      }\n      stream.on(\"end\", onend);\n      stream.on(\"finish\", onfinish);\n      if (options.error !== false) {\n        stream.on(\"error\", onerror);\n      }\n      stream.on(\"close\", onclose);\n      if (closed) {\n        runOnNextTick(onclose);\n      } else if (\n        (wState !== null && wState !== void 0 && wState.errorEmitted) ||\n        (rState !== null && rState !== void 0 && rState.errorEmitted)\n      ) {\n        if (!willEmitClose) {\n          runOnNextTick(onclose);\n        }\n      } else if (\n        !readable &&\n        (!willEmitClose || isReadable(stream)) &&\n        (writableFinished || isWritable(stream) === false)\n      ) {\n        runOnNextTick(onclose);\n      } else if (\n        !writable &&\n        (!willEmitClose || isWritable(stream)) &&\n        (readableFinished || isReadable(stream) === false)\n      ) {\n        runOnNextTick(onclose);\n      } else if (rState && stream.req && stream.aborted) {\n        runOnNextTick(onclose);\n      }\n      const cleanup = () => {\n        callback = nop;\n        stream.removeListener(\"aborted\", onclose);\n        stream.removeListener(\"complete\", onfinish);\n        stream.removeListener(\"abort\", onclose);\n        stream.removeListener(\"request\", onrequest);\n        if (stream.req) stream.req.removeListener(\"finish\", onfinish);\n        stream.removeListener(\"end\", onlegacyfinish);\n        stream.removeListener(\"close\", onlegacyfinish);\n        stream.removeListener(\"finish\", onfinish);\n        stream.removeListener(\"end\", onend);\n        stream.removeListener(\"error\", onerror);\n        stream.removeListener(\"close\", onclose);\n      };\n      if (options.signal && !closed) {\n        const abort = () => {\n          const endCallback = callback;\n          cleanup();\n          endCallback.call(\n            stream,\n            new AbortError(void 0, {\n              cause: options.signal.reason,\n            }),\n          );\n        };\n        if (options.signal.aborted) {\n          runOnNextTick(abort);\n        } else {\n          const originalCallback = callback;\n          callback = once((...args) => {\n            options.signal.removeEventListener(\"abort\", abort);\n            originalCallback.apply(stream, args);\n          });\n          options.signal.addEventListener(\"abort\", abort);\n        }\n      }\n      return cleanup;\n    }\n    function finished(stream, opts) {\n      return new Promise2((resolve, reject) => {\n        eos(stream, opts, err => {\n          if (err) {\n            reject(err);\n          } else {\n            resolve();\n          }\n        });\n      });\n    }\n    module.exports = eos;\n    module.exports.finished = finished;\n  },\n});\n\n// node_modules/readable-stream/lib/internal/streams/operators.js\nvar require_operators = __commonJS({\n  \"node_modules/readable-stream/lib/internal/streams/operators.js\"(exports, module) {\n    \"use strict\";\n    var AbortController = globalThis.AbortController || __require(\"abort-controller\").AbortController;\n    var {\n      codes: { ERR_INVALID_ARG_TYPE, ERR_MISSING_ARGS, ERR_OUT_OF_RANGE },\n      AbortError,\n    } = require_errors();\n    var { validateAbortSignal, validateInteger, validateObject } = require_validators();\n    var kWeakHandler = require_primordials().Symbol(\"kWeak\");\n    var { finished } = require_end_of_stream();\n    var {\n      ArrayPrototypePush,\n      MathFloor,\n      Number: Number2,\n      NumberIsNaN,\n      Promise: Promise2,\n      PromiseReject,\n      PromisePrototypeCatch,\n      Symbol: Symbol2,\n    } = require_primordials();\n    var kEmpty = Symbol2(\"kEmpty\");\n    var kEof = Symbol2(\"kEof\");\n    function map(fn, options) {\n      if (typeof fn !== \"function\") {\n        throw new ERR_INVALID_ARG_TYPE(\"fn\", [\"Function\", \"AsyncFunction\"], fn);\n      }\n      if (options != null) {\n        validateObject(options, \"options\");\n      }\n      if ((options === null || options === void 0 ? void 0 : options.signal) != null) {\n        validateAbortSignal(options.signal, \"options.signal\");\n      }\n      let concurrency = 1;\n      if ((options === null || options === void 0 ? void 0 : options.concurrency) != null) {\n        concurrency = MathFloor(options.concurrency);\n      }\n      validateInteger(concurrency, \"concurrency\", 1);\n      return async function* map2() {\n        var _options$signal, _options$signal2;\n        const ac = new AbortController();\n        const stream = this;\n        const queue = [];\n        const signal = ac.signal;\n        const signalOpt = {\n          signal,\n        };\n        const abort = () => ac.abort();\n        if (\n          options !== null &&\n          options !== void 0 &&\n          (_options$signal = options.signal) !== null &&\n          _options$signal !== void 0 &&\n          _options$signal.aborted\n        ) {\n          abort();\n        }\n        options === null || options === void 0\n          ? void 0\n          : (_options$signal2 = options.signal) === null || _options$signal2 === void 0\n          ? void 0\n          : _options$signal2.addEventListener(\"abort\", abort);\n        let next;\n        let resume;\n        let done = false;\n        function onDone() {\n          done = true;\n        }\n        async function pump() {\n          try {\n            for await (let val of stream) {\n              var _val;\n              if (done) {\n                return;\n              }\n              if (signal.aborted) {\n                throw new AbortError();\n              }\n              try {\n                val = fn(val, signalOpt);\n              } catch (err) {\n                val = PromiseReject(err);\n              }\n              if (val === kEmpty) {\n                continue;\n              }\n              if (typeof ((_val = val) === null || _val === void 0 ? void 0 : _val.catch) === \"function\") {\n                val.catch(onDone);\n              }\n              queue.push(val);\n              if (next) {\n                next();\n                next = null;\n              }\n              if (!done && queue.length && queue.length >= concurrency) {\n                await new Promise2(resolve => {\n                  resume = resolve;\n                });\n              }\n            }\n            queue.push(kEof);\n          } catch (err) {\n            const val = PromiseReject(err);\n            PromisePrototypeCatch(val, onDone);\n            queue.push(val);\n          } finally {\n            var _options$signal3;\n            done = true;\n            if (next) {\n              next();\n              next = null;\n            }\n            options === null || options === void 0\n              ? void 0\n              : (_options$signal3 = options.signal) === null || _options$signal3 === void 0\n              ? void 0\n              : _options$signal3.removeEventListener(\"abort\", abort);\n          }\n        }\n        pump();\n        try {\n          while (true) {\n            while (queue.length > 0) {\n              const val = await queue[0];\n              if (val === kEof) {\n                return;\n              }\n              if (signal.aborted) {\n                throw new AbortError();\n              }\n              if (val !== kEmpty) {\n                yield val;\n              }\n              queue.shift();\n              if (resume) {\n                resume();\n                resume = null;\n              }\n            }\n            await new Promise2(resolve => {\n              next = resolve;\n            });\n          }\n        } finally {\n          ac.abort();\n          done = true;\n          if (resume) {\n            resume();\n            resume = null;\n          }\n        }\n      }.call(this);\n    }\n    function asIndexedPairs(options = void 0) {\n      if (options != null) {\n        validateObject(options, \"options\");\n      }\n      if ((options === null || options === void 0 ? void 0 : options.signal) != null) {\n        validateAbortSignal(options.signal, \"options.signal\");\n      }\n      return async function* asIndexedPairs2() {\n        let index = 0;\n        for await (const val of this) {\n          var _options$signal4;\n          if (\n            options !== null &&\n            options !== void 0 &&\n            (_options$signal4 = options.signal) !== null &&\n            _options$signal4 !== void 0 &&\n            _options$signal4.aborted\n          ) {\n            throw new AbortError({\n              cause: options.signal.reason,\n            });\n          }\n          yield [index++, val];\n        }\n      }.call(this);\n    }\n    async function some(fn, options = void 0) {\n      for await (const unused of filter.call(this, fn, options)) {\n        return true;\n      }\n      return false;\n    }\n    async function every(fn, options = void 0) {\n      if (typeof fn !== \"function\") {\n        throw new ERR_INVALID_ARG_TYPE(\"fn\", [\"Function\", \"AsyncFunction\"], fn);\n      }\n      return !(await some.call(\n        this,\n        async (...args) => {\n          return !(await fn(...args));\n        },\n        options,\n      ));\n    }\n    async function find(fn, options) {\n      for await (const result of filter.call(this, fn, options)) {\n        return result;\n      }\n      return void 0;\n    }\n    async function forEach(fn, options) {\n      if (typeof fn !== \"function\") {\n        throw new ERR_INVALID_ARG_TYPE(\"fn\", [\"Function\", \"AsyncFunction\"], fn);\n      }\n      async function forEachFn(value, options2) {\n        await fn(value, options2);\n        return kEmpty;\n      }\n      for await (const unused of map.call(this, forEachFn, options));\n    }\n    function filter(fn, options) {\n      if (typeof fn !== \"function\") {\n        throw new ERR_INVALID_ARG_TYPE(\"fn\", [\"Function\", \"AsyncFunction\"], fn);\n      }\n      async function filterFn(value, options2) {\n        if (await fn(value, options2)) {\n          return value;\n        }\n        return kEmpty;\n      }\n      return map.call(this, filterFn, options);\n    }\n    var ReduceAwareErrMissingArgs = class extends ERR_MISSING_ARGS {\n      constructor() {\n        super(\"reduce\");\n        this.message = \"Reduce of an empty stream requires an initial value\";\n      }\n    };\n    async function reduce(reducer, initialValue, options) {\n      var _options$signal5;\n      if (typeof reducer !== \"function\") {\n        throw new ERR_INVALID_ARG_TYPE(\"reducer\", [\"Function\", \"AsyncFunction\"], reducer);\n      }\n      if (options != null) {\n        validateObject(options, \"options\");\n      }\n      if ((options === null || options === void 0 ? void 0 : options.signal) != null) {\n        validateAbortSignal(options.signal, \"options.signal\");\n      }\n      let hasInitialValue = arguments.length > 1;\n      if (\n        options !== null &&\n        options !== void 0 &&\n        (_options$signal5 = options.signal) !== null &&\n        _options$signal5 !== void 0 &&\n        _options$signal5.aborted\n      ) {\n        const err = new AbortError(void 0, {\n          cause: options.signal.reason,\n        });\n        this.once(\"error\", () => {});\n        await finished(this.destroy(err));\n        throw err;\n      }\n      const ac = new AbortController();\n      const signal = ac.signal;\n      if (options !== null && options !== void 0 && options.signal) {\n        const opts = {\n          once: true,\n          [kWeakHandler]: this,\n        };\n        options.signal.addEventListener(\"abort\", () => ac.abort(), opts);\n      }\n      let gotAnyItemFromStream = false;\n      try {\n        for await (const value of this) {\n          var _options$signal6;\n          gotAnyItemFromStream = true;\n          if (\n            options !== null &&\n            options !== void 0 &&\n            (_options$signal6 = options.signal) !== null &&\n            _options$signal6 !== void 0 &&\n            _options$signal6.aborted\n          ) {\n            throw new AbortError();\n          }\n          if (!hasInitialValue) {\n            initialValue = value;\n            hasInitialValue = true;\n          } else {\n            initialValue = await reducer(initialValue, value, {\n              signal,\n            });\n          }\n        }\n        if (!gotAnyItemFromStream && !hasInitialValue) {\n          throw new ReduceAwareErrMissingArgs();\n        }\n      } finally {\n        ac.abort();\n      }\n      return initialValue;\n    }\n    async function toArray(options) {\n      if (options != null) {\n        validateObject(options, \"options\");\n      }\n      if ((options === null || options === void 0 ? void 0 : options.signal) != null) {\n        validateAbortSignal(options.signal, \"options.signal\");\n      }\n      const result = [];\n      for await (const val of this) {\n        var _options$signal7;\n        if (\n          options !== null &&\n          options !== void 0 &&\n          (_options$signal7 = options.signal) !== null &&\n          _options$signal7 !== void 0 &&\n          _options$signal7.aborted\n        ) {\n          throw new AbortError(void 0, {\n            cause: options.signal.reason,\n          });\n        }\n        ArrayPrototypePush(result, val);\n      }\n      return result;\n    }\n    function flatMap(fn, options) {\n      const values = map.call(this, fn, options);\n      return async function* flatMap2() {\n        for await (const val of values) {\n          yield* val;\n        }\n      }.call(this);\n    }\n    function toIntegerOrInfinity(number) {\n      number = Number2(number);\n      if (NumberIsNaN(number)) {\n        return 0;\n      }\n      if (number < 0) {\n        throw new ERR_OUT_OF_RANGE(\"number\", \">= 0\", number);\n      }\n      return number;\n    }\n    function drop(number, options = void 0) {\n      if (options != null) {\n        validateObject(options, \"options\");\n      }\n      if ((options === null || options === void 0 ? void 0 : options.signal) != null) {\n        validateAbortSignal(options.signal, \"options.signal\");\n      }\n      number = toIntegerOrInfinity(number);\n      return async function* drop2() {\n        var _options$signal8;\n        if (\n          options !== null &&\n          options !== void 0 &&\n          (_options$signal8 = options.signal) !== null &&\n          _options$signal8 !== void 0 &&\n          _options$signal8.aborted\n        ) {\n          throw new AbortError();\n        }\n        for await (const val of this) {\n          var _options$signal9;\n          if (\n            options !== null &&\n            options !== void 0 &&\n            (_options$signal9 = options.signal) !== null &&\n            _options$signal9 !== void 0 &&\n            _options$signal9.aborted\n          ) {\n            throw new AbortError();\n          }\n          if (number-- <= 0) {\n            yield val;\n          }\n        }\n      }.call(this);\n    }\n    function take(number, options = void 0) {\n      if (options != null) {\n        validateObject(options, \"options\");\n      }\n      if ((options === null || options === void 0 ? void 0 : options.signal) != null) {\n        validateAbortSignal(options.signal, \"options.signal\");\n      }\n      number = toIntegerOrInfinity(number);\n      return async function* take2() {\n        var _options$signal10;\n        if (\n          options !== null &&\n          options !== void 0 &&\n          (_options$signal10 = options.signal) !== null &&\n          _options$signal10 !== void 0 &&\n          _options$signal10.aborted\n        ) {\n          throw new AbortError();\n        }\n        for await (const val of this) {\n          var _options$signal11;\n          if (\n            options !== null &&\n            options !== void 0 &&\n            (_options$signal11 = options.signal) !== null &&\n            _options$signal11 !== void 0 &&\n            _options$signal11.aborted\n          ) {\n            throw new AbortError();\n          }\n          if (number-- > 0) {\n            yield val;\n          } else {\n            return;\n          }\n        }\n      }.call(this);\n    }\n    module.exports.streamReturningOperators = {\n      asIndexedPairs,\n      drop,\n      filter,\n      flatMap,\n      map,\n      take,\n    };\n    module.exports.promiseReturningOperators = {\n      every,\n      forEach,\n      reduce,\n      toArray,\n      some,\n      find,\n    };\n  },\n});\n\n// node_modules/readable-stream/lib/internal/streams/destroy.js\nvar require_destroy = __commonJS({\n  \"node_modules/readable-stream/lib/internal/streams/destroy.js\"(exports, module) {\n    \"use strict\";\n    var {\n      aggregateTwoErrors,\n      codes: { ERR_MULTIPLE_CALLBACK },\n      AbortError,\n    } = require_errors();\n    var { Symbol: Symbol2 } = require_primordials();\n    var { kDestroyed, isDestroyed, isFinished, isServerRequest } = require_utils();\n    var kDestroy = \"#kDestroy\";\n    var kConstruct = \"#kConstruct\";\n    function checkError(err, w, r) {\n      if (err) {\n        err.stack;\n        if (w && !w.errored) {\n          w.errored = err;\n        }\n        if (r && !r.errored) {\n          r.errored = err;\n        }\n      }\n    }\n    function destroy(err, cb) {\n      const r = this._readableState;\n      const w = this._writableState;\n      const s = w || r;\n      if ((w && w.destroyed) || (r && r.destroyed)) {\n        if (typeof cb === \"function\") {\n          cb();\n        }\n        return this;\n      }\n      checkError(err, w, r);\n      if (w) {\n        w.destroyed = true;\n      }\n      if (r) {\n        r.destroyed = true;\n      }\n      if (!s.constructed) {\n        this.once(kDestroy, er => {\n          _destroy(this, aggregateTwoErrors(er, err), cb);\n        });\n      } else {\n        _destroy(this, err, cb);\n      }\n      return this;\n    }\n    function _destroy(self, err, cb) {\n      let called = false;\n      function onDestroy(err2) {\n        if (called) {\n          return;\n        }\n        called = true;\n        const r = self._readableState;\n        const w = self._writableState;\n        checkError(err2, w, r);\n        if (w) {\n          w.closed = true;\n        }\n        if (r) {\n          r.closed = true;\n        }\n        if (typeof cb === \"function\") {\n          cb(err2);\n        }\n        if (err2) {\n          runOnNextTick(emitErrorCloseNT, self, err2);\n        } else {\n          runOnNextTick(emitCloseNT, self);\n        }\n      }\n      try {\n        self._destroy(err || null, onDestroy);\n      } catch (err2) {\n        onDestroy(err2);\n      }\n    }\n    function emitErrorCloseNT(self, err) {\n      emitErrorNT(self, err);\n      emitCloseNT(self);\n    }\n    function emitCloseNT(self) {\n      const r = self._readableState;\n      const w = self._writableState;\n      if (w) {\n        w.closeEmitted = true;\n      }\n      if (r) {\n        r.closeEmitted = true;\n      }\n      if ((w && w.emitClose) || (r && r.emitClose)) {\n        self.emit(\"close\");\n      }\n    }\n    function emitErrorNT(self, err) {\n      const r = self?._readableState;\n      const w = self?._writableState;\n      if (w?.errorEmitted || r?.errorEmitted) {\n        return;\n      }\n      if (w) {\n        w.errorEmitted = true;\n      }\n      if (r) {\n        r.errorEmitted = true;\n      }\n      self?.emit?.(\"error\", err);\n    }\n    function undestroy() {\n      const r = this._readableState;\n      const w = this._writableState;\n      if (r) {\n        r.constructed = true;\n        r.closed = false;\n        r.closeEmitted = false;\n        r.destroyed = false;\n        r.errored = null;\n        r.errorEmitted = false;\n        r.reading = false;\n        r.ended = r.readable === false;\n        r.endEmitted = r.readable === false;\n      }\n      if (w) {\n        w.constructed = true;\n        w.destroyed = false;\n        w.closed = false;\n        w.closeEmitted = false;\n        w.errored = null;\n        w.errorEmitted = false;\n        w.finalCalled = false;\n        w.prefinished = false;\n        w.ended = w.writable === false;\n        w.ending = w.writable === false;\n        w.finished = w.writable === false;\n      }\n    }\n    function errorOrDestroy(stream, err, sync) {\n      const r = stream?._readableState;\n      const w = stream?._writableState;\n      if ((w && w.destroyed) || (r && r.destroyed)) {\n        return this;\n      }\n      if ((r && r.autoDestroy) || (w && w.autoDestroy)) stream.destroy(err);\n      else if (err) {\n        Error.captureStackTrace(err);\n        if (w && !w.errored) {\n          w.errored = err;\n        }\n        if (r && !r.errored) {\n          r.errored = err;\n        }\n        if (sync) {\n          runOnNextTick(emitErrorNT, stream, err);\n        } else {\n          emitErrorNT(stream, err);\n        }\n      }\n    }\n    function construct(stream, cb) {\n      if (typeof stream._construct !== \"function\") {\n        return;\n      }\n      const r = stream._readableState;\n      const w = stream._writableState;\n      if (r) {\n        r.constructed = false;\n      }\n      if (w) {\n        w.constructed = false;\n      }\n      stream.once(kConstruct, cb);\n      if (stream.listenerCount(kConstruct) > 1) {\n        return;\n      }\n      runOnNextTick(constructNT, stream);\n    }\n    function constructNT(stream) {\n      let called = false;\n      function onConstruct(err) {\n        if (called) {\n          errorOrDestroy(stream, err !== null && err !== void 0 ? err : new ERR_MULTIPLE_CALLBACK());\n          return;\n        }\n        called = true;\n        const r = stream._readableState;\n        const w = stream._writableState;\n        const s = w || r;\n        if (r) {\n          r.constructed = true;\n        }\n        if (w) {\n          w.constructed = true;\n        }\n        if (s.destroyed) {\n          stream.emit(kDestroy, err);\n        } else if (err) {\n          errorOrDestroy(stream, err, true);\n        } else {\n          runOnNextTick(emitConstructNT, stream);\n        }\n      }\n      try {\n        stream._construct(onConstruct);\n      } catch (err) {\n        onConstruct(err);\n      }\n    }\n    function emitConstructNT(stream) {\n      stream.emit(kConstruct);\n    }\n    function isRequest(stream) {\n      return stream && stream.setHeader && typeof stream.abort === \"function\";\n    }\n    function emitCloseLegacy(stream) {\n      stream.emit(\"close\");\n    }\n    function emitErrorCloseLegacy(stream, err) {\n      stream.emit(\"error\", err);\n      runOnNextTick(emitCloseLegacy, stream);\n    }\n    function destroyer(stream, err) {\n      if (!stream || isDestroyed(stream)) {\n        return;\n      }\n      if (!err && !isFinished(stream)) {\n        err = new AbortError();\n      }\n      if (isServerRequest(stream)) {\n        stream.socket = null;\n        stream.destroy(err);\n      } else if (isRequest(stream)) {\n        stream.abort();\n      } else if (isRequest(stream.req)) {\n        stream.req.abort();\n      } else if (typeof stream.destroy === \"function\") {\n        stream.destroy(err);\n      } else if (typeof stream.close === \"function\") {\n        stream.close();\n      } else if (err) {\n        runOnNextTick(emitErrorCloseLegacy, stream);\n      } else {\n        runOnNextTick(emitCloseLegacy, stream);\n      }\n      if (!stream.destroyed) {\n        stream[kDestroyed] = true;\n      }\n    }\n    module.exports = {\n      construct,\n      destroyer,\n      destroy,\n      undestroy,\n      errorOrDestroy,\n    };\n  },\n});\n\n// node_modules/readable-stream/lib/internal/streams/legacy.js\nvar require_legacy = __commonJS({\n  \"node_modules/readable-stream/lib/internal/streams/legacy.js\"(exports, module) {\n    \"use strict\";\n    var { ArrayIsArray, ObjectSetPrototypeOf } = require_primordials();\n    var { EventEmitter: _EE } = __require(\"bun:events_native\");\n    var EE;\n    if (__TRACK_EE__) {\n      EE = DebugEventEmitter;\n    } else {\n      EE = _EE;\n    }\n\n    function Stream(options) {\n      if (!(this instanceof Stream)) return new Stream(options);\n      EE.call(this, options);\n    }\n    ObjectSetPrototypeOf(Stream.prototype, EE.prototype);\n    ObjectSetPrototypeOf(Stream, EE);\n\n    Stream.prototype.pipe = function (dest, options) {\n      const source = this;\n      function ondata(chunk) {\n        if (dest.writable && dest.write(chunk) === false && source.pause) {\n          source.pause();\n        }\n      }\n      source.on(\"data\", ondata);\n      function ondrain() {\n        if (source.readable && source.resume) {\n          source.resume();\n        }\n      }\n      dest.on(\"drain\", ondrain);\n      if (!dest._isStdio && (!options || options.end !== false)) {\n        source.on(\"end\", onend);\n        source.on(\"close\", onclose);\n      }\n      let didOnEnd = false;\n      function onend() {\n        if (didOnEnd) return;\n        didOnEnd = true;\n        dest.end();\n      }\n      function onclose() {\n        if (didOnEnd) return;\n        didOnEnd = true;\n        if (typeof dest.destroy === \"function\") dest.destroy();\n      }\n      function onerror(er) {\n        cleanup();\n        if (EE.listenerCount(this, \"error\") === 0) {\n          this.emit(\"error\", er);\n        }\n      }\n      prependListener(source, \"error\", onerror);\n      prependListener(dest, \"error\", onerror);\n      function cleanup() {\n        source.removeListener(\"data\", ondata);\n        dest.removeListener(\"drain\", ondrain);\n        source.removeListener(\"end\", onend);\n        source.removeListener(\"close\", onclose);\n        source.removeListener(\"error\", onerror);\n        dest.removeListener(\"error\", onerror);\n        source.removeListener(\"end\", cleanup);\n        source.removeListener(\"close\", cleanup);\n        dest.removeListener(\"close\", cleanup);\n      }\n      source.on(\"end\", cleanup);\n      source.on(\"close\", cleanup);\n      dest.on(\"close\", cleanup);\n      dest.emit(\"pipe\", source);\n      return dest;\n    };\n    function prependListener(emitter, event, fn) {\n      if (typeof emitter.prependListener === \"function\") return emitter.prependListener(event, fn);\n      if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);\n      else if (ArrayIsArray(emitter._events[event])) emitter._events[event].unshift(fn);\n      else emitter._events[event] = [fn, emitter._events[event]];\n    }\n    module.exports = {\n      Stream,\n      prependListener,\n    };\n  },\n});\n\n// node_modules/readable-stream/lib/internal/streams/add-abort-signal.js\nvar require_add_abort_signal = __commonJS({\n  \"node_modules/readable-stream/lib/internal/streams/add-abort-signal.js\"(exports, module) {\n    \"use strict\";\n    var { AbortError, codes } = require_errors();\n    var eos = require_end_of_stream();\n    var { ERR_INVALID_ARG_TYPE } = codes;\n    var validateAbortSignal = (signal, name) => {\n      if (typeof signal !== \"object\" || !(\"aborted\" in signal)) {\n        throw new ERR_INVALID_ARG_TYPE(name, \"AbortSignal\", signal);\n      }\n    };\n    function isNodeStream(obj) {\n      return !!(obj && typeof obj.pipe === \"function\");\n    }\n    module.exports.addAbortSignal = function addAbortSignal(signal, stream) {\n      validateAbortSignal(signal, \"signal\");\n      if (!isNodeStream(stream)) {\n        throw new ERR_INVALID_ARG_TYPE(\"stream\", \"stream.Stream\", stream);\n      }\n      return module.exports.addAbortSignalNoValidate(signal, stream);\n    };\n    module.exports.addAbortSignalNoValidate = function (signal, stream) {\n      if (typeof signal !== \"object\" || !(\"aborted\" in signal)) {\n        return stream;\n      }\n      const onAbort = () => {\n        stream.destroy(\n          new AbortError(void 0, {\n            cause: signal.reason,\n          }),\n        );\n      };\n      if (signal.aborted) {\n        onAbort();\n      } else {\n        signal.addEventListener(\"abort\", onAbort);\n        eos(stream, () => signal.removeEventListener(\"abort\", onAbort));\n      }\n      return stream;\n    };\n  },\n});\n\n// node_modules/readable-stream/lib/internal/streams/state.js\nvar require_state = __commonJS({\n  \"node_modules/readable-stream/lib/internal/streams/state.js\"(exports, module) {\n    \"use strict\";\n    var { MathFloor, NumberIsInteger } = require_primordials();\n    var { ERR_INVALID_ARG_VALUE } = require_errors().codes;\n    function highWaterMarkFrom(options, isDuplex, duplexKey) {\n      return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;\n    }\n    function getDefaultHighWaterMark(objectMode) {\n      return objectMode ? 16 : 16 * 1024;\n    }\n    function getHighWaterMark(state, options, duplexKey, isDuplex) {\n      const hwm = highWaterMarkFrom(options, isDuplex, duplexKey);\n      if (hwm != null) {\n        if (!NumberIsInteger(hwm) || hwm < 0) {\n          const name = isDuplex ? `options.${duplexKey}` : \"options.highWaterMark\";\n          throw new ERR_INVALID_ARG_VALUE(name, hwm);\n        }\n        return MathFloor(hwm);\n      }\n      return getDefaultHighWaterMark(state.objectMode);\n    }\n    module.exports = {\n      getHighWaterMark,\n      getDefaultHighWaterMark,\n    };\n  },\n});\n\n// node_modules/readable-stream/lib/internal/streams/from.js\nvar require_from = __commonJS({\n  \"node_modules/readable-stream/lib/internal/streams/from.js\"(exports, module) {\n    \"use strict\";\n    var { PromisePrototypeThen, SymbolAsyncIterator, SymbolIterator } = require_primordials();\n    var { ERR_INVALID_ARG_TYPE, ERR_STREAM_NULL_VALUES } = require_errors().codes;\n    function from(Readable, iterable, opts) {\n      let iterator;\n      if (typeof iterable === \"string\" || iterable instanceof Buffer) {\n        return new Readable({\n          objectMode: true,\n          ...opts,\n          read() {\n            this.push(iterable);\n            this.push(null);\n          },\n        });\n      }\n      let isAsync;\n      if (iterable && iterable[SymbolAsyncIterator]) {\n        isAsync = true;\n        iterator = iterable[SymbolAsyncIterator]();\n      } else if (iterable && iterable[SymbolIterator]) {\n        isAsync = false;\n        iterator = iterable[SymbolIterator]();\n      } else {\n        throw new ERR_INVALID_ARG_TYPE(\"iterable\", [\"Iterable\"], iterable);\n      }\n      const readable = new Readable({\n        objectMode: true,\n        highWaterMark: 1,\n        ...opts,\n      });\n      let reading = false;\n      readable._read = function () {\n        if (!reading) {\n          reading = true;\n          next();\n        }\n      };\n      readable._destroy = function (error, cb) {\n        PromisePrototypeThen(\n          close(error),\n          () => runOnNextTick(cb, error),\n          e => runOnNextTick(cb, e || error),\n        );\n      };\n      async function close(error) {\n        const hadError = error !== void 0 && error !== null;\n        const hasThrow = typeof iterator.throw === \"function\";\n        if (hadError && hasThrow) {\n          const { value, done } = await iterator.throw(error);\n          await value;\n          if (done) {\n            return;\n          }\n        }\n        if (typeof iterator.return === \"function\") {\n          const { value } = await iterator.return();\n          await value;\n        }\n      }\n      async function next() {\n        for (;;) {\n          try {\n            const { value, done } = isAsync ? await iterator.next() : iterator.next();\n            if (done) {\n              readable.push(null);\n            } else {\n              const res = value && typeof value.then === \"function\" ? await value : value;\n              if (res === null) {\n                reading = false;\n                throw new ERR_STREAM_NULL_VALUES();\n              } else if (readable.push(res)) {\n                continue;\n              } else {\n                reading = false;\n              }\n            }\n          } catch (err) {\n            readable.destroy(err);\n          }\n          break;\n        }\n      }\n      return readable;\n    }\n    module.exports = from;\n  },\n});\n\nvar _ReadableFromWeb;\n\n// node_modules/readable-stream/lib/internal/streams/readable.js\nvar require_readable = __commonJS({\n  \"node_modules/readable-stream/lib/internal/streams/readable.js\"(exports, module) {\n    \"use strict\";\n    var {\n      ArrayPrototypeIndexOf,\n      NumberIsInteger,\n      NumberIsNaN,\n      NumberParseInt,\n      ObjectDefineProperties,\n      ObjectKeys,\n      ObjectSetPrototypeOf,\n      Promise: Promise2,\n      SafeSet,\n      SymbolAsyncIterator,\n      Symbol: Symbol2,\n    } = require_primordials();\n\n    var ReadableState = globalThis[Symbol.for(\"Bun.lazy\")](\"bun:stream\").ReadableState;\n    var { EventEmitter: EE } = __require(\"bun:events_native\");\n    var { Stream, prependListener } = require_legacy();\n\n    function Readable(options) {\n      if (!(this instanceof Readable)) return new Readable(options);\n      const isDuplex = this instanceof require_duplex();\n      this._readableState = new ReadableState(options, this, isDuplex);\n      if (options) {\n        const { read, destroy, construct, signal } = options;\n        if (typeof read === \"function\") this._read = read;\n        if (typeof destroy === \"function\") this._destroy = destroy;\n        if (typeof construct === \"function\") this._construct = construct;\n        if (signal && !isDuplex) addAbortSignal(signal, this);\n      }\n      Stream.call(this, options);\n\n      destroyImpl.construct(this, () => {\n        if (this._readableState.needReadable) {\n          maybeReadMore(this, this._readableState);\n        }\n      });\n    }\n    ObjectSetPrototypeOf(Readable.prototype, Stream.prototype);\n    ObjectSetPrototypeOf(Readable, Stream);\n\n    Readable.prototype.on = function (ev, fn) {\n      const res = Stream.prototype.on.call(this, ev, fn);\n      const state = this._readableState;\n      if (ev === \"data\") {\n        state.readableListening = this.listenerCount(\"readable\") > 0;\n        if (state.flowing !== false) {\n          __DEBUG__ && debug(\"in flowing mode!\", this.__id);\n          this.resume();\n        } else {\n          __DEBUG__ && debug(\"in readable mode!\", this.__id);\n        }\n      } else if (ev === \"readable\") {\n        __DEBUG__ && debug(\"readable listener added!\", this.__id);\n        if (!state.endEmitted && !state.readableListening) {\n          state.readableListening = state.needReadable = true;\n          state.flowing = false;\n          state.emittedReadable = false;\n          __DEBUG__ &&\n            debug(\n              \"on readable - state.length, reading, emittedReadable\",\n              state.length,\n              state.reading,\n              state.emittedReadable,\n              this.__id,\n            );\n          if (state.length) {\n            emitReadable(this, state);\n          } else if (!state.reading) {\n            runOnNextTick(nReadingNextTick, this);\n          }\n        } else if (state.endEmitted) {\n          __DEBUG__ && debug(\"end already emitted...\", this.__id);\n        }\n      }\n      return res;\n    };\n\n    class ReadableFromWeb extends Readable {\n      #reader;\n      #closed;\n      #pendingChunks;\n      #stream;\n\n      constructor(options, stream) {\n        const { objectMode, highWaterMark, encoding, signal } = options;\n        super({\n          objectMode,\n          highWaterMark,\n          encoding,\n          signal,\n        });\n        this.#pendingChunks = [];\n        this.#reader = undefined;\n        this.#stream = stream;\n        this.#closed = false;\n      }\n\n      #drainPending() {\n        var pendingChunks = this.#pendingChunks,\n          pendingChunksI = 0,\n          pendingChunksCount = pendingChunks.length;\n\n        for (; pendingChunksI < pendingChunksCount; pendingChunksI++) {\n          const chunk = pendingChunks[pendingChunksI];\n          pendingChunks[pendingChunksI] = undefined;\n          if (!this.push(chunk, undefined)) {\n            this.#pendingChunks = pendingChunks.slice(pendingChunksI + 1);\n            return true;\n          }\n        }\n\n        if (pendingChunksCount > 0) {\n          this.#pendingChunks = [];\n        }\n\n        return false;\n      }\n\n      #handleDone(reader) {\n        reader.releaseLock();\n        this.#reader = undefined;\n        this.#closed = true;\n        this.push(null);\n        return;\n      }\n\n      async _read() {\n        __DEBUG__ && debug(\"ReadableFromWeb _read()\", this.__id);\n        var stream = this.#stream,\n          reader = this.#reader;\n        if (stream) {\n          reader = this.#reader = stream.getReader();\n          this.#stream = undefined;\n        } else if (this.#drainPending()) {\n          return;\n        }\n\n        var deferredError;\n        try {\n          do {\n            var done = false,\n              value;\n            const firstResult = reader.readMany();\n\n            if (isPromise(firstResult)) {\n              ({ done, value } = await firstResult);\n\n              if (this.#closed) {\n                this.#pendingChunks.push(...value);\n                return;\n              }\n            } else {\n              ({ done, value } = firstResult);\n            }\n\n            if (done) {\n              this.#handleDone(reader);\n              return;\n            }\n\n            if (!this.push(value[0])) {\n              this.#pendingChunks = value.slice(1);\n              return;\n            }\n\n            for (let i = 1, count = value.length; i < count; i++) {\n              if (!this.push(value[i])) {\n                this.#pendingChunks = value.slice(i + 1);\n                return;\n              }\n            }\n          } while (!this.#closed);\n        } catch (e) {\n          deferredError = e;\n        } finally {\n          if (deferredError) throw deferredError;\n        }\n      }\n\n      _destroy(error, callback) {\n        if (!this.#closed) {\n          var reader = this.#reader;\n          if (reader) {\n            this.#reader = undefined;\n            reader.cancel(error).finally(() => {\n              this.#closed = true;\n              callback(error);\n            });\n          }\n\n          return;\n        }\n        try {\n          callback(error);\n        } catch (error) {\n          globalThis.reportError(error);\n        }\n      }\n    }\n\n    /**\n     * @param {ReadableStream} readableStream\n     * @param {{\n     *   highWaterMark? : number,\n     *   encoding? : string,\n     *   objectMode? : boolean,\n     *   signal? : AbortSignal,\n     * }} [options]\n     * @returns {Readable}\n     */\n    function newStreamReadableFromReadableStream(readableStream, options = {}) {\n      if (!isReadableStream(readableStream)) {\n        throw new ERR_INVALID_ARG_TYPE(\"readableStream\", \"ReadableStream\", readableStream);\n      }\n\n      validateObject(options, \"options\");\n      const {\n        highWaterMark,\n        encoding,\n        objectMode = false,\n        signal,\n        // native = true,\n      } = options;\n\n      if (encoding !== undefined && !Buffer.isEncoding(encoding))\n        throw new ERR_INVALID_ARG_VALUE(encoding, \"options.encoding\");\n      validateBoolean(objectMode, \"options.objectMode\");\n\n      // validateBoolean(native, \"options.native\");\n\n      // if (!native) {\n      //   return new ReadableFromWeb(\n      //     {\n      //       highWaterMark,\n      //       encoding,\n      //       objectMode,\n      //       signal,\n      //     },\n      //     readableStream,\n      //   );\n      // }\n\n      const nativeStream = getNativeReadableStream(Readable, readableStream, options);\n\n      return (\n        nativeStream ||\n        new ReadableFromWeb(\n          {\n            highWaterMark,\n            encoding,\n            objectMode,\n            signal,\n          },\n          readableStream,\n        )\n      );\n    }\n\n    module.exports = Readable;\n    _ReadableFromWeb = ReadableFromWeb;\n\n    var { addAbortSignal } = require_add_abort_signal();\n    var eos = require_end_of_stream();\n    const {\n      maybeReadMore: _maybeReadMore,\n      resume,\n      emitReadable: _emitReadable,\n      onEofChunk,\n    } = globalThis[Symbol.for(\"Bun.lazy\")](\"bun:stream\");\n    function maybeReadMore(stream, state) {\n      process.nextTick(_maybeReadMore, stream, state);\n    }\n    // REVERT ME\n    function emitReadable(stream, state) {\n      __DEBUG__ && debug(\"NativeReadable - emitReadable\", stream.__id);\n      _emitReadable(stream, state);\n    }\n    var destroyImpl = require_destroy();\n    var {\n      aggregateTwoErrors,\n      codes: {\n        ERR_INVALID_ARG_TYPE,\n        ERR_METHOD_NOT_IMPLEMENTED,\n        ERR_OUT_OF_RANGE,\n        ERR_STREAM_PUSH_AFTER_EOF,\n        ERR_STREAM_UNSHIFT_AFTER_END_EVENT,\n      },\n    } = require_errors();\n    var { validateObject } = require_validators();\n    var { StringDecoder } = __require(\"string_decoder\");\n    var from = require_from();\n    var nop = () => {};\n    var { errorOrDestroy } = destroyImpl;\n\n    Readable.prototype.destroy = destroyImpl.destroy;\n    Readable.prototype._undestroy = destroyImpl.undestroy;\n    Readable.prototype._destroy = function (err, cb) {\n      cb(err);\n    };\n    Readable.prototype[EE.captureRejectionSymbol] = function (err) {\n      this.destroy(err);\n    };\n    Readable.prototype.push = function (chunk, encoding) {\n      return readableAddChunk(this, chunk, encoding, false);\n    };\n    Readable.prototype.unshift = function (chunk, encoding) {\n      return readableAddChunk(this, chunk, encoding, true);\n    };\n    function readableAddChunk(stream, chunk, encoding, addToFront) {\n      __DEBUG__ && debug(\"readableAddChunk\", chunk, stream.__id);\n      const state = stream._readableState;\n      let err;\n      if (!state.objectMode) {\n        if (typeof chunk === \"string\") {\n          encoding = encoding || state.defaultEncoding;\n          if (state.encoding !== encoding) {\n            if (addToFront && state.encoding) {\n              chunk = Buffer.from(chunk, encoding).toString(state.encoding);\n            } else {\n              chunk = Buffer.from(chunk, encoding);\n              encoding = \"\";\n            }\n          }\n        } else if (chunk instanceof Buffer) {\n          encoding = \"\";\n        } else if (Stream._isUint8Array(chunk)) {\n          if (addToFront || !state.decoder) {\n            chunk = Stream._uint8ArrayToBuffer(chunk);\n          }\n          encoding = \"\";\n        } else if (chunk != null) {\n          err = new ERR_INVALID_ARG_TYPE(\"chunk\", [\"string\", \"Buffer\", \"Uint8Array\"], chunk);\n        }\n      }\n      if (err) {\n        errorOrDestroy(stream, err);\n      } else if (chunk === null) {\n        state.reading = false;\n        onEofChunk(stream, state);\n      } else if (state.objectMode || (chunk && chunk.length > 0)) {\n        if (addToFront) {\n          if (state.endEmitted) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());\n          else if (state.destroyed || state.errored) return false;\n          else addChunk(stream, state, chunk, true);\n        } else if (state.ended) {\n          errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());\n        } else if (state.destroyed || state.errored) {\n          return false;\n        } else {\n          state.reading = false;\n          if (state.decoder && !encoding) {\n            chunk = state.decoder.write(chunk);\n            if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);\n            else maybeReadMore(stream, state);\n          } else {\n            addChunk(stream, state, chunk, false);\n          }\n        }\n      } else if (!addToFront) {\n        state.reading = false;\n        maybeReadMore(stream, state);\n      }\n      return !state.ended && (state.length < state.highWaterMark || state.length === 0);\n    }\n    function addChunk(stream, state, chunk, addToFront) {\n      __DEBUG__ && debug(\"adding chunk\", stream.__id);\n      __DEBUG__ && debug(\"chunk\", chunk.toString(), stream.__id);\n      if (state.flowing && state.length === 0 && !state.sync && stream.listenerCount(\"data\") > 0) {\n        if (state.multiAwaitDrain) {\n          state.awaitDrainWriters.clear();\n        } else {\n          state.awaitDrainWriters = null;\n        }\n        state.dataEmitted = true;\n        stream.emit(\"data\", chunk);\n      } else {\n        state.length += state.objectMode ? 1 : chunk.length;\n        if (addToFront) state.buffer.unshift(chunk);\n        else state.buffer.push(chunk);\n        __DEBUG__ && debug(\"needReadable @ addChunk\", state.needReadable, stream.__id);\n        if (state.needReadable) emitReadable(stream, state);\n      }\n      maybeReadMore(stream, state);\n    }\n    Readable.prototype.isPaused = function () {\n      const state = this._readableState;\n      return state.paused === true || state.flowing === false;\n    };\n    Readable.prototype.setEncoding = function (enc) {\n      const decoder = new StringDecoder(enc);\n      this._readableState.decoder = decoder;\n      this._readableState.encoding = this._readableState.decoder.encoding;\n      const buffer = this._readableState.buffer;\n      let content = \"\";\n      // BufferList does not support iterator now, and iterator is slow in JSC.\n      // for (const data of buffer) {\n      //   content += decoder.write(data);\n      // }\n      // buffer.clear();\n      for (let i = buffer.length; i > 0; i--) {\n        content += decoder.write(buffer.shift());\n      }\n      if (content !== \"\") buffer.push(content);\n      this._readableState.length = content.length;\n      return this;\n    };\n    var MAX_HWM = 1073741824;\n    function computeNewHighWaterMark(n) {\n      if (n > MAX_HWM) {\n        throw new ERR_OUT_OF_RANGE(\"size\", \"<= 1GiB\", n);\n      } else {\n        n--;\n        n |= n >>> 1;\n        n |= n >>> 2;\n        n |= n >>> 4;\n        n |= n >>> 8;\n        n |= n >>> 16;\n        n++;\n      }\n      return n;\n    }\n    function howMuchToRead(n, state) {\n      if (n <= 0 || (state.length === 0 && state.ended)) return 0;\n      if (state.objectMode) return 1;\n      if (NumberIsNaN(n)) {\n        if (state.flowing && state.length) return state.buffer.first().length;\n        return state.length;\n      }\n      if (n <= state.length) return n;\n      return state.ended ? state.length : 0;\n    }\n    // You can override either this method, or the async _read(n) below.\n    Readable.prototype.read = function (n) {\n      __DEBUG__ && debug(\"read - n =\", n, this.__id);\n      if (!NumberIsInteger(n)) {\n        n = NumberParseInt(n, 10);\n      }\n      const state = this._readableState;\n      const nOrig = n;\n\n      // If we're asking for more than the current hwm, then raise the hwm.\n      if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);\n\n      if (n !== 0) state.emittedReadable = false;\n\n      // If we're doing read(0) to trigger a readable event, but we\n      // already have a bunch of data in the buffer, then just trigger\n      // the 'readable' event and move on.\n      if (\n        n === 0 &&\n        state.needReadable &&\n        ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)\n      ) {\n        __DEBUG__ && debug(\"read: emitReadable or endReadable\", state.length, state.ended, this.__id);\n        if (state.length === 0 && state.ended) endReadable(this);\n        else emitReadable(this, state);\n        return null;\n      }\n\n      n = howMuchToRead(n, state);\n\n      // If we've ended, and we're now clear, then finish it up.\n      if (n === 0 && state.ended) {\n        __DEBUG__ &&\n          debug(\"read: calling endReadable if length 0 -- length, state.ended\", state.length, state.ended, this.__id);\n        if (state.length === 0) endReadable(this);\n        return null;\n      }\n\n      // All the actual chunk generation logic needs to be\n      // *below* the call to _read.  The reason is that in certain\n      // synthetic stream cases, such as passthrough streams, _read\n      // may be a completely synchronous operation which may change\n      // the state of the read buffer, providing enough data when\n      // before there was *not* enough.\n      //\n      // So, the steps are:\n      // 1. Figure out what the state of things will be after we do\n      // a read from the buffer.\n      //\n      // 2. If that resulting state will trigger a _read, then call _read.\n      // Note that this may be asynchronous, or synchronous.  Yes, it is\n      // deeply ugly to write APIs this way, but that still doesn't mean\n      // that the Readable class should behave improperly, as streams are\n      // designed to be sync/async agnostic.\n      // Take note if the _read call is sync or async (ie, if the read call\n      // has returned yet), so that we know whether or not it's safe to emit\n      // 'readable' etc.\n      //\n      // 3. Actually pull the requested chunks out of the buffer and return.\n\n      // if we need a readable event, then we need to do some reading.\n      let doRead = state.needReadable;\n      __DEBUG__ && debug(\"need readable\", doRead, this.__id);\n\n      // If we currently have less than the highWaterMark, then also read some.\n      if (state.length === 0 || state.length - n < state.highWaterMark) {\n        doRead = true;\n        __DEBUG__ && debug(\"length less than watermark\", doRead, this.__id);\n      }\n\n      // However, if we've ended, then there's no point, if we're already\n      // reading, then it's unnecessary, if we're constructing we have to wait,\n      // and if we're destroyed or errored, then it's not allowed,\n      if (state.ended || state.reading || state.destroyed || state.errored || !state.constructed) {\n        __DEBUG__ && debug(\"state.constructed?\", state.constructed, this.__id);\n        doRead = false;\n        __DEBUG__ && debug(\"reading, ended or constructing\", doRead, this.__id);\n      } else if (doRead) {\n        __DEBUG__ && debug(\"do read\", this.__id);\n        state.reading = true;\n        state.sync = true;\n        // If the length is currently zero, then we *need* a readable event.\n        if (state.length === 0) state.needReadable = true;\n\n        // Call internal read method\n        try {\n          var result = this._read(state.highWaterMark);\n          if (isPromise(result)) {\n            __DEBUG__ && debug(\"async _read\", this.__id);\n            const peeked = Bun.peek(result);\n            __DEBUG__ && debug(\"peeked promise\", peeked, this.__id);\n            if (peeked !== result) {\n              result = peeked;\n            }\n          }\n\n          if (isPromise(result) && result?.then && isCallable(result.then)) {\n            __DEBUG__ && debug(\"async _read result.then setup\", this.__id);\n            result.then(nop, function (err) {\n              errorOrDestroy(this, err);\n            });\n          }\n        } catch (err) {\n          errorOrDestroy(this, err);\n        }\n\n        state.sync = false;\n        // If _read pushed data synchronously, then `reading` will be false,\n        // and we need to re-evaluate how much data we can return to the user.\n        if (!state.reading) n = howMuchToRead(nOrig, state);\n      }\n\n      __DEBUG__ && debug(\"n @ fromList\", n, this.__id);\n      let ret;\n      if (n > 0) ret = fromList(n, state);\n      else ret = null;\n\n      __DEBUG__ && debug(\"ret @ read\", ret, this.__id);\n\n      if (ret === null) {\n        state.needReadable = state.length <= state.highWaterMark;\n        __DEBUG__ && debug(\"state.length while ret = null\", state.length, this.__id);\n        n = 0;\n      } else {\n        state.length -= n;\n        if (state.multiAwaitDrain) {\n          state.awaitDrainWriters.clear();\n        } else {\n          state.awaitDrainWriters = null;\n        }\n      }\n\n      if (state.length === 0) {\n        // If we have nothing in the buffer, then we want to know\n        // as soon as we *do* get something into the buffer.\n        if (!state.ended) state.needReadable = true;\n\n        // If we tried to read() past the EOF, then emit end on the next tick.\n        if (nOrig !== n && state.ended) endReadable(this);\n      }\n\n      if (ret !== null && !state.errorEmitted && !state.closeEmitted) {\n        state.dataEmitted = true;\n        this.emit(\"data\", ret);\n      }\n\n      return ret;\n    };\n    Readable.prototype._read = function (n) {\n      throw new ERR_METHOD_NOT_IMPLEMENTED(\"_read()\");\n    };\n    Readable.prototype.pipe = function (dest, pipeOpts) {\n      const src = this;\n      const state = this._readableState;\n      if (state.pipes.length === 1) {\n        if (!state.multiAwaitDrain) {\n          state.multiAwaitDrain = true;\n          state.awaitDrainWriters = new SafeSet(state.awaitDrainWriters ? [state.awaitDrainWriters] : []);\n        }\n      }\n      state.pipes.push(dest);\n      __DEBUG__ && debug(\"pipe count=%d opts=%j\", state.pipes.length, pipeOpts, src.__id);\n      const doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;\n      const endFn = doEnd ? onend : unpipe;\n      if (state.endEmitted) runOnNextTick(endFn);\n      else src.once(\"end\", endFn);\n      dest.on(\"unpipe\", onunpipe);\n      function onunpipe(readable, unpipeInfo) {\n        __DEBUG__ && debug(\"onunpipe\", src.__id);\n        if (readable === src) {\n          if (unpipeInfo && unpipeInfo.hasUnpiped === false) {\n            unpipeInfo.hasUnpiped = true;\n            cleanup();\n          }\n        }\n      }\n      function onend() {\n        __DEBUG__ && debug(\"onend\", src.__id);\n        dest.end();\n      }\n      let ondrain;\n      let cleanedUp = false;\n      function cleanup() {\n        __DEBUG__ && debug(\"cleanup\", src.__id);\n        dest.removeListener(\"close\", onclose);\n        dest.removeListener(\"finish\", onfinish);\n        if (ondrain) {\n          dest.removeListener(\"drain\", ondrain);\n        }\n        dest.removeListener(\"error\", onerror);\n        dest.removeListener(\"unpipe\", onunpipe);\n        src.removeListener(\"end\", onend);\n        src.removeListener(\"end\", unpipe);\n        src.removeListener(\"data\", ondata);\n        cleanedUp = true;\n        if (ondrain && state.awaitDrainWriters && (!dest._writableState || dest._writableState.needDrain)) ondrain();\n      }\n      function pause() {\n        if (!cleanedUp) {\n          if (state.pipes.length === 1 && state.pipes[0] === dest) {\n            __DEBUG__ && debug(\"false write response, pause\", 0, src.__id);\n            state.awaitDrainWriters = dest;\n            state.multiAwaitDrain = false;\n          } else if (state.pipes.length > 1 && state.pipes.includes(dest)) {\n            __DEBUG__ && debug(\"false write response, pause\", state.awaitDrainWriters.size, src.__id);\n            state.awaitDrainWriters.add(dest);\n          }\n          src.pause();\n        }\n        if (!ondrain) {\n          ondrain = pipeOnDrain(src, dest);\n          dest.on(\"drain\", ondrain);\n        }\n      }\n      src.on(\"data\", ondata);\n      function ondata(chunk) {\n        __DEBUG__ && debug(\"ondata\", src.__id);\n        const ret = dest.write(chunk);\n        __DEBUG__ && debug(\"dest.write\", ret, src.__id);\n        if (ret === false) {\n          pause();\n        }\n      }\n      function onerror(er) {\n        debug(\"onerror\", er);\n        unpipe();\n        dest.removeListener(\"error\", onerror);\n        if (dest.listenerCount(\"error\") === 0) {\n          const s = dest._writableState || dest._readableState;\n          if (s && !s.errorEmitted) {\n            errorOrDestroy(dest, er);\n          } else {\n            dest.emit(\"error\", er);\n          }\n        }\n      }\n      prependListener(dest, \"error\", onerror);\n      function onclose() {\n        dest.removeListener(\"finish\", onfinish);\n        unpipe();\n      }\n      dest.once(\"close\", onclose);\n      function onfinish() {\n        debug(\"onfinish\");\n        dest.removeListener(\"close\", onclose);\n        unpipe();\n      }\n      dest.once(\"finish\", onfinish);\n      function unpipe() {\n        debug(\"unpipe\");\n        src.unpipe(dest);\n      }\n      dest.emit(\"pipe\", src);\n      if (dest.writableNeedDrain === true) {\n        if (state.flowing) {\n          pause();\n        }\n      } else if (!state.flowing) {\n        debug(\"pipe resume\");\n        src.resume();\n      }\n      return dest;\n    };\n    function pipeOnDrain(src, dest) {\n      return function pipeOnDrainFunctionResult() {\n        const state = src._readableState;\n        if (state.awaitDrainWriters === dest) {\n          debug(\"pipeOnDrain\", 1);\n          state.awaitDrainWriters = null;\n        } else if (state.multiAwaitDrain) {\n          debug(\"pipeOnDrain\", state.awaitDrainWriters.size);\n          state.awaitDrainWriters.delete(dest);\n        }\n        if ((!state.awaitDrainWriters || state.awaitDrainWriters.size === 0) && src.listenerCount(\"data\")) {\n          src.resume();\n        }\n      };\n    }\n    Readable.prototype.unpipe = function (dest) {\n      const state = this._readableState;\n      const unpipeInfo = {\n        hasUnpiped: false,\n      };\n      if (state.pipes.length === 0) return this;\n      if (!dest) {\n        const dests = state.pipes;\n        state.pipes = [];\n        this.pause();\n        for (let i = 0; i < dests.length; i++)\n          dests[i].emit(\"unpipe\", this, {\n            hasUnpiped: false,\n          });\n        return this;\n      }\n      const index = ArrayPrototypeIndexOf(state.pipes, dest);\n      if (index === -1) return this;\n      state.pipes.splice(index, 1);\n      if (state.pipes.length === 0) this.pause();\n      dest.emit(\"unpipe\", this, unpipeInfo);\n      return this;\n    };\n    Readable.prototype.addListener = Readable.prototype.on;\n    Readable.prototype.removeListener = function (ev, fn) {\n      const res = Stream.prototype.removeListener.call(this, ev, fn);\n      if (ev === \"readable\") {\n        runOnNextTick(updateReadableListening, this);\n      }\n      return res;\n    };\n    Readable.prototype.off = Readable.prototype.removeListener;\n    Readable.prototype.removeAllListeners = function (ev) {\n      const res = Stream.prototype.removeAllListeners.apply(this, arguments);\n      if (ev === \"readable\" || ev === void 0) {\n        runOnNextTick(updateReadableListening, this);\n      }\n      return res;\n    };\n    function updateReadableListening(self) {\n      const state = self._readableState;\n      state.readableListening = self.listenerCount(\"readable\") > 0;\n      if (state.resumeScheduled && state.paused === false) {\n        state.flowing = true;\n      } else if (self.listenerCount(\"data\") > 0) {\n        self.resume();\n      } else if (!state.readableListening) {\n        state.flowing = null;\n      }\n    }\n    function nReadingNextTick(self) {\n      __DEBUG__ && debug(\"on readable nextTick, calling read(0)\", self.__id);\n      self.read(0);\n    }\n    Readable.prototype.resume = function () {\n      const state = this._readableState;\n      if (!state.flowing) {\n        __DEBUG__ && debug(\"resume\", this.__id);\n        state.flowing = !state.readableListening;\n        resume(this, state);\n      }\n      state.paused = false;\n      return this;\n    };\n    Readable.prototype.pause = function () {\n      __DEBUG__ && debug(\"call pause flowing=%j\", this._readableState.flowing, this.__id);\n      if (this._readableState.flowing !== false) {\n        __DEBUG__ && debug(\"pause\", this.__id);\n        this._readableState.flowing = false;\n        this.emit(\"pause\");\n      }\n      this._readableState.paused = true;\n      return this;\n    };\n    Readable.prototype.wrap = function (stream) {\n      let paused = false;\n      stream.on(\"data\", chunk => {\n        if (!this.push(chunk) && stream.pause) {\n          paused = true;\n          stream.pause();\n        }\n      });\n      stream.on(\"end\", () => {\n        this.push(null);\n      });\n      stream.on(\"error\", err => {\n        errorOrDestroy(this, err);\n      });\n      stream.on(\"close\", () => {\n        this.destroy();\n      });\n      stream.on(\"destroy\", () => {\n        this.destroy();\n      });\n      this._read = () => {\n        if (paused && stream.resume) {\n          paused = false;\n          stream.resume();\n        }\n      };\n      const streamKeys = ObjectKeys(stream);\n      for (let j = 1; j < streamKeys.length; j++) {\n        const i = streamKeys[j];\n        if (this[i] === void 0 && typeof stream[i] === \"function\") {\n          this[i] = stream[i].bind(stream);\n        }\n      }\n      return this;\n    };\n    Readable.prototype[SymbolAsyncIterator] = function () {\n      return streamToAsyncIterator(this);\n    };\n    Readable.prototype.iterator = function (options) {\n      if (options !== void 0) {\n        validateObject(options, \"options\");\n      }\n      return streamToAsyncIterator(this, options);\n    };\n    function streamToAsyncIterator(stream, options) {\n      if (typeof stream.read !== \"function\") {\n        stream = Readable.wrap(stream, {\n          objectMode: true,\n        });\n      }\n      const iter = createAsyncIterator(stream, options);\n      iter.stream = stream;\n      return iter;\n    }\n    async function* createAsyncIterator(stream, options) {\n      let callback = nop;\n      function next(resolve) {\n        if (this === stream) {\n          callback();\n          callback = nop;\n        } else {\n          callback = resolve;\n        }\n      }\n      stream.on(\"readable\", next);\n      let error;\n      const cleanup = eos(\n        stream,\n        {\n          writable: false,\n        },\n        err => {\n          error = err ? aggregateTwoErrors(error, err) : null;\n          callback();\n          callback = nop;\n        },\n      );\n      try {\n        while (true) {\n          const chunk = stream.destroyed ? null : stream.read();\n          if (chunk !== null) {\n            yield chunk;\n          } else if (error) {\n            throw error;\n          } else if (error === null) {\n            return;\n          } else {\n            await new Promise2(next);\n          }\n        }\n      } catch (err) {\n        error = aggregateTwoErrors(error, err);\n        throw error;\n      } finally {\n        if (\n          (error || (options === null || options === void 0 ? void 0 : options.destroyOnReturn) !== false) &&\n          (error === void 0 || stream._readableState.autoDestroy)\n        ) {\n          destroyImpl.destroyer(stream, null);\n        } else {\n          stream.off(\"readable\", next);\n          cleanup();\n        }\n      }\n    }\n    ObjectDefineProperties(Readable.prototype, {\n      readable: {\n        get() {\n          const r = this._readableState;\n          return !!r && r.readable !== false && !r.destroyed && !r.errorEmitted && !r.endEmitted;\n        },\n        set(val) {\n          if (this._readableState) {\n            this._readableState.readable = !!val;\n          }\n        },\n      },\n      readableDidRead: {\n        enumerable: false,\n        get: function () {\n          return this._readableState.dataEmitted;\n        },\n      },\n      readableAborted: {\n        enumerable: false,\n        get: function () {\n          return !!(\n            this._readableState.readable !== false &&\n            (this._readableState.destroyed || this._readableState.errored) &&\n            !this._readableState.endEmitted\n          );\n        },\n      },\n      readableHighWaterMark: {\n        enumerable: false,\n        get: function () {\n          return this._readableState.highWaterMark;\n        },\n      },\n      readableBuffer: {\n        enumerable: false,\n        get: function () {\n          return this._readableState && this._readableState.buffer;\n        },\n      },\n      readableFlowing: {\n        enumerable: false,\n        get: function () {\n          return this._readableState.flowing;\n        },\n        set: function (state) {\n          if (this._readableState) {\n            this._readableState.flowing = state;\n          }\n        },\n      },\n      readableLength: {\n        enumerable: false,\n        get() {\n          return this._readableState.length;\n        },\n      },\n      readableObjectMode: {\n        enumerable: false,\n        get() {\n          return this._readableState ? this._readableState.objectMode : false;\n        },\n      },\n      readableEncoding: {\n        enumerable: false,\n        get() {\n          return this._readableState ? this._readableState.encoding : null;\n        },\n      },\n      errored: {\n        enumerable: false,\n        get() {\n          return this._readableState ? this._readableState.errored : null;\n        },\n      },\n      closed: {\n        get() {\n          return this._readableState ? this._readableState.closed : false;\n        },\n      },\n      destroyed: {\n        enumerable: false,\n        get() {\n          return this._readableState ? this._readableState.destroyed : false;\n        },\n        set(value) {\n          if (!this._readableState) {\n            return;\n          }\n          this._readableState.destroyed = value;\n        },\n      },\n      readableEnded: {\n        enumerable: false,\n        get() {\n          return this._readableState ? this._readableState.endEmitted : false;\n        },\n      },\n    });\n    Readable._fromList = fromList;\n    function fromList(n, state) {\n      if (state.length === 0) return null;\n      let ret;\n      if (state.objectMode) ret = state.buffer.shift();\n      else if (!n || n >= state.length) {\n        if (state.decoder) ret = state.buffer.join(\"\");\n        else if (state.buffer.length === 1) ret = state.buffer.first();\n        else ret = state.buffer.concat(state.length);\n        state.buffer.clear();\n      } else {\n        ret = state.buffer.consume(n, state.decoder);\n      }\n      return ret;\n    }\n    function endReadable(stream) {\n      const state = stream._readableState;\n      __DEBUG__ && debug(\"endEmitted @ endReadable\", state.endEmitted, stream.__id);\n      if (!state.endEmitted) {\n        state.ended = true;\n        runOnNextTick(endReadableNT, state, stream);\n      }\n    }\n    function endReadableNT(state, stream) {\n      __DEBUG__ && debug(\"endReadableNT -- endEmitted, state.length\", state.endEmitted, state.length, stream.__id);\n      if (!state.errored && !state.closeEmitted && !state.endEmitted && state.length === 0) {\n        state.endEmitted = true;\n        stream.emit(\"end\");\n        __DEBUG__ && debug(\"end emitted @ endReadableNT\", stream.__id);\n        if (stream.writable && stream.allowHalfOpen === false) {\n          runOnNextTick(endWritableNT, stream);\n        } else if (state.autoDestroy) {\n          const wState = stream._writableState;\n          const autoDestroy = !wState || (wState.autoDestroy && (wState.finished || wState.writable === false));\n          if (autoDestroy) {\n            stream.destroy();\n          }\n        }\n      }\n    }\n    function endWritableNT(stream) {\n      const writable = stream.writable && !stream.writableEnded && !stream.destroyed;\n      if (writable) {\n        stream.end();\n      }\n    }\n    Readable.from = function (iterable, opts) {\n      return from(Readable, iterable, opts);\n    };\n    var webStreamsAdapters = {\n      newStreamReadableFromReadableStream,\n    };\n    function lazyWebStreams() {\n      if (webStreamsAdapters === void 0) webStreamsAdapters = {};\n      return webStreamsAdapters;\n    }\n    Readable.fromWeb = function (readableStream, options) {\n      return lazyWebStreams().newStreamReadableFromReadableStream(readableStream, options);\n    };\n    Readable.toWeb = function (streamReadable) {\n      return lazyWebStreams().newReadableStreamFromStreamReadable(streamReadable);\n    };\n    Readable.wrap = function (src, options) {\n      var _ref, _src$readableObjectMo;\n      return new Readable({\n        objectMode:\n          (_ref =\n            (_src$readableObjectMo = src.readableObjectMode) !== null && _src$readableObjectMo !== void 0\n              ? _src$readableObjectMo\n              : src.objectMode) !== null && _ref !== void 0\n            ? _ref\n            : true,\n        ...options,\n        destroy(err, callback) {\n          destroyImpl.destroyer(src, err);\n          callback(err);\n        },\n      }).wrap(src);\n    };\n  },\n});\n\n// node_modules/readable-stream/lib/internal/streams/writable.js\nvar require_writable = __commonJS({\n  \"node_modules/readable-stream/lib/internal/streams/writable.js\"(exports, module) {\n    \"use strict\";\n    var {\n      ArrayPrototypeSlice,\n      Error: Error2,\n      FunctionPrototypeSymbolHasInstance,\n      ObjectDefineProperty,\n      ObjectDefineProperties,\n      ObjectSetPrototypeOf,\n      StringPrototypeToLowerCase,\n      Symbol: Symbol2,\n      SymbolHasInstance,\n    } = require_primordials();\n\n    var { EventEmitter: EE } = __require(\"bun:events_native\");\n    var Stream = require_legacy().Stream;\n    var destroyImpl = require_destroy();\n    var { addAbortSignal } = require_add_abort_signal();\n    var { getHighWaterMark, getDefaultHighWaterMark } = require_state();\n    var {\n      ERR_INVALID_ARG_TYPE,\n      ERR_METHOD_NOT_IMPLEMENTED,\n      ERR_MULTIPLE_CALLBACK,\n      ERR_STREAM_CANNOT_PIPE,\n      ERR_STREAM_DESTROYED,\n      ERR_STREAM_ALREADY_FINISHED,\n      ERR_STREAM_NULL_VALUES,\n      ERR_STREAM_WRITE_AFTER_END,\n      ERR_UNKNOWN_ENCODING,\n    } = require_errors().codes;\n    var { errorOrDestroy } = destroyImpl;\n\n    function Writable(options = {}) {\n      const isDuplex = this instanceof require_duplex();\n      if (!isDuplex && !FunctionPrototypeSymbolHasInstance(Writable, this)) return new Writable(options);\n      this._writableState = new WritableState(options, this, isDuplex);\n      if (options) {\n        if (typeof options.write === \"function\") this._write = options.write;\n        if (typeof options.writev === \"function\") this._writev = options.writev;\n        if (typeof options.destroy === \"function\") this._destroy = options.destroy;\n        if (typeof options.final === \"function\") this._final = options.final;\n        if (typeof options.construct === \"function\") this._construct = options.construct;\n        if (options.signal) addAbortSignal(options.signal, this);\n      }\n      Stream.call(this, options);\n\n      destroyImpl.construct(this, () => {\n        const state = this._writableState;\n        if (!state.writing) {\n          clearBuffer(this, state);\n        }\n        finishMaybe(this, state);\n      });\n    }\n    ObjectSetPrototypeOf(Writable.prototype, Stream.prototype);\n    ObjectSetPrototypeOf(Writable, Stream);\n    module.exports = Writable;\n\n    function nop() {}\n    var kOnFinished = Symbol2(\"kOnFinished\");\n    function WritableState(options, stream, isDuplex) {\n      if (typeof isDuplex !== \"boolean\") isDuplex = stream instanceof require_duplex();\n      this.objectMode = !!(options && options.objectMode);\n      if (isDuplex) this.objectMode = this.objectMode || !!(options && options.writableObjectMode);\n      this.highWaterMark = options\n        ? getHighWaterMark(this, options, \"writableHighWaterMark\", isDuplex)\n        : getDefaultHighWaterMark(false);\n      this.finalCalled = false;\n      this.needDrain = false;\n      this.ending = false;\n      this.ended = false;\n      this.finished = false;\n      this.destroyed = false;\n      const noDecode = !!(options && options.decodeStrings === false);\n      this.decodeStrings = !noDecode;\n      this.defaultEncoding = (options && options.defaultEncoding) || \"utf8\";\n      this.length = 0;\n      this.writing = false;\n      this.corked = 0;\n      this.sync = true;\n      this.bufferProcessing = false;\n      this.onwrite = onwrite.bind(void 0, stream);\n      this.writecb = null;\n      this.writelen = 0;\n      this.afterWriteTickInfo = null;\n      resetBuffer(this);\n      this.pendingcb = 0;\n      this.constructed = true;\n      this.prefinished = false;\n      this.errorEmitted = false;\n      this.emitClose = !options || options.emitClose !== false;\n      this.autoDestroy = !options || options.autoDestroy !== false;\n      this.errored = null;\n      this.closed = false;\n      this.closeEmitted = false;\n      this[kOnFinished] = [];\n    }\n    function resetBuffer(state) {\n      state.buffered = [];\n      state.bufferedIndex = 0;\n      state.allBuffers = true;\n      state.allNoop = true;\n    }\n    WritableState.prototype.getBuffer = function getBuffer() {\n      return ArrayPrototypeSlice(this.buffered, this.bufferedIndex);\n    };\n    ObjectDefineProperty(WritableState.prototype, \"bufferedRequestCount\", {\n      get() {\n        return this.buffered.length - this.bufferedIndex;\n      },\n    });\n\n    ObjectDefineProperty(Writable, SymbolHasInstance, {\n      value: function (object) {\n        if (FunctionPrototypeSymbolHasInstance(this, object)) return true;\n        if (this !== Writable) return false;\n        return object && object._writableState instanceof WritableState;\n      },\n    });\n    Writable.prototype.pipe = function () {\n      errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());\n    };\n    function _write(stream, chunk, encoding, cb) {\n      const state = stream._writableState;\n      if (typeof encoding === \"function\") {\n        cb = encoding;\n        encoding = state.defaultEncoding;\n      } else {\n        if (!encoding) encoding = state.defaultEncoding;\n        else if (encoding !== \"buffer\" && !Buffer.isEncoding(encoding)) throw new ERR_UNKNOWN_ENCODING(encoding);\n        if (typeof cb !== \"function\") cb = nop;\n      }\n      if (chunk === null) {\n        throw new ERR_STREAM_NULL_VALUES();\n      } else if (!state.objectMode) {\n        if (typeof chunk === \"string\") {\n          if (state.decodeStrings !== false) {\n            chunk = Buffer.from(chunk, encoding);\n            encoding = \"buffer\";\n          }\n        } else if (chunk instanceof Buffer) {\n          encoding = \"buffer\";\n        } else if (Stream._isUint8Array(chunk)) {\n          chunk = Stream._uint8ArrayToBuffer(chunk);\n          encoding = \"buffer\";\n        } else {\n          throw new ERR_INVALID_ARG_TYPE(\"chunk\", [\"string\", \"Buffer\", \"Uint8Array\"], chunk);\n        }\n      }\n      let err;\n      if (state.ending) {\n        err = new ERR_STREAM_WRITE_AFTER_END();\n      } else if (state.destroyed) {\n        err = new ERR_STREAM_DESTROYED(\"write\");\n      }\n      if (err) {\n        runOnNextTick(cb, err);\n        errorOrDestroy(stream, err, true);\n        return err;\n      }\n      state.pendingcb++;\n      return writeOrBuffer(stream, state, chunk, encoding, cb);\n    }\n    Writable.prototype.write = function (chunk, encoding, cb) {\n      return _write(this, chunk, encoding, cb) === true;\n    };\n    Writable.prototype.cork = function () {\n      this._writableState.corked++;\n    };\n    Writable.prototype.uncork = function () {\n      const state = this._writableState;\n      if (state.corked) {\n        state.corked--;\n        if (!state.writing) clearBuffer(this, state);\n      }\n    };\n    Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {\n      if (typeof encoding === \"string\") encoding = StringPrototypeToLowerCase(encoding);\n      if (!Buffer.isEncoding(encoding)) throw new ERR_UNKNOWN_ENCODING(encoding);\n      this._writableState.defaultEncoding = encoding;\n      return this;\n    };\n    function writeOrBuffer(stream, state, chunk, encoding, callback) {\n      const len = state.objectMode ? 1 : chunk.length;\n      state.length += len;\n      const ret = state.length < state.highWaterMark;\n      if (!ret) state.needDrain = true;\n      if (state.writing || state.corked || state.errored || !state.constructed) {\n        state.buffered.push({\n          chunk,\n          encoding,\n          callback,\n        });\n        if (state.allBuffers && encoding !== \"buffer\") {\n          state.allBuffers = false;\n        }\n        if (state.allNoop && callback !== nop) {\n          state.allNoop = false;\n        }\n      } else {\n        state.writelen = len;\n        state.writecb = callback;\n        state.writing = true;\n        state.sync = true;\n        stream._write(chunk, encoding, state.onwrite);\n        state.sync = false;\n      }\n      return ret && !state.errored && !state.destroyed;\n    }\n    function doWrite(stream, state, writev, len, chunk, encoding, cb) {\n      state.writelen = len;\n      state.writecb = cb;\n      state.writing = true;\n      state.sync = true;\n      if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED(\"write\"));\n      else if (writev) stream._writev(chunk, state.onwrite);\n      else stream._write(chunk, encoding, state.onwrite);\n      state.sync = false;\n    }\n    function onwriteError(stream, state, er, cb) {\n      --state.pendingcb;\n      cb(er);\n      errorBuffer(state);\n      errorOrDestroy(stream, er);\n    }\n    function onwrite(stream, er) {\n      const state = stream._writableState;\n      const sync = state.sync;\n      const cb = state.writecb;\n      if (typeof cb !== \"function\") {\n        errorOrDestroy(stream, new ERR_MULTIPLE_CALLBACK());\n        return;\n      }\n      state.writing = false;\n      state.writecb = null;\n      state.length -= state.writelen;\n      state.writelen = 0;\n      if (er) {\n        Error.captureStackTrace(er);\n        if (!state.errored) {\n          state.errored = er;\n        }\n        if (stream._readableState && !stream._readableState.errored) {\n          stream._readableState.errored = er;\n        }\n        if (sync) {\n          runOnNextTick(onwriteError, stream, state, er, cb);\n        } else {\n          onwriteError(stream, state, er, cb);\n        }\n      } else {\n        if (state.buffered.length > state.bufferedIndex) {\n          clearBuffer(stream, state);\n        }\n        if (sync) {\n          if (state.afterWriteTickInfo !== null && state.afterWriteTickInfo.cb === cb) {\n            state.afterWriteTickInfo.count++;\n          } else {\n            state.afterWriteTickInfo = {\n              count: 1,\n              cb,\n              stream,\n              state,\n            };\n            runOnNextTick(afterWriteTick, state.afterWriteTickInfo);\n          }\n        } else {\n          afterWrite(stream, state, 1, cb);\n        }\n      }\n    }\n    function afterWriteTick({ stream, state, count, cb }) {\n      state.afterWriteTickInfo = null;\n      return afterWrite(stream, state, count, cb);\n    }\n    function afterWrite(stream, state, count, cb) {\n      const needDrain = !state.ending && !stream.destroyed && state.length === 0 && state.needDrain;\n      if (needDrain) {\n        state.needDrain = false;\n        stream.emit(\"drain\");\n      }\n      while (count-- > 0) {\n        state.pendingcb--;\n        cb();\n      }\n      if (state.destroyed) {\n        errorBuffer(state);\n      }\n      finishMaybe(stream, state);\n    }\n    function errorBuffer(state) {\n      if (state.writing) {\n        return;\n      }\n      for (let n = state.bufferedIndex; n < state.buffered.length; ++n) {\n        var _state$errored;\n        const { chunk, callback } = state.buffered[n];\n        const len = state.objectMode ? 1 : chunk.length;\n        state.length -= len;\n        callback(\n          (_state$errored = state.errored) !== null && _state$errored !== void 0\n            ? _state$errored\n            : new ERR_STREAM_DESTROYED(\"write\"),\n        );\n      }\n      const onfinishCallbacks = state[kOnFinished].splice(0);\n      for (let i = 0; i < onfinishCallbacks.length; i++) {\n        var _state$errored2;\n        onfinishCallbacks[i](\n          (_state$errored2 = state.errored) !== null && _state$errored2 !== void 0\n            ? _state$errored2\n            : new ERR_STREAM_DESTROYED(\"end\"),\n        );\n      }\n      resetBuffer(state);\n    }\n    function clearBuffer(stream, state) {\n      if (state.corked || state.bufferProcessing || state.destroyed || !state.constructed) {\n        return;\n      }\n      const { buffered, bufferedIndex, objectMode } = state;\n      const bufferedLength = buffered.length - bufferedIndex;\n      if (!bufferedLength) {\n        return;\n      }\n      let i = bufferedIndex;\n      state.bufferProcessing = true;\n      if (bufferedLength > 1 && stream._writev) {\n        state.pendingcb -= bufferedLength - 1;\n        const callback = state.allNoop\n          ? nop\n          : err => {\n              for (let n = i; n < buffered.length; ++n) {\n                buffered[n].callback(err);\n              }\n            };\n        const chunks = state.allNoop && i === 0 ? buffered : ArrayPrototypeSlice(buffered, i);\n        chunks.allBuffers = state.allBuffers;\n        doWrite(stream, state, true, state.length, chunks, \"\", callback);\n        resetBuffer(state);\n      } else {\n        do {\n          const { chunk, encoding, callback } = buffered[i];\n          buffered[i++] = null;\n          const len = objectMode ? 1 : chunk.length;\n          doWrite(stream, state, false, len, chunk, encoding, callback);\n        } while (i < buffered.length && !state.writing);\n        if (i === buffered.length) {\n          resetBuffer(state);\n        } else if (i > 256) {\n          buffered.splice(0, i);\n          state.bufferedIndex = 0;\n        } else {\n          state.bufferedIndex = i;\n        }\n      }\n      state.bufferProcessing = false;\n    }\n    Writable.prototype._write = function (chunk, encoding, cb) {\n      if (this._writev) {\n        this._writev(\n          [\n            {\n              chunk,\n              encoding,\n            },\n          ],\n          cb,\n        );\n      } else {\n        throw new ERR_METHOD_NOT_IMPLEMENTED(\"_write()\");\n      }\n    };\n    Writable.prototype._writev = null;\n    Writable.prototype.end = function (chunk, encoding, cb, native = false) {\n      const state = this._writableState;\n      __DEBUG__ && debug(\"end\", state, this.__id);\n      if (typeof chunk === \"function\") {\n        cb = chunk;\n        chunk = null;\n        encoding = null;\n      } else if (typeof encoding === \"function\") {\n        cb = encoding;\n        encoding = null;\n      }\n      let err;\n      if (chunk !== null && chunk !== void 0) {\n        let ret;\n        if (!native) {\n          ret = _write(this, chunk, encoding);\n        } else {\n          ret = this.write(chunk, encoding);\n        }\n        if (ret instanceof Error2) {\n          err = ret;\n        }\n      }\n      if (state.corked) {\n        state.corked = 1;\n        this.uncork();\n      }\n      if (err) {\n        this.emit(\"error\", err);\n      } else if (!state.errored && !state.ending) {\n        state.ending = true;\n        finishMaybe(this, state, true);\n        state.ended = true;\n      } else if (state.finished) {\n        err = new ERR_STREAM_ALREADY_FINISHED(\"end\");\n      } else if (state.destroyed) {\n        err = new ERR_STREAM_DESTROYED(\"end\");\n      }\n      if (typeof cb === \"function\") {\n        if (err || state.finished) {\n          runOnNextTick(cb, err);\n        } else {\n          state[kOnFinished].push(cb);\n        }\n      }\n      return this;\n    };\n    function needFinish(state, tag) {\n      var needFinish =\n        state.ending &&\n        !state.destroyed &&\n        state.constructed &&\n        state.length === 0 &&\n        !state.errored &&\n        state.buffered.length === 0 &&\n        !state.finished &&\n        !state.writing &&\n        !state.errorEmitted &&\n        !state.closeEmitted;\n      debug(\"needFinish\", needFinish, tag);\n      return needFinish;\n    }\n    function callFinal(stream, state) {\n      let called = false;\n      function onFinish(err) {\n        if (called) {\n          errorOrDestroy(stream, err !== null && err !== void 0 ? err : ERR_MULTIPLE_CALLBACK());\n          return;\n        }\n        called = true;\n        state.pendingcb--;\n        if (err) {\n          const onfinishCallbacks = state[kOnFinished].splice(0);\n          for (let i = 0; i < onfinishCallbacks.length; i++) {\n            onfinishCallbacks[i](err);\n          }\n          errorOrDestroy(stream, err, state.sync);\n        } else if (needFinish(state)) {\n          state.prefinished = true;\n          stream.emit(\"prefinish\");\n          state.pendingcb++;\n          runOnNextTick(finish, stream, state);\n        }\n      }\n      state.sync = true;\n      state.pendingcb++;\n      try {\n        stream._final(onFinish);\n      } catch (err) {\n        onFinish(err);\n      }\n      state.sync = false;\n    }\n    function prefinish(stream, state) {\n      if (!state.prefinished && !state.finalCalled) {\n        if (typeof stream._final === \"function\" && !state.destroyed) {\n          state.finalCalled = true;\n          callFinal(stream, state);\n        } else {\n          state.prefinished = true;\n          stream.emit(\"prefinish\");\n        }\n      }\n    }\n    function finishMaybe(stream, state, sync) {\n      __DEBUG__ && debug(\"finishMaybe -- state, sync\", state, sync, stream.__id);\n\n      if (!needFinish(state, stream.__id)) return;\n\n      prefinish(stream, state);\n      if (state.pendingcb === 0) {\n        if (sync) {\n          state.pendingcb++;\n          runOnNextTick(\n            (stream2, state2) => {\n              if (needFinish(state2)) {\n                finish(stream2, state2);\n              } else {\n                state2.pendingcb--;\n              }\n            },\n            stream,\n            state,\n          );\n        } else if (needFinish(state)) {\n          state.pendingcb++;\n          finish(stream, state);\n        }\n      }\n    }\n    function finish(stream, state) {\n      state.pendingcb--;\n      state.finished = true;\n      const onfinishCallbacks = state[kOnFinished].splice(0);\n      for (let i = 0; i < onfinishCallbacks.length; i++) {\n        onfinishCallbacks[i]();\n      }\n      stream.emit(\"finish\");\n      if (state.autoDestroy) {\n        const rState = stream._readableState;\n        const autoDestroy = !rState || (rState.autoDestroy && (rState.endEmitted || rState.readable === false));\n        if (autoDestroy) {\n          stream.destroy();\n        }\n      }\n    }\n    ObjectDefineProperties(Writable.prototype, {\n      closed: {\n        get() {\n          return this._writableState ? this._writableState.closed : false;\n        },\n      },\n      destroyed: {\n        get() {\n          return this._writableState ? this._writableState.destroyed : false;\n        },\n        set(value) {\n          if (this._writableState) {\n            this._writableState.destroyed = value;\n          }\n        },\n      },\n      writable: {\n        get() {\n          const w = this._writableState;\n          return !!w && w.writable !== false && !w.destroyed && !w.errored && !w.ending && !w.ended;\n        },\n        set(val) {\n          if (this._writableState) {\n            this._writableState.writable = !!val;\n          }\n        },\n      },\n      writableFinished: {\n        get() {\n          return this._writableState ? this._writableState.finished : false;\n        },\n      },\n      writableObjectMode: {\n        get() {\n          return this._writableState ? this._writableState.objectMode : false;\n        },\n      },\n      writableBuffer: {\n        get() {\n          return this._writableState && this._writableState.getBuffer();\n        },\n      },\n      writableEnded: {\n        get() {\n          return this._writableState ? this._writableState.ending : false;\n        },\n      },\n      writableNeedDrain: {\n        get() {\n          const wState = this._writableState;\n          if (!wState) return false;\n          return !wState.destroyed && !wState.ending && wState.needDrain;\n        },\n      },\n      writableHighWaterMark: {\n        get() {\n          return this._writableState && this._writableState.highWaterMark;\n        },\n      },\n      writableCorked: {\n        get() {\n          return this._writableState ? this._writableState.corked : 0;\n        },\n      },\n      writableLength: {\n        get() {\n          return this._writableState && this._writableState.length;\n        },\n      },\n      errored: {\n        enumerable: false,\n        get() {\n          return this._writableState ? this._writableState.errored : null;\n        },\n      },\n      writableAborted: {\n        enumerable: false,\n        get: function () {\n          return !!(\n            this._writableState.writable !== false &&\n            (this._writableState.destroyed || this._writableState.errored) &&\n            !this._writableState.finished\n          );\n        },\n      },\n    });\n    var destroy = destroyImpl.destroy;\n    Writable.prototype.destroy = function (err, cb) {\n      const state = this._writableState;\n      if (!state.destroyed && (state.bufferedIndex < state.buffered.length || state[kOnFinished].length)) {\n        runOnNextTick(errorBuffer, state);\n      }\n      destroy.call(this, err, cb);\n      return this;\n    };\n    Writable.prototype._undestroy = destroyImpl.undestroy;\n    Writable.prototype._destroy = function (err, cb) {\n      cb(err);\n    };\n    Writable.prototype[EE.captureRejectionSymbol] = function (err) {\n      this.destroy(err);\n    };\n    var webStreamsAdapters;\n    function lazyWebStreams() {\n      if (webStreamsAdapters === void 0) webStreamsAdapters = {};\n      return webStreamsAdapters;\n    }\n    Writable.fromWeb = function (writableStream, options) {\n      return lazyWebStreams().newStreamWritableFromWritableStream(writableStream, options);\n    };\n    Writable.toWeb = function (streamWritable) {\n      return lazyWebStreams().newWritableStreamFromStreamWritable(streamWritable);\n    };\n  },\n});\n\n// node_modules/readable-stream/lib/internal/streams/duplexify.js\nvar require_duplexify = __commonJS({\n  \"node_modules/readable-stream/lib/internal/streams/duplexify.js\"(exports, module) {\n    \"use strict\";\n    var bufferModule = __require(\"buffer\");\n    var {\n      isReadable,\n      isWritable,\n      isIterable,\n      isNodeStream,\n      isReadableNodeStream,\n      isWritableNodeStream,\n      isDuplexNodeStream,\n    } = require_utils();\n    var eos = require_end_of_stream();\n    var {\n      AbortError,\n      codes: { ERR_INVALID_ARG_TYPE, ERR_INVALID_RETURN_VALUE },\n    } = require_errors();\n    var { destroyer } = require_destroy();\n    var Duplex = require_duplex();\n    var Readable = require_readable();\n    var { createDeferredPromise } = require_util();\n    var from = require_from();\n    var Blob = globalThis.Blob || bufferModule.Blob;\n    var isBlob =\n      typeof Blob !== \"undefined\"\n        ? function isBlob2(b) {\n            return b instanceof Blob;\n          }\n        : function isBlob2(b) {\n            return false;\n          };\n    var AbortController = globalThis.AbortController || __require(\"abort-controller\").AbortController;\n    var { FunctionPrototypeCall } = require_primordials();\n    class Duplexify extends Duplex {\n      constructor(options) {\n        super(options);\n\n        // https://github.com/nodejs/node/pull/34385\n\n        if ((options === null || options === undefined ? undefined : options.readable) === false) {\n          this._readableState.readable = false;\n          this._readableState.ended = true;\n          this._readableState.endEmitted = true;\n        }\n        if ((options === null || options === undefined ? undefined : options.writable) === false) {\n          this._writableState.writable = false;\n          this._writableState.ending = true;\n          this._writableState.ended = true;\n          this._writableState.finished = true;\n        }\n      }\n    }\n    module.exports = function duplexify(body, name) {\n      if (isDuplexNodeStream(body)) {\n        return body;\n      }\n      if (isReadableNodeStream(body)) {\n        return _duplexify({\n          readable: body,\n        });\n      }\n      if (isWritableNodeStream(body)) {\n        return _duplexify({\n          writable: body,\n        });\n      }\n      if (isNodeStream(body)) {\n        return _duplexify({\n          writable: false,\n          readable: false,\n        });\n      }\n      if (typeof body === \"function\") {\n        const { value, write, final, destroy } = fromAsyncGen(body);\n        if (isIterable(value)) {\n          return from(Duplexify, value, {\n            objectMode: true,\n            write,\n            final,\n            destroy,\n          });\n        }\n        const then2 = value === null || value === void 0 ? void 0 : value.then;\n        if (typeof then2 === \"function\") {\n          let d;\n          const promise = FunctionPrototypeCall(\n            then2,\n            value,\n            val => {\n              if (val != null) {\n                throw new ERR_INVALID_RETURN_VALUE(\"nully\", \"body\", val);\n              }\n            },\n            err => {\n              destroyer(d, err);\n            },\n          );\n          return (d = new Duplexify({\n            objectMode: true,\n            readable: false,\n            write,\n            final(cb) {\n              final(async () => {\n                try {\n                  await promise;\n                  runOnNextTick(cb, null);\n                } catch (err) {\n                  runOnNextTick(cb, err);\n                }\n              });\n            },\n            destroy,\n          }));\n        }\n        throw new ERR_INVALID_RETURN_VALUE(\"Iterable, AsyncIterable or AsyncFunction\", name, value);\n      }\n      if (isBlob(body)) {\n        return duplexify(body.arrayBuffer());\n      }\n      if (isIterable(body)) {\n        return from(Duplexify, body, {\n          objectMode: true,\n          writable: false,\n        });\n      }\n      if (\n        typeof (body === null || body === void 0 ? void 0 : body.writable) === \"object\" ||\n        typeof (body === null || body === void 0 ? void 0 : body.readable) === \"object\"\n      ) {\n        const readable =\n          body !== null && body !== void 0 && body.readable\n            ? isReadableNodeStream(body === null || body === void 0 ? void 0 : body.readable)\n              ? body === null || body === void 0\n                ? void 0\n                : body.readable\n              : duplexify(body.readable)\n            : void 0;\n        const writable =\n          body !== null && body !== void 0 && body.writable\n            ? isWritableNodeStream(body === null || body === void 0 ? void 0 : body.writable)\n              ? body === null || body === void 0\n                ? void 0\n                : body.writable\n              : duplexify(body.writable)\n            : void 0;\n        return _duplexify({\n          readable,\n          writable,\n        });\n      }\n      const then = body === null || body === void 0 ? void 0 : body.then;\n      if (typeof then === \"function\") {\n        let d;\n        FunctionPrototypeCall(\n          then,\n          body,\n          val => {\n            if (val != null) {\n              d.push(val);\n            }\n            d.push(null);\n          },\n          err => {\n            destroyer(d, err);\n          },\n        );\n        return (d = new Duplexify({\n          objectMode: true,\n          writable: false,\n          read() {},\n        }));\n      }\n      throw new ERR_INVALID_ARG_TYPE(\n        name,\n        [\n          \"Blob\",\n          \"ReadableStream\",\n          \"WritableStream\",\n          \"Stream\",\n          \"Iterable\",\n          \"AsyncIterable\",\n          \"Function\",\n          \"{ readable, writable } pair\",\n          \"Promise\",\n        ],\n        body,\n      );\n    };\n    function fromAsyncGen(fn) {\n      let { promise, resolve } = createDeferredPromise();\n      const ac = new AbortController();\n      const signal = ac.signal;\n      const value = fn(\n        (async function* () {\n          while (true) {\n            const _promise = promise;\n            promise = null;\n            const { chunk, done, cb } = await _promise;\n            runOnNextTick(cb);\n            if (done) return;\n            if (signal.aborted)\n              throw new AbortError(void 0, {\n                cause: signal.reason,\n              });\n            ({ promise, resolve } = createDeferredPromise());\n            yield chunk;\n          }\n        })(),\n        {\n          signal,\n        },\n      );\n      return {\n        value,\n        write(chunk, encoding, cb) {\n          const _resolve = resolve;\n          resolve = null;\n          _resolve({\n            chunk,\n            done: false,\n            cb,\n          });\n        },\n        final(cb) {\n          const _resolve = resolve;\n          resolve = null;\n          _resolve({\n            done: true,\n            cb,\n          });\n        },\n        destroy(err, cb) {\n          ac.abort();\n          cb(err);\n        },\n      };\n    }\n    function _duplexify(pair) {\n      const r =\n        pair.readable && typeof pair.readable.read !== \"function\" ? Readable.wrap(pair.readable) : pair.readable;\n      const w = pair.writable;\n      let readable = !!isReadable(r);\n      let writable = !!isWritable(w);\n      let ondrain;\n      let onfinish;\n      let onreadable;\n      let onclose;\n      let d;\n      function onfinished(err) {\n        const cb = onclose;\n        onclose = null;\n        if (cb) {\n          cb(err);\n        } else if (err) {\n          d.destroy(err);\n        } else if (!readable && !writable) {\n          d.destroy();\n        }\n      }\n      d = new Duplexify({\n        readableObjectMode: !!(r !== null && r !== void 0 && r.readableObjectMode),\n        writableObjectMode: !!(w !== null && w !== void 0 && w.writableObjectMode),\n        readable,\n        writable,\n      });\n      if (writable) {\n        eos(w, err => {\n          writable = false;\n          if (err) {\n            destroyer(r, err);\n          }\n          onfinished(err);\n        });\n        d._write = function (chunk, encoding, callback) {\n          if (w.write(chunk, encoding)) {\n            callback();\n          } else {\n            ondrain = callback;\n          }\n        };\n        d._final = function (callback) {\n          w.end();\n          onfinish = callback;\n        };\n        w.on(\"drain\", function () {\n          if (ondrain) {\n            const cb = ondrain;\n            ondrain = null;\n            cb();\n          }\n        });\n        w.on(\"finish\", function () {\n          if (onfinish) {\n            const cb = onfinish;\n            onfinish = null;\n            cb();\n          }\n        });\n      }\n      if (readable) {\n        eos(r, err => {\n          readable = false;\n          if (err) {\n            destroyer(r, err);\n          }\n          onfinished(err);\n        });\n        r.on(\"readable\", function () {\n          if (onreadable) {\n            const cb = onreadable;\n            onreadable = null;\n            cb();\n          }\n        });\n        r.on(\"end\", function () {\n          d.push(null);\n        });\n        d._read = function () {\n          while (true) {\n            const buf = r.read();\n            if (buf === null) {\n              onreadable = d._read;\n              return;\n            }\n            if (!d.push(buf)) {\n              return;\n            }\n          }\n        };\n      }\n      d._destroy = function (err, callback) {\n        if (!err && onclose !== null) {\n          err = new AbortError();\n        }\n        onreadable = null;\n        ondrain = null;\n        onfinish = null;\n        if (onclose === null) {\n          callback(err);\n        } else {\n          onclose = callback;\n          destroyer(w, err);\n          destroyer(r, err);\n        }\n      };\n      return d;\n    }\n  },\n});\n\n// node_modules/readable-stream/lib/internal/streams/duplex.js\nvar require_duplex = __commonJS({\n  \"node_modules/readable-stream/lib/internal/streams/duplex.js\"(exports, module) {\n    \"use strict\";\n    var { ObjectDefineProperties, ObjectGetOwnPropertyDescriptor, ObjectKeys, ObjectSetPrototypeOf } =\n      require_primordials();\n\n    var Readable = require_readable();\n\n    function Duplex(options) {\n      if (!(this instanceof Duplex)) return new Duplex(options);\n      Readable.call(this, options);\n      Writable.call(this, options);\n\n      if (options) {\n        this.allowHalfOpen = options.allowHalfOpen !== false;\n        if (options.readable === false) {\n          this._readableState.readable = false;\n          this._readableState.ended = true;\n          this._readableState.endEmitted = true;\n        }\n        if (options.writable === false) {\n          this._writableState.writable = false;\n          this._writableState.ending = true;\n          this._writableState.ended = true;\n          this._writableState.finished = true;\n        }\n      } else {\n        this.allowHalfOpen = true;\n      }\n    }\n    module.exports = Duplex;\n\n    ObjectSetPrototypeOf(Duplex.prototype, Readable.prototype);\n    ObjectSetPrototypeOf(Duplex, Readable);\n\n    {\n      for (var method in Writable.prototype) {\n        if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];\n      }\n    }\n\n    ObjectDefineProperties(Duplex.prototype, {\n      writable: ObjectGetOwnPropertyDescriptor(Writable.prototype, \"writable\"),\n      writableHighWaterMark: ObjectGetOwnPropertyDescriptor(Writable.prototype, \"writableHighWaterMark\"),\n      writableObjectMode: ObjectGetOwnPropertyDescriptor(Writable.prototype, \"writableObjectMode\"),\n      writableBuffer: ObjectGetOwnPropertyDescriptor(Writable.prototype, \"writableBuffer\"),\n      writableLength: ObjectGetOwnPropertyDescriptor(Writable.prototype, \"writableLength\"),\n      writableFinished: ObjectGetOwnPropertyDescriptor(Writable.prototype, \"writableFinished\"),\n      writableCorked: ObjectGetOwnPropertyDescriptor(Writable.prototype, \"writableCorked\"),\n      writableEnded: ObjectGetOwnPropertyDescriptor(Writable.prototype, \"writableEnded\"),\n      writableNeedDrain: ObjectGetOwnPropertyDescriptor(Writable.prototype, \"writableNeedDrain\"),\n      destroyed: {\n        get() {\n          if (this._readableState === void 0 || this._writableState === void 0) {\n            return false;\n          }\n          return this._readableState.destroyed && this._writableState.destroyed;\n        },\n        set(value) {\n          if (this._readableState && this._writableState) {\n            this._readableState.destroyed = value;\n            this._writableState.destroyed = value;\n          }\n        },\n      },\n    });\n    var webStreamsAdapters;\n    function lazyWebStreams() {\n      if (webStreamsAdapters === void 0) webStreamsAdapters = {};\n      return webStreamsAdapters;\n    }\n    Duplex.fromWeb = function (pair, options) {\n      return lazyWebStreams().newStreamDuplexFromReadableWritablePair(pair, options);\n    };\n    Duplex.toWeb = function (duplex) {\n      return lazyWebStreams().newReadableWritablePairFromDuplex(duplex);\n    };\n    var duplexify;\n    Duplex.from = function (body) {\n      if (!duplexify) {\n        duplexify = require_duplexify();\n      }\n      return duplexify(body, \"body\");\n    };\n  },\n});\n\n// node_modules/readable-stream/lib/internal/streams/transform.js\nvar require_transform = __commonJS({\n  \"node_modules/readable-stream/lib/internal/streams/transform.js\"(exports, module) {\n    \"use strict\";\n    var { ObjectSetPrototypeOf, Symbol: Symbol2 } = require_primordials();\n    var { ERR_METHOD_NOT_IMPLEMENTED } = require_errors().codes;\n    var Duplex = require_duplex();\n    function Transform(options) {\n      if (!(this instanceof Transform)) return new Transform(options);\n      Duplex.call(this, options);\n\n      this._readableState.sync = false;\n      this[kCallback] = null;\n\n      if (options) {\n        if (typeof options.transform === \"function\") this._transform = options.transform;\n        if (typeof options.flush === \"function\") this._flush = options.flush;\n      }\n\n      this.on(\"prefinish\", prefinish.bind(this));\n    }\n    ObjectSetPrototypeOf(Transform.prototype, Duplex.prototype);\n    ObjectSetPrototypeOf(Transform, Duplex);\n\n    module.exports = Transform;\n    var kCallback = Symbol2(\"kCallback\");\n    function final(cb) {\n      if (typeof this._flush === \"function\" && !this.destroyed) {\n        this._flush((er, data) => {\n          if (er) {\n            if (cb) {\n              cb(er);\n            } else {\n              this.destroy(er);\n            }\n            return;\n          }\n          if (data != null) {\n            this.push(data);\n          }\n          this.push(null);\n          if (cb) {\n            cb();\n          }\n        });\n      } else {\n        this.push(null);\n        if (cb) {\n          cb();\n        }\n      }\n    }\n    function prefinish() {\n      if (this._final !== final) {\n        final.call(this);\n      }\n    }\n    Transform.prototype._final = final;\n    Transform.prototype._transform = function (chunk, encoding, callback) {\n      throw new ERR_METHOD_NOT_IMPLEMENTED(\"_transform()\");\n    };\n    Transform.prototype._write = function (chunk, encoding, callback) {\n      const rState = this._readableState;\n      const wState = this._writableState;\n      const length = rState.length;\n      this._transform(chunk, encoding, (err, val) => {\n        if (err) {\n          callback(err);\n          return;\n        }\n        if (val != null) {\n          this.push(val);\n        }\n        if (\n          wState.ended ||\n          length === rState.length ||\n          rState.length < rState.highWaterMark ||\n          rState.highWaterMark === 0 ||\n          rState.length === 0\n        ) {\n          callback();\n        } else {\n          this[kCallback] = callback;\n        }\n      });\n    };\n    Transform.prototype._read = function () {\n      if (this[kCallback]) {\n        const callback = this[kCallback];\n        this[kCallback] = null;\n        callback();\n      }\n    };\n  },\n});\n\n// node_modules/readable-stream/lib/internal/streams/passthrough.js\nvar require_passthrough = __commonJS({\n  \"node_modules/readable-stream/lib/internal/streams/passthrough.js\"(exports, module) {\n    \"use strict\";\n    var { ObjectSetPrototypeOf } = require_primordials();\n    var Transform = require_transform();\n\n    function PassThrough(options) {\n      if (!(this instanceof PassThrough)) return new PassThrough(options);\n      Transform.call(this, options);\n    }\n\n    ObjectSetPrototypeOf(PassThrough.prototype, Transform.prototype);\n    ObjectSetPrototypeOf(PassThrough, Transform);\n\n    PassThrough.prototype._transform = function (chunk, encoding, cb) {\n      cb(null, chunk);\n    };\n\n    module.exports = PassThrough;\n  },\n});\n\n// node_modules/readable-stream/lib/internal/streams/pipeline.js\nvar require_pipeline = __commonJS({\n  \"node_modules/readable-stream/lib/internal/streams/pipeline.js\"(exports, module) {\n    \"use strict\";\n    var { ArrayIsArray, Promise: Promise2, SymbolAsyncIterator } = require_primordials();\n    var eos = require_end_of_stream();\n    var { once } = require_util();\n    var destroyImpl = require_destroy();\n    var Duplex = require_duplex();\n    var {\n      aggregateTwoErrors,\n      codes: { ERR_INVALID_ARG_TYPE, ERR_INVALID_RETURN_VALUE, ERR_MISSING_ARGS, ERR_STREAM_DESTROYED },\n      AbortError,\n    } = require_errors();\n    var { validateFunction, validateAbortSignal } = require_validators();\n    var { isIterable, isReadable, isReadableNodeStream, isNodeStream } = require_utils();\n    var AbortController = globalThis.AbortController || __require(\"abort-controller\").AbortController;\n    var PassThrough;\n    var Readable;\n    function destroyer(stream, reading, writing) {\n      let finished = false;\n      stream.on(\"close\", () => {\n        finished = true;\n      });\n      const cleanup = eos(\n        stream,\n        {\n          readable: reading,\n          writable: writing,\n        },\n        err => {\n          finished = !err;\n        },\n      );\n      return {\n        destroy: err => {\n          if (finished) return;\n          finished = true;\n          destroyImpl.destroyer(stream, err || new ERR_STREAM_DESTROYED(\"pipe\"));\n        },\n        cleanup,\n      };\n    }\n    function popCallback(streams) {\n      validateFunction(streams[streams.length - 1], \"streams[stream.length - 1]\");\n      return streams.pop();\n    }\n    function makeAsyncIterable(val) {\n      if (isIterable(val)) {\n        return val;\n      } else if (isReadableNodeStream(val)) {\n        return fromReadable(val);\n      }\n      throw new ERR_INVALID_ARG_TYPE(\"val\", [\"Readable\", \"Iterable\", \"AsyncIterable\"], val);\n    }\n    async function* fromReadable(val) {\n      if (!Readable) {\n        Readable = require_readable();\n      }\n      yield* Readable.prototype[SymbolAsyncIterator].call(val);\n    }\n    async function pump(iterable, writable, finish, { end }) {\n      let error;\n      let onresolve = null;\n      const resume = err => {\n        if (err) {\n          error = err;\n        }\n        if (onresolve) {\n          const callback = onresolve;\n          onresolve = null;\n          callback();\n        }\n      };\n      const wait = () =>\n        new Promise2((resolve, reject) => {\n          if (error) {\n            reject(error);\n          } else {\n            onresolve = () => {\n              if (error) {\n                reject(error);\n              } else {\n                resolve();\n              }\n            };\n          }\n        });\n      writable.on(\"drain\", resume);\n      const cleanup = eos(\n        writable,\n        {\n          readable: false,\n        },\n        resume,\n      );\n      try {\n        if (writable.writableNeedDrain) {\n          await wait();\n        }\n        for await (const chunk of iterable) {\n          if (!writable.write(chunk)) {\n            await wait();\n          }\n        }\n        if (end) {\n          writable.end();\n        }\n        await wait();\n        finish();\n      } catch (err) {\n        finish(error !== err ? aggregateTwoErrors(error, err) : err);\n      } finally {\n        cleanup();\n        writable.off(\"drain\", resume);\n      }\n    }\n    function pipeline(...streams) {\n      return pipelineImpl(streams, once(popCallback(streams)));\n    }\n    function pipelineImpl(streams, callback, opts) {\n      if (streams.length === 1 && ArrayIsArray(streams[0])) {\n        streams = streams[0];\n      }\n      if (streams.length < 2) {\n        throw new ERR_MISSING_ARGS(\"streams\");\n      }\n      const ac = new AbortController();\n      const signal = ac.signal;\n      const outerSignal = opts === null || opts === void 0 ? void 0 : opts.signal;\n      const lastStreamCleanup = [];\n      validateAbortSignal(outerSignal, \"options.signal\");\n      function abort() {\n        finishImpl(new AbortError());\n      }\n      outerSignal === null || outerSignal === void 0 ? void 0 : outerSignal.addEventListener(\"abort\", abort);\n      let error;\n      let value;\n      const destroys = [];\n      let finishCount = 0;\n      function finish(err) {\n        finishImpl(err, --finishCount === 0);\n      }\n      function finishImpl(err, final) {\n        if (err && (!error || error.code === \"ERR_STREAM_PREMATURE_CLOSE\")) {\n          error = err;\n        }\n        if (!error && !final) {\n          return;\n        }\n        while (destroys.length) {\n          destroys.shift()(error);\n        }\n        outerSignal === null || outerSignal === void 0 ? void 0 : outerSignal.removeEventListener(\"abort\", abort);\n        ac.abort();\n        if (final) {\n          if (!error) {\n            lastStreamCleanup.forEach(fn => fn());\n          }\n          runOnNextTick(callback, error, value);\n        }\n      }\n      let ret;\n      for (let i = 0; i < streams.length; i++) {\n        const stream = streams[i];\n        const reading = i < streams.length - 1;\n        const writing = i > 0;\n        const end = reading || (opts === null || opts === void 0 ? void 0 : opts.end) !== false;\n        const isLastStream = i === streams.length - 1;\n        if (isNodeStream(stream)) {\n          let onError = function (err) {\n            if (err && err.name !== \"AbortError\" && err.code !== \"ERR_STREAM_PREMATURE_CLOSE\") {\n              finish(err);\n            }\n          };\n          if (end) {\n            const { destroy, cleanup } = destroyer(stream, reading, writing);\n            destroys.push(destroy);\n            if (isReadable(stream) && isLastStream) {\n              lastStreamCleanup.push(cleanup);\n            }\n          }\n          stream.on(\"error\", onError);\n          if (isReadable(stream) && isLastStream) {\n            lastStreamCleanup.push(() => {\n              stream.removeListener(\"error\", onError);\n            });\n          }\n        }\n        if (i === 0) {\n          if (typeof stream === \"function\") {\n            ret = stream({\n              signal,\n            });\n            if (!isIterable(ret)) {\n              throw new ERR_INVALID_RETURN_VALUE(\"Iterable, AsyncIterable or Stream\", \"source\", ret);\n            }\n          } else if (isIterable(stream) || isReadableNodeStream(stream)) {\n            ret = stream;\n          } else {\n            ret = Duplex.from(stream);\n          }\n        } else if (typeof stream === \"function\") {\n          ret = makeAsyncIterable(ret);\n          ret = stream(ret, {\n            signal,\n          });\n          if (reading) {\n            if (!isIterable(ret, true)) {\n              throw new ERR_INVALID_RETURN_VALUE(\"AsyncIterable\", `transform[${i - 1}]`, ret);\n            }\n          } else {\n            var _ret;\n            if (!PassThrough) {\n              PassThrough = require_passthrough();\n            }\n            const pt = new PassThrough({\n              objectMode: true,\n            });\n            const then = (_ret = ret) === null || _ret === void 0 ? void 0 : _ret.then;\n            if (typeof then === \"function\") {\n              finishCount++;\n              then.call(\n                ret,\n                val => {\n                  value = val;\n                  if (val != null) {\n                    pt.write(val);\n                  }\n                  if (end) {\n                    pt.end();\n                  }\n                  runOnNextTick(finish);\n                },\n                err => {\n                  pt.destroy(err);\n                  runOnNextTick(finish, err);\n                },\n              );\n            } else if (isIterable(ret, true)) {\n              finishCount++;\n              pump(ret, pt, finish, {\n                end,\n              });\n            } else {\n              throw new ERR_INVALID_RETURN_VALUE(\"AsyncIterable or Promise\", \"destination\", ret);\n            }\n            ret = pt;\n            const { destroy, cleanup } = destroyer(ret, false, true);\n            destroys.push(destroy);\n            if (isLastStream) {\n              lastStreamCleanup.push(cleanup);\n            }\n          }\n        } else if (isNodeStream(stream)) {\n          if (isReadableNodeStream(ret)) {\n            finishCount += 2;\n            const cleanup = pipe(ret, stream, finish, {\n              end,\n            });\n            if (isReadable(stream) && isLastStream) {\n              lastStreamCleanup.push(cleanup);\n            }\n          } else if (isIterable(ret)) {\n            finishCount++;\n            pump(ret, stream, finish, {\n              end,\n            });\n          } else {\n            throw new ERR_INVALID_ARG_TYPE(\"val\", [\"Readable\", \"Iterable\", \"AsyncIterable\"], ret);\n          }\n          ret = stream;\n        } else {\n          ret = Duplex.from(stream);\n        }\n      }\n      if (\n        (signal !== null && signal !== void 0 && signal.aborted) ||\n        (outerSignal !== null && outerSignal !== void 0 && outerSignal.aborted)\n      ) {\n        runOnNextTick(abort);\n      }\n      return ret;\n    }\n    function pipe(src, dst, finish, { end }) {\n      src.pipe(dst, {\n        end,\n      });\n      if (end) {\n        src.once(\"end\", () => dst.end());\n      } else {\n        finish();\n      }\n      eos(\n        src,\n        {\n          readable: true,\n          writable: false,\n        },\n        err => {\n          const rState = src._readableState;\n          if (\n            err &&\n            err.code === \"ERR_STREAM_PREMATURE_CLOSE\" &&\n            rState &&\n            rState.ended &&\n            !rState.errored &&\n            !rState.errorEmitted\n          ) {\n            src.once(\"end\", finish).once(\"error\", finish);\n          } else {\n            finish(err);\n          }\n        },\n      );\n      return eos(\n        dst,\n        {\n          readable: false,\n          writable: true,\n        },\n        finish,\n      );\n    }\n    module.exports = {\n      pipelineImpl,\n      pipeline,\n    };\n  },\n});\n\n// node_modules/readable-stream/lib/internal/streams/compose.js\nvar require_compose = __commonJS({\n  \"node_modules/readable-stream/lib/internal/streams/compose.js\"(exports, module) {\n    \"use strict\";\n    var { pipeline } = require_pipeline();\n    var Duplex = require_duplex();\n    var { destroyer } = require_destroy();\n    var { isNodeStream, isReadable, isWritable } = require_utils();\n    var {\n      AbortError,\n      codes: { ERR_INVALID_ARG_VALUE, ERR_MISSING_ARGS },\n    } = require_errors();\n    module.exports = function compose(...streams) {\n      if (streams.length === 0) {\n        throw new ERR_MISSING_ARGS(\"streams\");\n      }\n      if (streams.length === 1) {\n        return Duplex.from(streams[0]);\n      }\n      const orgStreams = [...streams];\n      if (typeof streams[0] === \"function\") {\n        streams[0] = Duplex.from(streams[0]);\n      }\n      if (typeof streams[streams.length - 1] === \"function\") {\n        const idx = streams.length - 1;\n        streams[idx] = Duplex.from(streams[idx]);\n      }\n      for (let n = 0; n < streams.length; ++n) {\n        if (!isNodeStream(streams[n])) {\n          continue;\n        }\n        if (n < streams.length - 1 && !isReadable(streams[n])) {\n          throw new ERR_INVALID_ARG_VALUE(`streams[${n}]`, orgStreams[n], \"must be readable\");\n        }\n        if (n > 0 && !isWritable(streams[n])) {\n          throw new ERR_INVALID_ARG_VALUE(`streams[${n}]`, orgStreams[n], \"must be writable\");\n        }\n      }\n      let ondrain;\n      let onfinish;\n      let onreadable;\n      let onclose;\n      let d;\n      function onfinished(err) {\n        const cb = onclose;\n        onclose = null;\n        if (cb) {\n          cb(err);\n        } else if (err) {\n          d.destroy(err);\n        } else if (!readable && !writable) {\n          d.destroy();\n        }\n      }\n      const head = streams[0];\n      const tail = pipeline(streams, onfinished);\n      const writable = !!isWritable(head);\n      const readable = !!isReadable(tail);\n      d = new Duplex({\n        writableObjectMode: !!(head !== null && head !== void 0 && head.writableObjectMode),\n        readableObjectMode: !!(tail !== null && tail !== void 0 && tail.writableObjectMode),\n        writable,\n        readable,\n      });\n      if (writable) {\n        d._write = function (chunk, encoding, callback) {\n          if (head.write(chunk, encoding)) {\n            callback();\n          } else {\n            ondrain = callback;\n          }\n        };\n        d._final = function (callback) {\n          head.end();\n          onfinish = callback;\n        };\n        head.on(\"drain\", function () {\n          if (ondrain) {\n            const cb = ondrain;\n            ondrain = null;\n            cb();\n          }\n        });\n        tail.on(\"finish\", function () {\n          if (onfinish) {\n            const cb = onfinish;\n            onfinish = null;\n            cb();\n          }\n        });\n      }\n      if (readable) {\n        tail.on(\"readable\", function () {\n          if (onreadable) {\n            const cb = onreadable;\n            onreadable = null;\n            cb();\n          }\n        });\n        tail.on(\"end\", function () {\n          d.push(null);\n        });\n        d._read = function () {\n          while (true) {\n            const buf = tail.read();\n            if (buf === null) {\n              onreadable = d._read;\n              return;\n            }\n            if (!d.push(buf)) {\n              return;\n            }\n          }\n        };\n      }\n      d._destroy = function (err, callback) {\n        if (!err && onclose !== null) {\n          err = new AbortError();\n        }\n        onreadable = null;\n        ondrain = null;\n        onfinish = null;\n        if (onclose === null) {\n          callback(err);\n        } else {\n          onclose = callback;\n          destroyer(tail, err);\n        }\n      };\n      return d;\n    };\n  },\n});\n\n// node_modules/readable-stream/lib/stream/promises.js\nvar require_promises = __commonJS({\n  \"node_modules/readable-stream/lib/stream/promises.js\"(exports, module) {\n    \"use strict\";\n    var { ArrayPrototypePop, Promise: Promise2 } = require_primordials();\n    var { isIterable, isNodeStream } = require_utils();\n    var { pipelineImpl: pl } = require_pipeline();\n    var { finished } = require_end_of_stream();\n    function pipeline(...streams) {\n      return new Promise2((resolve, reject) => {\n        let signal;\n        let end;\n        const lastArg = streams[streams.length - 1];\n        if (lastArg && typeof lastArg === \"object\" && !isNodeStream(lastArg) && !isIterable(lastArg)) {\n          const options = ArrayPrototypePop(streams);\n          signal = options.signal;\n          end = options.end;\n        }\n        pl(\n          streams,\n          (err, value) => {\n            if (err) {\n              reject(err);\n            } else {\n              resolve(value);\n            }\n          },\n          {\n            signal,\n            end,\n          },\n        );\n      });\n    }\n    module.exports = {\n      finished,\n      pipeline,\n    };\n  },\n});\n// node_modules/readable-stream/lib/stream.js\nvar require_stream = __commonJS({\n  \"node_modules/readable-stream/lib/stream.js\"(exports, module) {\n    \"use strict\";\n    var { ObjectDefineProperty, ObjectKeys, ReflectApply } = require_primordials();\n    var {\n      promisify: { custom: customPromisify },\n    } = require_util();\n\n    var { streamReturningOperators, promiseReturningOperators } = require_operators();\n    var {\n      codes: { ERR_ILLEGAL_CONSTRUCTOR },\n    } = require_errors();\n    var compose = require_compose();\n    var { pipeline } = require_pipeline();\n    var { destroyer } = require_destroy();\n    var eos = require_end_of_stream();\n    var promises = require_promises();\n    var utils = require_utils();\n    var Stream = (module.exports = require_legacy().Stream);\n    Stream.isDisturbed = utils.isDisturbed;\n    Stream.isErrored = utils.isErrored;\n    Stream.isWritable = utils.isWritable;\n    Stream.isReadable = utils.isReadable;\n    Stream.Readable = require_readable();\n    for (const key of ObjectKeys(streamReturningOperators)) {\n      let fn = function (...args) {\n        if (new.target) {\n          throw ERR_ILLEGAL_CONSTRUCTOR();\n        }\n        return Stream.Readable.from(ReflectApply(op, this, args));\n      };\n      const op = streamReturningOperators[key];\n      ObjectDefineProperty(fn, \"name\", {\n        value: op.name,\n      });\n      ObjectDefineProperty(fn, \"length\", {\n        value: op.length,\n      });\n      ObjectDefineProperty(Stream.Readable.prototype, key, {\n        value: fn,\n        enumerable: false,\n        configurable: true,\n        writable: true,\n      });\n    }\n    for (const key of ObjectKeys(promiseReturningOperators)) {\n      let fn = function (...args) {\n        if (new.target) {\n          throw ERR_ILLEGAL_CONSTRUCTOR();\n        }\n        return ReflectApply(op, this, args);\n      };\n      const op = promiseReturningOperators[key];\n      ObjectDefineProperty(fn, \"name\", {\n        value: op.name,\n      });\n      ObjectDefineProperty(fn, \"length\", {\n        value: op.length,\n      });\n      ObjectDefineProperty(Stream.Readable.prototype, key, {\n        value: fn,\n        enumerable: false,\n        configurable: true,\n        writable: true,\n      });\n    }\n    Stream.Writable = require_writable();\n    Stream.Duplex = require_duplex();\n    Stream.Transform = require_transform();\n    Stream.PassThrough = require_passthrough();\n    Stream.pipeline = pipeline;\n    var { addAbortSignal } = require_add_abort_signal();\n    Stream.addAbortSignal = addAbortSignal;\n    Stream.finished = eos;\n    Stream.destroy = destroyer;\n    Stream.compose = compose;\n    ObjectDefineProperty(Stream, \"promises\", {\n      configurable: true,\n      enumerable: true,\n      get() {\n        return promises;\n      },\n    });\n    ObjectDefineProperty(pipeline, customPromisify, {\n      enumerable: true,\n      get() {\n        return promises.pipeline;\n      },\n    });\n    ObjectDefineProperty(eos, customPromisify, {\n      enumerable: true,\n      get() {\n        return promises.finished;\n      },\n    });\n    Stream.Stream = Stream;\n    Stream._isUint8Array = function isUint8Array(value) {\n      return value instanceof Uint8Array;\n    };\n    Stream._uint8ArrayToBuffer = function _uint8ArrayToBuffer(chunk) {\n      return new Buffer(chunk.buffer, chunk.byteOffset, chunk.byteLength);\n    };\n  },\n});\n\n// node_modules/readable-stream/lib/ours/index.js\nvar require_ours = __commonJS({\n  \"node_modules/readable-stream/lib/ours/index.js\"(exports, module) {\n    \"use strict\";\n    const CustomStream = require_stream();\n    const promises = require_promises();\n    const originalDestroy = CustomStream.Readable.destroy;\n    module.exports = CustomStream;\n    module.exports._uint8ArrayToBuffer = CustomStream._uint8ArrayToBuffer;\n    module.exports._isUint8Array = CustomStream._isUint8Array;\n    module.exports.isDisturbed = CustomStream.isDisturbed;\n    module.exports.isErrored = CustomStream.isErrored;\n    module.exports.isWritable = CustomStream.isWritable;\n    module.exports.isReadable = CustomStream.isReadable;\n    module.exports.Readable = CustomStream.Readable;\n    module.exports.Writable = CustomStream.Writable;\n    module.exports.Duplex = CustomStream.Duplex;\n    module.exports.Transform = CustomStream.Transform;\n    module.exports.PassThrough = CustomStream.PassThrough;\n    module.exports.addAbortSignal = CustomStream.addAbortSignal;\n    module.exports.finished = CustomStream.finished;\n    module.exports.destroy = CustomStream.destroy;\n    module.exports.destroy = originalDestroy;\n    module.exports.pipeline = CustomStream.pipeline;\n    module.exports.compose = CustomStream.compose;\n\n    module.exports._getNativeReadableStreamPrototype = getNativeReadableStreamPrototype;\n    module.exports.NativeWritable = NativeWritable;\n\n    Object.defineProperty(CustomStream, \"promises\", {\n      configurable: true,\n      enumerable: true,\n      get() {\n        return promises;\n      },\n    });\n    module.exports.Stream = CustomStream.Stream;\n    module.exports.default = module.exports;\n  },\n});\n\n/**\n * Bun native stream wrapper\n *\n * This glue code lets us avoid using ReadableStreams to wrap Bun internal streams\n *\n */\nfunction createNativeStreamReadable(nativeType, Readable) {\n  var [pull, start, cancel, setClose, deinit, updateRef, drainFn] = globalThis[Symbol.for(\"Bun.lazy\")](nativeType);\n\n  var closer = [false];\n  var handleNumberResult = function (nativeReadable, result, view, isClosed) {\n    if (result > 0) {\n      const slice = view.subarray(0, result);\n      const remainder = view.subarray(result);\n      if (slice.byteLength > 0) {\n        nativeReadable.push(slice);\n      }\n\n      if (isClosed) {\n        nativeReadable.push(null);\n      }\n\n      return remainder.byteLength > 0 ? remainder : undefined;\n    }\n\n    if (isClosed) {\n      nativeReadable.push(null);\n    }\n\n    return view;\n  };\n\n  var handleArrayBufferViewResult = function (nativeReadable, result, view, isClosed) {\n    if (result.byteLength > 0) {\n      nativeReadable.push(result);\n    }\n\n    if (isClosed) {\n      nativeReadable.push(null);\n    }\n\n    return view;\n  };\n\n  var DYNAMICALLY_ADJUST_CHUNK_SIZE = process.env.BUN_DISABLE_DYNAMIC_CHUNK_SIZE !== \"1\";\n\n  const finalizer = new FinalizationRegistry(ptr => ptr && deinit(ptr));\n  const MIN_BUFFER_SIZE = 512;\n  var NativeReadable = class NativeReadable extends Readable {\n    #ptr;\n    #refCount = 1;\n    #constructed = false;\n    #remainingChunk = undefined;\n    #highWaterMark;\n    #pendingRead = false;\n    #hasResized = !DYNAMICALLY_ADJUST_CHUNK_SIZE;\n    #unregisterToken;\n    constructor(ptr, options = {}) {\n      super(options);\n      if (typeof options.highWaterMark === \"number\") {\n        this.#highWaterMark = options.highWaterMark;\n      } else {\n        this.#highWaterMark = 256 * 1024;\n      }\n      this.#ptr = ptr;\n      this.#constructed = false;\n      this.#remainingChunk = undefined;\n      this.#pendingRead = false;\n      this.#unregisterToken = {};\n      finalizer.register(this, this.#ptr, this.#unregisterToken);\n    }\n\n    // maxToRead is by default the highWaterMark passed from the Readable.read call to this fn\n    // However, in the case of an fs.ReadStream, we can pass the number of bytes we want to read\n    // which may be significantly less than the actual highWaterMark\n    _read(maxToRead) {\n      __DEBUG__ && debug(\"NativeReadable._read\", this.__id);\n      if (this.#pendingRead) {\n        __DEBUG__ && debug(\"pendingRead is true\", this.__id);\n        return;\n      }\n\n      var ptr = this.#ptr;\n      __DEBUG__ && debug(\"ptr @ NativeReadable._read\", ptr, this.__id);\n      if (ptr === 0) {\n        this.push(null);\n        return;\n      }\n\n      if (!this.#constructed) {\n        __DEBUG__ && debug(\"NativeReadable not constructed yet\", this.__id);\n        this.#internalConstruct(ptr);\n      }\n\n      return this.#internalRead(this.#getRemainingChunk(maxToRead), ptr);\n      // const internalReadRes = this.#internalRead(\n      //   this.#getRemainingChunk(),\n      //   ptr,\n      // );\n      // // REVERT ME\n      // const wrap = new Promise((resolve) => {\n      //   if (!this.internalReadRes?.then) {\n      //     debug(\"internalReadRes not promise\");\n      //     resolve(internalReadRes);\n      //     return;\n      //   }\n      //   internalReadRes.then((result) => {\n      //     debug(\"internalReadRes done\");\n      //     resolve(result);\n      //   });\n      // });\n      // return wrap;\n    }\n\n    #internalConstruct(ptr) {\n      this.#constructed = true;\n      const result = start(ptr, this.#highWaterMark);\n      __DEBUG__ && debug(\"NativeReadable internal `start` result\", result, this.__id);\n\n      if (typeof result === \"number\" && result > 1) {\n        this.#hasResized = true;\n        __DEBUG__ && debug(\"NativeReadable resized\", this.__id);\n\n        this.#highWaterMark = Math.min(this.#highWaterMark, result);\n      }\n\n      if (drainFn) {\n        const drainResult = drainFn(ptr);\n        __DEBUG__ && debug(\"NativeReadable drain result\", drainResult, this.__id);\n        if ((drainResult?.byteLength ?? 0) > 0) {\n          this.push(drainResult);\n        }\n      }\n    }\n\n    // maxToRead can be the highWaterMark (by default) or the remaining amount of the stream to read\n    // This is so the the consumer of the stream can terminate the stream early if they know\n    // how many bytes they want to read (ie. when reading only part of a file)\n    #getRemainingChunk(maxToRead = this.#highWaterMark) {\n      var chunk = this.#remainingChunk;\n      __DEBUG__ && debug(\"chunk @ #getRemainingChunk\", chunk, this.__id);\n      if (chunk?.byteLength ?? 0 < MIN_BUFFER_SIZE) {\n        var size = maxToRead > MIN_BUFFER_SIZE ? maxToRead : MIN_BUFFER_SIZE;\n        this.#remainingChunk = chunk = new Buffer(size);\n      }\n      return chunk;\n    }\n\n    push(result, encoding) {\n      __DEBUG__ && debug(\"NativeReadable push -- result, encoding\", result, encoding, this.__id);\n      return super.push(...arguments);\n    }\n\n    #handleResult(result, view, isClosed) {\n      __DEBUG__ && debug(\"result, isClosed @ #handleResult\", result, isClosed, this.__id);\n\n      if (typeof result === \"number\") {\n        if (result >= this.#highWaterMark && !this.#hasResized && !isClosed) {\n          this.#highWaterMark *= 2;\n          this.#hasResized = true;\n        }\n\n        return handleNumberResult(this, result, view, isClosed);\n      } else if (typeof result === \"boolean\") {\n        this.push(null);\n        return view?.byteLength ?? 0 > 0 ? view : undefined;\n      } else if (ArrayBuffer.isView(result)) {\n        if (result.byteLength >= this.#highWaterMark && !this.#hasResized && !isClosed) {\n          this.#highWaterMark *= 2;\n          this.#hasResized = true;\n          __DEBUG__ && debug(\"Resized\", this.__id);\n        }\n\n        return handleArrayBufferViewResult(this, result, view, isClosed);\n      } else {\n        __DEBUG__ && debug(\"Unknown result type\", result, this.__id);\n        throw new Error(\"Invalid result from pull\");\n      }\n    }\n\n    #internalRead(view, ptr) {\n      __DEBUG__ && debug(\"#internalRead()\", this.__id);\n      closer[0] = false;\n      var result = pull(ptr, view, closer);\n      if (isPromise(result)) {\n        this.#pendingRead = true;\n        return result.then(\n          result => {\n            this.#pendingRead = false;\n            __DEBUG__ && debug(\"pending no longerrrrrrrr (result returned from pull)\", this.__id);\n            this.#remainingChunk = this.#handleResult(result, view, closer[0]);\n          },\n          reason => {\n            __DEBUG__ && debug(\"error from pull\", reason, this.__id);\n            errorOrDestroy(this, reason);\n          },\n        );\n      } else {\n        this.#remainingChunk = this.#handleResult(result, view, closer[0]);\n      }\n    }\n\n    _destroy(error, callback) {\n      var ptr = this.#ptr;\n      if (ptr === 0) {\n        callback(error);\n        return;\n      }\n\n      finalizer.unregister(this.#unregisterToken);\n      this.#ptr = 0;\n      if (updateRef) {\n        updateRef(ptr, false);\n      }\n      __DEBUG__ && debug(\"NativeReadable destroyed\", this.__id);\n      cancel(ptr, error);\n      callback(error);\n    }\n\n    ref() {\n      var ptr = this.#ptr;\n      if (ptr === 0) return;\n      if (this.#refCount++ === 0) {\n        updateRef(ptr, true);\n      }\n    }\n\n    unref() {\n      var ptr = this.#ptr;\n      if (ptr === 0) return;\n      if (this.#refCount-- === 1) {\n        updateRef(ptr, false);\n      }\n    }\n  };\n\n  if (!updateRef) {\n    NativeReadable.prototype.ref = undefined;\n    NativeReadable.prototype.unref = undefined;\n  }\n\n  return NativeReadable;\n}\n\nvar nativeReadableStreamPrototypes = {\n  0: undefined,\n  1: undefined,\n  2: undefined,\n  3: undefined,\n  4: undefined,\n  5: undefined,\n};\nfunction getNativeReadableStreamPrototype(nativeType, Readable) {\n  return (nativeReadableStreamPrototypes[nativeType] ||= createNativeStreamReadable(nativeType, Readable));\n}\n\nfunction getNativeReadableStream(Readable, stream, options) {\n  if (!(stream && typeof stream === \"object\" && stream instanceof ReadableStream)) {\n    return undefined;\n  }\n\n  const native = direct(stream);\n  if (!native) {\n    debug(\"no native readable stream\");\n    return undefined;\n  }\n  const { stream: ptr, data: type } = native;\n\n  const NativeReadable = getNativeReadableStreamPrototype(type, Readable);\n\n  return new NativeReadable(ptr, options);\n}\n/** --- Bun native stream wrapper ---  */\n\nvar Writable = require_writable();\nvar NativeWritable = class NativeWritable extends Writable {\n  #pathOrFdOrSink;\n  #fileSink;\n  #native = true;\n\n  _construct;\n  _destroy;\n  _final;\n\n  constructor(pathOrFdOrSink, options = {}) {\n    super(options);\n\n    this._construct = this.#internalConstruct;\n    this._destroy = this.#internalDestroy;\n    this._final = this.#internalFinal;\n\n    this.#pathOrFdOrSink = pathOrFdOrSink;\n  }\n\n  // These are confusingly two different fns for construct which initially were the same thing because\n  // `_construct` is part of the lifecycle of Writable and is not called lazily,\n  // so we need to separate our _construct for Writable state and actual construction of the write stream\n  #internalConstruct(cb) {\n    this._writableState.constructed = true;\n    this.constructed = true;\n    cb();\n  }\n\n  #lazyConstruct() {\n    // TODO: Turn this check into check for instanceof FileSink\n    if (typeof this.#pathOrFdOrSink === \"object\") {\n      if (typeof this.#pathOrFdOrSink.write === \"function\") {\n        this.#fileSink = this.#pathOrFdOrSink;\n      } else {\n        throw new Error(\"Invalid FileSink\");\n      }\n    } else {\n      this.#fileSink = Bun.file(this.#pathOrFdOrSink).writer();\n    }\n  }\n\n  write(chunk, encoding, cb, native = this.#native) {\n    if (!native) {\n      this.#native = false;\n      return super.write(chunk, encoding, cb);\n    }\n\n    if (!this.#fileSink) {\n      this.#lazyConstruct();\n    }\n    var fileSink = this.#fileSink;\n    var result = fileSink.write(chunk);\n\n    if (isPromise(result)) {\n      // var writePromises = this.#writePromises;\n      // var i = writePromises.length;\n      // writePromises[i] = result;\n      result.then(() => {\n        this.emit(\"drain\");\n        fileSink.flush(true);\n        // // We can't naively use i here because we don't know when writes will resolve necessarily\n        // writePromises.splice(writePromises.indexOf(result), 1);\n      });\n      return false;\n    }\n    fileSink.flush(true);\n    // TODO: Should we just have a calculation based on encoding and length of chunk?\n    if (cb) cb(null, chunk.byteLength);\n    return true;\n  }\n\n  end(chunk, encoding, cb, native = this.#native) {\n    return super.end(chunk, encoding, cb, native);\n  }\n\n  #internalDestroy(error, cb) {\n    this._writableState.destroyed = true;\n    if (cb) cb(error);\n  }\n\n  #internalFinal(cb) {\n    if (this.#fileSink) {\n      this.#fileSink.end();\n    }\n    if (cb) cb();\n  }\n\n  ref() {\n    if (!this.#fileSink) {\n      this.#lazyConstruct();\n    }\n    this.#fileSink.ref();\n  }\n\n  unref() {\n    if (!this.#fileSink) return;\n    this.#fileSink.unref();\n  }\n};\n\nconst stream_exports = require_ours();\nstream_exports[Symbol.for(\"CommonJS\")] = 0;\nstream_exports[Symbol.for(\"::bunternal::\")] = { _ReadableFromWeb };\nexport default stream_exports;\nexport var _uint8ArrayToBuffer = stream_exports._uint8ArrayToBuffer;\nexport var _isUint8Array = stream_exports._isUint8Array;\nexport var isDisturbed = stream_exports.isDisturbed;\nexport var isErrored = stream_exports.isErrored;\nexport var isWritable = stream_exports.isWritable;\nexport var isReadable = stream_exports.isReadable;\nexport var Readable = stream_exports.Readable;\nexport var Writable = stream_exports.Writable;\nexport var Duplex = stream_exports.Duplex;\nexport var Transform = stream_exports.Transform;\nexport var PassThrough = stream_exports.PassThrough;\nexport var addAbortSignal = stream_exports.addAbortSignal;\nexport var finished = stream_exports.finished;\nexport var destroy = stream_exports.destroy;\nexport var pipeline = stream_exports.pipeline;\nexport var compose = stream_exports.compose;\nexport var Stream = stream_exports.Stream;\nexport var eos = (stream_exports[\"eos\"] = require_end_of_stream);\nexport var _getNativeReadableStreamPrototype = stream_exports._getNativeReadableStreamPrototype;\nexport var NativeWritable = stream_exports.NativeWritable;\nexport var promises = Stream.promise;\n",
  "// Hardcoded module \"node:stream\" / \"readable-stream\"\n// \"readable-stream\" npm package\n// just transpiled\nvar { isPromise, isCallable, direct, Object } = import.meta.primordials;\n\nglobalThis.__IDS_TO_TRACK = process.env.DEBUG_TRACK_EE?.length\n  ? process.env.DEBUG_TRACK_EE.split(\",\")\n  : process.env.DEBUG_STREAMS?.length\n  ? process.env.DEBUG_STREAMS.split(\",\")\n  : null;\n\n// Separating DEBUG, DEBUG_STREAMS and DEBUG_TRACK_EE env vars makes it easier to focus on the\n// events in this file rather than all debug output across all files\n\n// You can include comma-delimited IDs as the value to either DEBUG_STREAMS or DEBUG_TRACK_EE and it will track\n// The events and/or all of the outputs for the given stream IDs assigned at stream construction\n// By default, child_process gives\n\nconst __TRACK_EE__ = !!process.env.DEBUG_TRACK_EE;\nconst __DEBUG__ = !!(process.env.DEBUG || process.env.DEBUG_STREAMS || __TRACK_EE__);\n\nvar debug = __DEBUG__\n  ? globalThis.__IDS_TO_TRACK\n    ? // If we are tracking IDs for debug event emitters, we should prefix the debug output with the ID\n      (...args) => {\n        const lastItem = args[args.length - 1];\n        if (!globalThis.__IDS_TO_TRACK.includes(lastItem)) return;\n        console.log(`ID: ${lastItem}`, ...args.slice(0, -1));\n      }\n    : (...args) => console.log(...args.slice(0, -1))\n  : () => {};\n\nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __ObjectSetPrototypeOf = Object.setPrototypeOf;\nvar __require = x => import.meta.require(x);\n\nvar _EE = __require(\"bun:events_native\");\n\nfunction DebugEventEmitter(opts) {\n  if (!(this instanceof DebugEventEmitter)) return new DebugEventEmitter(opts);\n  _EE.call(this, opts);\n  const __id = opts.__id;\n  if (__id) {\n    __defProp(this, \"__id\", {\n      value: __id,\n      readable: true,\n      writable: false,\n      enumerable: false,\n    });\n  }\n}\n\n__ObjectSetPrototypeOf(DebugEventEmitter.prototype, _EE.prototype);\n__ObjectSetPrototypeOf(DebugEventEmitter, _EE);\n\nDebugEventEmitter.prototype.emit = function (event, ...args) {\n  var __id = this.__id;\n  if (__id) {\n    debug(\"emit\", event, ...args, __id);\n  } else {\n    debug(\"emit\", event, ...args);\n  }\n  return _EE.prototype.emit.call(this, event, ...args);\n};\nDebugEventEmitter.prototype.on = function (event, handler) {\n  var __id = this.__id;\n  if (__id) {\n    debug(\"on\", event, \"added\", __id);\n  } else {\n    debug(\"on\", event, \"added\");\n  }\n  return _EE.prototype.on.call(this, event, handler);\n};\nDebugEventEmitter.prototype.addListener = function (event, handler) {\n  return this.on(event, handler);\n};\n\nvar __commonJS = (cb, mod) =>\n  function __require2() {\n    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;\n  };\nvar __copyProps = (to, from, except, desc) => {\n  if ((from && typeof from === \"object\") || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, {\n          get: () => from[key],\n          set: val => (from[key] = val),\n          enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable,\n          configurable: true,\n        });\n  }\n  return to;\n};\n\nvar runOnNextTick = process.nextTick;\n\nfunction isReadableStream(value) {\n  return typeof value === \"object\" && value !== null && value instanceof ReadableStream;\n}\n\nfunction validateBoolean(value, name) {\n  if (typeof value !== \"boolean\") throw new ERR_INVALID_ARG_TYPE(name, \"boolean\", value);\n}\n\n/**\n * @callback validateObject\n * @param {*} value\n * @param {string} name\n * @param {{\n *   allowArray?: boolean,\n *   allowFunction?: boolean,\n *   nullable?: boolean\n * }} [options]\n */\n\n/** @type {validateObject} */\nconst validateObject = (value, name, options = null) => {\n  const allowArray = options?.allowArray ?? false;\n  const allowFunction = options?.allowFunction ?? false;\n  const nullable = options?.nullable ?? false;\n  if (\n    (!nullable && value === null) ||\n    (!allowArray && ArrayIsArray(value)) ||\n    (typeof value !== \"object\" && (!allowFunction || typeof value !== \"function\"))\n  ) {\n    throw new ERR_INVALID_ARG_TYPE(name, \"Object\", value);\n  }\n};\n\n/**\n * @callback validateString\n * @param {*} value\n * @param {string} name\n * @returns {asserts value is string}\n */\n\n/** @type {validateString} */\nfunction validateString(value, name) {\n  if (typeof value !== \"string\") throw new ERR_INVALID_ARG_TYPE(name, \"string\", value);\n}\n\nvar ArrayIsArray = Array.isArray;\n\n//------------------------------------------------------------------------------\n// Node error polyfills\n//------------------------------------------------------------------------------\n\nfunction ERR_INVALID_ARG_TYPE(name, type, value) {\n  return new Error(`The argument '${name}' is invalid. Received '${value}' for type '${type}'`);\n}\n\nfunction ERR_INVALID_ARG_VALUE(name, value, reason) {\n  return new Error(`The value '${value}' is invalid for argument '${name}'. Reason: ${reason}`);\n}\n\n// node_modules/readable-stream/lib/ours/primordials.js\nvar require_primordials = __commonJS({\n  \"node_modules/readable-stream/lib/ours/primordials.js\"(exports, module) {\n    \"use strict\";\n    module.exports = {\n      ArrayIsArray(self) {\n        return Array.isArray(self);\n      },\n      ArrayPrototypeIncludes(self, el) {\n        return self.includes(el);\n      },\n      ArrayPrototypeIndexOf(self, el) {\n        return self.indexOf(el);\n      },\n      ArrayPrototypeJoin(self, sep) {\n        return self.join(sep);\n      },\n      ArrayPrototypeMap(self, fn) {\n        return self.map(fn);\n      },\n      ArrayPrototypePop(self, el) {\n        return self.pop(el);\n      },\n      ArrayPrototypePush(self, el) {\n        return self.push(el);\n      },\n      ArrayPrototypeSlice(self, start, end) {\n        return self.slice(start, end);\n      },\n      Error,\n      FunctionPrototypeCall(fn, thisArgs, ...args) {\n        return fn.call(thisArgs, ...args);\n      },\n      FunctionPrototypeSymbolHasInstance(self, instance) {\n        return Function.prototype[Symbol.hasInstance].call(self, instance);\n      },\n      MathFloor: Math.floor,\n      Number,\n      NumberIsInteger: Number.isInteger,\n      NumberIsNaN: Number.isNaN,\n      NumberMAX_SAFE_INTEGER: Number.MAX_SAFE_INTEGER,\n      NumberMIN_SAFE_INTEGER: Number.MIN_SAFE_INTEGER,\n      NumberParseInt: Number.parseInt,\n      ObjectDefineProperties(self, props) {\n        return Object.defineProperties(self, props);\n      },\n      ObjectDefineProperty(self, name, prop) {\n        return Object.defineProperty(self, name, prop);\n      },\n      ObjectGetOwnPropertyDescriptor(self, name) {\n        return Object.getOwnPropertyDescriptor(self, name);\n      },\n      ObjectKeys(obj) {\n        return Object.keys(obj);\n      },\n      ObjectSetPrototypeOf(target, proto) {\n        return Object.setPrototypeOf(target, proto);\n      },\n      Promise,\n      PromisePrototypeCatch(self, fn) {\n        return self.catch(fn);\n      },\n      PromisePrototypeThen(self, thenFn, catchFn) {\n        return self.then(thenFn, catchFn);\n      },\n      PromiseReject(err) {\n        return Promise.reject(err);\n      },\n      ReflectApply: Reflect.apply,\n      RegExpPrototypeTest(self, value) {\n        return self.test(value);\n      },\n      SafeSet: Set,\n      String,\n      StringPrototypeSlice(self, start, end) {\n        return self.slice(start, end);\n      },\n      StringPrototypeToLowerCase(self) {\n        return self.toLowerCase();\n      },\n      StringPrototypeToUpperCase(self) {\n        return self.toUpperCase();\n      },\n      StringPrototypeTrim(self) {\n        return self.trim();\n      },\n      Symbol,\n      SymbolAsyncIterator: Symbol.asyncIterator,\n      SymbolHasInstance: Symbol.hasInstance,\n      SymbolIterator: Symbol.iterator,\n      TypedArrayPrototypeSet(self, buf, len) {\n        return self.set(buf, len);\n      },\n      Uint8Array,\n    };\n  },\n});\n// node_modules/readable-stream/lib/ours/util.js\nvar require_util = __commonJS({\n  \"node_modules/readable-stream/lib/ours/util.js\"(exports, module) {\n    \"use strict\";\n    var bufferModule = __require(\"buffer\");\n    var AsyncFunction = Object.getPrototypeOf(async function () {}).constructor;\n    var Blob = globalThis.Blob || bufferModule.Blob;\n    var isBlob =\n      typeof Blob !== \"undefined\"\n        ? function isBlob2(b) {\n            return b instanceof Blob;\n          }\n        : function isBlob2(b) {\n            return false;\n          };\n    var AggregateError = class extends Error {\n      constructor(errors) {\n        if (!Array.isArray(errors)) {\n          throw new TypeError(`Expected input to be an Array, got ${typeof errors}`);\n        }\n        let message = \"\";\n        for (let i = 0; i < errors.length; i++) {\n          message += `    ${errors[i].stack}\n`;\n        }\n        super(message);\n        this.name = \"AggregateError\";\n        this.errors = errors;\n      }\n    };\n    module.exports = {\n      AggregateError,\n      once(callback) {\n        let called = false;\n        return function (...args) {\n          if (called) {\n            return;\n          }\n          called = true;\n          callback.apply(this, args);\n        };\n      },\n      createDeferredPromise: function () {\n        let resolve;\n        let reject;\n        const promise = new Promise((res, rej) => {\n          resolve = res;\n          reject = rej;\n        });\n        return {\n          promise,\n          resolve,\n          reject,\n        };\n      },\n      promisify(fn) {\n        return new Promise((resolve, reject) => {\n          fn((err, ...args) => {\n            if (err) {\n              return reject(err);\n            }\n            return resolve(...args);\n          });\n        });\n      },\n      debuglog() {\n        return function () {};\n      },\n      format(format, ...args) {\n        return format.replace(/%([sdifj])/g, function (...[_unused, type]) {\n          const replacement = args.shift();\n          if (type === \"f\") {\n            return replacement.toFixed(6);\n          } else if (type === \"j\") {\n            return JSON.stringify(replacement);\n          } else if (type === \"s\" && typeof replacement === \"object\") {\n            const ctor = replacement.constructor !== Object ? replacement.constructor.name : \"\";\n            return `${ctor} {}`.trim();\n          } else {\n            return replacement.toString();\n          }\n        });\n      },\n      inspect(value) {\n        switch (typeof value) {\n          case \"string\":\n            if (value.includes(\"'\")) {\n              if (!value.includes('\"')) {\n                return `\"${value}\"`;\n              } else if (!value.includes(\"`\") && !value.includes(\"${\")) {\n                return `\\`${value}\\``;\n              }\n            }\n            return `'${value}'`;\n          case \"number\":\n            if (isNaN(value)) {\n              return \"NaN\";\n            } else if (Object.is(value, -0)) {\n              return String(value);\n            }\n            return value;\n          case \"bigint\":\n            return `${String(value)}n`;\n          case \"boolean\":\n          case \"undefined\":\n            return String(value);\n          case \"object\":\n            return \"{}\";\n        }\n      },\n      types: {\n        isAsyncFunction(fn) {\n          return fn instanceof AsyncFunction;\n        },\n        isArrayBufferView(arr) {\n          return ArrayBuffer.isView(arr);\n        },\n      },\n      isBlob,\n    };\n    module.exports.promisify.custom = Symbol.for(\"nodejs.util.promisify.custom\");\n  },\n});\n\n// node_modules/readable-stream/lib/ours/errors.js\nvar require_errors = __commonJS({\n  \"node_modules/readable-stream/lib/ours/errors.js\"(exports, module) {\n    \"use strict\";\n    var { format, inspect, AggregateError: CustomAggregateError } = require_util();\n    var AggregateError = globalThis.AggregateError || CustomAggregateError;\n    var kIsNodeError = Symbol(\"kIsNodeError\");\n    var kTypes = [\"string\", \"function\", \"number\", \"object\", \"Function\", \"Object\", \"boolean\", \"bigint\", \"symbol\"];\n    var classRegExp = /^([A-Z][a-z0-9]*)+$/;\n    var nodeInternalPrefix = \"__node_internal_\";\n    var codes = {};\n    function assert(value, message) {\n      if (!value) {\n        throw new codes.ERR_INTERNAL_ASSERTION(message);\n      }\n    }\n    function addNumericalSeparator(val) {\n      let res = \"\";\n      let i = val.length;\n      const start = val[0] === \"-\" ? 1 : 0;\n      for (; i >= start + 4; i -= 3) {\n        res = `_${val.slice(i - 3, i)}${res}`;\n      }\n      return `${val.slice(0, i)}${res}`;\n    }\n    function getMessage(key, msg, args) {\n      if (typeof msg === \"function\") {\n        assert(\n          msg.length <= args.length,\n          `Code: ${key}; The provided arguments length (${args.length}) does not match the required ones (${msg.length}).`,\n        );\n        return msg(...args);\n      }\n      const expectedLength = (msg.match(/%[dfijoOs]/g) || []).length;\n      assert(\n        expectedLength === args.length,\n        `Code: ${key}; The provided arguments length (${args.length}) does not match the required ones (${expectedLength}).`,\n      );\n      if (args.length === 0) {\n        return msg;\n      }\n      return format(msg, ...args);\n    }\n    function E(code, message, Base) {\n      if (!Base) {\n        Base = Error;\n      }\n      class NodeError extends Base {\n        constructor(...args) {\n          super(getMessage(code, message, args));\n        }\n        toString() {\n          return `${this.name} [${code}]: ${this.message}`;\n        }\n      }\n      Object.defineProperties(NodeError.prototype, {\n        name: {\n          value: Base.name,\n          writable: true,\n          enumerable: false,\n          configurable: true,\n        },\n        toString: {\n          value() {\n            return `${this.name} [${code}]: ${this.message}`;\n          },\n          writable: true,\n          enumerable: false,\n          configurable: true,\n        },\n      });\n      NodeError.prototype.code = code;\n      NodeError.prototype[kIsNodeError] = true;\n      codes[code] = NodeError;\n    }\n    function hideStackFrames(fn) {\n      const hidden = nodeInternalPrefix + fn.name;\n      Object.defineProperty(fn, \"name\", {\n        value: hidden,\n      });\n      return fn;\n    }\n    function aggregateTwoErrors(innerError, outerError) {\n      if (innerError && outerError && innerError !== outerError) {\n        if (Array.isArray(outerError.errors)) {\n          outerError.errors.push(innerError);\n          return outerError;\n        }\n        const err = new AggregateError([outerError, innerError], outerError.message);\n        err.code = outerError.code;\n        return err;\n      }\n      return innerError || outerError;\n    }\n    var AbortError = class extends Error {\n      constructor(message = \"The operation was aborted\", options = void 0) {\n        if (options !== void 0 && typeof options !== \"object\") {\n          throw new codes.ERR_INVALID_ARG_TYPE(\"options\", \"Object\", options);\n        }\n        super(message, options);\n        this.code = \"ABORT_ERR\";\n        this.name = \"AbortError\";\n      }\n    };\n    E(\"ERR_ASSERTION\", \"%s\", Error);\n    E(\n      \"ERR_INVALID_ARG_TYPE\",\n      (name, expected, actual) => {\n        assert(typeof name === \"string\", \"'name' must be a string\");\n        if (!Array.isArray(expected)) {\n          expected = [expected];\n        }\n        let msg = \"The \";\n        if (name.endsWith(\" argument\")) {\n          msg += `${name} `;\n        } else {\n          msg += `\"${name}\" ${name.includes(\".\") ? \"property\" : \"argument\"} `;\n        }\n        msg += \"must be \";\n        const types = [];\n        const instances = [];\n        const other = [];\n        for (const value of expected) {\n          assert(typeof value === \"string\", \"All expected entries have to be of type string\");\n          if (kTypes.includes(value)) {\n            types.push(value.toLowerCase());\n          } else if (classRegExp.test(value)) {\n            instances.push(value);\n          } else {\n            assert(value !== \"object\", 'The value \"object\" should be written as \"Object\"');\n            other.push(value);\n          }\n        }\n        if (instances.length > 0) {\n          const pos = types.indexOf(\"object\");\n          if (pos !== -1) {\n            types.splice(types, pos, 1);\n            instances.push(\"Object\");\n          }\n        }\n        if (types.length > 0) {\n          switch (types.length) {\n            case 1:\n              msg += `of type ${types[0]}`;\n              break;\n            case 2:\n              msg += `one of type ${types[0]} or ${types[1]}`;\n              break;\n            default: {\n              const last = types.pop();\n              msg += `one of type ${types.join(\", \")}, or ${last}`;\n            }\n          }\n          if (instances.length > 0 || other.length > 0) {\n            msg += \" or \";\n          }\n        }\n        if (instances.length > 0) {\n          switch (instances.length) {\n            case 1:\n              msg += `an instance of ${instances[0]}`;\n              break;\n            case 2:\n              msg += `an instance of ${instances[0]} or ${instances[1]}`;\n              break;\n            default: {\n              const last = instances.pop();\n              msg += `an instance of ${instances.join(\", \")}, or ${last}`;\n            }\n          }\n          if (other.length > 0) {\n            msg += \" or \";\n          }\n        }\n        switch (other.length) {\n          case 0:\n            break;\n          case 1:\n            if (other[0].toLowerCase() !== other[0]) {\n              msg += \"an \";\n            }\n            msg += `${other[0]}`;\n            break;\n          case 2:\n            msg += `one of ${other[0]} or ${other[1]}`;\n            break;\n          default: {\n            const last = other.pop();\n            msg += `one of ${other.join(\", \")}, or ${last}`;\n          }\n        }\n        if (actual == null) {\n          msg += `. Received ${actual}`;\n        } else if (typeof actual === \"function\" && actual.name) {\n          msg += `. Received function ${actual.name}`;\n        } else if (typeof actual === \"object\") {\n          var _actual$constructor;\n          if (\n            (_actual$constructor = actual.constructor) !== null &&\n            _actual$constructor !== void 0 &&\n            _actual$constructor.name\n          ) {\n            msg += `. Received an instance of ${actual.constructor.name}`;\n          } else {\n            const inspected = inspect(actual, {\n              depth: -1,\n            });\n            msg += `. Received ${inspected}`;\n          }\n        } else {\n          let inspected = inspect(actual, {\n            colors: false,\n          });\n          if (inspected.length > 25) {\n            inspected = `${inspected.slice(0, 25)}...`;\n          }\n          msg += `. Received type ${typeof actual} (${inspected})`;\n        }\n        return msg;\n      },\n      TypeError,\n    );\n    E(\n      \"ERR_INVALID_ARG_VALUE\",\n      (name, value, reason = \"is invalid\") => {\n        let inspected = inspect(value);\n        if (inspected.length > 128) {\n          inspected = inspected.slice(0, 128) + \"...\";\n        }\n        const type = name.includes(\".\") ? \"property\" : \"argument\";\n        return `The ${type} '${name}' ${reason}. Received ${inspected}`;\n      },\n      TypeError,\n    );\n    E(\n      \"ERR_INVALID_RETURN_VALUE\",\n      (input, name, value) => {\n        var _value$constructor;\n        const type =\n          value !== null &&\n          value !== void 0 &&\n          (_value$constructor = value.constructor) !== null &&\n          _value$constructor !== void 0 &&\n          _value$constructor.name\n            ? `instance of ${value.constructor.name}`\n            : `type ${typeof value}`;\n        return `Expected ${input} to be returned from the \"${name}\" function but got ${type}.`;\n      },\n      TypeError,\n    );\n    E(\n      \"ERR_MISSING_ARGS\",\n      (...args) => {\n        assert(args.length > 0, \"At least one arg needs to be specified\");\n        let msg;\n        const len = args.length;\n        args = (Array.isArray(args) ? args : [args]).map(a => `\"${a}\"`).join(\" or \");\n        switch (len) {\n          case 1:\n            msg += `The ${args[0]} argument`;\n            break;\n          case 2:\n            msg += `The ${args[0]} and ${args[1]} arguments`;\n            break;\n          default:\n            {\n              const last = args.pop();\n              msg += `The ${args.join(\", \")}, and ${last} arguments`;\n            }\n            break;\n        }\n        return `${msg} must be specified`;\n      },\n      TypeError,\n    );\n    E(\n      \"ERR_OUT_OF_RANGE\",\n      (str, range, input) => {\n        assert(range, 'Missing \"range\" argument');\n        let received;\n        if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {\n          received = addNumericalSeparator(String(input));\n        } else if (typeof input === \"bigint\") {\n          received = String(input);\n          if (input > 2n ** 32n || input < -(2n ** 32n)) {\n            received = addNumericalSeparator(received);\n          }\n          received += \"n\";\n        } else {\n          received = inspect(input);\n        }\n        return `The value of \"${str}\" is out of range. It must be ${range}. Received ${received}`;\n      },\n      RangeError,\n    );\n    E(\"ERR_MULTIPLE_CALLBACK\", \"Callback called multiple times\", Error);\n    E(\"ERR_METHOD_NOT_IMPLEMENTED\", \"The %s method is not implemented\", Error);\n    E(\"ERR_STREAM_ALREADY_FINISHED\", \"Cannot call %s after a stream was finished\", Error);\n    E(\"ERR_STREAM_CANNOT_PIPE\", \"Cannot pipe, not readable\", Error);\n    E(\"ERR_STREAM_DESTROYED\", \"Cannot call %s after a stream was destroyed\", Error);\n    E(\"ERR_STREAM_NULL_VALUES\", \"May not write null values to stream\", TypeError);\n    E(\"ERR_STREAM_PREMATURE_CLOSE\", \"Premature close\", Error);\n    E(\"ERR_STREAM_PUSH_AFTER_EOF\", \"stream.push() after EOF\", Error);\n    E(\"ERR_STREAM_UNSHIFT_AFTER_END_EVENT\", \"stream.unshift() after end event\", Error);\n    E(\"ERR_STREAM_WRITE_AFTER_END\", \"write after end\", Error);\n    E(\"ERR_UNKNOWN_ENCODING\", \"Unknown encoding: %s\", TypeError);\n    module.exports = {\n      AbortError,\n      aggregateTwoErrors: hideStackFrames(aggregateTwoErrors),\n      hideStackFrames,\n      codes,\n    };\n  },\n});\n\n// node_modules/readable-stream/lib/internal/validators.js\nvar require_validators = __commonJS({\n  \"node_modules/readable-stream/lib/internal/validators.js\"(exports, module) {\n    \"use strict\";\n    var {\n      ArrayIsArray,\n      ArrayPrototypeIncludes,\n      ArrayPrototypeJoin,\n      ArrayPrototypeMap,\n      NumberIsInteger,\n      NumberMAX_SAFE_INTEGER,\n      NumberMIN_SAFE_INTEGER,\n      NumberParseInt,\n      RegExpPrototypeTest,\n      String: String2,\n      StringPrototypeToUpperCase,\n      StringPrototypeTrim,\n    } = require_primordials();\n    var {\n      hideStackFrames,\n      codes: { ERR_SOCKET_BAD_PORT, ERR_INVALID_ARG_TYPE, ERR_INVALID_ARG_VALUE, ERR_OUT_OF_RANGE, ERR_UNKNOWN_SIGNAL },\n    } = require_errors();\n    var { normalizeEncoding } = require_util();\n    var { isAsyncFunction, isArrayBufferView } = require_util().types;\n    var signals = {};\n    function isInt32(value) {\n      return value === (value | 0);\n    }\n    function isUint32(value) {\n      return value === value >>> 0;\n    }\n    var octalReg = /^[0-7]+$/;\n    var modeDesc = \"must be a 32-bit unsigned integer or an octal string\";\n    function parseFileMode(value, name, def) {\n      if (typeof value === \"undefined\") {\n        value = def;\n      }\n      if (typeof value === \"string\") {\n        if (!RegExpPrototypeTest(octalReg, value)) {\n          throw new ERR_INVALID_ARG_VALUE(name, value, modeDesc);\n        }\n        value = NumberParseInt(value, 8);\n      }\n      validateInt32(value, name, 0, 2 ** 32 - 1);\n      return value;\n    }\n    var validateInteger = hideStackFrames((value, name, min = NumberMIN_SAFE_INTEGER, max = NumberMAX_SAFE_INTEGER) => {\n      if (typeof value !== \"number\") throw new ERR_INVALID_ARG_TYPE(name, \"number\", value);\n      if (!NumberIsInteger(value)) throw new ERR_OUT_OF_RANGE(name, \"an integer\", value);\n      if (value < min || value > max) throw new ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value);\n    });\n    var validateInt32 = hideStackFrames((value, name, min = -2147483648, max = 2147483647) => {\n      if (typeof value !== \"number\") {\n        throw new ERR_INVALID_ARG_TYPE(name, \"number\", value);\n      }\n      if (!isInt32(value)) {\n        if (!NumberIsInteger(value)) {\n          throw new ERR_OUT_OF_RANGE(name, \"an integer\", value);\n        }\n        throw new ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value);\n      }\n      if (value < min || value > max) {\n        throw new ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value);\n      }\n    });\n    var validateUint32 = hideStackFrames((value, name, positive) => {\n      if (typeof value !== \"number\") {\n        throw new ERR_INVALID_ARG_TYPE(name, \"number\", value);\n      }\n      if (!isUint32(value)) {\n        if (!NumberIsInteger(value)) {\n          throw new ERR_OUT_OF_RANGE(name, \"an integer\", value);\n        }\n        const min = positive ? 1 : 0;\n        throw new ERR_OUT_OF_RANGE(name, `>= ${min} && < 4294967296`, value);\n      }\n      if (positive && value === 0) {\n        throw new ERR_OUT_OF_RANGE(name, \">= 1 && < 4294967296\", value);\n      }\n    });\n    function validateString(value, name) {\n      if (typeof value !== \"string\") throw new ERR_INVALID_ARG_TYPE(name, \"string\", value);\n    }\n    function validateNumber(value, name) {\n      if (typeof value !== \"number\") throw new ERR_INVALID_ARG_TYPE(name, \"number\", value);\n    }\n    var validateOneOf = hideStackFrames((value, name, oneOf) => {\n      if (!ArrayPrototypeIncludes(oneOf, value)) {\n        const allowed = ArrayPrototypeJoin(\n          ArrayPrototypeMap(oneOf, v => (typeof v === \"string\" ? `'${v}'` : String2(v))),\n          \", \",\n        );\n        const reason = \"must be one of: \" + allowed;\n        throw new ERR_INVALID_ARG_VALUE(name, value, reason);\n      }\n    });\n    function validateBoolean(value, name) {\n      if (typeof value !== \"boolean\") throw new ERR_INVALID_ARG_TYPE(name, \"boolean\", value);\n    }\n    var validateObject = hideStackFrames((value, name, options) => {\n      const useDefaultOptions = options == null;\n      const allowArray = useDefaultOptions ? false : options.allowArray;\n      const allowFunction = useDefaultOptions ? false : options.allowFunction;\n      const nullable = useDefaultOptions ? false : options.nullable;\n      if (\n        (!nullable && value === null) ||\n        (!allowArray && ArrayIsArray(value)) ||\n        (typeof value !== \"object\" && (!allowFunction || typeof value !== \"function\"))\n      ) {\n        throw new ERR_INVALID_ARG_TYPE(name, \"Object\", value);\n      }\n    });\n    var validateArray = hideStackFrames((value, name, minLength = 0) => {\n      if (!ArrayIsArray(value)) {\n        throw new ERR_INVALID_ARG_TYPE(name, \"Array\", value);\n      }\n      if (value.length < minLength) {\n        const reason = `must be longer than ${minLength}`;\n        throw new ERR_INVALID_ARG_VALUE(name, value, reason);\n      }\n    });\n    function validateSignalName(signal, name = \"signal\") {\n      validateString(signal, name);\n      if (signals[signal] === void 0) {\n        if (signals[StringPrototypeToUpperCase(signal)] !== void 0) {\n          throw new ERR_UNKNOWN_SIGNAL(signal + \" (signals must use all capital letters)\");\n        }\n        throw new ERR_UNKNOWN_SIGNAL(signal);\n      }\n    }\n    var validateBuffer = hideStackFrames((buffer, name = \"buffer\") => {\n      if (!isArrayBufferView(buffer)) {\n        throw new ERR_INVALID_ARG_TYPE(name, [\"Buffer\", \"TypedArray\", \"DataView\"], buffer);\n      }\n    });\n    function validateEncoding(data, encoding) {\n      const normalizedEncoding = normalizeEncoding(encoding);\n      const length = data.length;\n      if (normalizedEncoding === \"hex\" && length % 2 !== 0) {\n        throw new ERR_INVALID_ARG_VALUE(\"encoding\", encoding, `is invalid for data of length ${length}`);\n      }\n    }\n    function validatePort(port, name = \"Port\", allowZero = true) {\n      if (\n        (typeof port !== \"number\" && typeof port !== \"string\") ||\n        (typeof port === \"string\" && StringPrototypeTrim(port).length === 0) ||\n        +port !== +port >>> 0 ||\n        port > 65535 ||\n        (port === 0 && !allowZero)\n      ) {\n        throw new ERR_SOCKET_BAD_PORT(name, port, allowZero);\n      }\n      return port | 0;\n    }\n    var validateAbortSignal = hideStackFrames((signal, name) => {\n      if (signal !== void 0 && (signal === null || typeof signal !== \"object\" || !(\"aborted\" in signal))) {\n        throw new ERR_INVALID_ARG_TYPE(name, \"AbortSignal\", signal);\n      }\n    });\n    var validateFunction = hideStackFrames((value, name) => {\n      if (typeof value !== \"function\") throw new ERR_INVALID_ARG_TYPE(name, \"Function\", value);\n    });\n    var validatePlainFunction = hideStackFrames((value, name) => {\n      if (typeof value !== \"function\" || isAsyncFunction(value))\n        throw new ERR_INVALID_ARG_TYPE(name, \"Function\", value);\n    });\n    var validateUndefined = hideStackFrames((value, name) => {\n      if (value !== void 0) throw new ERR_INVALID_ARG_TYPE(name, \"undefined\", value);\n    });\n    module.exports = {\n      isInt32,\n      isUint32,\n      parseFileMode,\n      validateArray,\n      validateBoolean,\n      validateBuffer,\n      validateEncoding,\n      validateFunction,\n      validateInt32,\n      validateInteger,\n      validateNumber,\n      validateObject,\n      validateOneOf,\n      validatePlainFunction,\n      validatePort,\n      validateSignalName,\n      validateString,\n      validateUint32,\n      validateUndefined,\n      validateAbortSignal,\n    };\n  },\n});\n\n// node_modules/readable-stream/lib/internal/streams/utils.js\nvar require_utils = __commonJS({\n  \"node_modules/readable-stream/lib/internal/streams/utils.js\"(exports, module) {\n    \"use strict\";\n    var { Symbol: Symbol2, SymbolAsyncIterator, SymbolIterator } = require_primordials();\n    var kDestroyed = Symbol2(\"kDestroyed\");\n    var kIsErrored = Symbol2(\"kIsErrored\");\n    var kIsReadable = Symbol2(\"kIsReadable\");\n    var kIsDisturbed = Symbol2(\"kIsDisturbed\");\n    function isReadableNodeStream(obj, strict = false) {\n      var _obj$_readableState;\n      return !!(\n        obj &&\n        typeof obj.pipe === \"function\" &&\n        typeof obj.on === \"function\" &&\n        (!strict || (typeof obj.pause === \"function\" && typeof obj.resume === \"function\")) &&\n        (!obj._writableState ||\n          ((_obj$_readableState = obj._readableState) === null || _obj$_readableState === void 0\n            ? void 0\n            : _obj$_readableState.readable) !== false) &&\n        (!obj._writableState || obj._readableState)\n      );\n    }\n    function isWritableNodeStream(obj) {\n      var _obj$_writableState;\n      return !!(\n        obj &&\n        typeof obj.write === \"function\" &&\n        typeof obj.on === \"function\" &&\n        (!obj._readableState ||\n          ((_obj$_writableState = obj._writableState) === null || _obj$_writableState === void 0\n            ? void 0\n            : _obj$_writableState.writable) !== false)\n      );\n    }\n    function isDuplexNodeStream(obj) {\n      return !!(\n        obj &&\n        typeof obj.pipe === \"function\" &&\n        obj._readableState &&\n        typeof obj.on === \"function\" &&\n        typeof obj.write === \"function\"\n      );\n    }\n    function isNodeStream(obj) {\n      return (\n        obj &&\n        (obj._readableState ||\n          obj._writableState ||\n          (typeof obj.write === \"function\" && typeof obj.on === \"function\") ||\n          (typeof obj.pipe === \"function\" && typeof obj.on === \"function\"))\n      );\n    }\n    function isIterable(obj, isAsync) {\n      if (obj == null) return false;\n      if (isAsync === true) return typeof obj[SymbolAsyncIterator] === \"function\";\n      if (isAsync === false) return typeof obj[SymbolIterator] === \"function\";\n      return typeof obj[SymbolAsyncIterator] === \"function\" || typeof obj[SymbolIterator] === \"function\";\n    }\n    function isDestroyed(stream) {\n      if (!isNodeStream(stream)) return null;\n      const wState = stream._writableState;\n      const rState = stream._readableState;\n      const state = wState || rState;\n      return !!(stream.destroyed || stream[kDestroyed] || (state !== null && state !== void 0 && state.destroyed));\n    }\n    function isWritableEnded(stream) {\n      if (!isWritableNodeStream(stream)) return null;\n      if (stream.writableEnded === true) return true;\n      const wState = stream._writableState;\n      if (wState !== null && wState !== void 0 && wState.errored) return false;\n      if (typeof (wState === null || wState === void 0 ? void 0 : wState.ended) !== \"boolean\") return null;\n      return wState.ended;\n    }\n    function isWritableFinished(stream, strict) {\n      if (!isWritableNodeStream(stream)) return null;\n      if (stream.writableFinished === true) return true;\n      const wState = stream._writableState;\n      if (wState !== null && wState !== void 0 && wState.errored) return false;\n      if (typeof (wState === null || wState === void 0 ? void 0 : wState.finished) !== \"boolean\") return null;\n      return !!(wState.finished || (strict === false && wState.ended === true && wState.length === 0));\n    }\n    function isReadableEnded(stream) {\n      if (!isReadableNodeStream(stream)) return null;\n      if (stream.readableEnded === true) return true;\n      const rState = stream._readableState;\n      if (!rState || rState.errored) return false;\n      if (typeof (rState === null || rState === void 0 ? void 0 : rState.ended) !== \"boolean\") return null;\n      return rState.ended;\n    }\n    function isReadableFinished(stream, strict) {\n      if (!isReadableNodeStream(stream)) return null;\n      const rState = stream._readableState;\n      if (rState !== null && rState !== void 0 && rState.errored) return false;\n      if (typeof (rState === null || rState === void 0 ? void 0 : rState.endEmitted) !== \"boolean\") return null;\n      return !!(rState.endEmitted || (strict === false && rState.ended === true && rState.length === 0));\n    }\n    function isReadable(stream) {\n      if (stream && stream[kIsReadable] != null) return stream[kIsReadable];\n      if (typeof (stream === null || stream === void 0 ? void 0 : stream.readable) !== \"boolean\") return null;\n      if (isDestroyed(stream)) return false;\n      return isReadableNodeStream(stream) && stream.readable && !isReadableFinished(stream);\n    }\n    function isWritable(stream) {\n      if (typeof (stream === null || stream === void 0 ? void 0 : stream.writable) !== \"boolean\") return null;\n      if (isDestroyed(stream)) return false;\n      return isWritableNodeStream(stream) && stream.writable && !isWritableEnded(stream);\n    }\n    function isFinished(stream, opts) {\n      if (!isNodeStream(stream)) {\n        return null;\n      }\n      if (isDestroyed(stream)) {\n        return true;\n      }\n      if ((opts === null || opts === void 0 ? void 0 : opts.readable) !== false && isReadable(stream)) {\n        return false;\n      }\n      if ((opts === null || opts === void 0 ? void 0 : opts.writable) !== false && isWritable(stream)) {\n        return false;\n      }\n      return true;\n    }\n    function isWritableErrored(stream) {\n      var _stream$_writableStat, _stream$_writableStat2;\n      if (!isNodeStream(stream)) {\n        return null;\n      }\n      if (stream.writableErrored) {\n        return stream.writableErrored;\n      }\n      return (_stream$_writableStat =\n        (_stream$_writableStat2 = stream._writableState) === null || _stream$_writableStat2 === void 0\n          ? void 0\n          : _stream$_writableStat2.errored) !== null && _stream$_writableStat !== void 0\n        ? _stream$_writableStat\n        : null;\n    }\n    function isReadableErrored(stream) {\n      var _stream$_readableStat, _stream$_readableStat2;\n      if (!isNodeStream(stream)) {\n        return null;\n      }\n      if (stream.readableErrored) {\n        return stream.readableErrored;\n      }\n      return (_stream$_readableStat =\n        (_stream$_readableStat2 = stream._readableState) === null || _stream$_readableStat2 === void 0\n          ? void 0\n          : _stream$_readableStat2.errored) !== null && _stream$_readableStat !== void 0\n        ? _stream$_readableStat\n        : null;\n    }\n    function isClosed(stream) {\n      if (!isNodeStream(stream)) {\n        return null;\n      }\n      if (typeof stream.closed === \"boolean\") {\n        return stream.closed;\n      }\n      const wState = stream._writableState;\n      const rState = stream._readableState;\n      if (\n        typeof (wState === null || wState === void 0 ? void 0 : wState.closed) === \"boolean\" ||\n        typeof (rState === null || rState === void 0 ? void 0 : rState.closed) === \"boolean\"\n      ) {\n        return (\n          (wState === null || wState === void 0 ? void 0 : wState.closed) ||\n          (rState === null || rState === void 0 ? void 0 : rState.closed)\n        );\n      }\n      if (typeof stream._closed === \"boolean\" && isOutgoingMessage(stream)) {\n        return stream._closed;\n      }\n      return null;\n    }\n    function isOutgoingMessage(stream) {\n      return (\n        typeof stream._closed === \"boolean\" &&\n        typeof stream._defaultKeepAlive === \"boolean\" &&\n        typeof stream._removedConnection === \"boolean\" &&\n        typeof stream._removedContLen === \"boolean\"\n      );\n    }\n    function isServerResponse(stream) {\n      return typeof stream._sent100 === \"boolean\" && isOutgoingMessage(stream);\n    }\n    function isServerRequest(stream) {\n      var _stream$req;\n      return (\n        typeof stream._consuming === \"boolean\" &&\n        typeof stream._dumped === \"boolean\" &&\n        ((_stream$req = stream.req) === null || _stream$req === void 0 ? void 0 : _stream$req.upgradeOrConnect) ===\n          void 0\n      );\n    }\n    function willEmitClose(stream) {\n      if (!isNodeStream(stream)) return null;\n      const wState = stream._writableState;\n      const rState = stream._readableState;\n      const state = wState || rState;\n      return (\n        (!state && isServerResponse(stream)) ||\n        !!(state && state.autoDestroy && state.emitClose && state.closed === false)\n      );\n    }\n    function isDisturbed(stream) {\n      var _stream$kIsDisturbed;\n      return !!(\n        stream &&\n        ((_stream$kIsDisturbed = stream[kIsDisturbed]) !== null && _stream$kIsDisturbed !== void 0\n          ? _stream$kIsDisturbed\n          : stream.readableDidRead || stream.readableAborted)\n      );\n    }\n    function isErrored(stream) {\n      var _ref,\n        _ref2,\n        _ref3,\n        _ref4,\n        _ref5,\n        _stream$kIsErrored,\n        _stream$_readableStat3,\n        _stream$_writableStat3,\n        _stream$_readableStat4,\n        _stream$_writableStat4;\n      return !!(\n        stream &&\n        ((_ref =\n          (_ref2 =\n            (_ref3 =\n              (_ref4 =\n                (_ref5 =\n                  (_stream$kIsErrored = stream[kIsErrored]) !== null && _stream$kIsErrored !== void 0\n                    ? _stream$kIsErrored\n                    : stream.readableErrored) !== null && _ref5 !== void 0\n                  ? _ref5\n                  : stream.writableErrored) !== null && _ref4 !== void 0\n                ? _ref4\n                : (_stream$_readableStat3 = stream._readableState) === null || _stream$_readableStat3 === void 0\n                ? void 0\n                : _stream$_readableStat3.errorEmitted) !== null && _ref3 !== void 0\n              ? _ref3\n              : (_stream$_writableStat3 = stream._writableState) === null || _stream$_writableStat3 === void 0\n              ? void 0\n              : _stream$_writableStat3.errorEmitted) !== null && _ref2 !== void 0\n            ? _ref2\n            : (_stream$_readableStat4 = stream._readableState) === null || _stream$_readableStat4 === void 0\n            ? void 0\n            : _stream$_readableStat4.errored) !== null && _ref !== void 0\n          ? _ref\n          : (_stream$_writableStat4 = stream._writableState) === null || _stream$_writableStat4 === void 0\n          ? void 0\n          : _stream$_writableStat4.errored)\n      );\n    }\n    module.exports = {\n      kDestroyed,\n      isDisturbed,\n      kIsDisturbed,\n      isErrored,\n      kIsErrored,\n      isReadable,\n      kIsReadable,\n      isClosed,\n      isDestroyed,\n      isDuplexNodeStream,\n      isFinished,\n      isIterable,\n      isReadableNodeStream,\n      isReadableEnded,\n      isReadableFinished,\n      isReadableErrored,\n      isNodeStream,\n      isWritable,\n      isWritableNodeStream,\n      isWritableEnded,\n      isWritableFinished,\n      isWritableErrored,\n      isServerRequest,\n      isServerResponse,\n      willEmitClose,\n    };\n  },\n});\n\n// node_modules/readable-stream/lib/internal/streams/end-of-stream.js\nvar require_end_of_stream = __commonJS({\n  \"node_modules/readable-stream/lib/internal/streams/end-of-stream.js\"(exports, module) {\n    \"use strict\";\n    var { AbortError, codes } = require_errors();\n    var { ERR_INVALID_ARG_TYPE, ERR_STREAM_PREMATURE_CLOSE } = codes;\n    var { once } = require_util();\n    var { validateAbortSignal, validateFunction, validateObject } = require_validators();\n    var { Promise: Promise2 } = require_primordials();\n    var {\n      isClosed,\n      isReadable,\n      isReadableNodeStream,\n      isReadableFinished,\n      isReadableErrored,\n      isWritable,\n      isWritableNodeStream,\n      isWritableFinished,\n      isWritableErrored,\n      isNodeStream,\n      willEmitClose: _willEmitClose,\n    } = require_utils();\n    function isRequest(stream) {\n      return stream.setHeader && typeof stream.abort === \"function\";\n    }\n    var nop = () => {};\n    function eos(stream, options, callback) {\n      var _options$readable, _options$writable;\n      if (arguments.length === 2) {\n        callback = options;\n        options = {};\n      } else if (options == null) {\n        options = {};\n      } else {\n        validateObject(options, \"options\");\n      }\n      validateFunction(callback, \"callback\");\n      validateAbortSignal(options.signal, \"options.signal\");\n      callback = once(callback);\n      const readable =\n        (_options$readable = options.readable) !== null && _options$readable !== void 0\n          ? _options$readable\n          : isReadableNodeStream(stream);\n      const writable =\n        (_options$writable = options.writable) !== null && _options$writable !== void 0\n          ? _options$writable\n          : isWritableNodeStream(stream);\n      if (!isNodeStream(stream)) {\n        throw new ERR_INVALID_ARG_TYPE(\"stream\", \"Stream\", stream);\n      }\n      const wState = stream._writableState;\n      const rState = stream._readableState;\n      const onlegacyfinish = () => {\n        if (!stream.writable) {\n          onfinish();\n        }\n      };\n      let willEmitClose =\n        _willEmitClose(stream) &&\n        isReadableNodeStream(stream) === readable &&\n        isWritableNodeStream(stream) === writable;\n      let writableFinished = isWritableFinished(stream, false);\n      const onfinish = () => {\n        writableFinished = true;\n        if (stream.destroyed) {\n          willEmitClose = false;\n        }\n        if (willEmitClose && (!stream.readable || readable)) {\n          return;\n        }\n        if (!readable || readableFinished) {\n          callback.call(stream);\n        }\n      };\n      let readableFinished = isReadableFinished(stream, false);\n      const onend = () => {\n        readableFinished = true;\n        if (stream.destroyed) {\n          willEmitClose = false;\n        }\n        if (willEmitClose && (!stream.writable || writable)) {\n          return;\n        }\n        if (!writable || writableFinished) {\n          callback.call(stream);\n        }\n      };\n      const onerror = err => {\n        callback.call(stream, err);\n      };\n      let closed = isClosed(stream);\n      const onclose = () => {\n        closed = true;\n        const errored = isWritableErrored(stream) || isReadableErrored(stream);\n        if (errored && typeof errored !== \"boolean\") {\n          return callback.call(stream, errored);\n        }\n        if (readable && !readableFinished && isReadableNodeStream(stream, true)) {\n          if (!isReadableFinished(stream, false)) return callback.call(stream, new ERR_STREAM_PREMATURE_CLOSE());\n        }\n        if (writable && !writableFinished) {\n          if (!isWritableFinished(stream, false)) return callback.call(stream, new ERR_STREAM_PREMATURE_CLOSE());\n        }\n        callback.call(stream);\n      };\n      const onrequest = () => {\n        stream.req.on(\"finish\", onfinish);\n      };\n      if (isRequest(stream)) {\n        stream.on(\"complete\", onfinish);\n        if (!willEmitClose) {\n          stream.on(\"abort\", onclose);\n        }\n        if (stream.req) {\n          onrequest();\n        } else {\n          stream.on(\"request\", onrequest);\n        }\n      } else if (writable && !wState) {\n        stream.on(\"end\", onlegacyfinish);\n        stream.on(\"close\", onlegacyfinish);\n      }\n      if (!willEmitClose && typeof stream.aborted === \"boolean\") {\n        stream.on(\"aborted\", onclose);\n      }\n      stream.on(\"end\", onend);\n      stream.on(\"finish\", onfinish);\n      if (options.error !== false) {\n        stream.on(\"error\", onerror);\n      }\n      stream.on(\"close\", onclose);\n      if (closed) {\n        runOnNextTick(onclose);\n      } else if (\n        (wState !== null && wState !== void 0 && wState.errorEmitted) ||\n        (rState !== null && rState !== void 0 && rState.errorEmitted)\n      ) {\n        if (!willEmitClose) {\n          runOnNextTick(onclose);\n        }\n      } else if (\n        !readable &&\n        (!willEmitClose || isReadable(stream)) &&\n        (writableFinished || isWritable(stream) === false)\n      ) {\n        runOnNextTick(onclose);\n      } else if (\n        !writable &&\n        (!willEmitClose || isWritable(stream)) &&\n        (readableFinished || isReadable(stream) === false)\n      ) {\n        runOnNextTick(onclose);\n      } else if (rState && stream.req && stream.aborted) {\n        runOnNextTick(onclose);\n      }\n      const cleanup = () => {\n        callback = nop;\n        stream.removeListener(\"aborted\", onclose);\n        stream.removeListener(\"complete\", onfinish);\n        stream.removeListener(\"abort\", onclose);\n        stream.removeListener(\"request\", onrequest);\n        if (stream.req) stream.req.removeListener(\"finish\", onfinish);\n        stream.removeListener(\"end\", onlegacyfinish);\n        stream.removeListener(\"close\", onlegacyfinish);\n        stream.removeListener(\"finish\", onfinish);\n        stream.removeListener(\"end\", onend);\n        stream.removeListener(\"error\", onerror);\n        stream.removeListener(\"close\", onclose);\n      };\n      if (options.signal && !closed) {\n        const abort = () => {\n          const endCallback = callback;\n          cleanup();\n          endCallback.call(\n            stream,\n            new AbortError(void 0, {\n              cause: options.signal.reason,\n            }),\n          );\n        };\n        if (options.signal.aborted) {\n          runOnNextTick(abort);\n        } else {\n          const originalCallback = callback;\n          callback = once((...args) => {\n            options.signal.removeEventListener(\"abort\", abort);\n            originalCallback.apply(stream, args);\n          });\n          options.signal.addEventListener(\"abort\", abort);\n        }\n      }\n      return cleanup;\n    }\n    function finished(stream, opts) {\n      return new Promise2((resolve, reject) => {\n        eos(stream, opts, err => {\n          if (err) {\n            reject(err);\n          } else {\n            resolve();\n          }\n        });\n      });\n    }\n    module.exports = eos;\n    module.exports.finished = finished;\n  },\n});\n\n// node_modules/readable-stream/lib/internal/streams/operators.js\nvar require_operators = __commonJS({\n  \"node_modules/readable-stream/lib/internal/streams/operators.js\"(exports, module) {\n    \"use strict\";\n    var AbortController = globalThis.AbortController || __require(\"abort-controller\").AbortController;\n    var {\n      codes: { ERR_INVALID_ARG_TYPE, ERR_MISSING_ARGS, ERR_OUT_OF_RANGE },\n      AbortError,\n    } = require_errors();\n    var { validateAbortSignal, validateInteger, validateObject } = require_validators();\n    var kWeakHandler = require_primordials().Symbol(\"kWeak\");\n    var { finished } = require_end_of_stream();\n    var {\n      ArrayPrototypePush,\n      MathFloor,\n      Number: Number2,\n      NumberIsNaN,\n      Promise: Promise2,\n      PromiseReject,\n      PromisePrototypeCatch,\n      Symbol: Symbol2,\n    } = require_primordials();\n    var kEmpty = Symbol2(\"kEmpty\");\n    var kEof = Symbol2(\"kEof\");\n    function map(fn, options) {\n      if (typeof fn !== \"function\") {\n        throw new ERR_INVALID_ARG_TYPE(\"fn\", [\"Function\", \"AsyncFunction\"], fn);\n      }\n      if (options != null) {\n        validateObject(options, \"options\");\n      }\n      if ((options === null || options === void 0 ? void 0 : options.signal) != null) {\n        validateAbortSignal(options.signal, \"options.signal\");\n      }\n      let concurrency = 1;\n      if ((options === null || options === void 0 ? void 0 : options.concurrency) != null) {\n        concurrency = MathFloor(options.concurrency);\n      }\n      validateInteger(concurrency, \"concurrency\", 1);\n      return async function* map2() {\n        var _options$signal, _options$signal2;\n        const ac = new AbortController();\n        const stream = this;\n        const queue = [];\n        const signal = ac.signal;\n        const signalOpt = {\n          signal,\n        };\n        const abort = () => ac.abort();\n        if (\n          options !== null &&\n          options !== void 0 &&\n          (_options$signal = options.signal) !== null &&\n          _options$signal !== void 0 &&\n          _options$signal.aborted\n        ) {\n          abort();\n        }\n        options === null || options === void 0\n          ? void 0\n          : (_options$signal2 = options.signal) === null || _options$signal2 === void 0\n          ? void 0\n          : _options$signal2.addEventListener(\"abort\", abort);\n        let next;\n        let resume;\n        let done = false;\n        function onDone() {\n          done = true;\n        }\n        async function pump() {\n          try {\n            for await (let val of stream) {\n              var _val;\n              if (done) {\n                return;\n              }\n              if (signal.aborted) {\n                throw new AbortError();\n              }\n              try {\n                val = fn(val, signalOpt);\n              } catch (err) {\n                val = PromiseReject(err);\n              }\n              if (val === kEmpty) {\n                continue;\n              }\n              if (typeof ((_val = val) === null || _val === void 0 ? void 0 : _val.catch) === \"function\") {\n                val.catch(onDone);\n              }\n              queue.push(val);\n              if (next) {\n                next();\n                next = null;\n              }\n              if (!done && queue.length && queue.length >= concurrency) {\n                await new Promise2(resolve => {\n                  resume = resolve;\n                });\n              }\n            }\n            queue.push(kEof);\n          } catch (err) {\n            const val = PromiseReject(err);\n            PromisePrototypeCatch(val, onDone);\n            queue.push(val);\n          } finally {\n            var _options$signal3;\n            done = true;\n            if (next) {\n              next();\n              next = null;\n            }\n            options === null || options === void 0\n              ? void 0\n              : (_options$signal3 = options.signal) === null || _options$signal3 === void 0\n              ? void 0\n              : _options$signal3.removeEventListener(\"abort\", abort);\n          }\n        }\n        pump();\n        try {\n          while (true) {\n            while (queue.length > 0) {\n              const val = await queue[0];\n              if (val === kEof) {\n                return;\n              }\n              if (signal.aborted) {\n                throw new AbortError();\n              }\n              if (val !== kEmpty) {\n                yield val;\n              }\n              queue.shift();\n              if (resume) {\n                resume();\n                resume = null;\n              }\n            }\n            await new Promise2(resolve => {\n              next = resolve;\n            });\n          }\n        } finally {\n          ac.abort();\n          done = true;\n          if (resume) {\n            resume();\n            resume = null;\n          }\n        }\n      }.call(this);\n    }\n    function asIndexedPairs(options = void 0) {\n      if (options != null) {\n        validateObject(options, \"options\");\n      }\n      if ((options === null || options === void 0 ? void 0 : options.signal) != null) {\n        validateAbortSignal(options.signal, \"options.signal\");\n      }\n      return async function* asIndexedPairs2() {\n        let index = 0;\n        for await (const val of this) {\n          var _options$signal4;\n          if (\n            options !== null &&\n            options !== void 0 &&\n            (_options$signal4 = options.signal) !== null &&\n            _options$signal4 !== void 0 &&\n            _options$signal4.aborted\n          ) {\n            throw new AbortError({\n              cause: options.signal.reason,\n            });\n          }\n          yield [index++, val];\n        }\n      }.call(this);\n    }\n    async function some(fn, options = void 0) {\n      for await (const unused of filter.call(this, fn, options)) {\n        return true;\n      }\n      return false;\n    }\n    async function every(fn, options = void 0) {\n      if (typeof fn !== \"function\") {\n        throw new ERR_INVALID_ARG_TYPE(\"fn\", [\"Function\", \"AsyncFunction\"], fn);\n      }\n      return !(await some.call(\n        this,\n        async (...args) => {\n          return !(await fn(...args));\n        },\n        options,\n      ));\n    }\n    async function find(fn, options) {\n      for await (const result of filter.call(this, fn, options)) {\n        return result;\n      }\n      return void 0;\n    }\n    async function forEach(fn, options) {\n      if (typeof fn !== \"function\") {\n        throw new ERR_INVALID_ARG_TYPE(\"fn\", [\"Function\", \"AsyncFunction\"], fn);\n      }\n      async function forEachFn(value, options2) {\n        await fn(value, options2);\n        return kEmpty;\n      }\n      for await (const unused of map.call(this, forEachFn, options));\n    }\n    function filter(fn, options) {\n      if (typeof fn !== \"function\") {\n        throw new ERR_INVALID_ARG_TYPE(\"fn\", [\"Function\", \"AsyncFunction\"], fn);\n      }\n      async function filterFn(value, options2) {\n        if (await fn(value, options2)) {\n          return value;\n        }\n        return kEmpty;\n      }\n      return map.call(this, filterFn, options);\n    }\n    var ReduceAwareErrMissingArgs = class extends ERR_MISSING_ARGS {\n      constructor() {\n        super(\"reduce\");\n        this.message = \"Reduce of an empty stream requires an initial value\";\n      }\n    };\n    async function reduce(reducer, initialValue, options) {\n      var _options$signal5;\n      if (typeof reducer !== \"function\") {\n        throw new ERR_INVALID_ARG_TYPE(\"reducer\", [\"Function\", \"AsyncFunction\"], reducer);\n      }\n      if (options != null) {\n        validateObject(options, \"options\");\n      }\n      if ((options === null || options === void 0 ? void 0 : options.signal) != null) {\n        validateAbortSignal(options.signal, \"options.signal\");\n      }\n      let hasInitialValue = arguments.length > 1;\n      if (\n        options !== null &&\n        options !== void 0 &&\n        (_options$signal5 = options.signal) !== null &&\n        _options$signal5 !== void 0 &&\n        _options$signal5.aborted\n      ) {\n        const err = new AbortError(void 0, {\n          cause: options.signal.reason,\n        });\n        this.once(\"error\", () => {});\n        await finished(this.destroy(err));\n        throw err;\n      }\n      const ac = new AbortController();\n      const signal = ac.signal;\n      if (options !== null && options !== void 0 && options.signal) {\n        const opts = {\n          once: true,\n          [kWeakHandler]: this,\n        };\n        options.signal.addEventListener(\"abort\", () => ac.abort(), opts);\n      }\n      let gotAnyItemFromStream = false;\n      try {\n        for await (const value of this) {\n          var _options$signal6;\n          gotAnyItemFromStream = true;\n          if (\n            options !== null &&\n            options !== void 0 &&\n            (_options$signal6 = options.signal) !== null &&\n            _options$signal6 !== void 0 &&\n            _options$signal6.aborted\n          ) {\n            throw new AbortError();\n          }\n          if (!hasInitialValue) {\n            initialValue = value;\n            hasInitialValue = true;\n          } else {\n            initialValue = await reducer(initialValue, value, {\n              signal,\n            });\n          }\n        }\n        if (!gotAnyItemFromStream && !hasInitialValue) {\n          throw new ReduceAwareErrMissingArgs();\n        }\n      } finally {\n        ac.abort();\n      }\n      return initialValue;\n    }\n    async function toArray(options) {\n      if (options != null) {\n        validateObject(options, \"options\");\n      }\n      if ((options === null || options === void 0 ? void 0 : options.signal) != null) {\n        validateAbortSignal(options.signal, \"options.signal\");\n      }\n      const result = [];\n      for await (const val of this) {\n        var _options$signal7;\n        if (\n          options !== null &&\n          options !== void 0 &&\n          (_options$signal7 = options.signal) !== null &&\n          _options$signal7 !== void 0 &&\n          _options$signal7.aborted\n        ) {\n          throw new AbortError(void 0, {\n            cause: options.signal.reason,\n          });\n        }\n        ArrayPrototypePush(result, val);\n      }\n      return result;\n    }\n    function flatMap(fn, options) {\n      const values = map.call(this, fn, options);\n      return async function* flatMap2() {\n        for await (const val of values) {\n          yield* val;\n        }\n      }.call(this);\n    }\n    function toIntegerOrInfinity(number) {\n      number = Number2(number);\n      if (NumberIsNaN(number)) {\n        return 0;\n      }\n      if (number < 0) {\n        throw new ERR_OUT_OF_RANGE(\"number\", \">= 0\", number);\n      }\n      return number;\n    }\n    function drop(number, options = void 0) {\n      if (options != null) {\n        validateObject(options, \"options\");\n      }\n      if ((options === null || options === void 0 ? void 0 : options.signal) != null) {\n        validateAbortSignal(options.signal, \"options.signal\");\n      }\n      number = toIntegerOrInfinity(number);\n      return async function* drop2() {\n        var _options$signal8;\n        if (\n          options !== null &&\n          options !== void 0 &&\n          (_options$signal8 = options.signal) !== null &&\n          _options$signal8 !== void 0 &&\n          _options$signal8.aborted\n        ) {\n          throw new AbortError();\n        }\n        for await (const val of this) {\n          var _options$signal9;\n          if (\n            options !== null &&\n            options !== void 0 &&\n            (_options$signal9 = options.signal) !== null &&\n            _options$signal9 !== void 0 &&\n            _options$signal9.aborted\n          ) {\n            throw new AbortError();\n          }\n          if (number-- <= 0) {\n            yield val;\n          }\n        }\n      }.call(this);\n    }\n    function take(number, options = void 0) {\n      if (options != null) {\n        validateObject(options, \"options\");\n      }\n      if ((options === null || options === void 0 ? void 0 : options.signal) != null) {\n        validateAbortSignal(options.signal, \"options.signal\");\n      }\n      number = toIntegerOrInfinity(number);\n      return async function* take2() {\n        var _options$signal10;\n        if (\n          options !== null &&\n          options !== void 0 &&\n          (_options$signal10 = options.signal) !== null &&\n          _options$signal10 !== void 0 &&\n          _options$signal10.aborted\n        ) {\n          throw new AbortError();\n        }\n        for await (const val of this) {\n          var _options$signal11;\n          if (\n            options !== null &&\n            options !== void 0 &&\n            (_options$signal11 = options.signal) !== null &&\n            _options$signal11 !== void 0 &&\n            _options$signal11.aborted\n          ) {\n            throw new AbortError();\n          }\n          if (number-- > 0) {\n            yield val;\n          } else {\n            return;\n          }\n        }\n      }.call(this);\n    }\n    module.exports.streamReturningOperators = {\n      asIndexedPairs,\n      drop,\n      filter,\n      flatMap,\n      map,\n      take,\n    };\n    module.exports.promiseReturningOperators = {\n      every,\n      forEach,\n      reduce,\n      toArray,\n      some,\n      find,\n    };\n  },\n});\n\n// node_modules/readable-stream/lib/internal/streams/destroy.js\nvar require_destroy = __commonJS({\n  \"node_modules/readable-stream/lib/internal/streams/destroy.js\"(exports, module) {\n    \"use strict\";\n    var {\n      aggregateTwoErrors,\n      codes: { ERR_MULTIPLE_CALLBACK },\n      AbortError,\n    } = require_errors();\n    var { Symbol: Symbol2 } = require_primordials();\n    var { kDestroyed, isDestroyed, isFinished, isServerRequest } = require_utils();\n    var kDestroy = \"#kDestroy\";\n    var kConstruct = \"#kConstruct\";\n    function checkError(err, w, r) {\n      if (err) {\n        err.stack;\n        if (w && !w.errored) {\n          w.errored = err;\n        }\n        if (r && !r.errored) {\n          r.errored = err;\n        }\n      }\n    }\n    function destroy(err, cb) {\n      const r = this._readableState;\n      const w = this._writableState;\n      const s = w || r;\n      if ((w && w.destroyed) || (r && r.destroyed)) {\n        if (typeof cb === \"function\") {\n          cb();\n        }\n        return this;\n      }\n      checkError(err, w, r);\n      if (w) {\n        w.destroyed = true;\n      }\n      if (r) {\n        r.destroyed = true;\n      }\n      if (!s.constructed) {\n        this.once(kDestroy, er => {\n          _destroy(this, aggregateTwoErrors(er, err), cb);\n        });\n      } else {\n        _destroy(this, err, cb);\n      }\n      return this;\n    }\n    function _destroy(self, err, cb) {\n      let called = false;\n      function onDestroy(err2) {\n        if (called) {\n          return;\n        }\n        called = true;\n        const r = self._readableState;\n        const w = self._writableState;\n        checkError(err2, w, r);\n        if (w) {\n          w.closed = true;\n        }\n        if (r) {\n          r.closed = true;\n        }\n        if (typeof cb === \"function\") {\n          cb(err2);\n        }\n        if (err2) {\n          runOnNextTick(emitErrorCloseNT, self, err2);\n        } else {\n          runOnNextTick(emitCloseNT, self);\n        }\n      }\n      try {\n        self._destroy(err || null, onDestroy);\n      } catch (err2) {\n        onDestroy(err2);\n      }\n    }\n    function emitErrorCloseNT(self, err) {\n      emitErrorNT(self, err);\n      emitCloseNT(self);\n    }\n    function emitCloseNT(self) {\n      const r = self._readableState;\n      const w = self._writableState;\n      if (w) {\n        w.closeEmitted = true;\n      }\n      if (r) {\n        r.closeEmitted = true;\n      }\n      if ((w && w.emitClose) || (r && r.emitClose)) {\n        self.emit(\"close\");\n      }\n    }\n    function emitErrorNT(self, err) {\n      const r = self?._readableState;\n      const w = self?._writableState;\n      if (w?.errorEmitted || r?.errorEmitted) {\n        return;\n      }\n      if (w) {\n        w.errorEmitted = true;\n      }\n      if (r) {\n        r.errorEmitted = true;\n      }\n      self?.emit?.(\"error\", err);\n    }\n    function undestroy() {\n      const r = this._readableState;\n      const w = this._writableState;\n      if (r) {\n        r.constructed = true;\n        r.closed = false;\n        r.closeEmitted = false;\n        r.destroyed = false;\n        r.errored = null;\n        r.errorEmitted = false;\n        r.reading = false;\n        r.ended = r.readable === false;\n        r.endEmitted = r.readable === false;\n      }\n      if (w) {\n        w.constructed = true;\n        w.destroyed = false;\n        w.closed = false;\n        w.closeEmitted = false;\n        w.errored = null;\n        w.errorEmitted = false;\n        w.finalCalled = false;\n        w.prefinished = false;\n        w.ended = w.writable === false;\n        w.ending = w.writable === false;\n        w.finished = w.writable === false;\n      }\n    }\n    function errorOrDestroy(stream, err, sync) {\n      const r = stream?._readableState;\n      const w = stream?._writableState;\n      if ((w && w.destroyed) || (r && r.destroyed)) {\n        return this;\n      }\n      if ((r && r.autoDestroy) || (w && w.autoDestroy)) stream.destroy(err);\n      else if (err) {\n        Error.captureStackTrace(err);\n        if (w && !w.errored) {\n          w.errored = err;\n        }\n        if (r && !r.errored) {\n          r.errored = err;\n        }\n        if (sync) {\n          runOnNextTick(emitErrorNT, stream, err);\n        } else {\n          emitErrorNT(stream, err);\n        }\n      }\n    }\n    function construct(stream, cb) {\n      if (typeof stream._construct !== \"function\") {\n        return;\n      }\n      const r = stream._readableState;\n      const w = stream._writableState;\n      if (r) {\n        r.constructed = false;\n      }\n      if (w) {\n        w.constructed = false;\n      }\n      stream.once(kConstruct, cb);\n      if (stream.listenerCount(kConstruct) > 1) {\n        return;\n      }\n      runOnNextTick(constructNT, stream);\n    }\n    function constructNT(stream) {\n      let called = false;\n      function onConstruct(err) {\n        if (called) {\n          errorOrDestroy(stream, err !== null && err !== void 0 ? err : new ERR_MULTIPLE_CALLBACK());\n          return;\n        }\n        called = true;\n        const r = stream._readableState;\n        const w = stream._writableState;\n        const s = w || r;\n        if (r) {\n          r.constructed = true;\n        }\n        if (w) {\n          w.constructed = true;\n        }\n        if (s.destroyed) {\n          stream.emit(kDestroy, err);\n        } else if (err) {\n          errorOrDestroy(stream, err, true);\n        } else {\n          runOnNextTick(emitConstructNT, stream);\n        }\n      }\n      try {\n        stream._construct(onConstruct);\n      } catch (err) {\n        onConstruct(err);\n      }\n    }\n    function emitConstructNT(stream) {\n      stream.emit(kConstruct);\n    }\n    function isRequest(stream) {\n      return stream && stream.setHeader && typeof stream.abort === \"function\";\n    }\n    function emitCloseLegacy(stream) {\n      stream.emit(\"close\");\n    }\n    function emitErrorCloseLegacy(stream, err) {\n      stream.emit(\"error\", err);\n      runOnNextTick(emitCloseLegacy, stream);\n    }\n    function destroyer(stream, err) {\n      if (!stream || isDestroyed(stream)) {\n        return;\n      }\n      if (!err && !isFinished(stream)) {\n        err = new AbortError();\n      }\n      if (isServerRequest(stream)) {\n        stream.socket = null;\n        stream.destroy(err);\n      } else if (isRequest(stream)) {\n        stream.abort();\n      } else if (isRequest(stream.req)) {\n        stream.req.abort();\n      } else if (typeof stream.destroy === \"function\") {\n        stream.destroy(err);\n      } else if (typeof stream.close === \"function\") {\n        stream.close();\n      } else if (err) {\n        runOnNextTick(emitErrorCloseLegacy, stream);\n      } else {\n        runOnNextTick(emitCloseLegacy, stream);\n      }\n      if (!stream.destroyed) {\n        stream[kDestroyed] = true;\n      }\n    }\n    module.exports = {\n      construct,\n      destroyer,\n      destroy,\n      undestroy,\n      errorOrDestroy,\n    };\n  },\n});\n\n// node_modules/readable-stream/lib/internal/streams/legacy.js\nvar require_legacy = __commonJS({\n  \"node_modules/readable-stream/lib/internal/streams/legacy.js\"(exports, module) {\n    \"use strict\";\n    var { ArrayIsArray, ObjectSetPrototypeOf } = require_primordials();\n    var { EventEmitter: _EE } = __require(\"bun:events_native\");\n    var EE;\n    if (__TRACK_EE__) {\n      EE = DebugEventEmitter;\n    } else {\n      EE = _EE;\n    }\n\n    function Stream(options) {\n      if (!(this instanceof Stream)) return new Stream(options);\n      EE.call(this, options);\n    }\n    ObjectSetPrototypeOf(Stream.prototype, EE.prototype);\n    ObjectSetPrototypeOf(Stream, EE);\n\n    Stream.prototype.pipe = function (dest, options) {\n      const source = this;\n      function ondata(chunk) {\n        if (dest.writable && dest.write(chunk) === false && source.pause) {\n          source.pause();\n        }\n      }\n      source.on(\"data\", ondata);\n      function ondrain() {\n        if (source.readable && source.resume) {\n          source.resume();\n        }\n      }\n      dest.on(\"drain\", ondrain);\n      if (!dest._isStdio && (!options || options.end !== false)) {\n        source.on(\"end\", onend);\n        source.on(\"close\", onclose);\n      }\n      let didOnEnd = false;\n      function onend() {\n        if (didOnEnd) return;\n        didOnEnd = true;\n        dest.end();\n      }\n      function onclose() {\n        if (didOnEnd) return;\n        didOnEnd = true;\n        if (typeof dest.destroy === \"function\") dest.destroy();\n      }\n      function onerror(er) {\n        cleanup();\n        if (EE.listenerCount(this, \"error\") === 0) {\n          this.emit(\"error\", er);\n        }\n      }\n      prependListener(source, \"error\", onerror);\n      prependListener(dest, \"error\", onerror);\n      function cleanup() {\n        source.removeListener(\"data\", ondata);\n        dest.removeListener(\"drain\", ondrain);\n        source.removeListener(\"end\", onend);\n        source.removeListener(\"close\", onclose);\n        source.removeListener(\"error\", onerror);\n        dest.removeListener(\"error\", onerror);\n        source.removeListener(\"end\", cleanup);\n        source.removeListener(\"close\", cleanup);\n        dest.removeListener(\"close\", cleanup);\n      }\n      source.on(\"end\", cleanup);\n      source.on(\"close\", cleanup);\n      dest.on(\"close\", cleanup);\n      dest.emit(\"pipe\", source);\n      return dest;\n    };\n    function prependListener(emitter, event, fn) {\n      if (typeof emitter.prependListener === \"function\") return emitter.prependListener(event, fn);\n      if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);\n      else if (ArrayIsArray(emitter._events[event])) emitter._events[event].unshift(fn);\n      else emitter._events[event] = [fn, emitter._events[event]];\n    }\n    module.exports = {\n      Stream,\n      prependListener,\n    };\n  },\n});\n\n// node_modules/readable-stream/lib/internal/streams/add-abort-signal.js\nvar require_add_abort_signal = __commonJS({\n  \"node_modules/readable-stream/lib/internal/streams/add-abort-signal.js\"(exports, module) {\n    \"use strict\";\n    var { AbortError, codes } = require_errors();\n    var eos = require_end_of_stream();\n    var { ERR_INVALID_ARG_TYPE } = codes;\n    var validateAbortSignal = (signal, name) => {\n      if (typeof signal !== \"object\" || !(\"aborted\" in signal)) {\n        throw new ERR_INVALID_ARG_TYPE(name, \"AbortSignal\", signal);\n      }\n    };\n    function isNodeStream(obj) {\n      return !!(obj && typeof obj.pipe === \"function\");\n    }\n    module.exports.addAbortSignal = function addAbortSignal(signal, stream) {\n      validateAbortSignal(signal, \"signal\");\n      if (!isNodeStream(stream)) {\n        throw new ERR_INVALID_ARG_TYPE(\"stream\", \"stream.Stream\", stream);\n      }\n      return module.exports.addAbortSignalNoValidate(signal, stream);\n    };\n    module.exports.addAbortSignalNoValidate = function (signal, stream) {\n      if (typeof signal !== \"object\" || !(\"aborted\" in signal)) {\n        return stream;\n      }\n      const onAbort = () => {\n        stream.destroy(\n          new AbortError(void 0, {\n            cause: signal.reason,\n          }),\n        );\n      };\n      if (signal.aborted) {\n        onAbort();\n      } else {\n        signal.addEventListener(\"abort\", onAbort);\n        eos(stream, () => signal.removeEventListener(\"abort\", onAbort));\n      }\n      return stream;\n    };\n  },\n});\n\n// node_modules/readable-stream/lib/internal/streams/state.js\nvar require_state = __commonJS({\n  \"node_modules/readable-stream/lib/internal/streams/state.js\"(exports, module) {\n    \"use strict\";\n    var { MathFloor, NumberIsInteger } = require_primordials();\n    var { ERR_INVALID_ARG_VALUE } = require_errors().codes;\n    function highWaterMarkFrom(options, isDuplex, duplexKey) {\n      return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;\n    }\n    function getDefaultHighWaterMark(objectMode) {\n      return objectMode ? 16 : 16 * 1024;\n    }\n    function getHighWaterMark(state, options, duplexKey, isDuplex) {\n      const hwm = highWaterMarkFrom(options, isDuplex, duplexKey);\n      if (hwm != null) {\n        if (!NumberIsInteger(hwm) || hwm < 0) {\n          const name = isDuplex ? `options.${duplexKey}` : \"options.highWaterMark\";\n          throw new ERR_INVALID_ARG_VALUE(name, hwm);\n        }\n        return MathFloor(hwm);\n      }\n      return getDefaultHighWaterMark(state.objectMode);\n    }\n    module.exports = {\n      getHighWaterMark,\n      getDefaultHighWaterMark,\n    };\n  },\n});\n\n// node_modules/readable-stream/lib/internal/streams/from.js\nvar require_from = __commonJS({\n  \"node_modules/readable-stream/lib/internal/streams/from.js\"(exports, module) {\n    \"use strict\";\n    var { PromisePrototypeThen, SymbolAsyncIterator, SymbolIterator } = require_primordials();\n    var { ERR_INVALID_ARG_TYPE, ERR_STREAM_NULL_VALUES } = require_errors().codes;\n    function from(Readable, iterable, opts) {\n      let iterator;\n      if (typeof iterable === \"string\" || iterable instanceof Buffer) {\n        return new Readable({\n          objectMode: true,\n          ...opts,\n          read() {\n            this.push(iterable);\n            this.push(null);\n          },\n        });\n      }\n      let isAsync;\n      if (iterable && iterable[SymbolAsyncIterator]) {\n        isAsync = true;\n        iterator = iterable[SymbolAsyncIterator]();\n      } else if (iterable && iterable[SymbolIterator]) {\n        isAsync = false;\n        iterator = iterable[SymbolIterator]();\n      } else {\n        throw new ERR_INVALID_ARG_TYPE(\"iterable\", [\"Iterable\"], iterable);\n      }\n      const readable = new Readable({\n        objectMode: true,\n        highWaterMark: 1,\n        ...opts,\n      });\n      let reading = false;\n      readable._read = function () {\n        if (!reading) {\n          reading = true;\n          next();\n        }\n      };\n      readable._destroy = function (error, cb) {\n        PromisePrototypeThen(\n          close(error),\n          () => runOnNextTick(cb, error),\n          e => runOnNextTick(cb, e || error),\n        );\n      };\n      async function close(error) {\n        const hadError = error !== void 0 && error !== null;\n        const hasThrow = typeof iterator.throw === \"function\";\n        if (hadError && hasThrow) {\n          const { value, done } = await iterator.throw(error);\n          await value;\n          if (done) {\n            return;\n          }\n        }\n        if (typeof iterator.return === \"function\") {\n          const { value } = await iterator.return();\n          await value;\n        }\n      }\n      async function next() {\n        for (;;) {\n          try {\n            const { value, done } = isAsync ? await iterator.next() : iterator.next();\n            if (done) {\n              readable.push(null);\n            } else {\n              const res = value && typeof value.then === \"function\" ? await value : value;\n              if (res === null) {\n                reading = false;\n                throw new ERR_STREAM_NULL_VALUES();\n              } else if (readable.push(res)) {\n                continue;\n              } else {\n                reading = false;\n              }\n            }\n          } catch (err) {\n            readable.destroy(err);\n          }\n          break;\n        }\n      }\n      return readable;\n    }\n    module.exports = from;\n  },\n});\n\nvar _ReadableFromWeb;\n\n// node_modules/readable-stream/lib/internal/streams/readable.js\nvar require_readable = __commonJS({\n  \"node_modules/readable-stream/lib/internal/streams/readable.js\"(exports, module) {\n    \"use strict\";\n    var {\n      ArrayPrototypeIndexOf,\n      NumberIsInteger,\n      NumberIsNaN,\n      NumberParseInt,\n      ObjectDefineProperties,\n      ObjectKeys,\n      ObjectSetPrototypeOf,\n      Promise: Promise2,\n      SafeSet,\n      SymbolAsyncIterator,\n      Symbol: Symbol2,\n    } = require_primordials();\n\n    var ReadableState = globalThis[Symbol.for(\"Bun.lazy\")](\"bun:stream\").ReadableState;\n    var { EventEmitter: EE } = __require(\"bun:events_native\");\n    var { Stream, prependListener } = require_legacy();\n\n    function Readable(options) {\n      if (!(this instanceof Readable)) return new Readable(options);\n      const isDuplex = this instanceof require_duplex();\n      this._readableState = new ReadableState(options, this, isDuplex);\n      if (options) {\n        const { read, destroy, construct, signal } = options;\n        if (typeof read === \"function\") this._read = read;\n        if (typeof destroy === \"function\") this._destroy = destroy;\n        if (typeof construct === \"function\") this._construct = construct;\n        if (signal && !isDuplex) addAbortSignal(signal, this);\n      }\n      Stream.call(this, options);\n\n      destroyImpl.construct(this, () => {\n        if (this._readableState.needReadable) {\n          maybeReadMore(this, this._readableState);\n        }\n      });\n    }\n    ObjectSetPrototypeOf(Readable.prototype, Stream.prototype);\n    ObjectSetPrototypeOf(Readable, Stream);\n\n    Readable.prototype.on = function (ev, fn) {\n      const res = Stream.prototype.on.call(this, ev, fn);\n      const state = this._readableState;\n      if (ev === \"data\") {\n        state.readableListening = this.listenerCount(\"readable\") > 0;\n        if (state.flowing !== false) {\n          __DEBUG__ && debug(\"in flowing mode!\", this.__id);\n          this.resume();\n        } else {\n          __DEBUG__ && debug(\"in readable mode!\", this.__id);\n        }\n      } else if (ev === \"readable\") {\n        __DEBUG__ && debug(\"readable listener added!\", this.__id);\n        if (!state.endEmitted && !state.readableListening) {\n          state.readableListening = state.needReadable = true;\n          state.flowing = false;\n          state.emittedReadable = false;\n          __DEBUG__ &&\n            debug(\n              \"on readable - state.length, reading, emittedReadable\",\n              state.length,\n              state.reading,\n              state.emittedReadable,\n              this.__id,\n            );\n          if (state.length) {\n            emitReadable(this, state);\n          } else if (!state.reading) {\n            runOnNextTick(nReadingNextTick, this);\n          }\n        } else if (state.endEmitted) {\n          __DEBUG__ && debug(\"end already emitted...\", this.__id);\n        }\n      }\n      return res;\n    };\n\n    class ReadableFromWeb extends Readable {\n      #reader;\n      #closed;\n      #pendingChunks;\n      #stream;\n\n      constructor(options, stream) {\n        const { objectMode, highWaterMark, encoding, signal } = options;\n        super({\n          objectMode,\n          highWaterMark,\n          encoding,\n          signal,\n        });\n        this.#pendingChunks = [];\n        this.#reader = undefined;\n        this.#stream = stream;\n        this.#closed = false;\n      }\n\n      #drainPending() {\n        var pendingChunks = this.#pendingChunks,\n          pendingChunksI = 0,\n          pendingChunksCount = pendingChunks.length;\n\n        for (; pendingChunksI < pendingChunksCount; pendingChunksI++) {\n          const chunk = pendingChunks[pendingChunksI];\n          pendingChunks[pendingChunksI] = undefined;\n          if (!this.push(chunk, undefined)) {\n            this.#pendingChunks = pendingChunks.slice(pendingChunksI + 1);\n            return true;\n          }\n        }\n\n        if (pendingChunksCount > 0) {\n          this.#pendingChunks = [];\n        }\n\n        return false;\n      }\n\n      #handleDone(reader) {\n        reader.releaseLock();\n        this.#reader = undefined;\n        this.#closed = true;\n        this.push(null);\n        return;\n      }\n\n      async _read() {\n        __DEBUG__ && debug(\"ReadableFromWeb _read()\", this.__id);\n        var stream = this.#stream,\n          reader = this.#reader;\n        if (stream) {\n          reader = this.#reader = stream.getReader();\n          this.#stream = undefined;\n        } else if (this.#drainPending()) {\n          return;\n        }\n\n        var deferredError;\n        try {\n          do {\n            var done = false,\n              value;\n            const firstResult = reader.readMany();\n\n            if (isPromise(firstResult)) {\n              ({ done, value } = await firstResult);\n\n              if (this.#closed) {\n                this.#pendingChunks.push(...value);\n                return;\n              }\n            } else {\n              ({ done, value } = firstResult);\n            }\n\n            if (done) {\n              this.#handleDone(reader);\n              return;\n            }\n\n            if (!this.push(value[0])) {\n              this.#pendingChunks = value.slice(1);\n              return;\n            }\n\n            for (let i = 1, count = value.length; i < count; i++) {\n              if (!this.push(value[i])) {\n                this.#pendingChunks = value.slice(i + 1);\n                return;\n              }\n            }\n          } while (!this.#closed);\n        } catch (e) {\n          deferredError = e;\n        } finally {\n          if (deferredError) throw deferredError;\n        }\n      }\n\n      _destroy(error, callback) {\n        if (!this.#closed) {\n          var reader = this.#reader;\n          if (reader) {\n            this.#reader = undefined;\n            reader.cancel(error).finally(() => {\n              this.#closed = true;\n              callback(error);\n            });\n          }\n\n          return;\n        }\n        try {\n          callback(error);\n        } catch (error) {\n          globalThis.reportError(error);\n        }\n      }\n    }\n\n    /**\n     * @param {ReadableStream} readableStream\n     * @param {{\n     *   highWaterMark? : number,\n     *   encoding? : string,\n     *   objectMode? : boolean,\n     *   signal? : AbortSignal,\n     * }} [options]\n     * @returns {Readable}\n     */\n    function newStreamReadableFromReadableStream(readableStream, options = {}) {\n      if (!isReadableStream(readableStream)) {\n        throw new ERR_INVALID_ARG_TYPE(\"readableStream\", \"ReadableStream\", readableStream);\n      }\n\n      validateObject(options, \"options\");\n      const {\n        highWaterMark,\n        encoding,\n        objectMode = false,\n        signal,\n        // native = true,\n      } = options;\n\n      if (encoding !== undefined && !Buffer.isEncoding(encoding))\n        throw new ERR_INVALID_ARG_VALUE(encoding, \"options.encoding\");\n      validateBoolean(objectMode, \"options.objectMode\");\n\n      // validateBoolean(native, \"options.native\");\n\n      // if (!native) {\n      //   return new ReadableFromWeb(\n      //     {\n      //       highWaterMark,\n      //       encoding,\n      //       objectMode,\n      //       signal,\n      //     },\n      //     readableStream,\n      //   );\n      // }\n\n      const nativeStream = getNativeReadableStream(Readable, readableStream, options);\n\n      return (\n        nativeStream ||\n        new ReadableFromWeb(\n          {\n            highWaterMark,\n            encoding,\n            objectMode,\n            signal,\n          },\n          readableStream,\n        )\n      );\n    }\n\n    module.exports = Readable;\n    _ReadableFromWeb = ReadableFromWeb;\n\n    var { addAbortSignal } = require_add_abort_signal();\n    var eos = require_end_of_stream();\n    const {\n      maybeReadMore: _maybeReadMore,\n      resume,\n      emitReadable: _emitReadable,\n      onEofChunk,\n    } = globalThis[Symbol.for(\"Bun.lazy\")](\"bun:stream\");\n    function maybeReadMore(stream, state) {\n      process.nextTick(_maybeReadMore, stream, state);\n    }\n    // REVERT ME\n    function emitReadable(stream, state) {\n      __DEBUG__ && debug(\"NativeReadable - emitReadable\", stream.__id);\n      _emitReadable(stream, state);\n    }\n    var destroyImpl = require_destroy();\n    var {\n      aggregateTwoErrors,\n      codes: {\n        ERR_INVALID_ARG_TYPE,\n        ERR_METHOD_NOT_IMPLEMENTED,\n        ERR_OUT_OF_RANGE,\n        ERR_STREAM_PUSH_AFTER_EOF,\n        ERR_STREAM_UNSHIFT_AFTER_END_EVENT,\n      },\n    } = require_errors();\n    var { validateObject } = require_validators();\n    var { StringDecoder } = __require(\"string_decoder\");\n    var from = require_from();\n    var nop = () => {};\n    var { errorOrDestroy } = destroyImpl;\n\n    Readable.prototype.destroy = destroyImpl.destroy;\n    Readable.prototype._undestroy = destroyImpl.undestroy;\n    Readable.prototype._destroy = function (err, cb) {\n      cb(err);\n    };\n    Readable.prototype[EE.captureRejectionSymbol] = function (err) {\n      this.destroy(err);\n    };\n    Readable.prototype.push = function (chunk, encoding) {\n      return readableAddChunk(this, chunk, encoding, false);\n    };\n    Readable.prototype.unshift = function (chunk, encoding) {\n      return readableAddChunk(this, chunk, encoding, true);\n    };\n    function readableAddChunk(stream, chunk, encoding, addToFront) {\n      __DEBUG__ && debug(\"readableAddChunk\", chunk, stream.__id);\n      const state = stream._readableState;\n      let err;\n      if (!state.objectMode) {\n        if (typeof chunk === \"string\") {\n          encoding = encoding || state.defaultEncoding;\n          if (state.encoding !== encoding) {\n            if (addToFront && state.encoding) {\n              chunk = Buffer.from(chunk, encoding).toString(state.encoding);\n            } else {\n              chunk = Buffer.from(chunk, encoding);\n              encoding = \"\";\n            }\n          }\n        } else if (chunk instanceof Buffer) {\n          encoding = \"\";\n        } else if (Stream._isUint8Array(chunk)) {\n          if (addToFront || !state.decoder) {\n            chunk = Stream._uint8ArrayToBuffer(chunk);\n          }\n          encoding = \"\";\n        } else if (chunk != null) {\n          err = new ERR_INVALID_ARG_TYPE(\"chunk\", [\"string\", \"Buffer\", \"Uint8Array\"], chunk);\n        }\n      }\n      if (err) {\n        errorOrDestroy(stream, err);\n      } else if (chunk === null) {\n        state.reading = false;\n        onEofChunk(stream, state);\n      } else if (state.objectMode || (chunk && chunk.length > 0)) {\n        if (addToFront) {\n          if (state.endEmitted) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());\n          else if (state.destroyed || state.errored) return false;\n          else addChunk(stream, state, chunk, true);\n        } else if (state.ended) {\n          errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());\n        } else if (state.destroyed || state.errored) {\n          return false;\n        } else {\n          state.reading = false;\n          if (state.decoder && !encoding) {\n            chunk = state.decoder.write(chunk);\n            if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);\n            else maybeReadMore(stream, state);\n          } else {\n            addChunk(stream, state, chunk, false);\n          }\n        }\n      } else if (!addToFront) {\n        state.reading = false;\n        maybeReadMore(stream, state);\n      }\n      return !state.ended && (state.length < state.highWaterMark || state.length === 0);\n    }\n    function addChunk(stream, state, chunk, addToFront) {\n      __DEBUG__ && debug(\"adding chunk\", stream.__id);\n      __DEBUG__ && debug(\"chunk\", chunk.toString(), stream.__id);\n      if (state.flowing && state.length === 0 && !state.sync && stream.listenerCount(\"data\") > 0) {\n        if (state.multiAwaitDrain) {\n          state.awaitDrainWriters.clear();\n        } else {\n          state.awaitDrainWriters = null;\n        }\n        state.dataEmitted = true;\n        stream.emit(\"data\", chunk);\n      } else {\n        state.length += state.objectMode ? 1 : chunk.length;\n        if (addToFront) state.buffer.unshift(chunk);\n        else state.buffer.push(chunk);\n        __DEBUG__ && debug(\"needReadable @ addChunk\", state.needReadable, stream.__id);\n        if (state.needReadable) emitReadable(stream, state);\n      }\n      maybeReadMore(stream, state);\n    }\n    Readable.prototype.isPaused = function () {\n      const state = this._readableState;\n      return state.paused === true || state.flowing === false;\n    };\n    Readable.prototype.setEncoding = function (enc) {\n      const decoder = new StringDecoder(enc);\n      this._readableState.decoder = decoder;\n      this._readableState.encoding = this._readableState.decoder.encoding;\n      const buffer = this._readableState.buffer;\n      let content = \"\";\n      // BufferList does not support iterator now, and iterator is slow in JSC.\n      // for (const data of buffer) {\n      //   content += decoder.write(data);\n      // }\n      // buffer.clear();\n      for (let i = buffer.length; i > 0; i--) {\n        content += decoder.write(buffer.shift());\n      }\n      if (content !== \"\") buffer.push(content);\n      this._readableState.length = content.length;\n      return this;\n    };\n    var MAX_HWM = 1073741824;\n    function computeNewHighWaterMark(n) {\n      if (n > MAX_HWM) {\n        throw new ERR_OUT_OF_RANGE(\"size\", \"<= 1GiB\", n);\n      } else {\n        n--;\n        n |= n >>> 1;\n        n |= n >>> 2;\n        n |= n >>> 4;\n        n |= n >>> 8;\n        n |= n >>> 16;\n        n++;\n      }\n      return n;\n    }\n    function howMuchToRead(n, state) {\n      if (n <= 0 || (state.length === 0 && state.ended)) return 0;\n      if (state.objectMode) return 1;\n      if (NumberIsNaN(n)) {\n        if (state.flowing && state.length) return state.buffer.first().length;\n        return state.length;\n      }\n      if (n <= state.length) return n;\n      return state.ended ? state.length : 0;\n    }\n    // You can override either this method, or the async _read(n) below.\n    Readable.prototype.read = function (n) {\n      __DEBUG__ && debug(\"read - n =\", n, this.__id);\n      if (!NumberIsInteger(n)) {\n        n = NumberParseInt(n, 10);\n      }\n      const state = this._readableState;\n      const nOrig = n;\n\n      // If we're asking for more than the current hwm, then raise the hwm.\n      if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);\n\n      if (n !== 0) state.emittedReadable = false;\n\n      // If we're doing read(0) to trigger a readable event, but we\n      // already have a bunch of data in the buffer, then just trigger\n      // the 'readable' event and move on.\n      if (\n        n === 0 &&\n        state.needReadable &&\n        ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)\n      ) {\n        __DEBUG__ && debug(\"read: emitReadable or endReadable\", state.length, state.ended, this.__id);\n        if (state.length === 0 && state.ended) endReadable(this);\n        else emitReadable(this, state);\n        return null;\n      }\n\n      n = howMuchToRead(n, state);\n\n      // If we've ended, and we're now clear, then finish it up.\n      if (n === 0 && state.ended) {\n        __DEBUG__ &&\n          debug(\"read: calling endReadable if length 0 -- length, state.ended\", state.length, state.ended, this.__id);\n        if (state.length === 0) endReadable(this);\n        return null;\n      }\n\n      // All the actual chunk generation logic needs to be\n      // *below* the call to _read.  The reason is that in certain\n      // synthetic stream cases, such as passthrough streams, _read\n      // may be a completely synchronous operation which may change\n      // the state of the read buffer, providing enough data when\n      // before there was *not* enough.\n      //\n      // So, the steps are:\n      // 1. Figure out what the state of things will be after we do\n      // a read from the buffer.\n      //\n      // 2. If that resulting state will trigger a _read, then call _read.\n      // Note that this may be asynchronous, or synchronous.  Yes, it is\n      // deeply ugly to write APIs this way, but that still doesn't mean\n      // that the Readable class should behave improperly, as streams are\n      // designed to be sync/async agnostic.\n      // Take note if the _read call is sync or async (ie, if the read call\n      // has returned yet), so that we know whether or not it's safe to emit\n      // 'readable' etc.\n      //\n      // 3. Actually pull the requested chunks out of the buffer and return.\n\n      // if we need a readable event, then we need to do some reading.\n      let doRead = state.needReadable;\n      __DEBUG__ && debug(\"need readable\", doRead, this.__id);\n\n      // If we currently have less than the highWaterMark, then also read some.\n      if (state.length === 0 || state.length - n < state.highWaterMark) {\n        doRead = true;\n        __DEBUG__ && debug(\"length less than watermark\", doRead, this.__id);\n      }\n\n      // However, if we've ended, then there's no point, if we're already\n      // reading, then it's unnecessary, if we're constructing we have to wait,\n      // and if we're destroyed or errored, then it's not allowed,\n      if (state.ended || state.reading || state.destroyed || state.errored || !state.constructed) {\n        __DEBUG__ && debug(\"state.constructed?\", state.constructed, this.__id);\n        doRead = false;\n        __DEBUG__ && debug(\"reading, ended or constructing\", doRead, this.__id);\n      } else if (doRead) {\n        __DEBUG__ && debug(\"do read\", this.__id);\n        state.reading = true;\n        state.sync = true;\n        // If the length is currently zero, then we *need* a readable event.\n        if (state.length === 0) state.needReadable = true;\n\n        // Call internal read method\n        try {\n          var result = this._read(state.highWaterMark);\n          if (isPromise(result)) {\n            __DEBUG__ && debug(\"async _read\", this.__id);\n            const peeked = Bun.peek(result);\n            __DEBUG__ && debug(\"peeked promise\", peeked, this.__id);\n            if (peeked !== result) {\n              result = peeked;\n            }\n          }\n\n          if (isPromise(result) && result?.then && isCallable(result.then)) {\n            __DEBUG__ && debug(\"async _read result.then setup\", this.__id);\n            result.then(nop, function (err) {\n              errorOrDestroy(this, err);\n            });\n          }\n        } catch (err) {\n          errorOrDestroy(this, err);\n        }\n\n        state.sync = false;\n        // If _read pushed data synchronously, then `reading` will be false,\n        // and we need to re-evaluate how much data we can return to the user.\n        if (!state.reading) n = howMuchToRead(nOrig, state);\n      }\n\n      __DEBUG__ && debug(\"n @ fromList\", n, this.__id);\n      let ret;\n      if (n > 0) ret = fromList(n, state);\n      else ret = null;\n\n      __DEBUG__ && debug(\"ret @ read\", ret, this.__id);\n\n      if (ret === null) {\n        state.needReadable = state.length <= state.highWaterMark;\n        __DEBUG__ && debug(\"state.length while ret = null\", state.length, this.__id);\n        n = 0;\n      } else {\n        state.length -= n;\n        if (state.multiAwaitDrain) {\n          state.awaitDrainWriters.clear();\n        } else {\n          state.awaitDrainWriters = null;\n        }\n      }\n\n      if (state.length === 0) {\n        // If we have nothing in the buffer, then we want to know\n        // as soon as we *do* get something into the buffer.\n        if (!state.ended) state.needReadable = true;\n\n        // If we tried to read() past the EOF, then emit end on the next tick.\n        if (nOrig !== n && state.ended) endReadable(this);\n      }\n\n      if (ret !== null && !state.errorEmitted && !state.closeEmitted) {\n        state.dataEmitted = true;\n        this.emit(\"data\", ret);\n      }\n\n      return ret;\n    };\n    Readable.prototype._read = function (n) {\n      throw new ERR_METHOD_NOT_IMPLEMENTED(\"_read()\");\n    };\n    Readable.prototype.pipe = function (dest, pipeOpts) {\n      const src = this;\n      const state = this._readableState;\n      if (state.pipes.length === 1) {\n        if (!state.multiAwaitDrain) {\n          state.multiAwaitDrain = true;\n          state.awaitDrainWriters = new SafeSet(state.awaitDrainWriters ? [state.awaitDrainWriters] : []);\n        }\n      }\n      state.pipes.push(dest);\n      __DEBUG__ && debug(\"pipe count=%d opts=%j\", state.pipes.length, pipeOpts, src.__id);\n      const doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;\n      const endFn = doEnd ? onend : unpipe;\n      if (state.endEmitted) runOnNextTick(endFn);\n      else src.once(\"end\", endFn);\n      dest.on(\"unpipe\", onunpipe);\n      function onunpipe(readable, unpipeInfo) {\n        __DEBUG__ && debug(\"onunpipe\", src.__id);\n        if (readable === src) {\n          if (unpipeInfo && unpipeInfo.hasUnpiped === false) {\n            unpipeInfo.hasUnpiped = true;\n            cleanup();\n          }\n        }\n      }\n      function onend() {\n        __DEBUG__ && debug(\"onend\", src.__id);\n        dest.end();\n      }\n      let ondrain;\n      let cleanedUp = false;\n      function cleanup() {\n        __DEBUG__ && debug(\"cleanup\", src.__id);\n        dest.removeListener(\"close\", onclose);\n        dest.removeListener(\"finish\", onfinish);\n        if (ondrain) {\n          dest.removeListener(\"drain\", ondrain);\n        }\n        dest.removeListener(\"error\", onerror);\n        dest.removeListener(\"unpipe\", onunpipe);\n        src.removeListener(\"end\", onend);\n        src.removeListener(\"end\", unpipe);\n        src.removeListener(\"data\", ondata);\n        cleanedUp = true;\n        if (ondrain && state.awaitDrainWriters && (!dest._writableState || dest._writableState.needDrain)) ondrain();\n      }\n      function pause() {\n        if (!cleanedUp) {\n          if (state.pipes.length === 1 && state.pipes[0] === dest) {\n            __DEBUG__ && debug(\"false write response, pause\", 0, src.__id);\n            state.awaitDrainWriters = dest;\n            state.multiAwaitDrain = false;\n          } else if (state.pipes.length > 1 && state.pipes.includes(dest)) {\n            __DEBUG__ && debug(\"false write response, pause\", state.awaitDrainWriters.size, src.__id);\n            state.awaitDrainWriters.add(dest);\n          }\n          src.pause();\n        }\n        if (!ondrain) {\n          ondrain = pipeOnDrain(src, dest);\n          dest.on(\"drain\", ondrain);\n        }\n      }\n      src.on(\"data\", ondata);\n      function ondata(chunk) {\n        __DEBUG__ && debug(\"ondata\", src.__id);\n        const ret = dest.write(chunk);\n        __DEBUG__ && debug(\"dest.write\", ret, src.__id);\n        if (ret === false) {\n          pause();\n        }\n      }\n      function onerror(er) {\n        debug(\"onerror\", er);\n        unpipe();\n        dest.removeListener(\"error\", onerror);\n        if (dest.listenerCount(\"error\") === 0) {\n          const s = dest._writableState || dest._readableState;\n          if (s && !s.errorEmitted) {\n            errorOrDestroy(dest, er);\n          } else {\n            dest.emit(\"error\", er);\n          }\n        }\n      }\n      prependListener(dest, \"error\", onerror);\n      function onclose() {\n        dest.removeListener(\"finish\", onfinish);\n        unpipe();\n      }\n      dest.once(\"close\", onclose);\n      function onfinish() {\n        debug(\"onfinish\");\n        dest.removeListener(\"close\", onclose);\n        unpipe();\n      }\n      dest.once(\"finish\", onfinish);\n      function unpipe() {\n        debug(\"unpipe\");\n        src.unpipe(dest);\n      }\n      dest.emit(\"pipe\", src);\n      if (dest.writableNeedDrain === true) {\n        if (state.flowing) {\n          pause();\n        }\n      } else if (!state.flowing) {\n        debug(\"pipe resume\");\n        src.resume();\n      }\n      return dest;\n    };\n    function pipeOnDrain(src, dest) {\n      return function pipeOnDrainFunctionResult() {\n        const state = src._readableState;\n        if (state.awaitDrainWriters === dest) {\n          debug(\"pipeOnDrain\", 1);\n          state.awaitDrainWriters = null;\n        } else if (state.multiAwaitDrain) {\n          debug(\"pipeOnDrain\", state.awaitDrainWriters.size);\n          state.awaitDrainWriters.delete(dest);\n        }\n        if ((!state.awaitDrainWriters || state.awaitDrainWriters.size === 0) && src.listenerCount(\"data\")) {\n          src.resume();\n        }\n      };\n    }\n    Readable.prototype.unpipe = function (dest) {\n      const state = this._readableState;\n      const unpipeInfo = {\n        hasUnpiped: false,\n      };\n      if (state.pipes.length === 0) return this;\n      if (!dest) {\n        const dests = state.pipes;\n        state.pipes = [];\n        this.pause();\n        for (let i = 0; i < dests.length; i++)\n          dests[i].emit(\"unpipe\", this, {\n            hasUnpiped: false,\n          });\n        return this;\n      }\n      const index = ArrayPrototypeIndexOf(state.pipes, dest);\n      if (index === -1) return this;\n      state.pipes.splice(index, 1);\n      if (state.pipes.length === 0) this.pause();\n      dest.emit(\"unpipe\", this, unpipeInfo);\n      return this;\n    };\n    Readable.prototype.addListener = Readable.prototype.on;\n    Readable.prototype.removeListener = function (ev, fn) {\n      const res = Stream.prototype.removeListener.call(this, ev, fn);\n      if (ev === \"readable\") {\n        runOnNextTick(updateReadableListening, this);\n      }\n      return res;\n    };\n    Readable.prototype.off = Readable.prototype.removeListener;\n    Readable.prototype.removeAllListeners = function (ev) {\n      const res = Stream.prototype.removeAllListeners.apply(this, arguments);\n      if (ev === \"readable\" || ev === void 0) {\n        runOnNextTick(updateReadableListening, this);\n      }\n      return res;\n    };\n    function updateReadableListening(self) {\n      const state = self._readableState;\n      state.readableListening = self.listenerCount(\"readable\") > 0;\n      if (state.resumeScheduled && state.paused === false) {\n        state.flowing = true;\n      } else if (self.listenerCount(\"data\") > 0) {\n        self.resume();\n      } else if (!state.readableListening) {\n        state.flowing = null;\n      }\n    }\n    function nReadingNextTick(self) {\n      __DEBUG__ && debug(\"on readable nextTick, calling read(0)\", self.__id);\n      self.read(0);\n    }\n    Readable.prototype.resume = function () {\n      const state = this._readableState;\n      if (!state.flowing) {\n        __DEBUG__ && debug(\"resume\", this.__id);\n        state.flowing = !state.readableListening;\n        resume(this, state);\n      }\n      state.paused = false;\n      return this;\n    };\n    Readable.prototype.pause = function () {\n      __DEBUG__ && debug(\"call pause flowing=%j\", this._readableState.flowing, this.__id);\n      if (this._readableState.flowing !== false) {\n        __DEBUG__ && debug(\"pause\", this.__id);\n        this._readableState.flowing = false;\n        this.emit(\"pause\");\n      }\n      this._readableState.paused = true;\n      return this;\n    };\n    Readable.prototype.wrap = function (stream) {\n      let paused = false;\n      stream.on(\"data\", chunk => {\n        if (!this.push(chunk) && stream.pause) {\n          paused = true;\n          stream.pause();\n        }\n      });\n      stream.on(\"end\", () => {\n        this.push(null);\n      });\n      stream.on(\"error\", err => {\n        errorOrDestroy(this, err);\n      });\n      stream.on(\"close\", () => {\n        this.destroy();\n      });\n      stream.on(\"destroy\", () => {\n        this.destroy();\n      });\n      this._read = () => {\n        if (paused && stream.resume) {\n          paused = false;\n          stream.resume();\n        }\n      };\n      const streamKeys = ObjectKeys(stream);\n      for (let j = 1; j < streamKeys.length; j++) {\n        const i = streamKeys[j];\n        if (this[i] === void 0 && typeof stream[i] === \"function\") {\n          this[i] = stream[i].bind(stream);\n        }\n      }\n      return this;\n    };\n    Readable.prototype[SymbolAsyncIterator] = function () {\n      return streamToAsyncIterator(this);\n    };\n    Readable.prototype.iterator = function (options) {\n      if (options !== void 0) {\n        validateObject(options, \"options\");\n      }\n      return streamToAsyncIterator(this, options);\n    };\n    function streamToAsyncIterator(stream, options) {\n      if (typeof stream.read !== \"function\") {\n        stream = Readable.wrap(stream, {\n          objectMode: true,\n        });\n      }\n      const iter = createAsyncIterator(stream, options);\n      iter.stream = stream;\n      return iter;\n    }\n    async function* createAsyncIterator(stream, options) {\n      let callback = nop;\n      function next(resolve) {\n        if (this === stream) {\n          callback();\n          callback = nop;\n        } else {\n          callback = resolve;\n        }\n      }\n      stream.on(\"readable\", next);\n      let error;\n      const cleanup = eos(\n        stream,\n        {\n          writable: false,\n        },\n        err => {\n          error = err ? aggregateTwoErrors(error, err) : null;\n          callback();\n          callback = nop;\n        },\n      );\n      try {\n        while (true) {\n          const chunk = stream.destroyed ? null : stream.read();\n          if (chunk !== null) {\n            yield chunk;\n          } else if (error) {\n            throw error;\n          } else if (error === null) {\n            return;\n          } else {\n            await new Promise2(next);\n          }\n        }\n      } catch (err) {\n        error = aggregateTwoErrors(error, err);\n        throw error;\n      } finally {\n        if (\n          (error || (options === null || options === void 0 ? void 0 : options.destroyOnReturn) !== false) &&\n          (error === void 0 || stream._readableState.autoDestroy)\n        ) {\n          destroyImpl.destroyer(stream, null);\n        } else {\n          stream.off(\"readable\", next);\n          cleanup();\n        }\n      }\n    }\n    ObjectDefineProperties(Readable.prototype, {\n      readable: {\n        get() {\n          const r = this._readableState;\n          return !!r && r.readable !== false && !r.destroyed && !r.errorEmitted && !r.endEmitted;\n        },\n        set(val) {\n          if (this._readableState) {\n            this._readableState.readable = !!val;\n          }\n        },\n      },\n      readableDidRead: {\n        enumerable: false,\n        get: function () {\n          return this._readableState.dataEmitted;\n        },\n      },\n      readableAborted: {\n        enumerable: false,\n        get: function () {\n          return !!(\n            this._readableState.readable !== false &&\n            (this._readableState.destroyed || this._readableState.errored) &&\n            !this._readableState.endEmitted\n          );\n        },\n      },\n      readableHighWaterMark: {\n        enumerable: false,\n        get: function () {\n          return this._readableState.highWaterMark;\n        },\n      },\n      readableBuffer: {\n        enumerable: false,\n        get: function () {\n          return this._readableState && this._readableState.buffer;\n        },\n      },\n      readableFlowing: {\n        enumerable: false,\n        get: function () {\n          return this._readableState.flowing;\n        },\n        set: function (state) {\n          if (this._readableState) {\n            this._readableState.flowing = state;\n          }\n        },\n      },\n      readableLength: {\n        enumerable: false,\n        get() {\n          return this._readableState.length;\n        },\n      },\n      readableObjectMode: {\n        enumerable: false,\n        get() {\n          return this._readableState ? this._readableState.objectMode : false;\n        },\n      },\n      readableEncoding: {\n        enumerable: false,\n        get() {\n          return this._readableState ? this._readableState.encoding : null;\n        },\n      },\n      errored: {\n        enumerable: false,\n        get() {\n          return this._readableState ? this._readableState.errored : null;\n        },\n      },\n      closed: {\n        get() {\n          return this._readableState ? this._readableState.closed : false;\n        },\n      },\n      destroyed: {\n        enumerable: false,\n        get() {\n          return this._readableState ? this._readableState.destroyed : false;\n        },\n        set(value) {\n          if (!this._readableState) {\n            return;\n          }\n          this._readableState.destroyed = value;\n        },\n      },\n      readableEnded: {\n        enumerable: false,\n        get() {\n          return this._readableState ? this._readableState.endEmitted : false;\n        },\n      },\n    });\n    Readable._fromList = fromList;\n    function fromList(n, state) {\n      if (state.length === 0) return null;\n      let ret;\n      if (state.objectMode) ret = state.buffer.shift();\n      else if (!n || n >= state.length) {\n        if (state.decoder) ret = state.buffer.join(\"\");\n        else if (state.buffer.length === 1) ret = state.buffer.first();\n        else ret = state.buffer.concat(state.length);\n        state.buffer.clear();\n      } else {\n        ret = state.buffer.consume(n, state.decoder);\n      }\n      return ret;\n    }\n    function endReadable(stream) {\n      const state = stream._readableState;\n      __DEBUG__ && debug(\"endEmitted @ endReadable\", state.endEmitted, stream.__id);\n      if (!state.endEmitted) {\n        state.ended = true;\n        runOnNextTick(endReadableNT, state, stream);\n      }\n    }\n    function endReadableNT(state, stream) {\n      __DEBUG__ && debug(\"endReadableNT -- endEmitted, state.length\", state.endEmitted, state.length, stream.__id);\n      if (!state.errored && !state.closeEmitted && !state.endEmitted && state.length === 0) {\n        state.endEmitted = true;\n        stream.emit(\"end\");\n        __DEBUG__ && debug(\"end emitted @ endReadableNT\", stream.__id);\n        if (stream.writable && stream.allowHalfOpen === false) {\n          runOnNextTick(endWritableNT, stream);\n        } else if (state.autoDestroy) {\n          const wState = stream._writableState;\n          const autoDestroy = !wState || (wState.autoDestroy && (wState.finished || wState.writable === false));\n          if (autoDestroy) {\n            stream.destroy();\n          }\n        }\n      }\n    }\n    function endWritableNT(stream) {\n      const writable = stream.writable && !stream.writableEnded && !stream.destroyed;\n      if (writable) {\n        stream.end();\n      }\n    }\n    Readable.from = function (iterable, opts) {\n      return from(Readable, iterable, opts);\n    };\n    var webStreamsAdapters = {\n      newStreamReadableFromReadableStream,\n    };\n    function lazyWebStreams() {\n      if (webStreamsAdapters === void 0) webStreamsAdapters = {};\n      return webStreamsAdapters;\n    }\n    Readable.fromWeb = function (readableStream, options) {\n      return lazyWebStreams().newStreamReadableFromReadableStream(readableStream, options);\n    };\n    Readable.toWeb = function (streamReadable) {\n      return lazyWebStreams().newReadableStreamFromStreamReadable(streamReadable);\n    };\n    Readable.wrap = function (src, options) {\n      var _ref, _src$readableObjectMo;\n      return new Readable({\n        objectMode:\n          (_ref =\n            (_src$readableObjectMo = src.readableObjectMode) !== null && _src$readableObjectMo !== void 0\n              ? _src$readableObjectMo\n              : src.objectMode) !== null && _ref !== void 0\n            ? _ref\n            : true,\n        ...options,\n        destroy(err, callback) {\n          destroyImpl.destroyer(src, err);\n          callback(err);\n        },\n      }).wrap(src);\n    };\n  },\n});\n\n// node_modules/readable-stream/lib/internal/streams/writable.js\nvar require_writable = __commonJS({\n  \"node_modules/readable-stream/lib/internal/streams/writable.js\"(exports, module) {\n    \"use strict\";\n    var {\n      ArrayPrototypeSlice,\n      Error: Error2,\n      FunctionPrototypeSymbolHasInstance,\n      ObjectDefineProperty,\n      ObjectDefineProperties,\n      ObjectSetPrototypeOf,\n      StringPrototypeToLowerCase,\n      Symbol: Symbol2,\n      SymbolHasInstance,\n    } = require_primordials();\n\n    var { EventEmitter: EE } = __require(\"bun:events_native\");\n    var Stream = require_legacy().Stream;\n    var destroyImpl = require_destroy();\n    var { addAbortSignal } = require_add_abort_signal();\n    var { getHighWaterMark, getDefaultHighWaterMark } = require_state();\n    var {\n      ERR_INVALID_ARG_TYPE,\n      ERR_METHOD_NOT_IMPLEMENTED,\n      ERR_MULTIPLE_CALLBACK,\n      ERR_STREAM_CANNOT_PIPE,\n      ERR_STREAM_DESTROYED,\n      ERR_STREAM_ALREADY_FINISHED,\n      ERR_STREAM_NULL_VALUES,\n      ERR_STREAM_WRITE_AFTER_END,\n      ERR_UNKNOWN_ENCODING,\n    } = require_errors().codes;\n    var { errorOrDestroy } = destroyImpl;\n\n    function Writable(options = {}) {\n      const isDuplex = this instanceof require_duplex();\n      if (!isDuplex && !FunctionPrototypeSymbolHasInstance(Writable, this)) return new Writable(options);\n      this._writableState = new WritableState(options, this, isDuplex);\n      if (options) {\n        if (typeof options.write === \"function\") this._write = options.write;\n        if (typeof options.writev === \"function\") this._writev = options.writev;\n        if (typeof options.destroy === \"function\") this._destroy = options.destroy;\n        if (typeof options.final === \"function\") this._final = options.final;\n        if (typeof options.construct === \"function\") this._construct = options.construct;\n        if (options.signal) addAbortSignal(options.signal, this);\n      }\n      Stream.call(this, options);\n\n      destroyImpl.construct(this, () => {\n        const state = this._writableState;\n        if (!state.writing) {\n          clearBuffer(this, state);\n        }\n        finishMaybe(this, state);\n      });\n    }\n    ObjectSetPrototypeOf(Writable.prototype, Stream.prototype);\n    ObjectSetPrototypeOf(Writable, Stream);\n    module.exports = Writable;\n\n    function nop() {}\n    var kOnFinished = Symbol2(\"kOnFinished\");\n    function WritableState(options, stream, isDuplex) {\n      if (typeof isDuplex !== \"boolean\") isDuplex = stream instanceof require_duplex();\n      this.objectMode = !!(options && options.objectMode);\n      if (isDuplex) this.objectMode = this.objectMode || !!(options && options.writableObjectMode);\n      this.highWaterMark = options\n        ? getHighWaterMark(this, options, \"writableHighWaterMark\", isDuplex)\n        : getDefaultHighWaterMark(false);\n      this.finalCalled = false;\n      this.needDrain = false;\n      this.ending = false;\n      this.ended = false;\n      this.finished = false;\n      this.destroyed = false;\n      const noDecode = !!(options && options.decodeStrings === false);\n      this.decodeStrings = !noDecode;\n      this.defaultEncoding = (options && options.defaultEncoding) || \"utf8\";\n      this.length = 0;\n      this.writing = false;\n      this.corked = 0;\n      this.sync = true;\n      this.bufferProcessing = false;\n      this.onwrite = onwrite.bind(void 0, stream);\n      this.writecb = null;\n      this.writelen = 0;\n      this.afterWriteTickInfo = null;\n      resetBuffer(this);\n      this.pendingcb = 0;\n      this.constructed = true;\n      this.prefinished = false;\n      this.errorEmitted = false;\n      this.emitClose = !options || options.emitClose !== false;\n      this.autoDestroy = !options || options.autoDestroy !== false;\n      this.errored = null;\n      this.closed = false;\n      this.closeEmitted = false;\n      this[kOnFinished] = [];\n    }\n    function resetBuffer(state) {\n      state.buffered = [];\n      state.bufferedIndex = 0;\n      state.allBuffers = true;\n      state.allNoop = true;\n    }\n    WritableState.prototype.getBuffer = function getBuffer() {\n      return ArrayPrototypeSlice(this.buffered, this.bufferedIndex);\n    };\n    ObjectDefineProperty(WritableState.prototype, \"bufferedRequestCount\", {\n      get() {\n        return this.buffered.length - this.bufferedIndex;\n      },\n    });\n\n    ObjectDefineProperty(Writable, SymbolHasInstance, {\n      value: function (object) {\n        if (FunctionPrototypeSymbolHasInstance(this, object)) return true;\n        if (this !== Writable) return false;\n        return object && object._writableState instanceof WritableState;\n      },\n    });\n    Writable.prototype.pipe = function () {\n      errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());\n    };\n    function _write(stream, chunk, encoding, cb) {\n      const state = stream._writableState;\n      if (typeof encoding === \"function\") {\n        cb = encoding;\n        encoding = state.defaultEncoding;\n      } else {\n        if (!encoding) encoding = state.defaultEncoding;\n        else if (encoding !== \"buffer\" && !Buffer.isEncoding(encoding)) throw new ERR_UNKNOWN_ENCODING(encoding);\n        if (typeof cb !== \"function\") cb = nop;\n      }\n      if (chunk === null) {\n        throw new ERR_STREAM_NULL_VALUES();\n      } else if (!state.objectMode) {\n        if (typeof chunk === \"string\") {\n          if (state.decodeStrings !== false) {\n            chunk = Buffer.from(chunk, encoding);\n            encoding = \"buffer\";\n          }\n        } else if (chunk instanceof Buffer) {\n          encoding = \"buffer\";\n        } else if (Stream._isUint8Array(chunk)) {\n          chunk = Stream._uint8ArrayToBuffer(chunk);\n          encoding = \"buffer\";\n        } else {\n          throw new ERR_INVALID_ARG_TYPE(\"chunk\", [\"string\", \"Buffer\", \"Uint8Array\"], chunk);\n        }\n      }\n      let err;\n      if (state.ending) {\n        err = new ERR_STREAM_WRITE_AFTER_END();\n      } else if (state.destroyed) {\n        err = new ERR_STREAM_DESTROYED(\"write\");\n      }\n      if (err) {\n        runOnNextTick(cb, err);\n        errorOrDestroy(stream, err, true);\n        return err;\n      }\n      state.pendingcb++;\n      return writeOrBuffer(stream, state, chunk, encoding, cb);\n    }\n    Writable.prototype.write = function (chunk, encoding, cb) {\n      return _write(this, chunk, encoding, cb) === true;\n    };\n    Writable.prototype.cork = function () {\n      this._writableState.corked++;\n    };\n    Writable.prototype.uncork = function () {\n      const state = this._writableState;\n      if (state.corked) {\n        state.corked--;\n        if (!state.writing) clearBuffer(this, state);\n      }\n    };\n    Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {\n      if (typeof encoding === \"string\") encoding = StringPrototypeToLowerCase(encoding);\n      if (!Buffer.isEncoding(encoding)) throw new ERR_UNKNOWN_ENCODING(encoding);\n      this._writableState.defaultEncoding = encoding;\n      return this;\n    };\n    function writeOrBuffer(stream, state, chunk, encoding, callback) {\n      const len = state.objectMode ? 1 : chunk.length;\n      state.length += len;\n      const ret = state.length < state.highWaterMark;\n      if (!ret) state.needDrain = true;\n      if (state.writing || state.corked || state.errored || !state.constructed) {\n        state.buffered.push({\n          chunk,\n          encoding,\n          callback,\n        });\n        if (state.allBuffers && encoding !== \"buffer\") {\n          state.allBuffers = false;\n        }\n        if (state.allNoop && callback !== nop) {\n          state.allNoop = false;\n        }\n      } else {\n        state.writelen = len;\n        state.writecb = callback;\n        state.writing = true;\n        state.sync = true;\n        stream._write(chunk, encoding, state.onwrite);\n        state.sync = false;\n      }\n      return ret && !state.errored && !state.destroyed;\n    }\n    function doWrite(stream, state, writev, len, chunk, encoding, cb) {\n      state.writelen = len;\n      state.writecb = cb;\n      state.writing = true;\n      state.sync = true;\n      if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED(\"write\"));\n      else if (writev) stream._writev(chunk, state.onwrite);\n      else stream._write(chunk, encoding, state.onwrite);\n      state.sync = false;\n    }\n    function onwriteError(stream, state, er, cb) {\n      --state.pendingcb;\n      cb(er);\n      errorBuffer(state);\n      errorOrDestroy(stream, er);\n    }\n    function onwrite(stream, er) {\n      const state = stream._writableState;\n      const sync = state.sync;\n      const cb = state.writecb;\n      if (typeof cb !== \"function\") {\n        errorOrDestroy(stream, new ERR_MULTIPLE_CALLBACK());\n        return;\n      }\n      state.writing = false;\n      state.writecb = null;\n      state.length -= state.writelen;\n      state.writelen = 0;\n      if (er) {\n        Error.captureStackTrace(er);\n        if (!state.errored) {\n          state.errored = er;\n        }\n        if (stream._readableState && !stream._readableState.errored) {\n          stream._readableState.errored = er;\n        }\n        if (sync) {\n          runOnNextTick(onwriteError, stream, state, er, cb);\n        } else {\n          onwriteError(stream, state, er, cb);\n        }\n      } else {\n        if (state.buffered.length > state.bufferedIndex) {\n          clearBuffer(stream, state);\n        }\n        if (sync) {\n          if (state.afterWriteTickInfo !== null && state.afterWriteTickInfo.cb === cb) {\n            state.afterWriteTickInfo.count++;\n          } else {\n            state.afterWriteTickInfo = {\n              count: 1,\n              cb,\n              stream,\n              state,\n            };\n            runOnNextTick(afterWriteTick, state.afterWriteTickInfo);\n          }\n        } else {\n          afterWrite(stream, state, 1, cb);\n        }\n      }\n    }\n    function afterWriteTick({ stream, state, count, cb }) {\n      state.afterWriteTickInfo = null;\n      return afterWrite(stream, state, count, cb);\n    }\n    function afterWrite(stream, state, count, cb) {\n      const needDrain = !state.ending && !stream.destroyed && state.length === 0 && state.needDrain;\n      if (needDrain) {\n        state.needDrain = false;\n        stream.emit(\"drain\");\n      }\n      while (count-- > 0) {\n        state.pendingcb--;\n        cb();\n      }\n      if (state.destroyed) {\n        errorBuffer(state);\n      }\n      finishMaybe(stream, state);\n    }\n    function errorBuffer(state) {\n      if (state.writing) {\n        return;\n      }\n      for (let n = state.bufferedIndex; n < state.buffered.length; ++n) {\n        var _state$errored;\n        const { chunk, callback } = state.buffered[n];\n        const len = state.objectMode ? 1 : chunk.length;\n        state.length -= len;\n        callback(\n          (_state$errored = state.errored) !== null && _state$errored !== void 0\n            ? _state$errored\n            : new ERR_STREAM_DESTROYED(\"write\"),\n        );\n      }\n      const onfinishCallbacks = state[kOnFinished].splice(0);\n      for (let i = 0; i < onfinishCallbacks.length; i++) {\n        var _state$errored2;\n        onfinishCallbacks[i](\n          (_state$errored2 = state.errored) !== null && _state$errored2 !== void 0\n            ? _state$errored2\n            : new ERR_STREAM_DESTROYED(\"end\"),\n        );\n      }\n      resetBuffer(state);\n    }\n    function clearBuffer(stream, state) {\n      if (state.corked || state.bufferProcessing || state.destroyed || !state.constructed) {\n        return;\n      }\n      const { buffered, bufferedIndex, objectMode } = state;\n      const bufferedLength = buffered.length - bufferedIndex;\n      if (!bufferedLength) {\n        return;\n      }\n      let i = bufferedIndex;\n      state.bufferProcessing = true;\n      if (bufferedLength > 1 && stream._writev) {\n        state.pendingcb -= bufferedLength - 1;\n        const callback = state.allNoop\n          ? nop\n          : err => {\n              for (let n = i; n < buffered.length; ++n) {\n                buffered[n].callback(err);\n              }\n            };\n        const chunks = state.allNoop && i === 0 ? buffered : ArrayPrototypeSlice(buffered, i);\n        chunks.allBuffers = state.allBuffers;\n        doWrite(stream, state, true, state.length, chunks, \"\", callback);\n        resetBuffer(state);\n      } else {\n        do {\n          const { chunk, encoding, callback } = buffered[i];\n          buffered[i++] = null;\n          const len = objectMode ? 1 : chunk.length;\n          doWrite(stream, state, false, len, chunk, encoding, callback);\n        } while (i < buffered.length && !state.writing);\n        if (i === buffered.length) {\n          resetBuffer(state);\n        } else if (i > 256) {\n          buffered.splice(0, i);\n          state.bufferedIndex = 0;\n        } else {\n          state.bufferedIndex = i;\n        }\n      }\n      state.bufferProcessing = false;\n    }\n    Writable.prototype._write = function (chunk, encoding, cb) {\n      if (this._writev) {\n        this._writev(\n          [\n            {\n              chunk,\n              encoding,\n            },\n          ],\n          cb,\n        );\n      } else {\n        throw new ERR_METHOD_NOT_IMPLEMENTED(\"_write()\");\n      }\n    };\n    Writable.prototype._writev = null;\n    Writable.prototype.end = function (chunk, encoding, cb, native = false) {\n      const state = this._writableState;\n      __DEBUG__ && debug(\"end\", state, this.__id);\n      if (typeof chunk === \"function\") {\n        cb = chunk;\n        chunk = null;\n        encoding = null;\n      } else if (typeof encoding === \"function\") {\n        cb = encoding;\n        encoding = null;\n      }\n      let err;\n      if (chunk !== null && chunk !== void 0) {\n        let ret;\n        if (!native) {\n          ret = _write(this, chunk, encoding);\n        } else {\n          ret = this.write(chunk, encoding);\n        }\n        if (ret instanceof Error2) {\n          err = ret;\n        }\n      }\n      if (state.corked) {\n        state.corked = 1;\n        this.uncork();\n      }\n      if (err) {\n        this.emit(\"error\", err);\n      } else if (!state.errored && !state.ending) {\n        state.ending = true;\n        finishMaybe(this, state, true);\n        state.ended = true;\n      } else if (state.finished) {\n        err = new ERR_STREAM_ALREADY_FINISHED(\"end\");\n      } else if (state.destroyed) {\n        err = new ERR_STREAM_DESTROYED(\"end\");\n      }\n      if (typeof cb === \"function\") {\n        if (err || state.finished) {\n          runOnNextTick(cb, err);\n        } else {\n          state[kOnFinished].push(cb);\n        }\n      }\n      return this;\n    };\n    function needFinish(state, tag) {\n      var needFinish =\n        state.ending &&\n        !state.destroyed &&\n        state.constructed &&\n        state.length === 0 &&\n        !state.errored &&\n        state.buffered.length === 0 &&\n        !state.finished &&\n        !state.writing &&\n        !state.errorEmitted &&\n        !state.closeEmitted;\n      debug(\"needFinish\", needFinish, tag);\n      return needFinish;\n    }\n    function callFinal(stream, state) {\n      let called = false;\n      function onFinish(err) {\n        if (called) {\n          errorOrDestroy(stream, err !== null && err !== void 0 ? err : ERR_MULTIPLE_CALLBACK());\n          return;\n        }\n        called = true;\n        state.pendingcb--;\n        if (err) {\n          const onfinishCallbacks = state[kOnFinished].splice(0);\n          for (let i = 0; i < onfinishCallbacks.length; i++) {\n            onfinishCallbacks[i](err);\n          }\n          errorOrDestroy(stream, err, state.sync);\n        } else if (needFinish(state)) {\n          state.prefinished = true;\n          stream.emit(\"prefinish\");\n          state.pendingcb++;\n          runOnNextTick(finish, stream, state);\n        }\n      }\n      state.sync = true;\n      state.pendingcb++;\n      try {\n        stream._final(onFinish);\n      } catch (err) {\n        onFinish(err);\n      }\n      state.sync = false;\n    }\n    function prefinish(stream, state) {\n      if (!state.prefinished && !state.finalCalled) {\n        if (typeof stream._final === \"function\" && !state.destroyed) {\n          state.finalCalled = true;\n          callFinal(stream, state);\n        } else {\n          state.prefinished = true;\n          stream.emit(\"prefinish\");\n        }\n      }\n    }\n    function finishMaybe(stream, state, sync) {\n      __DEBUG__ && debug(\"finishMaybe -- state, sync\", state, sync, stream.__id);\n\n      if (!needFinish(state, stream.__id)) return;\n\n      prefinish(stream, state);\n      if (state.pendingcb === 0) {\n        if (sync) {\n          state.pendingcb++;\n          runOnNextTick(\n            (stream2, state2) => {\n              if (needFinish(state2)) {\n                finish(stream2, state2);\n              } else {\n                state2.pendingcb--;\n              }\n            },\n            stream,\n            state,\n          );\n        } else if (needFinish(state)) {\n          state.pendingcb++;\n          finish(stream, state);\n        }\n      }\n    }\n    function finish(stream, state) {\n      state.pendingcb--;\n      state.finished = true;\n      const onfinishCallbacks = state[kOnFinished].splice(0);\n      for (let i = 0; i < onfinishCallbacks.length; i++) {\n        onfinishCallbacks[i]();\n      }\n      stream.emit(\"finish\");\n      if (state.autoDestroy) {\n        const rState = stream._readableState;\n        const autoDestroy = !rState || (rState.autoDestroy && (rState.endEmitted || rState.readable === false));\n        if (autoDestroy) {\n          stream.destroy();\n        }\n      }\n    }\n    ObjectDefineProperties(Writable.prototype, {\n      closed: {\n        get() {\n          return this._writableState ? this._writableState.closed : false;\n        },\n      },\n      destroyed: {\n        get() {\n          return this._writableState ? this._writableState.destroyed : false;\n        },\n        set(value) {\n          if (this._writableState) {\n            this._writableState.destroyed = value;\n          }\n        },\n      },\n      writable: {\n        get() {\n          const w = this._writableState;\n          return !!w && w.writable !== false && !w.destroyed && !w.errored && !w.ending && !w.ended;\n        },\n        set(val) {\n          if (this._writableState) {\n            this._writableState.writable = !!val;\n          }\n        },\n      },\n      writableFinished: {\n        get() {\n          return this._writableState ? this._writableState.finished : false;\n        },\n      },\n      writableObjectMode: {\n        get() {\n          return this._writableState ? this._writableState.objectMode : false;\n        },\n      },\n      writableBuffer: {\n        get() {\n          return this._writableState && this._writableState.getBuffer();\n        },\n      },\n      writableEnded: {\n        get() {\n          return this._writableState ? this._writableState.ending : false;\n        },\n      },\n      writableNeedDrain: {\n        get() {\n          const wState = this._writableState;\n          if (!wState) return false;\n          return !wState.destroyed && !wState.ending && wState.needDrain;\n        },\n      },\n      writableHighWaterMark: {\n        get() {\n          return this._writableState && this._writableState.highWaterMark;\n        },\n      },\n      writableCorked: {\n        get() {\n          return this._writableState ? this._writableState.corked : 0;\n        },\n      },\n      writableLength: {\n        get() {\n          return this._writableState && this._writableState.length;\n        },\n      },\n      errored: {\n        enumerable: false,\n        get() {\n          return this._writableState ? this._writableState.errored : null;\n        },\n      },\n      writableAborted: {\n        enumerable: false,\n        get: function () {\n          return !!(\n            this._writableState.writable !== false &&\n            (this._writableState.destroyed || this._writableState.errored) &&\n            !this._writableState.finished\n          );\n        },\n      },\n    });\n    var destroy = destroyImpl.destroy;\n    Writable.prototype.destroy = function (err, cb) {\n      const state = this._writableState;\n      if (!state.destroyed && (state.bufferedIndex < state.buffered.length || state[kOnFinished].length)) {\n        runOnNextTick(errorBuffer, state);\n      }\n      destroy.call(this, err, cb);\n      return this;\n    };\n    Writable.prototype._undestroy = destroyImpl.undestroy;\n    Writable.prototype._destroy = function (err, cb) {\n      cb(err);\n    };\n    Writable.prototype[EE.captureRejectionSymbol] = function (err) {\n      this.destroy(err);\n    };\n    var webStreamsAdapters;\n    function lazyWebStreams() {\n      if (webStreamsAdapters === void 0) webStreamsAdapters = {};\n      return webStreamsAdapters;\n    }\n    Writable.fromWeb = function (writableStream, options) {\n      return lazyWebStreams().newStreamWritableFromWritableStream(writableStream, options);\n    };\n    Writable.toWeb = function (streamWritable) {\n      return lazyWebStreams().newWritableStreamFromStreamWritable(streamWritable);\n    };\n  },\n});\n\n// node_modules/readable-stream/lib/internal/streams/duplexify.js\nvar require_duplexify = __commonJS({\n  \"node_modules/readable-stream/lib/internal/streams/duplexify.js\"(exports, module) {\n    \"use strict\";\n    var bufferModule = __require(\"buffer\");\n    var {\n      isReadable,\n      isWritable,\n      isIterable,\n      isNodeStream,\n      isReadableNodeStream,\n      isWritableNodeStream,\n      isDuplexNodeStream,\n    } = require_utils();\n    var eos = require_end_of_stream();\n    var {\n      AbortError,\n      codes: { ERR_INVALID_ARG_TYPE, ERR_INVALID_RETURN_VALUE },\n    } = require_errors();\n    var { destroyer } = require_destroy();\n    var Duplex = require_duplex();\n    var Readable = require_readable();\n    var { createDeferredPromise } = require_util();\n    var from = require_from();\n    var Blob = globalThis.Blob || bufferModule.Blob;\n    var isBlob =\n      typeof Blob !== \"undefined\"\n        ? function isBlob2(b) {\n            return b instanceof Blob;\n          }\n        : function isBlob2(b) {\n            return false;\n          };\n    var AbortController = globalThis.AbortController || __require(\"abort-controller\").AbortController;\n    var { FunctionPrototypeCall } = require_primordials();\n    class Duplexify extends Duplex {\n      constructor(options) {\n        super(options);\n\n        // https://github.com/nodejs/node/pull/34385\n\n        if ((options === null || options === undefined ? undefined : options.readable) === false) {\n          this._readableState.readable = false;\n          this._readableState.ended = true;\n          this._readableState.endEmitted = true;\n        }\n        if ((options === null || options === undefined ? undefined : options.writable) === false) {\n          this._writableState.writable = false;\n          this._writableState.ending = true;\n          this._writableState.ended = true;\n          this._writableState.finished = true;\n        }\n      }\n    }\n    module.exports = function duplexify(body, name) {\n      if (isDuplexNodeStream(body)) {\n        return body;\n      }\n      if (isReadableNodeStream(body)) {\n        return _duplexify({\n          readable: body,\n        });\n      }\n      if (isWritableNodeStream(body)) {\n        return _duplexify({\n          writable: body,\n        });\n      }\n      if (isNodeStream(body)) {\n        return _duplexify({\n          writable: false,\n          readable: false,\n        });\n      }\n      if (typeof body === \"function\") {\n        const { value, write, final, destroy } = fromAsyncGen(body);\n        if (isIterable(value)) {\n          return from(Duplexify, value, {\n            objectMode: true,\n            write,\n            final,\n            destroy,\n          });\n        }\n        const then2 = value === null || value === void 0 ? void 0 : value.then;\n        if (typeof then2 === \"function\") {\n          let d;\n          const promise = FunctionPrototypeCall(\n            then2,\n            value,\n            val => {\n              if (val != null) {\n                throw new ERR_INVALID_RETURN_VALUE(\"nully\", \"body\", val);\n              }\n            },\n            err => {\n              destroyer(d, err);\n            },\n          );\n          return (d = new Duplexify({\n            objectMode: true,\n            readable: false,\n            write,\n            final(cb) {\n              final(async () => {\n                try {\n                  await promise;\n                  runOnNextTick(cb, null);\n                } catch (err) {\n                  runOnNextTick(cb, err);\n                }\n              });\n            },\n            destroy,\n          }));\n        }\n        throw new ERR_INVALID_RETURN_VALUE(\"Iterable, AsyncIterable or AsyncFunction\", name, value);\n      }\n      if (isBlob(body)) {\n        return duplexify(body.arrayBuffer());\n      }\n      if (isIterable(body)) {\n        return from(Duplexify, body, {\n          objectMode: true,\n          writable: false,\n        });\n      }\n      if (\n        typeof (body === null || body === void 0 ? void 0 : body.writable) === \"object\" ||\n        typeof (body === null || body === void 0 ? void 0 : body.readable) === \"object\"\n      ) {\n        const readable =\n          body !== null && body !== void 0 && body.readable\n            ? isReadableNodeStream(body === null || body === void 0 ? void 0 : body.readable)\n              ? body === null || body === void 0\n                ? void 0\n                : body.readable\n              : duplexify(body.readable)\n            : void 0;\n        const writable =\n          body !== null && body !== void 0 && body.writable\n            ? isWritableNodeStream(body === null || body === void 0 ? void 0 : body.writable)\n              ? body === null || body === void 0\n                ? void 0\n                : body.writable\n              : duplexify(body.writable)\n            : void 0;\n        return _duplexify({\n          readable,\n          writable,\n        });\n      }\n      const then = body === null || body === void 0 ? void 0 : body.then;\n      if (typeof then === \"function\") {\n        let d;\n        FunctionPrototypeCall(\n          then,\n          body,\n          val => {\n            if (val != null) {\n              d.push(val);\n            }\n            d.push(null);\n          },\n          err => {\n            destroyer(d, err);\n          },\n        );\n        return (d = new Duplexify({\n          objectMode: true,\n          writable: false,\n          read() {},\n        }));\n      }\n      throw new ERR_INVALID_ARG_TYPE(\n        name,\n        [\n          \"Blob\",\n          \"ReadableStream\",\n          \"WritableStream\",\n          \"Stream\",\n          \"Iterable\",\n          \"AsyncIterable\",\n          \"Function\",\n          \"{ readable, writable } pair\",\n          \"Promise\",\n        ],\n        body,\n      );\n    };\n    function fromAsyncGen(fn) {\n      let { promise, resolve } = createDeferredPromise();\n      const ac = new AbortController();\n      const signal = ac.signal;\n      const value = fn(\n        (async function* () {\n          while (true) {\n            const _promise = promise;\n            promise = null;\n            const { chunk, done, cb } = await _promise;\n            runOnNextTick(cb);\n            if (done) return;\n            if (signal.aborted)\n              throw new AbortError(void 0, {\n                cause: signal.reason,\n              });\n            ({ promise, resolve } = createDeferredPromise());\n            yield chunk;\n          }\n        })(),\n        {\n          signal,\n        },\n      );\n      return {\n        value,\n        write(chunk, encoding, cb) {\n          const _resolve = resolve;\n          resolve = null;\n          _resolve({\n            chunk,\n            done: false,\n            cb,\n          });\n        },\n        final(cb) {\n          const _resolve = resolve;\n          resolve = null;\n          _resolve({\n            done: true,\n            cb,\n          });\n        },\n        destroy(err, cb) {\n          ac.abort();\n          cb(err);\n        },\n      };\n    }\n    function _duplexify(pair) {\n      const r =\n        pair.readable && typeof pair.readable.read !== \"function\" ? Readable.wrap(pair.readable) : pair.readable;\n      const w = pair.writable;\n      let readable = !!isReadable(r);\n      let writable = !!isWritable(w);\n      let ondrain;\n      let onfinish;\n      let onreadable;\n      let onclose;\n      let d;\n      function onfinished(err) {\n        const cb = onclose;\n        onclose = null;\n        if (cb) {\n          cb(err);\n        } else if (err) {\n          d.destroy(err);\n        } else if (!readable && !writable) {\n          d.destroy();\n        }\n      }\n      d = new Duplexify({\n        readableObjectMode: !!(r !== null && r !== void 0 && r.readableObjectMode),\n        writableObjectMode: !!(w !== null && w !== void 0 && w.writableObjectMode),\n        readable,\n        writable,\n      });\n      if (writable) {\n        eos(w, err => {\n          writable = false;\n          if (err) {\n            destroyer(r, err);\n          }\n          onfinished(err);\n        });\n        d._write = function (chunk, encoding, callback) {\n          if (w.write(chunk, encoding)) {\n            callback();\n          } else {\n            ondrain = callback;\n          }\n        };\n        d._final = function (callback) {\n          w.end();\n          onfinish = callback;\n        };\n        w.on(\"drain\", function () {\n          if (ondrain) {\n            const cb = ondrain;\n            ondrain = null;\n            cb();\n          }\n        });\n        w.on(\"finish\", function () {\n          if (onfinish) {\n            const cb = onfinish;\n            onfinish = null;\n            cb();\n          }\n        });\n      }\n      if (readable) {\n        eos(r, err => {\n          readable = false;\n          if (err) {\n            destroyer(r, err);\n          }\n          onfinished(err);\n        });\n        r.on(\"readable\", function () {\n          if (onreadable) {\n            const cb = onreadable;\n            onreadable = null;\n            cb();\n          }\n        });\n        r.on(\"end\", function () {\n          d.push(null);\n        });\n        d._read = function () {\n          while (true) {\n            const buf = r.read();\n            if (buf === null) {\n              onreadable = d._read;\n              return;\n            }\n            if (!d.push(buf)) {\n              return;\n            }\n          }\n        };\n      }\n      d._destroy = function (err, callback) {\n        if (!err && onclose !== null) {\n          err = new AbortError();\n        }\n        onreadable = null;\n        ondrain = null;\n        onfinish = null;\n        if (onclose === null) {\n          callback(err);\n        } else {\n          onclose = callback;\n          destroyer(w, err);\n          destroyer(r, err);\n        }\n      };\n      return d;\n    }\n  },\n});\n\n// node_modules/readable-stream/lib/internal/streams/duplex.js\nvar require_duplex = __commonJS({\n  \"node_modules/readable-stream/lib/internal/streams/duplex.js\"(exports, module) {\n    \"use strict\";\n    var { ObjectDefineProperties, ObjectGetOwnPropertyDescriptor, ObjectKeys, ObjectSetPrototypeOf } =\n      require_primordials();\n\n    var Readable = require_readable();\n\n    function Duplex(options) {\n      if (!(this instanceof Duplex)) return new Duplex(options);\n      Readable.call(this, options);\n      Writable.call(this, options);\n\n      if (options) {\n        this.allowHalfOpen = options.allowHalfOpen !== false;\n        if (options.readable === false) {\n          this._readableState.readable = false;\n          this._readableState.ended = true;\n          this._readableState.endEmitted = true;\n        }\n        if (options.writable === false) {\n          this._writableState.writable = false;\n          this._writableState.ending = true;\n          this._writableState.ended = true;\n          this._writableState.finished = true;\n        }\n      } else {\n        this.allowHalfOpen = true;\n      }\n    }\n    module.exports = Duplex;\n\n    ObjectSetPrototypeOf(Duplex.prototype, Readable.prototype);\n    ObjectSetPrototypeOf(Duplex, Readable);\n\n    {\n      for (var method in Writable.prototype) {\n        if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];\n      }\n    }\n\n    ObjectDefineProperties(Duplex.prototype, {\n      writable: ObjectGetOwnPropertyDescriptor(Writable.prototype, \"writable\"),\n      writableHighWaterMark: ObjectGetOwnPropertyDescriptor(Writable.prototype, \"writableHighWaterMark\"),\n      writableObjectMode: ObjectGetOwnPropertyDescriptor(Writable.prototype, \"writableObjectMode\"),\n      writableBuffer: ObjectGetOwnPropertyDescriptor(Writable.prototype, \"writableBuffer\"),\n      writableLength: ObjectGetOwnPropertyDescriptor(Writable.prototype, \"writableLength\"),\n      writableFinished: ObjectGetOwnPropertyDescriptor(Writable.prototype, \"writableFinished\"),\n      writableCorked: ObjectGetOwnPropertyDescriptor(Writable.prototype, \"writableCorked\"),\n      writableEnded: ObjectGetOwnPropertyDescriptor(Writable.prototype, \"writableEnded\"),\n      writableNeedDrain: ObjectGetOwnPropertyDescriptor(Writable.prototype, \"writableNeedDrain\"),\n      destroyed: {\n        get() {\n          if (this._readableState === void 0 || this._writableState === void 0) {\n            return false;\n          }\n          return this._readableState.destroyed && this._writableState.destroyed;\n        },\n        set(value) {\n          if (this._readableState && this._writableState) {\n            this._readableState.destroyed = value;\n            this._writableState.destroyed = value;\n          }\n        },\n      },\n    });\n    var webStreamsAdapters;\n    function lazyWebStreams() {\n      if (webStreamsAdapters === void 0) webStreamsAdapters = {};\n      return webStreamsAdapters;\n    }\n    Duplex.fromWeb = function (pair, options) {\n      return lazyWebStreams().newStreamDuplexFromReadableWritablePair(pair, options);\n    };\n    Duplex.toWeb = function (duplex) {\n      return lazyWebStreams().newReadableWritablePairFromDuplex(duplex);\n    };\n    var duplexify;\n    Duplex.from = function (body) {\n      if (!duplexify) {\n        duplexify = require_duplexify();\n      }\n      return duplexify(body, \"body\");\n    };\n  },\n});\n\n// node_modules/readable-stream/lib/internal/streams/transform.js\nvar require_transform = __commonJS({\n  \"node_modules/readable-stream/lib/internal/streams/transform.js\"(exports, module) {\n    \"use strict\";\n    var { ObjectSetPrototypeOf, Symbol: Symbol2 } = require_primordials();\n    var { ERR_METHOD_NOT_IMPLEMENTED } = require_errors().codes;\n    var Duplex = require_duplex();\n    function Transform(options) {\n      if (!(this instanceof Transform)) return new Transform(options);\n      Duplex.call(this, options);\n\n      this._readableState.sync = false;\n      this[kCallback] = null;\n\n      if (options) {\n        if (typeof options.transform === \"function\") this._transform = options.transform;\n        if (typeof options.flush === \"function\") this._flush = options.flush;\n      }\n\n      this.on(\"prefinish\", prefinish.bind(this));\n    }\n    ObjectSetPrototypeOf(Transform.prototype, Duplex.prototype);\n    ObjectSetPrototypeOf(Transform, Duplex);\n\n    module.exports = Transform;\n    var kCallback = Symbol2(\"kCallback\");\n    function final(cb) {\n      if (typeof this._flush === \"function\" && !this.destroyed) {\n        this._flush((er, data) => {\n          if (er) {\n            if (cb) {\n              cb(er);\n            } else {\n              this.destroy(er);\n            }\n            return;\n          }\n          if (data != null) {\n            this.push(data);\n          }\n          this.push(null);\n          if (cb) {\n            cb();\n          }\n        });\n      } else {\n        this.push(null);\n        if (cb) {\n          cb();\n        }\n      }\n    }\n    function prefinish() {\n      if (this._final !== final) {\n        final.call(this);\n      }\n    }\n    Transform.prototype._final = final;\n    Transform.prototype._transform = function (chunk, encoding, callback) {\n      throw new ERR_METHOD_NOT_IMPLEMENTED(\"_transform()\");\n    };\n    Transform.prototype._write = function (chunk, encoding, callback) {\n      const rState = this._readableState;\n      const wState = this._writableState;\n      const length = rState.length;\n      this._transform(chunk, encoding, (err, val) => {\n        if (err) {\n          callback(err);\n          return;\n        }\n        if (val != null) {\n          this.push(val);\n        }\n        if (\n          wState.ended ||\n          length === rState.length ||\n          rState.length < rState.highWaterMark ||\n          rState.highWaterMark === 0 ||\n          rState.length === 0\n        ) {\n          callback();\n        } else {\n          this[kCallback] = callback;\n        }\n      });\n    };\n    Transform.prototype._read = function () {\n      if (this[kCallback]) {\n        const callback = this[kCallback];\n        this[kCallback] = null;\n        callback();\n      }\n    };\n  },\n});\n\n// node_modules/readable-stream/lib/internal/streams/passthrough.js\nvar require_passthrough = __commonJS({\n  \"node_modules/readable-stream/lib/internal/streams/passthrough.js\"(exports, module) {\n    \"use strict\";\n    var { ObjectSetPrototypeOf } = require_primordials();\n    var Transform = require_transform();\n\n    function PassThrough(options) {\n      if (!(this instanceof PassThrough)) return new PassThrough(options);\n      Transform.call(this, options);\n    }\n\n    ObjectSetPrototypeOf(PassThrough.prototype, Transform.prototype);\n    ObjectSetPrototypeOf(PassThrough, Transform);\n\n    PassThrough.prototype._transform = function (chunk, encoding, cb) {\n      cb(null, chunk);\n    };\n\n    module.exports = PassThrough;\n  },\n});\n\n// node_modules/readable-stream/lib/internal/streams/pipeline.js\nvar require_pipeline = __commonJS({\n  \"node_modules/readable-stream/lib/internal/streams/pipeline.js\"(exports, module) {\n    \"use strict\";\n    var { ArrayIsArray, Promise: Promise2, SymbolAsyncIterator } = require_primordials();\n    var eos = require_end_of_stream();\n    var { once } = require_util();\n    var destroyImpl = require_destroy();\n    var Duplex = require_duplex();\n    var {\n      aggregateTwoErrors,\n      codes: { ERR_INVALID_ARG_TYPE, ERR_INVALID_RETURN_VALUE, ERR_MISSING_ARGS, ERR_STREAM_DESTROYED },\n      AbortError,\n    } = require_errors();\n    var { validateFunction, validateAbortSignal } = require_validators();\n    var { isIterable, isReadable, isReadableNodeStream, isNodeStream } = require_utils();\n    var AbortController = globalThis.AbortController || __require(\"abort-controller\").AbortController;\n    var PassThrough;\n    var Readable;\n    function destroyer(stream, reading, writing) {\n      let finished = false;\n      stream.on(\"close\", () => {\n        finished = true;\n      });\n      const cleanup = eos(\n        stream,\n        {\n          readable: reading,\n          writable: writing,\n        },\n        err => {\n          finished = !err;\n        },\n      );\n      return {\n        destroy: err => {\n          if (finished) return;\n          finished = true;\n          destroyImpl.destroyer(stream, err || new ERR_STREAM_DESTROYED(\"pipe\"));\n        },\n        cleanup,\n      };\n    }\n    function popCallback(streams) {\n      validateFunction(streams[streams.length - 1], \"streams[stream.length - 1]\");\n      return streams.pop();\n    }\n    function makeAsyncIterable(val) {\n      if (isIterable(val)) {\n        return val;\n      } else if (isReadableNodeStream(val)) {\n        return fromReadable(val);\n      }\n      throw new ERR_INVALID_ARG_TYPE(\"val\", [\"Readable\", \"Iterable\", \"AsyncIterable\"], val);\n    }\n    async function* fromReadable(val) {\n      if (!Readable) {\n        Readable = require_readable();\n      }\n      yield* Readable.prototype[SymbolAsyncIterator].call(val);\n    }\n    async function pump(iterable, writable, finish, { end }) {\n      let error;\n      let onresolve = null;\n      const resume = err => {\n        if (err) {\n          error = err;\n        }\n        if (onresolve) {\n          const callback = onresolve;\n          onresolve = null;\n          callback();\n        }\n      };\n      const wait = () =>\n        new Promise2((resolve, reject) => {\n          if (error) {\n            reject(error);\n          } else {\n            onresolve = () => {\n              if (error) {\n                reject(error);\n              } else {\n                resolve();\n              }\n            };\n          }\n        });\n      writable.on(\"drain\", resume);\n      const cleanup = eos(\n        writable,\n        {\n          readable: false,\n        },\n        resume,\n      );\n      try {\n        if (writable.writableNeedDrain) {\n          await wait();\n        }\n        for await (const chunk of iterable) {\n          if (!writable.write(chunk)) {\n            await wait();\n          }\n        }\n        if (end) {\n          writable.end();\n        }\n        await wait();\n        finish();\n      } catch (err) {\n        finish(error !== err ? aggregateTwoErrors(error, err) : err);\n      } finally {\n        cleanup();\n        writable.off(\"drain\", resume);\n      }\n    }\n    function pipeline(...streams) {\n      return pipelineImpl(streams, once(popCallback(streams)));\n    }\n    function pipelineImpl(streams, callback, opts) {\n      if (streams.length === 1 && ArrayIsArray(streams[0])) {\n        streams = streams[0];\n      }\n      if (streams.length < 2) {\n        throw new ERR_MISSING_ARGS(\"streams\");\n      }\n      const ac = new AbortController();\n      const signal = ac.signal;\n      const outerSignal = opts === null || opts === void 0 ? void 0 : opts.signal;\n      const lastStreamCleanup = [];\n      validateAbortSignal(outerSignal, \"options.signal\");\n      function abort() {\n        finishImpl(new AbortError());\n      }\n      outerSignal === null || outerSignal === void 0 ? void 0 : outerSignal.addEventListener(\"abort\", abort);\n      let error;\n      let value;\n      const destroys = [];\n      let finishCount = 0;\n      function finish(err) {\n        finishImpl(err, --finishCount === 0);\n      }\n      function finishImpl(err, final) {\n        if (err && (!error || error.code === \"ERR_STREAM_PREMATURE_CLOSE\")) {\n          error = err;\n        }\n        if (!error && !final) {\n          return;\n        }\n        while (destroys.length) {\n          destroys.shift()(error);\n        }\n        outerSignal === null || outerSignal === void 0 ? void 0 : outerSignal.removeEventListener(\"abort\", abort);\n        ac.abort();\n        if (final) {\n          if (!error) {\n            lastStreamCleanup.forEach(fn => fn());\n          }\n          runOnNextTick(callback, error, value);\n        }\n      }\n      let ret;\n      for (let i = 0; i < streams.length; i++) {\n        const stream = streams[i];\n        const reading = i < streams.length - 1;\n        const writing = i > 0;\n        const end = reading || (opts === null || opts === void 0 ? void 0 : opts.end) !== false;\n        const isLastStream = i === streams.length - 1;\n        if (isNodeStream(stream)) {\n          let onError = function (err) {\n            if (err && err.name !== \"AbortError\" && err.code !== \"ERR_STREAM_PREMATURE_CLOSE\") {\n              finish(err);\n            }\n          };\n          if (end) {\n            const { destroy, cleanup } = destroyer(stream, reading, writing);\n            destroys.push(destroy);\n            if (isReadable(stream) && isLastStream) {\n              lastStreamCleanup.push(cleanup);\n            }\n          }\n          stream.on(\"error\", onError);\n          if (isReadable(stream) && isLastStream) {\n            lastStreamCleanup.push(() => {\n              stream.removeListener(\"error\", onError);\n            });\n          }\n        }\n        if (i === 0) {\n          if (typeof stream === \"function\") {\n            ret = stream({\n              signal,\n            });\n            if (!isIterable(ret)) {\n              throw new ERR_INVALID_RETURN_VALUE(\"Iterable, AsyncIterable or Stream\", \"source\", ret);\n            }\n          } else if (isIterable(stream) || isReadableNodeStream(stream)) {\n            ret = stream;\n          } else {\n            ret = Duplex.from(stream);\n          }\n        } else if (typeof stream === \"function\") {\n          ret = makeAsyncIterable(ret);\n          ret = stream(ret, {\n            signal,\n          });\n          if (reading) {\n            if (!isIterable(ret, true)) {\n              throw new ERR_INVALID_RETURN_VALUE(\"AsyncIterable\", `transform[${i - 1}]`, ret);\n            }\n          } else {\n            var _ret;\n            if (!PassThrough) {\n              PassThrough = require_passthrough();\n            }\n            const pt = new PassThrough({\n              objectMode: true,\n            });\n            const then = (_ret = ret) === null || _ret === void 0 ? void 0 : _ret.then;\n            if (typeof then === \"function\") {\n              finishCount++;\n              then.call(\n                ret,\n                val => {\n                  value = val;\n                  if (val != null) {\n                    pt.write(val);\n                  }\n                  if (end) {\n                    pt.end();\n                  }\n                  runOnNextTick(finish);\n                },\n                err => {\n                  pt.destroy(err);\n                  runOnNextTick(finish, err);\n                },\n              );\n            } else if (isIterable(ret, true)) {\n              finishCount++;\n              pump(ret, pt, finish, {\n                end,\n              });\n            } else {\n              throw new ERR_INVALID_RETURN_VALUE(\"AsyncIterable or Promise\", \"destination\", ret);\n            }\n            ret = pt;\n            const { destroy, cleanup } = destroyer(ret, false, true);\n            destroys.push(destroy);\n            if (isLastStream) {\n              lastStreamCleanup.push(cleanup);\n            }\n          }\n        } else if (isNodeStream(stream)) {\n          if (isReadableNodeStream(ret)) {\n            finishCount += 2;\n            const cleanup = pipe(ret, stream, finish, {\n              end,\n            });\n            if (isReadable(stream) && isLastStream) {\n              lastStreamCleanup.push(cleanup);\n            }\n          } else if (isIterable(ret)) {\n            finishCount++;\n            pump(ret, stream, finish, {\n              end,\n            });\n          } else {\n            throw new ERR_INVALID_ARG_TYPE(\"val\", [\"Readable\", \"Iterable\", \"AsyncIterable\"], ret);\n          }\n          ret = stream;\n        } else {\n          ret = Duplex.from(stream);\n        }\n      }\n      if (\n        (signal !== null && signal !== void 0 && signal.aborted) ||\n        (outerSignal !== null && outerSignal !== void 0 && outerSignal.aborted)\n      ) {\n        runOnNextTick(abort);\n      }\n      return ret;\n    }\n    function pipe(src, dst, finish, { end }) {\n      src.pipe(dst, {\n        end,\n      });\n      if (end) {\n        src.once(\"end\", () => dst.end());\n      } else {\n        finish();\n      }\n      eos(\n        src,\n        {\n          readable: true,\n          writable: false,\n        },\n        err => {\n          const rState = src._readableState;\n          if (\n            err &&\n            err.code === \"ERR_STREAM_PREMATURE_CLOSE\" &&\n            rState &&\n            rState.ended &&\n            !rState.errored &&\n            !rState.errorEmitted\n          ) {\n            src.once(\"end\", finish).once(\"error\", finish);\n          } else {\n            finish(err);\n          }\n        },\n      );\n      return eos(\n        dst,\n        {\n          readable: false,\n          writable: true,\n        },\n        finish,\n      );\n    }\n    module.exports = {\n      pipelineImpl,\n      pipeline,\n    };\n  },\n});\n\n// node_modules/readable-stream/lib/internal/streams/compose.js\nvar require_compose = __commonJS({\n  \"node_modules/readable-stream/lib/internal/streams/compose.js\"(exports, module) {\n    \"use strict\";\n    var { pipeline } = require_pipeline();\n    var Duplex = require_duplex();\n    var { destroyer } = require_destroy();\n    var { isNodeStream, isReadable, isWritable } = require_utils();\n    var {\n      AbortError,\n      codes: { ERR_INVALID_ARG_VALUE, ERR_MISSING_ARGS },\n    } = require_errors();\n    module.exports = function compose(...streams) {\n      if (streams.length === 0) {\n        throw new ERR_MISSING_ARGS(\"streams\");\n      }\n      if (streams.length === 1) {\n        return Duplex.from(streams[0]);\n      }\n      const orgStreams = [...streams];\n      if (typeof streams[0] === \"function\") {\n        streams[0] = Duplex.from(streams[0]);\n      }\n      if (typeof streams[streams.length - 1] === \"function\") {\n        const idx = streams.length - 1;\n        streams[idx] = Duplex.from(streams[idx]);\n      }\n      for (let n = 0; n < streams.length; ++n) {\n        if (!isNodeStream(streams[n])) {\n          continue;\n        }\n        if (n < streams.length - 1 && !isReadable(streams[n])) {\n          throw new ERR_INVALID_ARG_VALUE(`streams[${n}]`, orgStreams[n], \"must be readable\");\n        }\n        if (n > 0 && !isWritable(streams[n])) {\n          throw new ERR_INVALID_ARG_VALUE(`streams[${n}]`, orgStreams[n], \"must be writable\");\n        }\n      }\n      let ondrain;\n      let onfinish;\n      let onreadable;\n      let onclose;\n      let d;\n      function onfinished(err) {\n        const cb = onclose;\n        onclose = null;\n        if (cb) {\n          cb(err);\n        } else if (err) {\n          d.destroy(err);\n        } else if (!readable && !writable) {\n          d.destroy();\n        }\n      }\n      const head = streams[0];\n      const tail = pipeline(streams, onfinished);\n      const writable = !!isWritable(head);\n      const readable = !!isReadable(tail);\n      d = new Duplex({\n        writableObjectMode: !!(head !== null && head !== void 0 && head.writableObjectMode),\n        readableObjectMode: !!(tail !== null && tail !== void 0 && tail.writableObjectMode),\n        writable,\n        readable,\n      });\n      if (writable) {\n        d._write = function (chunk, encoding, callback) {\n          if (head.write(chunk, encoding)) {\n            callback();\n          } else {\n            ondrain = callback;\n          }\n        };\n        d._final = function (callback) {\n          head.end();\n          onfinish = callback;\n        };\n        head.on(\"drain\", function () {\n          if (ondrain) {\n            const cb = ondrain;\n            ondrain = null;\n            cb();\n          }\n        });\n        tail.on(\"finish\", function () {\n          if (onfinish) {\n            const cb = onfinish;\n            onfinish = null;\n            cb();\n          }\n        });\n      }\n      if (readable) {\n        tail.on(\"readable\", function () {\n          if (onreadable) {\n            const cb = onreadable;\n            onreadable = null;\n            cb();\n          }\n        });\n        tail.on(\"end\", function () {\n          d.push(null);\n        });\n        d._read = function () {\n          while (true) {\n            const buf = tail.read();\n            if (buf === null) {\n              onreadable = d._read;\n              return;\n            }\n            if (!d.push(buf)) {\n              return;\n            }\n          }\n        };\n      }\n      d._destroy = function (err, callback) {\n        if (!err && onclose !== null) {\n          err = new AbortError();\n        }\n        onreadable = null;\n        ondrain = null;\n        onfinish = null;\n        if (onclose === null) {\n          callback(err);\n        } else {\n          onclose = callback;\n          destroyer(tail, err);\n        }\n      };\n      return d;\n    };\n  },\n});\n\n// node_modules/readable-stream/lib/stream/promises.js\nvar require_promises = __commonJS({\n  \"node_modules/readable-stream/lib/stream/promises.js\"(exports, module) {\n    \"use strict\";\n    var { ArrayPrototypePop, Promise: Promise2 } = require_primordials();\n    var { isIterable, isNodeStream } = require_utils();\n    var { pipelineImpl: pl } = require_pipeline();\n    var { finished } = require_end_of_stream();\n    function pipeline(...streams) {\n      return new Promise2((resolve, reject) => {\n        let signal;\n        let end;\n        const lastArg = streams[streams.length - 1];\n        if (lastArg && typeof lastArg === \"object\" && !isNodeStream(lastArg) && !isIterable(lastArg)) {\n          const options = ArrayPrototypePop(streams);\n          signal = options.signal;\n          end = options.end;\n        }\n        pl(\n          streams,\n          (err, value) => {\n            if (err) {\n              reject(err);\n            } else {\n              resolve(value);\n            }\n          },\n          {\n            signal,\n            end,\n          },\n        );\n      });\n    }\n    module.exports = {\n      finished,\n      pipeline,\n    };\n  },\n});\n// node_modules/readable-stream/lib/stream.js\nvar require_stream = __commonJS({\n  \"node_modules/readable-stream/lib/stream.js\"(exports, module) {\n    \"use strict\";\n    var { ObjectDefineProperty, ObjectKeys, ReflectApply } = require_primordials();\n    var {\n      promisify: { custom: customPromisify },\n    } = require_util();\n\n    var { streamReturningOperators, promiseReturningOperators } = require_operators();\n    var {\n      codes: { ERR_ILLEGAL_CONSTRUCTOR },\n    } = require_errors();\n    var compose = require_compose();\n    var { pipeline } = require_pipeline();\n    var { destroyer } = require_destroy();\n    var eos = require_end_of_stream();\n    var promises = require_promises();\n    var utils = require_utils();\n    var Stream = (module.exports = require_legacy().Stream);\n    Stream.isDisturbed = utils.isDisturbed;\n    Stream.isErrored = utils.isErrored;\n    Stream.isWritable = utils.isWritable;\n    Stream.isReadable = utils.isReadable;\n    Stream.Readable = require_readable();\n    for (const key of ObjectKeys(streamReturningOperators)) {\n      let fn = function (...args) {\n        if (new.target) {\n          throw ERR_ILLEGAL_CONSTRUCTOR();\n        }\n        return Stream.Readable.from(ReflectApply(op, this, args));\n      };\n      const op = streamReturningOperators[key];\n      ObjectDefineProperty(fn, \"name\", {\n        value: op.name,\n      });\n      ObjectDefineProperty(fn, \"length\", {\n        value: op.length,\n      });\n      ObjectDefineProperty(Stream.Readable.prototype, key, {\n        value: fn,\n        enumerable: false,\n        configurable: true,\n        writable: true,\n      });\n    }\n    for (const key of ObjectKeys(promiseReturningOperators)) {\n      let fn = function (...args) {\n        if (new.target) {\n          throw ERR_ILLEGAL_CONSTRUCTOR();\n        }\n        return ReflectApply(op, this, args);\n      };\n      const op = promiseReturningOperators[key];\n      ObjectDefineProperty(fn, \"name\", {\n        value: op.name,\n      });\n      ObjectDefineProperty(fn, \"length\", {\n        value: op.length,\n      });\n      ObjectDefineProperty(Stream.Readable.prototype, key, {\n        value: fn,\n        enumerable: false,\n        configurable: true,\n        writable: true,\n      });\n    }\n    Stream.Writable = require_writable();\n    Stream.Duplex = require_duplex();\n    Stream.Transform = require_transform();\n    Stream.PassThrough = require_passthrough();\n    Stream.pipeline = pipeline;\n    var { addAbortSignal } = require_add_abort_signal();\n    Stream.addAbortSignal = addAbortSignal;\n    Stream.finished = eos;\n    Stream.destroy = destroyer;\n    Stream.compose = compose;\n    ObjectDefineProperty(Stream, \"promises\", {\n      configurable: true,\n      enumerable: true,\n      get() {\n        return promises;\n      },\n    });\n    ObjectDefineProperty(pipeline, customPromisify, {\n      enumerable: true,\n      get() {\n        return promises.pipeline;\n      },\n    });\n    ObjectDefineProperty(eos, customPromisify, {\n      enumerable: true,\n      get() {\n        return promises.finished;\n      },\n    });\n    Stream.Stream = Stream;\n    Stream._isUint8Array = function isUint8Array(value) {\n      return value instanceof Uint8Array;\n    };\n    Stream._uint8ArrayToBuffer = function _uint8ArrayToBuffer(chunk) {\n      return new Buffer(chunk.buffer, chunk.byteOffset, chunk.byteLength);\n    };\n  },\n});\n\n// node_modules/readable-stream/lib/ours/index.js\nvar require_ours = __commonJS({\n  \"node_modules/readable-stream/lib/ours/index.js\"(exports, module) {\n    \"use strict\";\n    const CustomStream = require_stream();\n    const promises = require_promises();\n    const originalDestroy = CustomStream.Readable.destroy;\n    module.exports = CustomStream;\n    module.exports._uint8ArrayToBuffer = CustomStream._uint8ArrayToBuffer;\n    module.exports._isUint8Array = CustomStream._isUint8Array;\n    module.exports.isDisturbed = CustomStream.isDisturbed;\n    module.exports.isErrored = CustomStream.isErrored;\n    module.exports.isWritable = CustomStream.isWritable;\n    module.exports.isReadable = CustomStream.isReadable;\n    module.exports.Readable = CustomStream.Readable;\n    module.exports.Writable = CustomStream.Writable;\n    module.exports.Duplex = CustomStream.Duplex;\n    module.exports.Transform = CustomStream.Transform;\n    module.exports.PassThrough = CustomStream.PassThrough;\n    module.exports.addAbortSignal = CustomStream.addAbortSignal;\n    module.exports.finished = CustomStream.finished;\n    module.exports.destroy = CustomStream.destroy;\n    module.exports.destroy = originalDestroy;\n    module.exports.pipeline = CustomStream.pipeline;\n    module.exports.compose = CustomStream.compose;\n\n    module.exports._getNativeReadableStreamPrototype = getNativeReadableStreamPrototype;\n    module.exports.NativeWritable = NativeWritable;\n\n    Object.defineProperty(CustomStream, \"promises\", {\n      configurable: true,\n      enumerable: true,\n      get() {\n        return promises;\n      },\n    });\n    module.exports.Stream = CustomStream.Stream;\n    module.exports.default = module.exports;\n  },\n});\n\n/**\n * Bun native stream wrapper\n *\n * This glue code lets us avoid using ReadableStreams to wrap Bun internal streams\n *\n */\nfunction createNativeStreamReadable(nativeType, Readable) {\n  var [pull, start, cancel, setClose, deinit, updateRef, drainFn] = globalThis[Symbol.for(\"Bun.lazy\")](nativeType);\n\n  var closer = [false];\n  var handleNumberResult = function (nativeReadable, result, view, isClosed) {\n    if (result > 0) {\n      const slice = view.subarray(0, result);\n      const remainder = view.subarray(result);\n      if (slice.byteLength > 0) {\n        nativeReadable.push(slice);\n      }\n\n      if (isClosed) {\n        nativeReadable.push(null);\n      }\n\n      return remainder.byteLength > 0 ? remainder : undefined;\n    }\n\n    if (isClosed) {\n      nativeReadable.push(null);\n    }\n\n    return view;\n  };\n\n  var handleArrayBufferViewResult = function (nativeReadable, result, view, isClosed) {\n    if (result.byteLength > 0) {\n      nativeReadable.push(result);\n    }\n\n    if (isClosed) {\n      nativeReadable.push(null);\n    }\n\n    return view;\n  };\n\n  var DYNAMICALLY_ADJUST_CHUNK_SIZE = process.env.BUN_DISABLE_DYNAMIC_CHUNK_SIZE !== \"1\";\n\n  const finalizer = new FinalizationRegistry(ptr => ptr && deinit(ptr));\n  const MIN_BUFFER_SIZE = 512;\n  var NativeReadable = class NativeReadable extends Readable {\n    #ptr;\n    #refCount = 1;\n    #constructed = false;\n    #remainingChunk = undefined;\n    #highWaterMark;\n    #pendingRead = false;\n    #hasResized = !DYNAMICALLY_ADJUST_CHUNK_SIZE;\n    #unregisterToken;\n    constructor(ptr, options = {}) {\n      super(options);\n      if (typeof options.highWaterMark === \"number\") {\n        this.#highWaterMark = options.highWaterMark;\n      } else {\n        this.#highWaterMark = 256 * 1024;\n      }\n      this.#ptr = ptr;\n      this.#constructed = false;\n      this.#remainingChunk = undefined;\n      this.#pendingRead = false;\n      this.#unregisterToken = {};\n      finalizer.register(this, this.#ptr, this.#unregisterToken);\n    }\n\n    // maxToRead is by default the highWaterMark passed from the Readable.read call to this fn\n    // However, in the case of an fs.ReadStream, we can pass the number of bytes we want to read\n    // which may be significantly less than the actual highWaterMark\n    _read(maxToRead) {\n      __DEBUG__ && debug(\"NativeReadable._read\", this.__id);\n      if (this.#pendingRead) {\n        __DEBUG__ && debug(\"pendingRead is true\", this.__id);\n        return;\n      }\n\n      var ptr = this.#ptr;\n      __DEBUG__ && debug(\"ptr @ NativeReadable._read\", ptr, this.__id);\n      if (ptr === 0) {\n        this.push(null);\n        return;\n      }\n\n      if (!this.#constructed) {\n        __DEBUG__ && debug(\"NativeReadable not constructed yet\", this.__id);\n        this.#internalConstruct(ptr);\n      }\n\n      return this.#internalRead(this.#getRemainingChunk(maxToRead), ptr);\n      // const internalReadRes = this.#internalRead(\n      //   this.#getRemainingChunk(),\n      //   ptr,\n      // );\n      // // REVERT ME\n      // const wrap = new Promise((resolve) => {\n      //   if (!this.internalReadRes?.then) {\n      //     debug(\"internalReadRes not promise\");\n      //     resolve(internalReadRes);\n      //     return;\n      //   }\n      //   internalReadRes.then((result) => {\n      //     debug(\"internalReadRes done\");\n      //     resolve(result);\n      //   });\n      // });\n      // return wrap;\n    }\n\n    #internalConstruct(ptr) {\n      this.#constructed = true;\n      const result = start(ptr, this.#highWaterMark);\n      __DEBUG__ && debug(\"NativeReadable internal `start` result\", result, this.__id);\n\n      if (typeof result === \"number\" && result > 1) {\n        this.#hasResized = true;\n        __DEBUG__ && debug(\"NativeReadable resized\", this.__id);\n\n        this.#highWaterMark = Math.min(this.#highWaterMark, result);\n      }\n\n      if (drainFn) {\n        const drainResult = drainFn(ptr);\n        __DEBUG__ && debug(\"NativeReadable drain result\", drainResult, this.__id);\n        if ((drainResult?.byteLength ?? 0) > 0) {\n          this.push(drainResult);\n        }\n      }\n    }\n\n    // maxToRead can be the highWaterMark (by default) or the remaining amount of the stream to read\n    // This is so the the consumer of the stream can terminate the stream early if they know\n    // how many bytes they want to read (ie. when reading only part of a file)\n    #getRemainingChunk(maxToRead = this.#highWaterMark) {\n      var chunk = this.#remainingChunk;\n      __DEBUG__ && debug(\"chunk @ #getRemainingChunk\", chunk, this.__id);\n      if (chunk?.byteLength ?? 0 < MIN_BUFFER_SIZE) {\n        var size = maxToRead > MIN_BUFFER_SIZE ? maxToRead : MIN_BUFFER_SIZE;\n        this.#remainingChunk = chunk = new Buffer(size);\n      }\n      return chunk;\n    }\n\n    push(result, encoding) {\n      __DEBUG__ && debug(\"NativeReadable push -- result, encoding\", result, encoding, this.__id);\n      return super.push(...arguments);\n    }\n\n    #handleResult(result, view, isClosed) {\n      __DEBUG__ && debug(\"result, isClosed @ #handleResult\", result, isClosed, this.__id);\n\n      if (typeof result === \"number\") {\n        if (result >= this.#highWaterMark && !this.#hasResized && !isClosed) {\n          this.#highWaterMark *= 2;\n          this.#hasResized = true;\n        }\n\n        return handleNumberResult(this, result, view, isClosed);\n      } else if (typeof result === \"boolean\") {\n        this.push(null);\n        return view?.byteLength ?? 0 > 0 ? view : undefined;\n      } else if (ArrayBuffer.isView(result)) {\n        if (result.byteLength >= this.#highWaterMark && !this.#hasResized && !isClosed) {\n          this.#highWaterMark *= 2;\n          this.#hasResized = true;\n          __DEBUG__ && debug(\"Resized\", this.__id);\n        }\n\n        return handleArrayBufferViewResult(this, result, view, isClosed);\n      } else {\n        __DEBUG__ && debug(\"Unknown result type\", result, this.__id);\n        throw new Error(\"Invalid result from pull\");\n      }\n    }\n\n    #internalRead(view, ptr) {\n      __DEBUG__ && debug(\"#internalRead()\", this.__id);\n      closer[0] = false;\n      var result = pull(ptr, view, closer);\n      if (isPromise(result)) {\n        this.#pendingRead = true;\n        return result.then(\n          result => {\n            this.#pendingRead = false;\n            __DEBUG__ && debug(\"pending no longerrrrrrrr (result returned from pull)\", this.__id);\n            this.#remainingChunk = this.#handleResult(result, view, closer[0]);\n          },\n          reason => {\n            __DEBUG__ && debug(\"error from pull\", reason, this.__id);\n            errorOrDestroy(this, reason);\n          },\n        );\n      } else {\n        this.#remainingChunk = this.#handleResult(result, view, closer[0]);\n      }\n    }\n\n    _destroy(error, callback) {\n      var ptr = this.#ptr;\n      if (ptr === 0) {\n        callback(error);\n        return;\n      }\n\n      finalizer.unregister(this.#unregisterToken);\n      this.#ptr = 0;\n      if (updateRef) {\n        updateRef(ptr, false);\n      }\n      __DEBUG__ && debug(\"NativeReadable destroyed\", this.__id);\n      cancel(ptr, error);\n      callback(error);\n    }\n\n    ref() {\n      var ptr = this.#ptr;\n      if (ptr === 0) return;\n      if (this.#refCount++ === 0) {\n        updateRef(ptr, true);\n      }\n    }\n\n    unref() {\n      var ptr = this.#ptr;\n      if (ptr === 0) return;\n      if (this.#refCount-- === 1) {\n        updateRef(ptr, false);\n      }\n    }\n  };\n\n  if (!updateRef) {\n    NativeReadable.prototype.ref = undefined;\n    NativeReadable.prototype.unref = undefined;\n  }\n\n  return NativeReadable;\n}\n\nvar nativeReadableStreamPrototypes = {\n  0: undefined,\n  1: undefined,\n  2: undefined,\n  3: undefined,\n  4: undefined,\n  5: undefined,\n};\nfunction getNativeReadableStreamPrototype(nativeType, Readable) {\n  return (nativeReadableStreamPrototypes[nativeType] ||= createNativeStreamReadable(nativeType, Readable));\n}\n\nfunction getNativeReadableStream(Readable, stream, options) {\n  if (!(stream && typeof stream === \"object\" && stream instanceof ReadableStream)) {\n    return undefined;\n  }\n\n  const native = direct(stream);\n  if (!native) {\n    debug(\"no native readable stream\");\n    return undefined;\n  }\n  const { stream: ptr, data: type } = native;\n\n  const NativeReadable = getNativeReadableStreamPrototype(type, Readable);\n\n  return new NativeReadable(ptr, options);\n}\n/** --- Bun native stream wrapper ---  */\n\nvar Writable = require_writable();\nvar NativeWritable = class NativeWritable extends Writable {\n  #pathOrFdOrSink;\n  #fileSink;\n  #native = true;\n\n  _construct;\n  _destroy;\n  _final;\n\n  constructor(pathOrFdOrSink, options = {}) {\n    super(options);\n\n    this._construct = this.#internalConstruct;\n    this._destroy = this.#internalDestroy;\n    this._final = this.#internalFinal;\n\n    this.#pathOrFdOrSink = pathOrFdOrSink;\n  }\n\n  // These are confusingly two different fns for construct which initially were the same thing because\n  // `_construct` is part of the lifecycle of Writable and is not called lazily,\n  // so we need to separate our _construct for Writable state and actual construction of the write stream\n  #internalConstruct(cb) {\n    this._writableState.constructed = true;\n    this.constructed = true;\n    cb();\n  }\n\n  #lazyConstruct() {\n    // TODO: Turn this check into check for instanceof FileSink\n    if (typeof this.#pathOrFdOrSink === \"object\") {\n      if (typeof this.#pathOrFdOrSink.write === \"function\") {\n        this.#fileSink = this.#pathOrFdOrSink;\n      } else {\n        throw new Error(\"Invalid FileSink\");\n      }\n    } else {\n      this.#fileSink = Bun.file(this.#pathOrFdOrSink).writer();\n    }\n  }\n\n  write(chunk, encoding, cb, native = this.#native) {\n    if (!native) {\n      this.#native = false;\n      return super.write(chunk, encoding, cb);\n    }\n\n    if (!this.#fileSink) {\n      this.#lazyConstruct();\n    }\n    var fileSink = this.#fileSink;\n    var result = fileSink.write(chunk);\n\n    if (isPromise(result)) {\n      // var writePromises = this.#writePromises;\n      // var i = writePromises.length;\n      // writePromises[i] = result;\n      result.then(() => {\n        this.emit(\"drain\");\n        fileSink.flush(true);\n        // // We can't naively use i here because we don't know when writes will resolve necessarily\n        // writePromises.splice(writePromises.indexOf(result), 1);\n      });\n      return false;\n    }\n    fileSink.flush(true);\n    // TODO: Should we just have a calculation based on encoding and length of chunk?\n    if (cb) cb(null, chunk.byteLength);\n    return true;\n  }\n\n  end(chunk, encoding, cb, native = this.#native) {\n    return super.end(chunk, encoding, cb, native);\n  }\n\n  #internalDestroy(error, cb) {\n    this._writableState.destroyed = true;\n    if (cb) cb(error);\n  }\n\n  #internalFinal(cb) {\n    if (this.#fileSink) {\n      this.#fileSink.end();\n    }\n    if (cb) cb();\n  }\n\n  ref() {\n    if (!this.#fileSink) {\n      this.#lazyConstruct();\n    }\n    this.#fileSink.ref();\n  }\n\n  unref() {\n    if (!this.#fileSink) return;\n    this.#fileSink.unref();\n  }\n};\n\nconst stream_exports = require_ours();\nstream_exports[Symbol.for(\"CommonJS\")] = 0;\nstream_exports[Symbol.for(\"::bunternal::\")] = { _ReadableFromWeb };\nexport default stream_exports;\nexport var _uint8ArrayToBuffer = stream_exports._uint8ArrayToBuffer;\nexport var _isUint8Array = stream_exports._isUint8Array;\nexport var isDisturbed = stream_exports.isDisturbed;\nexport var isErrored = stream_exports.isErrored;\nexport var isWritable = stream_exports.isWritable;\nexport var isReadable = stream_exports.isReadable;\nexport var Readable = stream_exports.Readable;\nexport var Writable = stream_exports.Writable;\nexport var Duplex = stream_exports.Duplex;\nexport var Transform = stream_exports.Transform;\nexport var PassThrough = stream_exports.PassThrough;\nexport var addAbortSignal = stream_exports.addAbortSignal;\nexport var finished = stream_exports.finished;\nexport var destroy = stream_exports.destroy;\nexport var pipeline = stream_exports.pipeline;\nexport var compose = stream_exports.compose;\nexport var Stream = stream_exports.Stream;\nexport var eos = (stream_exports[\"eos\"] = require_end_of_stream);\nexport var _getNativeReadableStreamPrototype = stream_exports._getNativeReadableStreamPrototype;\nexport var NativeWritable = stream_exports.NativeWritable;\nexport var promises = Stream.promise;\n"
  ],
  "mappings": ";;A//////DA2CA,IAAS,4BAAiB,CAAC,MAAM;AAC/B,QAAM,gBAAgB;AAAoB,WAAO,IAAI,kBAAkB,IAAI;AAC3E,MAAI,KAAK,MAAM,IAAI;AACnB,QAAM,OAAO,KAAK;AAClB,MAAI;AACF,cAAU,MAAM,QAAQ;AAAA,MACtB,OAAO;AAAA,MACP,UAAU;AAAA,MACV,UAAU;AAAA,MACV,YAAY;AAAA,IACd,CAAC;AAAA,GAiDI,2BAAgB,CAAC,OAAO;AAC/B,gBAAc,UAAU,YAAY,UAAU,QAAQ,iBAAiB;AAAA,GAGhE,0BAAe,CAAC,OAAO,MAAM;AACpC,aAAW,UAAU;AAAW,UAAM,IAAI,qBAAqB,MAAM,WAAW,KAAK;AAAA;",
  "debugId": "C95EBBF8A541902864756e2164756e21",
  "names": []
}