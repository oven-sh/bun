{
  "version": 3,
  "sources": ["src/js/node/zlib.js", "src/js/node/zlib.js", "src/js/node/zlib.js"],
  "sourcesContent": [
    "// Hardcoded module \"node:zlib\"\n// TODO: **use a native binding from Bun for this!!**\n// This is a very slow module!\n// It should really be fixed. It will show up in benchmarking. It also loads\n// slowly. We need to fix it!\n\nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __commonJS = (cb, mod) =>\n  function __require() {\n    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;\n  };\n\nvar __copyProps = (to, from, except, desc) => {\n  if ((from && typeof from === \"object\") || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, {\n          get: () => from[key],\n          enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable,\n        });\n  }\n  return to;\n};\nvar __reExport = (target, mod, secondTarget) => (\n  __copyProps(target, mod, \"default\"), secondTarget && __copyProps(secondTarget, mod, \"default\")\n);\nvar __toESM = (mod, isNodeMode, target) => (\n  (target = mod != null ? __create(__getProtoOf(mod)) : {}),\n  __copyProps(\n    isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", { value: mod, enumerable: true }) : target,\n    mod,\n  )\n);\nvar __toCommonJS = mod => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\n\nconst require = id => import.meta.require(id);\n\n// node_modules/pako/lib/zlib/zstream.js\nvar require_zstream = __commonJS({\n  \"node_modules/pako/lib/zlib/zstream.js\"(exports, module2) {\n    \"use strict\";\n    function ZStream() {\n      this.input = null;\n      this.next_in = 0;\n      this.avail_in = 0;\n      this.total_in = 0;\n      this.output = null;\n      this.next_out = 0;\n      this.avail_out = 0;\n      this.total_out = 0;\n      this.msg = \"\";\n      this.state = null;\n      this.data_type = 2;\n      this.adler = 0;\n    }\n    module2.exports = ZStream;\n  },\n});\n\n// node_modules/pako/lib/utils/common.js\nvar require_common = __commonJS({\n  \"node_modules/pako/lib/utils/common.js\"(exports) {\n    \"use strict\";\n    var TYPED_OK =\n      typeof Uint8Array !== \"undefined\" && typeof Uint16Array !== \"undefined\" && typeof Int32Array !== \"undefined\";\n    function _has(obj, key) {\n      return Object.prototype.hasOwnProperty.call(obj, key);\n    }\n    exports.assign = function (obj) {\n      var sources = Array.prototype.slice.call(arguments, 1);\n      while (sources.length) {\n        var source = sources.shift();\n        if (!source) {\n          continue;\n        }\n        if (typeof source !== \"object\") {\n          throw new TypeError(source + \"must be non-object\");\n        }\n        for (var p in source) {\n          if (_has(source, p)) {\n            obj[p] = source[p];\n          }\n        }\n      }\n      return obj;\n    };\n    exports.shrinkBuf = function (buf, size) {\n      if (buf.length === size) {\n        return buf;\n      }\n      if (buf.subarray) {\n        return buf.subarray(0, size);\n      }\n      buf.length = size;\n      return buf;\n    };\n    var fnTyped = {\n      arraySet: function (dest, src, src_offs, len, dest_offs) {\n        if (src.subarray && dest.subarray) {\n          dest.set(src.subarray(src_offs, src_offs + len), dest_offs);\n          return;\n        }\n        for (var i = 0; i < len; i++) {\n          dest[dest_offs + i] = src[src_offs + i];\n        }\n      },\n      flattenChunks: function (chunks) {\n        var i, l, len, pos, chunk, result;\n        len = 0;\n        for (i = 0, l = chunks.length; i < l; i++) {\n          len += chunks[i].length;\n        }\n        result = new Uint8Array(len);\n        pos = 0;\n        for (i = 0, l = chunks.length; i < l; i++) {\n          chunk = chunks[i];\n          result.set(chunk, pos);\n          pos += chunk.length;\n        }\n        return result;\n      },\n    };\n    var fnUntyped = {\n      arraySet: function (dest, src, src_offs, len, dest_offs) {\n        for (var i = 0; i < len; i++) {\n          dest[dest_offs + i] = src[src_offs + i];\n        }\n      },\n      flattenChunks: function (chunks) {\n        return [].concat.apply([], chunks);\n      },\n    };\n    exports.setTyped = function (on) {\n      if (on) {\n        exports.Buf8 = Uint8Array;\n        exports.Buf16 = Uint16Array;\n        exports.Buf32 = Int32Array;\n        exports.assign(exports, fnTyped);\n      } else {\n        exports.Buf8 = Array;\n        exports.Buf16 = Array;\n        exports.Buf32 = Array;\n        exports.assign(exports, fnUntyped);\n      }\n    };\n    exports.setTyped(TYPED_OK);\n  },\n});\n\n// node_modules/pako/lib/zlib/trees.js\nvar require_trees = __commonJS({\n  \"node_modules/pako/lib/zlib/trees.js\"(exports) {\n    \"use strict\";\n    var utils = require_common();\n    var Z_FIXED = 4;\n    var Z_BINARY = 0;\n    var Z_TEXT = 1;\n    var Z_UNKNOWN = 2;\n    function zero(buf) {\n      var len = buf.length;\n      while (--len >= 0) {\n        buf[len] = 0;\n      }\n    }\n    var STORED_BLOCK = 0;\n    var STATIC_TREES = 1;\n    var DYN_TREES = 2;\n    var MIN_MATCH = 3;\n    var MAX_MATCH = 258;\n    var LENGTH_CODES = 29;\n    var LITERALS = 256;\n    var L_CODES = LITERALS + 1 + LENGTH_CODES;\n    var D_CODES = 30;\n    var BL_CODES = 19;\n    var HEAP_SIZE = 2 * L_CODES + 1;\n    var MAX_BITS = 15;\n    var Buf_size = 16;\n    var MAX_BL_BITS = 7;\n    var END_BLOCK = 256;\n    var REP_3_6 = 16;\n    var REPZ_3_10 = 17;\n    var REPZ_11_138 = 18;\n    var extra_lbits = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0];\n    var extra_dbits = [\n      0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13,\n    ];\n    var extra_blbits = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7];\n    var bl_order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];\n    var DIST_CODE_LEN = 512;\n    var static_ltree = new Array((L_CODES + 2) * 2);\n    zero(static_ltree);\n    var static_dtree = new Array(D_CODES * 2);\n    zero(static_dtree);\n    var _dist_code = new Array(DIST_CODE_LEN);\n    zero(_dist_code);\n    var _length_code = new Array(MAX_MATCH - MIN_MATCH + 1);\n    zero(_length_code);\n    var base_length = new Array(LENGTH_CODES);\n    zero(base_length);\n    var base_dist = new Array(D_CODES);\n    zero(base_dist);\n    function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {\n      this.static_tree = static_tree;\n      this.extra_bits = extra_bits;\n      this.extra_base = extra_base;\n      this.elems = elems;\n      this.max_length = max_length;\n      this.has_stree = static_tree && static_tree.length;\n    }\n    var static_l_desc;\n    var static_d_desc;\n    var static_bl_desc;\n    function TreeDesc(dyn_tree, stat_desc) {\n      this.dyn_tree = dyn_tree;\n      this.max_code = 0;\n      this.stat_desc = stat_desc;\n    }\n    function d_code(dist) {\n      return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];\n    }\n    function put_short(s, w) {\n      s.pending_buf[s.pending++] = w & 255;\n      s.pending_buf[s.pending++] = (w >>> 8) & 255;\n    }\n    function send_bits(s, value, length) {\n      if (s.bi_valid > Buf_size - length) {\n        s.bi_buf |= (value << s.bi_valid) & 65535;\n        put_short(s, s.bi_buf);\n        s.bi_buf = value >> (Buf_size - s.bi_valid);\n        s.bi_valid += length - Buf_size;\n      } else {\n        s.bi_buf |= (value << s.bi_valid) & 65535;\n        s.bi_valid += length;\n      }\n    }\n    function send_code(s, c, tree) {\n      send_bits(s, tree[c * 2], tree[c * 2 + 1]);\n    }\n    function bi_reverse(code, len) {\n      var res = 0;\n      do {\n        res |= code & 1;\n        code >>>= 1;\n        res <<= 1;\n      } while (--len > 0);\n      return res >>> 1;\n    }\n    function bi_flush(s) {\n      if (s.bi_valid === 16) {\n        put_short(s, s.bi_buf);\n        s.bi_buf = 0;\n        s.bi_valid = 0;\n      } else if (s.bi_valid >= 8) {\n        s.pending_buf[s.pending++] = s.bi_buf & 255;\n        s.bi_buf >>= 8;\n        s.bi_valid -= 8;\n      }\n    }\n    function gen_bitlen(s, desc) {\n      var tree = desc.dyn_tree;\n      var max_code = desc.max_code;\n      var stree = desc.stat_desc.static_tree;\n      var has_stree = desc.stat_desc.has_stree;\n      var extra = desc.stat_desc.extra_bits;\n      var base = desc.stat_desc.extra_base;\n      var max_length = desc.stat_desc.max_length;\n      var h;\n      var n, m;\n      var bits;\n      var xbits;\n      var f;\n      var overflow = 0;\n      for (bits = 0; bits <= MAX_BITS; bits++) {\n        s.bl_count[bits] = 0;\n      }\n      tree[s.heap[s.heap_max] * 2 + 1] = 0;\n      for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {\n        n = s.heap[h];\n        bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;\n        if (bits > max_length) {\n          bits = max_length;\n          overflow++;\n        }\n        tree[n * 2 + 1] = bits;\n        if (n > max_code) {\n          continue;\n        }\n        s.bl_count[bits]++;\n        xbits = 0;\n        if (n >= base) {\n          xbits = extra[n - base];\n        }\n        f = tree[n * 2];\n        s.opt_len += f * (bits + xbits);\n        if (has_stree) {\n          s.static_len += f * (stree[n * 2 + 1] + xbits);\n        }\n      }\n      if (overflow === 0) {\n        return;\n      }\n      do {\n        bits = max_length - 1;\n        while (s.bl_count[bits] === 0) {\n          bits--;\n        }\n        s.bl_count[bits]--;\n        s.bl_count[bits + 1] += 2;\n        s.bl_count[max_length]--;\n        overflow -= 2;\n      } while (overflow > 0);\n      for (bits = max_length; bits !== 0; bits--) {\n        n = s.bl_count[bits];\n        while (n !== 0) {\n          m = s.heap[--h];\n          if (m > max_code) {\n            continue;\n          }\n          if (tree[m * 2 + 1] !== bits) {\n            s.opt_len += (bits - tree[m * 2 + 1]) * tree[m * 2];\n            tree[m * 2 + 1] = bits;\n          }\n          n--;\n        }\n      }\n    }\n    function gen_codes(tree, max_code, bl_count) {\n      var next_code = new Array(MAX_BITS + 1);\n      var code = 0;\n      var bits;\n      var n;\n      for (bits = 1; bits <= MAX_BITS; bits++) {\n        next_code[bits] = code = (code + bl_count[bits - 1]) << 1;\n      }\n      for (n = 0; n <= max_code; n++) {\n        var len = tree[n * 2 + 1];\n        if (len === 0) {\n          continue;\n        }\n        tree[n * 2] = bi_reverse(next_code[len]++, len);\n      }\n    }\n    function tr_static_init() {\n      var n;\n      var bits;\n      var length;\n      var code;\n      var dist;\n      var bl_count = new Array(MAX_BITS + 1);\n      length = 0;\n      for (code = 0; code < LENGTH_CODES - 1; code++) {\n        base_length[code] = length;\n        for (n = 0; n < 1 << extra_lbits[code]; n++) {\n          _length_code[length++] = code;\n        }\n      }\n      _length_code[length - 1] = code;\n      dist = 0;\n      for (code = 0; code < 16; code++) {\n        base_dist[code] = dist;\n        for (n = 0; n < 1 << extra_dbits[code]; n++) {\n          _dist_code[dist++] = code;\n        }\n      }\n      dist >>= 7;\n      for (; code < D_CODES; code++) {\n        base_dist[code] = dist << 7;\n        for (n = 0; n < 1 << (extra_dbits[code] - 7); n++) {\n          _dist_code[256 + dist++] = code;\n        }\n      }\n      for (bits = 0; bits <= MAX_BITS; bits++) {\n        bl_count[bits] = 0;\n      }\n      n = 0;\n      while (n <= 143) {\n        static_ltree[n * 2 + 1] = 8;\n        n++;\n        bl_count[8]++;\n      }\n      while (n <= 255) {\n        static_ltree[n * 2 + 1] = 9;\n        n++;\n        bl_count[9]++;\n      }\n      while (n <= 279) {\n        static_ltree[n * 2 + 1] = 7;\n        n++;\n        bl_count[7]++;\n      }\n      while (n <= 287) {\n        static_ltree[n * 2 + 1] = 8;\n        n++;\n        bl_count[8]++;\n      }\n      gen_codes(static_ltree, L_CODES + 1, bl_count);\n      for (n = 0; n < D_CODES; n++) {\n        static_dtree[n * 2 + 1] = 5;\n        static_dtree[n * 2] = bi_reverse(n, 5);\n      }\n      static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);\n      static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES, MAX_BITS);\n      static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES, MAX_BL_BITS);\n    }\n    function init_block(s) {\n      var n;\n      for (n = 0; n < L_CODES; n++) {\n        s.dyn_ltree[n * 2] = 0;\n      }\n      for (n = 0; n < D_CODES; n++) {\n        s.dyn_dtree[n * 2] = 0;\n      }\n      for (n = 0; n < BL_CODES; n++) {\n        s.bl_tree[n * 2] = 0;\n      }\n      s.dyn_ltree[END_BLOCK * 2] = 1;\n      s.opt_len = s.static_len = 0;\n      s.last_lit = s.matches = 0;\n    }\n    function bi_windup(s) {\n      if (s.bi_valid > 8) {\n        put_short(s, s.bi_buf);\n      } else if (s.bi_valid > 0) {\n        s.pending_buf[s.pending++] = s.bi_buf;\n      }\n      s.bi_buf = 0;\n      s.bi_valid = 0;\n    }\n    function copy_block(s, buf, len, header) {\n      bi_windup(s);\n      if (header) {\n        put_short(s, len);\n        put_short(s, ~len);\n      }\n      utils.arraySet(s.pending_buf, s.window, buf, len, s.pending);\n      s.pending += len;\n    }\n    function smaller(tree, n, m, depth) {\n      var _n2 = n * 2;\n      var _m2 = m * 2;\n      return tree[_n2] < tree[_m2] || (tree[_n2] === tree[_m2] && depth[n] <= depth[m]);\n    }\n    function pqdownheap(s, tree, k) {\n      var v = s.heap[k];\n      var j = k << 1;\n      while (j <= s.heap_len) {\n        if (j < s.heap_len && smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {\n          j++;\n        }\n        if (smaller(tree, v, s.heap[j], s.depth)) {\n          break;\n        }\n        s.heap[k] = s.heap[j];\n        k = j;\n        j <<= 1;\n      }\n      s.heap[k] = v;\n    }\n    function compress_block(s, ltree, dtree) {\n      var dist;\n      var lc;\n      var lx = 0;\n      var code;\n      var extra;\n      if (s.last_lit !== 0) {\n        do {\n          dist = (s.pending_buf[s.d_buf + lx * 2] << 8) | s.pending_buf[s.d_buf + lx * 2 + 1];\n          lc = s.pending_buf[s.l_buf + lx];\n          lx++;\n          if (dist === 0) {\n            send_code(s, lc, ltree);\n          } else {\n            code = _length_code[lc];\n            send_code(s, code + LITERALS + 1, ltree);\n            extra = extra_lbits[code];\n            if (extra !== 0) {\n              lc -= base_length[code];\n              send_bits(s, lc, extra);\n            }\n            dist--;\n            code = d_code(dist);\n            send_code(s, code, dtree);\n            extra = extra_dbits[code];\n            if (extra !== 0) {\n              dist -= base_dist[code];\n              send_bits(s, dist, extra);\n            }\n          }\n        } while (lx < s.last_lit);\n      }\n      send_code(s, END_BLOCK, ltree);\n    }\n    function build_tree(s, desc) {\n      var tree = desc.dyn_tree;\n      var stree = desc.stat_desc.static_tree;\n      var has_stree = desc.stat_desc.has_stree;\n      var elems = desc.stat_desc.elems;\n      var n, m;\n      var max_code = -1;\n      var node;\n      s.heap_len = 0;\n      s.heap_max = HEAP_SIZE;\n      for (n = 0; n < elems; n++) {\n        if (tree[n * 2] !== 0) {\n          s.heap[++s.heap_len] = max_code = n;\n          s.depth[n] = 0;\n        } else {\n          tree[n * 2 + 1] = 0;\n        }\n      }\n      while (s.heap_len < 2) {\n        node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;\n        tree[node * 2] = 1;\n        s.depth[node] = 0;\n        s.opt_len--;\n        if (has_stree) {\n          s.static_len -= stree[node * 2 + 1];\n        }\n      }\n      desc.max_code = max_code;\n      for (n = s.heap_len >> 1; n >= 1; n--) {\n        pqdownheap(s, tree, n);\n      }\n      node = elems;\n      do {\n        n = s.heap[1];\n        s.heap[1] = s.heap[s.heap_len--];\n        pqdownheap(s, tree, 1);\n        m = s.heap[1];\n        s.heap[--s.heap_max] = n;\n        s.heap[--s.heap_max] = m;\n        tree[node * 2] = tree[n * 2] + tree[m * 2];\n        s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;\n        tree[n * 2 + 1] = tree[m * 2 + 1] = node;\n        s.heap[1] = node++;\n        pqdownheap(s, tree, 1);\n      } while (s.heap_len >= 2);\n      s.heap[--s.heap_max] = s.heap[1];\n      gen_bitlen(s, desc);\n      gen_codes(tree, max_code, s.bl_count);\n    }\n    function scan_tree(s, tree, max_code) {\n      var n;\n      var prevlen = -1;\n      var curlen;\n      var nextlen = tree[0 * 2 + 1];\n      var count = 0;\n      var max_count = 7;\n      var min_count = 4;\n      if (nextlen === 0) {\n        max_count = 138;\n        min_count = 3;\n      }\n      tree[(max_code + 1) * 2 + 1] = 65535;\n      for (n = 0; n <= max_code; n++) {\n        curlen = nextlen;\n        nextlen = tree[(n + 1) * 2 + 1];\n        if (++count < max_count && curlen === nextlen) {\n          continue;\n        } else if (count < min_count) {\n          s.bl_tree[curlen * 2] += count;\n        } else if (curlen !== 0) {\n          if (curlen !== prevlen) {\n            s.bl_tree[curlen * 2]++;\n          }\n          s.bl_tree[REP_3_6 * 2]++;\n        } else if (count <= 10) {\n          s.bl_tree[REPZ_3_10 * 2]++;\n        } else {\n          s.bl_tree[REPZ_11_138 * 2]++;\n        }\n        count = 0;\n        prevlen = curlen;\n        if (nextlen === 0) {\n          max_count = 138;\n          min_count = 3;\n        } else if (curlen === nextlen) {\n          max_count = 6;\n          min_count = 3;\n        } else {\n          max_count = 7;\n          min_count = 4;\n        }\n      }\n    }\n    function send_tree(s, tree, max_code) {\n      var n;\n      var prevlen = -1;\n      var curlen;\n      var nextlen = tree[0 * 2 + 1];\n      var count = 0;\n      var max_count = 7;\n      var min_count = 4;\n      if (nextlen === 0) {\n        max_count = 138;\n        min_count = 3;\n      }\n      for (n = 0; n <= max_code; n++) {\n        curlen = nextlen;\n        nextlen = tree[(n + 1) * 2 + 1];\n        if (++count < max_count && curlen === nextlen) {\n          continue;\n        } else if (count < min_count) {\n          do {\n            send_code(s, curlen, s.bl_tree);\n          } while (--count !== 0);\n        } else if (curlen !== 0) {\n          if (curlen !== prevlen) {\n            send_code(s, curlen, s.bl_tree);\n            count--;\n          }\n          send_code(s, REP_3_6, s.bl_tree);\n          send_bits(s, count - 3, 2);\n        } else if (count <= 10) {\n          send_code(s, REPZ_3_10, s.bl_tree);\n          send_bits(s, count - 3, 3);\n        } else {\n          send_code(s, REPZ_11_138, s.bl_tree);\n          send_bits(s, count - 11, 7);\n        }\n        count = 0;\n        prevlen = curlen;\n        if (nextlen === 0) {\n          max_count = 138;\n          min_count = 3;\n        } else if (curlen === nextlen) {\n          max_count = 6;\n          min_count = 3;\n        } else {\n          max_count = 7;\n          min_count = 4;\n        }\n      }\n    }\n    function build_bl_tree(s) {\n      var max_blindex;\n      scan_tree(s, s.dyn_ltree, s.l_desc.max_code);\n      scan_tree(s, s.dyn_dtree, s.d_desc.max_code);\n      build_tree(s, s.bl_desc);\n      for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {\n        if (s.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0) {\n          break;\n        }\n      }\n      s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;\n      return max_blindex;\n    }\n    function send_all_trees(s, lcodes, dcodes, blcodes) {\n      var rank;\n      send_bits(s, lcodes - 257, 5);\n      send_bits(s, dcodes - 1, 5);\n      send_bits(s, blcodes - 4, 4);\n      for (rank = 0; rank < blcodes; rank++) {\n        send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1], 3);\n      }\n      send_tree(s, s.dyn_ltree, lcodes - 1);\n      send_tree(s, s.dyn_dtree, dcodes - 1);\n    }\n    function detect_data_type(s) {\n      var black_mask = 4093624447;\n      var n;\n      for (n = 0; n <= 31; n++, black_mask >>>= 1) {\n        if (black_mask & 1 && s.dyn_ltree[n * 2] !== 0) {\n          return Z_BINARY;\n        }\n      }\n      if (s.dyn_ltree[9 * 2] !== 0 || s.dyn_ltree[10 * 2] !== 0 || s.dyn_ltree[13 * 2] !== 0) {\n        return Z_TEXT;\n      }\n      for (n = 32; n < LITERALS; n++) {\n        if (s.dyn_ltree[n * 2] !== 0) {\n          return Z_TEXT;\n        }\n      }\n      return Z_BINARY;\n    }\n    var static_init_done = false;\n    function _tr_init(s) {\n      if (!static_init_done) {\n        tr_static_init();\n        static_init_done = true;\n      }\n      s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc);\n      s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc);\n      s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);\n      s.bi_buf = 0;\n      s.bi_valid = 0;\n      init_block(s);\n    }\n    function _tr_stored_block(s, buf, stored_len, last) {\n      send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);\n      copy_block(s, buf, stored_len, true);\n    }\n    function _tr_align(s) {\n      send_bits(s, STATIC_TREES << 1, 3);\n      send_code(s, END_BLOCK, static_ltree);\n      bi_flush(s);\n    }\n    function _tr_flush_block(s, buf, stored_len, last) {\n      var opt_lenb, static_lenb;\n      var max_blindex = 0;\n      if (s.level > 0) {\n        if (s.strm.data_type === Z_UNKNOWN) {\n          s.strm.data_type = detect_data_type(s);\n        }\n        build_tree(s, s.l_desc);\n        build_tree(s, s.d_desc);\n        max_blindex = build_bl_tree(s);\n        opt_lenb = (s.opt_len + 3 + 7) >>> 3;\n        static_lenb = (s.static_len + 3 + 7) >>> 3;\n        if (static_lenb <= opt_lenb) {\n          opt_lenb = static_lenb;\n        }\n      } else {\n        opt_lenb = static_lenb = stored_len + 5;\n      }\n      if (stored_len + 4 <= opt_lenb && buf !== -1) {\n        _tr_stored_block(s, buf, stored_len, last);\n      } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {\n        send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);\n        compress_block(s, static_ltree, static_dtree);\n      } else {\n        send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);\n        send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);\n        compress_block(s, s.dyn_ltree, s.dyn_dtree);\n      }\n      init_block(s);\n      if (last) {\n        bi_windup(s);\n      }\n    }\n    function _tr_tally(s, dist, lc) {\n      s.pending_buf[s.d_buf + s.last_lit * 2] = (dist >>> 8) & 255;\n      s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 255;\n      s.pending_buf[s.l_buf + s.last_lit] = lc & 255;\n      s.last_lit++;\n      if (dist === 0) {\n        s.dyn_ltree[lc * 2]++;\n      } else {\n        s.matches++;\n        dist--;\n        s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]++;\n        s.dyn_dtree[d_code(dist) * 2]++;\n      }\n      return s.last_lit === s.lit_bufsize - 1;\n    }\n    exports._tr_init = _tr_init;\n    exports._tr_stored_block = _tr_stored_block;\n    exports._tr_flush_block = _tr_flush_block;\n    exports._tr_tally = _tr_tally;\n    exports._tr_align = _tr_align;\n  },\n});\n\n// node_modules/pako/lib/zlib/adler32.js\nvar require_adler32 = __commonJS({\n  \"node_modules/pako/lib/zlib/adler32.js\"(exports, module2) {\n    \"use strict\";\n    function adler32(adler, buf, len, pos) {\n      var s1 = (adler & 65535) | 0,\n        s2 = ((adler >>> 16) & 65535) | 0,\n        n = 0;\n      while (len !== 0) {\n        n = len > 2e3 ? 2e3 : len;\n        len -= n;\n        do {\n          s1 = (s1 + buf[pos++]) | 0;\n          s2 = (s2 + s1) | 0;\n        } while (--n);\n        s1 %= 65521;\n        s2 %= 65521;\n      }\n      return s1 | (s2 << 16) | 0;\n    }\n    module2.exports = adler32;\n  },\n});\n\n// node_modules/pako/lib/zlib/crc32.js\nvar require_crc32 = __commonJS({\n  \"node_modules/pako/lib/zlib/crc32.js\"(exports, module2) {\n    \"use strict\";\n    function makeTable() {\n      var c,\n        table = [];\n      for (var n = 0; n < 256; n++) {\n        c = n;\n        for (var k = 0; k < 8; k++) {\n          c = c & 1 ? 3988292384 ^ (c >>> 1) : c >>> 1;\n        }\n        table[n] = c;\n      }\n      return table;\n    }\n    var crcTable = makeTable();\n    function crc32(crc, buf, len, pos) {\n      var t = crcTable,\n        end = pos + len;\n      crc ^= -1;\n      for (var i = pos; i < end; i++) {\n        crc = (crc >>> 8) ^ t[(crc ^ buf[i]) & 255];\n      }\n      return crc ^ -1;\n    }\n    module2.exports = crc32;\n  },\n});\n\n// node_modules/pako/lib/zlib/messages.js\nvar require_messages = __commonJS({\n  \"node_modules/pako/lib/zlib/messages.js\"(exports, module2) {\n    \"use strict\";\n    module2.exports = {\n      2: \"need dictionary\",\n      1: \"stream end\",\n      0: \"\",\n      \"-1\": \"file error\",\n      \"-2\": \"stream error\",\n      \"-3\": \"data error\",\n      \"-4\": \"insufficient memory\",\n      \"-5\": \"buffer error\",\n      \"-6\": \"incompatible version\",\n    };\n  },\n});\n\n// node_modules/pako/lib/zlib/deflate.js\nvar require_deflate = __commonJS({\n  \"node_modules/pako/lib/zlib/deflate.js\"(exports) {\n    \"use strict\";\n    var utils = require_common();\n    var trees = require_trees();\n    var adler32 = require_adler32();\n    var crc32 = require_crc32();\n    var msg = require_messages();\n    var Z_NO_FLUSH = 0;\n    var Z_PARTIAL_FLUSH = 1;\n    var Z_FULL_FLUSH = 3;\n    var Z_FINISH = 4;\n    var Z_BLOCK = 5;\n    var Z_OK = 0;\n    var Z_STREAM_END = 1;\n    var Z_STREAM_ERROR = -2;\n    var Z_DATA_ERROR = -3;\n    var Z_BUF_ERROR = -5;\n    var Z_DEFAULT_COMPRESSION = -1;\n    var Z_FILTERED = 1;\n    var Z_HUFFMAN_ONLY = 2;\n    var Z_RLE = 3;\n    var Z_FIXED = 4;\n    var Z_DEFAULT_STRATEGY = 0;\n    var Z_UNKNOWN = 2;\n    var Z_DEFLATED = 8;\n    var MAX_MEM_LEVEL = 9;\n    var MAX_WBITS = 15;\n    var DEF_MEM_LEVEL = 8;\n    var LENGTH_CODES = 29;\n    var LITERALS = 256;\n    var L_CODES = LITERALS + 1 + LENGTH_CODES;\n    var D_CODES = 30;\n    var BL_CODES = 19;\n    var HEAP_SIZE = 2 * L_CODES + 1;\n    var MAX_BITS = 15;\n    var MIN_MATCH = 3;\n    var MAX_MATCH = 258;\n    var MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;\n    var PRESET_DICT = 32;\n    var INIT_STATE = 42;\n    var EXTRA_STATE = 69;\n    var NAME_STATE = 73;\n    var COMMENT_STATE = 91;\n    var HCRC_STATE = 103;\n    var BUSY_STATE = 113;\n    var FINISH_STATE = 666;\n    var BS_NEED_MORE = 1;\n    var BS_BLOCK_DONE = 2;\n    var BS_FINISH_STARTED = 3;\n    var BS_FINISH_DONE = 4;\n    var OS_CODE = 3;\n    function err(strm, errorCode) {\n      strm.msg = msg[errorCode];\n      return errorCode;\n    }\n    function rank(f) {\n      return (f << 1) - (f > 4 ? 9 : 0);\n    }\n    function zero(buf) {\n      var len = buf.length;\n      while (--len >= 0) {\n        buf[len] = 0;\n      }\n    }\n    function flush_pending(strm) {\n      var s = strm.state;\n      var len = s.pending;\n      if (len > strm.avail_out) {\n        len = strm.avail_out;\n      }\n      if (len === 0) {\n        return;\n      }\n      utils.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);\n      strm.next_out += len;\n      s.pending_out += len;\n      strm.total_out += len;\n      strm.avail_out -= len;\n      s.pending -= len;\n      if (s.pending === 0) {\n        s.pending_out = 0;\n      }\n    }\n    function flush_block_only(s, last) {\n      trees._tr_flush_block(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last);\n      s.block_start = s.strstart;\n      flush_pending(s.strm);\n    }\n    function put_byte(s, b) {\n      s.pending_buf[s.pending++] = b;\n    }\n    function putShortMSB(s, b) {\n      s.pending_buf[s.pending++] = (b >>> 8) & 255;\n      s.pending_buf[s.pending++] = b & 255;\n    }\n    function read_buf(strm, buf, start, size) {\n      var len = strm.avail_in;\n      if (len > size) {\n        len = size;\n      }\n      if (len === 0) {\n        return 0;\n      }\n      strm.avail_in -= len;\n      utils.arraySet(buf, strm.input, strm.next_in, len, start);\n      if (strm.state.wrap === 1) {\n        strm.adler = adler32(strm.adler, buf, len, start);\n      } else if (strm.state.wrap === 2) {\n        strm.adler = crc32(strm.adler, buf, len, start);\n      }\n      strm.next_in += len;\n      strm.total_in += len;\n      return len;\n    }\n    function longest_match(s, cur_match) {\n      var chain_length = s.max_chain_length;\n      var scan = s.strstart;\n      var match;\n      var len;\n      var best_len = s.prev_length;\n      var nice_match = s.nice_match;\n      var limit = s.strstart > s.w_size - MIN_LOOKAHEAD ? s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0;\n      var _win = s.window;\n      var wmask = s.w_mask;\n      var prev = s.prev;\n      var strend = s.strstart + MAX_MATCH;\n      var scan_end1 = _win[scan + best_len - 1];\n      var scan_end = _win[scan + best_len];\n      if (s.prev_length >= s.good_match) {\n        chain_length >>= 2;\n      }\n      if (nice_match > s.lookahead) {\n        nice_match = s.lookahead;\n      }\n      do {\n        match = cur_match;\n        if (\n          _win[match + best_len] !== scan_end ||\n          _win[match + best_len - 1] !== scan_end1 ||\n          _win[match] !== _win[scan] ||\n          _win[++match] !== _win[scan + 1]\n        ) {\n          continue;\n        }\n        scan += 2;\n        match++;\n        do {} while (\n          _win[++scan] === _win[++match] &&\n          _win[++scan] === _win[++match] &&\n          _win[++scan] === _win[++match] &&\n          _win[++scan] === _win[++match] &&\n          _win[++scan] === _win[++match] &&\n          _win[++scan] === _win[++match] &&\n          _win[++scan] === _win[++match] &&\n          _win[++scan] === _win[++match] &&\n          scan < strend\n        );\n        len = MAX_MATCH - (strend - scan);\n        scan = strend - MAX_MATCH;\n        if (len > best_len) {\n          s.match_start = cur_match;\n          best_len = len;\n          if (len >= nice_match) {\n            break;\n          }\n          scan_end1 = _win[scan + best_len - 1];\n          scan_end = _win[scan + best_len];\n        }\n      } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);\n      if (best_len <= s.lookahead) {\n        return best_len;\n      }\n      return s.lookahead;\n    }\n    function fill_window(s) {\n      var _w_size = s.w_size;\n      var p, n, m, more, str;\n      do {\n        more = s.window_size - s.lookahead - s.strstart;\n        if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {\n          utils.arraySet(s.window, s.window, _w_size, _w_size, 0);\n          s.match_start -= _w_size;\n          s.strstart -= _w_size;\n          s.block_start -= _w_size;\n          n = s.hash_size;\n          p = n;\n          do {\n            m = s.head[--p];\n            s.head[p] = m >= _w_size ? m - _w_size : 0;\n          } while (--n);\n          n = _w_size;\n          p = n;\n          do {\n            m = s.prev[--p];\n            s.prev[p] = m >= _w_size ? m - _w_size : 0;\n          } while (--n);\n          more += _w_size;\n        }\n        if (s.strm.avail_in === 0) {\n          break;\n        }\n        n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);\n        s.lookahead += n;\n        if (s.lookahead + s.insert >= MIN_MATCH) {\n          str = s.strstart - s.insert;\n          s.ins_h = s.window[str];\n          s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + 1]) & s.hash_mask;\n          while (s.insert) {\n            s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;\n            s.prev[str & s.w_mask] = s.head[s.ins_h];\n            s.head[s.ins_h] = str;\n            str++;\n            s.insert--;\n            if (s.lookahead + s.insert < MIN_MATCH) {\n              break;\n            }\n          }\n        }\n      } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);\n    }\n    function deflate_stored(s, flush) {\n      var max_block_size = 65535;\n      if (max_block_size > s.pending_buf_size - 5) {\n        max_block_size = s.pending_buf_size - 5;\n      }\n      for (;;) {\n        if (s.lookahead <= 1) {\n          fill_window(s);\n          if (s.lookahead === 0 && flush === Z_NO_FLUSH) {\n            return BS_NEED_MORE;\n          }\n          if (s.lookahead === 0) {\n            break;\n          }\n        }\n        s.strstart += s.lookahead;\n        s.lookahead = 0;\n        var max_start = s.block_start + max_block_size;\n        if (s.strstart === 0 || s.strstart >= max_start) {\n          s.lookahead = s.strstart - max_start;\n          s.strstart = max_start;\n          flush_block_only(s, false);\n          if (s.strm.avail_out === 0) {\n            return BS_NEED_MORE;\n          }\n        }\n        if (s.strstart - s.block_start >= s.w_size - MIN_LOOKAHEAD) {\n          flush_block_only(s, false);\n          if (s.strm.avail_out === 0) {\n            return BS_NEED_MORE;\n          }\n        }\n      }\n      s.insert = 0;\n      if (flush === Z_FINISH) {\n        flush_block_only(s, true);\n        if (s.strm.avail_out === 0) {\n          return BS_FINISH_STARTED;\n        }\n        return BS_FINISH_DONE;\n      }\n      if (s.strstart > s.block_start) {\n        flush_block_only(s, false);\n        if (s.strm.avail_out === 0) {\n          return BS_NEED_MORE;\n        }\n      }\n      return BS_NEED_MORE;\n    }\n    function deflate_fast(s, flush) {\n      var hash_head;\n      var bflush;\n      for (;;) {\n        if (s.lookahead < MIN_LOOKAHEAD) {\n          fill_window(s);\n          if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {\n            return BS_NEED_MORE;\n          }\n          if (s.lookahead === 0) {\n            break;\n          }\n        }\n        hash_head = 0;\n        if (s.lookahead >= MIN_MATCH) {\n          s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\n          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n          s.head[s.ins_h] = s.strstart;\n        }\n        if (hash_head !== 0 && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {\n          s.match_length = longest_match(s, hash_head);\n        }\n        if (s.match_length >= MIN_MATCH) {\n          bflush = trees._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);\n          s.lookahead -= s.match_length;\n          if (s.match_length <= s.max_lazy_match && s.lookahead >= MIN_MATCH) {\n            s.match_length--;\n            do {\n              s.strstart++;\n              s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\n              hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n              s.head[s.ins_h] = s.strstart;\n            } while (--s.match_length !== 0);\n            s.strstart++;\n          } else {\n            s.strstart += s.match_length;\n            s.match_length = 0;\n            s.ins_h = s.window[s.strstart];\n            s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + 1]) & s.hash_mask;\n          }\n        } else {\n          bflush = trees._tr_tally(s, 0, s.window[s.strstart]);\n          s.lookahead--;\n          s.strstart++;\n        }\n        if (bflush) {\n          flush_block_only(s, false);\n          if (s.strm.avail_out === 0) {\n            return BS_NEED_MORE;\n          }\n        }\n      }\n      s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;\n      if (flush === Z_FINISH) {\n        flush_block_only(s, true);\n        if (s.strm.avail_out === 0) {\n          return BS_FINISH_STARTED;\n        }\n        return BS_FINISH_DONE;\n      }\n      if (s.last_lit) {\n        flush_block_only(s, false);\n        if (s.strm.avail_out === 0) {\n          return BS_NEED_MORE;\n        }\n      }\n      return BS_BLOCK_DONE;\n    }\n    function deflate_slow(s, flush) {\n      var hash_head;\n      var bflush;\n      var max_insert;\n      for (;;) {\n        if (s.lookahead < MIN_LOOKAHEAD) {\n          fill_window(s);\n          if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {\n            return BS_NEED_MORE;\n          }\n          if (s.lookahead === 0) {\n            break;\n          }\n        }\n        hash_head = 0;\n        if (s.lookahead >= MIN_MATCH) {\n          s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\n          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n          s.head[s.ins_h] = s.strstart;\n        }\n        s.prev_length = s.match_length;\n        s.prev_match = s.match_start;\n        s.match_length = MIN_MATCH - 1;\n        if (hash_head !== 0 && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {\n          s.match_length = longest_match(s, hash_head);\n          if (\n            s.match_length <= 5 &&\n            (s.strategy === Z_FILTERED || (s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096))\n          ) {\n            s.match_length = MIN_MATCH - 1;\n          }\n        }\n        if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {\n          max_insert = s.strstart + s.lookahead - MIN_MATCH;\n          bflush = trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);\n          s.lookahead -= s.prev_length - 1;\n          s.prev_length -= 2;\n          do {\n            if (++s.strstart <= max_insert) {\n              s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\n              hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n              s.head[s.ins_h] = s.strstart;\n            }\n          } while (--s.prev_length !== 0);\n          s.match_available = 0;\n          s.match_length = MIN_MATCH - 1;\n          s.strstart++;\n          if (bflush) {\n            flush_block_only(s, false);\n            if (s.strm.avail_out === 0) {\n              return BS_NEED_MORE;\n            }\n          }\n        } else if (s.match_available) {\n          bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);\n          if (bflush) {\n            flush_block_only(s, false);\n          }\n          s.strstart++;\n          s.lookahead--;\n          if (s.strm.avail_out === 0) {\n            return BS_NEED_MORE;\n          }\n        } else {\n          s.match_available = 1;\n          s.strstart++;\n          s.lookahead--;\n        }\n      }\n      if (s.match_available) {\n        bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);\n        s.match_available = 0;\n      }\n      s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;\n      if (flush === Z_FINISH) {\n        flush_block_only(s, true);\n        if (s.strm.avail_out === 0) {\n          return BS_FINISH_STARTED;\n        }\n        return BS_FINISH_DONE;\n      }\n      if (s.last_lit) {\n        flush_block_only(s, false);\n        if (s.strm.avail_out === 0) {\n          return BS_NEED_MORE;\n        }\n      }\n      return BS_BLOCK_DONE;\n    }\n    function deflate_rle(s, flush) {\n      var bflush;\n      var prev;\n      var scan, strend;\n      var _win = s.window;\n      for (;;) {\n        if (s.lookahead <= MAX_MATCH) {\n          fill_window(s);\n          if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {\n            return BS_NEED_MORE;\n          }\n          if (s.lookahead === 0) {\n            break;\n          }\n        }\n        s.match_length = 0;\n        if (s.lookahead >= MIN_MATCH && s.strstart > 0) {\n          scan = s.strstart - 1;\n          prev = _win[scan];\n          if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {\n            strend = s.strstart + MAX_MATCH;\n            do {} while (\n              prev === _win[++scan] &&\n              prev === _win[++scan] &&\n              prev === _win[++scan] &&\n              prev === _win[++scan] &&\n              prev === _win[++scan] &&\n              prev === _win[++scan] &&\n              prev === _win[++scan] &&\n              prev === _win[++scan] &&\n              scan < strend\n            );\n            s.match_length = MAX_MATCH - (strend - scan);\n            if (s.match_length > s.lookahead) {\n              s.match_length = s.lookahead;\n            }\n          }\n        }\n        if (s.match_length >= MIN_MATCH) {\n          bflush = trees._tr_tally(s, 1, s.match_length - MIN_MATCH);\n          s.lookahead -= s.match_length;\n          s.strstart += s.match_length;\n          s.match_length = 0;\n        } else {\n          bflush = trees._tr_tally(s, 0, s.window[s.strstart]);\n          s.lookahead--;\n          s.strstart++;\n        }\n        if (bflush) {\n          flush_block_only(s, false);\n          if (s.strm.avail_out === 0) {\n            return BS_NEED_MORE;\n          }\n        }\n      }\n      s.insert = 0;\n      if (flush === Z_FINISH) {\n        flush_block_only(s, true);\n        if (s.strm.avail_out === 0) {\n          return BS_FINISH_STARTED;\n        }\n        return BS_FINISH_DONE;\n      }\n      if (s.last_lit) {\n        flush_block_only(s, false);\n        if (s.strm.avail_out === 0) {\n          return BS_NEED_MORE;\n        }\n      }\n      return BS_BLOCK_DONE;\n    }\n    function deflate_huff(s, flush) {\n      var bflush;\n      for (;;) {\n        if (s.lookahead === 0) {\n          fill_window(s);\n          if (s.lookahead === 0) {\n            if (flush === Z_NO_FLUSH) {\n              return BS_NEED_MORE;\n            }\n            break;\n          }\n        }\n        s.match_length = 0;\n        bflush = trees._tr_tally(s, 0, s.window[s.strstart]);\n        s.lookahead--;\n        s.strstart++;\n        if (bflush) {\n          flush_block_only(s, false);\n          if (s.strm.avail_out === 0) {\n            return BS_NEED_MORE;\n          }\n        }\n      }\n      s.insert = 0;\n      if (flush === Z_FINISH) {\n        flush_block_only(s, true);\n        if (s.strm.avail_out === 0) {\n          return BS_FINISH_STARTED;\n        }\n        return BS_FINISH_DONE;\n      }\n      if (s.last_lit) {\n        flush_block_only(s, false);\n        if (s.strm.avail_out === 0) {\n          return BS_NEED_MORE;\n        }\n      }\n      return BS_BLOCK_DONE;\n    }\n    function Config(good_length, max_lazy, nice_length, max_chain, func) {\n      this.good_length = good_length;\n      this.max_lazy = max_lazy;\n      this.nice_length = nice_length;\n      this.max_chain = max_chain;\n      this.func = func;\n    }\n    var configuration_table;\n    configuration_table = [\n      new Config(0, 0, 0, 0, deflate_stored),\n      new Config(4, 4, 8, 4, deflate_fast),\n      new Config(4, 5, 16, 8, deflate_fast),\n      new Config(4, 6, 32, 32, deflate_fast),\n      new Config(4, 4, 16, 16, deflate_slow),\n      new Config(8, 16, 32, 32, deflate_slow),\n      new Config(8, 16, 128, 128, deflate_slow),\n      new Config(8, 32, 128, 256, deflate_slow),\n      new Config(32, 128, 258, 1024, deflate_slow),\n      new Config(32, 258, 258, 4096, deflate_slow),\n    ];\n    function lm_init(s) {\n      s.window_size = 2 * s.w_size;\n      zero(s.head);\n      s.max_lazy_match = configuration_table[s.level].max_lazy;\n      s.good_match = configuration_table[s.level].good_length;\n      s.nice_match = configuration_table[s.level].nice_length;\n      s.max_chain_length = configuration_table[s.level].max_chain;\n      s.strstart = 0;\n      s.block_start = 0;\n      s.lookahead = 0;\n      s.insert = 0;\n      s.match_length = s.prev_length = MIN_MATCH - 1;\n      s.match_available = 0;\n      s.ins_h = 0;\n    }\n    function DeflateState() {\n      this.strm = null;\n      this.status = 0;\n      this.pending_buf = null;\n      this.pending_buf_size = 0;\n      this.pending_out = 0;\n      this.pending = 0;\n      this.wrap = 0;\n      this.gzhead = null;\n      this.gzindex = 0;\n      this.method = Z_DEFLATED;\n      this.last_flush = -1;\n      this.w_size = 0;\n      this.w_bits = 0;\n      this.w_mask = 0;\n      this.window = null;\n      this.window_size = 0;\n      this.prev = null;\n      this.head = null;\n      this.ins_h = 0;\n      this.hash_size = 0;\n      this.hash_bits = 0;\n      this.hash_mask = 0;\n      this.hash_shift = 0;\n      this.block_start = 0;\n      this.match_length = 0;\n      this.prev_match = 0;\n      this.match_available = 0;\n      this.strstart = 0;\n      this.match_start = 0;\n      this.lookahead = 0;\n      this.prev_length = 0;\n      this.max_chain_length = 0;\n      this.max_lazy_match = 0;\n      this.level = 0;\n      this.strategy = 0;\n      this.good_match = 0;\n      this.nice_match = 0;\n      this.dyn_ltree = new utils.Buf16(HEAP_SIZE * 2);\n      this.dyn_dtree = new utils.Buf16((2 * D_CODES + 1) * 2);\n      this.bl_tree = new utils.Buf16((2 * BL_CODES + 1) * 2);\n      zero(this.dyn_ltree);\n      zero(this.dyn_dtree);\n      zero(this.bl_tree);\n      this.l_desc = null;\n      this.d_desc = null;\n      this.bl_desc = null;\n      this.bl_count = new utils.Buf16(MAX_BITS + 1);\n      this.heap = new utils.Buf16(2 * L_CODES + 1);\n      zero(this.heap);\n      this.heap_len = 0;\n      this.heap_max = 0;\n      this.depth = new utils.Buf16(2 * L_CODES + 1);\n      zero(this.depth);\n      this.l_buf = 0;\n      this.lit_bufsize = 0;\n      this.last_lit = 0;\n      this.d_buf = 0;\n      this.opt_len = 0;\n      this.static_len = 0;\n      this.matches = 0;\n      this.insert = 0;\n      this.bi_buf = 0;\n      this.bi_valid = 0;\n    }\n    function deflateResetKeep(strm) {\n      var s;\n      if (!strm || !strm.state) {\n        return err(strm, Z_STREAM_ERROR);\n      }\n      strm.total_in = strm.total_out = 0;\n      strm.data_type = Z_UNKNOWN;\n      s = strm.state;\n      s.pending = 0;\n      s.pending_out = 0;\n      if (s.wrap < 0) {\n        s.wrap = -s.wrap;\n      }\n      s.status = s.wrap ? INIT_STATE : BUSY_STATE;\n      strm.adler = s.wrap === 2 ? 0 : 1;\n      s.last_flush = Z_NO_FLUSH;\n      trees._tr_init(s);\n      return Z_OK;\n    }\n    function deflateReset(strm) {\n      var ret = deflateResetKeep(strm);\n      if (ret === Z_OK) {\n        lm_init(strm.state);\n      }\n      return ret;\n    }\n    function deflateSetHeader(strm, head) {\n      if (!strm || !strm.state) {\n        return Z_STREAM_ERROR;\n      }\n      if (strm.state.wrap !== 2) {\n        return Z_STREAM_ERROR;\n      }\n      strm.state.gzhead = head;\n      return Z_OK;\n    }\n    function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {\n      if (!strm) {\n        return Z_STREAM_ERROR;\n      }\n      var wrap = 1;\n      if (level === Z_DEFAULT_COMPRESSION) {\n        level = 6;\n      }\n      if (windowBits < 0) {\n        wrap = 0;\n        windowBits = -windowBits;\n      } else if (windowBits > 15) {\n        wrap = 2;\n        windowBits -= 16;\n      }\n      if (\n        memLevel < 1 ||\n        memLevel > MAX_MEM_LEVEL ||\n        method !== Z_DEFLATED ||\n        windowBits < 8 ||\n        windowBits > 15 ||\n        level < 0 ||\n        level > 9 ||\n        strategy < 0 ||\n        strategy > Z_FIXED\n      ) {\n        return err(strm, Z_STREAM_ERROR);\n      }\n      if (windowBits === 8) {\n        windowBits = 9;\n      }\n      var s = new DeflateState();\n      strm.state = s;\n      s.strm = strm;\n      s.wrap = wrap;\n      s.gzhead = null;\n      s.w_bits = windowBits;\n      s.w_size = 1 << s.w_bits;\n      s.w_mask = s.w_size - 1;\n      s.hash_bits = memLevel + 7;\n      s.hash_size = 1 << s.hash_bits;\n      s.hash_mask = s.hash_size - 1;\n      s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);\n      s.window = new utils.Buf8(s.w_size * 2);\n      s.head = new utils.Buf16(s.hash_size);\n      s.prev = new utils.Buf16(s.w_size);\n      s.lit_bufsize = 1 << (memLevel + 6);\n      s.pending_buf_size = s.lit_bufsize * 4;\n      s.pending_buf = new utils.Buf8(s.pending_buf_size);\n      s.d_buf = 1 * s.lit_bufsize;\n      s.l_buf = (1 + 2) * s.lit_bufsize;\n      s.level = level;\n      s.strategy = strategy;\n      s.method = method;\n      return deflateReset(strm);\n    }\n    function deflateInit(strm, level) {\n      return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);\n    }\n    function deflate(strm, flush) {\n      var old_flush, s;\n      var beg, val;\n      if (!strm || !strm.state || flush > Z_BLOCK || flush < 0) {\n        return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;\n      }\n      s = strm.state;\n      if (!strm.output || (!strm.input && strm.avail_in !== 0) || (s.status === FINISH_STATE && flush !== Z_FINISH)) {\n        return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR : Z_STREAM_ERROR);\n      }\n      s.strm = strm;\n      old_flush = s.last_flush;\n      s.last_flush = flush;\n      if (s.status === INIT_STATE) {\n        if (s.wrap === 2) {\n          strm.adler = 0;\n          put_byte(s, 31);\n          put_byte(s, 139);\n          put_byte(s, 8);\n          if (!s.gzhead) {\n            put_byte(s, 0);\n            put_byte(s, 0);\n            put_byte(s, 0);\n            put_byte(s, 0);\n            put_byte(s, 0);\n            put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);\n            put_byte(s, OS_CODE);\n            s.status = BUSY_STATE;\n          } else {\n            put_byte(\n              s,\n              (s.gzhead.text ? 1 : 0) +\n                (s.gzhead.hcrc ? 2 : 0) +\n                (!s.gzhead.extra ? 0 : 4) +\n                (!s.gzhead.name ? 0 : 8) +\n                (!s.gzhead.comment ? 0 : 16),\n            );\n            put_byte(s, s.gzhead.time & 255);\n            put_byte(s, (s.gzhead.time >> 8) & 255);\n            put_byte(s, (s.gzhead.time >> 16) & 255);\n            put_byte(s, (s.gzhead.time >> 24) & 255);\n            put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);\n            put_byte(s, s.gzhead.os & 255);\n            if (s.gzhead.extra && s.gzhead.extra.length) {\n              put_byte(s, s.gzhead.extra.length & 255);\n              put_byte(s, (s.gzhead.extra.length >> 8) & 255);\n            }\n            if (s.gzhead.hcrc) {\n              strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);\n            }\n            s.gzindex = 0;\n            s.status = EXTRA_STATE;\n          }\n        } else {\n          var header = (Z_DEFLATED + ((s.w_bits - 8) << 4)) << 8;\n          var level_flags = -1;\n          if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {\n            level_flags = 0;\n          } else if (s.level < 6) {\n            level_flags = 1;\n          } else if (s.level === 6) {\n            level_flags = 2;\n          } else {\n            level_flags = 3;\n          }\n          header |= level_flags << 6;\n          if (s.strstart !== 0) {\n            header |= PRESET_DICT;\n          }\n          header += 31 - (header % 31);\n          s.status = BUSY_STATE;\n          putShortMSB(s, header);\n          if (s.strstart !== 0) {\n            putShortMSB(s, strm.adler >>> 16);\n            putShortMSB(s, strm.adler & 65535);\n          }\n          strm.adler = 1;\n        }\n      }\n      if (s.status === EXTRA_STATE) {\n        if (s.gzhead.extra) {\n          beg = s.pending;\n          while (s.gzindex < (s.gzhead.extra.length & 65535)) {\n            if (s.pending === s.pending_buf_size) {\n              if (s.gzhead.hcrc && s.pending > beg) {\n                strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n              }\n              flush_pending(strm);\n              beg = s.pending;\n              if (s.pending === s.pending_buf_size) {\n                break;\n              }\n            }\n            put_byte(s, s.gzhead.extra[s.gzindex] & 255);\n            s.gzindex++;\n          }\n          if (s.gzhead.hcrc && s.pending > beg) {\n            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n          }\n          if (s.gzindex === s.gzhead.extra.length) {\n            s.gzindex = 0;\n            s.status = NAME_STATE;\n          }\n        } else {\n          s.status = NAME_STATE;\n        }\n      }\n      if (s.status === NAME_STATE) {\n        if (s.gzhead.name) {\n          beg = s.pending;\n          do {\n            if (s.pending === s.pending_buf_size) {\n              if (s.gzhead.hcrc && s.pending > beg) {\n                strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n              }\n              flush_pending(strm);\n              beg = s.pending;\n              if (s.pending === s.pending_buf_size) {\n                val = 1;\n                break;\n              }\n            }\n            if (s.gzindex < s.gzhead.name.length) {\n              val = s.gzhead.name.charCodeAt(s.gzindex++) & 255;\n            } else {\n              val = 0;\n            }\n            put_byte(s, val);\n          } while (val !== 0);\n          if (s.gzhead.hcrc && s.pending > beg) {\n            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n          }\n          if (val === 0) {\n            s.gzindex = 0;\n            s.status = COMMENT_STATE;\n          }\n        } else {\n          s.status = COMMENT_STATE;\n        }\n      }\n      if (s.status === COMMENT_STATE) {\n        if (s.gzhead.comment) {\n          beg = s.pending;\n          do {\n            if (s.pending === s.pending_buf_size) {\n              if (s.gzhead.hcrc && s.pending > beg) {\n                strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n              }\n              flush_pending(strm);\n              beg = s.pending;\n              if (s.pending === s.pending_buf_size) {\n                val = 1;\n                break;\n              }\n            }\n            if (s.gzindex < s.gzhead.comment.length) {\n              val = s.gzhead.comment.charCodeAt(s.gzindex++) & 255;\n            } else {\n              val = 0;\n            }\n            put_byte(s, val);\n          } while (val !== 0);\n          if (s.gzhead.hcrc && s.pending > beg) {\n            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n          }\n          if (val === 0) {\n            s.status = HCRC_STATE;\n          }\n        } else {\n          s.status = HCRC_STATE;\n        }\n      }\n      if (s.status === HCRC_STATE) {\n        if (s.gzhead.hcrc) {\n          if (s.pending + 2 > s.pending_buf_size) {\n            flush_pending(strm);\n          }\n          if (s.pending + 2 <= s.pending_buf_size) {\n            put_byte(s, strm.adler & 255);\n            put_byte(s, (strm.adler >> 8) & 255);\n            strm.adler = 0;\n            s.status = BUSY_STATE;\n          }\n        } else {\n          s.status = BUSY_STATE;\n        }\n      }\n      if (s.pending !== 0) {\n        flush_pending(strm);\n        if (strm.avail_out === 0) {\n          s.last_flush = -1;\n          return Z_OK;\n        }\n      } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH) {\n        return err(strm, Z_BUF_ERROR);\n      }\n      if (s.status === FINISH_STATE && strm.avail_in !== 0) {\n        return err(strm, Z_BUF_ERROR);\n      }\n      if (strm.avail_in !== 0 || s.lookahead !== 0 || (flush !== Z_NO_FLUSH && s.status !== FINISH_STATE)) {\n        var bstate =\n          s.strategy === Z_HUFFMAN_ONLY\n            ? deflate_huff(s, flush)\n            : s.strategy === Z_RLE\n            ? deflate_rle(s, flush)\n            : configuration_table[s.level].func(s, flush);\n        if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {\n          s.status = FINISH_STATE;\n        }\n        if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {\n          if (strm.avail_out === 0) {\n            s.last_flush = -1;\n          }\n          return Z_OK;\n        }\n        if (bstate === BS_BLOCK_DONE) {\n          if (flush === Z_PARTIAL_FLUSH) {\n            trees._tr_align(s);\n          } else if (flush !== Z_BLOCK) {\n            trees._tr_stored_block(s, 0, 0, false);\n            if (flush === Z_FULL_FLUSH) {\n              zero(s.head);\n              if (s.lookahead === 0) {\n                s.strstart = 0;\n                s.block_start = 0;\n                s.insert = 0;\n              }\n            }\n          }\n          flush_pending(strm);\n          if (strm.avail_out === 0) {\n            s.last_flush = -1;\n            return Z_OK;\n          }\n        }\n      }\n      if (flush !== Z_FINISH) {\n        return Z_OK;\n      }\n      if (s.wrap <= 0) {\n        return Z_STREAM_END;\n      }\n      if (s.wrap === 2) {\n        put_byte(s, strm.adler & 255);\n        put_byte(s, (strm.adler >> 8) & 255);\n        put_byte(s, (strm.adler >> 16) & 255);\n        put_byte(s, (strm.adler >> 24) & 255);\n        put_byte(s, strm.total_in & 255);\n        put_byte(s, (strm.total_in >> 8) & 255);\n        put_byte(s, (strm.total_in >> 16) & 255);\n        put_byte(s, (strm.total_in >> 24) & 255);\n      } else {\n        putShortMSB(s, strm.adler >>> 16);\n        putShortMSB(s, strm.adler & 65535);\n      }\n      flush_pending(strm);\n      if (s.wrap > 0) {\n        s.wrap = -s.wrap;\n      }\n      return s.pending !== 0 ? Z_OK : Z_STREAM_END;\n    }\n    function deflateEnd(strm) {\n      var status;\n      if (!strm || !strm.state) {\n        return Z_STREAM_ERROR;\n      }\n      status = strm.state.status;\n      if (\n        status !== INIT_STATE &&\n        status !== EXTRA_STATE &&\n        status !== NAME_STATE &&\n        status !== COMMENT_STATE &&\n        status !== HCRC_STATE &&\n        status !== BUSY_STATE &&\n        status !== FINISH_STATE\n      ) {\n        return err(strm, Z_STREAM_ERROR);\n      }\n      strm.state = null;\n      return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;\n    }\n    function deflateSetDictionary(strm, dictionary) {\n      var dictLength = dictionary.length;\n      var s;\n      var str, n;\n      var wrap;\n      var avail;\n      var next;\n      var input;\n      var tmpDict;\n      if (!strm || !strm.state) {\n        return Z_STREAM_ERROR;\n      }\n      s = strm.state;\n      wrap = s.wrap;\n      if (wrap === 2 || (wrap === 1 && s.status !== INIT_STATE) || s.lookahead) {\n        return Z_STREAM_ERROR;\n      }\n      if (wrap === 1) {\n        strm.adler = adler32(strm.adler, dictionary, dictLength, 0);\n      }\n      s.wrap = 0;\n      if (dictLength >= s.w_size) {\n        if (wrap === 0) {\n          zero(s.head);\n          s.strstart = 0;\n          s.block_start = 0;\n          s.insert = 0;\n        }\n        tmpDict = new utils.Buf8(s.w_size);\n        utils.arraySet(tmpDict, dictionary, dictLength - s.w_size, s.w_size, 0);\n        dictionary = tmpDict;\n        dictLength = s.w_size;\n      }\n      avail = strm.avail_in;\n      next = strm.next_in;\n      input = strm.input;\n      strm.avail_in = dictLength;\n      strm.next_in = 0;\n      strm.input = dictionary;\n      fill_window(s);\n      while (s.lookahead >= MIN_MATCH) {\n        str = s.strstart;\n        n = s.lookahead - (MIN_MATCH - 1);\n        do {\n          s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;\n          s.prev[str & s.w_mask] = s.head[s.ins_h];\n          s.head[s.ins_h] = str;\n          str++;\n        } while (--n);\n        s.strstart = str;\n        s.lookahead = MIN_MATCH - 1;\n        fill_window(s);\n      }\n      s.strstart += s.lookahead;\n      s.block_start = s.strstart;\n      s.insert = s.lookahead;\n      s.lookahead = 0;\n      s.match_length = s.prev_length = MIN_MATCH - 1;\n      s.match_available = 0;\n      strm.next_in = next;\n      strm.input = input;\n      strm.avail_in = avail;\n      s.wrap = wrap;\n      return Z_OK;\n    }\n    exports.deflateInit = deflateInit;\n    exports.deflateInit2 = deflateInit2;\n    exports.deflateReset = deflateReset;\n    exports.deflateResetKeep = deflateResetKeep;\n    exports.deflateSetHeader = deflateSetHeader;\n    exports.deflate = deflate;\n    exports.deflateEnd = deflateEnd;\n    exports.deflateSetDictionary = deflateSetDictionary;\n    exports.deflateInfo = \"pako deflate (from Nodeca project)\";\n  },\n});\n\n// node_modules/pako/lib/zlib/inffast.js\nvar require_inffast = __commonJS({\n  \"node_modules/pako/lib/zlib/inffast.js\"(exports, module2) {\n    \"use strict\";\n    var BAD = 30;\n    var TYPE = 12;\n    module2.exports = function inflate_fast(strm, start) {\n      var state;\n      var _in;\n      var last;\n      var _out;\n      var beg;\n      var end;\n      var dmax;\n      var wsize;\n      var whave;\n      var wnext;\n      var s_window;\n      var hold;\n      var bits;\n      var lcode;\n      var dcode;\n      var lmask;\n      var dmask;\n      var here;\n      var op;\n      var len;\n      var dist;\n      var from;\n      var from_source;\n      var input, output;\n      state = strm.state;\n      _in = strm.next_in;\n      input = strm.input;\n      last = _in + (strm.avail_in - 5);\n      _out = strm.next_out;\n      output = strm.output;\n      beg = _out - (start - strm.avail_out);\n      end = _out + (strm.avail_out - 257);\n      dmax = state.dmax;\n      wsize = state.wsize;\n      whave = state.whave;\n      wnext = state.wnext;\n      s_window = state.window;\n      hold = state.hold;\n      bits = state.bits;\n      lcode = state.lencode;\n      dcode = state.distcode;\n      lmask = (1 << state.lenbits) - 1;\n      dmask = (1 << state.distbits) - 1;\n      top: do {\n        if (bits < 15) {\n          hold += input[_in++] << bits;\n          bits += 8;\n          hold += input[_in++] << bits;\n          bits += 8;\n        }\n        here = lcode[hold & lmask];\n        dolen: for (;;) {\n          op = here >>> 24;\n          hold >>>= op;\n          bits -= op;\n          op = (here >>> 16) & 255;\n          if (op === 0) {\n            output[_out++] = here & 65535;\n          } else if (op & 16) {\n            len = here & 65535;\n            op &= 15;\n            if (op) {\n              if (bits < op) {\n                hold += input[_in++] << bits;\n                bits += 8;\n              }\n              len += hold & ((1 << op) - 1);\n              hold >>>= op;\n              bits -= op;\n            }\n            if (bits < 15) {\n              hold += input[_in++] << bits;\n              bits += 8;\n              hold += input[_in++] << bits;\n              bits += 8;\n            }\n            here = dcode[hold & dmask];\n            dodist: for (;;) {\n              op = here >>> 24;\n              hold >>>= op;\n              bits -= op;\n              op = (here >>> 16) & 255;\n              if (op & 16) {\n                dist = here & 65535;\n                op &= 15;\n                if (bits < op) {\n                  hold += input[_in++] << bits;\n                  bits += 8;\n                  if (bits < op) {\n                    hold += input[_in++] << bits;\n                    bits += 8;\n                  }\n                }\n                dist += hold & ((1 << op) - 1);\n                if (dist > dmax) {\n                  strm.msg = \"invalid distance too far back\";\n                  state.mode = BAD;\n                  break top;\n                }\n                hold >>>= op;\n                bits -= op;\n                op = _out - beg;\n                if (dist > op) {\n                  op = dist - op;\n                  if (op > whave) {\n                    if (state.sane) {\n                      strm.msg = \"invalid distance too far back\";\n                      state.mode = BAD;\n                      break top;\n                    }\n                  }\n                  from = 0;\n                  from_source = s_window;\n                  if (wnext === 0) {\n                    from += wsize - op;\n                    if (op < len) {\n                      len -= op;\n                      do {\n                        output[_out++] = s_window[from++];\n                      } while (--op);\n                      from = _out - dist;\n                      from_source = output;\n                    }\n                  } else if (wnext < op) {\n                    from += wsize + wnext - op;\n                    op -= wnext;\n                    if (op < len) {\n                      len -= op;\n                      do {\n                        output[_out++] = s_window[from++];\n                      } while (--op);\n                      from = 0;\n                      if (wnext < len) {\n                        op = wnext;\n                        len -= op;\n                        do {\n                          output[_out++] = s_window[from++];\n                        } while (--op);\n                        from = _out - dist;\n                        from_source = output;\n                      }\n                    }\n                  } else {\n                    from += wnext - op;\n                    if (op < len) {\n                      len -= op;\n                      do {\n                        output[_out++] = s_window[from++];\n                      } while (--op);\n                      from = _out - dist;\n                      from_source = output;\n                    }\n                  }\n                  while (len > 2) {\n                    output[_out++] = from_source[from++];\n                    output[_out++] = from_source[from++];\n                    output[_out++] = from_source[from++];\n                    len -= 3;\n                  }\n                  if (len) {\n                    output[_out++] = from_source[from++];\n                    if (len > 1) {\n                      output[_out++] = from_source[from++];\n                    }\n                  }\n                } else {\n                  from = _out - dist;\n                  do {\n                    output[_out++] = output[from++];\n                    output[_out++] = output[from++];\n                    output[_out++] = output[from++];\n                    len -= 3;\n                  } while (len > 2);\n                  if (len) {\n                    output[_out++] = output[from++];\n                    if (len > 1) {\n                      output[_out++] = output[from++];\n                    }\n                  }\n                }\n              } else if ((op & 64) === 0) {\n                here = dcode[(here & 65535) + (hold & ((1 << op) - 1))];\n                continue dodist;\n              } else {\n                strm.msg = \"invalid distance code\";\n                state.mode = BAD;\n                break top;\n              }\n              break;\n            }\n          } else if ((op & 64) === 0) {\n            here = lcode[(here & 65535) + (hold & ((1 << op) - 1))];\n            continue dolen;\n          } else if (op & 32) {\n            state.mode = TYPE;\n            break top;\n          } else {\n            strm.msg = \"invalid literal/length code\";\n            state.mode = BAD;\n            break top;\n          }\n          break;\n        }\n      } while (_in < last && _out < end);\n      len = bits >> 3;\n      _in -= len;\n      bits -= len << 3;\n      hold &= (1 << bits) - 1;\n      strm.next_in = _in;\n      strm.next_out = _out;\n      strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last);\n      strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);\n      state.hold = hold;\n      state.bits = bits;\n      return;\n    };\n  },\n});\n\n// node_modules/pako/lib/zlib/inftrees.js\nvar require_inftrees = __commonJS({\n  \"node_modules/pako/lib/zlib/inftrees.js\"(exports, module2) {\n    \"use strict\";\n    var utils = require_common();\n    var MAXBITS = 15;\n    var ENOUGH_LENS = 852;\n    var ENOUGH_DISTS = 592;\n    var CODES = 0;\n    var LENS = 1;\n    var DISTS = 2;\n    var lbase = [\n      3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258,\n      0, 0,\n    ];\n    var lext = [\n      16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21,\n      16, 72, 78,\n    ];\n    var dbase = [\n      1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,\n      8193, 12289, 16385, 24577, 0, 0,\n    ];\n    var dext = [\n      16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28,\n      29, 29, 64, 64,\n    ];\n    module2.exports = function inflate_table(type, lens, lens_index, codes, table, table_index, work, opts) {\n      var bits = opts.bits;\n      var len = 0;\n      var sym = 0;\n      var min = 0,\n        max = 0;\n      var root = 0;\n      var curr = 0;\n      var drop = 0;\n      var left = 0;\n      var used = 0;\n      var huff = 0;\n      var incr;\n      var fill;\n      var low;\n      var mask;\n      var next;\n      var base = null;\n      var base_index = 0;\n      var end;\n      var count = new utils.Buf16(MAXBITS + 1);\n      var offs = new utils.Buf16(MAXBITS + 1);\n      var extra = null;\n      var extra_index = 0;\n      var here_bits, here_op, here_val;\n      for (len = 0; len <= MAXBITS; len++) {\n        count[len] = 0;\n      }\n      for (sym = 0; sym < codes; sym++) {\n        count[lens[lens_index + sym]]++;\n      }\n      root = bits;\n      for (max = MAXBITS; max >= 1; max--) {\n        if (count[max] !== 0) {\n          break;\n        }\n      }\n      if (root > max) {\n        root = max;\n      }\n      if (max === 0) {\n        table[table_index++] = (1 << 24) | (64 << 16) | 0;\n        table[table_index++] = (1 << 24) | (64 << 16) | 0;\n        opts.bits = 1;\n        return 0;\n      }\n      for (min = 1; min < max; min++) {\n        if (count[min] !== 0) {\n          break;\n        }\n      }\n      if (root < min) {\n        root = min;\n      }\n      left = 1;\n      for (len = 1; len <= MAXBITS; len++) {\n        left <<= 1;\n        left -= count[len];\n        if (left < 0) {\n          return -1;\n        }\n      }\n      if (left > 0 && (type === CODES || max !== 1)) {\n        return -1;\n      }\n      offs[1] = 0;\n      for (len = 1; len < MAXBITS; len++) {\n        offs[len + 1] = offs[len] + count[len];\n      }\n      for (sym = 0; sym < codes; sym++) {\n        if (lens[lens_index + sym] !== 0) {\n          work[offs[lens[lens_index + sym]]++] = sym;\n        }\n      }\n      if (type === CODES) {\n        base = extra = work;\n        end = 19;\n      } else if (type === LENS) {\n        base = lbase;\n        base_index -= 257;\n        extra = lext;\n        extra_index -= 257;\n        end = 256;\n      } else {\n        base = dbase;\n        extra = dext;\n        end = -1;\n      }\n      huff = 0;\n      sym = 0;\n      len = min;\n      next = table_index;\n      curr = root;\n      drop = 0;\n      low = -1;\n      used = 1 << root;\n      mask = used - 1;\n      if ((type === LENS && used > ENOUGH_LENS) || (type === DISTS && used > ENOUGH_DISTS)) {\n        return 1;\n      }\n      for (;;) {\n        here_bits = len - drop;\n        if (work[sym] < end) {\n          here_op = 0;\n          here_val = work[sym];\n        } else if (work[sym] > end) {\n          here_op = extra[extra_index + work[sym]];\n          here_val = base[base_index + work[sym]];\n        } else {\n          here_op = 32 + 64;\n          here_val = 0;\n        }\n        incr = 1 << (len - drop);\n        fill = 1 << curr;\n        min = fill;\n        do {\n          fill -= incr;\n          table[next + (huff >> drop) + fill] = (here_bits << 24) | (here_op << 16) | here_val | 0;\n        } while (fill !== 0);\n        incr = 1 << (len - 1);\n        while (huff & incr) {\n          incr >>= 1;\n        }\n        if (incr !== 0) {\n          huff &= incr - 1;\n          huff += incr;\n        } else {\n          huff = 0;\n        }\n        sym++;\n        if (--count[len] === 0) {\n          if (len === max) {\n            break;\n          }\n          len = lens[lens_index + work[sym]];\n        }\n        if (len > root && (huff & mask) !== low) {\n          if (drop === 0) {\n            drop = root;\n          }\n          next += min;\n          curr = len - drop;\n          left = 1 << curr;\n          while (curr + drop < max) {\n            left -= count[curr + drop];\n            if (left <= 0) {\n              break;\n            }\n            curr++;\n            left <<= 1;\n          }\n          used += 1 << curr;\n          if ((type === LENS && used > ENOUGH_LENS) || (type === DISTS && used > ENOUGH_DISTS)) {\n            return 1;\n          }\n          low = huff & mask;\n          table[low] = (root << 24) | (curr << 16) | (next - table_index) | 0;\n        }\n      }\n      if (huff !== 0) {\n        table[next + huff] = ((len - drop) << 24) | (64 << 16) | 0;\n      }\n      opts.bits = root;\n      return 0;\n    };\n  },\n});\n\n// node_modules/pako/lib/zlib/inflate.js\nvar require_inflate = __commonJS({\n  \"node_modules/pako/lib/zlib/inflate.js\"(exports) {\n    \"use strict\";\n    var utils = require_common();\n    var adler32 = require_adler32();\n    var crc32 = require_crc32();\n    var inflate_fast = require_inffast();\n    var inflate_table = require_inftrees();\n    var CODES = 0;\n    var LENS = 1;\n    var DISTS = 2;\n    var Z_FINISH = 4;\n    var Z_BLOCK = 5;\n    var Z_TREES = 6;\n    var Z_OK = 0;\n    var Z_STREAM_END = 1;\n    var Z_NEED_DICT = 2;\n    var Z_STREAM_ERROR = -2;\n    var Z_DATA_ERROR = -3;\n    var Z_MEM_ERROR = -4;\n    var Z_BUF_ERROR = -5;\n    var Z_DEFLATED = 8;\n    var HEAD = 1;\n    var FLAGS = 2;\n    var TIME = 3;\n    var OS = 4;\n    var EXLEN = 5;\n    var EXTRA = 6;\n    var NAME = 7;\n    var COMMENT = 8;\n    var HCRC = 9;\n    var DICTID = 10;\n    var DICT = 11;\n    var TYPE = 12;\n    var TYPEDO = 13;\n    var STORED = 14;\n    var COPY_ = 15;\n    var COPY = 16;\n    var TABLE = 17;\n    var LENLENS = 18;\n    var CODELENS = 19;\n    var LEN_ = 20;\n    var LEN = 21;\n    var LENEXT = 22;\n    var DIST = 23;\n    var DISTEXT = 24;\n    var MATCH = 25;\n    var LIT = 26;\n    var CHECK = 27;\n    var LENGTH = 28;\n    var DONE = 29;\n    var BAD = 30;\n    var MEM = 31;\n    var SYNC = 32;\n    var ENOUGH_LENS = 852;\n    var ENOUGH_DISTS = 592;\n    var MAX_WBITS = 15;\n    var DEF_WBITS = MAX_WBITS;\n    function zswap32(q) {\n      return ((q >>> 24) & 255) + ((q >>> 8) & 65280) + ((q & 65280) << 8) + ((q & 255) << 24);\n    }\n    function InflateState() {\n      this.mode = 0;\n      this.last = false;\n      this.wrap = 0;\n      this.havedict = false;\n      this.flags = 0;\n      this.dmax = 0;\n      this.check = 0;\n      this.total = 0;\n      this.head = null;\n      this.wbits = 0;\n      this.wsize = 0;\n      this.whave = 0;\n      this.wnext = 0;\n      this.window = null;\n      this.hold = 0;\n      this.bits = 0;\n      this.length = 0;\n      this.offset = 0;\n      this.extra = 0;\n      this.lencode = null;\n      this.distcode = null;\n      this.lenbits = 0;\n      this.distbits = 0;\n      this.ncode = 0;\n      this.nlen = 0;\n      this.ndist = 0;\n      this.have = 0;\n      this.next = null;\n      this.lens = new utils.Buf16(320);\n      this.work = new utils.Buf16(288);\n      this.lendyn = null;\n      this.distdyn = null;\n      this.sane = 0;\n      this.back = 0;\n      this.was = 0;\n    }\n    function inflateResetKeep(strm) {\n      var state;\n      if (!strm || !strm.state) {\n        return Z_STREAM_ERROR;\n      }\n      state = strm.state;\n      strm.total_in = strm.total_out = state.total = 0;\n      strm.msg = \"\";\n      if (state.wrap) {\n        strm.adler = state.wrap & 1;\n      }\n      state.mode = HEAD;\n      state.last = 0;\n      state.havedict = 0;\n      state.dmax = 32768;\n      state.head = null;\n      state.hold = 0;\n      state.bits = 0;\n      state.lencode = state.lendyn = new utils.Buf32(ENOUGH_LENS);\n      state.distcode = state.distdyn = new utils.Buf32(ENOUGH_DISTS);\n      state.sane = 1;\n      state.back = -1;\n      return Z_OK;\n    }\n    function inflateReset(strm) {\n      var state;\n      if (!strm || !strm.state) {\n        return Z_STREAM_ERROR;\n      }\n      state = strm.state;\n      state.wsize = 0;\n      state.whave = 0;\n      state.wnext = 0;\n      return inflateResetKeep(strm);\n    }\n    function inflateReset2(strm, windowBits) {\n      var wrap;\n      var state;\n      if (!strm || !strm.state) {\n        return Z_STREAM_ERROR;\n      }\n      state = strm.state;\n      if (windowBits < 0) {\n        wrap = 0;\n        windowBits = -windowBits;\n      } else {\n        wrap = (windowBits >> 4) + 1;\n        if (windowBits < 48) {\n          windowBits &= 15;\n        }\n      }\n      if (windowBits && (windowBits < 8 || windowBits > 15)) {\n        return Z_STREAM_ERROR;\n      }\n      if (state.window !== null && state.wbits !== windowBits) {\n        state.window = null;\n      }\n      state.wrap = wrap;\n      state.wbits = windowBits;\n      return inflateReset(strm);\n    }\n    function inflateInit2(strm, windowBits) {\n      var ret;\n      var state;\n      if (!strm) {\n        return Z_STREAM_ERROR;\n      }\n      state = new InflateState();\n      strm.state = state;\n      state.window = null;\n      ret = inflateReset2(strm, windowBits);\n      if (ret !== Z_OK) {\n        strm.state = null;\n      }\n      return ret;\n    }\n    function inflateInit(strm) {\n      return inflateInit2(strm, DEF_WBITS);\n    }\n    var virgin = true;\n    var lenfix;\n    var distfix;\n    function fixedtables(state) {\n      if (virgin) {\n        var sym;\n        lenfix = new utils.Buf32(512);\n        distfix = new utils.Buf32(32);\n        sym = 0;\n        while (sym < 144) {\n          state.lens[sym++] = 8;\n        }\n        while (sym < 256) {\n          state.lens[sym++] = 9;\n        }\n        while (sym < 280) {\n          state.lens[sym++] = 7;\n        }\n        while (sym < 288) {\n          state.lens[sym++] = 8;\n        }\n        inflate_table(LENS, state.lens, 0, 288, lenfix, 0, state.work, {\n          bits: 9,\n        });\n        sym = 0;\n        while (sym < 32) {\n          state.lens[sym++] = 5;\n        }\n        inflate_table(DISTS, state.lens, 0, 32, distfix, 0, state.work, {\n          bits: 5,\n        });\n        virgin = false;\n      }\n      state.lencode = lenfix;\n      state.lenbits = 9;\n      state.distcode = distfix;\n      state.distbits = 5;\n    }\n    function updatewindow(strm, src, end, copy) {\n      var dist;\n      var state = strm.state;\n      if (state.window === null) {\n        state.wsize = 1 << state.wbits;\n        state.wnext = 0;\n        state.whave = 0;\n        state.window = new utils.Buf8(state.wsize);\n      }\n      if (copy >= state.wsize) {\n        utils.arraySet(state.window, src, end - state.wsize, state.wsize, 0);\n        state.wnext = 0;\n        state.whave = state.wsize;\n      } else {\n        dist = state.wsize - state.wnext;\n        if (dist > copy) {\n          dist = copy;\n        }\n        utils.arraySet(state.window, src, end - copy, dist, state.wnext);\n        copy -= dist;\n        if (copy) {\n          utils.arraySet(state.window, src, end - copy, copy, 0);\n          state.wnext = copy;\n          state.whave = state.wsize;\n        } else {\n          state.wnext += dist;\n          if (state.wnext === state.wsize) {\n            state.wnext = 0;\n          }\n          if (state.whave < state.wsize) {\n            state.whave += dist;\n          }\n        }\n      }\n      return 0;\n    }\n    function inflate(strm, flush) {\n      var state;\n      var input, output;\n      var next;\n      var put;\n      var have, left;\n      var hold;\n      var bits;\n      var _in, _out;\n      var copy;\n      var from;\n      var from_source;\n      var here = 0;\n      var here_bits, here_op, here_val;\n      var last_bits, last_op, last_val;\n      var len;\n      var ret;\n      var hbuf = new utils.Buf8(4);\n      var opts;\n      var n;\n      var order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];\n      if (!strm || !strm.state || !strm.output || (!strm.input && strm.avail_in !== 0)) {\n        return Z_STREAM_ERROR;\n      }\n      state = strm.state;\n      if (state.mode === TYPE) {\n        state.mode = TYPEDO;\n      }\n      put = strm.next_out;\n      output = strm.output;\n      left = strm.avail_out;\n      next = strm.next_in;\n      input = strm.input;\n      have = strm.avail_in;\n      hold = state.hold;\n      bits = state.bits;\n      _in = have;\n      _out = left;\n      ret = Z_OK;\n      inf_leave: for (;;) {\n        switch (state.mode) {\n          case HEAD:\n            if (state.wrap === 0) {\n              state.mode = TYPEDO;\n              break;\n            }\n            while (bits < 16) {\n              if (have === 0) {\n                break inf_leave;\n              }\n              have--;\n              hold += input[next++] << bits;\n              bits += 8;\n            }\n            if (state.wrap & 2 && hold === 35615) {\n              state.check = 0;\n              hbuf[0] = hold & 255;\n              hbuf[1] = (hold >>> 8) & 255;\n              state.check = crc32(state.check, hbuf, 2, 0);\n              hold = 0;\n              bits = 0;\n              state.mode = FLAGS;\n              break;\n            }\n            state.flags = 0;\n            if (state.head) {\n              state.head.done = false;\n            }\n            if (!(state.wrap & 1) || (((hold & 255) << 8) + (hold >> 8)) % 31) {\n              strm.msg = \"incorrect header check\";\n              state.mode = BAD;\n              break;\n            }\n            if ((hold & 15) !== Z_DEFLATED) {\n              strm.msg = \"unknown compression method\";\n              state.mode = BAD;\n              break;\n            }\n            hold >>>= 4;\n            bits -= 4;\n            len = (hold & 15) + 8;\n            if (state.wbits === 0) {\n              state.wbits = len;\n            } else if (len > state.wbits) {\n              strm.msg = \"invalid window size\";\n              state.mode = BAD;\n              break;\n            }\n            state.dmax = 1 << len;\n            strm.adler = state.check = 1;\n            state.mode = hold & 512 ? DICTID : TYPE;\n            hold = 0;\n            bits = 0;\n            break;\n          case FLAGS:\n            while (bits < 16) {\n              if (have === 0) {\n                break inf_leave;\n              }\n              have--;\n              hold += input[next++] << bits;\n              bits += 8;\n            }\n            state.flags = hold;\n            if ((state.flags & 255) !== Z_DEFLATED) {\n              strm.msg = \"unknown compression method\";\n              state.mode = BAD;\n              break;\n            }\n            if (state.flags & 57344) {\n              strm.msg = \"unknown header flags set\";\n              state.mode = BAD;\n              break;\n            }\n            if (state.head) {\n              state.head.text = (hold >> 8) & 1;\n            }\n            if (state.flags & 512) {\n              hbuf[0] = hold & 255;\n              hbuf[1] = (hold >>> 8) & 255;\n              state.check = crc32(state.check, hbuf, 2, 0);\n            }\n            hold = 0;\n            bits = 0;\n            state.mode = TIME;\n          case TIME:\n            while (bits < 32) {\n              if (have === 0) {\n                break inf_leave;\n              }\n              have--;\n              hold += input[next++] << bits;\n              bits += 8;\n            }\n            if (state.head) {\n              state.head.time = hold;\n            }\n            if (state.flags & 512) {\n              hbuf[0] = hold & 255;\n              hbuf[1] = (hold >>> 8) & 255;\n              hbuf[2] = (hold >>> 16) & 255;\n              hbuf[3] = (hold >>> 24) & 255;\n              state.check = crc32(state.check, hbuf, 4, 0);\n            }\n            hold = 0;\n            bits = 0;\n            state.mode = OS;\n          case OS:\n            while (bits < 16) {\n              if (have === 0) {\n                break inf_leave;\n              }\n              have--;\n              hold += input[next++] << bits;\n              bits += 8;\n            }\n            if (state.head) {\n              state.head.xflags = hold & 255;\n              state.head.os = hold >> 8;\n            }\n            if (state.flags & 512) {\n              hbuf[0] = hold & 255;\n              hbuf[1] = (hold >>> 8) & 255;\n              state.check = crc32(state.check, hbuf, 2, 0);\n            }\n            hold = 0;\n            bits = 0;\n            state.mode = EXLEN;\n          case EXLEN:\n            if (state.flags & 1024) {\n              while (bits < 16) {\n                if (have === 0) {\n                  break inf_leave;\n                }\n                have--;\n                hold += input[next++] << bits;\n                bits += 8;\n              }\n              state.length = hold;\n              if (state.head) {\n                state.head.extra_len = hold;\n              }\n              if (state.flags & 512) {\n                hbuf[0] = hold & 255;\n                hbuf[1] = (hold >>> 8) & 255;\n                state.check = crc32(state.check, hbuf, 2, 0);\n              }\n              hold = 0;\n              bits = 0;\n            } else if (state.head) {\n              state.head.extra = null;\n            }\n            state.mode = EXTRA;\n          case EXTRA:\n            if (state.flags & 1024) {\n              copy = state.length;\n              if (copy > have) {\n                copy = have;\n              }\n              if (copy) {\n                if (state.head) {\n                  len = state.head.extra_len - state.length;\n                  if (!state.head.extra) {\n                    state.head.extra = new Array(state.head.extra_len);\n                  }\n                  utils.arraySet(state.head.extra, input, next, copy, len);\n                }\n                if (state.flags & 512) {\n                  state.check = crc32(state.check, input, copy, next);\n                }\n                have -= copy;\n                next += copy;\n                state.length -= copy;\n              }\n              if (state.length) {\n                break inf_leave;\n              }\n            }\n            state.length = 0;\n            state.mode = NAME;\n          case NAME:\n            if (state.flags & 2048) {\n              if (have === 0) {\n                break inf_leave;\n              }\n              copy = 0;\n              do {\n                len = input[next + copy++];\n                if (state.head && len && state.length < 65536) {\n                  state.head.name += String.fromCharCode(len);\n                }\n              } while (len && copy < have);\n              if (state.flags & 512) {\n                state.check = crc32(state.check, input, copy, next);\n              }\n              have -= copy;\n              next += copy;\n              if (len) {\n                break inf_leave;\n              }\n            } else if (state.head) {\n              state.head.name = null;\n            }\n            state.length = 0;\n            state.mode = COMMENT;\n          case COMMENT:\n            if (state.flags & 4096) {\n              if (have === 0) {\n                break inf_leave;\n              }\n              copy = 0;\n              do {\n                len = input[next + copy++];\n                if (state.head && len && state.length < 65536) {\n                  state.head.comment += String.fromCharCode(len);\n                }\n              } while (len && copy < have);\n              if (state.flags & 512) {\n                state.check = crc32(state.check, input, copy, next);\n              }\n              have -= copy;\n              next += copy;\n              if (len) {\n                break inf_leave;\n              }\n            } else if (state.head) {\n              state.head.comment = null;\n            }\n            state.mode = HCRC;\n          case HCRC:\n            if (state.flags & 512) {\n              while (bits < 16) {\n                if (have === 0) {\n                  break inf_leave;\n                }\n                have--;\n                hold += input[next++] << bits;\n                bits += 8;\n              }\n              if (hold !== (state.check & 65535)) {\n                strm.msg = \"header crc mismatch\";\n                state.mode = BAD;\n                break;\n              }\n              hold = 0;\n              bits = 0;\n            }\n            if (state.head) {\n              state.head.hcrc = (state.flags >> 9) & 1;\n              state.head.done = true;\n            }\n            strm.adler = state.check = 0;\n            state.mode = TYPE;\n            break;\n          case DICTID:\n            while (bits < 32) {\n              if (have === 0) {\n                break inf_leave;\n              }\n              have--;\n              hold += input[next++] << bits;\n              bits += 8;\n            }\n            strm.adler = state.check = zswap32(hold);\n            hold = 0;\n            bits = 0;\n            state.mode = DICT;\n          case DICT:\n            if (state.havedict === 0) {\n              strm.next_out = put;\n              strm.avail_out = left;\n              strm.next_in = next;\n              strm.avail_in = have;\n              state.hold = hold;\n              state.bits = bits;\n              return Z_NEED_DICT;\n            }\n            strm.adler = state.check = 1;\n            state.mode = TYPE;\n          case TYPE:\n            if (flush === Z_BLOCK || flush === Z_TREES) {\n              break inf_leave;\n            }\n          case TYPEDO:\n            if (state.last) {\n              hold >>>= bits & 7;\n              bits -= bits & 7;\n              state.mode = CHECK;\n              break;\n            }\n            while (bits < 3) {\n              if (have === 0) {\n                break inf_leave;\n              }\n              have--;\n              hold += input[next++] << bits;\n              bits += 8;\n            }\n            state.last = hold & 1;\n            hold >>>= 1;\n            bits -= 1;\n            switch (hold & 3) {\n              case 0:\n                state.mode = STORED;\n                break;\n              case 1:\n                fixedtables(state);\n                state.mode = LEN_;\n                if (flush === Z_TREES) {\n                  hold >>>= 2;\n                  bits -= 2;\n                  break inf_leave;\n                }\n                break;\n              case 2:\n                state.mode = TABLE;\n                break;\n              case 3:\n                strm.msg = \"invalid block type\";\n                state.mode = BAD;\n            }\n            hold >>>= 2;\n            bits -= 2;\n            break;\n          case STORED:\n            hold >>>= bits & 7;\n            bits -= bits & 7;\n            while (bits < 32) {\n              if (have === 0) {\n                break inf_leave;\n              }\n              have--;\n              hold += input[next++] << bits;\n              bits += 8;\n            }\n            if ((hold & 65535) !== ((hold >>> 16) ^ 65535)) {\n              strm.msg = \"invalid stored block lengths\";\n              state.mode = BAD;\n              break;\n            }\n            state.length = hold & 65535;\n            hold = 0;\n            bits = 0;\n            state.mode = COPY_;\n            if (flush === Z_TREES) {\n              break inf_leave;\n            }\n          case COPY_:\n            state.mode = COPY;\n          case COPY:\n            copy = state.length;\n            if (copy) {\n              if (copy > have) {\n                copy = have;\n              }\n              if (copy > left) {\n                copy = left;\n              }\n              if (copy === 0) {\n                break inf_leave;\n              }\n              utils.arraySet(output, input, next, copy, put);\n              have -= copy;\n              next += copy;\n              left -= copy;\n              put += copy;\n              state.length -= copy;\n              break;\n            }\n            state.mode = TYPE;\n            break;\n          case TABLE:\n            while (bits < 14) {\n              if (have === 0) {\n                break inf_leave;\n              }\n              have--;\n              hold += input[next++] << bits;\n              bits += 8;\n            }\n            state.nlen = (hold & 31) + 257;\n            hold >>>= 5;\n            bits -= 5;\n            state.ndist = (hold & 31) + 1;\n            hold >>>= 5;\n            bits -= 5;\n            state.ncode = (hold & 15) + 4;\n            hold >>>= 4;\n            bits -= 4;\n            if (state.nlen > 286 || state.ndist > 30) {\n              strm.msg = \"too many length or distance symbols\";\n              state.mode = BAD;\n              break;\n            }\n            state.have = 0;\n            state.mode = LENLENS;\n          case LENLENS:\n            while (state.have < state.ncode) {\n              while (bits < 3) {\n                if (have === 0) {\n                  break inf_leave;\n                }\n                have--;\n                hold += input[next++] << bits;\n                bits += 8;\n              }\n              state.lens[order[state.have++]] = hold & 7;\n              hold >>>= 3;\n              bits -= 3;\n            }\n            while (state.have < 19) {\n              state.lens[order[state.have++]] = 0;\n            }\n            state.lencode = state.lendyn;\n            state.lenbits = 7;\n            opts = { bits: state.lenbits };\n            ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);\n            state.lenbits = opts.bits;\n            if (ret) {\n              strm.msg = \"invalid code lengths set\";\n              state.mode = BAD;\n              break;\n            }\n            state.have = 0;\n            state.mode = CODELENS;\n          case CODELENS:\n            while (state.have < state.nlen + state.ndist) {\n              for (;;) {\n                here = state.lencode[hold & ((1 << state.lenbits) - 1)];\n                here_bits = here >>> 24;\n                here_op = (here >>> 16) & 255;\n                here_val = here & 65535;\n                if (here_bits <= bits) {\n                  break;\n                }\n                if (have === 0) {\n                  break inf_leave;\n                }\n                have--;\n                hold += input[next++] << bits;\n                bits += 8;\n              }\n              if (here_val < 16) {\n                hold >>>= here_bits;\n                bits -= here_bits;\n                state.lens[state.have++] = here_val;\n              } else {\n                if (here_val === 16) {\n                  n = here_bits + 2;\n                  while (bits < n) {\n                    if (have === 0) {\n                      break inf_leave;\n                    }\n                    have--;\n                    hold += input[next++] << bits;\n                    bits += 8;\n                  }\n                  hold >>>= here_bits;\n                  bits -= here_bits;\n                  if (state.have === 0) {\n                    strm.msg = \"invalid bit length repeat\";\n                    state.mode = BAD;\n                    break;\n                  }\n                  len = state.lens[state.have - 1];\n                  copy = 3 + (hold & 3);\n                  hold >>>= 2;\n                  bits -= 2;\n                } else if (here_val === 17) {\n                  n = here_bits + 3;\n                  while (bits < n) {\n                    if (have === 0) {\n                      break inf_leave;\n                    }\n                    have--;\n                    hold += input[next++] << bits;\n                    bits += 8;\n                  }\n                  hold >>>= here_bits;\n                  bits -= here_bits;\n                  len = 0;\n                  copy = 3 + (hold & 7);\n                  hold >>>= 3;\n                  bits -= 3;\n                } else {\n                  n = here_bits + 7;\n                  while (bits < n) {\n                    if (have === 0) {\n                      break inf_leave;\n                    }\n                    have--;\n                    hold += input[next++] << bits;\n                    bits += 8;\n                  }\n                  hold >>>= here_bits;\n                  bits -= here_bits;\n                  len = 0;\n                  copy = 11 + (hold & 127);\n                  hold >>>= 7;\n                  bits -= 7;\n                }\n                if (state.have + copy > state.nlen + state.ndist) {\n                  strm.msg = \"invalid bit length repeat\";\n                  state.mode = BAD;\n                  break;\n                }\n                while (copy--) {\n                  state.lens[state.have++] = len;\n                }\n              }\n            }\n            if (state.mode === BAD) {\n              break;\n            }\n            if (state.lens[256] === 0) {\n              strm.msg = \"invalid code -- missing end-of-block\";\n              state.mode = BAD;\n              break;\n            }\n            state.lenbits = 9;\n            opts = { bits: state.lenbits };\n            ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);\n            state.lenbits = opts.bits;\n            if (ret) {\n              strm.msg = \"invalid literal/lengths set\";\n              state.mode = BAD;\n              break;\n            }\n            state.distbits = 6;\n            state.distcode = state.distdyn;\n            opts = { bits: state.distbits };\n            ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);\n            state.distbits = opts.bits;\n            if (ret) {\n              strm.msg = \"invalid distances set\";\n              state.mode = BAD;\n              break;\n            }\n            state.mode = LEN_;\n            if (flush === Z_TREES) {\n              break inf_leave;\n            }\n          case LEN_:\n            state.mode = LEN;\n          case LEN:\n            if (have >= 6 && left >= 258) {\n              strm.next_out = put;\n              strm.avail_out = left;\n              strm.next_in = next;\n              strm.avail_in = have;\n              state.hold = hold;\n              state.bits = bits;\n              inflate_fast(strm, _out);\n              put = strm.next_out;\n              output = strm.output;\n              left = strm.avail_out;\n              next = strm.next_in;\n              input = strm.input;\n              have = strm.avail_in;\n              hold = state.hold;\n              bits = state.bits;\n              if (state.mode === TYPE) {\n                state.back = -1;\n              }\n              break;\n            }\n            state.back = 0;\n            for (;;) {\n              here = state.lencode[hold & ((1 << state.lenbits) - 1)];\n              here_bits = here >>> 24;\n              here_op = (here >>> 16) & 255;\n              here_val = here & 65535;\n              if (here_bits <= bits) {\n                break;\n              }\n              if (have === 0) {\n                break inf_leave;\n              }\n              have--;\n              hold += input[next++] << bits;\n              bits += 8;\n            }\n            if (here_op && (here_op & 240) === 0) {\n              last_bits = here_bits;\n              last_op = here_op;\n              last_val = here_val;\n              for (;;) {\n                here = state.lencode[last_val + ((hold & ((1 << (last_bits + last_op)) - 1)) >> last_bits)];\n                here_bits = here >>> 24;\n                here_op = (here >>> 16) & 255;\n                here_val = here & 65535;\n                if (last_bits + here_bits <= bits) {\n                  break;\n                }\n                if (have === 0) {\n                  break inf_leave;\n                }\n                have--;\n                hold += input[next++] << bits;\n                bits += 8;\n              }\n              hold >>>= last_bits;\n              bits -= last_bits;\n              state.back += last_bits;\n            }\n            hold >>>= here_bits;\n            bits -= here_bits;\n            state.back += here_bits;\n            state.length = here_val;\n            if (here_op === 0) {\n              state.mode = LIT;\n              break;\n            }\n            if (here_op & 32) {\n              state.back = -1;\n              state.mode = TYPE;\n              break;\n            }\n            if (here_op & 64) {\n              strm.msg = \"invalid literal/length code\";\n              state.mode = BAD;\n              break;\n            }\n            state.extra = here_op & 15;\n            state.mode = LENEXT;\n          case LENEXT:\n            if (state.extra) {\n              n = state.extra;\n              while (bits < n) {\n                if (have === 0) {\n                  break inf_leave;\n                }\n                have--;\n                hold += input[next++] << bits;\n                bits += 8;\n              }\n              state.length += hold & ((1 << state.extra) - 1);\n              hold >>>= state.extra;\n              bits -= state.extra;\n              state.back += state.extra;\n            }\n            state.was = state.length;\n            state.mode = DIST;\n          case DIST:\n            for (;;) {\n              here = state.distcode[hold & ((1 << state.distbits) - 1)];\n              here_bits = here >>> 24;\n              here_op = (here >>> 16) & 255;\n              here_val = here & 65535;\n              if (here_bits <= bits) {\n                break;\n              }\n              if (have === 0) {\n                break inf_leave;\n              }\n              have--;\n              hold += input[next++] << bits;\n              bits += 8;\n            }\n            if ((here_op & 240) === 0) {\n              last_bits = here_bits;\n              last_op = here_op;\n              last_val = here_val;\n              for (;;) {\n                here = state.distcode[last_val + ((hold & ((1 << (last_bits + last_op)) - 1)) >> last_bits)];\n                here_bits = here >>> 24;\n                here_op = (here >>> 16) & 255;\n                here_val = here & 65535;\n                if (last_bits + here_bits <= bits) {\n                  break;\n                }\n                if (have === 0) {\n                  break inf_leave;\n                }\n                have--;\n                hold += input[next++] << bits;\n                bits += 8;\n              }\n              hold >>>= last_bits;\n              bits -= last_bits;\n              state.back += last_bits;\n            }\n            hold >>>= here_bits;\n            bits -= here_bits;\n            state.back += here_bits;\n            if (here_op & 64) {\n              strm.msg = \"invalid distance code\";\n              state.mode = BAD;\n              break;\n            }\n            state.offset = here_val;\n            state.extra = here_op & 15;\n            state.mode = DISTEXT;\n          case DISTEXT:\n            if (state.extra) {\n              n = state.extra;\n              while (bits < n) {\n                if (have === 0) {\n                  break inf_leave;\n                }\n                have--;\n                hold += input[next++] << bits;\n                bits += 8;\n              }\n              state.offset += hold & ((1 << state.extra) - 1);\n              hold >>>= state.extra;\n              bits -= state.extra;\n              state.back += state.extra;\n            }\n            if (state.offset > state.dmax) {\n              strm.msg = \"invalid distance too far back\";\n              state.mode = BAD;\n              break;\n            }\n            state.mode = MATCH;\n          case MATCH:\n            if (left === 0) {\n              break inf_leave;\n            }\n            copy = _out - left;\n            if (state.offset > copy) {\n              copy = state.offset - copy;\n              if (copy > state.whave) {\n                if (state.sane) {\n                  strm.msg = \"invalid distance too far back\";\n                  state.mode = BAD;\n                  break;\n                }\n              }\n              if (copy > state.wnext) {\n                copy -= state.wnext;\n                from = state.wsize - copy;\n              } else {\n                from = state.wnext - copy;\n              }\n              if (copy > state.length) {\n                copy = state.length;\n              }\n              from_source = state.window;\n            } else {\n              from_source = output;\n              from = put - state.offset;\n              copy = state.length;\n            }\n            if (copy > left) {\n              copy = left;\n            }\n            left -= copy;\n            state.length -= copy;\n            do {\n              output[put++] = from_source[from++];\n            } while (--copy);\n            if (state.length === 0) {\n              state.mode = LEN;\n            }\n            break;\n          case LIT:\n            if (left === 0) {\n              break inf_leave;\n            }\n            output[put++] = state.length;\n            left--;\n            state.mode = LEN;\n            break;\n          case CHECK:\n            if (state.wrap) {\n              while (bits < 32) {\n                if (have === 0) {\n                  break inf_leave;\n                }\n                have--;\n                hold |= input[next++] << bits;\n                bits += 8;\n              }\n              _out -= left;\n              strm.total_out += _out;\n              state.total += _out;\n              if (_out) {\n                strm.adler = state.check = state.flags\n                  ? crc32(state.check, output, _out, put - _out)\n                  : adler32(state.check, output, _out, put - _out);\n              }\n              _out = left;\n              if ((state.flags ? hold : zswap32(hold)) !== state.check) {\n                strm.msg = \"incorrect data check\";\n                state.mode = BAD;\n                break;\n              }\n              hold = 0;\n              bits = 0;\n            }\n            state.mode = LENGTH;\n          case LENGTH:\n            if (state.wrap && state.flags) {\n              while (bits < 32) {\n                if (have === 0) {\n                  break inf_leave;\n                }\n                have--;\n                hold += input[next++] << bits;\n                bits += 8;\n              }\n              if (hold !== (state.total & 4294967295)) {\n                strm.msg = \"incorrect length check\";\n                state.mode = BAD;\n                break;\n              }\n              hold = 0;\n              bits = 0;\n            }\n            state.mode = DONE;\n          case DONE:\n            ret = Z_STREAM_END;\n            break inf_leave;\n          case BAD:\n            ret = Z_DATA_ERROR;\n            break inf_leave;\n          case MEM:\n            return Z_MEM_ERROR;\n          case SYNC:\n          default:\n            return Z_STREAM_ERROR;\n        }\n      }\n      strm.next_out = put;\n      strm.avail_out = left;\n      strm.next_in = next;\n      strm.avail_in = have;\n      state.hold = hold;\n      state.bits = bits;\n      if (state.wsize || (_out !== strm.avail_out && state.mode < BAD && (state.mode < CHECK || flush !== Z_FINISH))) {\n        if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {\n          state.mode = MEM;\n          return Z_MEM_ERROR;\n        }\n      }\n      _in -= strm.avail_in;\n      _out -= strm.avail_out;\n      strm.total_in += _in;\n      strm.total_out += _out;\n      state.total += _out;\n      if (state.wrap && _out) {\n        strm.adler = state.check = state.flags\n          ? crc32(state.check, output, _out, strm.next_out - _out)\n          : adler32(state.check, output, _out, strm.next_out - _out);\n      }\n      strm.data_type =\n        state.bits +\n        (state.last ? 64 : 0) +\n        (state.mode === TYPE ? 128 : 0) +\n        (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);\n      if (((_in === 0 && _out === 0) || flush === Z_FINISH) && ret === Z_OK) {\n        ret = Z_BUF_ERROR;\n      }\n      return ret;\n    }\n    function inflateEnd(strm) {\n      if (!strm || !strm.state) {\n        return Z_STREAM_ERROR;\n      }\n      var state = strm.state;\n      if (state.window) {\n        state.window = null;\n      }\n      strm.state = null;\n      return Z_OK;\n    }\n    function inflateGetHeader(strm, head) {\n      var state;\n      if (!strm || !strm.state) {\n        return Z_STREAM_ERROR;\n      }\n      state = strm.state;\n      if ((state.wrap & 2) === 0) {\n        return Z_STREAM_ERROR;\n      }\n      state.head = head;\n      head.done = false;\n      return Z_OK;\n    }\n    function inflateSetDictionary(strm, dictionary) {\n      var dictLength = dictionary.length;\n      var state;\n      var dictid;\n      var ret;\n      if (!strm || !strm.state) {\n        return Z_STREAM_ERROR;\n      }\n      state = strm.state;\n      if (state.wrap !== 0 && state.mode !== DICT) {\n        return Z_STREAM_ERROR;\n      }\n      if (state.mode === DICT) {\n        dictid = 1;\n        dictid = adler32(dictid, dictionary, dictLength, 0);\n        if (dictid !== state.check) {\n          return Z_DATA_ERROR;\n        }\n      }\n      ret = updatewindow(strm, dictionary, dictLength, dictLength);\n      if (ret) {\n        state.mode = MEM;\n        return Z_MEM_ERROR;\n      }\n      state.havedict = 1;\n      return Z_OK;\n    }\n    exports.inflateReset = inflateReset;\n    exports.inflateReset2 = inflateReset2;\n    exports.inflateResetKeep = inflateResetKeep;\n    exports.inflateInit = inflateInit;\n    exports.inflateInit2 = inflateInit2;\n    exports.inflate = inflate;\n    exports.inflateEnd = inflateEnd;\n    exports.inflateGetHeader = inflateGetHeader;\n    exports.inflateSetDictionary = inflateSetDictionary;\n    exports.inflateInfo = \"pako inflate (from Nodeca project)\";\n  },\n});\n\n// node_modules/pako/lib/zlib/constants.js\nvar require_constants = __commonJS({\n  \"node_modules/pako/lib/zlib/constants.js\"(exports, module2) {\n    \"use strict\";\n    module2.exports = {\n      Z_NO_FLUSH: 0,\n      Z_PARTIAL_FLUSH: 1,\n      Z_SYNC_FLUSH: 2,\n      Z_FULL_FLUSH: 3,\n      Z_FINISH: 4,\n      Z_BLOCK: 5,\n      Z_TREES: 6,\n      Z_OK: 0,\n      Z_STREAM_END: 1,\n      Z_NEED_DICT: 2,\n      Z_ERRNO: -1,\n      Z_STREAM_ERROR: -2,\n      Z_DATA_ERROR: -3,\n      Z_BUF_ERROR: -5,\n      Z_NO_COMPRESSION: 0,\n      Z_BEST_SPEED: 1,\n      Z_BEST_COMPRESSION: 9,\n      Z_DEFAULT_COMPRESSION: -1,\n      Z_FILTERED: 1,\n      Z_HUFFMAN_ONLY: 2,\n      Z_RLE: 3,\n      Z_FIXED: 4,\n      Z_DEFAULT_STRATEGY: 0,\n      Z_BINARY: 0,\n      Z_TEXT: 1,\n      Z_UNKNOWN: 2,\n      Z_DEFLATED: 8,\n    };\n  },\n});\n\n// node_modules/browserify-zlib/lib/binding.js\nvar require_binding = __commonJS({\n  \"node_modules/browserify-zlib/lib/binding.js\"(exports) {\n    \"use strict\";\n    var assert = require(\"assert\");\n    var Zstream = require_zstream();\n    var zlib_deflate = require_deflate();\n    var zlib_inflate = require_inflate();\n    var constants = require_constants();\n    for (key in constants) {\n      exports[key] = constants[key];\n    }\n    var key;\n    exports.NONE = 0;\n    exports.DEFLATE = 1;\n    exports.INFLATE = 2;\n    exports.GZIP = 3;\n    exports.GUNZIP = 4;\n    exports.DEFLATERAW = 5;\n    exports.INFLATERAW = 6;\n    exports.UNZIP = 7;\n    var GZIP_HEADER_ID1 = 31;\n    var GZIP_HEADER_ID2 = 139;\n    function Zlib(mode) {\n      if (typeof mode !== \"number\" || mode < exports.DEFLATE || mode > exports.UNZIP) {\n        throw new TypeError(\"Bad argument\");\n      }\n      this.dictionary = null;\n      this.err = 0;\n      this.flush = 0;\n      this.init_done = false;\n      this.level = 0;\n      this.memLevel = 0;\n      this.mode = mode;\n      this.strategy = 0;\n      this.windowBits = 0;\n      this.write_in_progress = false;\n      this.pending_close = false;\n      this.gzip_id_bytes_read = 0;\n    }\n    Zlib.prototype.close = function () {\n      if (this.write_in_progress) {\n        this.pending_close = true;\n        return;\n      }\n      this.pending_close = false;\n      assert(this.init_done, \"close before init\");\n      assert(this.mode <= exports.UNZIP);\n      if (this.mode === exports.DEFLATE || this.mode === exports.GZIP || this.mode === exports.DEFLATERAW) {\n        zlib_deflate.deflateEnd(this.strm);\n      } else if (\n        this.mode === exports.INFLATE ||\n        this.mode === exports.GUNZIP ||\n        this.mode === exports.INFLATERAW ||\n        this.mode === exports.UNZIP\n      ) {\n        zlib_inflate.inflateEnd(this.strm);\n      }\n      this.mode = exports.NONE;\n      this.dictionary = null;\n    };\n    Zlib.prototype.write = function (flush, input, in_off, in_len, out, out_off, out_len) {\n      return this._write(true, flush, input, in_off, in_len, out, out_off, out_len);\n    };\n    Zlib.prototype.writeSync = function (flush, input, in_off, in_len, out, out_off, out_len) {\n      return this._write(false, flush, input, in_off, in_len, out, out_off, out_len);\n    };\n    Zlib.prototype._write = function (async, flush, input, in_off, in_len, out, out_off, out_len) {\n      assert.equal(arguments.length, 8);\n      assert(this.init_done, \"write before init\");\n      assert(this.mode !== exports.NONE, \"already finalized\");\n      assert.equal(false, this.write_in_progress, \"write already in progress\");\n      assert.equal(false, this.pending_close, \"close is pending\");\n      this.write_in_progress = true;\n      assert.equal(false, flush === void 0, \"must provide flush value\");\n      this.write_in_progress = true;\n      if (\n        flush !== exports.Z_NO_FLUSH &&\n        flush !== exports.Z_PARTIAL_FLUSH &&\n        flush !== exports.Z_SYNC_FLUSH &&\n        flush !== exports.Z_FULL_FLUSH &&\n        flush !== exports.Z_FINISH &&\n        flush !== exports.Z_BLOCK\n      ) {\n        throw new Error(\"Invalid flush value\");\n      }\n      if (input == null) {\n        input = Buffer.alloc(0);\n        in_len = 0;\n        in_off = 0;\n      }\n      this.strm.avail_in = in_len;\n      this.strm.input = input;\n      this.strm.next_in = in_off;\n      this.strm.avail_out = out_len;\n      this.strm.output = out;\n      this.strm.next_out = out_off;\n      this.flush = flush;\n      if (!async) {\n        this._process();\n        if (this._checkError()) {\n          return this._afterSync();\n        }\n        return;\n      }\n      var self = this;\n      process.nextTick(function () {\n        self._process();\n        self._after();\n      });\n      return this;\n    };\n    Zlib.prototype._afterSync = function () {\n      var avail_out = this.strm.avail_out;\n      var avail_in = this.strm.avail_in;\n      this.write_in_progress = false;\n      return [avail_in, avail_out];\n    };\n    Zlib.prototype._process = function () {\n      var next_expected_header_byte = null;\n      switch (this.mode) {\n        case exports.DEFLATE:\n        case exports.GZIP:\n        case exports.DEFLATERAW:\n          this.err = zlib_deflate.deflate(this.strm, this.flush);\n          break;\n        case exports.UNZIP:\n          if (this.strm.avail_in > 0) {\n            next_expected_header_byte = this.strm.next_in;\n          }\n          switch (this.gzip_id_bytes_read) {\n            case 0:\n              if (next_expected_header_byte === null) {\n                break;\n              }\n              if (this.strm.input[next_expected_header_byte] === GZIP_HEADER_ID1) {\n                this.gzip_id_bytes_read = 1;\n                next_expected_header_byte++;\n                if (this.strm.avail_in === 1) {\n                  break;\n                }\n              } else {\n                this.mode = exports.INFLATE;\n                break;\n              }\n            case 1:\n              if (next_expected_header_byte === null) {\n                break;\n              }\n              if (this.strm.input[next_expected_header_byte] === GZIP_HEADER_ID2) {\n                this.gzip_id_bytes_read = 2;\n                this.mode = exports.GUNZIP;\n              } else {\n                this.mode = exports.INFLATE;\n              }\n              break;\n            default:\n              throw new Error(\"invalid number of gzip magic number bytes read\");\n          }\n        case exports.INFLATE:\n        case exports.GUNZIP:\n        case exports.INFLATERAW:\n          this.err = zlib_inflate.inflate(this.strm, this.flush);\n          if (this.err === exports.Z_NEED_DICT && this.dictionary) {\n            this.err = zlib_inflate.inflateSetDictionary(this.strm, this.dictionary);\n            if (this.err === exports.Z_OK) {\n              this.err = zlib_inflate.inflate(this.strm, this.flush);\n            } else if (this.err === exports.Z_DATA_ERROR) {\n              this.err = exports.Z_NEED_DICT;\n            }\n          }\n          while (\n            this.strm.avail_in > 0 &&\n            this.mode === exports.GUNZIP &&\n            this.err === exports.Z_STREAM_END &&\n            this.strm.next_in[0] !== 0\n          ) {\n            this.reset();\n            this.err = zlib_inflate.inflate(this.strm, this.flush);\n          }\n          break;\n        default:\n          throw new Error(\"Unknown mode \" + this.mode);\n      }\n    };\n    Zlib.prototype._checkError = function () {\n      switch (this.err) {\n        case exports.Z_OK:\n        case exports.Z_BUF_ERROR:\n          if (this.strm.avail_out !== 0 && this.flush === exports.Z_FINISH) {\n            this._error(\"unexpected end of file\");\n            return false;\n          }\n          break;\n        case exports.Z_STREAM_END:\n          break;\n        case exports.Z_NEED_DICT:\n          if (this.dictionary == null) {\n            this._error(\"Missing dictionary\");\n          } else {\n            this._error(\"Bad dictionary\");\n          }\n          return false;\n        default:\n          this._error(\"Zlib error\");\n          return false;\n      }\n      return true;\n    };\n    Zlib.prototype._after = function () {\n      if (!this._checkError()) {\n        return;\n      }\n      var avail_out = this.strm.avail_out;\n      var avail_in = this.strm.avail_in;\n      this.write_in_progress = false;\n      this.callback(avail_in, avail_out);\n      if (this.pending_close) {\n        this.close();\n      }\n    };\n    Zlib.prototype._error = function (message) {\n      if (this.strm.msg) {\n        message = this.strm.msg;\n      }\n      this.onerror(message, this.err);\n      this.write_in_progress = false;\n      if (this.pending_close) {\n        this.close();\n      }\n    };\n    Zlib.prototype.init = function (windowBits, level, memLevel, strategy, dictionary) {\n      assert(\n        arguments.length === 4 || arguments.length === 5,\n        \"init(windowBits, level, memLevel, strategy, [dictionary])\",\n      );\n      assert(windowBits >= 8 && windowBits <= 15, \"invalid windowBits\");\n      assert(level >= -1 && level <= 9, \"invalid compression level\");\n      assert(memLevel >= 1 && memLevel <= 9, \"invalid memlevel\");\n      assert(\n        strategy === exports.Z_FILTERED ||\n          strategy === exports.Z_HUFFMAN_ONLY ||\n          strategy === exports.Z_RLE ||\n          strategy === exports.Z_FIXED ||\n          strategy === exports.Z_DEFAULT_STRATEGY,\n        \"invalid strategy\",\n      );\n      this._init(level, windowBits, memLevel, strategy, dictionary);\n      this._setDictionary();\n    };\n    Zlib.prototype.params = function () {\n      throw new Error(\"deflateParams Not supported\");\n    };\n    Zlib.prototype.reset = function () {\n      this._reset();\n      this._setDictionary();\n    };\n    Zlib.prototype._init = function (level, windowBits, memLevel, strategy, dictionary) {\n      this.level = level;\n      this.windowBits = windowBits;\n      this.memLevel = memLevel;\n      this.strategy = strategy;\n      this.flush = exports.Z_NO_FLUSH;\n      this.err = exports.Z_OK;\n      if (this.mode === exports.GZIP || this.mode === exports.GUNZIP) {\n        this.windowBits += 16;\n      }\n      if (this.mode === exports.UNZIP) {\n        this.windowBits += 32;\n      }\n      if (this.mode === exports.DEFLATERAW || this.mode === exports.INFLATERAW) {\n        this.windowBits = -1 * this.windowBits;\n      }\n      this.strm = new Zstream();\n      switch (this.mode) {\n        case exports.DEFLATE:\n        case exports.GZIP:\n        case exports.DEFLATERAW:\n          this.err = zlib_deflate.deflateInit2(\n            this.strm,\n            this.level,\n            exports.Z_DEFLATED,\n            this.windowBits,\n            this.memLevel,\n            this.strategy,\n          );\n          break;\n        case exports.INFLATE:\n        case exports.GUNZIP:\n        case exports.INFLATERAW:\n        case exports.UNZIP:\n          this.err = zlib_inflate.inflateInit2(this.strm, this.windowBits);\n          break;\n        default:\n          throw new Error(\"Unknown mode \" + this.mode);\n      }\n      if (this.err !== exports.Z_OK) {\n        this._error(\"Init error\");\n      }\n      this.dictionary = dictionary;\n      this.write_in_progress = false;\n      this.init_done = true;\n    };\n    Zlib.prototype._setDictionary = function () {\n      if (this.dictionary == null) {\n        return;\n      }\n      this.err = exports.Z_OK;\n      switch (this.mode) {\n        case exports.DEFLATE:\n        case exports.DEFLATERAW:\n          this.err = zlib_deflate.deflateSetDictionary(this.strm, this.dictionary);\n          break;\n        default:\n          break;\n      }\n      if (this.err !== exports.Z_OK) {\n        this._error(\"Failed to set dictionary\");\n      }\n    };\n    Zlib.prototype._reset = function () {\n      this.err = exports.Z_OK;\n      switch (this.mode) {\n        case exports.DEFLATE:\n        case exports.DEFLATERAW:\n        case exports.GZIP:\n          this.err = zlib_deflate.deflateReset(this.strm);\n          break;\n        case exports.INFLATE:\n        case exports.INFLATERAW:\n        case exports.GUNZIP:\n          this.err = zlib_inflate.inflateReset(this.strm);\n          break;\n        default:\n          break;\n      }\n      if (this.err !== exports.Z_OK) {\n        this._error(\"Failed to reset stream\");\n      }\n    };\n    exports.Zlib = Zlib;\n  },\n});\n\n// node_modules/browserify-zlib/lib/index.js\nvar require_lib = __commonJS({\n  \"node_modules/browserify-zlib/lib/index.js\"(exports) {\n    \"use strict\";\n    var Buffer2 = require(\"buffer\").Buffer;\n    var Transform = require(\"stream\").Transform;\n    var binding = require_binding();\n    var util = require(\"util\");\n    var assert = require(\"assert\").ok;\n    var kMaxLength = require(\"buffer\").kMaxLength;\n    var kRangeErrorMessage =\n      \"Cannot create final Buffer. It would be larger than 0x\" + kMaxLength.toString(16) + \" bytes\";\n    binding.Z_MIN_WINDOWBITS = 8;\n    binding.Z_MAX_WINDOWBITS = 15;\n    binding.Z_DEFAULT_WINDOWBITS = 15;\n    binding.Z_MIN_CHUNK = 64;\n    binding.Z_MAX_CHUNK = Infinity;\n    binding.Z_DEFAULT_CHUNK = 16 * 1024;\n    binding.Z_MIN_MEMLEVEL = 1;\n    binding.Z_MAX_MEMLEVEL = 9;\n    binding.Z_DEFAULT_MEMLEVEL = 8;\n    binding.Z_MIN_LEVEL = -1;\n    binding.Z_MAX_LEVEL = 9;\n    binding.Z_DEFAULT_LEVEL = binding.Z_DEFAULT_COMPRESSION;\n    var bkeys = Object.keys(binding);\n    for (bk = 0; bk < bkeys.length; bk++) {\n      bkey = bkeys[bk];\n      if (bkey.match(/^Z/)) {\n        Object.defineProperty(exports, bkey, {\n          enumerable: true,\n          value: binding[bkey],\n          writable: false,\n        });\n      }\n    }\n    var bkey;\n    var bk;\n    var codes = {\n      Z_OK: binding.Z_OK,\n      Z_STREAM_END: binding.Z_STREAM_END,\n      Z_NEED_DICT: binding.Z_NEED_DICT,\n      Z_ERRNO: binding.Z_ERRNO,\n      Z_STREAM_ERROR: binding.Z_STREAM_ERROR,\n      Z_DATA_ERROR: binding.Z_DATA_ERROR,\n      Z_MEM_ERROR: binding.Z_MEM_ERROR,\n      Z_BUF_ERROR: binding.Z_BUF_ERROR,\n      Z_VERSION_ERROR: binding.Z_VERSION_ERROR,\n    };\n    var ckeys = Object.keys(codes);\n    for (ck = 0; ck < ckeys.length; ck++) {\n      ckey = ckeys[ck];\n      codes[codes[ckey]] = ckey;\n    }\n    var ckey;\n    var ck;\n    Object.defineProperty(exports, \"codes\", {\n      enumerable: true,\n      value: Object.freeze(codes),\n      writable: false,\n    });\n    exports.constants = require_constants();\n    exports.Deflate = Deflate;\n    exports.Inflate = Inflate;\n    exports.Gzip = Gzip;\n    exports.Gunzip = Gunzip;\n    exports.DeflateRaw = DeflateRaw;\n    exports.InflateRaw = InflateRaw;\n    exports.Unzip = Unzip;\n    exports.createDeflate = function (o) {\n      return new Deflate(o);\n    };\n    exports.createInflate = function (o) {\n      return new Inflate(o);\n    };\n    exports.createDeflateRaw = function (o) {\n      return new DeflateRaw(o);\n    };\n    exports.createInflateRaw = function (o) {\n      return new InflateRaw(o);\n    };\n    exports.createGzip = function (o) {\n      return new Gzip(o);\n    };\n    exports.createGunzip = function (o) {\n      return new Gunzip(o);\n    };\n    exports.createUnzip = function (o) {\n      return new Unzip(o);\n    };\n    exports.deflate = function (buffer, opts, callback) {\n      if (typeof opts === \"function\") {\n        callback = opts;\n        opts = {};\n      }\n      return zlibBuffer(new Deflate(opts), buffer, callback);\n    };\n    exports.deflateSync = function (buffer, opts) {\n      return zlibBufferSync(new Deflate(opts), buffer);\n    };\n    exports.gzip = function (buffer, opts, callback) {\n      if (typeof opts === \"function\") {\n        callback = opts;\n        opts = {};\n      }\n      return zlibBuffer(new Gzip(opts), buffer, callback);\n    };\n    exports.gzipSync = function (buffer, opts) {\n      return zlibBufferSync(new Gzip(opts), buffer);\n    };\n    exports.deflateRaw = function (buffer, opts, callback) {\n      if (typeof opts === \"function\") {\n        callback = opts;\n        opts = {};\n      }\n      return zlibBuffer(new DeflateRaw(opts), buffer, callback);\n    };\n    exports.deflateRawSync = function (buffer, opts) {\n      return zlibBufferSync(new DeflateRaw(opts), buffer);\n    };\n    exports.unzip = function (buffer, opts, callback) {\n      if (typeof opts === \"function\") {\n        callback = opts;\n        opts = {};\n      }\n      return zlibBuffer(new Unzip(opts), buffer, callback);\n    };\n    exports.unzipSync = function (buffer, opts) {\n      return zlibBufferSync(new Unzip(opts), buffer);\n    };\n    exports.inflate = function (buffer, opts, callback) {\n      if (typeof opts === \"function\") {\n        callback = opts;\n        opts = {};\n      }\n      return zlibBuffer(new Inflate(opts), buffer, callback);\n    };\n    exports.inflateSync = function (buffer, opts) {\n      return zlibBufferSync(new Inflate(opts), buffer);\n    };\n    exports.gunzip = function (buffer, opts, callback) {\n      if (typeof opts === \"function\") {\n        callback = opts;\n        opts = {};\n      }\n      return zlibBuffer(new Gunzip(opts), buffer, callback);\n    };\n    exports.gunzipSync = function (buffer, opts) {\n      return zlibBufferSync(new Gunzip(opts), buffer);\n    };\n    exports.inflateRaw = function (buffer, opts, callback) {\n      if (typeof opts === \"function\") {\n        callback = opts;\n        opts = {};\n      }\n      return zlibBuffer(new InflateRaw(opts), buffer, callback);\n    };\n    exports.inflateRawSync = function (buffer, opts) {\n      return zlibBufferSync(new InflateRaw(opts), buffer);\n    };\n    function zlibBuffer(engine, buffer, callback) {\n      var buffers = [];\n      var nread = 0;\n      engine.on(\"error\", onError);\n      engine.on(\"end\", onEnd);\n      engine.end(buffer);\n      flow();\n      function flow() {\n        var chunk;\n        while (null !== (chunk = engine.read())) {\n          buffers.push(chunk);\n          nread += chunk.length;\n        }\n        engine.once(\"readable\", flow);\n      }\n      function onError(err) {\n        engine.removeListener(\"end\", onEnd);\n        engine.removeListener(\"readable\", flow);\n        callback(err);\n      }\n      function onEnd() {\n        var buf;\n        var err = null;\n        if (nread >= kMaxLength) {\n          err = new RangeError(kRangeErrorMessage);\n        } else {\n          buf = Buffer2.concat(buffers, nread);\n        }\n        buffers = [];\n        engine.close();\n        callback(err, buf);\n      }\n    }\n    function zlibBufferSync(engine, buffer) {\n      if (typeof buffer === \"string\") buffer = Buffer2.from(buffer);\n      if (!Buffer2.isBuffer(buffer)) throw new TypeError(\"Not a string or buffer\");\n      var flushFlag = engine._finishFlushFlag;\n      return engine._processChunk(buffer, flushFlag);\n    }\n    function Deflate(opts) {\n      if (!(this instanceof Deflate)) return new Deflate(opts);\n      Zlib.call(this, opts, binding.DEFLATE);\n    }\n    function Inflate(opts) {\n      if (!(this instanceof Inflate)) return new Inflate(opts);\n      Zlib.call(this, opts, binding.INFLATE);\n    }\n    function Gzip(opts) {\n      if (!(this instanceof Gzip)) return new Gzip(opts);\n      Zlib.call(this, opts, binding.GZIP);\n    }\n    function Gunzip(opts) {\n      if (!(this instanceof Gunzip)) return new Gunzip(opts);\n      Zlib.call(this, opts, binding.GUNZIP);\n    }\n    function DeflateRaw(opts) {\n      if (!(this instanceof DeflateRaw)) return new DeflateRaw(opts);\n      Zlib.call(this, opts, binding.DEFLATERAW);\n    }\n    function InflateRaw(opts) {\n      if (!(this instanceof InflateRaw)) return new InflateRaw(opts);\n      Zlib.call(this, opts, binding.INFLATERAW);\n    }\n    function Unzip(opts) {\n      if (!(this instanceof Unzip)) return new Unzip(opts);\n      Zlib.call(this, opts, binding.UNZIP);\n    }\n    function isValidFlushFlag(flag) {\n      return (\n        flag === binding.Z_NO_FLUSH ||\n        flag === binding.Z_PARTIAL_FLUSH ||\n        flag === binding.Z_SYNC_FLUSH ||\n        flag === binding.Z_FULL_FLUSH ||\n        flag === binding.Z_FINISH ||\n        flag === binding.Z_BLOCK\n      );\n    }\n    function Zlib(opts, mode) {\n      var _this = this;\n      this._opts = opts = opts || {};\n      this._chunkSize = opts.chunkSize || exports.Z_DEFAULT_CHUNK;\n      Transform.call(this, opts);\n      if (opts.flush && !isValidFlushFlag(opts.flush)) {\n        throw new Error(\"Invalid flush flag: \" + opts.flush);\n      }\n      if (opts.finishFlush && !isValidFlushFlag(opts.finishFlush)) {\n        throw new Error(\"Invalid flush flag: \" + opts.finishFlush);\n      }\n      this._flushFlag = opts.flush || binding.Z_NO_FLUSH;\n      this._finishFlushFlag = typeof opts.finishFlush !== \"undefined\" ? opts.finishFlush : binding.Z_FINISH;\n      if (opts.chunkSize) {\n        if (opts.chunkSize < exports.Z_MIN_CHUNK || opts.chunkSize > exports.Z_MAX_CHUNK) {\n          throw new Error(\"Invalid chunk size: \" + opts.chunkSize);\n        }\n      }\n      if (opts.windowBits) {\n        if (opts.windowBits < exports.Z_MIN_WINDOWBITS || opts.windowBits > exports.Z_MAX_WINDOWBITS) {\n          throw new Error(\"Invalid windowBits: \" + opts.windowBits);\n        }\n      }\n      if (opts.level) {\n        if (opts.level < exports.Z_MIN_LEVEL || opts.level > exports.Z_MAX_LEVEL) {\n          throw new Error(\"Invalid compression level: \" + opts.level);\n        }\n      }\n      if (opts.memLevel) {\n        if (opts.memLevel < exports.Z_MIN_MEMLEVEL || opts.memLevel > exports.Z_MAX_MEMLEVEL) {\n          throw new Error(\"Invalid memLevel: \" + opts.memLevel);\n        }\n      }\n      if (opts.strategy) {\n        if (\n          opts.strategy != exports.Z_FILTERED &&\n          opts.strategy != exports.Z_HUFFMAN_ONLY &&\n          opts.strategy != exports.Z_RLE &&\n          opts.strategy != exports.Z_FIXED &&\n          opts.strategy != exports.Z_DEFAULT_STRATEGY\n        ) {\n          throw new Error(\"Invalid strategy: \" + opts.strategy);\n        }\n      }\n      if (opts.dictionary) {\n        if (!Buffer2.isBuffer(opts.dictionary)) {\n          throw new Error(\"Invalid dictionary: it should be a Buffer instance\");\n        }\n      }\n      this._handle = new binding.Zlib(mode);\n      var self = this;\n      this._hadError = false;\n      this._handle.onerror = function (message, errno) {\n        _close(self);\n        self._hadError = true;\n        var error = new Error(message);\n        error.errno = errno;\n        error.code = exports.codes[errno];\n        self.emit(\"error\", error);\n      };\n      var level = exports.Z_DEFAULT_COMPRESSION;\n      if (typeof opts.level === \"number\") level = opts.level;\n      var strategy = exports.Z_DEFAULT_STRATEGY;\n      if (typeof opts.strategy === \"number\") strategy = opts.strategy;\n      this._handle.init(\n        opts.windowBits || exports.Z_DEFAULT_WINDOWBITS,\n        level,\n        opts.memLevel || exports.Z_DEFAULT_MEMLEVEL,\n        strategy,\n        opts.dictionary,\n      );\n      this._buffer = Buffer2.allocUnsafe(this._chunkSize);\n      this._offset = 0;\n      this._level = level;\n      this._strategy = strategy;\n      this.once(\"end\", this.close);\n      Object.defineProperty(this, \"_closed\", {\n        get: function () {\n          return !_this._handle;\n        },\n        configurable: true,\n        enumerable: true,\n      });\n    }\n    util.inherits(Zlib, Transform);\n    Zlib.prototype.params = function (level, strategy, callback) {\n      if (level < exports.Z_MIN_LEVEL || level > exports.Z_MAX_LEVEL) {\n        throw new RangeError(\"Invalid compression level: \" + level);\n      }\n      if (\n        strategy != exports.Z_FILTERED &&\n        strategy != exports.Z_HUFFMAN_ONLY &&\n        strategy != exports.Z_RLE &&\n        strategy != exports.Z_FIXED &&\n        strategy != exports.Z_DEFAULT_STRATEGY\n      ) {\n        throw new TypeError(\"Invalid strategy: \" + strategy);\n      }\n      if (this._level !== level || this._strategy !== strategy) {\n        var self = this;\n        this.flush(binding.Z_SYNC_FLUSH, function () {\n          assert(self._handle, \"zlib binding closed\");\n          self._handle.params(level, strategy);\n          if (!self._hadError) {\n            self._level = level;\n            self._strategy = strategy;\n            if (callback) callback();\n          }\n        });\n      } else {\n        process.nextTick(callback);\n      }\n    };\n    Zlib.prototype.reset = function () {\n      assert(this._handle, \"zlib binding closed\");\n      return this._handle.reset();\n    };\n    Zlib.prototype._flush = function (callback) {\n      this._transform(Buffer2.alloc(0), \"\", callback);\n    };\n    Zlib.prototype.flush = function (kind, callback) {\n      var _this2 = this;\n      var ws = this._writableState;\n      if (typeof kind === \"function\" || (kind === void 0 && !callback)) {\n        callback = kind;\n        kind = binding.Z_FULL_FLUSH;\n      }\n      if (ws.ended) {\n        if (callback) process.nextTick(callback);\n      } else if (ws.ending) {\n        if (callback) this.once(\"end\", callback);\n      } else if (ws.needDrain) {\n        if (callback) {\n          this.once(\"drain\", function () {\n            return _this2.flush(kind, callback);\n          });\n        }\n      } else {\n        this._flushFlag = kind;\n        this.write(Buffer2.alloc(0), \"\", callback);\n      }\n    };\n    Zlib.prototype.close = function (callback) {\n      _close(this, callback);\n      process.nextTick(emitCloseNT, this);\n    };\n    function _close(engine, callback) {\n      if (callback) process.nextTick(callback);\n      if (!engine._handle) return;\n      engine._handle.close();\n      engine._handle = null;\n    }\n    function emitCloseNT(self) {\n      self.emit(\"close\");\n    }\n    Zlib.prototype._transform = function (chunk, encoding, cb) {\n      var flushFlag;\n      var ws = this._writableState;\n      var ending = ws.ending || ws.ended;\n      var last = ending && (!chunk || ws.length === chunk.length);\n      if (chunk !== null && !Buffer2.isBuffer(chunk)) return cb(new Error(\"invalid input\"));\n      if (!this._handle) return cb(new Error(\"zlib binding closed\"));\n      if (last) flushFlag = this._finishFlushFlag;\n      else {\n        flushFlag = this._flushFlag;\n        if (chunk.length >= ws.length) {\n          this._flushFlag = this._opts.flush || binding.Z_NO_FLUSH;\n        }\n      }\n      this._processChunk(chunk, flushFlag, cb);\n    };\n    Zlib.prototype._processChunk = function (chunk, flushFlag, cb) {\n      var availInBefore = chunk && chunk.length;\n      var availOutBefore = this._chunkSize - this._offset;\n      var inOff = 0;\n      var self = this;\n      var async = typeof cb === \"function\";\n      if (!async) {\n        var buffers = [];\n        var nread = 0;\n        var error;\n        this.on(\"error\", function (er) {\n          error = er;\n        });\n        assert(this._handle, \"zlib binding closed\");\n        do {\n          var res = this._handle.writeSync(\n            flushFlag,\n            chunk,\n            inOff,\n            availInBefore,\n            this._buffer,\n            this._offset,\n            availOutBefore,\n          );\n        } while (!this._hadError && callback(res[0], res[1]));\n        if (this._hadError) {\n          throw error;\n        }\n        if (nread >= kMaxLength) {\n          _close(this);\n          throw new RangeError(kRangeErrorMessage);\n        }\n        var buf = Buffer2.concat(buffers, nread);\n        _close(this);\n        return buf;\n      }\n      assert(this._handle, \"zlib binding closed\");\n      var req = this._handle.write(flushFlag, chunk, inOff, availInBefore, this._buffer, this._offset, availOutBefore);\n      req.buffer = chunk;\n      req.callback = callback;\n      function callback(availInAfter, availOutAfter) {\n        if (this) {\n          this.buffer = null;\n          this.callback = null;\n        }\n        if (self._hadError) return;\n        var have = availOutBefore - availOutAfter;\n        assert(have >= 0, \"have should not go down\");\n        if (have > 0) {\n          var out = self._buffer.slice(self._offset, self._offset + have);\n          self._offset += have;\n          if (async) {\n            self.push(out);\n          } else {\n            buffers.push(out);\n            nread += out.length;\n          }\n        }\n        if (availOutAfter === 0 || self._offset >= self._chunkSize) {\n          availOutBefore = self._chunkSize;\n          self._offset = 0;\n          self._buffer = Buffer2.allocUnsafe(self._chunkSize);\n        }\n        if (availOutAfter === 0) {\n          inOff += availInBefore - availInAfter;\n          availInBefore = availInAfter;\n          if (!async) return true;\n          var newReq = self._handle.write(\n            flushFlag,\n            chunk,\n            inOff,\n            availInBefore,\n            self._buffer,\n            self._offset,\n            self._chunkSize,\n          );\n          newReq.callback = callback;\n          newReq.buffer = chunk;\n          return;\n        }\n        if (!async) return false;\n        cb();\n      }\n    };\n    util.inherits(Deflate, Zlib);\n    util.inherits(Inflate, Zlib);\n    util.inherits(Gzip, Zlib);\n    util.inherits(Gunzip, Zlib);\n    util.inherits(DeflateRaw, Zlib);\n    util.inherits(InflateRaw, Zlib);\n    util.inherits(Unzip, Zlib);\n  },\n});\n\n// zlib.js\nvar zlib_exports = require_lib();\nzlib_exports[Symbol.for(\"CommonJS\")] = 0;\nexport default zlib_exports;\n\nexport var {\n  Deflate,\n  Inflate,\n  Gzip,\n  Gunzip,\n  DeflateRaw,\n  InflateRaw,\n  Unzip,\n  createDeflate,\n  createInflate,\n  createDeflateRaw,\n  createInflateRaw,\n  createGzip,\n  createGunzip,\n  createUnzip,\n  deflate,\n  deflateSync,\n  gzip,\n  gzipSync,\n  deflateRaw,\n  deflateRawSync,\n  unzip,\n  unzipSync,\n  inflate,\n  inflateSync,\n  gunzip,\n  gunzipSync,\n  inflateRaw,\n  inflateRawSync,\n  constants,\n} = zlib_exports;\n",
  "// Hardcoded module \"node:zlib\"\n// TODO: **use a native binding from Bun for this!!**\n// This is a very slow module!\n// It should really be fixed. It will show up in benchmarking. It also loads\n// slowly. We need to fix it!\n\nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __commonJS = (cb, mod) =>\n  function __require() {\n    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;\n  };\n\nvar __copyProps = (to, from, except, desc) => {\n  if ((from && typeof from === \"object\") || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, {\n          get: () => from[key],\n          enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable,\n        });\n  }\n  return to;\n};\nvar __reExport = (target, mod, secondTarget) => (\n  __copyProps(target, mod, \"default\"), secondTarget && __copyProps(secondTarget, mod, \"default\")\n);\nvar __toESM = (mod, isNodeMode, target) => (\n  (target = mod != null ? __create(__getProtoOf(mod)) : {}),\n  __copyProps(\n    isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", { value: mod, enumerable: true }) : target,\n    mod,\n  )\n);\nvar __toCommonJS = mod => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\n\nconst require = id => import.meta.require(id);\n\n// node_modules/pako/lib/zlib/zstream.js\nvar require_zstream = __commonJS({\n  \"node_modules/pako/lib/zlib/zstream.js\"(exports, module2) {\n    \"use strict\";\n    function ZStream() {\n      this.input = null;\n      this.next_in = 0;\n      this.avail_in = 0;\n      this.total_in = 0;\n      this.output = null;\n      this.next_out = 0;\n      this.avail_out = 0;\n      this.total_out = 0;\n      this.msg = \"\";\n      this.state = null;\n      this.data_type = 2;\n      this.adler = 0;\n    }\n    module2.exports = ZStream;\n  },\n});\n\n// node_modules/pako/lib/utils/common.js\nvar require_common = __commonJS({\n  \"node_modules/pako/lib/utils/common.js\"(exports) {\n    \"use strict\";\n    var TYPED_OK =\n      typeof Uint8Array !== \"undefined\" && typeof Uint16Array !== \"undefined\" && typeof Int32Array !== \"undefined\";\n    function _has(obj, key) {\n      return Object.prototype.hasOwnProperty.call(obj, key);\n    }\n    exports.assign = function (obj) {\n      var sources = Array.prototype.slice.call(arguments, 1);\n      while (sources.length) {\n        var source = sources.shift();\n        if (!source) {\n          continue;\n        }\n        if (typeof source !== \"object\") {\n          throw new TypeError(source + \"must be non-object\");\n        }\n        for (var p in source) {\n          if (_has(source, p)) {\n            obj[p] = source[p];\n          }\n        }\n      }\n      return obj;\n    };\n    exports.shrinkBuf = function (buf, size) {\n      if (buf.length === size) {\n        return buf;\n      }\n      if (buf.subarray) {\n        return buf.subarray(0, size);\n      }\n      buf.length = size;\n      return buf;\n    };\n    var fnTyped = {\n      arraySet: function (dest, src, src_offs, len, dest_offs) {\n        if (src.subarray && dest.subarray) {\n          dest.set(src.subarray(src_offs, src_offs + len), dest_offs);\n          return;\n        }\n        for (var i = 0; i < len; i++) {\n          dest[dest_offs + i] = src[src_offs + i];\n        }\n      },\n      flattenChunks: function (chunks) {\n        var i, l, len, pos, chunk, result;\n        len = 0;\n        for (i = 0, l = chunks.length; i < l; i++) {\n          len += chunks[i].length;\n        }\n        result = new Uint8Array(len);\n        pos = 0;\n        for (i = 0, l = chunks.length; i < l; i++) {\n          chunk = chunks[i];\n          result.set(chunk, pos);\n          pos += chunk.length;\n        }\n        return result;\n      },\n    };\n    var fnUntyped = {\n      arraySet: function (dest, src, src_offs, len, dest_offs) {\n        for (var i = 0; i < len; i++) {\n          dest[dest_offs + i] = src[src_offs + i];\n        }\n      },\n      flattenChunks: function (chunks) {\n        return [].concat.apply([], chunks);\n      },\n    };\n    exports.setTyped = function (on) {\n      if (on) {\n        exports.Buf8 = Uint8Array;\n        exports.Buf16 = Uint16Array;\n        exports.Buf32 = Int32Array;\n        exports.assign(exports, fnTyped);\n      } else {\n        exports.Buf8 = Array;\n        exports.Buf16 = Array;\n        exports.Buf32 = Array;\n        exports.assign(exports, fnUntyped);\n      }\n    };\n    exports.setTyped(TYPED_OK);\n  },\n});\n\n// node_modules/pako/lib/zlib/trees.js\nvar require_trees = __commonJS({\n  \"node_modules/pako/lib/zlib/trees.js\"(exports) {\n    \"use strict\";\n    var utils = require_common();\n    var Z_FIXED = 4;\n    var Z_BINARY = 0;\n    var Z_TEXT = 1;\n    var Z_UNKNOWN = 2;\n    function zero(buf) {\n      var len = buf.length;\n      while (--len >= 0) {\n        buf[len] = 0;\n      }\n    }\n    var STORED_BLOCK = 0;\n    var STATIC_TREES = 1;\n    var DYN_TREES = 2;\n    var MIN_MATCH = 3;\n    var MAX_MATCH = 258;\n    var LENGTH_CODES = 29;\n    var LITERALS = 256;\n    var L_CODES = LITERALS + 1 + LENGTH_CODES;\n    var D_CODES = 30;\n    var BL_CODES = 19;\n    var HEAP_SIZE = 2 * L_CODES + 1;\n    var MAX_BITS = 15;\n    var Buf_size = 16;\n    var MAX_BL_BITS = 7;\n    var END_BLOCK = 256;\n    var REP_3_6 = 16;\n    var REPZ_3_10 = 17;\n    var REPZ_11_138 = 18;\n    var extra_lbits = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0];\n    var extra_dbits = [\n      0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13,\n    ];\n    var extra_blbits = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7];\n    var bl_order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];\n    var DIST_CODE_LEN = 512;\n    var static_ltree = new Array((L_CODES + 2) * 2);\n    zero(static_ltree);\n    var static_dtree = new Array(D_CODES * 2);\n    zero(static_dtree);\n    var _dist_code = new Array(DIST_CODE_LEN);\n    zero(_dist_code);\n    var _length_code = new Array(MAX_MATCH - MIN_MATCH + 1);\n    zero(_length_code);\n    var base_length = new Array(LENGTH_CODES);\n    zero(base_length);\n    var base_dist = new Array(D_CODES);\n    zero(base_dist);\n    function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {\n      this.static_tree = static_tree;\n      this.extra_bits = extra_bits;\n      this.extra_base = extra_base;\n      this.elems = elems;\n      this.max_length = max_length;\n      this.has_stree = static_tree && static_tree.length;\n    }\n    var static_l_desc;\n    var static_d_desc;\n    var static_bl_desc;\n    function TreeDesc(dyn_tree, stat_desc) {\n      this.dyn_tree = dyn_tree;\n      this.max_code = 0;\n      this.stat_desc = stat_desc;\n    }\n    function d_code(dist) {\n      return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];\n    }\n    function put_short(s, w) {\n      s.pending_buf[s.pending++] = w & 255;\n      s.pending_buf[s.pending++] = (w >>> 8) & 255;\n    }\n    function send_bits(s, value, length) {\n      if (s.bi_valid > Buf_size - length) {\n        s.bi_buf |= (value << s.bi_valid) & 65535;\n        put_short(s, s.bi_buf);\n        s.bi_buf = value >> (Buf_size - s.bi_valid);\n        s.bi_valid += length - Buf_size;\n      } else {\n        s.bi_buf |= (value << s.bi_valid) & 65535;\n        s.bi_valid += length;\n      }\n    }\n    function send_code(s, c, tree) {\n      send_bits(s, tree[c * 2], tree[c * 2 + 1]);\n    }\n    function bi_reverse(code, len) {\n      var res = 0;\n      do {\n        res |= code & 1;\n        code >>>= 1;\n        res <<= 1;\n      } while (--len > 0);\n      return res >>> 1;\n    }\n    function bi_flush(s) {\n      if (s.bi_valid === 16) {\n        put_short(s, s.bi_buf);\n        s.bi_buf = 0;\n        s.bi_valid = 0;\n      } else if (s.bi_valid >= 8) {\n        s.pending_buf[s.pending++] = s.bi_buf & 255;\n        s.bi_buf >>= 8;\n        s.bi_valid -= 8;\n      }\n    }\n    function gen_bitlen(s, desc) {\n      var tree = desc.dyn_tree;\n      var max_code = desc.max_code;\n      var stree = desc.stat_desc.static_tree;\n      var has_stree = desc.stat_desc.has_stree;\n      var extra = desc.stat_desc.extra_bits;\n      var base = desc.stat_desc.extra_base;\n      var max_length = desc.stat_desc.max_length;\n      var h;\n      var n, m;\n      var bits;\n      var xbits;\n      var f;\n      var overflow = 0;\n      for (bits = 0; bits <= MAX_BITS; bits++) {\n        s.bl_count[bits] = 0;\n      }\n      tree[s.heap[s.heap_max] * 2 + 1] = 0;\n      for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {\n        n = s.heap[h];\n        bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;\n        if (bits > max_length) {\n          bits = max_length;\n          overflow++;\n        }\n        tree[n * 2 + 1] = bits;\n        if (n > max_code) {\n          continue;\n        }\n        s.bl_count[bits]++;\n        xbits = 0;\n        if (n >= base) {\n          xbits = extra[n - base];\n        }\n        f = tree[n * 2];\n        s.opt_len += f * (bits + xbits);\n        if (has_stree) {\n          s.static_len += f * (stree[n * 2 + 1] + xbits);\n        }\n      }\n      if (overflow === 0) {\n        return;\n      }\n      do {\n        bits = max_length - 1;\n        while (s.bl_count[bits] === 0) {\n          bits--;\n        }\n        s.bl_count[bits]--;\n        s.bl_count[bits + 1] += 2;\n        s.bl_count[max_length]--;\n        overflow -= 2;\n      } while (overflow > 0);\n      for (bits = max_length; bits !== 0; bits--) {\n        n = s.bl_count[bits];\n        while (n !== 0) {\n          m = s.heap[--h];\n          if (m > max_code) {\n            continue;\n          }\n          if (tree[m * 2 + 1] !== bits) {\n            s.opt_len += (bits - tree[m * 2 + 1]) * tree[m * 2];\n            tree[m * 2 + 1] = bits;\n          }\n          n--;\n        }\n      }\n    }\n    function gen_codes(tree, max_code, bl_count) {\n      var next_code = new Array(MAX_BITS + 1);\n      var code = 0;\n      var bits;\n      var n;\n      for (bits = 1; bits <= MAX_BITS; bits++) {\n        next_code[bits] = code = (code + bl_count[bits - 1]) << 1;\n      }\n      for (n = 0; n <= max_code; n++) {\n        var len = tree[n * 2 + 1];\n        if (len === 0) {\n          continue;\n        }\n        tree[n * 2] = bi_reverse(next_code[len]++, len);\n      }\n    }\n    function tr_static_init() {\n      var n;\n      var bits;\n      var length;\n      var code;\n      var dist;\n      var bl_count = new Array(MAX_BITS + 1);\n      length = 0;\n      for (code = 0; code < LENGTH_CODES - 1; code++) {\n        base_length[code] = length;\n        for (n = 0; n < 1 << extra_lbits[code]; n++) {\n          _length_code[length++] = code;\n        }\n      }\n      _length_code[length - 1] = code;\n      dist = 0;\n      for (code = 0; code < 16; code++) {\n        base_dist[code] = dist;\n        for (n = 0; n < 1 << extra_dbits[code]; n++) {\n          _dist_code[dist++] = code;\n        }\n      }\n      dist >>= 7;\n      for (; code < D_CODES; code++) {\n        base_dist[code] = dist << 7;\n        for (n = 0; n < 1 << (extra_dbits[code] - 7); n++) {\n          _dist_code[256 + dist++] = code;\n        }\n      }\n      for (bits = 0; bits <= MAX_BITS; bits++) {\n        bl_count[bits] = 0;\n      }\n      n = 0;\n      while (n <= 143) {\n        static_ltree[n * 2 + 1] = 8;\n        n++;\n        bl_count[8]++;\n      }\n      while (n <= 255) {\n        static_ltree[n * 2 + 1] = 9;\n        n++;\n        bl_count[9]++;\n      }\n      while (n <= 279) {\n        static_ltree[n * 2 + 1] = 7;\n        n++;\n        bl_count[7]++;\n      }\n      while (n <= 287) {\n        static_ltree[n * 2 + 1] = 8;\n        n++;\n        bl_count[8]++;\n      }\n      gen_codes(static_ltree, L_CODES + 1, bl_count);\n      for (n = 0; n < D_CODES; n++) {\n        static_dtree[n * 2 + 1] = 5;\n        static_dtree[n * 2] = bi_reverse(n, 5);\n      }\n      static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);\n      static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES, MAX_BITS);\n      static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES, MAX_BL_BITS);\n    }\n    function init_block(s) {\n      var n;\n      for (n = 0; n < L_CODES; n++) {\n        s.dyn_ltree[n * 2] = 0;\n      }\n      for (n = 0; n < D_CODES; n++) {\n        s.dyn_dtree[n * 2] = 0;\n      }\n      for (n = 0; n < BL_CODES; n++) {\n        s.bl_tree[n * 2] = 0;\n      }\n      s.dyn_ltree[END_BLOCK * 2] = 1;\n      s.opt_len = s.static_len = 0;\n      s.last_lit = s.matches = 0;\n    }\n    function bi_windup(s) {\n      if (s.bi_valid > 8) {\n        put_short(s, s.bi_buf);\n      } else if (s.bi_valid > 0) {\n        s.pending_buf[s.pending++] = s.bi_buf;\n      }\n      s.bi_buf = 0;\n      s.bi_valid = 0;\n    }\n    function copy_block(s, buf, len, header) {\n      bi_windup(s);\n      if (header) {\n        put_short(s, len);\n        put_short(s, ~len);\n      }\n      utils.arraySet(s.pending_buf, s.window, buf, len, s.pending);\n      s.pending += len;\n    }\n    function smaller(tree, n, m, depth) {\n      var _n2 = n * 2;\n      var _m2 = m * 2;\n      return tree[_n2] < tree[_m2] || (tree[_n2] === tree[_m2] && depth[n] <= depth[m]);\n    }\n    function pqdownheap(s, tree, k) {\n      var v = s.heap[k];\n      var j = k << 1;\n      while (j <= s.heap_len) {\n        if (j < s.heap_len && smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {\n          j++;\n        }\n        if (smaller(tree, v, s.heap[j], s.depth)) {\n          break;\n        }\n        s.heap[k] = s.heap[j];\n        k = j;\n        j <<= 1;\n      }\n      s.heap[k] = v;\n    }\n    function compress_block(s, ltree, dtree) {\n      var dist;\n      var lc;\n      var lx = 0;\n      var code;\n      var extra;\n      if (s.last_lit !== 0) {\n        do {\n          dist = (s.pending_buf[s.d_buf + lx * 2] << 8) | s.pending_buf[s.d_buf + lx * 2 + 1];\n          lc = s.pending_buf[s.l_buf + lx];\n          lx++;\n          if (dist === 0) {\n            send_code(s, lc, ltree);\n          } else {\n            code = _length_code[lc];\n            send_code(s, code + LITERALS + 1, ltree);\n            extra = extra_lbits[code];\n            if (extra !== 0) {\n              lc -= base_length[code];\n              send_bits(s, lc, extra);\n            }\n            dist--;\n            code = d_code(dist);\n            send_code(s, code, dtree);\n            extra = extra_dbits[code];\n            if (extra !== 0) {\n              dist -= base_dist[code];\n              send_bits(s, dist, extra);\n            }\n          }\n        } while (lx < s.last_lit);\n      }\n      send_code(s, END_BLOCK, ltree);\n    }\n    function build_tree(s, desc) {\n      var tree = desc.dyn_tree;\n      var stree = desc.stat_desc.static_tree;\n      var has_stree = desc.stat_desc.has_stree;\n      var elems = desc.stat_desc.elems;\n      var n, m;\n      var max_code = -1;\n      var node;\n      s.heap_len = 0;\n      s.heap_max = HEAP_SIZE;\n      for (n = 0; n < elems; n++) {\n        if (tree[n * 2] !== 0) {\n          s.heap[++s.heap_len] = max_code = n;\n          s.depth[n] = 0;\n        } else {\n          tree[n * 2 + 1] = 0;\n        }\n      }\n      while (s.heap_len < 2) {\n        node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;\n        tree[node * 2] = 1;\n        s.depth[node] = 0;\n        s.opt_len--;\n        if (has_stree) {\n          s.static_len -= stree[node * 2 + 1];\n        }\n      }\n      desc.max_code = max_code;\n      for (n = s.heap_len >> 1; n >= 1; n--) {\n        pqdownheap(s, tree, n);\n      }\n      node = elems;\n      do {\n        n = s.heap[1];\n        s.heap[1] = s.heap[s.heap_len--];\n        pqdownheap(s, tree, 1);\n        m = s.heap[1];\n        s.heap[--s.heap_max] = n;\n        s.heap[--s.heap_max] = m;\n        tree[node * 2] = tree[n * 2] + tree[m * 2];\n        s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;\n        tree[n * 2 + 1] = tree[m * 2 + 1] = node;\n        s.heap[1] = node++;\n        pqdownheap(s, tree, 1);\n      } while (s.heap_len >= 2);\n      s.heap[--s.heap_max] = s.heap[1];\n      gen_bitlen(s, desc);\n      gen_codes(tree, max_code, s.bl_count);\n    }\n    function scan_tree(s, tree, max_code) {\n      var n;\n      var prevlen = -1;\n      var curlen;\n      var nextlen = tree[0 * 2 + 1];\n      var count = 0;\n      var max_count = 7;\n      var min_count = 4;\n      if (nextlen === 0) {\n        max_count = 138;\n        min_count = 3;\n      }\n      tree[(max_code + 1) * 2 + 1] = 65535;\n      for (n = 0; n <= max_code; n++) {\n        curlen = nextlen;\n        nextlen = tree[(n + 1) * 2 + 1];\n        if (++count < max_count && curlen === nextlen) {\n          continue;\n        } else if (count < min_count) {\n          s.bl_tree[curlen * 2] += count;\n        } else if (curlen !== 0) {\n          if (curlen !== prevlen) {\n            s.bl_tree[curlen * 2]++;\n          }\n          s.bl_tree[REP_3_6 * 2]++;\n        } else if (count <= 10) {\n          s.bl_tree[REPZ_3_10 * 2]++;\n        } else {\n          s.bl_tree[REPZ_11_138 * 2]++;\n        }\n        count = 0;\n        prevlen = curlen;\n        if (nextlen === 0) {\n          max_count = 138;\n          min_count = 3;\n        } else if (curlen === nextlen) {\n          max_count = 6;\n          min_count = 3;\n        } else {\n          max_count = 7;\n          min_count = 4;\n        }\n      }\n    }\n    function send_tree(s, tree, max_code) {\n      var n;\n      var prevlen = -1;\n      var curlen;\n      var nextlen = tree[0 * 2 + 1];\n      var count = 0;\n      var max_count = 7;\n      var min_count = 4;\n      if (nextlen === 0) {\n        max_count = 138;\n        min_count = 3;\n      }\n      for (n = 0; n <= max_code; n++) {\n        curlen = nextlen;\n        nextlen = tree[(n + 1) * 2 + 1];\n        if (++count < max_count && curlen === nextlen) {\n          continue;\n        } else if (count < min_count) {\n          do {\n            send_code(s, curlen, s.bl_tree);\n          } while (--count !== 0);\n        } else if (curlen !== 0) {\n          if (curlen !== prevlen) {\n            send_code(s, curlen, s.bl_tree);\n            count--;\n          }\n          send_code(s, REP_3_6, s.bl_tree);\n          send_bits(s, count - 3, 2);\n        } else if (count <= 10) {\n          send_code(s, REPZ_3_10, s.bl_tree);\n          send_bits(s, count - 3, 3);\n        } else {\n          send_code(s, REPZ_11_138, s.bl_tree);\n          send_bits(s, count - 11, 7);\n        }\n        count = 0;\n        prevlen = curlen;\n        if (nextlen === 0) {\n          max_count = 138;\n          min_count = 3;\n        } else if (curlen === nextlen) {\n          max_count = 6;\n          min_count = 3;\n        } else {\n          max_count = 7;\n          min_count = 4;\n        }\n      }\n    }\n    function build_bl_tree(s) {\n      var max_blindex;\n      scan_tree(s, s.dyn_ltree, s.l_desc.max_code);\n      scan_tree(s, s.dyn_dtree, s.d_desc.max_code);\n      build_tree(s, s.bl_desc);\n      for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {\n        if (s.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0) {\n          break;\n        }\n      }\n      s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;\n      return max_blindex;\n    }\n    function send_all_trees(s, lcodes, dcodes, blcodes) {\n      var rank;\n      send_bits(s, lcodes - 257, 5);\n      send_bits(s, dcodes - 1, 5);\n      send_bits(s, blcodes - 4, 4);\n      for (rank = 0; rank < blcodes; rank++) {\n        send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1], 3);\n      }\n      send_tree(s, s.dyn_ltree, lcodes - 1);\n      send_tree(s, s.dyn_dtree, dcodes - 1);\n    }\n    function detect_data_type(s) {\n      var black_mask = 4093624447;\n      var n;\n      for (n = 0; n <= 31; n++, black_mask >>>= 1) {\n        if (black_mask & 1 && s.dyn_ltree[n * 2] !== 0) {\n          return Z_BINARY;\n        }\n      }\n      if (s.dyn_ltree[9 * 2] !== 0 || s.dyn_ltree[10 * 2] !== 0 || s.dyn_ltree[13 * 2] !== 0) {\n        return Z_TEXT;\n      }\n      for (n = 32; n < LITERALS; n++) {\n        if (s.dyn_ltree[n * 2] !== 0) {\n          return Z_TEXT;\n        }\n      }\n      return Z_BINARY;\n    }\n    var static_init_done = false;\n    function _tr_init(s) {\n      if (!static_init_done) {\n        tr_static_init();\n        static_init_done = true;\n      }\n      s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc);\n      s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc);\n      s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);\n      s.bi_buf = 0;\n      s.bi_valid = 0;\n      init_block(s);\n    }\n    function _tr_stored_block(s, buf, stored_len, last) {\n      send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);\n      copy_block(s, buf, stored_len, true);\n    }\n    function _tr_align(s) {\n      send_bits(s, STATIC_TREES << 1, 3);\n      send_code(s, END_BLOCK, static_ltree);\n      bi_flush(s);\n    }\n    function _tr_flush_block(s, buf, stored_len, last) {\n      var opt_lenb, static_lenb;\n      var max_blindex = 0;\n      if (s.level > 0) {\n        if (s.strm.data_type === Z_UNKNOWN) {\n          s.strm.data_type = detect_data_type(s);\n        }\n        build_tree(s, s.l_desc);\n        build_tree(s, s.d_desc);\n        max_blindex = build_bl_tree(s);\n        opt_lenb = (s.opt_len + 3 + 7) >>> 3;\n        static_lenb = (s.static_len + 3 + 7) >>> 3;\n        if (static_lenb <= opt_lenb) {\n          opt_lenb = static_lenb;\n        }\n      } else {\n        opt_lenb = static_lenb = stored_len + 5;\n      }\n      if (stored_len + 4 <= opt_lenb && buf !== -1) {\n        _tr_stored_block(s, buf, stored_len, last);\n      } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {\n        send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);\n        compress_block(s, static_ltree, static_dtree);\n      } else {\n        send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);\n        send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);\n        compress_block(s, s.dyn_ltree, s.dyn_dtree);\n      }\n      init_block(s);\n      if (last) {\n        bi_windup(s);\n      }\n    }\n    function _tr_tally(s, dist, lc) {\n      s.pending_buf[s.d_buf + s.last_lit * 2] = (dist >>> 8) & 255;\n      s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 255;\n      s.pending_buf[s.l_buf + s.last_lit] = lc & 255;\n      s.last_lit++;\n      if (dist === 0) {\n        s.dyn_ltree[lc * 2]++;\n      } else {\n        s.matches++;\n        dist--;\n        s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]++;\n        s.dyn_dtree[d_code(dist) * 2]++;\n      }\n      return s.last_lit === s.lit_bufsize - 1;\n    }\n    exports._tr_init = _tr_init;\n    exports._tr_stored_block = _tr_stored_block;\n    exports._tr_flush_block = _tr_flush_block;\n    exports._tr_tally = _tr_tally;\n    exports._tr_align = _tr_align;\n  },\n});\n\n// node_modules/pako/lib/zlib/adler32.js\nvar require_adler32 = __commonJS({\n  \"node_modules/pako/lib/zlib/adler32.js\"(exports, module2) {\n    \"use strict\";\n    function adler32(adler, buf, len, pos) {\n      var s1 = (adler & 65535) | 0,\n        s2 = ((adler >>> 16) & 65535) | 0,\n        n = 0;\n      while (len !== 0) {\n        n = len > 2e3 ? 2e3 : len;\n        len -= n;\n        do {\n          s1 = (s1 + buf[pos++]) | 0;\n          s2 = (s2 + s1) | 0;\n        } while (--n);\n        s1 %= 65521;\n        s2 %= 65521;\n      }\n      return s1 | (s2 << 16) | 0;\n    }\n    module2.exports = adler32;\n  },\n});\n\n// node_modules/pako/lib/zlib/crc32.js\nvar require_crc32 = __commonJS({\n  \"node_modules/pako/lib/zlib/crc32.js\"(exports, module2) {\n    \"use strict\";\n    function makeTable() {\n      var c,\n        table = [];\n      for (var n = 0; n < 256; n++) {\n        c = n;\n        for (var k = 0; k < 8; k++) {\n          c = c & 1 ? 3988292384 ^ (c >>> 1) : c >>> 1;\n        }\n        table[n] = c;\n      }\n      return table;\n    }\n    var crcTable = makeTable();\n    function crc32(crc, buf, len, pos) {\n      var t = crcTable,\n        end = pos + len;\n      crc ^= -1;\n      for (var i = pos; i < end; i++) {\n        crc = (crc >>> 8) ^ t[(crc ^ buf[i]) & 255];\n      }\n      return crc ^ -1;\n    }\n    module2.exports = crc32;\n  },\n});\n\n// node_modules/pako/lib/zlib/messages.js\nvar require_messages = __commonJS({\n  \"node_modules/pako/lib/zlib/messages.js\"(exports, module2) {\n    \"use strict\";\n    module2.exports = {\n      2: \"need dictionary\",\n      1: \"stream end\",\n      0: \"\",\n      \"-1\": \"file error\",\n      \"-2\": \"stream error\",\n      \"-3\": \"data error\",\n      \"-4\": \"insufficient memory\",\n      \"-5\": \"buffer error\",\n      \"-6\": \"incompatible version\",\n    };\n  },\n});\n\n// node_modules/pako/lib/zlib/deflate.js\nvar require_deflate = __commonJS({\n  \"node_modules/pako/lib/zlib/deflate.js\"(exports) {\n    \"use strict\";\n    var utils = require_common();\n    var trees = require_trees();\n    var adler32 = require_adler32();\n    var crc32 = require_crc32();\n    var msg = require_messages();\n    var Z_NO_FLUSH = 0;\n    var Z_PARTIAL_FLUSH = 1;\n    var Z_FULL_FLUSH = 3;\n    var Z_FINISH = 4;\n    var Z_BLOCK = 5;\n    var Z_OK = 0;\n    var Z_STREAM_END = 1;\n    var Z_STREAM_ERROR = -2;\n    var Z_DATA_ERROR = -3;\n    var Z_BUF_ERROR = -5;\n    var Z_DEFAULT_COMPRESSION = -1;\n    var Z_FILTERED = 1;\n    var Z_HUFFMAN_ONLY = 2;\n    var Z_RLE = 3;\n    var Z_FIXED = 4;\n    var Z_DEFAULT_STRATEGY = 0;\n    var Z_UNKNOWN = 2;\n    var Z_DEFLATED = 8;\n    var MAX_MEM_LEVEL = 9;\n    var MAX_WBITS = 15;\n    var DEF_MEM_LEVEL = 8;\n    var LENGTH_CODES = 29;\n    var LITERALS = 256;\n    var L_CODES = LITERALS + 1 + LENGTH_CODES;\n    var D_CODES = 30;\n    var BL_CODES = 19;\n    var HEAP_SIZE = 2 * L_CODES + 1;\n    var MAX_BITS = 15;\n    var MIN_MATCH = 3;\n    var MAX_MATCH = 258;\n    var MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;\n    var PRESET_DICT = 32;\n    var INIT_STATE = 42;\n    var EXTRA_STATE = 69;\n    var NAME_STATE = 73;\n    var COMMENT_STATE = 91;\n    var HCRC_STATE = 103;\n    var BUSY_STATE = 113;\n    var FINISH_STATE = 666;\n    var BS_NEED_MORE = 1;\n    var BS_BLOCK_DONE = 2;\n    var BS_FINISH_STARTED = 3;\n    var BS_FINISH_DONE = 4;\n    var OS_CODE = 3;\n    function err(strm, errorCode) {\n      strm.msg = msg[errorCode];\n      return errorCode;\n    }\n    function rank(f) {\n      return (f << 1) - (f > 4 ? 9 : 0);\n    }\n    function zero(buf) {\n      var len = buf.length;\n      while (--len >= 0) {\n        buf[len] = 0;\n      }\n    }\n    function flush_pending(strm) {\n      var s = strm.state;\n      var len = s.pending;\n      if (len > strm.avail_out) {\n        len = strm.avail_out;\n      }\n      if (len === 0) {\n        return;\n      }\n      utils.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);\n      strm.next_out += len;\n      s.pending_out += len;\n      strm.total_out += len;\n      strm.avail_out -= len;\n      s.pending -= len;\n      if (s.pending === 0) {\n        s.pending_out = 0;\n      }\n    }\n    function flush_block_only(s, last) {\n      trees._tr_flush_block(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last);\n      s.block_start = s.strstart;\n      flush_pending(s.strm);\n    }\n    function put_byte(s, b) {\n      s.pending_buf[s.pending++] = b;\n    }\n    function putShortMSB(s, b) {\n      s.pending_buf[s.pending++] = (b >>> 8) & 255;\n      s.pending_buf[s.pending++] = b & 255;\n    }\n    function read_buf(strm, buf, start, size) {\n      var len = strm.avail_in;\n      if (len > size) {\n        len = size;\n      }\n      if (len === 0) {\n        return 0;\n      }\n      strm.avail_in -= len;\n      utils.arraySet(buf, strm.input, strm.next_in, len, start);\n      if (strm.state.wrap === 1) {\n        strm.adler = adler32(strm.adler, buf, len, start);\n      } else if (strm.state.wrap === 2) {\n        strm.adler = crc32(strm.adler, buf, len, start);\n      }\n      strm.next_in += len;\n      strm.total_in += len;\n      return len;\n    }\n    function longest_match(s, cur_match) {\n      var chain_length = s.max_chain_length;\n      var scan = s.strstart;\n      var match;\n      var len;\n      var best_len = s.prev_length;\n      var nice_match = s.nice_match;\n      var limit = s.strstart > s.w_size - MIN_LOOKAHEAD ? s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0;\n      var _win = s.window;\n      var wmask = s.w_mask;\n      var prev = s.prev;\n      var strend = s.strstart + MAX_MATCH;\n      var scan_end1 = _win[scan + best_len - 1];\n      var scan_end = _win[scan + best_len];\n      if (s.prev_length >= s.good_match) {\n        chain_length >>= 2;\n      }\n      if (nice_match > s.lookahead) {\n        nice_match = s.lookahead;\n      }\n      do {\n        match = cur_match;\n        if (\n          _win[match + best_len] !== scan_end ||\n          _win[match + best_len - 1] !== scan_end1 ||\n          _win[match] !== _win[scan] ||\n          _win[++match] !== _win[scan + 1]\n        ) {\n          continue;\n        }\n        scan += 2;\n        match++;\n        do {} while (\n          _win[++scan] === _win[++match] &&\n          _win[++scan] === _win[++match] &&\n          _win[++scan] === _win[++match] &&\n          _win[++scan] === _win[++match] &&\n          _win[++scan] === _win[++match] &&\n          _win[++scan] === _win[++match] &&\n          _win[++scan] === _win[++match] &&\n          _win[++scan] === _win[++match] &&\n          scan < strend\n        );\n        len = MAX_MATCH - (strend - scan);\n        scan = strend - MAX_MATCH;\n        if (len > best_len) {\n          s.match_start = cur_match;\n          best_len = len;\n          if (len >= nice_match) {\n            break;\n          }\n          scan_end1 = _win[scan + best_len - 1];\n          scan_end = _win[scan + best_len];\n        }\n      } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);\n      if (best_len <= s.lookahead) {\n        return best_len;\n      }\n      return s.lookahead;\n    }\n    function fill_window(s) {\n      var _w_size = s.w_size;\n      var p, n, m, more, str;\n      do {\n        more = s.window_size - s.lookahead - s.strstart;\n        if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {\n          utils.arraySet(s.window, s.window, _w_size, _w_size, 0);\n          s.match_start -= _w_size;\n          s.strstart -= _w_size;\n          s.block_start -= _w_size;\n          n = s.hash_size;\n          p = n;\n          do {\n            m = s.head[--p];\n            s.head[p] = m >= _w_size ? m - _w_size : 0;\n          } while (--n);\n          n = _w_size;\n          p = n;\n          do {\n            m = s.prev[--p];\n            s.prev[p] = m >= _w_size ? m - _w_size : 0;\n          } while (--n);\n          more += _w_size;\n        }\n        if (s.strm.avail_in === 0) {\n          break;\n        }\n        n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);\n        s.lookahead += n;\n        if (s.lookahead + s.insert >= MIN_MATCH) {\n          str = s.strstart - s.insert;\n          s.ins_h = s.window[str];\n          s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + 1]) & s.hash_mask;\n          while (s.insert) {\n            s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;\n            s.prev[str & s.w_mask] = s.head[s.ins_h];\n            s.head[s.ins_h] = str;\n            str++;\n            s.insert--;\n            if (s.lookahead + s.insert < MIN_MATCH) {\n              break;\n            }\n          }\n        }\n      } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);\n    }\n    function deflate_stored(s, flush) {\n      var max_block_size = 65535;\n      if (max_block_size > s.pending_buf_size - 5) {\n        max_block_size = s.pending_buf_size - 5;\n      }\n      for (;;) {\n        if (s.lookahead <= 1) {\n          fill_window(s);\n          if (s.lookahead === 0 && flush === Z_NO_FLUSH) {\n            return BS_NEED_MORE;\n          }\n          if (s.lookahead === 0) {\n            break;\n          }\n        }\n        s.strstart += s.lookahead;\n        s.lookahead = 0;\n        var max_start = s.block_start + max_block_size;\n        if (s.strstart === 0 || s.strstart >= max_start) {\n          s.lookahead = s.strstart - max_start;\n          s.strstart = max_start;\n          flush_block_only(s, false);\n          if (s.strm.avail_out === 0) {\n            return BS_NEED_MORE;\n          }\n        }\n        if (s.strstart - s.block_start >= s.w_size - MIN_LOOKAHEAD) {\n          flush_block_only(s, false);\n          if (s.strm.avail_out === 0) {\n            return BS_NEED_MORE;\n          }\n        }\n      }\n      s.insert = 0;\n      if (flush === Z_FINISH) {\n        flush_block_only(s, true);\n        if (s.strm.avail_out === 0) {\n          return BS_FINISH_STARTED;\n        }\n        return BS_FINISH_DONE;\n      }\n      if (s.strstart > s.block_start) {\n        flush_block_only(s, false);\n        if (s.strm.avail_out === 0) {\n          return BS_NEED_MORE;\n        }\n      }\n      return BS_NEED_MORE;\n    }\n    function deflate_fast(s, flush) {\n      var hash_head;\n      var bflush;\n      for (;;) {\n        if (s.lookahead < MIN_LOOKAHEAD) {\n          fill_window(s);\n          if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {\n            return BS_NEED_MORE;\n          }\n          if (s.lookahead === 0) {\n            break;\n          }\n        }\n        hash_head = 0;\n        if (s.lookahead >= MIN_MATCH) {\n          s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\n          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n          s.head[s.ins_h] = s.strstart;\n        }\n        if (hash_head !== 0 && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {\n          s.match_length = longest_match(s, hash_head);\n        }\n        if (s.match_length >= MIN_MATCH) {\n          bflush = trees._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);\n          s.lookahead -= s.match_length;\n          if (s.match_length <= s.max_lazy_match && s.lookahead >= MIN_MATCH) {\n            s.match_length--;\n            do {\n              s.strstart++;\n              s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\n              hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n              s.head[s.ins_h] = s.strstart;\n            } while (--s.match_length !== 0);\n            s.strstart++;\n          } else {\n            s.strstart += s.match_length;\n            s.match_length = 0;\n            s.ins_h = s.window[s.strstart];\n            s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + 1]) & s.hash_mask;\n          }\n        } else {\n          bflush = trees._tr_tally(s, 0, s.window[s.strstart]);\n          s.lookahead--;\n          s.strstart++;\n        }\n        if (bflush) {\n          flush_block_only(s, false);\n          if (s.strm.avail_out === 0) {\n            return BS_NEED_MORE;\n          }\n        }\n      }\n      s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;\n      if (flush === Z_FINISH) {\n        flush_block_only(s, true);\n        if (s.strm.avail_out === 0) {\n          return BS_FINISH_STARTED;\n        }\n        return BS_FINISH_DONE;\n      }\n      if (s.last_lit) {\n        flush_block_only(s, false);\n        if (s.strm.avail_out === 0) {\n          return BS_NEED_MORE;\n        }\n      }\n      return BS_BLOCK_DONE;\n    }\n    function deflate_slow(s, flush) {\n      var hash_head;\n      var bflush;\n      var max_insert;\n      for (;;) {\n        if (s.lookahead < MIN_LOOKAHEAD) {\n          fill_window(s);\n          if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {\n            return BS_NEED_MORE;\n          }\n          if (s.lookahead === 0) {\n            break;\n          }\n        }\n        hash_head = 0;\n        if (s.lookahead >= MIN_MATCH) {\n          s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\n          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n          s.head[s.ins_h] = s.strstart;\n        }\n        s.prev_length = s.match_length;\n        s.prev_match = s.match_start;\n        s.match_length = MIN_MATCH - 1;\n        if (hash_head !== 0 && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {\n          s.match_length = longest_match(s, hash_head);\n          if (\n            s.match_length <= 5 &&\n            (s.strategy === Z_FILTERED || (s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096))\n          ) {\n            s.match_length = MIN_MATCH - 1;\n          }\n        }\n        if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {\n          max_insert = s.strstart + s.lookahead - MIN_MATCH;\n          bflush = trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);\n          s.lookahead -= s.prev_length - 1;\n          s.prev_length -= 2;\n          do {\n            if (++s.strstart <= max_insert) {\n              s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\n              hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n              s.head[s.ins_h] = s.strstart;\n            }\n          } while (--s.prev_length !== 0);\n          s.match_available = 0;\n          s.match_length = MIN_MATCH - 1;\n          s.strstart++;\n          if (bflush) {\n            flush_block_only(s, false);\n            if (s.strm.avail_out === 0) {\n              return BS_NEED_MORE;\n            }\n          }\n        } else if (s.match_available) {\n          bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);\n          if (bflush) {\n            flush_block_only(s, false);\n          }\n          s.strstart++;\n          s.lookahead--;\n          if (s.strm.avail_out === 0) {\n            return BS_NEED_MORE;\n          }\n        } else {\n          s.match_available = 1;\n          s.strstart++;\n          s.lookahead--;\n        }\n      }\n      if (s.match_available) {\n        bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);\n        s.match_available = 0;\n      }\n      s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;\n      if (flush === Z_FINISH) {\n        flush_block_only(s, true);\n        if (s.strm.avail_out === 0) {\n          return BS_FINISH_STARTED;\n        }\n        return BS_FINISH_DONE;\n      }\n      if (s.last_lit) {\n        flush_block_only(s, false);\n        if (s.strm.avail_out === 0) {\n          return BS_NEED_MORE;\n        }\n      }\n      return BS_BLOCK_DONE;\n    }\n    function deflate_rle(s, flush) {\n      var bflush;\n      var prev;\n      var scan, strend;\n      var _win = s.window;\n      for (;;) {\n        if (s.lookahead <= MAX_MATCH) {\n          fill_window(s);\n          if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {\n            return BS_NEED_MORE;\n          }\n          if (s.lookahead === 0) {\n            break;\n          }\n        }\n        s.match_length = 0;\n        if (s.lookahead >= MIN_MATCH && s.strstart > 0) {\n          scan = s.strstart - 1;\n          prev = _win[scan];\n          if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {\n            strend = s.strstart + MAX_MATCH;\n            do {} while (\n              prev === _win[++scan] &&\n              prev === _win[++scan] &&\n              prev === _win[++scan] &&\n              prev === _win[++scan] &&\n              prev === _win[++scan] &&\n              prev === _win[++scan] &&\n              prev === _win[++scan] &&\n              prev === _win[++scan] &&\n              scan < strend\n            );\n            s.match_length = MAX_MATCH - (strend - scan);\n            if (s.match_length > s.lookahead) {\n              s.match_length = s.lookahead;\n            }\n          }\n        }\n        if (s.match_length >= MIN_MATCH) {\n          bflush = trees._tr_tally(s, 1, s.match_length - MIN_MATCH);\n          s.lookahead -= s.match_length;\n          s.strstart += s.match_length;\n          s.match_length = 0;\n        } else {\n          bflush = trees._tr_tally(s, 0, s.window[s.strstart]);\n          s.lookahead--;\n          s.strstart++;\n        }\n        if (bflush) {\n          flush_block_only(s, false);\n          if (s.strm.avail_out === 0) {\n            return BS_NEED_MORE;\n          }\n        }\n      }\n      s.insert = 0;\n      if (flush === Z_FINISH) {\n        flush_block_only(s, true);\n        if (s.strm.avail_out === 0) {\n          return BS_FINISH_STARTED;\n        }\n        return BS_FINISH_DONE;\n      }\n      if (s.last_lit) {\n        flush_block_only(s, false);\n        if (s.strm.avail_out === 0) {\n          return BS_NEED_MORE;\n        }\n      }\n      return BS_BLOCK_DONE;\n    }\n    function deflate_huff(s, flush) {\n      var bflush;\n      for (;;) {\n        if (s.lookahead === 0) {\n          fill_window(s);\n          if (s.lookahead === 0) {\n            if (flush === Z_NO_FLUSH) {\n              return BS_NEED_MORE;\n            }\n            break;\n          }\n        }\n        s.match_length = 0;\n        bflush = trees._tr_tally(s, 0, s.window[s.strstart]);\n        s.lookahead--;\n        s.strstart++;\n        if (bflush) {\n          flush_block_only(s, false);\n          if (s.strm.avail_out === 0) {\n            return BS_NEED_MORE;\n          }\n        }\n      }\n      s.insert = 0;\n      if (flush === Z_FINISH) {\n        flush_block_only(s, true);\n        if (s.strm.avail_out === 0) {\n          return BS_FINISH_STARTED;\n        }\n        return BS_FINISH_DONE;\n      }\n      if (s.last_lit) {\n        flush_block_only(s, false);\n        if (s.strm.avail_out === 0) {\n          return BS_NEED_MORE;\n        }\n      }\n      return BS_BLOCK_DONE;\n    }\n    function Config(good_length, max_lazy, nice_length, max_chain, func) {\n      this.good_length = good_length;\n      this.max_lazy = max_lazy;\n      this.nice_length = nice_length;\n      this.max_chain = max_chain;\n      this.func = func;\n    }\n    var configuration_table;\n    configuration_table = [\n      new Config(0, 0, 0, 0, deflate_stored),\n      new Config(4, 4, 8, 4, deflate_fast),\n      new Config(4, 5, 16, 8, deflate_fast),\n      new Config(4, 6, 32, 32, deflate_fast),\n      new Config(4, 4, 16, 16, deflate_slow),\n      new Config(8, 16, 32, 32, deflate_slow),\n      new Config(8, 16, 128, 128, deflate_slow),\n      new Config(8, 32, 128, 256, deflate_slow),\n      new Config(32, 128, 258, 1024, deflate_slow),\n      new Config(32, 258, 258, 4096, deflate_slow),\n    ];\n    function lm_init(s) {\n      s.window_size = 2 * s.w_size;\n      zero(s.head);\n      s.max_lazy_match = configuration_table[s.level].max_lazy;\n      s.good_match = configuration_table[s.level].good_length;\n      s.nice_match = configuration_table[s.level].nice_length;\n      s.max_chain_length = configuration_table[s.level].max_chain;\n      s.strstart = 0;\n      s.block_start = 0;\n      s.lookahead = 0;\n      s.insert = 0;\n      s.match_length = s.prev_length = MIN_MATCH - 1;\n      s.match_available = 0;\n      s.ins_h = 0;\n    }\n    function DeflateState() {\n      this.strm = null;\n      this.status = 0;\n      this.pending_buf = null;\n      this.pending_buf_size = 0;\n      this.pending_out = 0;\n      this.pending = 0;\n      this.wrap = 0;\n      this.gzhead = null;\n      this.gzindex = 0;\n      this.method = Z_DEFLATED;\n      this.last_flush = -1;\n      this.w_size = 0;\n      this.w_bits = 0;\n      this.w_mask = 0;\n      this.window = null;\n      this.window_size = 0;\n      this.prev = null;\n      this.head = null;\n      this.ins_h = 0;\n      this.hash_size = 0;\n      this.hash_bits = 0;\n      this.hash_mask = 0;\n      this.hash_shift = 0;\n      this.block_start = 0;\n      this.match_length = 0;\n      this.prev_match = 0;\n      this.match_available = 0;\n      this.strstart = 0;\n      this.match_start = 0;\n      this.lookahead = 0;\n      this.prev_length = 0;\n      this.max_chain_length = 0;\n      this.max_lazy_match = 0;\n      this.level = 0;\n      this.strategy = 0;\n      this.good_match = 0;\n      this.nice_match = 0;\n      this.dyn_ltree = new utils.Buf16(HEAP_SIZE * 2);\n      this.dyn_dtree = new utils.Buf16((2 * D_CODES + 1) * 2);\n      this.bl_tree = new utils.Buf16((2 * BL_CODES + 1) * 2);\n      zero(this.dyn_ltree);\n      zero(this.dyn_dtree);\n      zero(this.bl_tree);\n      this.l_desc = null;\n      this.d_desc = null;\n      this.bl_desc = null;\n      this.bl_count = new utils.Buf16(MAX_BITS + 1);\n      this.heap = new utils.Buf16(2 * L_CODES + 1);\n      zero(this.heap);\n      this.heap_len = 0;\n      this.heap_max = 0;\n      this.depth = new utils.Buf16(2 * L_CODES + 1);\n      zero(this.depth);\n      this.l_buf = 0;\n      this.lit_bufsize = 0;\n      this.last_lit = 0;\n      this.d_buf = 0;\n      this.opt_len = 0;\n      this.static_len = 0;\n      this.matches = 0;\n      this.insert = 0;\n      this.bi_buf = 0;\n      this.bi_valid = 0;\n    }\n    function deflateResetKeep(strm) {\n      var s;\n      if (!strm || !strm.state) {\n        return err(strm, Z_STREAM_ERROR);\n      }\n      strm.total_in = strm.total_out = 0;\n      strm.data_type = Z_UNKNOWN;\n      s = strm.state;\n      s.pending = 0;\n      s.pending_out = 0;\n      if (s.wrap < 0) {\n        s.wrap = -s.wrap;\n      }\n      s.status = s.wrap ? INIT_STATE : BUSY_STATE;\n      strm.adler = s.wrap === 2 ? 0 : 1;\n      s.last_flush = Z_NO_FLUSH;\n      trees._tr_init(s);\n      return Z_OK;\n    }\n    function deflateReset(strm) {\n      var ret = deflateResetKeep(strm);\n      if (ret === Z_OK) {\n        lm_init(strm.state);\n      }\n      return ret;\n    }\n    function deflateSetHeader(strm, head) {\n      if (!strm || !strm.state) {\n        return Z_STREAM_ERROR;\n      }\n      if (strm.state.wrap !== 2) {\n        return Z_STREAM_ERROR;\n      }\n      strm.state.gzhead = head;\n      return Z_OK;\n    }\n    function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {\n      if (!strm) {\n        return Z_STREAM_ERROR;\n      }\n      var wrap = 1;\n      if (level === Z_DEFAULT_COMPRESSION) {\n        level = 6;\n      }\n      if (windowBits < 0) {\n        wrap = 0;\n        windowBits = -windowBits;\n      } else if (windowBits > 15) {\n        wrap = 2;\n        windowBits -= 16;\n      }\n      if (\n        memLevel < 1 ||\n        memLevel > MAX_MEM_LEVEL ||\n        method !== Z_DEFLATED ||\n        windowBits < 8 ||\n        windowBits > 15 ||\n        level < 0 ||\n        level > 9 ||\n        strategy < 0 ||\n        strategy > Z_FIXED\n      ) {\n        return err(strm, Z_STREAM_ERROR);\n      }\n      if (windowBits === 8) {\n        windowBits = 9;\n      }\n      var s = new DeflateState();\n      strm.state = s;\n      s.strm = strm;\n      s.wrap = wrap;\n      s.gzhead = null;\n      s.w_bits = windowBits;\n      s.w_size = 1 << s.w_bits;\n      s.w_mask = s.w_size - 1;\n      s.hash_bits = memLevel + 7;\n      s.hash_size = 1 << s.hash_bits;\n      s.hash_mask = s.hash_size - 1;\n      s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);\n      s.window = new utils.Buf8(s.w_size * 2);\n      s.head = new utils.Buf16(s.hash_size);\n      s.prev = new utils.Buf16(s.w_size);\n      s.lit_bufsize = 1 << (memLevel + 6);\n      s.pending_buf_size = s.lit_bufsize * 4;\n      s.pending_buf = new utils.Buf8(s.pending_buf_size);\n      s.d_buf = 1 * s.lit_bufsize;\n      s.l_buf = (1 + 2) * s.lit_bufsize;\n      s.level = level;\n      s.strategy = strategy;\n      s.method = method;\n      return deflateReset(strm);\n    }\n    function deflateInit(strm, level) {\n      return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);\n    }\n    function deflate(strm, flush) {\n      var old_flush, s;\n      var beg, val;\n      if (!strm || !strm.state || flush > Z_BLOCK || flush < 0) {\n        return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;\n      }\n      s = strm.state;\n      if (!strm.output || (!strm.input && strm.avail_in !== 0) || (s.status === FINISH_STATE && flush !== Z_FINISH)) {\n        return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR : Z_STREAM_ERROR);\n      }\n      s.strm = strm;\n      old_flush = s.last_flush;\n      s.last_flush = flush;\n      if (s.status === INIT_STATE) {\n        if (s.wrap === 2) {\n          strm.adler = 0;\n          put_byte(s, 31);\n          put_byte(s, 139);\n          put_byte(s, 8);\n          if (!s.gzhead) {\n            put_byte(s, 0);\n            put_byte(s, 0);\n            put_byte(s, 0);\n            put_byte(s, 0);\n            put_byte(s, 0);\n            put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);\n            put_byte(s, OS_CODE);\n            s.status = BUSY_STATE;\n          } else {\n            put_byte(\n              s,\n              (s.gzhead.text ? 1 : 0) +\n                (s.gzhead.hcrc ? 2 : 0) +\n                (!s.gzhead.extra ? 0 : 4) +\n                (!s.gzhead.name ? 0 : 8) +\n                (!s.gzhead.comment ? 0 : 16),\n            );\n            put_byte(s, s.gzhead.time & 255);\n            put_byte(s, (s.gzhead.time >> 8) & 255);\n            put_byte(s, (s.gzhead.time >> 16) & 255);\n            put_byte(s, (s.gzhead.time >> 24) & 255);\n            put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);\n            put_byte(s, s.gzhead.os & 255);\n            if (s.gzhead.extra && s.gzhead.extra.length) {\n              put_byte(s, s.gzhead.extra.length & 255);\n              put_byte(s, (s.gzhead.extra.length >> 8) & 255);\n            }\n            if (s.gzhead.hcrc) {\n              strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);\n            }\n            s.gzindex = 0;\n            s.status = EXTRA_STATE;\n          }\n        } else {\n          var header = (Z_DEFLATED + ((s.w_bits - 8) << 4)) << 8;\n          var level_flags = -1;\n          if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {\n            level_flags = 0;\n          } else if (s.level < 6) {\n            level_flags = 1;\n          } else if (s.level === 6) {\n            level_flags = 2;\n          } else {\n            level_flags = 3;\n          }\n          header |= level_flags << 6;\n          if (s.strstart !== 0) {\n            header |= PRESET_DICT;\n          }\n          header += 31 - (header % 31);\n          s.status = BUSY_STATE;\n          putShortMSB(s, header);\n          if (s.strstart !== 0) {\n            putShortMSB(s, strm.adler >>> 16);\n            putShortMSB(s, strm.adler & 65535);\n          }\n          strm.adler = 1;\n        }\n      }\n      if (s.status === EXTRA_STATE) {\n        if (s.gzhead.extra) {\n          beg = s.pending;\n          while (s.gzindex < (s.gzhead.extra.length & 65535)) {\n            if (s.pending === s.pending_buf_size) {\n              if (s.gzhead.hcrc && s.pending > beg) {\n                strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n              }\n              flush_pending(strm);\n              beg = s.pending;\n              if (s.pending === s.pending_buf_size) {\n                break;\n              }\n            }\n            put_byte(s, s.gzhead.extra[s.gzindex] & 255);\n            s.gzindex++;\n          }\n          if (s.gzhead.hcrc && s.pending > beg) {\n            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n          }\n          if (s.gzindex === s.gzhead.extra.length) {\n            s.gzindex = 0;\n            s.status = NAME_STATE;\n          }\n        } else {\n          s.status = NAME_STATE;\n        }\n      }\n      if (s.status === NAME_STATE) {\n        if (s.gzhead.name) {\n          beg = s.pending;\n          do {\n            if (s.pending === s.pending_buf_size) {\n              if (s.gzhead.hcrc && s.pending > beg) {\n                strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n              }\n              flush_pending(strm);\n              beg = s.pending;\n              if (s.pending === s.pending_buf_size) {\n                val = 1;\n                break;\n              }\n            }\n            if (s.gzindex < s.gzhead.name.length) {\n              val = s.gzhead.name.charCodeAt(s.gzindex++) & 255;\n            } else {\n              val = 0;\n            }\n            put_byte(s, val);\n          } while (val !== 0);\n          if (s.gzhead.hcrc && s.pending > beg) {\n            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n          }\n          if (val === 0) {\n            s.gzindex = 0;\n            s.status = COMMENT_STATE;\n          }\n        } else {\n          s.status = COMMENT_STATE;\n        }\n      }\n      if (s.status === COMMENT_STATE) {\n        if (s.gzhead.comment) {\n          beg = s.pending;\n          do {\n            if (s.pending === s.pending_buf_size) {\n              if (s.gzhead.hcrc && s.pending > beg) {\n                strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n              }\n              flush_pending(strm);\n              beg = s.pending;\n              if (s.pending === s.pending_buf_size) {\n                val = 1;\n                break;\n              }\n            }\n            if (s.gzindex < s.gzhead.comment.length) {\n              val = s.gzhead.comment.charCodeAt(s.gzindex++) & 255;\n            } else {\n              val = 0;\n            }\n            put_byte(s, val);\n          } while (val !== 0);\n          if (s.gzhead.hcrc && s.pending > beg) {\n            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n          }\n          if (val === 0) {\n            s.status = HCRC_STATE;\n          }\n        } else {\n          s.status = HCRC_STATE;\n        }\n      }\n      if (s.status === HCRC_STATE) {\n        if (s.gzhead.hcrc) {\n          if (s.pending + 2 > s.pending_buf_size) {\n            flush_pending(strm);\n          }\n          if (s.pending + 2 <= s.pending_buf_size) {\n            put_byte(s, strm.adler & 255);\n            put_byte(s, (strm.adler >> 8) & 255);\n            strm.adler = 0;\n            s.status = BUSY_STATE;\n          }\n        } else {\n          s.status = BUSY_STATE;\n        }\n      }\n      if (s.pending !== 0) {\n        flush_pending(strm);\n        if (strm.avail_out === 0) {\n          s.last_flush = -1;\n          return Z_OK;\n        }\n      } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH) {\n        return err(strm, Z_BUF_ERROR);\n      }\n      if (s.status === FINISH_STATE && strm.avail_in !== 0) {\n        return err(strm, Z_BUF_ERROR);\n      }\n      if (strm.avail_in !== 0 || s.lookahead !== 0 || (flush !== Z_NO_FLUSH && s.status !== FINISH_STATE)) {\n        var bstate =\n          s.strategy === Z_HUFFMAN_ONLY\n            ? deflate_huff(s, flush)\n            : s.strategy === Z_RLE\n            ? deflate_rle(s, flush)\n            : configuration_table[s.level].func(s, flush);\n        if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {\n          s.status = FINISH_STATE;\n        }\n        if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {\n          if (strm.avail_out === 0) {\n            s.last_flush = -1;\n          }\n          return Z_OK;\n        }\n        if (bstate === BS_BLOCK_DONE) {\n          if (flush === Z_PARTIAL_FLUSH) {\n            trees._tr_align(s);\n          } else if (flush !== Z_BLOCK) {\n            trees._tr_stored_block(s, 0, 0, false);\n            if (flush === Z_FULL_FLUSH) {\n              zero(s.head);\n              if (s.lookahead === 0) {\n                s.strstart = 0;\n                s.block_start = 0;\n                s.insert = 0;\n              }\n            }\n          }\n          flush_pending(strm);\n          if (strm.avail_out === 0) {\n            s.last_flush = -1;\n            return Z_OK;\n          }\n        }\n      }\n      if (flush !== Z_FINISH) {\n        return Z_OK;\n      }\n      if (s.wrap <= 0) {\n        return Z_STREAM_END;\n      }\n      if (s.wrap === 2) {\n        put_byte(s, strm.adler & 255);\n        put_byte(s, (strm.adler >> 8) & 255);\n        put_byte(s, (strm.adler >> 16) & 255);\n        put_byte(s, (strm.adler >> 24) & 255);\n        put_byte(s, strm.total_in & 255);\n        put_byte(s, (strm.total_in >> 8) & 255);\n        put_byte(s, (strm.total_in >> 16) & 255);\n        put_byte(s, (strm.total_in >> 24) & 255);\n      } else {\n        putShortMSB(s, strm.adler >>> 16);\n        putShortMSB(s, strm.adler & 65535);\n      }\n      flush_pending(strm);\n      if (s.wrap > 0) {\n        s.wrap = -s.wrap;\n      }\n      return s.pending !== 0 ? Z_OK : Z_STREAM_END;\n    }\n    function deflateEnd(strm) {\n      var status;\n      if (!strm || !strm.state) {\n        return Z_STREAM_ERROR;\n      }\n      status = strm.state.status;\n      if (\n        status !== INIT_STATE &&\n        status !== EXTRA_STATE &&\n        status !== NAME_STATE &&\n        status !== COMMENT_STATE &&\n        status !== HCRC_STATE &&\n        status !== BUSY_STATE &&\n        status !== FINISH_STATE\n      ) {\n        return err(strm, Z_STREAM_ERROR);\n      }\n      strm.state = null;\n      return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;\n    }\n    function deflateSetDictionary(strm, dictionary) {\n      var dictLength = dictionary.length;\n      var s;\n      var str, n;\n      var wrap;\n      var avail;\n      var next;\n      var input;\n      var tmpDict;\n      if (!strm || !strm.state) {\n        return Z_STREAM_ERROR;\n      }\n      s = strm.state;\n      wrap = s.wrap;\n      if (wrap === 2 || (wrap === 1 && s.status !== INIT_STATE) || s.lookahead) {\n        return Z_STREAM_ERROR;\n      }\n      if (wrap === 1) {\n        strm.adler = adler32(strm.adler, dictionary, dictLength, 0);\n      }\n      s.wrap = 0;\n      if (dictLength >= s.w_size) {\n        if (wrap === 0) {\n          zero(s.head);\n          s.strstart = 0;\n          s.block_start = 0;\n          s.insert = 0;\n        }\n        tmpDict = new utils.Buf8(s.w_size);\n        utils.arraySet(tmpDict, dictionary, dictLength - s.w_size, s.w_size, 0);\n        dictionary = tmpDict;\n        dictLength = s.w_size;\n      }\n      avail = strm.avail_in;\n      next = strm.next_in;\n      input = strm.input;\n      strm.avail_in = dictLength;\n      strm.next_in = 0;\n      strm.input = dictionary;\n      fill_window(s);\n      while (s.lookahead >= MIN_MATCH) {\n        str = s.strstart;\n        n = s.lookahead - (MIN_MATCH - 1);\n        do {\n          s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;\n          s.prev[str & s.w_mask] = s.head[s.ins_h];\n          s.head[s.ins_h] = str;\n          str++;\n        } while (--n);\n        s.strstart = str;\n        s.lookahead = MIN_MATCH - 1;\n        fill_window(s);\n      }\n      s.strstart += s.lookahead;\n      s.block_start = s.strstart;\n      s.insert = s.lookahead;\n      s.lookahead = 0;\n      s.match_length = s.prev_length = MIN_MATCH - 1;\n      s.match_available = 0;\n      strm.next_in = next;\n      strm.input = input;\n      strm.avail_in = avail;\n      s.wrap = wrap;\n      return Z_OK;\n    }\n    exports.deflateInit = deflateInit;\n    exports.deflateInit2 = deflateInit2;\n    exports.deflateReset = deflateReset;\n    exports.deflateResetKeep = deflateResetKeep;\n    exports.deflateSetHeader = deflateSetHeader;\n    exports.deflate = deflate;\n    exports.deflateEnd = deflateEnd;\n    exports.deflateSetDictionary = deflateSetDictionary;\n    exports.deflateInfo = \"pako deflate (from Nodeca project)\";\n  },\n});\n\n// node_modules/pako/lib/zlib/inffast.js\nvar require_inffast = __commonJS({\n  \"node_modules/pako/lib/zlib/inffast.js\"(exports, module2) {\n    \"use strict\";\n    var BAD = 30;\n    var TYPE = 12;\n    module2.exports = function inflate_fast(strm, start) {\n      var state;\n      var _in;\n      var last;\n      var _out;\n      var beg;\n      var end;\n      var dmax;\n      var wsize;\n      var whave;\n      var wnext;\n      var s_window;\n      var hold;\n      var bits;\n      var lcode;\n      var dcode;\n      var lmask;\n      var dmask;\n      var here;\n      var op;\n      var len;\n      var dist;\n      var from;\n      var from_source;\n      var input, output;\n      state = strm.state;\n      _in = strm.next_in;\n      input = strm.input;\n      last = _in + (strm.avail_in - 5);\n      _out = strm.next_out;\n      output = strm.output;\n      beg = _out - (start - strm.avail_out);\n      end = _out + (strm.avail_out - 257);\n      dmax = state.dmax;\n      wsize = state.wsize;\n      whave = state.whave;\n      wnext = state.wnext;\n      s_window = state.window;\n      hold = state.hold;\n      bits = state.bits;\n      lcode = state.lencode;\n      dcode = state.distcode;\n      lmask = (1 << state.lenbits) - 1;\n      dmask = (1 << state.distbits) - 1;\n      top: do {\n        if (bits < 15) {\n          hold += input[_in++] << bits;\n          bits += 8;\n          hold += input[_in++] << bits;\n          bits += 8;\n        }\n        here = lcode[hold & lmask];\n        dolen: for (;;) {\n          op = here >>> 24;\n          hold >>>= op;\n          bits -= op;\n          op = (here >>> 16) & 255;\n          if (op === 0) {\n            output[_out++] = here & 65535;\n          } else if (op & 16) {\n            len = here & 65535;\n            op &= 15;\n            if (op) {\n              if (bits < op) {\n                hold += input[_in++] << bits;\n                bits += 8;\n              }\n              len += hold & ((1 << op) - 1);\n              hold >>>= op;\n              bits -= op;\n            }\n            if (bits < 15) {\n              hold += input[_in++] << bits;\n              bits += 8;\n              hold += input[_in++] << bits;\n              bits += 8;\n            }\n            here = dcode[hold & dmask];\n            dodist: for (;;) {\n              op = here >>> 24;\n              hold >>>= op;\n              bits -= op;\n              op = (here >>> 16) & 255;\n              if (op & 16) {\n                dist = here & 65535;\n                op &= 15;\n                if (bits < op) {\n                  hold += input[_in++] << bits;\n                  bits += 8;\n                  if (bits < op) {\n                    hold += input[_in++] << bits;\n                    bits += 8;\n                  }\n                }\n                dist += hold & ((1 << op) - 1);\n                if (dist > dmax) {\n                  strm.msg = \"invalid distance too far back\";\n                  state.mode = BAD;\n                  break top;\n                }\n                hold >>>= op;\n                bits -= op;\n                op = _out - beg;\n                if (dist > op) {\n                  op = dist - op;\n                  if (op > whave) {\n                    if (state.sane) {\n                      strm.msg = \"invalid distance too far back\";\n                      state.mode = BAD;\n                      break top;\n                    }\n                  }\n                  from = 0;\n                  from_source = s_window;\n                  if (wnext === 0) {\n                    from += wsize - op;\n                    if (op < len) {\n                      len -= op;\n                      do {\n                        output[_out++] = s_window[from++];\n                      } while (--op);\n                      from = _out - dist;\n                      from_source = output;\n                    }\n                  } else if (wnext < op) {\n                    from += wsize + wnext - op;\n                    op -= wnext;\n                    if (op < len) {\n                      len -= op;\n                      do {\n                        output[_out++] = s_window[from++];\n                      } while (--op);\n                      from = 0;\n                      if (wnext < len) {\n                        op = wnext;\n                        len -= op;\n                        do {\n                          output[_out++] = s_window[from++];\n                        } while (--op);\n                        from = _out - dist;\n                        from_source = output;\n                      }\n                    }\n                  } else {\n                    from += wnext - op;\n                    if (op < len) {\n                      len -= op;\n                      do {\n                        output[_out++] = s_window[from++];\n                      } while (--op);\n                      from = _out - dist;\n                      from_source = output;\n                    }\n                  }\n                  while (len > 2) {\n                    output[_out++] = from_source[from++];\n                    output[_out++] = from_source[from++];\n                    output[_out++] = from_source[from++];\n                    len -= 3;\n                  }\n                  if (len) {\n                    output[_out++] = from_source[from++];\n                    if (len > 1) {\n                      output[_out++] = from_source[from++];\n                    }\n                  }\n                } else {\n                  from = _out - dist;\n                  do {\n                    output[_out++] = output[from++];\n                    output[_out++] = output[from++];\n                    output[_out++] = output[from++];\n                    len -= 3;\n                  } while (len > 2);\n                  if (len) {\n                    output[_out++] = output[from++];\n                    if (len > 1) {\n                      output[_out++] = output[from++];\n                    }\n                  }\n                }\n              } else if ((op & 64) === 0) {\n                here = dcode[(here & 65535) + (hold & ((1 << op) - 1))];\n                continue dodist;\n              } else {\n                strm.msg = \"invalid distance code\";\n                state.mode = BAD;\n                break top;\n              }\n              break;\n            }\n          } else if ((op & 64) === 0) {\n            here = lcode[(here & 65535) + (hold & ((1 << op) - 1))];\n            continue dolen;\n          } else if (op & 32) {\n            state.mode = TYPE;\n            break top;\n          } else {\n            strm.msg = \"invalid literal/length code\";\n            state.mode = BAD;\n            break top;\n          }\n          break;\n        }\n      } while (_in < last && _out < end);\n      len = bits >> 3;\n      _in -= len;\n      bits -= len << 3;\n      hold &= (1 << bits) - 1;\n      strm.next_in = _in;\n      strm.next_out = _out;\n      strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last);\n      strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);\n      state.hold = hold;\n      state.bits = bits;\n      return;\n    };\n  },\n});\n\n// node_modules/pako/lib/zlib/inftrees.js\nvar require_inftrees = __commonJS({\n  \"node_modules/pako/lib/zlib/inftrees.js\"(exports, module2) {\n    \"use strict\";\n    var utils = require_common();\n    var MAXBITS = 15;\n    var ENOUGH_LENS = 852;\n    var ENOUGH_DISTS = 592;\n    var CODES = 0;\n    var LENS = 1;\n    var DISTS = 2;\n    var lbase = [\n      3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258,\n      0, 0,\n    ];\n    var lext = [\n      16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21,\n      16, 72, 78,\n    ];\n    var dbase = [\n      1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,\n      8193, 12289, 16385, 24577, 0, 0,\n    ];\n    var dext = [\n      16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28,\n      29, 29, 64, 64,\n    ];\n    module2.exports = function inflate_table(type, lens, lens_index, codes, table, table_index, work, opts) {\n      var bits = opts.bits;\n      var len = 0;\n      var sym = 0;\n      var min = 0,\n        max = 0;\n      var root = 0;\n      var curr = 0;\n      var drop = 0;\n      var left = 0;\n      var used = 0;\n      var huff = 0;\n      var incr;\n      var fill;\n      var low;\n      var mask;\n      var next;\n      var base = null;\n      var base_index = 0;\n      var end;\n      var count = new utils.Buf16(MAXBITS + 1);\n      var offs = new utils.Buf16(MAXBITS + 1);\n      var extra = null;\n      var extra_index = 0;\n      var here_bits, here_op, here_val;\n      for (len = 0; len <= MAXBITS; len++) {\n        count[len] = 0;\n      }\n      for (sym = 0; sym < codes; sym++) {\n        count[lens[lens_index + sym]]++;\n      }\n      root = bits;\n      for (max = MAXBITS; max >= 1; max--) {\n        if (count[max] !== 0) {\n          break;\n        }\n      }\n      if (root > max) {\n        root = max;\n      }\n      if (max === 0) {\n        table[table_index++] = (1 << 24) | (64 << 16) | 0;\n        table[table_index++] = (1 << 24) | (64 << 16) | 0;\n        opts.bits = 1;\n        return 0;\n      }\n      for (min = 1; min < max; min++) {\n        if (count[min] !== 0) {\n          break;\n        }\n      }\n      if (root < min) {\n        root = min;\n      }\n      left = 1;\n      for (len = 1; len <= MAXBITS; len++) {\n        left <<= 1;\n        left -= count[len];\n        if (left < 0) {\n          return -1;\n        }\n      }\n      if (left > 0 && (type === CODES || max !== 1)) {\n        return -1;\n      }\n      offs[1] = 0;\n      for (len = 1; len < MAXBITS; len++) {\n        offs[len + 1] = offs[len] + count[len];\n      }\n      for (sym = 0; sym < codes; sym++) {\n        if (lens[lens_index + sym] !== 0) {\n          work[offs[lens[lens_index + sym]]++] = sym;\n        }\n      }\n      if (type === CODES) {\n        base = extra = work;\n        end = 19;\n      } else if (type === LENS) {\n        base = lbase;\n        base_index -= 257;\n        extra = lext;\n        extra_index -= 257;\n        end = 256;\n      } else {\n        base = dbase;\n        extra = dext;\n        end = -1;\n      }\n      huff = 0;\n      sym = 0;\n      len = min;\n      next = table_index;\n      curr = root;\n      drop = 0;\n      low = -1;\n      used = 1 << root;\n      mask = used - 1;\n      if ((type === LENS && used > ENOUGH_LENS) || (type === DISTS && used > ENOUGH_DISTS)) {\n        return 1;\n      }\n      for (;;) {\n        here_bits = len - drop;\n        if (work[sym] < end) {\n          here_op = 0;\n          here_val = work[sym];\n        } else if (work[sym] > end) {\n          here_op = extra[extra_index + work[sym]];\n          here_val = base[base_index + work[sym]];\n        } else {\n          here_op = 32 + 64;\n          here_val = 0;\n        }\n        incr = 1 << (len - drop);\n        fill = 1 << curr;\n        min = fill;\n        do {\n          fill -= incr;\n          table[next + (huff >> drop) + fill] = (here_bits << 24) | (here_op << 16) | here_val | 0;\n        } while (fill !== 0);\n        incr = 1 << (len - 1);\n        while (huff & incr) {\n          incr >>= 1;\n        }\n        if (incr !== 0) {\n          huff &= incr - 1;\n          huff += incr;\n        } else {\n          huff = 0;\n        }\n        sym++;\n        if (--count[len] === 0) {\n          if (len === max) {\n            break;\n          }\n          len = lens[lens_index + work[sym]];\n        }\n        if (len > root && (huff & mask) !== low) {\n          if (drop === 0) {\n            drop = root;\n          }\n          next += min;\n          curr = len - drop;\n          left = 1 << curr;\n          while (curr + drop < max) {\n            left -= count[curr + drop];\n            if (left <= 0) {\n              break;\n            }\n            curr++;\n            left <<= 1;\n          }\n          used += 1 << curr;\n          if ((type === LENS && used > ENOUGH_LENS) || (type === DISTS && used > ENOUGH_DISTS)) {\n            return 1;\n          }\n          low = huff & mask;\n          table[low] = (root << 24) | (curr << 16) | (next - table_index) | 0;\n        }\n      }\n      if (huff !== 0) {\n        table[next + huff] = ((len - drop) << 24) | (64 << 16) | 0;\n      }\n      opts.bits = root;\n      return 0;\n    };\n  },\n});\n\n// node_modules/pako/lib/zlib/inflate.js\nvar require_inflate = __commonJS({\n  \"node_modules/pako/lib/zlib/inflate.js\"(exports) {\n    \"use strict\";\n    var utils = require_common();\n    var adler32 = require_adler32();\n    var crc32 = require_crc32();\n    var inflate_fast = require_inffast();\n    var inflate_table = require_inftrees();\n    var CODES = 0;\n    var LENS = 1;\n    var DISTS = 2;\n    var Z_FINISH = 4;\n    var Z_BLOCK = 5;\n    var Z_TREES = 6;\n    var Z_OK = 0;\n    var Z_STREAM_END = 1;\n    var Z_NEED_DICT = 2;\n    var Z_STREAM_ERROR = -2;\n    var Z_DATA_ERROR = -3;\n    var Z_MEM_ERROR = -4;\n    var Z_BUF_ERROR = -5;\n    var Z_DEFLATED = 8;\n    var HEAD = 1;\n    var FLAGS = 2;\n    var TIME = 3;\n    var OS = 4;\n    var EXLEN = 5;\n    var EXTRA = 6;\n    var NAME = 7;\n    var COMMENT = 8;\n    var HCRC = 9;\n    var DICTID = 10;\n    var DICT = 11;\n    var TYPE = 12;\n    var TYPEDO = 13;\n    var STORED = 14;\n    var COPY_ = 15;\n    var COPY = 16;\n    var TABLE = 17;\n    var LENLENS = 18;\n    var CODELENS = 19;\n    var LEN_ = 20;\n    var LEN = 21;\n    var LENEXT = 22;\n    var DIST = 23;\n    var DISTEXT = 24;\n    var MATCH = 25;\n    var LIT = 26;\n    var CHECK = 27;\n    var LENGTH = 28;\n    var DONE = 29;\n    var BAD = 30;\n    var MEM = 31;\n    var SYNC = 32;\n    var ENOUGH_LENS = 852;\n    var ENOUGH_DISTS = 592;\n    var MAX_WBITS = 15;\n    var DEF_WBITS = MAX_WBITS;\n    function zswap32(q) {\n      return ((q >>> 24) & 255) + ((q >>> 8) & 65280) + ((q & 65280) << 8) + ((q & 255) << 24);\n    }\n    function InflateState() {\n      this.mode = 0;\n      this.last = false;\n      this.wrap = 0;\n      this.havedict = false;\n      this.flags = 0;\n      this.dmax = 0;\n      this.check = 0;\n      this.total = 0;\n      this.head = null;\n      this.wbits = 0;\n      this.wsize = 0;\n      this.whave = 0;\n      this.wnext = 0;\n      this.window = null;\n      this.hold = 0;\n      this.bits = 0;\n      this.length = 0;\n      this.offset = 0;\n      this.extra = 0;\n      this.lencode = null;\n      this.distcode = null;\n      this.lenbits = 0;\n      this.distbits = 0;\n      this.ncode = 0;\n      this.nlen = 0;\n      this.ndist = 0;\n      this.have = 0;\n      this.next = null;\n      this.lens = new utils.Buf16(320);\n      this.work = new utils.Buf16(288);\n      this.lendyn = null;\n      this.distdyn = null;\n      this.sane = 0;\n      this.back = 0;\n      this.was = 0;\n    }\n    function inflateResetKeep(strm) {\n      var state;\n      if (!strm || !strm.state) {\n        return Z_STREAM_ERROR;\n      }\n      state = strm.state;\n      strm.total_in = strm.total_out = state.total = 0;\n      strm.msg = \"\";\n      if (state.wrap) {\n        strm.adler = state.wrap & 1;\n      }\n      state.mode = HEAD;\n      state.last = 0;\n      state.havedict = 0;\n      state.dmax = 32768;\n      state.head = null;\n      state.hold = 0;\n      state.bits = 0;\n      state.lencode = state.lendyn = new utils.Buf32(ENOUGH_LENS);\n      state.distcode = state.distdyn = new utils.Buf32(ENOUGH_DISTS);\n      state.sane = 1;\n      state.back = -1;\n      return Z_OK;\n    }\n    function inflateReset(strm) {\n      var state;\n      if (!strm || !strm.state) {\n        return Z_STREAM_ERROR;\n      }\n      state = strm.state;\n      state.wsize = 0;\n      state.whave = 0;\n      state.wnext = 0;\n      return inflateResetKeep(strm);\n    }\n    function inflateReset2(strm, windowBits) {\n      var wrap;\n      var state;\n      if (!strm || !strm.state) {\n        return Z_STREAM_ERROR;\n      }\n      state = strm.state;\n      if (windowBits < 0) {\n        wrap = 0;\n        windowBits = -windowBits;\n      } else {\n        wrap = (windowBits >> 4) + 1;\n        if (windowBits < 48) {\n          windowBits &= 15;\n        }\n      }\n      if (windowBits && (windowBits < 8 || windowBits > 15)) {\n        return Z_STREAM_ERROR;\n      }\n      if (state.window !== null && state.wbits !== windowBits) {\n        state.window = null;\n      }\n      state.wrap = wrap;\n      state.wbits = windowBits;\n      return inflateReset(strm);\n    }\n    function inflateInit2(strm, windowBits) {\n      var ret;\n      var state;\n      if (!strm) {\n        return Z_STREAM_ERROR;\n      }\n      state = new InflateState();\n      strm.state = state;\n      state.window = null;\n      ret = inflateReset2(strm, windowBits);\n      if (ret !== Z_OK) {\n        strm.state = null;\n      }\n      return ret;\n    }\n    function inflateInit(strm) {\n      return inflateInit2(strm, DEF_WBITS);\n    }\n    var virgin = true;\n    var lenfix;\n    var distfix;\n    function fixedtables(state) {\n      if (virgin) {\n        var sym;\n        lenfix = new utils.Buf32(512);\n        distfix = new utils.Buf32(32);\n        sym = 0;\n        while (sym < 144) {\n          state.lens[sym++] = 8;\n        }\n        while (sym < 256) {\n          state.lens[sym++] = 9;\n        }\n        while (sym < 280) {\n          state.lens[sym++] = 7;\n        }\n        while (sym < 288) {\n          state.lens[sym++] = 8;\n        }\n        inflate_table(LENS, state.lens, 0, 288, lenfix, 0, state.work, {\n          bits: 9,\n        });\n        sym = 0;\n        while (sym < 32) {\n          state.lens[sym++] = 5;\n        }\n        inflate_table(DISTS, state.lens, 0, 32, distfix, 0, state.work, {\n          bits: 5,\n        });\n        virgin = false;\n      }\n      state.lencode = lenfix;\n      state.lenbits = 9;\n      state.distcode = distfix;\n      state.distbits = 5;\n    }\n    function updatewindow(strm, src, end, copy) {\n      var dist;\n      var state = strm.state;\n      if (state.window === null) {\n        state.wsize = 1 << state.wbits;\n        state.wnext = 0;\n        state.whave = 0;\n        state.window = new utils.Buf8(state.wsize);\n      }\n      if (copy >= state.wsize) {\n        utils.arraySet(state.window, src, end - state.wsize, state.wsize, 0);\n        state.wnext = 0;\n        state.whave = state.wsize;\n      } else {\n        dist = state.wsize - state.wnext;\n        if (dist > copy) {\n          dist = copy;\n        }\n        utils.arraySet(state.window, src, end - copy, dist, state.wnext);\n        copy -= dist;\n        if (copy) {\n          utils.arraySet(state.window, src, end - copy, copy, 0);\n          state.wnext = copy;\n          state.whave = state.wsize;\n        } else {\n          state.wnext += dist;\n          if (state.wnext === state.wsize) {\n            state.wnext = 0;\n          }\n          if (state.whave < state.wsize) {\n            state.whave += dist;\n          }\n        }\n      }\n      return 0;\n    }\n    function inflate(strm, flush) {\n      var state;\n      var input, output;\n      var next;\n      var put;\n      var have, left;\n      var hold;\n      var bits;\n      var _in, _out;\n      var copy;\n      var from;\n      var from_source;\n      var here = 0;\n      var here_bits, here_op, here_val;\n      var last_bits, last_op, last_val;\n      var len;\n      var ret;\n      var hbuf = new utils.Buf8(4);\n      var opts;\n      var n;\n      var order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];\n      if (!strm || !strm.state || !strm.output || (!strm.input && strm.avail_in !== 0)) {\n        return Z_STREAM_ERROR;\n      }\n      state = strm.state;\n      if (state.mode === TYPE) {\n        state.mode = TYPEDO;\n      }\n      put = strm.next_out;\n      output = strm.output;\n      left = strm.avail_out;\n      next = strm.next_in;\n      input = strm.input;\n      have = strm.avail_in;\n      hold = state.hold;\n      bits = state.bits;\n      _in = have;\n      _out = left;\n      ret = Z_OK;\n      inf_leave: for (;;) {\n        switch (state.mode) {\n          case HEAD:\n            if (state.wrap === 0) {\n              state.mode = TYPEDO;\n              break;\n            }\n            while (bits < 16) {\n              if (have === 0) {\n                break inf_leave;\n              }\n              have--;\n              hold += input[next++] << bits;\n              bits += 8;\n            }\n            if (state.wrap & 2 && hold === 35615) {\n              state.check = 0;\n              hbuf[0] = hold & 255;\n              hbuf[1] = (hold >>> 8) & 255;\n              state.check = crc32(state.check, hbuf, 2, 0);\n              hold = 0;\n              bits = 0;\n              state.mode = FLAGS;\n              break;\n            }\n            state.flags = 0;\n            if (state.head) {\n              state.head.done = false;\n            }\n            if (!(state.wrap & 1) || (((hold & 255) << 8) + (hold >> 8)) % 31) {\n              strm.msg = \"incorrect header check\";\n              state.mode = BAD;\n              break;\n            }\n            if ((hold & 15) !== Z_DEFLATED) {\n              strm.msg = \"unknown compression method\";\n              state.mode = BAD;\n              break;\n            }\n            hold >>>= 4;\n            bits -= 4;\n            len = (hold & 15) + 8;\n            if (state.wbits === 0) {\n              state.wbits = len;\n            } else if (len > state.wbits) {\n              strm.msg = \"invalid window size\";\n              state.mode = BAD;\n              break;\n            }\n            state.dmax = 1 << len;\n            strm.adler = state.check = 1;\n            state.mode = hold & 512 ? DICTID : TYPE;\n            hold = 0;\n            bits = 0;\n            break;\n          case FLAGS:\n            while (bits < 16) {\n              if (have === 0) {\n                break inf_leave;\n              }\n              have--;\n              hold += input[next++] << bits;\n              bits += 8;\n            }\n            state.flags = hold;\n            if ((state.flags & 255) !== Z_DEFLATED) {\n              strm.msg = \"unknown compression method\";\n              state.mode = BAD;\n              break;\n            }\n            if (state.flags & 57344) {\n              strm.msg = \"unknown header flags set\";\n              state.mode = BAD;\n              break;\n            }\n            if (state.head) {\n              state.head.text = (hold >> 8) & 1;\n            }\n            if (state.flags & 512) {\n              hbuf[0] = hold & 255;\n              hbuf[1] = (hold >>> 8) & 255;\n              state.check = crc32(state.check, hbuf, 2, 0);\n            }\n            hold = 0;\n            bits = 0;\n            state.mode = TIME;\n          case TIME:\n            while (bits < 32) {\n              if (have === 0) {\n                break inf_leave;\n              }\n              have--;\n              hold += input[next++] << bits;\n              bits += 8;\n            }\n            if (state.head) {\n              state.head.time = hold;\n            }\n            if (state.flags & 512) {\n              hbuf[0] = hold & 255;\n              hbuf[1] = (hold >>> 8) & 255;\n              hbuf[2] = (hold >>> 16) & 255;\n              hbuf[3] = (hold >>> 24) & 255;\n              state.check = crc32(state.check, hbuf, 4, 0);\n            }\n            hold = 0;\n            bits = 0;\n            state.mode = OS;\n          case OS:\n            while (bits < 16) {\n              if (have === 0) {\n                break inf_leave;\n              }\n              have--;\n              hold += input[next++] << bits;\n              bits += 8;\n            }\n            if (state.head) {\n              state.head.xflags = hold & 255;\n              state.head.os = hold >> 8;\n            }\n            if (state.flags & 512) {\n              hbuf[0] = hold & 255;\n              hbuf[1] = (hold >>> 8) & 255;\n              state.check = crc32(state.check, hbuf, 2, 0);\n            }\n            hold = 0;\n            bits = 0;\n            state.mode = EXLEN;\n          case EXLEN:\n            if (state.flags & 1024) {\n              while (bits < 16) {\n                if (have === 0) {\n                  break inf_leave;\n                }\n                have--;\n                hold += input[next++] << bits;\n                bits += 8;\n              }\n              state.length = hold;\n              if (state.head) {\n                state.head.extra_len = hold;\n              }\n              if (state.flags & 512) {\n                hbuf[0] = hold & 255;\n                hbuf[1] = (hold >>> 8) & 255;\n                state.check = crc32(state.check, hbuf, 2, 0);\n              }\n              hold = 0;\n              bits = 0;\n            } else if (state.head) {\n              state.head.extra = null;\n            }\n            state.mode = EXTRA;\n          case EXTRA:\n            if (state.flags & 1024) {\n              copy = state.length;\n              if (copy > have) {\n                copy = have;\n              }\n              if (copy) {\n                if (state.head) {\n                  len = state.head.extra_len - state.length;\n                  if (!state.head.extra) {\n                    state.head.extra = new Array(state.head.extra_len);\n                  }\n                  utils.arraySet(state.head.extra, input, next, copy, len);\n                }\n                if (state.flags & 512) {\n                  state.check = crc32(state.check, input, copy, next);\n                }\n                have -= copy;\n                next += copy;\n                state.length -= copy;\n              }\n              if (state.length) {\n                break inf_leave;\n              }\n            }\n            state.length = 0;\n            state.mode = NAME;\n          case NAME:\n            if (state.flags & 2048) {\n              if (have === 0) {\n                break inf_leave;\n              }\n              copy = 0;\n              do {\n                len = input[next + copy++];\n                if (state.head && len && state.length < 65536) {\n                  state.head.name += String.fromCharCode(len);\n                }\n              } while (len && copy < have);\n              if (state.flags & 512) {\n                state.check = crc32(state.check, input, copy, next);\n              }\n              have -= copy;\n              next += copy;\n              if (len) {\n                break inf_leave;\n              }\n            } else if (state.head) {\n              state.head.name = null;\n            }\n            state.length = 0;\n            state.mode = COMMENT;\n          case COMMENT:\n            if (state.flags & 4096) {\n              if (have === 0) {\n                break inf_leave;\n              }\n              copy = 0;\n              do {\n                len = input[next + copy++];\n                if (state.head && len && state.length < 65536) {\n                  state.head.comment += String.fromCharCode(len);\n                }\n              } while (len && copy < have);\n              if (state.flags & 512) {\n                state.check = crc32(state.check, input, copy, next);\n              }\n              have -= copy;\n              next += copy;\n              if (len) {\n                break inf_leave;\n              }\n            } else if (state.head) {\n              state.head.comment = null;\n            }\n            state.mode = HCRC;\n          case HCRC:\n            if (state.flags & 512) {\n              while (bits < 16) {\n                if (have === 0) {\n                  break inf_leave;\n                }\n                have--;\n                hold += input[next++] << bits;\n                bits += 8;\n              }\n              if (hold !== (state.check & 65535)) {\n                strm.msg = \"header crc mismatch\";\n                state.mode = BAD;\n                break;\n              }\n              hold = 0;\n              bits = 0;\n            }\n            if (state.head) {\n              state.head.hcrc = (state.flags >> 9) & 1;\n              state.head.done = true;\n            }\n            strm.adler = state.check = 0;\n            state.mode = TYPE;\n            break;\n          case DICTID:\n            while (bits < 32) {\n              if (have === 0) {\n                break inf_leave;\n              }\n              have--;\n              hold += input[next++] << bits;\n              bits += 8;\n            }\n            strm.adler = state.check = zswap32(hold);\n            hold = 0;\n            bits = 0;\n            state.mode = DICT;\n          case DICT:\n            if (state.havedict === 0) {\n              strm.next_out = put;\n              strm.avail_out = left;\n              strm.next_in = next;\n              strm.avail_in = have;\n              state.hold = hold;\n              state.bits = bits;\n              return Z_NEED_DICT;\n            }\n            strm.adler = state.check = 1;\n            state.mode = TYPE;\n          case TYPE:\n            if (flush === Z_BLOCK || flush === Z_TREES) {\n              break inf_leave;\n            }\n          case TYPEDO:\n            if (state.last) {\n              hold >>>= bits & 7;\n              bits -= bits & 7;\n              state.mode = CHECK;\n              break;\n            }\n            while (bits < 3) {\n              if (have === 0) {\n                break inf_leave;\n              }\n              have--;\n              hold += input[next++] << bits;\n              bits += 8;\n            }\n            state.last = hold & 1;\n            hold >>>= 1;\n            bits -= 1;\n            switch (hold & 3) {\n              case 0:\n                state.mode = STORED;\n                break;\n              case 1:\n                fixedtables(state);\n                state.mode = LEN_;\n                if (flush === Z_TREES) {\n                  hold >>>= 2;\n                  bits -= 2;\n                  break inf_leave;\n                }\n                break;\n              case 2:\n                state.mode = TABLE;\n                break;\n              case 3:\n                strm.msg = \"invalid block type\";\n                state.mode = BAD;\n            }\n            hold >>>= 2;\n            bits -= 2;\n            break;\n          case STORED:\n            hold >>>= bits & 7;\n            bits -= bits & 7;\n            while (bits < 32) {\n              if (have === 0) {\n                break inf_leave;\n              }\n              have--;\n              hold += input[next++] << bits;\n              bits += 8;\n            }\n            if ((hold & 65535) !== ((hold >>> 16) ^ 65535)) {\n              strm.msg = \"invalid stored block lengths\";\n              state.mode = BAD;\n              break;\n            }\n            state.length = hold & 65535;\n            hold = 0;\n            bits = 0;\n            state.mode = COPY_;\n            if (flush === Z_TREES) {\n              break inf_leave;\n            }\n          case COPY_:\n            state.mode = COPY;\n          case COPY:\n            copy = state.length;\n            if (copy) {\n              if (copy > have) {\n                copy = have;\n              }\n              if (copy > left) {\n                copy = left;\n              }\n              if (copy === 0) {\n                break inf_leave;\n              }\n              utils.arraySet(output, input, next, copy, put);\n              have -= copy;\n              next += copy;\n              left -= copy;\n              put += copy;\n              state.length -= copy;\n              break;\n            }\n            state.mode = TYPE;\n            break;\n          case TABLE:\n            while (bits < 14) {\n              if (have === 0) {\n                break inf_leave;\n              }\n              have--;\n              hold += input[next++] << bits;\n              bits += 8;\n            }\n            state.nlen = (hold & 31) + 257;\n            hold >>>= 5;\n            bits -= 5;\n            state.ndist = (hold & 31) + 1;\n            hold >>>= 5;\n            bits -= 5;\n            state.ncode = (hold & 15) + 4;\n            hold >>>= 4;\n            bits -= 4;\n            if (state.nlen > 286 || state.ndist > 30) {\n              strm.msg = \"too many length or distance symbols\";\n              state.mode = BAD;\n              break;\n            }\n            state.have = 0;\n            state.mode = LENLENS;\n          case LENLENS:\n            while (state.have < state.ncode) {\n              while (bits < 3) {\n                if (have === 0) {\n                  break inf_leave;\n                }\n                have--;\n                hold += input[next++] << bits;\n                bits += 8;\n              }\n              state.lens[order[state.have++]] = hold & 7;\n              hold >>>= 3;\n              bits -= 3;\n            }\n            while (state.have < 19) {\n              state.lens[order[state.have++]] = 0;\n            }\n            state.lencode = state.lendyn;\n            state.lenbits = 7;\n            opts = { bits: state.lenbits };\n            ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);\n            state.lenbits = opts.bits;\n            if (ret) {\n              strm.msg = \"invalid code lengths set\";\n              state.mode = BAD;\n              break;\n            }\n            state.have = 0;\n            state.mode = CODELENS;\n          case CODELENS:\n            while (state.have < state.nlen + state.ndist) {\n              for (;;) {\n                here = state.lencode[hold & ((1 << state.lenbits) - 1)];\n                here_bits = here >>> 24;\n                here_op = (here >>> 16) & 255;\n                here_val = here & 65535;\n                if (here_bits <= bits) {\n                  break;\n                }\n                if (have === 0) {\n                  break inf_leave;\n                }\n                have--;\n                hold += input[next++] << bits;\n                bits += 8;\n              }\n              if (here_val < 16) {\n                hold >>>= here_bits;\n                bits -= here_bits;\n                state.lens[state.have++] = here_val;\n              } else {\n                if (here_val === 16) {\n                  n = here_bits + 2;\n                  while (bits < n) {\n                    if (have === 0) {\n                      break inf_leave;\n                    }\n                    have--;\n                    hold += input[next++] << bits;\n                    bits += 8;\n                  }\n                  hold >>>= here_bits;\n                  bits -= here_bits;\n                  if (state.have === 0) {\n                    strm.msg = \"invalid bit length repeat\";\n                    state.mode = BAD;\n                    break;\n                  }\n                  len = state.lens[state.have - 1];\n                  copy = 3 + (hold & 3);\n                  hold >>>= 2;\n                  bits -= 2;\n                } else if (here_val === 17) {\n                  n = here_bits + 3;\n                  while (bits < n) {\n                    if (have === 0) {\n                      break inf_leave;\n                    }\n                    have--;\n                    hold += input[next++] << bits;\n                    bits += 8;\n                  }\n                  hold >>>= here_bits;\n                  bits -= here_bits;\n                  len = 0;\n                  copy = 3 + (hold & 7);\n                  hold >>>= 3;\n                  bits -= 3;\n                } else {\n                  n = here_bits + 7;\n                  while (bits < n) {\n                    if (have === 0) {\n                      break inf_leave;\n                    }\n                    have--;\n                    hold += input[next++] << bits;\n                    bits += 8;\n                  }\n                  hold >>>= here_bits;\n                  bits -= here_bits;\n                  len = 0;\n                  copy = 11 + (hold & 127);\n                  hold >>>= 7;\n                  bits -= 7;\n                }\n                if (state.have + copy > state.nlen + state.ndist) {\n                  strm.msg = \"invalid bit length repeat\";\n                  state.mode = BAD;\n                  break;\n                }\n                while (copy--) {\n                  state.lens[state.have++] = len;\n                }\n              }\n            }\n            if (state.mode === BAD) {\n              break;\n            }\n            if (state.lens[256] === 0) {\n              strm.msg = \"invalid code -- missing end-of-block\";\n              state.mode = BAD;\n              break;\n            }\n            state.lenbits = 9;\n            opts = { bits: state.lenbits };\n            ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);\n            state.lenbits = opts.bits;\n            if (ret) {\n              strm.msg = \"invalid literal/lengths set\";\n              state.mode = BAD;\n              break;\n            }\n            state.distbits = 6;\n            state.distcode = state.distdyn;\n            opts = { bits: state.distbits };\n            ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);\n            state.distbits = opts.bits;\n            if (ret) {\n              strm.msg = \"invalid distances set\";\n              state.mode = BAD;\n              break;\n            }\n            state.mode = LEN_;\n            if (flush === Z_TREES) {\n              break inf_leave;\n            }\n          case LEN_:\n            state.mode = LEN;\n          case LEN:\n            if (have >= 6 && left >= 258) {\n              strm.next_out = put;\n              strm.avail_out = left;\n              strm.next_in = next;\n              strm.avail_in = have;\n              state.hold = hold;\n              state.bits = bits;\n              inflate_fast(strm, _out);\n              put = strm.next_out;\n              output = strm.output;\n              left = strm.avail_out;\n              next = strm.next_in;\n              input = strm.input;\n              have = strm.avail_in;\n              hold = state.hold;\n              bits = state.bits;\n              if (state.mode === TYPE) {\n                state.back = -1;\n              }\n              break;\n            }\n            state.back = 0;\n            for (;;) {\n              here = state.lencode[hold & ((1 << state.lenbits) - 1)];\n              here_bits = here >>> 24;\n              here_op = (here >>> 16) & 255;\n              here_val = here & 65535;\n              if (here_bits <= bits) {\n                break;\n              }\n              if (have === 0) {\n                break inf_leave;\n              }\n              have--;\n              hold += input[next++] << bits;\n              bits += 8;\n            }\n            if (here_op && (here_op & 240) === 0) {\n              last_bits = here_bits;\n              last_op = here_op;\n              last_val = here_val;\n              for (;;) {\n                here = state.lencode[last_val + ((hold & ((1 << (last_bits + last_op)) - 1)) >> last_bits)];\n                here_bits = here >>> 24;\n                here_op = (here >>> 16) & 255;\n                here_val = here & 65535;\n                if (last_bits + here_bits <= bits) {\n                  break;\n                }\n                if (have === 0) {\n                  break inf_leave;\n                }\n                have--;\n                hold += input[next++] << bits;\n                bits += 8;\n              }\n              hold >>>= last_bits;\n              bits -= last_bits;\n              state.back += last_bits;\n            }\n            hold >>>= here_bits;\n            bits -= here_bits;\n            state.back += here_bits;\n            state.length = here_val;\n            if (here_op === 0) {\n              state.mode = LIT;\n              break;\n            }\n            if (here_op & 32) {\n              state.back = -1;\n              state.mode = TYPE;\n              break;\n            }\n            if (here_op & 64) {\n              strm.msg = \"invalid literal/length code\";\n              state.mode = BAD;\n              break;\n            }\n            state.extra = here_op & 15;\n            state.mode = LENEXT;\n          case LENEXT:\n            if (state.extra) {\n              n = state.extra;\n              while (bits < n) {\n                if (have === 0) {\n                  break inf_leave;\n                }\n                have--;\n                hold += input[next++] << bits;\n                bits += 8;\n              }\n              state.length += hold & ((1 << state.extra) - 1);\n              hold >>>= state.extra;\n              bits -= state.extra;\n              state.back += state.extra;\n            }\n            state.was = state.length;\n            state.mode = DIST;\n          case DIST:\n            for (;;) {\n              here = state.distcode[hold & ((1 << state.distbits) - 1)];\n              here_bits = here >>> 24;\n              here_op = (here >>> 16) & 255;\n              here_val = here & 65535;\n              if (here_bits <= bits) {\n                break;\n              }\n              if (have === 0) {\n                break inf_leave;\n              }\n              have--;\n              hold += input[next++] << bits;\n              bits += 8;\n            }\n            if ((here_op & 240) === 0) {\n              last_bits = here_bits;\n              last_op = here_op;\n              last_val = here_val;\n              for (;;) {\n                here = state.distcode[last_val + ((hold & ((1 << (last_bits + last_op)) - 1)) >> last_bits)];\n                here_bits = here >>> 24;\n                here_op = (here >>> 16) & 255;\n                here_val = here & 65535;\n                if (last_bits + here_bits <= bits) {\n                  break;\n                }\n                if (have === 0) {\n                  break inf_leave;\n                }\n                have--;\n                hold += input[next++] << bits;\n                bits += 8;\n              }\n              hold >>>= last_bits;\n              bits -= last_bits;\n              state.back += last_bits;\n            }\n            hold >>>= here_bits;\n            bits -= here_bits;\n            state.back += here_bits;\n            if (here_op & 64) {\n              strm.msg = \"invalid distance code\";\n              state.mode = BAD;\n              break;\n            }\n            state.offset = here_val;\n            state.extra = here_op & 15;\n            state.mode = DISTEXT;\n          case DISTEXT:\n            if (state.extra) {\n              n = state.extra;\n              while (bits < n) {\n                if (have === 0) {\n                  break inf_leave;\n                }\n                have--;\n                hold += input[next++] << bits;\n                bits += 8;\n              }\n              state.offset += hold & ((1 << state.extra) - 1);\n              hold >>>= state.extra;\n              bits -= state.extra;\n              state.back += state.extra;\n            }\n            if (state.offset > state.dmax) {\n              strm.msg = \"invalid distance too far back\";\n              state.mode = BAD;\n              break;\n            }\n            state.mode = MATCH;\n          case MATCH:\n            if (left === 0) {\n              break inf_leave;\n            }\n            copy = _out - left;\n            if (state.offset > copy) {\n              copy = state.offset - copy;\n              if (copy > state.whave) {\n                if (state.sane) {\n                  strm.msg = \"invalid distance too far back\";\n                  state.mode = BAD;\n                  break;\n                }\n              }\n              if (copy > state.wnext) {\n                copy -= state.wnext;\n                from = state.wsize - copy;\n              } else {\n                from = state.wnext - copy;\n              }\n              if (copy > state.length) {\n                copy = state.length;\n              }\n              from_source = state.window;\n            } else {\n              from_source = output;\n              from = put - state.offset;\n              copy = state.length;\n            }\n            if (copy > left) {\n              copy = left;\n            }\n            left -= copy;\n            state.length -= copy;\n            do {\n              output[put++] = from_source[from++];\n            } while (--copy);\n            if (state.length === 0) {\n              state.mode = LEN;\n            }\n            break;\n          case LIT:\n            if (left === 0) {\n              break inf_leave;\n            }\n            output[put++] = state.length;\n            left--;\n            state.mode = LEN;\n            break;\n          case CHECK:\n            if (state.wrap) {\n              while (bits < 32) {\n                if (have === 0) {\n                  break inf_leave;\n                }\n                have--;\n                hold |= input[next++] << bits;\n                bits += 8;\n              }\n              _out -= left;\n              strm.total_out += _out;\n              state.total += _out;\n              if (_out) {\n                strm.adler = state.check = state.flags\n                  ? crc32(state.check, output, _out, put - _out)\n                  : adler32(state.check, output, _out, put - _out);\n              }\n              _out = left;\n              if ((state.flags ? hold : zswap32(hold)) !== state.check) {\n                strm.msg = \"incorrect data check\";\n                state.mode = BAD;\n                break;\n              }\n              hold = 0;\n              bits = 0;\n            }\n            state.mode = LENGTH;\n          case LENGTH:\n            if (state.wrap && state.flags) {\n              while (bits < 32) {\n                if (have === 0) {\n                  break inf_leave;\n                }\n                have--;\n                hold += input[next++] << bits;\n                bits += 8;\n              }\n              if (hold !== (state.total & 4294967295)) {\n                strm.msg = \"incorrect length check\";\n                state.mode = BAD;\n                break;\n              }\n              hold = 0;\n              bits = 0;\n            }\n            state.mode = DONE;\n          case DONE:\n            ret = Z_STREAM_END;\n            break inf_leave;\n          case BAD:\n            ret = Z_DATA_ERROR;\n            break inf_leave;\n          case MEM:\n            return Z_MEM_ERROR;\n          case SYNC:\n          default:\n            return Z_STREAM_ERROR;\n        }\n      }\n      strm.next_out = put;\n      strm.avail_out = left;\n      strm.next_in = next;\n      strm.avail_in = have;\n      state.hold = hold;\n      state.bits = bits;\n      if (state.wsize || (_out !== strm.avail_out && state.mode < BAD && (state.mode < CHECK || flush !== Z_FINISH))) {\n        if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {\n          state.mode = MEM;\n          return Z_MEM_ERROR;\n        }\n      }\n      _in -= strm.avail_in;\n      _out -= strm.avail_out;\n      strm.total_in += _in;\n      strm.total_out += _out;\n      state.total += _out;\n      if (state.wrap && _out) {\n        strm.adler = state.check = state.flags\n          ? crc32(state.check, output, _out, strm.next_out - _out)\n          : adler32(state.check, output, _out, strm.next_out - _out);\n      }\n      strm.data_type =\n        state.bits +\n        (state.last ? 64 : 0) +\n        (state.mode === TYPE ? 128 : 0) +\n        (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);\n      if (((_in === 0 && _out === 0) || flush === Z_FINISH) && ret === Z_OK) {\n        ret = Z_BUF_ERROR;\n      }\n      return ret;\n    }\n    function inflateEnd(strm) {\n      if (!strm || !strm.state) {\n        return Z_STREAM_ERROR;\n      }\n      var state = strm.state;\n      if (state.window) {\n        state.window = null;\n      }\n      strm.state = null;\n      return Z_OK;\n    }\n    function inflateGetHeader(strm, head) {\n      var state;\n      if (!strm || !strm.state) {\n        return Z_STREAM_ERROR;\n      }\n      state = strm.state;\n      if ((state.wrap & 2) === 0) {\n        return Z_STREAM_ERROR;\n      }\n      state.head = head;\n      head.done = false;\n      return Z_OK;\n    }\n    function inflateSetDictionary(strm, dictionary) {\n      var dictLength = dictionary.length;\n      var state;\n      var dictid;\n      var ret;\n      if (!strm || !strm.state) {\n        return Z_STREAM_ERROR;\n      }\n      state = strm.state;\n      if (state.wrap !== 0 && state.mode !== DICT) {\n        return Z_STREAM_ERROR;\n      }\n      if (state.mode === DICT) {\n        dictid = 1;\n        dictid = adler32(dictid, dictionary, dictLength, 0);\n        if (dictid !== state.check) {\n          return Z_DATA_ERROR;\n        }\n      }\n      ret = updatewindow(strm, dictionary, dictLength, dictLength);\n      if (ret) {\n        state.mode = MEM;\n        return Z_MEM_ERROR;\n      }\n      state.havedict = 1;\n      return Z_OK;\n    }\n    exports.inflateReset = inflateReset;\n    exports.inflateReset2 = inflateReset2;\n    exports.inflateResetKeep = inflateResetKeep;\n    exports.inflateInit = inflateInit;\n    exports.inflateInit2 = inflateInit2;\n    exports.inflate = inflate;\n    exports.inflateEnd = inflateEnd;\n    exports.inflateGetHeader = inflateGetHeader;\n    exports.inflateSetDictionary = inflateSetDictionary;\n    exports.inflateInfo = \"pako inflate (from Nodeca project)\";\n  },\n});\n\n// node_modules/pako/lib/zlib/constants.js\nvar require_constants = __commonJS({\n  \"node_modules/pako/lib/zlib/constants.js\"(exports, module2) {\n    \"use strict\";\n    module2.exports = {\n      Z_NO_FLUSH: 0,\n      Z_PARTIAL_FLUSH: 1,\n      Z_SYNC_FLUSH: 2,\n      Z_FULL_FLUSH: 3,\n      Z_FINISH: 4,\n      Z_BLOCK: 5,\n      Z_TREES: 6,\n      Z_OK: 0,\n      Z_STREAM_END: 1,\n      Z_NEED_DICT: 2,\n      Z_ERRNO: -1,\n      Z_STREAM_ERROR: -2,\n      Z_DATA_ERROR: -3,\n      Z_BUF_ERROR: -5,\n      Z_NO_COMPRESSION: 0,\n      Z_BEST_SPEED: 1,\n      Z_BEST_COMPRESSION: 9,\n      Z_DEFAULT_COMPRESSION: -1,\n      Z_FILTERED: 1,\n      Z_HUFFMAN_ONLY: 2,\n      Z_RLE: 3,\n      Z_FIXED: 4,\n      Z_DEFAULT_STRATEGY: 0,\n      Z_BINARY: 0,\n      Z_TEXT: 1,\n      Z_UNKNOWN: 2,\n      Z_DEFLATED: 8,\n    };\n  },\n});\n\n// node_modules/browserify-zlib/lib/binding.js\nvar require_binding = __commonJS({\n  \"node_modules/browserify-zlib/lib/binding.js\"(exports) {\n    \"use strict\";\n    var assert = require(\"assert\");\n    var Zstream = require_zstream();\n    var zlib_deflate = require_deflate();\n    var zlib_inflate = require_inflate();\n    var constants = require_constants();\n    for (key in constants) {\n      exports[key] = constants[key];\n    }\n    var key;\n    exports.NONE = 0;\n    exports.DEFLATE = 1;\n    exports.INFLATE = 2;\n    exports.GZIP = 3;\n    exports.GUNZIP = 4;\n    exports.DEFLATERAW = 5;\n    exports.INFLATERAW = 6;\n    exports.UNZIP = 7;\n    var GZIP_HEADER_ID1 = 31;\n    var GZIP_HEADER_ID2 = 139;\n    function Zlib(mode) {\n      if (typeof mode !== \"number\" || mode < exports.DEFLATE || mode > exports.UNZIP) {\n        throw new TypeError(\"Bad argument\");\n      }\n      this.dictionary = null;\n      this.err = 0;\n      this.flush = 0;\n      this.init_done = false;\n      this.level = 0;\n      this.memLevel = 0;\n      this.mode = mode;\n      this.strategy = 0;\n      this.windowBits = 0;\n      this.write_in_progress = false;\n      this.pending_close = false;\n      this.gzip_id_bytes_read = 0;\n    }\n    Zlib.prototype.close = function () {\n      if (this.write_in_progress) {\n        this.pending_close = true;\n        return;\n      }\n      this.pending_close = false;\n      assert(this.init_done, \"close before init\");\n      assert(this.mode <= exports.UNZIP);\n      if (this.mode === exports.DEFLATE || this.mode === exports.GZIP || this.mode === exports.DEFLATERAW) {\n        zlib_deflate.deflateEnd(this.strm);\n      } else if (\n        this.mode === exports.INFLATE ||\n        this.mode === exports.GUNZIP ||\n        this.mode === exports.INFLATERAW ||\n        this.mode === exports.UNZIP\n      ) {\n        zlib_inflate.inflateEnd(this.strm);\n      }\n      this.mode = exports.NONE;\n      this.dictionary = null;\n    };\n    Zlib.prototype.write = function (flush, input, in_off, in_len, out, out_off, out_len) {\n      return this._write(true, flush, input, in_off, in_len, out, out_off, out_len);\n    };\n    Zlib.prototype.writeSync = function (flush, input, in_off, in_len, out, out_off, out_len) {\n      return this._write(false, flush, input, in_off, in_len, out, out_off, out_len);\n    };\n    Zlib.prototype._write = function (async, flush, input, in_off, in_len, out, out_off, out_len) {\n      assert.equal(arguments.length, 8);\n      assert(this.init_done, \"write before init\");\n      assert(this.mode !== exports.NONE, \"already finalized\");\n      assert.equal(false, this.write_in_progress, \"write already in progress\");\n      assert.equal(false, this.pending_close, \"close is pending\");\n      this.write_in_progress = true;\n      assert.equal(false, flush === void 0, \"must provide flush value\");\n      this.write_in_progress = true;\n      if (\n        flush !== exports.Z_NO_FLUSH &&\n        flush !== exports.Z_PARTIAL_FLUSH &&\n        flush !== exports.Z_SYNC_FLUSH &&\n        flush !== exports.Z_FULL_FLUSH &&\n        flush !== exports.Z_FINISH &&\n        flush !== exports.Z_BLOCK\n      ) {\n        throw new Error(\"Invalid flush value\");\n      }\n      if (input == null) {\n        input = Buffer.alloc(0);\n        in_len = 0;\n        in_off = 0;\n      }\n      this.strm.avail_in = in_len;\n      this.strm.input = input;\n      this.strm.next_in = in_off;\n      this.strm.avail_out = out_len;\n      this.strm.output = out;\n      this.strm.next_out = out_off;\n      this.flush = flush;\n      if (!async) {\n        this._process();\n        if (this._checkError()) {\n          return this._afterSync();\n        }\n        return;\n      }\n      var self = this;\n      process.nextTick(function () {\n        self._process();\n        self._after();\n      });\n      return this;\n    };\n    Zlib.prototype._afterSync = function () {\n      var avail_out = this.strm.avail_out;\n      var avail_in = this.strm.avail_in;\n      this.write_in_progress = false;\n      return [avail_in, avail_out];\n    };\n    Zlib.prototype._process = function () {\n      var next_expected_header_byte = null;\n      switch (this.mode) {\n        case exports.DEFLATE:\n        case exports.GZIP:\n        case exports.DEFLATERAW:\n          this.err = zlib_deflate.deflate(this.strm, this.flush);\n          break;\n        case exports.UNZIP:\n          if (this.strm.avail_in > 0) {\n            next_expected_header_byte = this.strm.next_in;\n          }\n          switch (this.gzip_id_bytes_read) {\n            case 0:\n              if (next_expected_header_byte === null) {\n                break;\n              }\n              if (this.strm.input[next_expected_header_byte] === GZIP_HEADER_ID1) {\n                this.gzip_id_bytes_read = 1;\n                next_expected_header_byte++;\n                if (this.strm.avail_in === 1) {\n                  break;\n                }\n              } else {\n                this.mode = exports.INFLATE;\n                break;\n              }\n            case 1:\n              if (next_expected_header_byte === null) {\n                break;\n              }\n              if (this.strm.input[next_expected_header_byte] === GZIP_HEADER_ID2) {\n                this.gzip_id_bytes_read = 2;\n                this.mode = exports.GUNZIP;\n              } else {\n                this.mode = exports.INFLATE;\n              }\n              break;\n            default:\n              throw new Error(\"invalid number of gzip magic number bytes read\");\n          }\n        case exports.INFLATE:\n        case exports.GUNZIP:\n        case exports.INFLATERAW:\n          this.err = zlib_inflate.inflate(this.strm, this.flush);\n          if (this.err === exports.Z_NEED_DICT && this.dictionary) {\n            this.err = zlib_inflate.inflateSetDictionary(this.strm, this.dictionary);\n            if (this.err === exports.Z_OK) {\n              this.err = zlib_inflate.inflate(this.strm, this.flush);\n            } else if (this.err === exports.Z_DATA_ERROR) {\n              this.err = exports.Z_NEED_DICT;\n            }\n          }\n          while (\n            this.strm.avail_in > 0 &&\n            this.mode === exports.GUNZIP &&\n            this.err === exports.Z_STREAM_END &&\n            this.strm.next_in[0] !== 0\n          ) {\n            this.reset();\n            this.err = zlib_inflate.inflate(this.strm, this.flush);\n          }\n          break;\n        default:\n          throw new Error(\"Unknown mode \" + this.mode);\n      }\n    };\n    Zlib.prototype._checkError = function () {\n      switch (this.err) {\n        case exports.Z_OK:\n        case exports.Z_BUF_ERROR:\n          if (this.strm.avail_out !== 0 && this.flush === exports.Z_FINISH) {\n            this._error(\"unexpected end of file\");\n            return false;\n          }\n          break;\n        case exports.Z_STREAM_END:\n          break;\n        case exports.Z_NEED_DICT:\n          if (this.dictionary == null) {\n            this._error(\"Missing dictionary\");\n          } else {\n            this._error(\"Bad dictionary\");\n          }\n          return false;\n        default:\n          this._error(\"Zlib error\");\n          return false;\n      }\n      return true;\n    };\n    Zlib.prototype._after = function () {\n      if (!this._checkError()) {\n        return;\n      }\n      var avail_out = this.strm.avail_out;\n      var avail_in = this.strm.avail_in;\n      this.write_in_progress = false;\n      this.callback(avail_in, avail_out);\n      if (this.pending_close) {\n        this.close();\n      }\n    };\n    Zlib.prototype._error = function (message) {\n      if (this.strm.msg) {\n        message = this.strm.msg;\n      }\n      this.onerror(message, this.err);\n      this.write_in_progress = false;\n      if (this.pending_close) {\n        this.close();\n      }\n    };\n    Zlib.prototype.init = function (windowBits, level, memLevel, strategy, dictionary) {\n      assert(\n        arguments.length === 4 || arguments.length === 5,\n        \"init(windowBits, level, memLevel, strategy, [dictionary])\",\n      );\n      assert(windowBits >= 8 && windowBits <= 15, \"invalid windowBits\");\n      assert(level >= -1 && level <= 9, \"invalid compression level\");\n      assert(memLevel >= 1 && memLevel <= 9, \"invalid memlevel\");\n      assert(\n        strategy === exports.Z_FILTERED ||\n          strategy === exports.Z_HUFFMAN_ONLY ||\n          strategy === exports.Z_RLE ||\n          strategy === exports.Z_FIXED ||\n          strategy === exports.Z_DEFAULT_STRATEGY,\n        \"invalid strategy\",\n      );\n      this._init(level, windowBits, memLevel, strategy, dictionary);\n      this._setDictionary();\n    };\n    Zlib.prototype.params = function () {\n      throw new Error(\"deflateParams Not supported\");\n    };\n    Zlib.prototype.reset = function () {\n      this._reset();\n      this._setDictionary();\n    };\n    Zlib.prototype._init = function (level, windowBits, memLevel, strategy, dictionary) {\n      this.level = level;\n      this.windowBits = windowBits;\n      this.memLevel = memLevel;\n      this.strategy = strategy;\n      this.flush = exports.Z_NO_FLUSH;\n      this.err = exports.Z_OK;\n      if (this.mode === exports.GZIP || this.mode === exports.GUNZIP) {\n        this.windowBits += 16;\n      }\n      if (this.mode === exports.UNZIP) {\n        this.windowBits += 32;\n      }\n      if (this.mode === exports.DEFLATERAW || this.mode === exports.INFLATERAW) {\n        this.windowBits = -1 * this.windowBits;\n      }\n      this.strm = new Zstream();\n      switch (this.mode) {\n        case exports.DEFLATE:\n        case exports.GZIP:\n        case exports.DEFLATERAW:\n          this.err = zlib_deflate.deflateInit2(\n            this.strm,\n            this.level,\n            exports.Z_DEFLATED,\n            this.windowBits,\n            this.memLevel,\n            this.strategy,\n          );\n          break;\n        case exports.INFLATE:\n        case exports.GUNZIP:\n        case exports.INFLATERAW:\n        case exports.UNZIP:\n          this.err = zlib_inflate.inflateInit2(this.strm, this.windowBits);\n          break;\n        default:\n          throw new Error(\"Unknown mode \" + this.mode);\n      }\n      if (this.err !== exports.Z_OK) {\n        this._error(\"Init error\");\n      }\n      this.dictionary = dictionary;\n      this.write_in_progress = false;\n      this.init_done = true;\n    };\n    Zlib.prototype._setDictionary = function () {\n      if (this.dictionary == null) {\n        return;\n      }\n      this.err = exports.Z_OK;\n      switch (this.mode) {\n        case exports.DEFLATE:\n        case exports.DEFLATERAW:\n          this.err = zlib_deflate.deflateSetDictionary(this.strm, this.dictionary);\n          break;\n        default:\n          break;\n      }\n      if (this.err !== exports.Z_OK) {\n        this._error(\"Failed to set dictionary\");\n      }\n    };\n    Zlib.prototype._reset = function () {\n      this.err = exports.Z_OK;\n      switch (this.mode) {\n        case exports.DEFLATE:\n        case exports.DEFLATERAW:\n        case exports.GZIP:\n          this.err = zlib_deflate.deflateReset(this.strm);\n          break;\n        case exports.INFLATE:\n        case exports.INFLATERAW:\n        case exports.GUNZIP:\n          this.err = zlib_inflate.inflateReset(this.strm);\n          break;\n        default:\n          break;\n      }\n      if (this.err !== exports.Z_OK) {\n        this._error(\"Failed to reset stream\");\n      }\n    };\n    exports.Zlib = Zlib;\n  },\n});\n\n// node_modules/browserify-zlib/lib/index.js\nvar require_lib = __commonJS({\n  \"node_modules/browserify-zlib/lib/index.js\"(exports) {\n    \"use strict\";\n    var Buffer2 = require(\"buffer\").Buffer;\n    var Transform = require(\"stream\").Transform;\n    var binding = require_binding();\n    var util = require(\"util\");\n    var assert = require(\"assert\").ok;\n    var kMaxLength = require(\"buffer\").kMaxLength;\n    var kRangeErrorMessage =\n      \"Cannot create final Buffer. It would be larger than 0x\" + kMaxLength.toString(16) + \" bytes\";\n    binding.Z_MIN_WINDOWBITS = 8;\n    binding.Z_MAX_WINDOWBITS = 15;\n    binding.Z_DEFAULT_WINDOWBITS = 15;\n    binding.Z_MIN_CHUNK = 64;\n    binding.Z_MAX_CHUNK = Infinity;\n    binding.Z_DEFAULT_CHUNK = 16 * 1024;\n    binding.Z_MIN_MEMLEVEL = 1;\n    binding.Z_MAX_MEMLEVEL = 9;\n    binding.Z_DEFAULT_MEMLEVEL = 8;\n    binding.Z_MIN_LEVEL = -1;\n    binding.Z_MAX_LEVEL = 9;\n    binding.Z_DEFAULT_LEVEL = binding.Z_DEFAULT_COMPRESSION;\n    var bkeys = Object.keys(binding);\n    for (bk = 0; bk < bkeys.length; bk++) {\n      bkey = bkeys[bk];\n      if (bkey.match(/^Z/)) {\n        Object.defineProperty(exports, bkey, {\n          enumerable: true,\n          value: binding[bkey],\n          writable: false,\n        });\n      }\n    }\n    var bkey;\n    var bk;\n    var codes = {\n      Z_OK: binding.Z_OK,\n      Z_STREAM_END: binding.Z_STREAM_END,\n      Z_NEED_DICT: binding.Z_NEED_DICT,\n      Z_ERRNO: binding.Z_ERRNO,\n      Z_STREAM_ERROR: binding.Z_STREAM_ERROR,\n      Z_DATA_ERROR: binding.Z_DATA_ERROR,\n      Z_MEM_ERROR: binding.Z_MEM_ERROR,\n      Z_BUF_ERROR: binding.Z_BUF_ERROR,\n      Z_VERSION_ERROR: binding.Z_VERSION_ERROR,\n    };\n    var ckeys = Object.keys(codes);\n    for (ck = 0; ck < ckeys.length; ck++) {\n      ckey = ckeys[ck];\n      codes[codes[ckey]] = ckey;\n    }\n    var ckey;\n    var ck;\n    Object.defineProperty(exports, \"codes\", {\n      enumerable: true,\n      value: Object.freeze(codes),\n      writable: false,\n    });\n    exports.constants = require_constants();\n    exports.Deflate = Deflate;\n    exports.Inflate = Inflate;\n    exports.Gzip = Gzip;\n    exports.Gunzip = Gunzip;\n    exports.DeflateRaw = DeflateRaw;\n    exports.InflateRaw = InflateRaw;\n    exports.Unzip = Unzip;\n    exports.createDeflate = function (o) {\n      return new Deflate(o);\n    };\n    exports.createInflate = function (o) {\n      return new Inflate(o);\n    };\n    exports.createDeflateRaw = function (o) {\n      return new DeflateRaw(o);\n    };\n    exports.createInflateRaw = function (o) {\n      return new InflateRaw(o);\n    };\n    exports.createGzip = function (o) {\n      return new Gzip(o);\n    };\n    exports.createGunzip = function (o) {\n      return new Gunzip(o);\n    };\n    exports.createUnzip = function (o) {\n      return new Unzip(o);\n    };\n    exports.deflate = function (buffer, opts, callback) {\n      if (typeof opts === \"function\") {\n        callback = opts;\n        opts = {};\n      }\n      return zlibBuffer(new Deflate(opts), buffer, callback);\n    };\n    exports.deflateSync = function (buffer, opts) {\n      return zlibBufferSync(new Deflate(opts), buffer);\n    };\n    exports.gzip = function (buffer, opts, callback) {\n      if (typeof opts === \"function\") {\n        callback = opts;\n        opts = {};\n      }\n      return zlibBuffer(new Gzip(opts), buffer, callback);\n    };\n    exports.gzipSync = function (buffer, opts) {\n      return zlibBufferSync(new Gzip(opts), buffer);\n    };\n    exports.deflateRaw = function (buffer, opts, callback) {\n      if (typeof opts === \"function\") {\n        callback = opts;\n        opts = {};\n      }\n      return zlibBuffer(new DeflateRaw(opts), buffer, callback);\n    };\n    exports.deflateRawSync = function (buffer, opts) {\n      return zlibBufferSync(new DeflateRaw(opts), buffer);\n    };\n    exports.unzip = function (buffer, opts, callback) {\n      if (typeof opts === \"function\") {\n        callback = opts;\n        opts = {};\n      }\n      return zlibBuffer(new Unzip(opts), buffer, callback);\n    };\n    exports.unzipSync = function (buffer, opts) {\n      return zlibBufferSync(new Unzip(opts), buffer);\n    };\n    exports.inflate = function (buffer, opts, callback) {\n      if (typeof opts === \"function\") {\n        callback = opts;\n        opts = {};\n      }\n      return zlibBuffer(new Inflate(opts), buffer, callback);\n    };\n    exports.inflateSync = function (buffer, opts) {\n      return zlibBufferSync(new Inflate(opts), buffer);\n    };\n    exports.gunzip = function (buffer, opts, callback) {\n      if (typeof opts === \"function\") {\n        callback = opts;\n        opts = {};\n      }\n      return zlibBuffer(new Gunzip(opts), buffer, callback);\n    };\n    exports.gunzipSync = function (buffer, opts) {\n      return zlibBufferSync(new Gunzip(opts), buffer);\n    };\n    exports.inflateRaw = function (buffer, opts, callback) {\n      if (typeof opts === \"function\") {\n        callback = opts;\n        opts = {};\n      }\n      return zlibBuffer(new InflateRaw(opts), buffer, callback);\n    };\n    exports.inflateRawSync = function (buffer, opts) {\n      return zlibBufferSync(new InflateRaw(opts), buffer);\n    };\n    function zlibBuffer(engine, buffer, callback) {\n      var buffers = [];\n      var nread = 0;\n      engine.on(\"error\", onError);\n      engine.on(\"end\", onEnd);\n      engine.end(buffer);\n      flow();\n      function flow() {\n        var chunk;\n        while (null !== (chunk = engine.read())) {\n          buffers.push(chunk);\n          nread += chunk.length;\n        }\n        engine.once(\"readable\", flow);\n      }\n      function onError(err) {\n        engine.removeListener(\"end\", onEnd);\n        engine.removeListener(\"readable\", flow);\n        callback(err);\n      }\n      function onEnd() {\n        var buf;\n        var err = null;\n        if (nread >= kMaxLength) {\n          err = new RangeError(kRangeErrorMessage);\n        } else {\n          buf = Buffer2.concat(buffers, nread);\n        }\n        buffers = [];\n        engine.close();\n        callback(err, buf);\n      }\n    }\n    function zlibBufferSync(engine, buffer) {\n      if (typeof buffer === \"string\") buffer = Buffer2.from(buffer);\n      if (!Buffer2.isBuffer(buffer)) throw new TypeError(\"Not a string or buffer\");\n      var flushFlag = engine._finishFlushFlag;\n      return engine._processChunk(buffer, flushFlag);\n    }\n    function Deflate(opts) {\n      if (!(this instanceof Deflate)) return new Deflate(opts);\n      Zlib.call(this, opts, binding.DEFLATE);\n    }\n    function Inflate(opts) {\n      if (!(this instanceof Inflate)) return new Inflate(opts);\n      Zlib.call(this, opts, binding.INFLATE);\n    }\n    function Gzip(opts) {\n      if (!(this instanceof Gzip)) return new Gzip(opts);\n      Zlib.call(this, opts, binding.GZIP);\n    }\n    function Gunzip(opts) {\n      if (!(this instanceof Gunzip)) return new Gunzip(opts);\n      Zlib.call(this, opts, binding.GUNZIP);\n    }\n    function DeflateRaw(opts) {\n      if (!(this instanceof DeflateRaw)) return new DeflateRaw(opts);\n      Zlib.call(this, opts, binding.DEFLATERAW);\n    }\n    function InflateRaw(opts) {\n      if (!(this instanceof InflateRaw)) return new InflateRaw(opts);\n      Zlib.call(this, opts, binding.INFLATERAW);\n    }\n    function Unzip(opts) {\n      if (!(this instanceof Unzip)) return new Unzip(opts);\n      Zlib.call(this, opts, binding.UNZIP);\n    }\n    function isValidFlushFlag(flag) {\n      return (\n        flag === binding.Z_NO_FLUSH ||\n        flag === binding.Z_PARTIAL_FLUSH ||\n        flag === binding.Z_SYNC_FLUSH ||\n        flag === binding.Z_FULL_FLUSH ||\n        flag === binding.Z_FINISH ||\n        flag === binding.Z_BLOCK\n      );\n    }\n    function Zlib(opts, mode) {\n      var _this = this;\n      this._opts = opts = opts || {};\n      this._chunkSize = opts.chunkSize || exports.Z_DEFAULT_CHUNK;\n      Transform.call(this, opts);\n      if (opts.flush && !isValidFlushFlag(opts.flush)) {\n        throw new Error(\"Invalid flush flag: \" + opts.flush);\n      }\n      if (opts.finishFlush && !isValidFlushFlag(opts.finishFlush)) {\n        throw new Error(\"Invalid flush flag: \" + opts.finishFlush);\n      }\n      this._flushFlag = opts.flush || binding.Z_NO_FLUSH;\n      this._finishFlushFlag = typeof opts.finishFlush !== \"undefined\" ? opts.finishFlush : binding.Z_FINISH;\n      if (opts.chunkSize) {\n        if (opts.chunkSize < exports.Z_MIN_CHUNK || opts.chunkSize > exports.Z_MAX_CHUNK) {\n          throw new Error(\"Invalid chunk size: \" + opts.chunkSize);\n        }\n      }\n      if (opts.windowBits) {\n        if (opts.windowBits < exports.Z_MIN_WINDOWBITS || opts.windowBits > exports.Z_MAX_WINDOWBITS) {\n          throw new Error(\"Invalid windowBits: \" + opts.windowBits);\n        }\n      }\n      if (opts.level) {\n        if (opts.level < exports.Z_MIN_LEVEL || opts.level > exports.Z_MAX_LEVEL) {\n          throw new Error(\"Invalid compression level: \" + opts.level);\n        }\n      }\n      if (opts.memLevel) {\n        if (opts.memLevel < exports.Z_MIN_MEMLEVEL || opts.memLevel > exports.Z_MAX_MEMLEVEL) {\n          throw new Error(\"Invalid memLevel: \" + opts.memLevel);\n        }\n      }\n      if (opts.strategy) {\n        if (\n          opts.strategy != exports.Z_FILTERED &&\n          opts.strategy != exports.Z_HUFFMAN_ONLY &&\n          opts.strategy != exports.Z_RLE &&\n          opts.strategy != exports.Z_FIXED &&\n          opts.strategy != exports.Z_DEFAULT_STRATEGY\n        ) {\n          throw new Error(\"Invalid strategy: \" + opts.strategy);\n        }\n      }\n      if (opts.dictionary) {\n        if (!Buffer2.isBuffer(opts.dictionary)) {\n          throw new Error(\"Invalid dictionary: it should be a Buffer instance\");\n        }\n      }\n      this._handle = new binding.Zlib(mode);\n      var self = this;\n      this._hadError = false;\n      this._handle.onerror = function (message, errno) {\n        _close(self);\n        self._hadError = true;\n        var error = new Error(message);\n        error.errno = errno;\n        error.code = exports.codes[errno];\n        self.emit(\"error\", error);\n      };\n      var level = exports.Z_DEFAULT_COMPRESSION;\n      if (typeof opts.level === \"number\") level = opts.level;\n      var strategy = exports.Z_DEFAULT_STRATEGY;\n      if (typeof opts.strategy === \"number\") strategy = opts.strategy;\n      this._handle.init(\n        opts.windowBits || exports.Z_DEFAULT_WINDOWBITS,\n        level,\n        opts.memLevel || exports.Z_DEFAULT_MEMLEVEL,\n        strategy,\n        opts.dictionary,\n      );\n      this._buffer = Buffer2.allocUnsafe(this._chunkSize);\n      this._offset = 0;\n      this._level = level;\n      this._strategy = strategy;\n      this.once(\"end\", this.close);\n      Object.defineProperty(this, \"_closed\", {\n        get: function () {\n          return !_this._handle;\n        },\n        configurable: true,\n        enumerable: true,\n      });\n    }\n    util.inherits(Zlib, Transform);\n    Zlib.prototype.params = function (level, strategy, callback) {\n      if (level < exports.Z_MIN_LEVEL || level > exports.Z_MAX_LEVEL) {\n        throw new RangeError(\"Invalid compression level: \" + level);\n      }\n      if (\n        strategy != exports.Z_FILTERED &&\n        strategy != exports.Z_HUFFMAN_ONLY &&\n        strategy != exports.Z_RLE &&\n        strategy != exports.Z_FIXED &&\n        strategy != exports.Z_DEFAULT_STRATEGY\n      ) {\n        throw new TypeError(\"Invalid strategy: \" + strategy);\n      }\n      if (this._level !== level || this._strategy !== strategy) {\n        var self = this;\n        this.flush(binding.Z_SYNC_FLUSH, function () {\n          assert(self._handle, \"zlib binding closed\");\n          self._handle.params(level, strategy);\n          if (!self._hadError) {\n            self._level = level;\n            self._strategy = strategy;\n            if (callback) callback();\n          }\n        });\n      } else {\n        process.nextTick(callback);\n      }\n    };\n    Zlib.prototype.reset = function () {\n      assert(this._handle, \"zlib binding closed\");\n      return this._handle.reset();\n    };\n    Zlib.prototype._flush = function (callback) {\n      this._transform(Buffer2.alloc(0), \"\", callback);\n    };\n    Zlib.prototype.flush = function (kind, callback) {\n      var _this2 = this;\n      var ws = this._writableState;\n      if (typeof kind === \"function\" || (kind === void 0 && !callback)) {\n        callback = kind;\n        kind = binding.Z_FULL_FLUSH;\n      }\n      if (ws.ended) {\n        if (callback) process.nextTick(callback);\n      } else if (ws.ending) {\n        if (callback) this.once(\"end\", callback);\n      } else if (ws.needDrain) {\n        if (callback) {\n          this.once(\"drain\", function () {\n            return _this2.flush(kind, callback);\n          });\n        }\n      } else {\n        this._flushFlag = kind;\n        this.write(Buffer2.alloc(0), \"\", callback);\n      }\n    };\n    Zlib.prototype.close = function (callback) {\n      _close(this, callback);\n      process.nextTick(emitCloseNT, this);\n    };\n    function _close(engine, callback) {\n      if (callback) process.nextTick(callback);\n      if (!engine._handle) return;\n      engine._handle.close();\n      engine._handle = null;\n    }\n    function emitCloseNT(self) {\n      self.emit(\"close\");\n    }\n    Zlib.prototype._transform = function (chunk, encoding, cb) {\n      var flushFlag;\n      var ws = this._writableState;\n      var ending = ws.ending || ws.ended;\n      var last = ending && (!chunk || ws.length === chunk.length);\n      if (chunk !== null && !Buffer2.isBuffer(chunk)) return cb(new Error(\"invalid input\"));\n      if (!this._handle) return cb(new Error(\"zlib binding closed\"));\n      if (last) flushFlag = this._finishFlushFlag;\n      else {\n        flushFlag = this._flushFlag;\n        if (chunk.length >= ws.length) {\n          this._flushFlag = this._opts.flush || binding.Z_NO_FLUSH;\n        }\n      }\n      this._processChunk(chunk, flushFlag, cb);\n    };\n    Zlib.prototype._processChunk = function (chunk, flushFlag, cb) {\n      var availInBefore = chunk && chunk.length;\n      var availOutBefore = this._chunkSize - this._offset;\n      var inOff = 0;\n      var self = this;\n      var async = typeof cb === \"function\";\n      if (!async) {\n        var buffers = [];\n        var nread = 0;\n        var error;\n        this.on(\"error\", function (er) {\n          error = er;\n        });\n        assert(this._handle, \"zlib binding closed\");\n        do {\n          var res = this._handle.writeSync(\n            flushFlag,\n            chunk,\n            inOff,\n            availInBefore,\n            this._buffer,\n            this._offset,\n            availOutBefore,\n          );\n        } while (!this._hadError && callback(res[0], res[1]));\n        if (this._hadError) {\n          throw error;\n        }\n        if (nread >= kMaxLength) {\n          _close(this);\n          throw new RangeError(kRangeErrorMessage);\n        }\n        var buf = Buffer2.concat(buffers, nread);\n        _close(this);\n        return buf;\n      }\n      assert(this._handle, \"zlib binding closed\");\n      var req = this._handle.write(flushFlag, chunk, inOff, availInBefore, this._buffer, this._offset, availOutBefore);\n      req.buffer = chunk;\n      req.callback = callback;\n      function callback(availInAfter, availOutAfter) {\n        if (this) {\n          this.buffer = null;\n          this.callback = null;\n        }\n        if (self._hadError) return;\n        var have = availOutBefore - availOutAfter;\n        assert(have >= 0, \"have should not go down\");\n        if (have > 0) {\n          var out = self._buffer.slice(self._offset, self._offset + have);\n          self._offset += have;\n          if (async) {\n            self.push(out);\n          } else {\n            buffers.push(out);\n            nread += out.length;\n          }\n        }\n        if (availOutAfter === 0 || self._offset >= self._chunkSize) {\n          availOutBefore = self._chunkSize;\n          self._offset = 0;\n          self._buffer = Buffer2.allocUnsafe(self._chunkSize);\n        }\n        if (availOutAfter === 0) {\n          inOff += availInBefore - availInAfter;\n          availInBefore = availInAfter;\n          if (!async) return true;\n          var newReq = self._handle.write(\n            flushFlag,\n            chunk,\n            inOff,\n            availInBefore,\n            self._buffer,\n            self._offset,\n            self._chunkSize,\n          );\n          newReq.callback = callback;\n          newReq.buffer = chunk;\n          return;\n        }\n        if (!async) return false;\n        cb();\n      }\n    };\n    util.inherits(Deflate, Zlib);\n    util.inherits(Inflate, Zlib);\n    util.inherits(Gzip, Zlib);\n    util.inherits(Gunzip, Zlib);\n    util.inherits(DeflateRaw, Zlib);\n    util.inherits(InflateRaw, Zlib);\n    util.inherits(Unzip, Zlib);\n  },\n});\n\n// zlib.js\nvar zlib_exports = require_lib();\nzlib_exports[Symbol.for(\"CommonJS\")] = 0;\nexport default zlib_exports;\n\nexport var {\n  Deflate,\n  Inflate,\n  Gzip,\n  Gunzip,\n  DeflateRaw,\n  InflateRaw,\n  Unzip,\n  createDeflate,\n  createInflate,\n  createDeflateRaw,\n  createInflateRaw,\n  createGzip,\n  createGunzip,\n  createUnzip,\n  deflate,\n  deflateSync,\n  gzip,\n  gzipSync,\n  deflateRaw,\n  deflateRawSync,\n  unzip,\n  unzipSync,\n  inflate,\n  inflateSync,\n  gunzip,\n  gunzipSync,\n  inflateRaw,\n  inflateRawSync,\n  constants,\n} = zlib_exports;\n",
  "// Hardcoded module \"node:zlib\"\n// TODO: **use a native binding from Bun for this!!**\n// This is a very slow module!\n// It should really be fixed. It will show up in benchmarking. It also loads\n// slowly. We need to fix it!\n\nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __commonJS = (cb, mod) =>\n  function __require() {\n    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;\n  };\n\nvar __copyProps = (to, from, except, desc) => {\n  if ((from && typeof from === \"object\") || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, {\n          get: () => from[key],\n          enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable,\n        });\n  }\n  return to;\n};\nvar __reExport = (target, mod, secondTarget) => (\n  __copyProps(target, mod, \"default\"), secondTarget && __copyProps(secondTarget, mod, \"default\")\n);\nvar __toESM = (mod, isNodeMode, target) => (\n  (target = mod != null ? __create(__getProtoOf(mod)) : {}),\n  __copyProps(\n    isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", { value: mod, enumerable: true }) : target,\n    mod,\n  )\n);\nvar __toCommonJS = mod => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\n\nconst require = id => import.meta.require(id);\n\n// node_modules/pako/lib/zlib/zstream.js\nvar require_zstream = __commonJS({\n  \"node_modules/pako/lib/zlib/zstream.js\"(exports, module2) {\n    \"use strict\";\n    function ZStream() {\n      this.input = null;\n      this.next_in = 0;\n      this.avail_in = 0;\n      this.total_in = 0;\n      this.output = null;\n      this.next_out = 0;\n      this.avail_out = 0;\n      this.total_out = 0;\n      this.msg = \"\";\n      this.state = null;\n      this.data_type = 2;\n      this.adler = 0;\n    }\n    module2.exports = ZStream;\n  },\n});\n\n// node_modules/pako/lib/utils/common.js\nvar require_common = __commonJS({\n  \"node_modules/pako/lib/utils/common.js\"(exports) {\n    \"use strict\";\n    var TYPED_OK =\n      typeof Uint8Array !== \"undefined\" && typeof Uint16Array !== \"undefined\" && typeof Int32Array !== \"undefined\";\n    function _has(obj, key) {\n      return Object.prototype.hasOwnProperty.call(obj, key);\n    }\n    exports.assign = function (obj) {\n      var sources = Array.prototype.slice.call(arguments, 1);\n      while (sources.length) {\n        var source = sources.shift();\n        if (!source) {\n          continue;\n        }\n        if (typeof source !== \"object\") {\n          throw new TypeError(source + \"must be non-object\");\n        }\n        for (var p in source) {\n          if (_has(source, p)) {\n            obj[p] = source[p];\n          }\n        }\n      }\n      return obj;\n    };\n    exports.shrinkBuf = function (buf, size) {\n      if (buf.length === size) {\n        return buf;\n      }\n      if (buf.subarray) {\n        return buf.subarray(0, size);\n      }\n      buf.length = size;\n      return buf;\n    };\n    var fnTyped = {\n      arraySet: function (dest, src, src_offs, len, dest_offs) {\n        if (src.subarray && dest.subarray) {\n          dest.set(src.subarray(src_offs, src_offs + len), dest_offs);\n          return;\n        }\n        for (var i = 0; i < len; i++) {\n          dest[dest_offs + i] = src[src_offs + i];\n        }\n      },\n      flattenChunks: function (chunks) {\n        var i, l, len, pos, chunk, result;\n        len = 0;\n        for (i = 0, l = chunks.length; i < l; i++) {\n          len += chunks[i].length;\n        }\n        result = new Uint8Array(len);\n        pos = 0;\n        for (i = 0, l = chunks.length; i < l; i++) {\n          chunk = chunks[i];\n          result.set(chunk, pos);\n          pos += chunk.length;\n        }\n        return result;\n      },\n    };\n    var fnUntyped = {\n      arraySet: function (dest, src, src_offs, len, dest_offs) {\n        for (var i = 0; i < len; i++) {\n          dest[dest_offs + i] = src[src_offs + i];\n        }\n      },\n      flattenChunks: function (chunks) {\n        return [].concat.apply([], chunks);\n      },\n    };\n    exports.setTyped = function (on) {\n      if (on) {\n        exports.Buf8 = Uint8Array;\n        exports.Buf16 = Uint16Array;\n        exports.Buf32 = Int32Array;\n        exports.assign(exports, fnTyped);\n      } else {\n        exports.Buf8 = Array;\n        exports.Buf16 = Array;\n        exports.Buf32 = Array;\n        exports.assign(exports, fnUntyped);\n      }\n    };\n    exports.setTyped(TYPED_OK);\n  },\n});\n\n// node_modules/pako/lib/zlib/trees.js\nvar require_trees = __commonJS({\n  \"node_modules/pako/lib/zlib/trees.js\"(exports) {\n    \"use strict\";\n    var utils = require_common();\n    var Z_FIXED = 4;\n    var Z_BINARY = 0;\n    var Z_TEXT = 1;\n    var Z_UNKNOWN = 2;\n    function zero(buf) {\n      var len = buf.length;\n      while (--len >= 0) {\n        buf[len] = 0;\n      }\n    }\n    var STORED_BLOCK = 0;\n    var STATIC_TREES = 1;\n    var DYN_TREES = 2;\n    var MIN_MATCH = 3;\n    var MAX_MATCH = 258;\n    var LENGTH_CODES = 29;\n    var LITERALS = 256;\n    var L_CODES = LITERALS + 1 + LENGTH_CODES;\n    var D_CODES = 30;\n    var BL_CODES = 19;\n    var HEAP_SIZE = 2 * L_CODES + 1;\n    var MAX_BITS = 15;\n    var Buf_size = 16;\n    var MAX_BL_BITS = 7;\n    var END_BLOCK = 256;\n    var REP_3_6 = 16;\n    var REPZ_3_10 = 17;\n    var REPZ_11_138 = 18;\n    var extra_lbits = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0];\n    var extra_dbits = [\n      0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13,\n    ];\n    var extra_blbits = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7];\n    var bl_order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];\n    var DIST_CODE_LEN = 512;\n    var static_ltree = new Array((L_CODES + 2) * 2);\n    zero(static_ltree);\n    var static_dtree = new Array(D_CODES * 2);\n    zero(static_dtree);\n    var _dist_code = new Array(DIST_CODE_LEN);\n    zero(_dist_code);\n    var _length_code = new Array(MAX_MATCH - MIN_MATCH + 1);\n    zero(_length_code);\n    var base_length = new Array(LENGTH_CODES);\n    zero(base_length);\n    var base_dist = new Array(D_CODES);\n    zero(base_dist);\n    function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {\n      this.static_tree = static_tree;\n      this.extra_bits = extra_bits;\n      this.extra_base = extra_base;\n      this.elems = elems;\n      this.max_length = max_length;\n      this.has_stree = static_tree && static_tree.length;\n    }\n    var static_l_desc;\n    var static_d_desc;\n    var static_bl_desc;\n    function TreeDesc(dyn_tree, stat_desc) {\n      this.dyn_tree = dyn_tree;\n      this.max_code = 0;\n      this.stat_desc = stat_desc;\n    }\n    function d_code(dist) {\n      return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];\n    }\n    function put_short(s, w) {\n      s.pending_buf[s.pending++] = w & 255;\n      s.pending_buf[s.pending++] = (w >>> 8) & 255;\n    }\n    function send_bits(s, value, length) {\n      if (s.bi_valid > Buf_size - length) {\n        s.bi_buf |= (value << s.bi_valid) & 65535;\n        put_short(s, s.bi_buf);\n        s.bi_buf = value >> (Buf_size - s.bi_valid);\n        s.bi_valid += length - Buf_size;\n      } else {\n        s.bi_buf |= (value << s.bi_valid) & 65535;\n        s.bi_valid += length;\n      }\n    }\n    function send_code(s, c, tree) {\n      send_bits(s, tree[c * 2], tree[c * 2 + 1]);\n    }\n    function bi_reverse(code, len) {\n      var res = 0;\n      do {\n        res |= code & 1;\n        code >>>= 1;\n        res <<= 1;\n      } while (--len > 0);\n      return res >>> 1;\n    }\n    function bi_flush(s) {\n      if (s.bi_valid === 16) {\n        put_short(s, s.bi_buf);\n        s.bi_buf = 0;\n        s.bi_valid = 0;\n      } else if (s.bi_valid >= 8) {\n        s.pending_buf[s.pending++] = s.bi_buf & 255;\n        s.bi_buf >>= 8;\n        s.bi_valid -= 8;\n      }\n    }\n    function gen_bitlen(s, desc) {\n      var tree = desc.dyn_tree;\n      var max_code = desc.max_code;\n      var stree = desc.stat_desc.static_tree;\n      var has_stree = desc.stat_desc.has_stree;\n      var extra = desc.stat_desc.extra_bits;\n      var base = desc.stat_desc.extra_base;\n      var max_length = desc.stat_desc.max_length;\n      var h;\n      var n, m;\n      var bits;\n      var xbits;\n      var f;\n      var overflow = 0;\n      for (bits = 0; bits <= MAX_BITS; bits++) {\n        s.bl_count[bits] = 0;\n      }\n      tree[s.heap[s.heap_max] * 2 + 1] = 0;\n      for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {\n        n = s.heap[h];\n        bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;\n        if (bits > max_length) {\n          bits = max_length;\n          overflow++;\n        }\n        tree[n * 2 + 1] = bits;\n        if (n > max_code) {\n          continue;\n        }\n        s.bl_count[bits]++;\n        xbits = 0;\n        if (n >= base) {\n          xbits = extra[n - base];\n        }\n        f = tree[n * 2];\n        s.opt_len += f * (bits + xbits);\n        if (has_stree) {\n          s.static_len += f * (stree[n * 2 + 1] + xbits);\n        }\n      }\n      if (overflow === 0) {\n        return;\n      }\n      do {\n        bits = max_length - 1;\n        while (s.bl_count[bits] === 0) {\n          bits--;\n        }\n        s.bl_count[bits]--;\n        s.bl_count[bits + 1] += 2;\n        s.bl_count[max_length]--;\n        overflow -= 2;\n      } while (overflow > 0);\n      for (bits = max_length; bits !== 0; bits--) {\n        n = s.bl_count[bits];\n        while (n !== 0) {\n          m = s.heap[--h];\n          if (m > max_code) {\n            continue;\n          }\n          if (tree[m * 2 + 1] !== bits) {\n            s.opt_len += (bits - tree[m * 2 + 1]) * tree[m * 2];\n            tree[m * 2 + 1] = bits;\n          }\n          n--;\n        }\n      }\n    }\n    function gen_codes(tree, max_code, bl_count) {\n      var next_code = new Array(MAX_BITS + 1);\n      var code = 0;\n      var bits;\n      var n;\n      for (bits = 1; bits <= MAX_BITS; bits++) {\n        next_code[bits] = code = (code + bl_count[bits - 1]) << 1;\n      }\n      for (n = 0; n <= max_code; n++) {\n        var len = tree[n * 2 + 1];\n        if (len === 0) {\n          continue;\n        }\n        tree[n * 2] = bi_reverse(next_code[len]++, len);\n      }\n    }\n    function tr_static_init() {\n      var n;\n      var bits;\n      var length;\n      var code;\n      var dist;\n      var bl_count = new Array(MAX_BITS + 1);\n      length = 0;\n      for (code = 0; code < LENGTH_CODES - 1; code++) {\n        base_length[code] = length;\n        for (n = 0; n < 1 << extra_lbits[code]; n++) {\n          _length_code[length++] = code;\n        }\n      }\n      _length_code[length - 1] = code;\n      dist = 0;\n      for (code = 0; code < 16; code++) {\n        base_dist[code] = dist;\n        for (n = 0; n < 1 << extra_dbits[code]; n++) {\n          _dist_code[dist++] = code;\n        }\n      }\n      dist >>= 7;\n      for (; code < D_CODES; code++) {\n        base_dist[code] = dist << 7;\n        for (n = 0; n < 1 << (extra_dbits[code] - 7); n++) {\n          _dist_code[256 + dist++] = code;\n        }\n      }\n      for (bits = 0; bits <= MAX_BITS; bits++) {\n        bl_count[bits] = 0;\n      }\n      n = 0;\n      while (n <= 143) {\n        static_ltree[n * 2 + 1] = 8;\n        n++;\n        bl_count[8]++;\n      }\n      while (n <= 255) {\n        static_ltree[n * 2 + 1] = 9;\n        n++;\n        bl_count[9]++;\n      }\n      while (n <= 279) {\n        static_ltree[n * 2 + 1] = 7;\n        n++;\n        bl_count[7]++;\n      }\n      while (n <= 287) {\n        static_ltree[n * 2 + 1] = 8;\n        n++;\n        bl_count[8]++;\n      }\n      gen_codes(static_ltree, L_CODES + 1, bl_count);\n      for (n = 0; n < D_CODES; n++) {\n        static_dtree[n * 2 + 1] = 5;\n        static_dtree[n * 2] = bi_reverse(n, 5);\n      }\n      static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);\n      static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES, MAX_BITS);\n      static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES, MAX_BL_BITS);\n    }\n    function init_block(s) {\n      var n;\n      for (n = 0; n < L_CODES; n++) {\n        s.dyn_ltree[n * 2] = 0;\n      }\n      for (n = 0; n < D_CODES; n++) {\n        s.dyn_dtree[n * 2] = 0;\n      }\n      for (n = 0; n < BL_CODES; n++) {\n        s.bl_tree[n * 2] = 0;\n      }\n      s.dyn_ltree[END_BLOCK * 2] = 1;\n      s.opt_len = s.static_len = 0;\n      s.last_lit = s.matches = 0;\n    }\n    function bi_windup(s) {\n      if (s.bi_valid > 8) {\n        put_short(s, s.bi_buf);\n      } else if (s.bi_valid > 0) {\n        s.pending_buf[s.pending++] = s.bi_buf;\n      }\n      s.bi_buf = 0;\n      s.bi_valid = 0;\n    }\n    function copy_block(s, buf, len, header) {\n      bi_windup(s);\n      if (header) {\n        put_short(s, len);\n        put_short(s, ~len);\n      }\n      utils.arraySet(s.pending_buf, s.window, buf, len, s.pending);\n      s.pending += len;\n    }\n    function smaller(tree, n, m, depth) {\n      var _n2 = n * 2;\n      var _m2 = m * 2;\n      return tree[_n2] < tree[_m2] || (tree[_n2] === tree[_m2] && depth[n] <= depth[m]);\n    }\n    function pqdownheap(s, tree, k) {\n      var v = s.heap[k];\n      var j = k << 1;\n      while (j <= s.heap_len) {\n        if (j < s.heap_len && smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {\n          j++;\n        }\n        if (smaller(tree, v, s.heap[j], s.depth)) {\n          break;\n        }\n        s.heap[k] = s.heap[j];\n        k = j;\n        j <<= 1;\n      }\n      s.heap[k] = v;\n    }\n    function compress_block(s, ltree, dtree) {\n      var dist;\n      var lc;\n      var lx = 0;\n      var code;\n      var extra;\n      if (s.last_lit !== 0) {\n        do {\n          dist = (s.pending_buf[s.d_buf + lx * 2] << 8) | s.pending_buf[s.d_buf + lx * 2 + 1];\n          lc = s.pending_buf[s.l_buf + lx];\n          lx++;\n          if (dist === 0) {\n            send_code(s, lc, ltree);\n          } else {\n            code = _length_code[lc];\n            send_code(s, code + LITERALS + 1, ltree);\n            extra = extra_lbits[code];\n            if (extra !== 0) {\n              lc -= base_length[code];\n              send_bits(s, lc, extra);\n            }\n            dist--;\n            code = d_code(dist);\n            send_code(s, code, dtree);\n            extra = extra_dbits[code];\n            if (extra !== 0) {\n              dist -= base_dist[code];\n              send_bits(s, dist, extra);\n            }\n          }\n        } while (lx < s.last_lit);\n      }\n      send_code(s, END_BLOCK, ltree);\n    }\n    function build_tree(s, desc) {\n      var tree = desc.dyn_tree;\n      var stree = desc.stat_desc.static_tree;\n      var has_stree = desc.stat_desc.has_stree;\n      var elems = desc.stat_desc.elems;\n      var n, m;\n      var max_code = -1;\n      var node;\n      s.heap_len = 0;\n      s.heap_max = HEAP_SIZE;\n      for (n = 0; n < elems; n++) {\n        if (tree[n * 2] !== 0) {\n          s.heap[++s.heap_len] = max_code = n;\n          s.depth[n] = 0;\n        } else {\n          tree[n * 2 + 1] = 0;\n        }\n      }\n      while (s.heap_len < 2) {\n        node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;\n        tree[node * 2] = 1;\n        s.depth[node] = 0;\n        s.opt_len--;\n        if (has_stree) {\n          s.static_len -= stree[node * 2 + 1];\n        }\n      }\n      desc.max_code = max_code;\n      for (n = s.heap_len >> 1; n >= 1; n--) {\n        pqdownheap(s, tree, n);\n      }\n      node = elems;\n      do {\n        n = s.heap[1];\n        s.heap[1] = s.heap[s.heap_len--];\n        pqdownheap(s, tree, 1);\n        m = s.heap[1];\n        s.heap[--s.heap_max] = n;\n        s.heap[--s.heap_max] = m;\n        tree[node * 2] = tree[n * 2] + tree[m * 2];\n        s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;\n        tree[n * 2 + 1] = tree[m * 2 + 1] = node;\n        s.heap[1] = node++;\n        pqdownheap(s, tree, 1);\n      } while (s.heap_len >= 2);\n      s.heap[--s.heap_max] = s.heap[1];\n      gen_bitlen(s, desc);\n      gen_codes(tree, max_code, s.bl_count);\n    }\n    function scan_tree(s, tree, max_code) {\n      var n;\n      var prevlen = -1;\n      var curlen;\n      var nextlen = tree[0 * 2 + 1];\n      var count = 0;\n      var max_count = 7;\n      var min_count = 4;\n      if (nextlen === 0) {\n        max_count = 138;\n        min_count = 3;\n      }\n      tree[(max_code + 1) * 2 + 1] = 65535;\n      for (n = 0; n <= max_code; n++) {\n        curlen = nextlen;\n        nextlen = tree[(n + 1) * 2 + 1];\n        if (++count < max_count && curlen === nextlen) {\n          continue;\n        } else if (count < min_count) {\n          s.bl_tree[curlen * 2] += count;\n        } else if (curlen !== 0) {\n          if (curlen !== prevlen) {\n            s.bl_tree[curlen * 2]++;\n          }\n          s.bl_tree[REP_3_6 * 2]++;\n        } else if (count <= 10) {\n          s.bl_tree[REPZ_3_10 * 2]++;\n        } else {\n          s.bl_tree[REPZ_11_138 * 2]++;\n        }\n        count = 0;\n        prevlen = curlen;\n        if (nextlen === 0) {\n          max_count = 138;\n          min_count = 3;\n        } else if (curlen === nextlen) {\n          max_count = 6;\n          min_count = 3;\n        } else {\n          max_count = 7;\n          min_count = 4;\n        }\n      }\n    }\n    function send_tree(s, tree, max_code) {\n      var n;\n      var prevlen = -1;\n      var curlen;\n      var nextlen = tree[0 * 2 + 1];\n      var count = 0;\n      var max_count = 7;\n      var min_count = 4;\n      if (nextlen === 0) {\n        max_count = 138;\n        min_count = 3;\n      }\n      for (n = 0; n <= max_code; n++) {\n        curlen = nextlen;\n        nextlen = tree[(n + 1) * 2 + 1];\n        if (++count < max_count && curlen === nextlen) {\n          continue;\n        } else if (count < min_count) {\n          do {\n            send_code(s, curlen, s.bl_tree);\n          } while (--count !== 0);\n        } else if (curlen !== 0) {\n          if (curlen !== prevlen) {\n            send_code(s, curlen, s.bl_tree);\n            count--;\n          }\n          send_code(s, REP_3_6, s.bl_tree);\n          send_bits(s, count - 3, 2);\n        } else if (count <= 10) {\n          send_code(s, REPZ_3_10, s.bl_tree);\n          send_bits(s, count - 3, 3);\n        } else {\n          send_code(s, REPZ_11_138, s.bl_tree);\n          send_bits(s, count - 11, 7);\n        }\n        count = 0;\n        prevlen = curlen;\n        if (nextlen === 0) {\n          max_count = 138;\n          min_count = 3;\n        } else if (curlen === nextlen) {\n          max_count = 6;\n          min_count = 3;\n        } else {\n          max_count = 7;\n          min_count = 4;\n        }\n      }\n    }\n    function build_bl_tree(s) {\n      var max_blindex;\n      scan_tree(s, s.dyn_ltree, s.l_desc.max_code);\n      scan_tree(s, s.dyn_dtree, s.d_desc.max_code);\n      build_tree(s, s.bl_desc);\n      for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {\n        if (s.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0) {\n          break;\n        }\n      }\n      s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;\n      return max_blindex;\n    }\n    function send_all_trees(s, lcodes, dcodes, blcodes) {\n      var rank;\n      send_bits(s, lcodes - 257, 5);\n      send_bits(s, dcodes - 1, 5);\n      send_bits(s, blcodes - 4, 4);\n      for (rank = 0; rank < blcodes; rank++) {\n        send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1], 3);\n      }\n      send_tree(s, s.dyn_ltree, lcodes - 1);\n      send_tree(s, s.dyn_dtree, dcodes - 1);\n    }\n    function detect_data_type(s) {\n      var black_mask = 4093624447;\n      var n;\n      for (n = 0; n <= 31; n++, black_mask >>>= 1) {\n        if (black_mask & 1 && s.dyn_ltree[n * 2] !== 0) {\n          return Z_BINARY;\n        }\n      }\n      if (s.dyn_ltree[9 * 2] !== 0 || s.dyn_ltree[10 * 2] !== 0 || s.dyn_ltree[13 * 2] !== 0) {\n        return Z_TEXT;\n      }\n      for (n = 32; n < LITERALS; n++) {\n        if (s.dyn_ltree[n * 2] !== 0) {\n          return Z_TEXT;\n        }\n      }\n      return Z_BINARY;\n    }\n    var static_init_done = false;\n    function _tr_init(s) {\n      if (!static_init_done) {\n        tr_static_init();\n        static_init_done = true;\n      }\n      s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc);\n      s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc);\n      s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);\n      s.bi_buf = 0;\n      s.bi_valid = 0;\n      init_block(s);\n    }\n    function _tr_stored_block(s, buf, stored_len, last) {\n      send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);\n      copy_block(s, buf, stored_len, true);\n    }\n    function _tr_align(s) {\n      send_bits(s, STATIC_TREES << 1, 3);\n      send_code(s, END_BLOCK, static_ltree);\n      bi_flush(s);\n    }\n    function _tr_flush_block(s, buf, stored_len, last) {\n      var opt_lenb, static_lenb;\n      var max_blindex = 0;\n      if (s.level > 0) {\n        if (s.strm.data_type === Z_UNKNOWN) {\n          s.strm.data_type = detect_data_type(s);\n        }\n        build_tree(s, s.l_desc);\n        build_tree(s, s.d_desc);\n        max_blindex = build_bl_tree(s);\n        opt_lenb = (s.opt_len + 3 + 7) >>> 3;\n        static_lenb = (s.static_len + 3 + 7) >>> 3;\n        if (static_lenb <= opt_lenb) {\n          opt_lenb = static_lenb;\n        }\n      } else {\n        opt_lenb = static_lenb = stored_len + 5;\n      }\n      if (stored_len + 4 <= opt_lenb && buf !== -1) {\n        _tr_stored_block(s, buf, stored_len, last);\n      } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {\n        send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);\n        compress_block(s, static_ltree, static_dtree);\n      } else {\n        send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);\n        send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);\n        compress_block(s, s.dyn_ltree, s.dyn_dtree);\n      }\n      init_block(s);\n      if (last) {\n        bi_windup(s);\n      }\n    }\n    function _tr_tally(s, dist, lc) {\n      s.pending_buf[s.d_buf + s.last_lit * 2] = (dist >>> 8) & 255;\n      s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 255;\n      s.pending_buf[s.l_buf + s.last_lit] = lc & 255;\n      s.last_lit++;\n      if (dist === 0) {\n        s.dyn_ltree[lc * 2]++;\n      } else {\n        s.matches++;\n        dist--;\n        s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]++;\n        s.dyn_dtree[d_code(dist) * 2]++;\n      }\n      return s.last_lit === s.lit_bufsize - 1;\n    }\n    exports._tr_init = _tr_init;\n    exports._tr_stored_block = _tr_stored_block;\n    exports._tr_flush_block = _tr_flush_block;\n    exports._tr_tally = _tr_tally;\n    exports._tr_align = _tr_align;\n  },\n});\n\n// node_modules/pako/lib/zlib/adler32.js\nvar require_adler32 = __commonJS({\n  \"node_modules/pako/lib/zlib/adler32.js\"(exports, module2) {\n    \"use strict\";\n    function adler32(adler, buf, len, pos) {\n      var s1 = (adler & 65535) | 0,\n        s2 = ((adler >>> 16) & 65535) | 0,\n        n = 0;\n      while (len !== 0) {\n        n = len > 2e3 ? 2e3 : len;\n        len -= n;\n        do {\n          s1 = (s1 + buf[pos++]) | 0;\n          s2 = (s2 + s1) | 0;\n        } while (--n);\n        s1 %= 65521;\n        s2 %= 65521;\n      }\n      return s1 | (s2 << 16) | 0;\n    }\n    module2.exports = adler32;\n  },\n});\n\n// node_modules/pako/lib/zlib/crc32.js\nvar require_crc32 = __commonJS({\n  \"node_modules/pako/lib/zlib/crc32.js\"(exports, module2) {\n    \"use strict\";\n    function makeTable() {\n      var c,\n        table = [];\n      for (var n = 0; n < 256; n++) {\n        c = n;\n        for (var k = 0; k < 8; k++) {\n          c = c & 1 ? 3988292384 ^ (c >>> 1) : c >>> 1;\n        }\n        table[n] = c;\n      }\n      return table;\n    }\n    var crcTable = makeTable();\n    function crc32(crc, buf, len, pos) {\n      var t = crcTable,\n        end = pos + len;\n      crc ^= -1;\n      for (var i = pos; i < end; i++) {\n        crc = (crc >>> 8) ^ t[(crc ^ buf[i]) & 255];\n      }\n      return crc ^ -1;\n    }\n    module2.exports = crc32;\n  },\n});\n\n// node_modules/pako/lib/zlib/messages.js\nvar require_messages = __commonJS({\n  \"node_modules/pako/lib/zlib/messages.js\"(exports, module2) {\n    \"use strict\";\n    module2.exports = {\n      2: \"need dictionary\",\n      1: \"stream end\",\n      0: \"\",\n      \"-1\": \"file error\",\n      \"-2\": \"stream error\",\n      \"-3\": \"data error\",\n      \"-4\": \"insufficient memory\",\n      \"-5\": \"buffer error\",\n      \"-6\": \"incompatible version\",\n    };\n  },\n});\n\n// node_modules/pako/lib/zlib/deflate.js\nvar require_deflate = __commonJS({\n  \"node_modules/pako/lib/zlib/deflate.js\"(exports) {\n    \"use strict\";\n    var utils = require_common();\n    var trees = require_trees();\n    var adler32 = require_adler32();\n    var crc32 = require_crc32();\n    var msg = require_messages();\n    var Z_NO_FLUSH = 0;\n    var Z_PARTIAL_FLUSH = 1;\n    var Z_FULL_FLUSH = 3;\n    var Z_FINISH = 4;\n    var Z_BLOCK = 5;\n    var Z_OK = 0;\n    var Z_STREAM_END = 1;\n    var Z_STREAM_ERROR = -2;\n    var Z_DATA_ERROR = -3;\n    var Z_BUF_ERROR = -5;\n    var Z_DEFAULT_COMPRESSION = -1;\n    var Z_FILTERED = 1;\n    var Z_HUFFMAN_ONLY = 2;\n    var Z_RLE = 3;\n    var Z_FIXED = 4;\n    var Z_DEFAULT_STRATEGY = 0;\n    var Z_UNKNOWN = 2;\n    var Z_DEFLATED = 8;\n    var MAX_MEM_LEVEL = 9;\n    var MAX_WBITS = 15;\n    var DEF_MEM_LEVEL = 8;\n    var LENGTH_CODES = 29;\n    var LITERALS = 256;\n    var L_CODES = LITERALS + 1 + LENGTH_CODES;\n    var D_CODES = 30;\n    var BL_CODES = 19;\n    var HEAP_SIZE = 2 * L_CODES + 1;\n    var MAX_BITS = 15;\n    var MIN_MATCH = 3;\n    var MAX_MATCH = 258;\n    var MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;\n    var PRESET_DICT = 32;\n    var INIT_STATE = 42;\n    var EXTRA_STATE = 69;\n    var NAME_STATE = 73;\n    var COMMENT_STATE = 91;\n    var HCRC_STATE = 103;\n    var BUSY_STATE = 113;\n    var FINISH_STATE = 666;\n    var BS_NEED_MORE = 1;\n    var BS_BLOCK_DONE = 2;\n    var BS_FINISH_STARTED = 3;\n    var BS_FINISH_DONE = 4;\n    var OS_CODE = 3;\n    function err(strm, errorCode) {\n      strm.msg = msg[errorCode];\n      return errorCode;\n    }\n    function rank(f) {\n      return (f << 1) - (f > 4 ? 9 : 0);\n    }\n    function zero(buf) {\n      var len = buf.length;\n      while (--len >= 0) {\n        buf[len] = 0;\n      }\n    }\n    function flush_pending(strm) {\n      var s = strm.state;\n      var len = s.pending;\n      if (len > strm.avail_out) {\n        len = strm.avail_out;\n      }\n      if (len === 0) {\n        return;\n      }\n      utils.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);\n      strm.next_out += len;\n      s.pending_out += len;\n      strm.total_out += len;\n      strm.avail_out -= len;\n      s.pending -= len;\n      if (s.pending === 0) {\n        s.pending_out = 0;\n      }\n    }\n    function flush_block_only(s, last) {\n      trees._tr_flush_block(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last);\n      s.block_start = s.strstart;\n      flush_pending(s.strm);\n    }\n    function put_byte(s, b) {\n      s.pending_buf[s.pending++] = b;\n    }\n    function putShortMSB(s, b) {\n      s.pending_buf[s.pending++] = (b >>> 8) & 255;\n      s.pending_buf[s.pending++] = b & 255;\n    }\n    function read_buf(strm, buf, start, size) {\n      var len = strm.avail_in;\n      if (len > size) {\n        len = size;\n      }\n      if (len === 0) {\n        return 0;\n      }\n      strm.avail_in -= len;\n      utils.arraySet(buf, strm.input, strm.next_in, len, start);\n      if (strm.state.wrap === 1) {\n        strm.adler = adler32(strm.adler, buf, len, start);\n      } else if (strm.state.wrap === 2) {\n        strm.adler = crc32(strm.adler, buf, len, start);\n      }\n      strm.next_in += len;\n      strm.total_in += len;\n      return len;\n    }\n    function longest_match(s, cur_match) {\n      var chain_length = s.max_chain_length;\n      var scan = s.strstart;\n      var match;\n      var len;\n      var best_len = s.prev_length;\n      var nice_match = s.nice_match;\n      var limit = s.strstart > s.w_size - MIN_LOOKAHEAD ? s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0;\n      var _win = s.window;\n      var wmask = s.w_mask;\n      var prev = s.prev;\n      var strend = s.strstart + MAX_MATCH;\n      var scan_end1 = _win[scan + best_len - 1];\n      var scan_end = _win[scan + best_len];\n      if (s.prev_length >= s.good_match) {\n        chain_length >>= 2;\n      }\n      if (nice_match > s.lookahead) {\n        nice_match = s.lookahead;\n      }\n      do {\n        match = cur_match;\n        if (\n          _win[match + best_len] !== scan_end ||\n          _win[match + best_len - 1] !== scan_end1 ||\n          _win[match] !== _win[scan] ||\n          _win[++match] !== _win[scan + 1]\n        ) {\n          continue;\n        }\n        scan += 2;\n        match++;\n        do {} while (\n          _win[++scan] === _win[++match] &&\n          _win[++scan] === _win[++match] &&\n          _win[++scan] === _win[++match] &&\n          _win[++scan] === _win[++match] &&\n          _win[++scan] === _win[++match] &&\n          _win[++scan] === _win[++match] &&\n          _win[++scan] === _win[++match] &&\n          _win[++scan] === _win[++match] &&\n          scan < strend\n        );\n        len = MAX_MATCH - (strend - scan);\n        scan = strend - MAX_MATCH;\n        if (len > best_len) {\n          s.match_start = cur_match;\n          best_len = len;\n          if (len >= nice_match) {\n            break;\n          }\n          scan_end1 = _win[scan + best_len - 1];\n          scan_end = _win[scan + best_len];\n        }\n      } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);\n      if (best_len <= s.lookahead) {\n        return best_len;\n      }\n      return s.lookahead;\n    }\n    function fill_window(s) {\n      var _w_size = s.w_size;\n      var p, n, m, more, str;\n      do {\n        more = s.window_size - s.lookahead - s.strstart;\n        if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {\n          utils.arraySet(s.window, s.window, _w_size, _w_size, 0);\n          s.match_start -= _w_size;\n          s.strstart -= _w_size;\n          s.block_start -= _w_size;\n          n = s.hash_size;\n          p = n;\n          do {\n            m = s.head[--p];\n            s.head[p] = m >= _w_size ? m - _w_size : 0;\n          } while (--n);\n          n = _w_size;\n          p = n;\n          do {\n            m = s.prev[--p];\n            s.prev[p] = m >= _w_size ? m - _w_size : 0;\n          } while (--n);\n          more += _w_size;\n        }\n        if (s.strm.avail_in === 0) {\n          break;\n        }\n        n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);\n        s.lookahead += n;\n        if (s.lookahead + s.insert >= MIN_MATCH) {\n          str = s.strstart - s.insert;\n          s.ins_h = s.window[str];\n          s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + 1]) & s.hash_mask;\n          while (s.insert) {\n            s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;\n            s.prev[str & s.w_mask] = s.head[s.ins_h];\n            s.head[s.ins_h] = str;\n            str++;\n            s.insert--;\n            if (s.lookahead + s.insert < MIN_MATCH) {\n              break;\n            }\n          }\n        }\n      } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);\n    }\n    function deflate_stored(s, flush) {\n      var max_block_size = 65535;\n      if (max_block_size > s.pending_buf_size - 5) {\n        max_block_size = s.pending_buf_size - 5;\n      }\n      for (;;) {\n        if (s.lookahead <= 1) {\n          fill_window(s);\n          if (s.lookahead === 0 && flush === Z_NO_FLUSH) {\n            return BS_NEED_MORE;\n          }\n          if (s.lookahead === 0) {\n            break;\n          }\n        }\n        s.strstart += s.lookahead;\n        s.lookahead = 0;\n        var max_start = s.block_start + max_block_size;\n        if (s.strstart === 0 || s.strstart >= max_start) {\n          s.lookahead = s.strstart - max_start;\n          s.strstart = max_start;\n          flush_block_only(s, false);\n          if (s.strm.avail_out === 0) {\n            return BS_NEED_MORE;\n          }\n        }\n        if (s.strstart - s.block_start >= s.w_size - MIN_LOOKAHEAD) {\n          flush_block_only(s, false);\n          if (s.strm.avail_out === 0) {\n            return BS_NEED_MORE;\n          }\n        }\n      }\n      s.insert = 0;\n      if (flush === Z_FINISH) {\n        flush_block_only(s, true);\n        if (s.strm.avail_out === 0) {\n          return BS_FINISH_STARTED;\n        }\n        return BS_FINISH_DONE;\n      }\n      if (s.strstart > s.block_start) {\n        flush_block_only(s, false);\n        if (s.strm.avail_out === 0) {\n          return BS_NEED_MORE;\n        }\n      }\n      return BS_NEED_MORE;\n    }\n    function deflate_fast(s, flush) {\n      var hash_head;\n      var bflush;\n      for (;;) {\n        if (s.lookahead < MIN_LOOKAHEAD) {\n          fill_window(s);\n          if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {\n            return BS_NEED_MORE;\n          }\n          if (s.lookahead === 0) {\n            break;\n          }\n        }\n        hash_head = 0;\n        if (s.lookahead >= MIN_MATCH) {\n          s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\n          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n          s.head[s.ins_h] = s.strstart;\n        }\n        if (hash_head !== 0 && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {\n          s.match_length = longest_match(s, hash_head);\n        }\n        if (s.match_length >= MIN_MATCH) {\n          bflush = trees._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);\n          s.lookahead -= s.match_length;\n          if (s.match_length <= s.max_lazy_match && s.lookahead >= MIN_MATCH) {\n            s.match_length--;\n            do {\n              s.strstart++;\n              s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\n              hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n              s.head[s.ins_h] = s.strstart;\n            } while (--s.match_length !== 0);\n            s.strstart++;\n          } else {\n            s.strstart += s.match_length;\n            s.match_length = 0;\n            s.ins_h = s.window[s.strstart];\n            s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + 1]) & s.hash_mask;\n          }\n        } else {\n          bflush = trees._tr_tally(s, 0, s.window[s.strstart]);\n          s.lookahead--;\n          s.strstart++;\n        }\n        if (bflush) {\n          flush_block_only(s, false);\n          if (s.strm.avail_out === 0) {\n            return BS_NEED_MORE;\n          }\n        }\n      }\n      s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;\n      if (flush === Z_FINISH) {\n        flush_block_only(s, true);\n        if (s.strm.avail_out === 0) {\n          return BS_FINISH_STARTED;\n        }\n        return BS_FINISH_DONE;\n      }\n      if (s.last_lit) {\n        flush_block_only(s, false);\n        if (s.strm.avail_out === 0) {\n          return BS_NEED_MORE;\n        }\n      }\n      return BS_BLOCK_DONE;\n    }\n    function deflate_slow(s, flush) {\n      var hash_head;\n      var bflush;\n      var max_insert;\n      for (;;) {\n        if (s.lookahead < MIN_LOOKAHEAD) {\n          fill_window(s);\n          if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {\n            return BS_NEED_MORE;\n          }\n          if (s.lookahead === 0) {\n            break;\n          }\n        }\n        hash_head = 0;\n        if (s.lookahead >= MIN_MATCH) {\n          s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\n          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n          s.head[s.ins_h] = s.strstart;\n        }\n        s.prev_length = s.match_length;\n        s.prev_match = s.match_start;\n        s.match_length = MIN_MATCH - 1;\n        if (hash_head !== 0 && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {\n          s.match_length = longest_match(s, hash_head);\n          if (\n            s.match_length <= 5 &&\n            (s.strategy === Z_FILTERED || (s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096))\n          ) {\n            s.match_length = MIN_MATCH - 1;\n          }\n        }\n        if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {\n          max_insert = s.strstart + s.lookahead - MIN_MATCH;\n          bflush = trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);\n          s.lookahead -= s.prev_length - 1;\n          s.prev_length -= 2;\n          do {\n            if (++s.strstart <= max_insert) {\n              s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\n              hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n              s.head[s.ins_h] = s.strstart;\n            }\n          } while (--s.prev_length !== 0);\n          s.match_available = 0;\n          s.match_length = MIN_MATCH - 1;\n          s.strstart++;\n          if (bflush) {\n            flush_block_only(s, false);\n            if (s.strm.avail_out === 0) {\n              return BS_NEED_MORE;\n            }\n          }\n        } else if (s.match_available) {\n          bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);\n          if (bflush) {\n            flush_block_only(s, false);\n          }\n          s.strstart++;\n          s.lookahead--;\n          if (s.strm.avail_out === 0) {\n            return BS_NEED_MORE;\n          }\n        } else {\n          s.match_available = 1;\n          s.strstart++;\n          s.lookahead--;\n        }\n      }\n      if (s.match_available) {\n        bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);\n        s.match_available = 0;\n      }\n      s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;\n      if (flush === Z_FINISH) {\n        flush_block_only(s, true);\n        if (s.strm.avail_out === 0) {\n          return BS_FINISH_STARTED;\n        }\n        return BS_FINISH_DONE;\n      }\n      if (s.last_lit) {\n        flush_block_only(s, false);\n        if (s.strm.avail_out === 0) {\n          return BS_NEED_MORE;\n        }\n      }\n      return BS_BLOCK_DONE;\n    }\n    function deflate_rle(s, flush) {\n      var bflush;\n      var prev;\n      var scan, strend;\n      var _win = s.window;\n      for (;;) {\n        if (s.lookahead <= MAX_MATCH) {\n          fill_window(s);\n          if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {\n            return BS_NEED_MORE;\n          }\n          if (s.lookahead === 0) {\n            break;\n          }\n        }\n        s.match_length = 0;\n        if (s.lookahead >= MIN_MATCH && s.strstart > 0) {\n          scan = s.strstart - 1;\n          prev = _win[scan];\n          if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {\n            strend = s.strstart + MAX_MATCH;\n            do {} while (\n              prev === _win[++scan] &&\n              prev === _win[++scan] &&\n              prev === _win[++scan] &&\n              prev === _win[++scan] &&\n              prev === _win[++scan] &&\n              prev === _win[++scan] &&\n              prev === _win[++scan] &&\n              prev === _win[++scan] &&\n              scan < strend\n            );\n            s.match_length = MAX_MATCH - (strend - scan);\n            if (s.match_length > s.lookahead) {\n              s.match_length = s.lookahead;\n            }\n          }\n        }\n        if (s.match_length >= MIN_MATCH) {\n          bflush = trees._tr_tally(s, 1, s.match_length - MIN_MATCH);\n          s.lookahead -= s.match_length;\n          s.strstart += s.match_length;\n          s.match_length = 0;\n        } else {\n          bflush = trees._tr_tally(s, 0, s.window[s.strstart]);\n          s.lookahead--;\n          s.strstart++;\n        }\n        if (bflush) {\n          flush_block_only(s, false);\n          if (s.strm.avail_out === 0) {\n            return BS_NEED_MORE;\n          }\n        }\n      }\n      s.insert = 0;\n      if (flush === Z_FINISH) {\n        flush_block_only(s, true);\n        if (s.strm.avail_out === 0) {\n          return BS_FINISH_STARTED;\n        }\n        return BS_FINISH_DONE;\n      }\n      if (s.last_lit) {\n        flush_block_only(s, false);\n        if (s.strm.avail_out === 0) {\n          return BS_NEED_MORE;\n        }\n      }\n      return BS_BLOCK_DONE;\n    }\n    function deflate_huff(s, flush) {\n      var bflush;\n      for (;;) {\n        if (s.lookahead === 0) {\n          fill_window(s);\n          if (s.lookahead === 0) {\n            if (flush === Z_NO_FLUSH) {\n              return BS_NEED_MORE;\n            }\n            break;\n          }\n        }\n        s.match_length = 0;\n        bflush = trees._tr_tally(s, 0, s.window[s.strstart]);\n        s.lookahead--;\n        s.strstart++;\n        if (bflush) {\n          flush_block_only(s, false);\n          if (s.strm.avail_out === 0) {\n            return BS_NEED_MORE;\n          }\n        }\n      }\n      s.insert = 0;\n      if (flush === Z_FINISH) {\n        flush_block_only(s, true);\n        if (s.strm.avail_out === 0) {\n          return BS_FINISH_STARTED;\n        }\n        return BS_FINISH_DONE;\n      }\n      if (s.last_lit) {\n        flush_block_only(s, false);\n        if (s.strm.avail_out === 0) {\n          return BS_NEED_MORE;\n        }\n      }\n      return BS_BLOCK_DONE;\n    }\n    function Config(good_length, max_lazy, nice_length, max_chain, func) {\n      this.good_length = good_length;\n      this.max_lazy = max_lazy;\n      this.nice_length = nice_length;\n      this.max_chain = max_chain;\n      this.func = func;\n    }\n    var configuration_table;\n    configuration_table = [\n      new Config(0, 0, 0, 0, deflate_stored),\n      new Config(4, 4, 8, 4, deflate_fast),\n      new Config(4, 5, 16, 8, deflate_fast),\n      new Config(4, 6, 32, 32, deflate_fast),\n      new Config(4, 4, 16, 16, deflate_slow),\n      new Config(8, 16, 32, 32, deflate_slow),\n      new Config(8, 16, 128, 128, deflate_slow),\n      new Config(8, 32, 128, 256, deflate_slow),\n      new Config(32, 128, 258, 1024, deflate_slow),\n      new Config(32, 258, 258, 4096, deflate_slow),\n    ];\n    function lm_init(s) {\n      s.window_size = 2 * s.w_size;\n      zero(s.head);\n      s.max_lazy_match = configuration_table[s.level].max_lazy;\n      s.good_match = configuration_table[s.level].good_length;\n      s.nice_match = configuration_table[s.level].nice_length;\n      s.max_chain_length = configuration_table[s.level].max_chain;\n      s.strstart = 0;\n      s.block_start = 0;\n      s.lookahead = 0;\n      s.insert = 0;\n      s.match_length = s.prev_length = MIN_MATCH - 1;\n      s.match_available = 0;\n      s.ins_h = 0;\n    }\n    function DeflateState() {\n      this.strm = null;\n      this.status = 0;\n      this.pending_buf = null;\n      this.pending_buf_size = 0;\n      this.pending_out = 0;\n      this.pending = 0;\n      this.wrap = 0;\n      this.gzhead = null;\n      this.gzindex = 0;\n      this.method = Z_DEFLATED;\n      this.last_flush = -1;\n      this.w_size = 0;\n      this.w_bits = 0;\n      this.w_mask = 0;\n      this.window = null;\n      this.window_size = 0;\n      this.prev = null;\n      this.head = null;\n      this.ins_h = 0;\n      this.hash_size = 0;\n      this.hash_bits = 0;\n      this.hash_mask = 0;\n      this.hash_shift = 0;\n      this.block_start = 0;\n      this.match_length = 0;\n      this.prev_match = 0;\n      this.match_available = 0;\n      this.strstart = 0;\n      this.match_start = 0;\n      this.lookahead = 0;\n      this.prev_length = 0;\n      this.max_chain_length = 0;\n      this.max_lazy_match = 0;\n      this.level = 0;\n      this.strategy = 0;\n      this.good_match = 0;\n      this.nice_match = 0;\n      this.dyn_ltree = new utils.Buf16(HEAP_SIZE * 2);\n      this.dyn_dtree = new utils.Buf16((2 * D_CODES + 1) * 2);\n      this.bl_tree = new utils.Buf16((2 * BL_CODES + 1) * 2);\n      zero(this.dyn_ltree);\n      zero(this.dyn_dtree);\n      zero(this.bl_tree);\n      this.l_desc = null;\n      this.d_desc = null;\n      this.bl_desc = null;\n      this.bl_count = new utils.Buf16(MAX_BITS + 1);\n      this.heap = new utils.Buf16(2 * L_CODES + 1);\n      zero(this.heap);\n      this.heap_len = 0;\n      this.heap_max = 0;\n      this.depth = new utils.Buf16(2 * L_CODES + 1);\n      zero(this.depth);\n      this.l_buf = 0;\n      this.lit_bufsize = 0;\n      this.last_lit = 0;\n      this.d_buf = 0;\n      this.opt_len = 0;\n      this.static_len = 0;\n      this.matches = 0;\n      this.insert = 0;\n      this.bi_buf = 0;\n      this.bi_valid = 0;\n    }\n    function deflateResetKeep(strm) {\n      var s;\n      if (!strm || !strm.state) {\n        return err(strm, Z_STREAM_ERROR);\n      }\n      strm.total_in = strm.total_out = 0;\n      strm.data_type = Z_UNKNOWN;\n      s = strm.state;\n      s.pending = 0;\n      s.pending_out = 0;\n      if (s.wrap < 0) {\n        s.wrap = -s.wrap;\n      }\n      s.status = s.wrap ? INIT_STATE : BUSY_STATE;\n      strm.adler = s.wrap === 2 ? 0 : 1;\n      s.last_flush = Z_NO_FLUSH;\n      trees._tr_init(s);\n      return Z_OK;\n    }\n    function deflateReset(strm) {\n      var ret = deflateResetKeep(strm);\n      if (ret === Z_OK) {\n        lm_init(strm.state);\n      }\n      return ret;\n    }\n    function deflateSetHeader(strm, head) {\n      if (!strm || !strm.state) {\n        return Z_STREAM_ERROR;\n      }\n      if (strm.state.wrap !== 2) {\n        return Z_STREAM_ERROR;\n      }\n      strm.state.gzhead = head;\n      return Z_OK;\n    }\n    function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {\n      if (!strm) {\n        return Z_STREAM_ERROR;\n      }\n      var wrap = 1;\n      if (level === Z_DEFAULT_COMPRESSION) {\n        level = 6;\n      }\n      if (windowBits < 0) {\n        wrap = 0;\n        windowBits = -windowBits;\n      } else if (windowBits > 15) {\n        wrap = 2;\n        windowBits -= 16;\n      }\n      if (\n        memLevel < 1 ||\n        memLevel > MAX_MEM_LEVEL ||\n        method !== Z_DEFLATED ||\n        windowBits < 8 ||\n        windowBits > 15 ||\n        level < 0 ||\n        level > 9 ||\n        strategy < 0 ||\n        strategy > Z_FIXED\n      ) {\n        return err(strm, Z_STREAM_ERROR);\n      }\n      if (windowBits === 8) {\n        windowBits = 9;\n      }\n      var s = new DeflateState();\n      strm.state = s;\n      s.strm = strm;\n      s.wrap = wrap;\n      s.gzhead = null;\n      s.w_bits = windowBits;\n      s.w_size = 1 << s.w_bits;\n      s.w_mask = s.w_size - 1;\n      s.hash_bits = memLevel + 7;\n      s.hash_size = 1 << s.hash_bits;\n      s.hash_mask = s.hash_size - 1;\n      s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);\n      s.window = new utils.Buf8(s.w_size * 2);\n      s.head = new utils.Buf16(s.hash_size);\n      s.prev = new utils.Buf16(s.w_size);\n      s.lit_bufsize = 1 << (memLevel + 6);\n      s.pending_buf_size = s.lit_bufsize * 4;\n      s.pending_buf = new utils.Buf8(s.pending_buf_size);\n      s.d_buf = 1 * s.lit_bufsize;\n      s.l_buf = (1 + 2) * s.lit_bufsize;\n      s.level = level;\n      s.strategy = strategy;\n      s.method = method;\n      return deflateReset(strm);\n    }\n    function deflateInit(strm, level) {\n      return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);\n    }\n    function deflate(strm, flush) {\n      var old_flush, s;\n      var beg, val;\n      if (!strm || !strm.state || flush > Z_BLOCK || flush < 0) {\n        return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;\n      }\n      s = strm.state;\n      if (!strm.output || (!strm.input && strm.avail_in !== 0) || (s.status === FINISH_STATE && flush !== Z_FINISH)) {\n        return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR : Z_STREAM_ERROR);\n      }\n      s.strm = strm;\n      old_flush = s.last_flush;\n      s.last_flush = flush;\n      if (s.status === INIT_STATE) {\n        if (s.wrap === 2) {\n          strm.adler = 0;\n          put_byte(s, 31);\n          put_byte(s, 139);\n          put_byte(s, 8);\n          if (!s.gzhead) {\n            put_byte(s, 0);\n            put_byte(s, 0);\n            put_byte(s, 0);\n            put_byte(s, 0);\n            put_byte(s, 0);\n            put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);\n            put_byte(s, OS_CODE);\n            s.status = BUSY_STATE;\n          } else {\n            put_byte(\n              s,\n              (s.gzhead.text ? 1 : 0) +\n                (s.gzhead.hcrc ? 2 : 0) +\n                (!s.gzhead.extra ? 0 : 4) +\n                (!s.gzhead.name ? 0 : 8) +\n                (!s.gzhead.comment ? 0 : 16),\n            );\n            put_byte(s, s.gzhead.time & 255);\n            put_byte(s, (s.gzhead.time >> 8) & 255);\n            put_byte(s, (s.gzhead.time >> 16) & 255);\n            put_byte(s, (s.gzhead.time >> 24) & 255);\n            put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);\n            put_byte(s, s.gzhead.os & 255);\n            if (s.gzhead.extra && s.gzhead.extra.length) {\n              put_byte(s, s.gzhead.extra.length & 255);\n              put_byte(s, (s.gzhead.extra.length >> 8) & 255);\n            }\n            if (s.gzhead.hcrc) {\n              strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);\n            }\n            s.gzindex = 0;\n            s.status = EXTRA_STATE;\n          }\n        } else {\n          var header = (Z_DEFLATED + ((s.w_bits - 8) << 4)) << 8;\n          var level_flags = -1;\n          if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {\n            level_flags = 0;\n          } else if (s.level < 6) {\n            level_flags = 1;\n          } else if (s.level === 6) {\n            level_flags = 2;\n          } else {\n            level_flags = 3;\n          }\n          header |= level_flags << 6;\n          if (s.strstart !== 0) {\n            header |= PRESET_DICT;\n          }\n          header += 31 - (header % 31);\n          s.status = BUSY_STATE;\n          putShortMSB(s, header);\n          if (s.strstart !== 0) {\n            putShortMSB(s, strm.adler >>> 16);\n            putShortMSB(s, strm.adler & 65535);\n          }\n          strm.adler = 1;\n        }\n      }\n      if (s.status === EXTRA_STATE) {\n        if (s.gzhead.extra) {\n          beg = s.pending;\n          while (s.gzindex < (s.gzhead.extra.length & 65535)) {\n            if (s.pending === s.pending_buf_size) {\n              if (s.gzhead.hcrc && s.pending > beg) {\n                strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n              }\n              flush_pending(strm);\n              beg = s.pending;\n              if (s.pending === s.pending_buf_size) {\n                break;\n              }\n            }\n            put_byte(s, s.gzhead.extra[s.gzindex] & 255);\n            s.gzindex++;\n          }\n          if (s.gzhead.hcrc && s.pending > beg) {\n            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n          }\n          if (s.gzindex === s.gzhead.extra.length) {\n            s.gzindex = 0;\n            s.status = NAME_STATE;\n          }\n        } else {\n          s.status = NAME_STATE;\n        }\n      }\n      if (s.status === NAME_STATE) {\n        if (s.gzhead.name) {\n          beg = s.pending;\n          do {\n            if (s.pending === s.pending_buf_size) {\n              if (s.gzhead.hcrc && s.pending > beg) {\n                strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n              }\n              flush_pending(strm);\n              beg = s.pending;\n              if (s.pending === s.pending_buf_size) {\n                val = 1;\n                break;\n              }\n            }\n            if (s.gzindex < s.gzhead.name.length) {\n              val = s.gzhead.name.charCodeAt(s.gzindex++) & 255;\n            } else {\n              val = 0;\n            }\n            put_byte(s, val);\n          } while (val !== 0);\n          if (s.gzhead.hcrc && s.pending > beg) {\n            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n          }\n          if (val === 0) {\n            s.gzindex = 0;\n            s.status = COMMENT_STATE;\n          }\n        } else {\n          s.status = COMMENT_STATE;\n        }\n      }\n      if (s.status === COMMENT_STATE) {\n        if (s.gzhead.comment) {\n          beg = s.pending;\n          do {\n            if (s.pending === s.pending_buf_size) {\n              if (s.gzhead.hcrc && s.pending > beg) {\n                strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n              }\n              flush_pending(strm);\n              beg = s.pending;\n              if (s.pending === s.pending_buf_size) {\n                val = 1;\n                break;\n              }\n            }\n            if (s.gzindex < s.gzhead.comment.length) {\n              val = s.gzhead.comment.charCodeAt(s.gzindex++) & 255;\n            } else {\n              val = 0;\n            }\n            put_byte(s, val);\n          } while (val !== 0);\n          if (s.gzhead.hcrc && s.pending > beg) {\n            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n          }\n          if (val === 0) {\n            s.status = HCRC_STATE;\n          }\n        } else {\n          s.status = HCRC_STATE;\n        }\n      }\n      if (s.status === HCRC_STATE) {\n        if (s.gzhead.hcrc) {\n          if (s.pending + 2 > s.pending_buf_size) {\n            flush_pending(strm);\n          }\n          if (s.pending + 2 <= s.pending_buf_size) {\n            put_byte(s, strm.adler & 255);\n            put_byte(s, (strm.adler >> 8) & 255);\n            strm.adler = 0;\n            s.status = BUSY_STATE;\n          }\n        } else {\n          s.status = BUSY_STATE;\n        }\n      }\n      if (s.pending !== 0) {\n        flush_pending(strm);\n        if (strm.avail_out === 0) {\n          s.last_flush = -1;\n          return Z_OK;\n        }\n      } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH) {\n        return err(strm, Z_BUF_ERROR);\n      }\n      if (s.status === FINISH_STATE && strm.avail_in !== 0) {\n        return err(strm, Z_BUF_ERROR);\n      }\n      if (strm.avail_in !== 0 || s.lookahead !== 0 || (flush !== Z_NO_FLUSH && s.status !== FINISH_STATE)) {\n        var bstate =\n          s.strategy === Z_HUFFMAN_ONLY\n            ? deflate_huff(s, flush)\n            : s.strategy === Z_RLE\n            ? deflate_rle(s, flush)\n            : configuration_table[s.level].func(s, flush);\n        if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {\n          s.status = FINISH_STATE;\n        }\n        if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {\n          if (strm.avail_out === 0) {\n            s.last_flush = -1;\n          }\n          return Z_OK;\n        }\n        if (bstate === BS_BLOCK_DONE) {\n          if (flush === Z_PARTIAL_FLUSH) {\n            trees._tr_align(s);\n          } else if (flush !== Z_BLOCK) {\n            trees._tr_stored_block(s, 0, 0, false);\n            if (flush === Z_FULL_FLUSH) {\n              zero(s.head);\n              if (s.lookahead === 0) {\n                s.strstart = 0;\n                s.block_start = 0;\n                s.insert = 0;\n              }\n            }\n          }\n          flush_pending(strm);\n          if (strm.avail_out === 0) {\n            s.last_flush = -1;\n            return Z_OK;\n          }\n        }\n      }\n      if (flush !== Z_FINISH) {\n        return Z_OK;\n      }\n      if (s.wrap <= 0) {\n        return Z_STREAM_END;\n      }\n      if (s.wrap === 2) {\n        put_byte(s, strm.adler & 255);\n        put_byte(s, (strm.adler >> 8) & 255);\n        put_byte(s, (strm.adler >> 16) & 255);\n        put_byte(s, (strm.adler >> 24) & 255);\n        put_byte(s, strm.total_in & 255);\n        put_byte(s, (strm.total_in >> 8) & 255);\n        put_byte(s, (strm.total_in >> 16) & 255);\n        put_byte(s, (strm.total_in >> 24) & 255);\n      } else {\n        putShortMSB(s, strm.adler >>> 16);\n        putShortMSB(s, strm.adler & 65535);\n      }\n      flush_pending(strm);\n      if (s.wrap > 0) {\n        s.wrap = -s.wrap;\n      }\n      return s.pending !== 0 ? Z_OK : Z_STREAM_END;\n    }\n    function deflateEnd(strm) {\n      var status;\n      if (!strm || !strm.state) {\n        return Z_STREAM_ERROR;\n      }\n      status = strm.state.status;\n      if (\n        status !== INIT_STATE &&\n        status !== EXTRA_STATE &&\n        status !== NAME_STATE &&\n        status !== COMMENT_STATE &&\n        status !== HCRC_STATE &&\n        status !== BUSY_STATE &&\n        status !== FINISH_STATE\n      ) {\n        return err(strm, Z_STREAM_ERROR);\n      }\n      strm.state = null;\n      return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;\n    }\n    function deflateSetDictionary(strm, dictionary) {\n      var dictLength = dictionary.length;\n      var s;\n      var str, n;\n      var wrap;\n      var avail;\n      var next;\n      var input;\n      var tmpDict;\n      if (!strm || !strm.state) {\n        return Z_STREAM_ERROR;\n      }\n      s = strm.state;\n      wrap = s.wrap;\n      if (wrap === 2 || (wrap === 1 && s.status !== INIT_STATE) || s.lookahead) {\n        return Z_STREAM_ERROR;\n      }\n      if (wrap === 1) {\n        strm.adler = adler32(strm.adler, dictionary, dictLength, 0);\n      }\n      s.wrap = 0;\n      if (dictLength >= s.w_size) {\n        if (wrap === 0) {\n          zero(s.head);\n          s.strstart = 0;\n          s.block_start = 0;\n          s.insert = 0;\n        }\n        tmpDict = new utils.Buf8(s.w_size);\n        utils.arraySet(tmpDict, dictionary, dictLength - s.w_size, s.w_size, 0);\n        dictionary = tmpDict;\n        dictLength = s.w_size;\n      }\n      avail = strm.avail_in;\n      next = strm.next_in;\n      input = strm.input;\n      strm.avail_in = dictLength;\n      strm.next_in = 0;\n      strm.input = dictionary;\n      fill_window(s);\n      while (s.lookahead >= MIN_MATCH) {\n        str = s.strstart;\n        n = s.lookahead - (MIN_MATCH - 1);\n        do {\n          s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;\n          s.prev[str & s.w_mask] = s.head[s.ins_h];\n          s.head[s.ins_h] = str;\n          str++;\n        } while (--n);\n        s.strstart = str;\n        s.lookahead = MIN_MATCH - 1;\n        fill_window(s);\n      }\n      s.strstart += s.lookahead;\n      s.block_start = s.strstart;\n      s.insert = s.lookahead;\n      s.lookahead = 0;\n      s.match_length = s.prev_length = MIN_MATCH - 1;\n      s.match_available = 0;\n      strm.next_in = next;\n      strm.input = input;\n      strm.avail_in = avail;\n      s.wrap = wrap;\n      return Z_OK;\n    }\n    exports.deflateInit = deflateInit;\n    exports.deflateInit2 = deflateInit2;\n    exports.deflateReset = deflateReset;\n    exports.deflateResetKeep = deflateResetKeep;\n    exports.deflateSetHeader = deflateSetHeader;\n    exports.deflate = deflate;\n    exports.deflateEnd = deflateEnd;\n    exports.deflateSetDictionary = deflateSetDictionary;\n    exports.deflateInfo = \"pako deflate (from Nodeca project)\";\n  },\n});\n\n// node_modules/pako/lib/zlib/inffast.js\nvar require_inffast = __commonJS({\n  \"node_modules/pako/lib/zlib/inffast.js\"(exports, module2) {\n    \"use strict\";\n    var BAD = 30;\n    var TYPE = 12;\n    module2.exports = function inflate_fast(strm, start) {\n      var state;\n      var _in;\n      var last;\n      var _out;\n      var beg;\n      var end;\n      var dmax;\n      var wsize;\n      var whave;\n      var wnext;\n      var s_window;\n      var hold;\n      var bits;\n      var lcode;\n      var dcode;\n      var lmask;\n      var dmask;\n      var here;\n      var op;\n      var len;\n      var dist;\n      var from;\n      var from_source;\n      var input, output;\n      state = strm.state;\n      _in = strm.next_in;\n      input = strm.input;\n      last = _in + (strm.avail_in - 5);\n      _out = strm.next_out;\n      output = strm.output;\n      beg = _out - (start - strm.avail_out);\n      end = _out + (strm.avail_out - 257);\n      dmax = state.dmax;\n      wsize = state.wsize;\n      whave = state.whave;\n      wnext = state.wnext;\n      s_window = state.window;\n      hold = state.hold;\n      bits = state.bits;\n      lcode = state.lencode;\n      dcode = state.distcode;\n      lmask = (1 << state.lenbits) - 1;\n      dmask = (1 << state.distbits) - 1;\n      top: do {\n        if (bits < 15) {\n          hold += input[_in++] << bits;\n          bits += 8;\n          hold += input[_in++] << bits;\n          bits += 8;\n        }\n        here = lcode[hold & lmask];\n        dolen: for (;;) {\n          op = here >>> 24;\n          hold >>>= op;\n          bits -= op;\n          op = (here >>> 16) & 255;\n          if (op === 0) {\n            output[_out++] = here & 65535;\n          } else if (op & 16) {\n            len = here & 65535;\n            op &= 15;\n            if (op) {\n              if (bits < op) {\n                hold += input[_in++] << bits;\n                bits += 8;\n              }\n              len += hold & ((1 << op) - 1);\n              hold >>>= op;\n              bits -= op;\n            }\n            if (bits < 15) {\n              hold += input[_in++] << bits;\n              bits += 8;\n              hold += input[_in++] << bits;\n              bits += 8;\n            }\n            here = dcode[hold & dmask];\n            dodist: for (;;) {\n              op = here >>> 24;\n              hold >>>= op;\n              bits -= op;\n              op = (here >>> 16) & 255;\n              if (op & 16) {\n                dist = here & 65535;\n                op &= 15;\n                if (bits < op) {\n                  hold += input[_in++] << bits;\n                  bits += 8;\n                  if (bits < op) {\n                    hold += input[_in++] << bits;\n                    bits += 8;\n                  }\n                }\n                dist += hold & ((1 << op) - 1);\n                if (dist > dmax) {\n                  strm.msg = \"invalid distance too far back\";\n                  state.mode = BAD;\n                  break top;\n                }\n                hold >>>= op;\n                bits -= op;\n                op = _out - beg;\n                if (dist > op) {\n                  op = dist - op;\n                  if (op > whave) {\n                    if (state.sane) {\n                      strm.msg = \"invalid distance too far back\";\n                      state.mode = BAD;\n                      break top;\n                    }\n                  }\n                  from = 0;\n                  from_source = s_window;\n                  if (wnext === 0) {\n                    from += wsize - op;\n                    if (op < len) {\n                      len -= op;\n                      do {\n                        output[_out++] = s_window[from++];\n                      } while (--op);\n                      from = _out - dist;\n                      from_source = output;\n                    }\n                  } else if (wnext < op) {\n                    from += wsize + wnext - op;\n                    op -= wnext;\n                    if (op < len) {\n                      len -= op;\n                      do {\n                        output[_out++] = s_window[from++];\n                      } while (--op);\n                      from = 0;\n                      if (wnext < len) {\n                        op = wnext;\n                        len -= op;\n                        do {\n                          output[_out++] = s_window[from++];\n                        } while (--op);\n                        from = _out - dist;\n                        from_source = output;\n                      }\n                    }\n                  } else {\n                    from += wnext - op;\n                    if (op < len) {\n                      len -= op;\n                      do {\n                        output[_out++] = s_window[from++];\n                      } while (--op);\n                      from = _out - dist;\n                      from_source = output;\n                    }\n                  }\n                  while (len > 2) {\n                    output[_out++] = from_source[from++];\n                    output[_out++] = from_source[from++];\n                    output[_out++] = from_source[from++];\n                    len -= 3;\n                  }\n                  if (len) {\n                    output[_out++] = from_source[from++];\n                    if (len > 1) {\n                      output[_out++] = from_source[from++];\n                    }\n                  }\n                } else {\n                  from = _out - dist;\n                  do {\n                    output[_out++] = output[from++];\n                    output[_out++] = output[from++];\n                    output[_out++] = output[from++];\n                    len -= 3;\n                  } while (len > 2);\n                  if (len) {\n                    output[_out++] = output[from++];\n                    if (len > 1) {\n                      output[_out++] = output[from++];\n                    }\n                  }\n                }\n              } else if ((op & 64) === 0) {\n                here = dcode[(here & 65535) + (hold & ((1 << op) - 1))];\n                continue dodist;\n              } else {\n                strm.msg = \"invalid distance code\";\n                state.mode = BAD;\n                break top;\n              }\n              break;\n            }\n          } else if ((op & 64) === 0) {\n            here = lcode[(here & 65535) + (hold & ((1 << op) - 1))];\n            continue dolen;\n          } else if (op & 32) {\n            state.mode = TYPE;\n            break top;\n          } else {\n            strm.msg = \"invalid literal/length code\";\n            state.mode = BAD;\n            break top;\n          }\n          break;\n        }\n      } while (_in < last && _out < end);\n      len = bits >> 3;\n      _in -= len;\n      bits -= len << 3;\n      hold &= (1 << bits) - 1;\n      strm.next_in = _in;\n      strm.next_out = _out;\n      strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last);\n      strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);\n      state.hold = hold;\n      state.bits = bits;\n      return;\n    };\n  },\n});\n\n// node_modules/pako/lib/zlib/inftrees.js\nvar require_inftrees = __commonJS({\n  \"node_modules/pako/lib/zlib/inftrees.js\"(exports, module2) {\n    \"use strict\";\n    var utils = require_common();\n    var MAXBITS = 15;\n    var ENOUGH_LENS = 852;\n    var ENOUGH_DISTS = 592;\n    var CODES = 0;\n    var LENS = 1;\n    var DISTS = 2;\n    var lbase = [\n      3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258,\n      0, 0,\n    ];\n    var lext = [\n      16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21,\n      16, 72, 78,\n    ];\n    var dbase = [\n      1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,\n      8193, 12289, 16385, 24577, 0, 0,\n    ];\n    var dext = [\n      16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28,\n      29, 29, 64, 64,\n    ];\n    module2.exports = function inflate_table(type, lens, lens_index, codes, table, table_index, work, opts) {\n      var bits = opts.bits;\n      var len = 0;\n      var sym = 0;\n      var min = 0,\n        max = 0;\n      var root = 0;\n      var curr = 0;\n      var drop = 0;\n      var left = 0;\n      var used = 0;\n      var huff = 0;\n      var incr;\n      var fill;\n      var low;\n      var mask;\n      var next;\n      var base = null;\n      var base_index = 0;\n      var end;\n      var count = new utils.Buf16(MAXBITS + 1);\n      var offs = new utils.Buf16(MAXBITS + 1);\n      var extra = null;\n      var extra_index = 0;\n      var here_bits, here_op, here_val;\n      for (len = 0; len <= MAXBITS; len++) {\n        count[len] = 0;\n      }\n      for (sym = 0; sym < codes; sym++) {\n        count[lens[lens_index + sym]]++;\n      }\n      root = bits;\n      for (max = MAXBITS; max >= 1; max--) {\n        if (count[max] !== 0) {\n          break;\n        }\n      }\n      if (root > max) {\n        root = max;\n      }\n      if (max === 0) {\n        table[table_index++] = (1 << 24) | (64 << 16) | 0;\n        table[table_index++] = (1 << 24) | (64 << 16) | 0;\n        opts.bits = 1;\n        return 0;\n      }\n      for (min = 1; min < max; min++) {\n        if (count[min] !== 0) {\n          break;\n        }\n      }\n      if (root < min) {\n        root = min;\n      }\n      left = 1;\n      for (len = 1; len <= MAXBITS; len++) {\n        left <<= 1;\n        left -= count[len];\n        if (left < 0) {\n          return -1;\n        }\n      }\n      if (left > 0 && (type === CODES || max !== 1)) {\n        return -1;\n      }\n      offs[1] = 0;\n      for (len = 1; len < MAXBITS; len++) {\n        offs[len + 1] = offs[len] + count[len];\n      }\n      for (sym = 0; sym < codes; sym++) {\n        if (lens[lens_index + sym] !== 0) {\n          work[offs[lens[lens_index + sym]]++] = sym;\n        }\n      }\n      if (type === CODES) {\n        base = extra = work;\n        end = 19;\n      } else if (type === LENS) {\n        base = lbase;\n        base_index -= 257;\n        extra = lext;\n        extra_index -= 257;\n        end = 256;\n      } else {\n        base = dbase;\n        extra = dext;\n        end = -1;\n      }\n      huff = 0;\n      sym = 0;\n      len = min;\n      next = table_index;\n      curr = root;\n      drop = 0;\n      low = -1;\n      used = 1 << root;\n      mask = used - 1;\n      if ((type === LENS && used > ENOUGH_LENS) || (type === DISTS && used > ENOUGH_DISTS)) {\n        return 1;\n      }\n      for (;;) {\n        here_bits = len - drop;\n        if (work[sym] < end) {\n          here_op = 0;\n          here_val = work[sym];\n        } else if (work[sym] > end) {\n          here_op = extra[extra_index + work[sym]];\n          here_val = base[base_index + work[sym]];\n        } else {\n          here_op = 32 + 64;\n          here_val = 0;\n        }\n        incr = 1 << (len - drop);\n        fill = 1 << curr;\n        min = fill;\n        do {\n          fill -= incr;\n          table[next + (huff >> drop) + fill] = (here_bits << 24) | (here_op << 16) | here_val | 0;\n        } while (fill !== 0);\n        incr = 1 << (len - 1);\n        while (huff & incr) {\n          incr >>= 1;\n        }\n        if (incr !== 0) {\n          huff &= incr - 1;\n          huff += incr;\n        } else {\n          huff = 0;\n        }\n        sym++;\n        if (--count[len] === 0) {\n          if (len === max) {\n            break;\n          }\n          len = lens[lens_index + work[sym]];\n        }\n        if (len > root && (huff & mask) !== low) {\n          if (drop === 0) {\n            drop = root;\n          }\n          next += min;\n          curr = len - drop;\n          left = 1 << curr;\n          while (curr + drop < max) {\n            left -= count[curr + drop];\n            if (left <= 0) {\n              break;\n            }\n            curr++;\n            left <<= 1;\n          }\n          used += 1 << curr;\n          if ((type === LENS && used > ENOUGH_LENS) || (type === DISTS && used > ENOUGH_DISTS)) {\n            return 1;\n          }\n          low = huff & mask;\n          table[low] = (root << 24) | (curr << 16) | (next - table_index) | 0;\n        }\n      }\n      if (huff !== 0) {\n        table[next + huff] = ((len - drop) << 24) | (64 << 16) | 0;\n      }\n      opts.bits = root;\n      return 0;\n    };\n  },\n});\n\n// node_modules/pako/lib/zlib/inflate.js\nvar require_inflate = __commonJS({\n  \"node_modules/pako/lib/zlib/inflate.js\"(exports) {\n    \"use strict\";\n    var utils = require_common();\n    var adler32 = require_adler32();\n    var crc32 = require_crc32();\n    var inflate_fast = require_inffast();\n    var inflate_table = require_inftrees();\n    var CODES = 0;\n    var LENS = 1;\n    var DISTS = 2;\n    var Z_FINISH = 4;\n    var Z_BLOCK = 5;\n    var Z_TREES = 6;\n    var Z_OK = 0;\n    var Z_STREAM_END = 1;\n    var Z_NEED_DICT = 2;\n    var Z_STREAM_ERROR = -2;\n    var Z_DATA_ERROR = -3;\n    var Z_MEM_ERROR = -4;\n    var Z_BUF_ERROR = -5;\n    var Z_DEFLATED = 8;\n    var HEAD = 1;\n    var FLAGS = 2;\n    var TIME = 3;\n    var OS = 4;\n    var EXLEN = 5;\n    var EXTRA = 6;\n    var NAME = 7;\n    var COMMENT = 8;\n    var HCRC = 9;\n    var DICTID = 10;\n    var DICT = 11;\n    var TYPE = 12;\n    var TYPEDO = 13;\n    var STORED = 14;\n    var COPY_ = 15;\n    var COPY = 16;\n    var TABLE = 17;\n    var LENLENS = 18;\n    var CODELENS = 19;\n    var LEN_ = 20;\n    var LEN = 21;\n    var LENEXT = 22;\n    var DIST = 23;\n    var DISTEXT = 24;\n    var MATCH = 25;\n    var LIT = 26;\n    var CHECK = 27;\n    var LENGTH = 28;\n    var DONE = 29;\n    var BAD = 30;\n    var MEM = 31;\n    var SYNC = 32;\n    var ENOUGH_LENS = 852;\n    var ENOUGH_DISTS = 592;\n    var MAX_WBITS = 15;\n    var DEF_WBITS = MAX_WBITS;\n    function zswap32(q) {\n      return ((q >>> 24) & 255) + ((q >>> 8) & 65280) + ((q & 65280) << 8) + ((q & 255) << 24);\n    }\n    function InflateState() {\n      this.mode = 0;\n      this.last = false;\n      this.wrap = 0;\n      this.havedict = false;\n      this.flags = 0;\n      this.dmax = 0;\n      this.check = 0;\n      this.total = 0;\n      this.head = null;\n      this.wbits = 0;\n      this.wsize = 0;\n      this.whave = 0;\n      this.wnext = 0;\n      this.window = null;\n      this.hold = 0;\n      this.bits = 0;\n      this.length = 0;\n      this.offset = 0;\n      this.extra = 0;\n      this.lencode = null;\n      this.distcode = null;\n      this.lenbits = 0;\n      this.distbits = 0;\n      this.ncode = 0;\n      this.nlen = 0;\n      this.ndist = 0;\n      this.have = 0;\n      this.next = null;\n      this.lens = new utils.Buf16(320);\n      this.work = new utils.Buf16(288);\n      this.lendyn = null;\n      this.distdyn = null;\n      this.sane = 0;\n      this.back = 0;\n      this.was = 0;\n    }\n    function inflateResetKeep(strm) {\n      var state;\n      if (!strm || !strm.state) {\n        return Z_STREAM_ERROR;\n      }\n      state = strm.state;\n      strm.total_in = strm.total_out = state.total = 0;\n      strm.msg = \"\";\n      if (state.wrap) {\n        strm.adler = state.wrap & 1;\n      }\n      state.mode = HEAD;\n      state.last = 0;\n      state.havedict = 0;\n      state.dmax = 32768;\n      state.head = null;\n      state.hold = 0;\n      state.bits = 0;\n      state.lencode = state.lendyn = new utils.Buf32(ENOUGH_LENS);\n      state.distcode = state.distdyn = new utils.Buf32(ENOUGH_DISTS);\n      state.sane = 1;\n      state.back = -1;\n      return Z_OK;\n    }\n    function inflateReset(strm) {\n      var state;\n      if (!strm || !strm.state) {\n        return Z_STREAM_ERROR;\n      }\n      state = strm.state;\n      state.wsize = 0;\n      state.whave = 0;\n      state.wnext = 0;\n      return inflateResetKeep(strm);\n    }\n    function inflateReset2(strm, windowBits) {\n      var wrap;\n      var state;\n      if (!strm || !strm.state) {\n        return Z_STREAM_ERROR;\n      }\n      state = strm.state;\n      if (windowBits < 0) {\n        wrap = 0;\n        windowBits = -windowBits;\n      } else {\n        wrap = (windowBits >> 4) + 1;\n        if (windowBits < 48) {\n          windowBits &= 15;\n        }\n      }\n      if (windowBits && (windowBits < 8 || windowBits > 15)) {\n        return Z_STREAM_ERROR;\n      }\n      if (state.window !== null && state.wbits !== windowBits) {\n        state.window = null;\n      }\n      state.wrap = wrap;\n      state.wbits = windowBits;\n      return inflateReset(strm);\n    }\n    function inflateInit2(strm, windowBits) {\n      var ret;\n      var state;\n      if (!strm) {\n        return Z_STREAM_ERROR;\n      }\n      state = new InflateState();\n      strm.state = state;\n      state.window = null;\n      ret = inflateReset2(strm, windowBits);\n      if (ret !== Z_OK) {\n        strm.state = null;\n      }\n      return ret;\n    }\n    function inflateInit(strm) {\n      return inflateInit2(strm, DEF_WBITS);\n    }\n    var virgin = true;\n    var lenfix;\n    var distfix;\n    function fixedtables(state) {\n      if (virgin) {\n        var sym;\n        lenfix = new utils.Buf32(512);\n        distfix = new utils.Buf32(32);\n        sym = 0;\n        while (sym < 144) {\n          state.lens[sym++] = 8;\n        }\n        while (sym < 256) {\n          state.lens[sym++] = 9;\n        }\n        while (sym < 280) {\n          state.lens[sym++] = 7;\n        }\n        while (sym < 288) {\n          state.lens[sym++] = 8;\n        }\n        inflate_table(LENS, state.lens, 0, 288, lenfix, 0, state.work, {\n          bits: 9,\n        });\n        sym = 0;\n        while (sym < 32) {\n          state.lens[sym++] = 5;\n        }\n        inflate_table(DISTS, state.lens, 0, 32, distfix, 0, state.work, {\n          bits: 5,\n        });\n        virgin = false;\n      }\n      state.lencode = lenfix;\n      state.lenbits = 9;\n      state.distcode = distfix;\n      state.distbits = 5;\n    }\n    function updatewindow(strm, src, end, copy) {\n      var dist;\n      var state = strm.state;\n      if (state.window === null) {\n        state.wsize = 1 << state.wbits;\n        state.wnext = 0;\n        state.whave = 0;\n        state.window = new utils.Buf8(state.wsize);\n      }\n      if (copy >= state.wsize) {\n        utils.arraySet(state.window, src, end - state.wsize, state.wsize, 0);\n        state.wnext = 0;\n        state.whave = state.wsize;\n      } else {\n        dist = state.wsize - state.wnext;\n        if (dist > copy) {\n          dist = copy;\n        }\n        utils.arraySet(state.window, src, end - copy, dist, state.wnext);\n        copy -= dist;\n        if (copy) {\n          utils.arraySet(state.window, src, end - copy, copy, 0);\n          state.wnext = copy;\n          state.whave = state.wsize;\n        } else {\n          state.wnext += dist;\n          if (state.wnext === state.wsize) {\n            state.wnext = 0;\n          }\n          if (state.whave < state.wsize) {\n            state.whave += dist;\n          }\n        }\n      }\n      return 0;\n    }\n    function inflate(strm, flush) {\n      var state;\n      var input, output;\n      var next;\n      var put;\n      var have, left;\n      var hold;\n      var bits;\n      var _in, _out;\n      var copy;\n      var from;\n      var from_source;\n      var here = 0;\n      var here_bits, here_op, here_val;\n      var last_bits, last_op, last_val;\n      var len;\n      var ret;\n      var hbuf = new utils.Buf8(4);\n      var opts;\n      var n;\n      var order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];\n      if (!strm || !strm.state || !strm.output || (!strm.input && strm.avail_in !== 0)) {\n        return Z_STREAM_ERROR;\n      }\n      state = strm.state;\n      if (state.mode === TYPE) {\n        state.mode = TYPEDO;\n      }\n      put = strm.next_out;\n      output = strm.output;\n      left = strm.avail_out;\n      next = strm.next_in;\n      input = strm.input;\n      have = strm.avail_in;\n      hold = state.hold;\n      bits = state.bits;\n      _in = have;\n      _out = left;\n      ret = Z_OK;\n      inf_leave: for (;;) {\n        switch (state.mode) {\n          case HEAD:\n            if (state.wrap === 0) {\n              state.mode = TYPEDO;\n              break;\n            }\n            while (bits < 16) {\n              if (have === 0) {\n                break inf_leave;\n              }\n              have--;\n              hold += input[next++] << bits;\n              bits += 8;\n            }\n            if (state.wrap & 2 && hold === 35615) {\n              state.check = 0;\n              hbuf[0] = hold & 255;\n              hbuf[1] = (hold >>> 8) & 255;\n              state.check = crc32(state.check, hbuf, 2, 0);\n              hold = 0;\n              bits = 0;\n              state.mode = FLAGS;\n              break;\n            }\n            state.flags = 0;\n            if (state.head) {\n              state.head.done = false;\n            }\n            if (!(state.wrap & 1) || (((hold & 255) << 8) + (hold >> 8)) % 31) {\n              strm.msg = \"incorrect header check\";\n              state.mode = BAD;\n              break;\n            }\n            if ((hold & 15) !== Z_DEFLATED) {\n              strm.msg = \"unknown compression method\";\n              state.mode = BAD;\n              break;\n            }\n            hold >>>= 4;\n            bits -= 4;\n            len = (hold & 15) + 8;\n            if (state.wbits === 0) {\n              state.wbits = len;\n            } else if (len > state.wbits) {\n              strm.msg = \"invalid window size\";\n              state.mode = BAD;\n              break;\n            }\n            state.dmax = 1 << len;\n            strm.adler = state.check = 1;\n            state.mode = hold & 512 ? DICTID : TYPE;\n            hold = 0;\n            bits = 0;\n            break;\n          case FLAGS:\n            while (bits < 16) {\n              if (have === 0) {\n                break inf_leave;\n              }\n              have--;\n              hold += input[next++] << bits;\n              bits += 8;\n            }\n            state.flags = hold;\n            if ((state.flags & 255) !== Z_DEFLATED) {\n              strm.msg = \"unknown compression method\";\n              state.mode = BAD;\n              break;\n            }\n            if (state.flags & 57344) {\n              strm.msg = \"unknown header flags set\";\n              state.mode = BAD;\n              break;\n            }\n            if (state.head) {\n              state.head.text = (hold >> 8) & 1;\n            }\n            if (state.flags & 512) {\n              hbuf[0] = hold & 255;\n              hbuf[1] = (hold >>> 8) & 255;\n              state.check = crc32(state.check, hbuf, 2, 0);\n            }\n            hold = 0;\n            bits = 0;\n            state.mode = TIME;\n          case TIME:\n            while (bits < 32) {\n              if (have === 0) {\n                break inf_leave;\n              }\n              have--;\n              hold += input[next++] << bits;\n              bits += 8;\n            }\n            if (state.head) {\n              state.head.time = hold;\n            }\n            if (state.flags & 512) {\n              hbuf[0] = hold & 255;\n              hbuf[1] = (hold >>> 8) & 255;\n              hbuf[2] = (hold >>> 16) & 255;\n              hbuf[3] = (hold >>> 24) & 255;\n              state.check = crc32(state.check, hbuf, 4, 0);\n            }\n            hold = 0;\n            bits = 0;\n            state.mode = OS;\n          case OS:\n            while (bits < 16) {\n              if (have === 0) {\n                break inf_leave;\n              }\n              have--;\n              hold += input[next++] << bits;\n              bits += 8;\n            }\n            if (state.head) {\n              state.head.xflags = hold & 255;\n              state.head.os = hold >> 8;\n            }\n            if (state.flags & 512) {\n              hbuf[0] = hold & 255;\n              hbuf[1] = (hold >>> 8) & 255;\n              state.check = crc32(state.check, hbuf, 2, 0);\n            }\n            hold = 0;\n            bits = 0;\n            state.mode = EXLEN;\n          case EXLEN:\n            if (state.flags & 1024) {\n              while (bits < 16) {\n                if (have === 0) {\n                  break inf_leave;\n                }\n                have--;\n                hold += input[next++] << bits;\n                bits += 8;\n              }\n              state.length = hold;\n              if (state.head) {\n                state.head.extra_len = hold;\n              }\n              if (state.flags & 512) {\n                hbuf[0] = hold & 255;\n                hbuf[1] = (hold >>> 8) & 255;\n                state.check = crc32(state.check, hbuf, 2, 0);\n              }\n              hold = 0;\n              bits = 0;\n            } else if (state.head) {\n              state.head.extra = null;\n            }\n            state.mode = EXTRA;\n          case EXTRA:\n            if (state.flags & 1024) {\n              copy = state.length;\n              if (copy > have) {\n                copy = have;\n              }\n              if (copy) {\n                if (state.head) {\n                  len = state.head.extra_len - state.length;\n                  if (!state.head.extra) {\n                    state.head.extra = new Array(state.head.extra_len);\n                  }\n                  utils.arraySet(state.head.extra, input, next, copy, len);\n                }\n                if (state.flags & 512) {\n                  state.check = crc32(state.check, input, copy, next);\n                }\n                have -= copy;\n                next += copy;\n                state.length -= copy;\n              }\n              if (state.length) {\n                break inf_leave;\n              }\n            }\n            state.length = 0;\n            state.mode = NAME;\n          case NAME:\n            if (state.flags & 2048) {\n              if (have === 0) {\n                break inf_leave;\n              }\n              copy = 0;\n              do {\n                len = input[next + copy++];\n                if (state.head && len && state.length < 65536) {\n                  state.head.name += String.fromCharCode(len);\n                }\n              } while (len && copy < have);\n              if (state.flags & 512) {\n                state.check = crc32(state.check, input, copy, next);\n              }\n              have -= copy;\n              next += copy;\n              if (len) {\n                break inf_leave;\n              }\n            } else if (state.head) {\n              state.head.name = null;\n            }\n            state.length = 0;\n            state.mode = COMMENT;\n          case COMMENT:\n            if (state.flags & 4096) {\n              if (have === 0) {\n                break inf_leave;\n              }\n              copy = 0;\n              do {\n                len = input[next + copy++];\n                if (state.head && len && state.length < 65536) {\n                  state.head.comment += String.fromCharCode(len);\n                }\n              } while (len && copy < have);\n              if (state.flags & 512) {\n                state.check = crc32(state.check, input, copy, next);\n              }\n              have -= copy;\n              next += copy;\n              if (len) {\n                break inf_leave;\n              }\n            } else if (state.head) {\n              state.head.comment = null;\n            }\n            state.mode = HCRC;\n          case HCRC:\n            if (state.flags & 512) {\n              while (bits < 16) {\n                if (have === 0) {\n                  break inf_leave;\n                }\n                have--;\n                hold += input[next++] << bits;\n                bits += 8;\n              }\n              if (hold !== (state.check & 65535)) {\n                strm.msg = \"header crc mismatch\";\n                state.mode = BAD;\n                break;\n              }\n              hold = 0;\n              bits = 0;\n            }\n            if (state.head) {\n              state.head.hcrc = (state.flags >> 9) & 1;\n              state.head.done = true;\n            }\n            strm.adler = state.check = 0;\n            state.mode = TYPE;\n            break;\n          case DICTID:\n            while (bits < 32) {\n              if (have === 0) {\n                break inf_leave;\n              }\n              have--;\n              hold += input[next++] << bits;\n              bits += 8;\n            }\n            strm.adler = state.check = zswap32(hold);\n            hold = 0;\n            bits = 0;\n            state.mode = DICT;\n          case DICT:\n            if (state.havedict === 0) {\n              strm.next_out = put;\n              strm.avail_out = left;\n              strm.next_in = next;\n              strm.avail_in = have;\n              state.hold = hold;\n              state.bits = bits;\n              return Z_NEED_DICT;\n            }\n            strm.adler = state.check = 1;\n            state.mode = TYPE;\n          case TYPE:\n            if (flush === Z_BLOCK || flush === Z_TREES) {\n              break inf_leave;\n            }\n          case TYPEDO:\n            if (state.last) {\n              hold >>>= bits & 7;\n              bits -= bits & 7;\n              state.mode = CHECK;\n              break;\n            }\n            while (bits < 3) {\n              if (have === 0) {\n                break inf_leave;\n              }\n              have--;\n              hold += input[next++] << bits;\n              bits += 8;\n            }\n            state.last = hold & 1;\n            hold >>>= 1;\n            bits -= 1;\n            switch (hold & 3) {\n              case 0:\n                state.mode = STORED;\n                break;\n              case 1:\n                fixedtables(state);\n                state.mode = LEN_;\n                if (flush === Z_TREES) {\n                  hold >>>= 2;\n                  bits -= 2;\n                  break inf_leave;\n                }\n                break;\n              case 2:\n                state.mode = TABLE;\n                break;\n              case 3:\n                strm.msg = \"invalid block type\";\n                state.mode = BAD;\n            }\n            hold >>>= 2;\n            bits -= 2;\n            break;\n          case STORED:\n            hold >>>= bits & 7;\n            bits -= bits & 7;\n            while (bits < 32) {\n              if (have === 0) {\n                break inf_leave;\n              }\n              have--;\n              hold += input[next++] << bits;\n              bits += 8;\n            }\n            if ((hold & 65535) !== ((hold >>> 16) ^ 65535)) {\n              strm.msg = \"invalid stored block lengths\";\n              state.mode = BAD;\n              break;\n            }\n            state.length = hold & 65535;\n            hold = 0;\n            bits = 0;\n            state.mode = COPY_;\n            if (flush === Z_TREES) {\n              break inf_leave;\n            }\n          case COPY_:\n            state.mode = COPY;\n          case COPY:\n            copy = state.length;\n            if (copy) {\n              if (copy > have) {\n                copy = have;\n              }\n              if (copy > left) {\n                copy = left;\n              }\n              if (copy === 0) {\n                break inf_leave;\n              }\n              utils.arraySet(output, input, next, copy, put);\n              have -= copy;\n              next += copy;\n              left -= copy;\n              put += copy;\n              state.length -= copy;\n              break;\n            }\n            state.mode = TYPE;\n            break;\n          case TABLE:\n            while (bits < 14) {\n              if (have === 0) {\n                break inf_leave;\n              }\n              have--;\n              hold += input[next++] << bits;\n              bits += 8;\n            }\n            state.nlen = (hold & 31) + 257;\n            hold >>>= 5;\n            bits -= 5;\n            state.ndist = (hold & 31) + 1;\n            hold >>>= 5;\n            bits -= 5;\n            state.ncode = (hold & 15) + 4;\n            hold >>>= 4;\n            bits -= 4;\n            if (state.nlen > 286 || state.ndist > 30) {\n              strm.msg = \"too many length or distance symbols\";\n              state.mode = BAD;\n              break;\n            }\n            state.have = 0;\n            state.mode = LENLENS;\n          case LENLENS:\n            while (state.have < state.ncode) {\n              while (bits < 3) {\n                if (have === 0) {\n                  break inf_leave;\n                }\n                have--;\n                hold += input[next++] << bits;\n                bits += 8;\n              }\n              state.lens[order[state.have++]] = hold & 7;\n              hold >>>= 3;\n              bits -= 3;\n            }\n            while (state.have < 19) {\n              state.lens[order[state.have++]] = 0;\n            }\n            state.lencode = state.lendyn;\n            state.lenbits = 7;\n            opts = { bits: state.lenbits };\n            ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);\n            state.lenbits = opts.bits;\n            if (ret) {\n              strm.msg = \"invalid code lengths set\";\n              state.mode = BAD;\n              break;\n            }\n            state.have = 0;\n            state.mode = CODELENS;\n          case CODELENS:\n            while (state.have < state.nlen + state.ndist) {\n              for (;;) {\n                here = state.lencode[hold & ((1 << state.lenbits) - 1)];\n                here_bits = here >>> 24;\n                here_op = (here >>> 16) & 255;\n                here_val = here & 65535;\n                if (here_bits <= bits) {\n                  break;\n                }\n                if (have === 0) {\n                  break inf_leave;\n                }\n                have--;\n                hold += input[next++] << bits;\n                bits += 8;\n              }\n              if (here_val < 16) {\n                hold >>>= here_bits;\n                bits -= here_bits;\n                state.lens[state.have++] = here_val;\n              } else {\n                if (here_val === 16) {\n                  n = here_bits + 2;\n                  while (bits < n) {\n                    if (have === 0) {\n                      break inf_leave;\n                    }\n                    have--;\n                    hold += input[next++] << bits;\n                    bits += 8;\n                  }\n                  hold >>>= here_bits;\n                  bits -= here_bits;\n                  if (state.have === 0) {\n                    strm.msg = \"invalid bit length repeat\";\n                    state.mode = BAD;\n                    break;\n                  }\n                  len = state.lens[state.have - 1];\n                  copy = 3 + (hold & 3);\n                  hold >>>= 2;\n                  bits -= 2;\n                } else if (here_val === 17) {\n                  n = here_bits + 3;\n                  while (bits < n) {\n                    if (have === 0) {\n                      break inf_leave;\n                    }\n                    have--;\n                    hold += input[next++] << bits;\n                    bits += 8;\n                  }\n                  hold >>>= here_bits;\n                  bits -= here_bits;\n                  len = 0;\n                  copy = 3 + (hold & 7);\n                  hold >>>= 3;\n                  bits -= 3;\n                } else {\n                  n = here_bits + 7;\n                  while (bits < n) {\n                    if (have === 0) {\n                      break inf_leave;\n                    }\n                    have--;\n                    hold += input[next++] << bits;\n                    bits += 8;\n                  }\n                  hold >>>= here_bits;\n                  bits -= here_bits;\n                  len = 0;\n                  copy = 11 + (hold & 127);\n                  hold >>>= 7;\n                  bits -= 7;\n                }\n                if (state.have + copy > state.nlen + state.ndist) {\n                  strm.msg = \"invalid bit length repeat\";\n                  state.mode = BAD;\n                  break;\n                }\n                while (copy--) {\n                  state.lens[state.have++] = len;\n                }\n              }\n            }\n            if (state.mode === BAD) {\n              break;\n            }\n            if (state.lens[256] === 0) {\n              strm.msg = \"invalid code -- missing end-of-block\";\n              state.mode = BAD;\n              break;\n            }\n            state.lenbits = 9;\n            opts = { bits: state.lenbits };\n            ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);\n            state.lenbits = opts.bits;\n            if (ret) {\n              strm.msg = \"invalid literal/lengths set\";\n              state.mode = BAD;\n              break;\n            }\n            state.distbits = 6;\n            state.distcode = state.distdyn;\n            opts = { bits: state.distbits };\n            ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);\n            state.distbits = opts.bits;\n            if (ret) {\n              strm.msg = \"invalid distances set\";\n              state.mode = BAD;\n              break;\n            }\n            state.mode = LEN_;\n            if (flush === Z_TREES) {\n              break inf_leave;\n            }\n          case LEN_:\n            state.mode = LEN;\n          case LEN:\n            if (have >= 6 && left >= 258) {\n              strm.next_out = put;\n              strm.avail_out = left;\n              strm.next_in = next;\n              strm.avail_in = have;\n              state.hold = hold;\n              state.bits = bits;\n              inflate_fast(strm, _out);\n              put = strm.next_out;\n              output = strm.output;\n              left = strm.avail_out;\n              next = strm.next_in;\n              input = strm.input;\n              have = strm.avail_in;\n              hold = state.hold;\n              bits = state.bits;\n              if (state.mode === TYPE) {\n                state.back = -1;\n              }\n              break;\n            }\n            state.back = 0;\n            for (;;) {\n              here = state.lencode[hold & ((1 << state.lenbits) - 1)];\n              here_bits = here >>> 24;\n              here_op = (here >>> 16) & 255;\n              here_val = here & 65535;\n              if (here_bits <= bits) {\n                break;\n              }\n              if (have === 0) {\n                break inf_leave;\n              }\n              have--;\n              hold += input[next++] << bits;\n              bits += 8;\n            }\n            if (here_op && (here_op & 240) === 0) {\n              last_bits = here_bits;\n              last_op = here_op;\n              last_val = here_val;\n              for (;;) {\n                here = state.lencode[last_val + ((hold & ((1 << (last_bits + last_op)) - 1)) >> last_bits)];\n                here_bits = here >>> 24;\n                here_op = (here >>> 16) & 255;\n                here_val = here & 65535;\n                if (last_bits + here_bits <= bits) {\n                  break;\n                }\n                if (have === 0) {\n                  break inf_leave;\n                }\n                have--;\n                hold += input[next++] << bits;\n                bits += 8;\n              }\n              hold >>>= last_bits;\n              bits -= last_bits;\n              state.back += last_bits;\n            }\n            hold >>>= here_bits;\n            bits -= here_bits;\n            state.back += here_bits;\n            state.length = here_val;\n            if (here_op === 0) {\n              state.mode = LIT;\n              break;\n            }\n            if (here_op & 32) {\n              state.back = -1;\n              state.mode = TYPE;\n              break;\n            }\n            if (here_op & 64) {\n              strm.msg = \"invalid literal/length code\";\n              state.mode = BAD;\n              break;\n            }\n            state.extra = here_op & 15;\n            state.mode = LENEXT;\n          case LENEXT:\n            if (state.extra) {\n              n = state.extra;\n              while (bits < n) {\n                if (have === 0) {\n                  break inf_leave;\n                }\n                have--;\n                hold += input[next++] << bits;\n                bits += 8;\n              }\n              state.length += hold & ((1 << state.extra) - 1);\n              hold >>>= state.extra;\n              bits -= state.extra;\n              state.back += state.extra;\n            }\n            state.was = state.length;\n            state.mode = DIST;\n          case DIST:\n            for (;;) {\n              here = state.distcode[hold & ((1 << state.distbits) - 1)];\n              here_bits = here >>> 24;\n              here_op = (here >>> 16) & 255;\n              here_val = here & 65535;\n              if (here_bits <= bits) {\n                break;\n              }\n              if (have === 0) {\n                break inf_leave;\n              }\n              have--;\n              hold += input[next++] << bits;\n              bits += 8;\n            }\n            if ((here_op & 240) === 0) {\n              last_bits = here_bits;\n              last_op = here_op;\n              last_val = here_val;\n              for (;;) {\n                here = state.distcode[last_val + ((hold & ((1 << (last_bits + last_op)) - 1)) >> last_bits)];\n                here_bits = here >>> 24;\n                here_op = (here >>> 16) & 255;\n                here_val = here & 65535;\n                if (last_bits + here_bits <= bits) {\n                  break;\n                }\n                if (have === 0) {\n                  break inf_leave;\n                }\n                have--;\n                hold += input[next++] << bits;\n                bits += 8;\n              }\n              hold >>>= last_bits;\n              bits -= last_bits;\n              state.back += last_bits;\n            }\n            hold >>>= here_bits;\n            bits -= here_bits;\n            state.back += here_bits;\n            if (here_op & 64) {\n              strm.msg = \"invalid distance code\";\n              state.mode = BAD;\n              break;\n            }\n            state.offset = here_val;\n            state.extra = here_op & 15;\n            state.mode = DISTEXT;\n          case DISTEXT:\n            if (state.extra) {\n              n = state.extra;\n              while (bits < n) {\n                if (have === 0) {\n                  break inf_leave;\n                }\n                have--;\n                hold += input[next++] << bits;\n                bits += 8;\n              }\n              state.offset += hold & ((1 << state.extra) - 1);\n              hold >>>= state.extra;\n              bits -= state.extra;\n              state.back += state.extra;\n            }\n            if (state.offset > state.dmax) {\n              strm.msg = \"invalid distance too far back\";\n              state.mode = BAD;\n              break;\n            }\n            state.mode = MATCH;\n          case MATCH:\n            if (left === 0) {\n              break inf_leave;\n            }\n            copy = _out - left;\n            if (state.offset > copy) {\n              copy = state.offset - copy;\n              if (copy > state.whave) {\n                if (state.sane) {\n                  strm.msg = \"invalid distance too far back\";\n                  state.mode = BAD;\n                  break;\n                }\n              }\n              if (copy > state.wnext) {\n                copy -= state.wnext;\n                from = state.wsize - copy;\n              } else {\n                from = state.wnext - copy;\n              }\n              if (copy > state.length) {\n                copy = state.length;\n              }\n              from_source = state.window;\n            } else {\n              from_source = output;\n              from = put - state.offset;\n              copy = state.length;\n            }\n            if (copy > left) {\n              copy = left;\n            }\n            left -= copy;\n            state.length -= copy;\n            do {\n              output[put++] = from_source[from++];\n            } while (--copy);\n            if (state.length === 0) {\n              state.mode = LEN;\n            }\n            break;\n          case LIT:\n            if (left === 0) {\n              break inf_leave;\n            }\n            output[put++] = state.length;\n            left--;\n            state.mode = LEN;\n            break;\n          case CHECK:\n            if (state.wrap) {\n              while (bits < 32) {\n                if (have === 0) {\n                  break inf_leave;\n                }\n                have--;\n                hold |= input[next++] << bits;\n                bits += 8;\n              }\n              _out -= left;\n              strm.total_out += _out;\n              state.total += _out;\n              if (_out) {\n                strm.adler = state.check = state.flags\n                  ? crc32(state.check, output, _out, put - _out)\n                  : adler32(state.check, output, _out, put - _out);\n              }\n              _out = left;\n              if ((state.flags ? hold : zswap32(hold)) !== state.check) {\n                strm.msg = \"incorrect data check\";\n                state.mode = BAD;\n                break;\n              }\n              hold = 0;\n              bits = 0;\n            }\n            state.mode = LENGTH;\n          case LENGTH:\n            if (state.wrap && state.flags) {\n              while (bits < 32) {\n                if (have === 0) {\n                  break inf_leave;\n                }\n                have--;\n                hold += input[next++] << bits;\n                bits += 8;\n              }\n              if (hold !== (state.total & 4294967295)) {\n                strm.msg = \"incorrect length check\";\n                state.mode = BAD;\n                break;\n              }\n              hold = 0;\n              bits = 0;\n            }\n            state.mode = DONE;\n          case DONE:\n            ret = Z_STREAM_END;\n            break inf_leave;\n          case BAD:\n            ret = Z_DATA_ERROR;\n            break inf_leave;\n          case MEM:\n            return Z_MEM_ERROR;\n          case SYNC:\n          default:\n            return Z_STREAM_ERROR;\n        }\n      }\n      strm.next_out = put;\n      strm.avail_out = left;\n      strm.next_in = next;\n      strm.avail_in = have;\n      state.hold = hold;\n      state.bits = bits;\n      if (state.wsize || (_out !== strm.avail_out && state.mode < BAD && (state.mode < CHECK || flush !== Z_FINISH))) {\n        if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {\n          state.mode = MEM;\n          return Z_MEM_ERROR;\n        }\n      }\n      _in -= strm.avail_in;\n      _out -= strm.avail_out;\n      strm.total_in += _in;\n      strm.total_out += _out;\n      state.total += _out;\n      if (state.wrap && _out) {\n        strm.adler = state.check = state.flags\n          ? crc32(state.check, output, _out, strm.next_out - _out)\n          : adler32(state.check, output, _out, strm.next_out - _out);\n      }\n      strm.data_type =\n        state.bits +\n        (state.last ? 64 : 0) +\n        (state.mode === TYPE ? 128 : 0) +\n        (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);\n      if (((_in === 0 && _out === 0) || flush === Z_FINISH) && ret === Z_OK) {\n        ret = Z_BUF_ERROR;\n      }\n      return ret;\n    }\n    function inflateEnd(strm) {\n      if (!strm || !strm.state) {\n        return Z_STREAM_ERROR;\n      }\n      var state = strm.state;\n      if (state.window) {\n        state.window = null;\n      }\n      strm.state = null;\n      return Z_OK;\n    }\n    function inflateGetHeader(strm, head) {\n      var state;\n      if (!strm || !strm.state) {\n        return Z_STREAM_ERROR;\n      }\n      state = strm.state;\n      if ((state.wrap & 2) === 0) {\n        return Z_STREAM_ERROR;\n      }\n      state.head = head;\n      head.done = false;\n      return Z_OK;\n    }\n    function inflateSetDictionary(strm, dictionary) {\n      var dictLength = dictionary.length;\n      var state;\n      var dictid;\n      var ret;\n      if (!strm || !strm.state) {\n        return Z_STREAM_ERROR;\n      }\n      state = strm.state;\n      if (state.wrap !== 0 && state.mode !== DICT) {\n        return Z_STREAM_ERROR;\n      }\n      if (state.mode === DICT) {\n        dictid = 1;\n        dictid = adler32(dictid, dictionary, dictLength, 0);\n        if (dictid !== state.check) {\n          return Z_DATA_ERROR;\n        }\n      }\n      ret = updatewindow(strm, dictionary, dictLength, dictLength);\n      if (ret) {\n        state.mode = MEM;\n        return Z_MEM_ERROR;\n      }\n      state.havedict = 1;\n      return Z_OK;\n    }\n    exports.inflateReset = inflateReset;\n    exports.inflateReset2 = inflateReset2;\n    exports.inflateResetKeep = inflateResetKeep;\n    exports.inflateInit = inflateInit;\n    exports.inflateInit2 = inflateInit2;\n    exports.inflate = inflate;\n    exports.inflateEnd = inflateEnd;\n    exports.inflateGetHeader = inflateGetHeader;\n    exports.inflateSetDictionary = inflateSetDictionary;\n    exports.inflateInfo = \"pako inflate (from Nodeca project)\";\n  },\n});\n\n// node_modules/pako/lib/zlib/constants.js\nvar require_constants = __commonJS({\n  \"node_modules/pako/lib/zlib/constants.js\"(exports, module2) {\n    \"use strict\";\n    module2.exports = {\n      Z_NO_FLUSH: 0,\n      Z_PARTIAL_FLUSH: 1,\n      Z_SYNC_FLUSH: 2,\n      Z_FULL_FLUSH: 3,\n      Z_FINISH: 4,\n      Z_BLOCK: 5,\n      Z_TREES: 6,\n      Z_OK: 0,\n      Z_STREAM_END: 1,\n      Z_NEED_DICT: 2,\n      Z_ERRNO: -1,\n      Z_STREAM_ERROR: -2,\n      Z_DATA_ERROR: -3,\n      Z_BUF_ERROR: -5,\n      Z_NO_COMPRESSION: 0,\n      Z_BEST_SPEED: 1,\n      Z_BEST_COMPRESSION: 9,\n      Z_DEFAULT_COMPRESSION: -1,\n      Z_FILTERED: 1,\n      Z_HUFFMAN_ONLY: 2,\n      Z_RLE: 3,\n      Z_FIXED: 4,\n      Z_DEFAULT_STRATEGY: 0,\n      Z_BINARY: 0,\n      Z_TEXT: 1,\n      Z_UNKNOWN: 2,\n      Z_DEFLATED: 8,\n    };\n  },\n});\n\n// node_modules/browserify-zlib/lib/binding.js\nvar require_binding = __commonJS({\n  \"node_modules/browserify-zlib/lib/binding.js\"(exports) {\n    \"use strict\";\n    var assert = require(\"assert\");\n    var Zstream = require_zstream();\n    var zlib_deflate = require_deflate();\n    var zlib_inflate = require_inflate();\n    var constants = require_constants();\n    for (key in constants) {\n      exports[key] = constants[key];\n    }\n    var key;\n    exports.NONE = 0;\n    exports.DEFLATE = 1;\n    exports.INFLATE = 2;\n    exports.GZIP = 3;\n    exports.GUNZIP = 4;\n    exports.DEFLATERAW = 5;\n    exports.INFLATERAW = 6;\n    exports.UNZIP = 7;\n    var GZIP_HEADER_ID1 = 31;\n    var GZIP_HEADER_ID2 = 139;\n    function Zlib(mode) {\n      if (typeof mode !== \"number\" || mode < exports.DEFLATE || mode > exports.UNZIP) {\n        throw new TypeError(\"Bad argument\");\n      }\n      this.dictionary = null;\n      this.err = 0;\n      this.flush = 0;\n      this.init_done = false;\n      this.level = 0;\n      this.memLevel = 0;\n      this.mode = mode;\n      this.strategy = 0;\n      this.windowBits = 0;\n      this.write_in_progress = false;\n      this.pending_close = false;\n      this.gzip_id_bytes_read = 0;\n    }\n    Zlib.prototype.close = function () {\n      if (this.write_in_progress) {\n        this.pending_close = true;\n        return;\n      }\n      this.pending_close = false;\n      assert(this.init_done, \"close before init\");\n      assert(this.mode <= exports.UNZIP);\n      if (this.mode === exports.DEFLATE || this.mode === exports.GZIP || this.mode === exports.DEFLATERAW) {\n        zlib_deflate.deflateEnd(this.strm);\n      } else if (\n        this.mode === exports.INFLATE ||\n        this.mode === exports.GUNZIP ||\n        this.mode === exports.INFLATERAW ||\n        this.mode === exports.UNZIP\n      ) {\n        zlib_inflate.inflateEnd(this.strm);\n      }\n      this.mode = exports.NONE;\n      this.dictionary = null;\n    };\n    Zlib.prototype.write = function (flush, input, in_off, in_len, out, out_off, out_len) {\n      return this._write(true, flush, input, in_off, in_len, out, out_off, out_len);\n    };\n    Zlib.prototype.writeSync = function (flush, input, in_off, in_len, out, out_off, out_len) {\n      return this._write(false, flush, input, in_off, in_len, out, out_off, out_len);\n    };\n    Zlib.prototype._write = function (async, flush, input, in_off, in_len, out, out_off, out_len) {\n      assert.equal(arguments.length, 8);\n      assert(this.init_done, \"write before init\");\n      assert(this.mode !== exports.NONE, \"already finalized\");\n      assert.equal(false, this.write_in_progress, \"write already in progress\");\n      assert.equal(false, this.pending_close, \"close is pending\");\n      this.write_in_progress = true;\n      assert.equal(false, flush === void 0, \"must provide flush value\");\n      this.write_in_progress = true;\n      if (\n        flush !== exports.Z_NO_FLUSH &&\n        flush !== exports.Z_PARTIAL_FLUSH &&\n        flush !== exports.Z_SYNC_FLUSH &&\n        flush !== exports.Z_FULL_FLUSH &&\n        flush !== exports.Z_FINISH &&\n        flush !== exports.Z_BLOCK\n      ) {\n        throw new Error(\"Invalid flush value\");\n      }\n      if (input == null) {\n        input = Buffer.alloc(0);\n        in_len = 0;\n        in_off = 0;\n      }\n      this.strm.avail_in = in_len;\n      this.strm.input = input;\n      this.strm.next_in = in_off;\n      this.strm.avail_out = out_len;\n      this.strm.output = out;\n      this.strm.next_out = out_off;\n      this.flush = flush;\n      if (!async) {\n        this._process();\n        if (this._checkError()) {\n          return this._afterSync();\n        }\n        return;\n      }\n      var self = this;\n      process.nextTick(function () {\n        self._process();\n        self._after();\n      });\n      return this;\n    };\n    Zlib.prototype._afterSync = function () {\n      var avail_out = this.strm.avail_out;\n      var avail_in = this.strm.avail_in;\n      this.write_in_progress = false;\n      return [avail_in, avail_out];\n    };\n    Zlib.prototype._process = function () {\n      var next_expected_header_byte = null;\n      switch (this.mode) {\n        case exports.DEFLATE:\n        case exports.GZIP:\n        case exports.DEFLATERAW:\n          this.err = zlib_deflate.deflate(this.strm, this.flush);\n          break;\n        case exports.UNZIP:\n          if (this.strm.avail_in > 0) {\n            next_expected_header_byte = this.strm.next_in;\n          }\n          switch (this.gzip_id_bytes_read) {\n            case 0:\n              if (next_expected_header_byte === null) {\n                break;\n              }\n              if (this.strm.input[next_expected_header_byte] === GZIP_HEADER_ID1) {\n                this.gzip_id_bytes_read = 1;\n                next_expected_header_byte++;\n                if (this.strm.avail_in === 1) {\n                  break;\n                }\n              } else {\n                this.mode = exports.INFLATE;\n                break;\n              }\n            case 1:\n              if (next_expected_header_byte === null) {\n                break;\n              }\n              if (this.strm.input[next_expected_header_byte] === GZIP_HEADER_ID2) {\n                this.gzip_id_bytes_read = 2;\n                this.mode = exports.GUNZIP;\n              } else {\n                this.mode = exports.INFLATE;\n              }\n              break;\n            default:\n              throw new Error(\"invalid number of gzip magic number bytes read\");\n          }\n        case exports.INFLATE:\n        case exports.GUNZIP:\n        case exports.INFLATERAW:\n          this.err = zlib_inflate.inflate(this.strm, this.flush);\n          if (this.err === exports.Z_NEED_DICT && this.dictionary) {\n            this.err = zlib_inflate.inflateSetDictionary(this.strm, this.dictionary);\n            if (this.err === exports.Z_OK) {\n              this.err = zlib_inflate.inflate(this.strm, this.flush);\n            } else if (this.err === exports.Z_DATA_ERROR) {\n              this.err = exports.Z_NEED_DICT;\n            }\n          }\n          while (\n            this.strm.avail_in > 0 &&\n            this.mode === exports.GUNZIP &&\n            this.err === exports.Z_STREAM_END &&\n            this.strm.next_in[0] !== 0\n          ) {\n            this.reset();\n            this.err = zlib_inflate.inflate(this.strm, this.flush);\n          }\n          break;\n        default:\n          throw new Error(\"Unknown mode \" + this.mode);\n      }\n    };\n    Zlib.prototype._checkError = function () {\n      switch (this.err) {\n        case exports.Z_OK:\n        case exports.Z_BUF_ERROR:\n          if (this.strm.avail_out !== 0 && this.flush === exports.Z_FINISH) {\n            this._error(\"unexpected end of file\");\n            return false;\n          }\n          break;\n        case exports.Z_STREAM_END:\n          break;\n        case exports.Z_NEED_DICT:\n          if (this.dictionary == null) {\n            this._error(\"Missing dictionary\");\n          } else {\n            this._error(\"Bad dictionary\");\n          }\n          return false;\n        default:\n          this._error(\"Zlib error\");\n          return false;\n      }\n      return true;\n    };\n    Zlib.prototype._after = function () {\n      if (!this._checkError()) {\n        return;\n      }\n      var avail_out = this.strm.avail_out;\n      var avail_in = this.strm.avail_in;\n      this.write_in_progress = false;\n      this.callback(avail_in, avail_out);\n      if (this.pending_close) {\n        this.close();\n      }\n    };\n    Zlib.prototype._error = function (message) {\n      if (this.strm.msg) {\n        message = this.strm.msg;\n      }\n      this.onerror(message, this.err);\n      this.write_in_progress = false;\n      if (this.pending_close) {\n        this.close();\n      }\n    };\n    Zlib.prototype.init = function (windowBits, level, memLevel, strategy, dictionary) {\n      assert(\n        arguments.length === 4 || arguments.length === 5,\n        \"init(windowBits, level, memLevel, strategy, [dictionary])\",\n      );\n      assert(windowBits >= 8 && windowBits <= 15, \"invalid windowBits\");\n      assert(level >= -1 && level <= 9, \"invalid compression level\");\n      assert(memLevel >= 1 && memLevel <= 9, \"invalid memlevel\");\n      assert(\n        strategy === exports.Z_FILTERED ||\n          strategy === exports.Z_HUFFMAN_ONLY ||\n          strategy === exports.Z_RLE ||\n          strategy === exports.Z_FIXED ||\n          strategy === exports.Z_DEFAULT_STRATEGY,\n        \"invalid strategy\",\n      );\n      this._init(level, windowBits, memLevel, strategy, dictionary);\n      this._setDictionary();\n    };\n    Zlib.prototype.params = function () {\n      throw new Error(\"deflateParams Not supported\");\n    };\n    Zlib.prototype.reset = function () {\n      this._reset();\n      this._setDictionary();\n    };\n    Zlib.prototype._init = function (level, windowBits, memLevel, strategy, dictionary) {\n      this.level = level;\n      this.windowBits = windowBits;\n      this.memLevel = memLevel;\n      this.strategy = strategy;\n      this.flush = exports.Z_NO_FLUSH;\n      this.err = exports.Z_OK;\n      if (this.mode === exports.GZIP || this.mode === exports.GUNZIP) {\n        this.windowBits += 16;\n      }\n      if (this.mode === exports.UNZIP) {\n        this.windowBits += 32;\n      }\n      if (this.mode === exports.DEFLATERAW || this.mode === exports.INFLATERAW) {\n        this.windowBits = -1 * this.windowBits;\n      }\n      this.strm = new Zstream();\n      switch (this.mode) {\n        case exports.DEFLATE:\n        case exports.GZIP:\n        case exports.DEFLATERAW:\n          this.err = zlib_deflate.deflateInit2(\n            this.strm,\n            this.level,\n            exports.Z_DEFLATED,\n            this.windowBits,\n            this.memLevel,\n            this.strategy,\n          );\n          break;\n        case exports.INFLATE:\n        case exports.GUNZIP:\n        case exports.INFLATERAW:\n        case exports.UNZIP:\n          this.err = zlib_inflate.inflateInit2(this.strm, this.windowBits);\n          break;\n        default:\n          throw new Error(\"Unknown mode \" + this.mode);\n      }\n      if (this.err !== exports.Z_OK) {\n        this._error(\"Init error\");\n      }\n      this.dictionary = dictionary;\n      this.write_in_progress = false;\n      this.init_done = true;\n    };\n    Zlib.prototype._setDictionary = function () {\n      if (this.dictionary == null) {\n        return;\n      }\n      this.err = exports.Z_OK;\n      switch (this.mode) {\n        case exports.DEFLATE:\n        case exports.DEFLATERAW:\n          this.err = zlib_deflate.deflateSetDictionary(this.strm, this.dictionary);\n          break;\n        default:\n          break;\n      }\n      if (this.err !== exports.Z_OK) {\n        this._error(\"Failed to set dictionary\");\n      }\n    };\n    Zlib.prototype._reset = function () {\n      this.err = exports.Z_OK;\n      switch (this.mode) {\n        case exports.DEFLATE:\n        case exports.DEFLATERAW:\n        case exports.GZIP:\n          this.err = zlib_deflate.deflateReset(this.strm);\n          break;\n        case exports.INFLATE:\n        case exports.INFLATERAW:\n        case exports.GUNZIP:\n          this.err = zlib_inflate.inflateReset(this.strm);\n          break;\n        default:\n          break;\n      }\n      if (this.err !== exports.Z_OK) {\n        this._error(\"Failed to reset stream\");\n      }\n    };\n    exports.Zlib = Zlib;\n  },\n});\n\n// node_modules/browserify-zlib/lib/index.js\nvar require_lib = __commonJS({\n  \"node_modules/browserify-zlib/lib/index.js\"(exports) {\n    \"use strict\";\n    var Buffer2 = require(\"buffer\").Buffer;\n    var Transform = require(\"stream\").Transform;\n    var binding = require_binding();\n    var util = require(\"util\");\n    var assert = require(\"assert\").ok;\n    var kMaxLength = require(\"buffer\").kMaxLength;\n    var kRangeErrorMessage =\n      \"Cannot create final Buffer. It would be larger than 0x\" + kMaxLength.toString(16) + \" bytes\";\n    binding.Z_MIN_WINDOWBITS = 8;\n    binding.Z_MAX_WINDOWBITS = 15;\n    binding.Z_DEFAULT_WINDOWBITS = 15;\n    binding.Z_MIN_CHUNK = 64;\n    binding.Z_MAX_CHUNK = Infinity;\n    binding.Z_DEFAULT_CHUNK = 16 * 1024;\n    binding.Z_MIN_MEMLEVEL = 1;\n    binding.Z_MAX_MEMLEVEL = 9;\n    binding.Z_DEFAULT_MEMLEVEL = 8;\n    binding.Z_MIN_LEVEL = -1;\n    binding.Z_MAX_LEVEL = 9;\n    binding.Z_DEFAULT_LEVEL = binding.Z_DEFAULT_COMPRESSION;\n    var bkeys = Object.keys(binding);\n    for (bk = 0; bk < bkeys.length; bk++) {\n      bkey = bkeys[bk];\n      if (bkey.match(/^Z/)) {\n        Object.defineProperty(exports, bkey, {\n          enumerable: true,\n          value: binding[bkey],\n          writable: false,\n        });\n      }\n    }\n    var bkey;\n    var bk;\n    var codes = {\n      Z_OK: binding.Z_OK,\n      Z_STREAM_END: binding.Z_STREAM_END,\n      Z_NEED_DICT: binding.Z_NEED_DICT,\n      Z_ERRNO: binding.Z_ERRNO,\n      Z_STREAM_ERROR: binding.Z_STREAM_ERROR,\n      Z_DATA_ERROR: binding.Z_DATA_ERROR,\n      Z_MEM_ERROR: binding.Z_MEM_ERROR,\n      Z_BUF_ERROR: binding.Z_BUF_ERROR,\n      Z_VERSION_ERROR: binding.Z_VERSION_ERROR,\n    };\n    var ckeys = Object.keys(codes);\n    for (ck = 0; ck < ckeys.length; ck++) {\n      ckey = ckeys[ck];\n      codes[codes[ckey]] = ckey;\n    }\n    var ckey;\n    var ck;\n    Object.defineProperty(exports, \"codes\", {\n      enumerable: true,\n      value: Object.freeze(codes),\n      writable: false,\n    });\n    exports.constants = require_constants();\n    exports.Deflate = Deflate;\n    exports.Inflate = Inflate;\n    exports.Gzip = Gzip;\n    exports.Gunzip = Gunzip;\n    exports.DeflateRaw = DeflateRaw;\n    exports.InflateRaw = InflateRaw;\n    exports.Unzip = Unzip;\n    exports.createDeflate = function (o) {\n      return new Deflate(o);\n    };\n    exports.createInflate = function (o) {\n      return new Inflate(o);\n    };\n    exports.createDeflateRaw = function (o) {\n      return new DeflateRaw(o);\n    };\n    exports.createInflateRaw = function (o) {\n      return new InflateRaw(o);\n    };\n    exports.createGzip = function (o) {\n      return new Gzip(o);\n    };\n    exports.createGunzip = function (o) {\n      return new Gunzip(o);\n    };\n    exports.createUnzip = function (o) {\n      return new Unzip(o);\n    };\n    exports.deflate = function (buffer, opts, callback) {\n      if (typeof opts === \"function\") {\n        callback = opts;\n        opts = {};\n      }\n      return zlibBuffer(new Deflate(opts), buffer, callback);\n    };\n    exports.deflateSync = function (buffer, opts) {\n      return zlibBufferSync(new Deflate(opts), buffer);\n    };\n    exports.gzip = function (buffer, opts, callback) {\n      if (typeof opts === \"function\") {\n        callback = opts;\n        opts = {};\n      }\n      return zlibBuffer(new Gzip(opts), buffer, callback);\n    };\n    exports.gzipSync = function (buffer, opts) {\n      return zlibBufferSync(new Gzip(opts), buffer);\n    };\n    exports.deflateRaw = function (buffer, opts, callback) {\n      if (typeof opts === \"function\") {\n        callback = opts;\n        opts = {};\n      }\n      return zlibBuffer(new DeflateRaw(opts), buffer, callback);\n    };\n    exports.deflateRawSync = function (buffer, opts) {\n      return zlibBufferSync(new DeflateRaw(opts), buffer);\n    };\n    exports.unzip = function (buffer, opts, callback) {\n      if (typeof opts === \"function\") {\n        callback = opts;\n        opts = {};\n      }\n      return zlibBuffer(new Unzip(opts), buffer, callback);\n    };\n    exports.unzipSync = function (buffer, opts) {\n      return zlibBufferSync(new Unzip(opts), buffer);\n    };\n    exports.inflate = function (buffer, opts, callback) {\n      if (typeof opts === \"function\") {\n        callback = opts;\n        opts = {};\n      }\n      return zlibBuffer(new Inflate(opts), buffer, callback);\n    };\n    exports.inflateSync = function (buffer, opts) {\n      return zlibBufferSync(new Inflate(opts), buffer);\n    };\n    exports.gunzip = function (buffer, opts, callback) {\n      if (typeof opts === \"function\") {\n        callback = opts;\n        opts = {};\n      }\n      return zlibBuffer(new Gunzip(opts), buffer, callback);\n    };\n    exports.gunzipSync = function (buffer, opts) {\n      return zlibBufferSync(new Gunzip(opts), buffer);\n    };\n    exports.inflateRaw = function (buffer, opts, callback) {\n      if (typeof opts === \"function\") {\n        callback = opts;\n        opts = {};\n      }\n      return zlibBuffer(new InflateRaw(opts), buffer, callback);\n    };\n    exports.inflateRawSync = function (buffer, opts) {\n      return zlibBufferSync(new InflateRaw(opts), buffer);\n    };\n    function zlibBuffer(engine, buffer, callback) {\n      var buffers = [];\n      var nread = 0;\n      engine.on(\"error\", onError);\n      engine.on(\"end\", onEnd);\n      engine.end(buffer);\n      flow();\n      function flow() {\n        var chunk;\n        while (null !== (chunk = engine.read())) {\n          buffers.push(chunk);\n          nread += chunk.length;\n        }\n        engine.once(\"readable\", flow);\n      }\n      function onError(err) {\n        engine.removeListener(\"end\", onEnd);\n        engine.removeListener(\"readable\", flow);\n        callback(err);\n      }\n      function onEnd() {\n        var buf;\n        var err = null;\n        if (nread >= kMaxLength) {\n          err = new RangeError(kRangeErrorMessage);\n        } else {\n          buf = Buffer2.concat(buffers, nread);\n        }\n        buffers = [];\n        engine.close();\n        callback(err, buf);\n      }\n    }\n    function zlibBufferSync(engine, buffer) {\n      if (typeof buffer === \"string\") buffer = Buffer2.from(buffer);\n      if (!Buffer2.isBuffer(buffer)) throw new TypeError(\"Not a string or buffer\");\n      var flushFlag = engine._finishFlushFlag;\n      return engine._processChunk(buffer, flushFlag);\n    }\n    function Deflate(opts) {\n      if (!(this instanceof Deflate)) return new Deflate(opts);\n      Zlib.call(this, opts, binding.DEFLATE);\n    }\n    function Inflate(opts) {\n      if (!(this instanceof Inflate)) return new Inflate(opts);\n      Zlib.call(this, opts, binding.INFLATE);\n    }\n    function Gzip(opts) {\n      if (!(this instanceof Gzip)) return new Gzip(opts);\n      Zlib.call(this, opts, binding.GZIP);\n    }\n    function Gunzip(opts) {\n      if (!(this instanceof Gunzip)) return new Gunzip(opts);\n      Zlib.call(this, opts, binding.GUNZIP);\n    }\n    function DeflateRaw(opts) {\n      if (!(this instanceof DeflateRaw)) return new DeflateRaw(opts);\n      Zlib.call(this, opts, binding.DEFLATERAW);\n    }\n    function InflateRaw(opts) {\n      if (!(this instanceof InflateRaw)) return new InflateRaw(opts);\n      Zlib.call(this, opts, binding.INFLATERAW);\n    }\n    function Unzip(opts) {\n      if (!(this instanceof Unzip)) return new Unzip(opts);\n      Zlib.call(this, opts, binding.UNZIP);\n    }\n    function isValidFlushFlag(flag) {\n      return (\n        flag === binding.Z_NO_FLUSH ||\n        flag === binding.Z_PARTIAL_FLUSH ||\n        flag === binding.Z_SYNC_FLUSH ||\n        flag === binding.Z_FULL_FLUSH ||\n        flag === binding.Z_FINISH ||\n        flag === binding.Z_BLOCK\n      );\n    }\n    function Zlib(opts, mode) {\n      var _this = this;\n      this._opts = opts = opts || {};\n      this._chunkSize = opts.chunkSize || exports.Z_DEFAULT_CHUNK;\n      Transform.call(this, opts);\n      if (opts.flush && !isValidFlushFlag(opts.flush)) {\n        throw new Error(\"Invalid flush flag: \" + opts.flush);\n      }\n      if (opts.finishFlush && !isValidFlushFlag(opts.finishFlush)) {\n        throw new Error(\"Invalid flush flag: \" + opts.finishFlush);\n      }\n      this._flushFlag = opts.flush || binding.Z_NO_FLUSH;\n      this._finishFlushFlag = typeof opts.finishFlush !== \"undefined\" ? opts.finishFlush : binding.Z_FINISH;\n      if (opts.chunkSize) {\n        if (opts.chunkSize < exports.Z_MIN_CHUNK || opts.chunkSize > exports.Z_MAX_CHUNK) {\n          throw new Error(\"Invalid chunk size: \" + opts.chunkSize);\n        }\n      }\n      if (opts.windowBits) {\n        if (opts.windowBits < exports.Z_MIN_WINDOWBITS || opts.windowBits > exports.Z_MAX_WINDOWBITS) {\n          throw new Error(\"Invalid windowBits: \" + opts.windowBits);\n        }\n      }\n      if (opts.level) {\n        if (opts.level < exports.Z_MIN_LEVEL || opts.level > exports.Z_MAX_LEVEL) {\n          throw new Error(\"Invalid compression level: \" + opts.level);\n        }\n      }\n      if (opts.memLevel) {\n        if (opts.memLevel < exports.Z_MIN_MEMLEVEL || opts.memLevel > exports.Z_MAX_MEMLEVEL) {\n          throw new Error(\"Invalid memLevel: \" + opts.memLevel);\n        }\n      }\n      if (opts.strategy) {\n        if (\n          opts.strategy != exports.Z_FILTERED &&\n          opts.strategy != exports.Z_HUFFMAN_ONLY &&\n          opts.strategy != exports.Z_RLE &&\n          opts.strategy != exports.Z_FIXED &&\n          opts.strategy != exports.Z_DEFAULT_STRATEGY\n        ) {\n          throw new Error(\"Invalid strategy: \" + opts.strategy);\n        }\n      }\n      if (opts.dictionary) {\n        if (!Buffer2.isBuffer(opts.dictionary)) {\n          throw new Error(\"Invalid dictionary: it should be a Buffer instance\");\n        }\n      }\n      this._handle = new binding.Zlib(mode);\n      var self = this;\n      this._hadError = false;\n      this._handle.onerror = function (message, errno) {\n        _close(self);\n        self._hadError = true;\n        var error = new Error(message);\n        error.errno = errno;\n        error.code = exports.codes[errno];\n        self.emit(\"error\", error);\n      };\n      var level = exports.Z_DEFAULT_COMPRESSION;\n      if (typeof opts.level === \"number\") level = opts.level;\n      var strategy = exports.Z_DEFAULT_STRATEGY;\n      if (typeof opts.strategy === \"number\") strategy = opts.strategy;\n      this._handle.init(\n        opts.windowBits || exports.Z_DEFAULT_WINDOWBITS,\n        level,\n        opts.memLevel || exports.Z_DEFAULT_MEMLEVEL,\n        strategy,\n        opts.dictionary,\n      );\n      this._buffer = Buffer2.allocUnsafe(this._chunkSize);\n      this._offset = 0;\n      this._level = level;\n      this._strategy = strategy;\n      this.once(\"end\", this.close);\n      Object.defineProperty(this, \"_closed\", {\n        get: function () {\n          return !_this._handle;\n        },\n        configurable: true,\n        enumerable: true,\n      });\n    }\n    util.inherits(Zlib, Transform);\n    Zlib.prototype.params = function (level, strategy, callback) {\n      if (level < exports.Z_MIN_LEVEL || level > exports.Z_MAX_LEVEL) {\n        throw new RangeError(\"Invalid compression level: \" + level);\n      }\n      if (\n        strategy != exports.Z_FILTERED &&\n        strategy != exports.Z_HUFFMAN_ONLY &&\n        strategy != exports.Z_RLE &&\n        strategy != exports.Z_FIXED &&\n        strategy != exports.Z_DEFAULT_STRATEGY\n      ) {\n        throw new TypeError(\"Invalid strategy: \" + strategy);\n      }\n      if (this._level !== level || this._strategy !== strategy) {\n        var self = this;\n        this.flush(binding.Z_SYNC_FLUSH, function () {\n          assert(self._handle, \"zlib binding closed\");\n          self._handle.params(level, strategy);\n          if (!self._hadError) {\n            self._level = level;\n            self._strategy = strategy;\n            if (callback) callback();\n          }\n        });\n      } else {\n        process.nextTick(callback);\n      }\n    };\n    Zlib.prototype.reset = function () {\n      assert(this._handle, \"zlib binding closed\");\n      return this._handle.reset();\n    };\n    Zlib.prototype._flush = function (callback) {\n      this._transform(Buffer2.alloc(0), \"\", callback);\n    };\n    Zlib.prototype.flush = function (kind, callback) {\n      var _this2 = this;\n      var ws = this._writableState;\n      if (typeof kind === \"function\" || (kind === void 0 && !callback)) {\n        callback = kind;\n        kind = binding.Z_FULL_FLUSH;\n      }\n      if (ws.ended) {\n        if (callback) process.nextTick(callback);\n      } else if (ws.ending) {\n        if (callback) this.once(\"end\", callback);\n      } else if (ws.needDrain) {\n        if (callback) {\n          this.once(\"drain\", function () {\n            return _this2.flush(kind, callback);\n          });\n        }\n      } else {\n        this._flushFlag = kind;\n        this.write(Buffer2.alloc(0), \"\", callback);\n      }\n    };\n    Zlib.prototype.close = function (callback) {\n      _close(this, callback);\n      process.nextTick(emitCloseNT, this);\n    };\n    function _close(engine, callback) {\n      if (callback) process.nextTick(callback);\n      if (!engine._handle) return;\n      engine._handle.close();\n      engine._handle = null;\n    }\n    function emitCloseNT(self) {\n      self.emit(\"close\");\n    }\n    Zlib.prototype._transform = function (chunk, encoding, cb) {\n      var flushFlag;\n      var ws = this._writableState;\n      var ending = ws.ending || ws.ended;\n      var last = ending && (!chunk || ws.length === chunk.length);\n      if (chunk !== null && !Buffer2.isBuffer(chunk)) return cb(new Error(\"invalid input\"));\n      if (!this._handle) return cb(new Error(\"zlib binding closed\"));\n      if (last) flushFlag = this._finishFlushFlag;\n      else {\n        flushFlag = this._flushFlag;\n        if (chunk.length >= ws.length) {\n          this._flushFlag = this._opts.flush || binding.Z_NO_FLUSH;\n        }\n      }\n      this._processChunk(chunk, flushFlag, cb);\n    };\n    Zlib.prototype._processChunk = function (chunk, flushFlag, cb) {\n      var availInBefore = chunk && chunk.length;\n      var availOutBefore = this._chunkSize - this._offset;\n      var inOff = 0;\n      var self = this;\n      var async = typeof cb === \"function\";\n      if (!async) {\n        var buffers = [];\n        var nread = 0;\n        var error;\n        this.on(\"error\", function (er) {\n          error = er;\n        });\n        assert(this._handle, \"zlib binding closed\");\n        do {\n          var res = this._handle.writeSync(\n            flushFlag,\n            chunk,\n            inOff,\n            availInBefore,\n            this._buffer,\n            this._offset,\n            availOutBefore,\n          );\n        } while (!this._hadError && callback(res[0], res[1]));\n        if (this._hadError) {\n          throw error;\n        }\n        if (nread >= kMaxLength) {\n          _close(this);\n          throw new RangeError(kRangeErrorMessage);\n        }\n        var buf = Buffer2.concat(buffers, nread);\n        _close(this);\n        return buf;\n      }\n      assert(this._handle, \"zlib binding closed\");\n      var req = this._handle.write(flushFlag, chunk, inOff, availInBefore, this._buffer, this._offset, availOutBefore);\n      req.buffer = chunk;\n      req.callback = callback;\n      function callback(availInAfter, availOutAfter) {\n        if (this) {\n          this.buffer = null;\n          this.callback = null;\n        }\n        if (self._hadError) return;\n        var have = availOutBefore - availOutAfter;\n        assert(have >= 0, \"have should not go down\");\n        if (have > 0) {\n          var out = self._buffer.slice(self._offset, self._offset + have);\n          self._offset += have;\n          if (async) {\n            self.push(out);\n          } else {\n            buffers.push(out);\n            nread += out.length;\n          }\n        }\n        if (availOutAfter === 0 || self._offset >= self._chunkSize) {\n          availOutBefore = self._chunkSize;\n          self._offset = 0;\n          self._buffer = Buffer2.allocUnsafe(self._chunkSize);\n        }\n        if (availOutAfter === 0) {\n          inOff += availInBefore - availInAfter;\n          availInBefore = availInAfter;\n          if (!async) return true;\n          var newReq = self._handle.write(\n            flushFlag,\n            chunk,\n            inOff,\n            availInBefore,\n            self._buffer,\n            self._offset,\n            self._chunkSize,\n          );\n          newReq.callback = callback;\n          newReq.buffer = chunk;\n          return;\n        }\n        if (!async) return false;\n        cb();\n      }\n    };\n    util.inherits(Deflate, Zlib);\n    util.inherits(Inflate, Zlib);\n    util.inherits(Gzip, Zlib);\n    util.inherits(Gunzip, Zlib);\n    util.inherits(DeflateRaw, Zlib);\n    util.inherits(InflateRaw, Zlib);\n    util.inherits(Unzip, Zlib);\n  },\n});\n\n// zlib.js\nvar zlib_exports = require_lib();\nzlib_exports[Symbol.for(\"CommonJS\")] = 0;\nexport default zlib_exports;\n\nexport var {\n  Deflate,\n  Inflate,\n  Gzip,\n  Gunzip,\n  DeflateRaw,\n  InflateRaw,\n  Unzip,\n  createDeflate,\n  createInflate,\n  createDeflateRaw,\n  createInflateRaw,\n  createGzip,\n  createGunzip,\n  createUnzip,\n  deflate,\n  deflateSync,\n  gzip,\n  gzipSync,\n  deflateRaw,\n  deflateRawSync,\n  unzip,\n  unzipSync,\n  inflate,\n  inflateSync,\n  gunzip,\n  gunzipSync,\n  inflateRaw,\n  inflateRawSync,\n  constants,\n} = zlib_exports;\n"
  ],
  "mappings": ";;A//////DASA,IAAI,oBAAoB,OAAO;",
  "debugId": "457CEEE48B592D2964756e2164756e21",
  "names": []
}