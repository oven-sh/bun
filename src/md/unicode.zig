pub const FoldInfo = struct {
    codepoints: [3]u21,
    n_codepoints: u2,
};

/// A map entry represents either a single codepoint or a range.
/// Ranges are encoded as two consecutive entries:
///   (min_codepoint | range_start_flag), (max_codepoint | range_end_flag)
/// Single codepoints are stored as-is (no flags).
///
/// The corresponding data array is indexed in the same way: each physical
/// slot in the map array maps to `n_codepoints` consecutive entries in the
/// data array, at position `physical_index * n_codepoints`.
const MapEntry = u32;

const range_start_flag: u32 = 0x40000000;
const range_end_flag: u32 = 0x80000000;
const codepoint_mask: u32 = 0x00ffffff;

/// Extract the raw codepoint value from a map entry.
inline fn rawCodepoint(entry: MapEntry) u21 {
    return @intCast(entry & codepoint_mask);
}

/// Binary search over a sorted map of codepoints, supporting both single values
/// and ranges encoded with flag bits. Returns the physical index of the found
/// record (for ranges, the index of the range-start entry), or null on failure.
///
/// This is a direct port of md4c's `md_unicode_bsearch__`.
fn unicodeBsearch(codepoint: u21, map: []const MapEntry) ?usize {
    if (map.len == 0) return null;

    var beg: usize = 0;
    var end: usize = map.len - 1;

    while (beg <= end) {
        var pivot_beg: usize = (beg + end) / 2;
        var pivot_end: usize = pivot_beg;

        // If pivot points at a range-start entry, the range-end is the next entry.
        if (map[pivot_end] & range_start_flag != 0)
            pivot_end += 1;
        // If pivot points at a range-end entry, the range-start is the previous entry.
        if (map[pivot_beg] & range_end_flag != 0) {
            if (pivot_beg == 0) return null;
            pivot_beg -= 1;
        }

        const lo_cp = rawCodepoint(map[pivot_beg]);
        const hi_cp = rawCodepoint(map[pivot_end]);

        if (codepoint < lo_cp) {
            if (pivot_beg == 0) return null;
            end = pivot_beg - 1;
        } else if (codepoint > hi_cp) {
            beg = pivot_end + 1;
        } else {
            return pivot_beg;
        }
    }

    return null;
}

// ---------------------------------------------------------------------------
// Fold Map 1: single-codepoint mappings
// (generated by scripts/build_folding_map.py in md4c)
//
// Each physical slot in fold_map_1 corresponds to exactly 1 entry in
// fold_map_1_data (at the same index). Range pairs (start, end) occupy
// two physical slots and thus two data entries -- the start entry's data
// value is the base folded codepoint for the range.
// ---------------------------------------------------------------------------

const fold_map_1 = [_]MapEntry{
    range_start_flag | 0x0041, range_end_flag | 0x005a,
    0x00b5,                    range_start_flag | 0x00c0,
    range_end_flag | 0x00d6,   range_start_flag | 0x00d8,
    range_end_flag | 0x00de,   range_start_flag | 0x0100,
    range_end_flag | 0x012e,   range_start_flag | 0x0132,
    range_end_flag | 0x0136,   range_start_flag | 0x0139,
    range_end_flag | 0x0147,   range_start_flag | 0x014a,
    range_end_flag | 0x0176,   0x0178,
    range_start_flag | 0x0179, range_end_flag | 0x017d,
    0x017f,                    0x0181,
    0x0182,                    0x0184,
    0x0186,                    0x0187,
    0x0189,                    0x018a,
    0x018b,                    0x018e,
    0x018f,                    0x0190,
    0x0191,                    0x0193,
    0x0194,                    0x0196,
    0x0197,                    0x0198,
    0x019c,                    0x019d,
    0x019f,                    range_start_flag | 0x01a0,
    range_end_flag | 0x01a4,   0x01a6,
    0x01a7,                    0x01a9,
    0x01ac,                    0x01ae,
    0x01af,                    0x01b1,
    0x01b2,                    0x01b3,
    0x01b5,                    0x01b7,
    0x01b8,                    0x01bc,
    0x01c4,                    0x01c5,
    0x01c7,                    0x01c8,
    0x01ca,                    range_start_flag | 0x01cb,
    range_end_flag | 0x01db,   range_start_flag | 0x01de,
    range_end_flag | 0x01ee,   0x01f1,
    0x01f2,                    0x01f4,
    0x01f6,                    0x01f7,
    range_start_flag | 0x01f8, range_end_flag | 0x021e,
    0x0220,                    range_start_flag | 0x0222,
    range_end_flag | 0x0232,   0x023a,
    0x023b,                    0x023d,
    0x023e,                    0x0241,
    0x0243,                    0x0244,
    0x0245,                    range_start_flag | 0x0246,
    range_end_flag | 0x024e,   0x0345,
    0x0370,                    0x0372,
    0x0376,                    0x037f,
    0x0386,                    range_start_flag | 0x0388,
    range_end_flag | 0x038a,   0x038c,
    0x038e,                    0x038f,
    range_start_flag | 0x0391, range_end_flag | 0x03a1,
    range_start_flag | 0x03a3, range_end_flag | 0x03ab,
    0x03c2,                    0x03cf,
    0x03d0,                    0x03d1,
    0x03d5,                    0x03d6,
    range_start_flag | 0x03d8, range_end_flag | 0x03ee,
    0x03f0,                    0x03f1,
    0x03f4,                    0x03f5,
    0x03f7,                    0x03f9,
    0x03fa,                    range_start_flag | 0x03fd,
    range_end_flag | 0x03ff,   range_start_flag | 0x0400,
    range_end_flag | 0x040f,   range_start_flag | 0x0410,
    range_end_flag | 0x042f,   range_start_flag | 0x0460,
    range_end_flag | 0x0480,   range_start_flag | 0x048a,
    range_end_flag | 0x04be,   0x04c0,
    range_start_flag | 0x04c1, range_end_flag | 0x04cd,
    range_start_flag | 0x04d0, range_end_flag | 0x052e,
    range_start_flag | 0x0531, range_end_flag | 0x0556,
    range_start_flag | 0x10a0, range_end_flag | 0x10c5,
    0x10c7,                    0x10cd,
    range_start_flag | 0x13f8, range_end_flag | 0x13fd,
    0x1c80,                    0x1c81,
    0x1c82,                    0x1c83,
    0x1c84,                    0x1c85,
    0x1c86,                    0x1c87,
    0x1c88,                    range_start_flag | 0x1c90,
    range_end_flag | 0x1cba,   range_start_flag | 0x1cbd,
    range_end_flag | 0x1cbf,   range_start_flag | 0x1e00,
    range_end_flag | 0x1e94,   0x1e9b,
    range_start_flag | 0x1ea0, range_end_flag | 0x1efe,
    range_start_flag | 0x1f08, range_end_flag | 0x1f0f,
    range_start_flag | 0x1f18, range_end_flag | 0x1f1d,
    range_start_flag | 0x1f28, range_end_flag | 0x1f2f,
    range_start_flag | 0x1f38, range_end_flag | 0x1f3f,
    range_start_flag | 0x1f48, range_end_flag | 0x1f4d,
    0x1f59,                    0x1f5b,
    0x1f5d,                    0x1f5f,
    range_start_flag | 0x1f68, range_end_flag | 0x1f6f,
    0x1fb8,                    0x1fb9,
    0x1fba,                    0x1fbb,
    0x1fbe,                    range_start_flag | 0x1fc8,
    range_end_flag | 0x1fcb,   0x1fd8,
    0x1fd9,                    0x1fda,
    0x1fdb,                    0x1fe8,
    0x1fe9,                    0x1fea,
    0x1feb,                    0x1fec,
    0x1ff8,                    0x1ff9,
    0x1ffa,                    0x1ffb,
    0x2126,                    0x212a,
    0x212b,                    0x2132,
    range_start_flag | 0x2160, range_end_flag | 0x216f,
    0x2183,                    range_start_flag | 0x24b6,
    range_end_flag | 0x24cf,   range_start_flag | 0x2c00,
    range_end_flag | 0x2c2f,   0x2c60,
    0x2c62,                    0x2c63,
    0x2c64,                    range_start_flag | 0x2c67,
    range_end_flag | 0x2c6b,   0x2c6d,
    0x2c6e,                    0x2c6f,
    0x2c70,                    0x2c72,
    0x2c75,                    0x2c7e,
    0x2c7f,                    range_start_flag | 0x2c80,
    range_end_flag | 0x2ce2,   0x2ceb,
    0x2ced,                    0x2cf2,
    range_start_flag | 0xa640, range_end_flag | 0xa66c,
    range_start_flag | 0xa680, range_end_flag | 0xa69a,
    range_start_flag | 0xa722, range_end_flag | 0xa72e,
    range_start_flag | 0xa732, range_end_flag | 0xa76e,
    0xa779,                    0xa77b,
    0xa77d,                    range_start_flag | 0xa77e,
    range_end_flag | 0xa786,   0xa78b,
    0xa78d,                    0xa790,
    0xa792,                    range_start_flag | 0xa796,
    range_end_flag | 0xa7a8,   0xa7aa,
    0xa7ab,                    0xa7ac,
    0xa7ad,                    0xa7ae,
    0xa7b0,                    0xa7b1,
    0xa7b2,                    0xa7b3,
    range_start_flag | 0xa7b4, range_end_flag | 0xa7c2,
    0xa7c4,                    0xa7c5,
    0xa7c6,                    0xa7c7,
    0xa7c9,                    0xa7d0,
    0xa7d6,                    0xa7d8,
    0xa7f5,                    range_start_flag | 0xab70,
    range_end_flag | 0xabbf,   range_start_flag | 0xff21,
    range_end_flag | 0xff3a,   range_start_flag | 0x10400,
    range_end_flag | 0x10427,  range_start_flag | 0x104b0,
    range_end_flag | 0x104d3,  range_start_flag | 0x10570,
    range_end_flag | 0x1057a,  range_start_flag | 0x1057c,
    range_end_flag | 0x1058a,  range_start_flag | 0x1058c,
    range_end_flag | 0x10592,  0x10594,
    0x10595,                   range_start_flag | 0x10c80,
    range_end_flag | 0x10cb2,  range_start_flag | 0x118a0,
    range_end_flag | 0x118bf,  range_start_flag | 0x16e40,
    range_end_flag | 0x16e5f,  range_start_flag | 0x1e900,
    range_end_flag | 0x1e921,
};

// Data indexed by physical map index. Each physical map slot has one
// corresponding data entry. For range start/end pairs, the range-start
// slot's data value is the base folded codepoint; the range-end slot's
// data value is the end folded codepoint.
const fold_map_1_data = [_]u21{
    0x0061,  0x007a,  0x03bc,  0x00e0,  0x00f6,  0x00f8,  0x00fe,  0x0101,  0x012f,  0x0133,  0x0137,  0x013a,  0x0148,
    0x014b,  0x0177,  0x00ff,  0x017a,  0x017e,  0x0073,  0x0253,  0x0183,  0x0185,  0x0254,  0x0188,  0x0256,  0x0257,
    0x018c,  0x01dd,  0x0259,  0x025b,  0x0192,  0x0260,  0x0263,  0x0269,  0x0268,  0x0199,  0x026f,  0x0272,  0x0275,
    0x01a1,  0x01a5,  0x0280,  0x01a8,  0x0283,  0x01ad,  0x0288,  0x01b0,  0x028a,  0x028b,  0x01b4,  0x01b6,  0x0292,
    0x01b9,  0x01bd,  0x01c6,  0x01c6,  0x01c9,  0x01c9,  0x01cc,  0x01cc,  0x01dc,  0x01df,  0x01ef,  0x01f3,  0x01f3,
    0x01f5,  0x0195,  0x01bf,  0x01f9,  0x021f,  0x019e,  0x0223,  0x0233,  0x2c65,  0x023c,  0x019a,  0x2c66,  0x0242,
    0x0180,  0x0289,  0x028c,  0x0247,  0x024f,  0x03b9,  0x0371,  0x0373,  0x0377,  0x03f3,  0x03ac,  0x03ad,  0x03af,
    0x03cc,  0x03cd,  0x03ce,  0x03b1,  0x03c1,  0x03c3,  0x03cb,  0x03c3,  0x03d7,  0x03b2,  0x03b8,  0x03c6,  0x03c0,
    0x03d9,  0x03ef,  0x03ba,  0x03c1,  0x03b8,  0x03b5,  0x03f8,  0x03f2,  0x03fb,  0x037b,  0x037d,  0x0450,  0x045f,
    0x0430,  0x044f,  0x0461,  0x0481,  0x048b,  0x04bf,  0x04cf,  0x04c2,  0x04ce,  0x04d1,  0x052f,  0x0561,  0x0586,
    0x2d00,  0x2d25,  0x2d27,  0x2d2d,  0x13f0,  0x13f5,  0x0432,  0x0434,  0x043e,  0x0441,  0x0442,  0x0442,  0x044a,
    0x0463,  0xa64b,  0x10d0,  0x10fa,  0x10fd,  0x10ff,  0x1e01,  0x1e95,  0x1e61,  0x1ea1,  0x1eff,  0x1f00,  0x1f07,
    0x1f10,  0x1f15,  0x1f20,  0x1f27,  0x1f30,  0x1f37,  0x1f40,  0x1f45,  0x1f51,  0x1f53,  0x1f55,  0x1f57,  0x1f60,
    0x1f67,  0x1fb0,  0x1fb1,  0x1f70,  0x1f71,  0x03b9,  0x1f72,  0x1f75,  0x1fd0,  0x1fd1,  0x1f76,  0x1f77,  0x1fe0,
    0x1fe1,  0x1f7a,  0x1f7b,  0x1fe5,  0x1f78,  0x1f79,  0x1f7c,  0x1f7d,  0x03c9,  0x006b,  0x00e5,  0x214e,  0x2170,
    0x217f,  0x2184,  0x24d0,  0x24e9,  0x2c30,  0x2c5f,  0x2c61,  0x026b,  0x1d7d,  0x027d,  0x2c68,  0x2c6c,  0x0251,
    0x0271,  0x0250,  0x0252,  0x2c73,  0x2c76,  0x023f,  0x0240,  0x2c81,  0x2ce3,  0x2cec,  0x2cee,  0x2cf3,  0xa641,
    0xa66d,  0xa681,  0xa69b,  0xa723,  0xa72f,  0xa733,  0xa76f,  0xa77a,  0xa77c,  0x1d79,  0xa77f,  0xa787,  0xa78c,
    0x0265,  0xa791,  0xa793,  0xa797,  0xa7a9,  0x0266,  0x025c,  0x0261,  0x026c,  0x026a,  0x029e,  0x0287,  0x029d,
    0xab53,  0xa7b5,  0xa7c3,  0xa794,  0x0282,  0x1d8e,  0xa7c8,  0xa7ca,  0xa7d1,  0xa7d7,  0xa7d9,  0xa7f6,  0x13a0,
    0x13ef,  0xff41,  0xff5a,  0x10428, 0x1044f, 0x104d8, 0x104fb, 0x10597, 0x105a1, 0x105a3, 0x105b1, 0x105b3, 0x105b9,
    0x105bb, 0x105bc, 0x10cc0, 0x10cf2, 0x118c0, 0x118df, 0x16e60, 0x16e7f, 0x1e922, 0x1e943,
};

// ---------------------------------------------------------------------------
// Fold Map 2: two-codepoint mappings
// ---------------------------------------------------------------------------

const fold_map_2 = [_]MapEntry{
    0x00df,                    0x0130,                  0x0149,                    0x01f0,                    0x0587,                    0x1e96,                    0x1e97,                  0x1e98,                    0x1e99,
    0x1e9a,                    0x1e9e,                  0x1f50,                    range_start_flag | 0x1f80, range_end_flag | 0x1f87,   range_start_flag | 0x1f88, range_end_flag | 0x1f8f, range_start_flag | 0x1f90, range_end_flag | 0x1f97,
    range_start_flag | 0x1f98, range_end_flag | 0x1f9f, range_start_flag | 0x1fa0, range_end_flag | 0x1fa7,   range_start_flag | 0x1fa8, range_end_flag | 0x1faf,   0x1fb2,                  0x1fb3,                    0x1fb4,
    0x1fb6,                    0x1fbc,                  0x1fc2,                    0x1fc3,                    0x1fc4,                    0x1fc6,                    0x1fcc,                  0x1fd6,                    0x1fe4,
    0x1fe6,                    0x1ff2,                  0x1ff3,                    0x1ff4,                    0x1ff6,                    0x1ffc,                    0xfb00,                  0xfb01,                    0xfb02,
    0xfb05,                    0xfb06,                  0xfb13,                    0xfb14,                    0xfb15,                    0xfb16,                    0xfb17,
};

// Each physical map slot corresponds to 2 data entries.
const fold_map_2_data = [_]u21{
    0x0073, 0x0073, 0x0069, 0x0307, 0x02bc, 0x006e, 0x006a, 0x030c, 0x0565, 0x0582, 0x0068, 0x0331, 0x0074, 0x0308,
    0x0077, 0x030a, 0x0079, 0x030a, 0x0061, 0x02be, 0x0073, 0x0073, 0x03c5, 0x0313, 0x1f00, 0x03b9, 0x1f07, 0x03b9,
    0x1f00, 0x03b9, 0x1f07, 0x03b9, 0x1f20, 0x03b9, 0x1f27, 0x03b9, 0x1f20, 0x03b9, 0x1f27, 0x03b9, 0x1f60, 0x03b9,
    0x1f67, 0x03b9, 0x1f60, 0x03b9, 0x1f67, 0x03b9, 0x1f70, 0x03b9, 0x03b1, 0x03b9, 0x03ac, 0x03b9, 0x03b1, 0x0342,
    0x03b1, 0x03b9, 0x1f74, 0x03b9, 0x03b7, 0x03b9, 0x03ae, 0x03b9, 0x03b7, 0x0342, 0x03b7, 0x03b9, 0x03b9, 0x0342,
    0x03c1, 0x0313, 0x03c5, 0x0342, 0x1f7c, 0x03b9, 0x03c9, 0x03b9, 0x03ce, 0x03b9, 0x03c9, 0x0342, 0x03c9, 0x03b9,
    0x0066, 0x0066, 0x0066, 0x0069, 0x0066, 0x006c, 0x0073, 0x0074, 0x0073, 0x0074, 0x0574, 0x0576, 0x0574, 0x0565,
    0x0574, 0x056b, 0x057e, 0x0576, 0x0574, 0x056d,
};

// ---------------------------------------------------------------------------
// Fold Map 3: three-codepoint mappings
// ---------------------------------------------------------------------------

const fold_map_3 = [_]MapEntry{
    0x0390, 0x03b0, 0x1f52, 0x1f54, 0x1f56, 0x1fb7, 0x1fc7, 0x1fd2, 0x1fd3,
    0x1fd7, 0x1fe2, 0x1fe3, 0x1fe7, 0x1ff7, 0xfb03, 0xfb04,
};

// Each physical map slot corresponds to 3 data entries.
const fold_map_3_data = [_]u21{
    0x03b9, 0x0308, 0x0301, 0x03c5, 0x0308, 0x0301, 0x03c5, 0x0313, 0x0300, 0x03c5, 0x0313, 0x0301,
    0x03c5, 0x0313, 0x0342, 0x03b1, 0x0342, 0x03b9, 0x03b7, 0x0342, 0x03b9, 0x03b9, 0x0308, 0x0300,
    0x03b9, 0x0308, 0x0301, 0x03b9, 0x0308, 0x0342, 0x03c5, 0x0308, 0x0300, 0x03c5, 0x0308, 0x0301,
    0x03c5, 0x0308, 0x0342, 0x03c9, 0x0342, 0x03b9, 0x0066, 0x0066, 0x0069, 0x0066, 0x0066, 0x006c,
};

/// Get the Unicode case-folded version of a codepoint.
/// Returns the original codepoint wrapped in a FoldInfo if no folding is needed.
///
/// This is a direct port of md4c's `md_get_unicode_fold_info`.
pub fn caseFold(codepoint: u21) FoldInfo {
    // Fast path for ASCII characters.
    if (codepoint <= 0x7f) {
        if (codepoint >= 'A' and codepoint <= 'Z') {
            return .{ .codepoints = .{ codepoint + ('a' - 'A'), 0, 0 }, .n_codepoints = 1 };
        }
        return .{ .codepoints = .{ codepoint, 0, 0 }, .n_codepoints = 1 };
    }

    // Try each fold map in order: 1-codepoint, 2-codepoint, 3-codepoint.
    // The data arrays are indexed by: physical_index * n_codepoints.
    return caseFoldFromMap(1, &fold_map_1, &fold_map_1_data, codepoint) orelse
        caseFoldFromMap(2, &fold_map_2, &fold_map_2_data, codepoint) orelse
        caseFoldFromMap(3, &fold_map_3, &fold_map_3_data, codepoint) orelse
        // No mapping found -- map the codepoint to itself.
        .{ .codepoints = .{ codepoint, 0, 0 }, .n_codepoints = 1 };
}

fn caseFoldFromMap(
    comptime n: u2,
    map: []const MapEntry,
    data: []const u21,
    codepoint: u21,
) ?FoldInfo {
    const index = unicodeBsearch(codepoint, map) orelse return null;
    const data_offset = index * @as(usize, n);

    var result: FoldInfo = .{ .codepoints = .{ 0, 0, 0 }, .n_codepoints = n };

    // Copy the base codepoints from the data table.
    inline for (0..n) |k| {
        result.codepoints[k] = data[data_offset + k];
    }

    // If the codepoint doesn't exactly match the map entry, we are
    // inside a range and need to adjust the first output codepoint.
    const map_cp = rawCodepoint(map[index]);
    if (map_cp != codepoint) {
        if (map_cp + 1 == result.codepoints[0]) {
            // Alternating type of the range.
            // e.g. 0x0100->0x0101, 0x0101->0x0101, 0x0102->0x0103, ...
            result.codepoints[0] = codepoint + (if ((codepoint & 0x1) == (map_cp & 0x1)) @as(u21, 1) else @as(u21, 0));
        } else {
            // Range-to-range mapping: offset from range start.
            result.codepoints[0] += (codepoint - map_cp);
        }
    }

    return result;
}

// ---------------------------------------------------------------------------
// Tests
// ---------------------------------------------------------------------------

test "ASCII case folding" {
    // Uppercase ASCII letters fold to lowercase.
    const info_A = caseFold('A');
    try std.testing.expectEqual(@as(u21, 'a'), info_A.codepoints[0]);
    try std.testing.expectEqual(@as(u2, 1), info_A.n_codepoints);

    const info_Z = caseFold('Z');
    try std.testing.expectEqual(@as(u21, 'z'), info_Z.codepoints[0]);
    try std.testing.expectEqual(@as(u2, 1), info_Z.n_codepoints);

    // Lowercase ASCII letters map to themselves.
    const info_a = caseFold('a');
    try std.testing.expectEqual(@as(u21, 'a'), info_a.codepoints[0]);
    try std.testing.expectEqual(@as(u2, 1), info_a.n_codepoints);

    // Non-letter ASCII maps to itself.
    const info_0 = caseFold('0');
    try std.testing.expectEqual(@as(u21, '0'), info_0.codepoints[0]);
    try std.testing.expectEqual(@as(u2, 1), info_0.n_codepoints);
}

test "Latin-1 supplement case folding" {
    // U+00C0 LATIN CAPITAL LETTER A WITH GRAVE -> U+00E0
    const info = caseFold(0x00c0);
    try std.testing.expectEqual(@as(u21, 0x00e0), info.codepoints[0]);
    try std.testing.expectEqual(@as(u2, 1), info.n_codepoints);

    // U+00D6 LATIN CAPITAL LETTER O WITH DIAERESIS -> U+00F6
    const info2 = caseFold(0x00d6);
    try std.testing.expectEqual(@as(u21, 0x00f6), info2.codepoints[0]);
}

test "Greek case folding" {
    // U+0391 GREEK CAPITAL LETTER ALPHA -> U+03B1
    const info = caseFold(0x0391);
    try std.testing.expectEqual(@as(u21, 0x03b1), info.codepoints[0]);
    try std.testing.expectEqual(@as(u2, 1), info.n_codepoints);
}

test "Cyrillic case folding" {
    // U+0410 CYRILLIC CAPITAL LETTER A -> U+0430
    const info = caseFold(0x0410);
    try std.testing.expectEqual(@as(u21, 0x0430), info.codepoints[0]);
    try std.testing.expectEqual(@as(u2, 1), info.n_codepoints);
}

test "Two-codepoint fold: German eszett" {
    // U+00DF LATIN SMALL LETTER SHARP S -> 0x0073, 0x0073 ("ss")
    const info = caseFold(0x00df);
    try std.testing.expectEqual(@as(u2, 2), info.n_codepoints);
    try std.testing.expectEqual(@as(u21, 0x0073), info.codepoints[0]);
    try std.testing.expectEqual(@as(u21, 0x0073), info.codepoints[1]);
}

test "Two-codepoint fold: fi ligature" {
    // U+FB01 LATIN SMALL LIGATURE FI -> 0x0066, 0x0069 ("fi")
    const info = caseFold(0xfb01);
    try std.testing.expectEqual(@as(u2, 2), info.n_codepoints);
    try std.testing.expectEqual(@as(u21, 0x0066), info.codepoints[0]);
    try std.testing.expectEqual(@as(u21, 0x0069), info.codepoints[1]);
}

test "Three-codepoint fold: ffi ligature" {
    // U+FB03 LATIN SMALL LIGATURE FFI -> 0x0066, 0x0066, 0x0069 ("ffi")
    const info = caseFold(0xfb03);
    try std.testing.expectEqual(@as(u2, 3), info.n_codepoints);
    try std.testing.expectEqual(@as(u21, 0x0066), info.codepoints[0]);
    try std.testing.expectEqual(@as(u21, 0x0066), info.codepoints[1]);
    try std.testing.expectEqual(@as(u21, 0x0069), info.codepoints[2]);
}

test "Alternating range: Latin Extended-A" {
    // U+0100 LATIN CAPITAL LETTER A WITH MACRON -> U+0101
    const info1 = caseFold(0x0100);
    try std.testing.expectEqual(@as(u21, 0x0101), info1.codepoints[0]);

    // U+0101 is already lowercase -> maps to itself
    const info2 = caseFold(0x0101);
    try std.testing.expectEqual(@as(u21, 0x0101), info2.codepoints[0]);

    // U+0102 LATIN CAPITAL LETTER A WITH BREVE -> U+0103
    const info3 = caseFold(0x0102);
    try std.testing.expectEqual(@as(u21, 0x0103), info3.codepoints[0]);
}

test "No mapping: already lowercase or not a letter" {
    // Some arbitrary codepoint with no fold mapping
    const info = caseFold(0x0600);
    try std.testing.expectEqual(@as(u21, 0x0600), info.codepoints[0]);
    try std.testing.expectEqual(@as(u2, 1), info.n_codepoints);
}

test "Omega symbol" {
    // U+2126 OHM SIGN -> U+03C9 GREEK SMALL LETTER OMEGA
    const info = caseFold(0x2126);
    try std.testing.expectEqual(@as(u21, 0x03c9), info.codepoints[0]);
    try std.testing.expectEqual(@as(u2, 1), info.n_codepoints);
}

test "Fullwidth Latin uppercase" {
    // U+FF21 FULLWIDTH LATIN CAPITAL LETTER A -> U+FF41
    const info = caseFold(0xff21);
    try std.testing.expectEqual(@as(u21, 0xff41), info.codepoints[0]);
    try std.testing.expectEqual(@as(u2, 1), info.n_codepoints);
}

test "Deseret alphabet" {
    // U+10400 DESERET CAPITAL LETTER LONG I -> U+10428
    const info = caseFold(0x10400);
    try std.testing.expectEqual(@as(u21, 0x10428), info.codepoints[0]);
    try std.testing.expectEqual(@as(u2, 1), info.n_codepoints);
}

test "Micro sign" {
    // U+00B5 MICRO SIGN -> U+03BC GREEK SMALL LETTER MU
    const info = caseFold(0x00b5);
    try std.testing.expectEqual(@as(u21, 0x03bc), info.codepoints[0]);
    try std.testing.expectEqual(@as(u2, 1), info.n_codepoints);
}

test "Kelvin sign" {
    // U+212A KELVIN SIGN -> U+006B LATIN SMALL LETTER K
    const info = caseFold(0x212a);
    try std.testing.expectEqual(@as(u21, 0x006b), info.codepoints[0]);
    try std.testing.expectEqual(@as(u2, 1), info.n_codepoints);
}

const std = @import("std");
