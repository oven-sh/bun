//! Generator binary for grapheme property tables.
//! Invoked via `zig build generate-grapheme-tables`.
//! Queries uucode for each codepoint and outputs a Zig source file
//! containing the pre-generated 3-level lookup tables.
//!
//! The table stores only GraphemeBreakNoControl values (u5, 17 possible),
//! keeping the tables small through high deduplication.

/// Must be kept in sync with grapheme.zig's GraphemeBreakNoControl.
const GraphemeBreakNoControl = enum(u5) {
    other,
    prepend,
    regional_indicator,
    spacing_mark,
    l,
    v,
    t,
    lv,
    lvt,
    zwj,
    zwnj,
    extended_pictographic,
    emoji_modifier_base,
    emoji_modifier,
    indic_conjunct_break_extend,
    indic_conjunct_break_linker,
    indic_conjunct_break_consonant,
};

const Context = struct {
    pub fn get(_: @This(), cp: u21) !GraphemeBreakNoControl {
        if (cp > uucode.config.max_code_point) return .other;

        const uu_gb = uucode.get(.grapheme_break_no_control, cp);
        return @enumFromInt(@intFromEnum(uu_gb));
    }

    pub fn eql(_: @This(), a: GraphemeBreakNoControl, b: GraphemeBreakNoControl) bool {
        return a == b;
    }
};

pub fn main() !void {
    var arena_state = std.heap.ArenaAllocator.init(std.heap.page_allocator);
    defer arena_state.deinit();
    const alloc = arena_state.allocator();

    const gen: lut.Generator(GraphemeBreakNoControl, Context) = .{};

    const t = try gen.generate(alloc);
    defer alloc.free(t.stage1);
    defer alloc.free(t.stage2);
    defer alloc.free(t.stage3);

    var buf: [4096]u8 = undefined;
    var stdout_file = std.fs.File.stdout().writer(&buf);
    const stdout = &stdout_file.interface;

    // Write header
    try stdout.writeAll(
        \\//! This file is auto-generated by `zig build generate-grapheme-tables`.
        \\//! Do not edit manually.
        \\
        \\const grapheme = @import("./grapheme.zig");
        \\const GraphemeBreakNoControl = grapheme.GraphemeBreakNoControl;
        \\
        \\pub const table = grapheme.Tables(GraphemeBreakNoControl){
        \\    .stage1 = &stage1,
        \\    .stage2 = &stage2,
        \\    .stage3 = &stage3,
        \\};
        \\
        \\
    );

    // Write stage1
    try stdout.print("const stage1: [{}]u16 = .{{", .{t.stage1.len});
    for (t.stage1) |entry| try stdout.print("{},", .{entry});
    try stdout.writeAll("};\n\n");

    // Write stage2
    try stdout.print("const stage2: [{}]u8 = .{{", .{t.stage2.len});
    for (t.stage2) |entry| try stdout.print("{},", .{entry});
    try stdout.writeAll("};\n\n");

    // Write stage3
    try stdout.print("const stage3: [{}]GraphemeBreakNoControl = .{{", .{t.stage3.len});
    for (t.stage3) |entry| {
        try stdout.print(".{s},", .{@tagName(entry)});
    }
    try stdout.writeAll("};\n");
    try stdout.flush();
}

const lut = @import("./lut.zig");
const std = @import("std");
const uucode = @import("uucode");
