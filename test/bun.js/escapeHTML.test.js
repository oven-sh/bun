import { describe, it, expect } from "bun:test";
import { gcTick } from "./gc";
import { escapeHTML } from "bun";

describe("escapeHTML", () => {
  // The matrix of cases we need to test for:
  // 1. Works with short strings
  // 2. Works with long strings
  // 3. Works with latin1 strings
  // 4. Works with utf16 strings
  // 5. Works when the text to escape is somewhere in the middle
  // 6. Works when the text to escape is in the beginning
  // 7. Works when the text to escape is in the end
  // 8. Returns the same string when there's no need to escape
  it("works", () => {
    expect(escapeHTML("absolutely nothing to do here")).toBe(
      "absolutely nothing to do here",
    );
    expect(escapeHTML("<script>alert(1)</script>")).toBe(
      "&lt;script&gt;alert(1)&lt;/script&gt;",
    );
    expect(escapeHTML("<")).toBe("&lt;");
    expect(escapeHTML(">")).toBe("&gt;");
    expect(escapeHTML("&")).toBe("&amp;");
    expect(escapeHTML("'")).toBe("&#x27;");
    expect(escapeHTML('"')).toBe("&quot;");
    expect(escapeHTML("\n")).toBe("\n");
    expect(escapeHTML("\r")).toBe("\r");
    expect(escapeHTML("\t")).toBe("\t");
    expect(escapeHTML("\f")).toBe("\f");
    expect(escapeHTML("\v")).toBe("\v");
    expect(escapeHTML("\b")).toBe("\b");
    expect(escapeHTML("\u00A0")).toBe("\u00A0");
    expect(escapeHTML("<script>ab")).toBe("&lt;script&gt;ab");
    expect(escapeHTML("<script>")).toBe("&lt;script&gt;");
    expect(escapeHTML("<script><script>")).toBe("&lt;script&gt;&lt;script&gt;");

    expect(escapeHTML("lalala" + "<script>alert(1)</script>" + "lalala")).toBe(
      "lalala&lt;script&gt;alert(1)&lt;/script&gt;lalala",
    );

    expect(escapeHTML("<script>alert(1)</script>" + "lalala")).toBe(
      "&lt;script&gt;alert(1)&lt;/script&gt;lalala",
    );
    expect(escapeHTML("lalala" + "<script>alert(1)</script>")).toBe(
      "lalala" + "&lt;script&gt;alert(1)&lt;/script&gt;",
    );

    expect(escapeHTML("What does ðŸ˜Š mean?")).toBe("What does ðŸ˜Š mean?");
    const output = escapeHTML("<What does ðŸ˜Š");
    expect(output).toBe("&lt;What does ðŸ˜Š");
    expect(escapeHTML("<div>What does ðŸ˜Š mean in text?")).toBe(
      "&lt;div&gt;What does ðŸ˜Š mean in text?",
    );

    expect(
      escapeHTML(
        ("lalala" + "<script>alert(1)</script>" + "lalala").repeat(900),
      ),
    ).toBe("lalala&lt;script&gt;alert(1)&lt;/script&gt;lalala".repeat(900));
    expect(
      escapeHTML(("<script>alert(1)</script>" + "lalala").repeat(900)),
    ).toBe("&lt;script&gt;alert(1)&lt;/script&gt;lalala".repeat(900));
    expect(
      escapeHTML(("lalala" + "<script>alert(1)</script>").repeat(900)),
    ).toBe(("lalala" + "&lt;script&gt;alert(1)&lt;/script&gt;").repeat(900));

    // the positions of the unicode codepoint are important
    // our simd code for U16 is at 8 bytes, so we need to especially check the boundaries
    expect(
      escapeHTML("ðŸ˜Šlalala" + "<script>alert(1)</script>" + "lalala"),
    ).toBe("ðŸ˜Šlalala&lt;script&gt;alert(1)&lt;/script&gt;lalala");
    expect(escapeHTML("<script>ðŸ˜Šalert(1)</script>" + "lalala")).toBe(
      "&lt;script&gt;ðŸ˜Šalert(1)&lt;/script&gt;lalala",
    );
    expect(escapeHTML("<script>alert(1)ðŸ˜Š</script>" + "lalala")).toBe(
      "&lt;script&gt;alert(1)ðŸ˜Š&lt;/script&gt;lalala",
    );
    expect(escapeHTML("<script>alert(1)</script>" + "ðŸ˜Šlalala")).toBe(
      "&lt;script&gt;alert(1)&lt;/script&gt;ðŸ˜Šlalala",
    );
    expect(escapeHTML("<script>alert(1)</script>" + "lalðŸ˜Šala")).toBe(
      "&lt;script&gt;alert(1)&lt;/script&gt;lalðŸ˜Šala",
    );
    expect(
      escapeHTML("<script>alert(1)</script>" + "lalðŸ˜Šala".repeat(10)),
    ).toBe("&lt;script&gt;alert(1)&lt;/script&gt;" + "lalðŸ˜Šala".repeat(10));

    for (let i = 1; i < 10; i++)
      expect(escapeHTML("<script>alert(1)</script>" + "laðŸ˜Š".repeat(i))).toBe(
        "&lt;script&gt;alert(1)&lt;/script&gt;" + "laðŸ˜Š".repeat(i),
      );

    expect(escapeHTML("laðŸ˜Š" + "<script>alert(1)</script>")).toBe(
      "laðŸ˜Š" + "&lt;script&gt;alert(1)&lt;/script&gt;",
    );
    expect(
      escapeHTML(("lalala" + "<script>alert(1)</script>ðŸ˜Š").repeat(1)),
    ).toBe(("lalala" + "&lt;script&gt;alert(1)&lt;/script&gt;ðŸ˜Š").repeat(1));

    expect(escapeHTML("ðŸ˜Š".repeat(100))).toBe("ðŸ˜Š".repeat(100));
    expect(escapeHTML("ðŸ˜Š<".repeat(100))).toBe("ðŸ˜Š&lt;".repeat(100));
    expect(escapeHTML("<ðŸ˜Š>".repeat(100))).toBe("&lt;ðŸ˜Š&gt;".repeat(100));
    expect(escapeHTML("ðŸ˜Š")).toBe("ðŸ˜Š");
    expect(escapeHTML("ðŸ˜ŠðŸ˜Š")).toBe("ðŸ˜ŠðŸ˜Š");
    expect(escapeHTML("ðŸ˜Šlo")).toBe("ðŸ˜Šlo");
    expect(escapeHTML("loðŸ˜Š")).toBe("loðŸ˜Š");

    expect(escapeHTML(" ".repeat(32) + "ðŸ˜Š")).toBe(" ".repeat(32) + "ðŸ˜Š");
    expect(escapeHTML(" ".repeat(32) + "ðŸ˜ŠðŸ˜Š")).toBe(" ".repeat(32) + "ðŸ˜ŠðŸ˜Š");
    expect(escapeHTML(" ".repeat(32) + "ðŸ˜Šlo")).toBe(" ".repeat(32) + "ðŸ˜Šlo");
    expect(escapeHTML(" ".repeat(32) + "loðŸ˜Š")).toBe(" ".repeat(32) + "loðŸ˜Š");
  });
});
