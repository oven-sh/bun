import { expect, test, describe } from "bun:test";
import fg from "fast-glob";
import { Glob, GlobMatchOptions } from "bun";
import * as path from "path";

const bunGlobOpts = {
  followSymlinks: true,
  onlyFiles: false,
} satisfies GlobMatchOptions;

const fgOpts = {
  followSymbolicLinks: true,
  onlyFiles: false,
  // absolute: true,
} satisfies NonNullable<Parameters<typeof fg.glob>[1]>;

describe("glob.match", async () => {
  test("recursively search node_modules", async () => {
    const pattern = "**/node_modules/**/*.js";
    const glob = new Glob(pattern);
    const filepaths = await glob.match(bunGlobOpts);
    const fgFilepths = await fg.glob(pattern, fgOpts);

    // console.error(filepaths);
    expect(filepaths.length).toEqual(fgFilepths.length);

    const bunfilepaths = new Set(filepaths);
    for (const filepath of fgFilepths) {
      if (!bunfilepaths.has(filepath)) console.error("Missing:", filepath);
      expect(bunfilepaths.has(filepath)).toBeTrue();
    }
  });

  test("recursive search js files", async () => {
    const pattern = "**/*.js";
    const glob = new Glob(pattern);
    const filepaths = await glob.match(bunGlobOpts);
    const fgFilepths = await fg.glob(pattern, fgOpts);

    expect(filepaths.length).toEqual(fgFilepths.length);

    const bunfilepaths = new Set(filepaths);
    for (const filepath of fgFilepths) {
      if (!bunfilepaths.has(filepath)) console.error("Missing:", filepath);
      expect(bunfilepaths.has(filepath)).toBeTrue();
    }
  });

  test("recursive search ts files", async () => {
    const pattern = "**/*.ts";
    const glob = new Glob(pattern);
    const filepaths = await glob.match(bunGlobOpts);
    const fgFilepths = await fg.glob(pattern, fgOpts);

    expect(filepaths.length).toEqual(fgFilepths.length);

    const bunfilepaths = new Set(filepaths);
    for (const filepath of fgFilepths) {
      if (!bunfilepaths.has(filepath)) console.error("Missing:", filepath);
      expect(bunfilepaths.has(filepath)).toBeTrue();
    }
  });

  test("glob not freed before matching done", async () => {
    const promise = (async () => {
      const glob = new Glob("**/node_modules/**/*.js");
      const result = glob.match(bunGlobOpts);
      Bun.gc(true);
      const result2 = await result;
      return result2;
    })();
    Bun.gc(true);
    const values = await promise;
    Bun.gc(true);
  });
});

/**
 * These are the e2e tests from fast-glob, with some omitted because we don't support features like ignored patterns
 * The snapshots are generated by running fast-glob on them first
 */
describe("fast-glob e2e tests", async () => {
  const cwd = "test/js/bun/glob";

  // const regularPatterns = [
  //   "fixtures/*",
  //   "fixtures/**",
  //   "fixtures/**/*",

  //   "fixtures/*/nested",
  //   "fixtures/*/nested/*",
  //   "fixtures/*/nested/**",
  //   "fixtures/*/nested/**/*",
  //   "fixtures/**/nested/*",
  //   "fixtures/**/nested/**",
  //   "fixtures/**/nested/**/*",

  //   "fixtures/{first,second}",
  //   "fixtures/{first,second}/*",
  //   "fixtures/{first,second}/**",
  //   "fixtures/{first,second}/**/*",

  //   // The @(pattern) syntax not supported so we don't include that here
  //   // "@(fixtures)/{first,second}",
  //   // "@(fixtures)/{first,second}/*",

  //   "fixtures/*/{first,second}/*",
  //   "fixtures/*/{first,second}/*/{nested,file.md}",
  //   "fixtures/**/{first,second}/**",
  //   "fixtures/**/{first,second}/{nested,file.md}",
  //   "fixtures/**/{first,second}/**/{nested,file.md}",

  //   "fixtures/{first,second}/{nested,file.md}",
  //   "fixtures/{first,second}/*/nested/*",
  //   "fixtures/{first,second}/**/nested/**",

  //   "fixtures/*/{nested,file.md}/*",
  //   "fixtures/**/{nested,file.md}/*",

  //   "./fixtures/*",
  // ];

  // regularPatterns.forEach(pattern =>
  //   test(`patterns regular ${pattern}`, () => {
  //     // let entries = fg.globSync(pattern, { cwd });
  //     let entries = new Glob(pattern).matchSync({ cwd, followSymlinks: true });
  //     entries = entries.sort();
  //     expect(entries).toMatchSnapshot(pattern);
  //   }),
  // );

  // const regularCwdPatterns = [
  //   { pattern: "*", cwd: "fixtures" },
  //   { pattern: "**", cwd: "fixtures" },
  //   { pattern: "**/*", cwd: "fixtures" },

  //   { pattern: "*/nested", cwd: "fixtures" },
  //   { pattern: "*/nested/*", cwd: "fixtures" },
  //   { pattern: "*/nested/**", cwd: "fixtures" },
  //   { pattern: "*/nested/**/*", cwd: "fixtures" },
  //   { pattern: "**/nested/*", cwd: "fixtures" },
  //   { pattern: "**/nested/**", cwd: "fixtures" },
  //   { pattern: "**/nested/**/*", cwd: "fixtures" },

  //   { pattern: "{first,second}", cwd: "fixtures" },
  //   { pattern: "{first,second}/*", cwd: "fixtures" },
  //   { pattern: "{first,second}/**", cwd: "fixtures" },
  //   { pattern: "{first,second}/**/*", cwd: "fixtures" },

  //   { pattern: "*/{first,second}/*", cwd: "fixtures" },
  //   { pattern: "*/{first,second}/*/{nested,file.md}", cwd: "fixtures" },
  //   { pattern: "**/{first,second}/**", cwd: "fixtures" },
  //   { pattern: "**/{first,second}/{nested,file.md}", cwd: "fixtures" },
  //   { pattern: "**/{first,second}/**/{nested,file.md}", cwd: "fixtures" },

  //   { pattern: "{first,second}/{nested,file.md}", cwd: "fixtures" },
  //   { pattern: "{first,second}/*/nested/*", cwd: "fixtures" },
  //   { pattern: "{first,second}/**/nested/**", cwd: "fixtures" },

  //   { pattern: "*/{nested,file.md}/*", cwd: "fixtures" },
  //   { pattern: "**/{nested,file.md}/*", cwd: "fixtures" },
  // ];

  // regularCwdPatterns.forEach(({ pattern, cwd: secondHalf }) =>
  //   test(`patterns regular cwd ${pattern}`, () => {
  //     const testCwd = path.join(cwd, secondHalf);
  //     // let entries = fg.globSync(pattern, { cwd: testCwd });
  //     let entries = new Glob(pattern).matchSync({ cwd: testCwd, followSymlinks: true });
  //     entries = entries.sort();
  //     expect(entries).toMatchSnapshot(pattern);
  //   }),
  // );

  const regularRelativePatterns = [
    { pattern: "./*" },
    { pattern: "./*", cwd: "fixtures" },
    { pattern: "./**", cwd: "fixtures" },
    { pattern: "./**/*", cwd: "fixtures" },

    { pattern: "../*", cwd: "fixtures/first" },
    { pattern: "../**", cwd: "fixtures/first", issue: 47 },
    { pattern: "../../*", cwd: "fixtures/first/nested" },

    { pattern: "../{first,second}", cwd: "fixtures/first" },
    { pattern: "./../*", cwd: "fixtures/first" },
  ];

  regularRelativePatterns.forEach(({ pattern, cwd: secondHalf }) =>
    test(`patterns regular relative cwd ${pattern}`, () => {
      const testCwd = secondHalf ? path.join(cwd, secondHalf) : cwd;
      // let entries = fg.globSync(pattern, { cwd: testCwd });
      let entries = new Glob(pattern).matchSync({ cwd: testCwd, followSymlinks: true });
      entries = entries.sort();
      expect(entries).toMatchSnapshot(pattern);
    }),
  );
});

function returnError(cb: () => any): Error | undefined {
  try {
    cb();
  } catch (err) {
    // @ts-expect-error
    return err;
  }
  return undefined;
}
