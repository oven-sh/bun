# Yarn v1 Lockfile Parsing Strategy for Bun

## Parser Architecture

### High-Level Approach

```
Input: yarn.lock file
  ↓
Lexer: Tokenize into lines and structure
  ↓
Parser: Build entries with key-value pairs  
  ↓
Validator: Check integrity and completeness
  ↓
Output: Map<PackageSpec, Resolution>
```

### Data Structures

```typescript
// Main data structure
type YarnLockfile = Map<PackageKey, PackageResolution>;

type PackageKey = {
  name: string;
  versionRange: string;
};

type PackageResolution = {
  version: string;
  resolved: string;
  integrity: string;
  dependencies?: Map<string, string>;
  optionalDependencies?: Map<string, string>;
};
```

## Parsing Algorithm

### Phase 1: Line-by-Line Tokenization

```
1. Read file as UTF-8 text
2. Split by newlines
3. Skip header (first 3 lines):
   - "# THIS IS AN AUTOGENERATED FILE..."
   - "# yarn lockfile v1"
   - (blank line)
4. Process remaining lines
```

### Phase 2: Entry Detection

An entry starts when:
- Line has 0 indentation
- Line ends with `:` 
- Line is not empty

Example:
```yaml
"lodash@^4.17.21":    ← Entry start (indent=0, ends with :)
  version "4.17.21"   ← Property (indent=2)
  resolved "..."      ← Property (indent=2)
```

### Phase 3: Key Parsing

The key line can have multiple version specs separated by `, `:

```yaml
"@babel/parser@^7.1.0", "@babel/parser@^7.14.7", "@babel/parser@^7.28.4":
```

Parsing:
1. Remove trailing `:`
2. Split by `", "` (quote-comma-space-quote)
3. For each part:
   - Remove surrounding quotes
   - Split on `@` to separate package name and version range
   - Handle scoped packages: `@scope/name@range` → name=`@scope/name`, range=`range`

Edge cases:
- Package name without scope: `lodash@^4.17.21` → name=`lodash`, range=`^4.17.21`
- Scoped package: `@babel/core@^7.0.0` → name=`@babel/core`, range=`^7.0.0`
- Exact version: `wrappy@1` → name=`wrappy`, range=`1`

### Phase 4: Field Parsing

Fields are indented with 2 spaces:

```yaml
  version "7.28.4"
  resolved "https://..."
  integrity sha512-...
  dependencies:
    dep1 "^1.0.0"
    dep2 "^2.0.0"
```

Field types:
- **Simple fields**: `fieldname "value"`
  - version, resolved, integrity
- **Object fields**: `fieldname:` followed by indented children (4 spaces)
  - dependencies, optionalDependencies

Parsing:
1. Detect indent level (2 spaces = field, 4 spaces = dependency)
2. Extract field name (text before space or `:`)
3. Extract field value (text in quotes after space)
4. For dependencies, collect all 4-space-indented lines until next 2-space or 0-space line

### Phase 5: Dependency Parsing

```yaml
  dependencies:
    dep1 "^1.0.0"
    dep2 "^2.0.0"
```

1. Split dependency line by first space
2. Left side = package name (may include scope)
3. Right side = quoted version range
4. Store in Map

## Indentation Rules

```
0 spaces: Entry key
2 spaces: Field name/value
4 spaces: Dependency entry
```

Example:
```
"package@^1.0.0":         ← 0 spaces (entry)
  version "1.0.0"         ← 2 spaces (field)
  dependencies:           ← 2 spaces (field)
    foo "^2.0.0"          ← 4 spaces (dependency)
    bar "^3.0.0"          ← 4 spaces (dependency)
  integrity sha512-...    ← 2 spaces (field)
```

## Quote Handling

All strings are double-quoted. Need to handle:

1. **Simple strings**: `"lodash"`
2. **Version ranges**: `"^4.17.21"`
3. **URLs**: `"https://registry.yarnpkg.com/..."`
4. **OR ranges**: `"^3.0.0 || ^4.0.0"`
5. **Complex ranges**: `">=1.0.0 <2.0.0"`

**Important**: The quotes are part of the format, not escaped in any way. There are no escape sequences to handle in practice (URLs don't need escaping).

## Edge Cases to Handle

### 1. Multi-line Keys (Deduplication)

```yaml
"package@^1.0.0", "package@^1.1.0", "package@^1.2.0":
```

May span multiple lines if very long:
```yaml
"@babel/helper-plugin-utils@^7.0.0", "@babel/helper-plugin-utils@^7.10.4", 
"@babel/helper-plugin-utils@^7.12.13", "@babel/helper-plugin-utils@^7.14.5":
```

**Strategy**: Continue reading lines until we see a `:` at the end.

### 2. Empty Dependencies

Package with no dependencies:
```yaml
wrappy@1:
  version "1.0.2"
  resolved "https://..."
  integrity sha512-...
```

No `dependencies` field present.

### 3. Optional Dependencies

```yaml
package@^1.0.0:
  version "1.0.0"
  optionalDependencies:
    optional-dep "^1.0.0"
```

Same parsing as dependencies, different field name.

### 4. Version Ranges with Spaces

```yaml
  dependencies:
    js-tokens "^3.0.0 || ^4.0.0"
```

Keep the entire quoted value intact.

## Implementation Pseudocode

```python
def parse_yarn_lock(content: str) -> YarnLockfile:
    lines = content.split('\n')[3:]  # Skip header
    lockfile = {}
    i = 0
    
    while i < len(lines):
        line = lines[i]
        
        # Skip empty lines
        if not line.strip():
            i += 1
            continue
            
        # Entry start (0 indentation, ends with :)
        if line[0] != ' ' and line.rstrip().endswith(':'):
            # Parse key(s)
            key_line = line.rstrip()[:-1]  # Remove trailing :
            package_specs = parse_package_specs(key_line)
            
            # Parse fields
            i += 1
            entry = {}
            
            while i < len(lines) and lines[i].startswith('  '):
                field_line = lines[i]
                
                # Check indentation
                if field_line.startswith('    '):
                    # This is a dependency, should have been parsed
                    i += 1
                    continue
                    
                # Parse field
                field_line = field_line.strip()
                
                if field_line.endswith(':'):
                    # Object field (dependencies, optionalDependencies)
                    field_name = field_line[:-1]
                    deps = {}
                    i += 1
                    
                    # Read dependencies
                    while i < len(lines) and lines[i].startswith('    '):
                        dep_line = lines[i].strip()
                        dep_name, dep_range = parse_dependency(dep_line)
                        deps[dep_name] = dep_range
                        i += 1
                    
                    entry[field_name] = deps
                    continue
                else:
                    # Simple field
                    field_name, field_value = parse_field(field_line)
                    entry[field_name] = field_value
                    i += 1
            
            # Store entry for each package spec
            for spec in package_specs:
                lockfile[spec] = entry
        else:
            i += 1
    
    return lockfile

def parse_package_specs(key_line: str) -> List[PackageKey]:
    # Handle: "package@range", "package@range2", "package@range3"
    specs = []
    parts = key_line.split('", "')
    
    for part in parts:
        part = part.strip('"')
        name, range = split_package_spec(part)
        specs.append(PackageKey(name, range))
    
    return specs

def split_package_spec(spec: str) -> Tuple[str, str]:
    # Handle scoped packages: @scope/name@range
    if spec.startswith('@'):
        # Find second @
        second_at = spec.index('@', 1)
        name = spec[:second_at]
        range = spec[second_at + 1:]
    else:
        # Regular package: name@range
        parts = spec.split('@', 1)
        name = parts[0]
        range = parts[1] if len(parts) > 1 else ''
    
    return (name, range)

def parse_field(field_line: str) -> Tuple[str, str]:
    # Parse: fieldname "value"
    space_idx = field_line.index(' ')
    field_name = field_line[:space_idx]
    field_value = field_line[space_idx + 1:].strip('"')
    return (field_name, field_value)

def parse_dependency(dep_line: str) -> Tuple[str, str]:
    # Parse: package-name "version-range"
    space_idx = dep_line.index(' ')
    dep_name = dep_line[:space_idx]
    dep_range = dep_line[space_idx + 1:].strip('"')
    return (dep_name, dep_range)
```

## Testing Strategy

Test cases to implement:

1. **Simple package**: No dependencies, single version range
2. **Deduplicated package**: Multiple version ranges → same resolution
3. **Multiple versions**: Same package, different resolutions
4. **Scoped package**: `@scope/name` format
5. **Complex dependencies**: Package with 10+ dependencies
6. **OR dependencies**: `"^3.0.0 || ^4.0.0"`
7. **Workspace monorepo**: Ensure workspace packages are skipped
8. **Dev dependencies**: Treated same as regular dependencies
9. **Long key line**: Many deduplicated ranges
10. **Empty file**: Just header
11. **Malformed entries**: Missing fields (should error)

## Performance Considerations

For a typical lockfile (3,730 lines, ~315 packages):
- **Parsing**: Should be O(n) where n = lines
- **Memory**: Store ~315 entries × ~4 fields each = ~1,260 objects
- **Lookup**: O(1) hash map lookup by (name, range)

Optimizations:
- Use string interning for package names (many duplicates)
- Pre-allocate maps with estimated size
- Stream parsing for very large files (not needed for typical case)

## Integration with Bun

After parsing, Bun needs to:

1. **Build dependency graph**: 
   - Start from workspace package.json files
   - Resolve each dependency using lockfile
   - Recursively resolve transitive dependencies

2. **Install packages**:
   - Download from `resolved` URL
   - Verify with `integrity` hash
   - Extract to node_modules with hoisting

3. **Handle workspaces**:
   - Create symlinks for workspace packages (not in lockfile)
   - Use workspace package.json directly

4. **Update lockfile**:
   - When adding/removing dependencies
   - Preserve deduplication
   - Maintain alphabetical order of entries
